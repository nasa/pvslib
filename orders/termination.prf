(termination (terminating_no_ascending_seq 0 (terminating_no_ascending_seq-1 nil 3820686330 ("" (skeep) (("" (split 1) (("1" (flatten) (("1" (expand "terminating" -1) (("1" (skeep) (("1" (lemma "no_infinite_descending_sequence") (("1" (inst -1 "<") (("1" (assert) (("1" (expand "ascending?") (("1" (expand "descending?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "termination_by_wf" -2) (("1" (expand "member" -3) (("1" (inst -1 "x") (("1" (expand "member" 1) (("1" (skeep) (("1" (inst -1 "x(n)" "x(1+n)") (("1" (assert) (("1" (inst -1 "n") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "no_infinite_descending_sequence") (("2" (expand "terminating" 1 1) (("2" (expand "termination_by_wf" 1) (("2" (expand "empty?" -2) (("2" (inst 1 "LAMBDA(a,b:T): R(b,a)") (("1" (skeep) nil nil) ("2" (inst -1 "LAMBDA(a,b:T): R(b,a)") (("2" (assert) (("2" (expand "empty?" 2) (("2" (skeep 2) (("2" (inst -2 "x") (("2" (expand "member") (("2" (expand "ascending?") (("2" (expand "descending?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((terminating const-decl "bool" termination nil) (T formal-type-decl nil termination nil) (no_infinite_descending_sequence formula-decl nil well_foundedness nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (descending? const-decl "bool" monotone_sequences nil) (member const-decl "bool" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (sequence type-eq-decl nil sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (termination_by_wf const-decl "bool" termination nil) (empty? const-decl "bool" sets nil) (ascending? const-decl "bool" monotone_sequences nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (R skolem-const-decl "Relation" termination nil) (Relation type-eq-decl nil termination nil)) nil)) (terminating_well_founded_converse 0 (terminating_well_founded_converse-1 nil 3822132696 ("" (skeep) (("" (split) (("1" (flatten) (("1" (rewrite "terminating_no_ascending_seq") (("1" (rewrite "no_infinite_descending_sequence") (("1" (rewrite "descending_converse_eq_ascending") nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "terminating") (("2" (inst 1 "converse(R)") (("2" (expand "termination_by_wf") (("2" (skeep) (("2" (expand "converse") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((terminating_no_ascending_seq formula-decl nil termination nil) (T formal-type-decl nil termination nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Relation type-eq-decl nil termination nil) (descending_converse_eq_ascending formula-decl nil monotone_sequences nil) (converse const-decl "pred[[T2, T1]]" relation_defs nil) (pred type-eq-decl nil defined_types nil) (no_infinite_descending_sequence formula-decl nil well_foundedness nil) (terminating const-decl "bool" termination nil) (termination_by_wf const-decl "bool" termination nil) (well_founded? const-decl "bool" orders nil) (R skolem-const-decl "Relation" termination nil)) shostak)) (well_founded_terminating_converse 0 (well_founded_terminating_converse-1 nil 3822159616 ("" (skeep) (("" (lemma "terminating_well_founded_converse") (("" (inst -1 "converse(R)") (("" (case-replace "converse(converse(R))=R") (("1" (ground) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((terminating_well_founded_converse formula-decl nil termination nil) (= const-decl "[T, T -> boolean]" equalities nil) (converse const-decl "pred[[T2, T1]]" relation_defs nil) (pred type-eq-decl nil defined_types nil) (Relation type-eq-decl nil termination nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil termination nil)) shostak)) (loop_is_not_terminating 0 (loop_is_not_terminating-2 "" 3882370276 ("" (skeep) (("" (skeep) (("" (lemma "iterate_n_tc") (("" (inst?) (("" (assert) (("" (skeep) (("" (lemma "terminating_no_ascending_seq") (("" (inst -1 "R") (("" (assert) (("" (expand "empty?" -1) (("" (expand "member" -1) (("" (expand "ascending?" -1) (("" (expand "iterate_n" -2) (("" (lemma "ascending_iterate_n") (("" (expand "iterate_n" -1) (("" (lemma "iterate_n_fseq") (("" (inst?) (("" (expand "iterate_n" -1) (("" (inst?) (("" (assert) (("" (skeep) (("" (inst -4 "LAMBDA(i:nat): fseq(mod(i,n))") (("1" (skeep) (("1" (typepred "mod(n_1,n)") (("1" (typepred "mod(1+n_1,n)") (("1" (case "mod(1+n_1,n) = 0") (("1" (case "mod(n_1,n) = n-1") (("1" (replace -1) (("1" (replace -2) (("1" (typepred "fseq") (("1" (expand "ascending_n?" -1) (("1" (inst -1 "n-1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "euclid_nat") (("2" (inst -1 "1+n_1" "n") (("2" (skeep -1) (("2" (replace -1 -2) (("2" (assert) (("2" (lemma "mod_sum_pos") (("2" (inst -1 "r" "q" "n") (("2" (replace -1) (("2" (lemma "mod_lt_nat") (("2" (inst -1 "n" "r") (("2" (assert) (("2" (replace -1) (("2" (replace -4) (("2" (assert) (("2" (case "NOT n_1 = n*q-1") (("1" (assert) nil nil) ("2" (replace -1) (("2" (lemma "mod_sum_pos") (("2" (inst -1 "-1" "q" "n") (("2" (replace -1) (("2" (lemma "mod_neg") (("2" (inst -1 "1" "n") (("2" (assert) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (assert) (("1" (case "n=1") (("1" (assert) nil nil) ("2" (lemma "mod_even") (("2" (inst -1 "1" "n") (("2" (assert) (("2" (replace -3 2) (("2" (typepred "n") (("2" (assert) (("2" (lemma "mod_lt_nat") (("2" (inst -1 "n" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 2) (("2" (assert) (("2" (lemma "mod_lt_nat") (("2" (inst -1 "n" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "mod(n_1, n) = mod(1+n_1,n) - 1") (("1" (replace -1) (("1" (typepred "fseq") (("1" (expand "ascending_n?" -1) (("1" (inst -1 "mod(1 + n_1, n) - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "floor_val") (("2" (assert) (("2" (typepred "n") (("2" (lemma "mod_lt_nat") (("2" (lemma "mod_even") (("2" (lemma "mod_neg") (("2" (lemma "mod_sum_pos") (("2" (lemma "euclid_nat") (("2" (inst -1 "1+n_1" "n") (("2" (skeep -1) (("2" (replace -1) (("2" (case "n_1 = n*q + r - 1") (("1" (replace -1) (("1" (assert) (("1" (inst-cp -3 "r-1" "q" "n") (("1" (replace -4 1) (("1" (inst -3 "r" "q" "n") (("1" (replace -3) (("1" (lemma "mod_lt_nat") (("1" (inst-cp -1 "n" "r") (("1" (inst -1 "n" "r-1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (loop_is_not_terminating-1 nil 3820754916 ("" (skeep) (("" (skeep) (("" (lemma "iterate_n_tc") (("" (inst?) (("" (assert) (("" (skeep) (("" (lemma "terminating_no_ascending_seq") (("" (inst -1 "R") (("" (assert) (("" (expand "empty?" -1) (("" (expand "member" -1) (("" (expand "ascending?" -1) (("" (expand "iterate_n" -2) (("" (lemma "ascending_iterate_n") (("" (expand "iterate_n" -1) (("" (lemma "iterate_n_fseq") (("" (inst?) (("" (expand "iterate_n" -1) (("" (inst?) (("" (assert) (("" (skeep) (("" (inst -4 "LAMBDA(i:nat): fseq(mod(i,n))") (("1" (skeep) (("1" (typepred "mod(n_1,n)") (("1" (typepred "mod(1+n_1,n)") (("1" (case "mod(1+n_1,n) = 0") (("1" (case "mod(n_1,n) = n-1") (("1" (replace -1) (("1" (replace -2) (("1" (typepred "fseq") (("1" (expand "ascending_n?" -1) (("1" (inst -1 "n-1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "euclid_nat") (("2" (inst -1 "1+n_1" "n") (("2" (skeep -1) (("2" (replace -1 -2) (("2" (assert) (("2" (lemma "mod_sum_pos") (("2" (inst -1 "r" "q" "n") (("2" (replace -1) (("2" (lemma "mod_lt_nat") (("2" (inst -1 "n" "r") (("2" (assert) (("2" (replace -1) (("2" (replace -4) (("2" (assert) (("2" (case "NOT n_1 = n*q-1") (("1" (assert) nil nil) ("2" (replace -1) (("2" (lemma "mod_sum_pos") (("2" (inst -1 "-1" "q" "n") (("2" (replace -1) (("2" (lemma "mod_neg") (("2" (inst?) (("2" (assert) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (assert) (("1" (case "n=1") (("1" (assert) nil nil) ("2" (lemma "mod_even") (("2" (inst -1 "1" "n") (("2" (assert) (("2" (replace -3 2) (("2" (typepred "n") (("2" (assert) (("2" (lemma "mod_lt_nat") (("2" (inst -1 "n" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 2) (("2" (assert) (("2" (lemma "mod_lt_nat") (("2" (inst -1 "n" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "mod(n_1, n) = mod(1+n_1,n) - 1") (("1" (replace -1) (("1" (typepred "fseq") (("1" (expand "ascending_n?" -1) (("1" (inst -1 "mod(1 + n_1, n) - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "floor_val") (("2" (assert) (("2" (typepred "n") (("2" (lemma "mod_lt_nat") (("2" (lemma "mod_even") (("2" (lemma "mod_neg") (("2" (lemma "mod_sum_pos") (("2" (lemma "euclid_nat") (("2" (inst -1 "1+n_1" "n") (("2" (skeep -1) (("2" (replace -1) (("2" (case "n_1 = n*q + r - 1") (("1" (replace -1) (("1" (assert) (("1" (inst-cp -3 "r-1" "q" "n") (("1" (replace -4 1) (("1" (inst -3 "r" "q" "n") (("1" (replace -3) (("1" (lemma "mod_lt_nat") (("1" (inst-cp -1 "n" "r") (("1" (inst -1 "n" "r-1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (pred type-eq-decl nil defined_types nil) (Relation type-eq-decl nil termination nil) (empty? const-decl "bool" sets nil) (ascending? const-decl "bool" monotone_sequences nil) (ascending_iterate_n formula-decl nil monotone_sequences nil) (iterate_n_fseq formula-decl nil monotone_sequences nil) (nil application-judgement "below(m)" mod nil) (<= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (n skolem-const-decl "posnat" termination nil) (sequence type-eq-decl nil sequences nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (ascending_n? const-decl "bool" monotone_sequences nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (euclid_nat formula-decl nil euclidean_division nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (mod_lt_nat formula-decl nil mod nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_times_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (mod_even formula-decl nil mod nil) (nil application-judgement "above(n)" exp2 nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (mod_neg formula-decl nil mod nil) (mod_sum_pos formula-decl nil mod nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (r skolem-const-decl "mod(n)" termination nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (minus_int_is_int application-judgement "int" integers nil) (floor_val formula-decl nil floor_ceil nil) (n_1 skolem-const-decl "nat" termination nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (iterate_n const-decl "PRED[[T, T]]" relation_iterate nil) (member const-decl "bool" sets nil) (terminating_no_ascending_seq formula-decl nil termination nil) (iterate_n_tc formula-decl nil relation_iterate nil) (T formal-type-decl nil termination nil)) shostak)) (terminating_is_weakly_terminating 0 (terminating_is_weakly_terminating-1 nil 3821704964 ("" (skeep :preds? t) (("" (expand "weakly_terminating") (("" (expand "terminating") (("" (skeep -1) (("" (lemma "wf_induction[T,<]") (("" (inst -1 "normalizable(R)") (("" (split) (("1" (propax) nil nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "normalizable" 1) (("2" (flatten) (("2" (expand "normal" 1) (("2" (skeep -2) (("2" (expand "termination_by_wf") (("2" (inst? -3) (("2" (assert) (("2" (inst? -1) (("2" (assert) (("2" (expand "normalizable") (("2" (split -1) (("1" (inst 1 "tt") (("1" (expand "TC") (("1" (propax) nil nil)) nil)) nil) ("2" (skeep -1) (("2" (insteep) (("2" (expand "TC" 1) (("2" (flatten) (("2" (inst 2 "tt") (("2" (assert) (("2" (expand "TC" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((weakly_terminating const-decl "bool" termination nil) (normalizable const-decl "bool" termination nil) (Relation type-eq-decl nil termination nil) (normal const-decl "bool" termination nil) (termination_by_wf const-decl "bool" termination nil) (TC inductive-decl "bool" relations nil) (tt skolem-const-decl "T" termination nil) (R skolem-const-decl "(terminating)" termination nil) (wf_induction formula-decl nil wf_induction nil) (T formal-type-decl nil termination nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (terminating const-decl "bool" termination nil)) shostak)))
