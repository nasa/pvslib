/Applications/Aquamacs.app/Contents/MacOS/Aquamacs does not support X; running in terminal mode

Setting tmp dir to value of environment variable TMPDIR:
  /var/folders/p7/6vklcyns5r75r8lbh6q8kzsm0000gp/T/
; 
; caught STYLE-WARNING:
;   Call to PVS::NAME-EXPR? could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
; 
; caught STYLE-WARNING:
;   Call to PVS::NUMBER-EXPR? could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
; 
; caught STYLE-WARNING:
;   Call to PVS::UNARY-APPLICATION? could not be inlined because its source code
;   was not saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in
;   effect to save function definitions for inlining.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
; 
; caught STYLE-WARNING:
;   Call to PVS::FORALL-EXPR? could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.

; 
; caught STYLE-WARNING:
;   Call to PVS::EXISTS-EXPR? could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions

Defining METIT. WARNING: redefining PP* (#<STANDARD-CLASS PVS::RATIONAL-EXPR>) in DEFMETHOD
Loading prelude library NASALib/pvsio_utils (/Users/cmunoz/src/PVS.gitlab/nasalib/pvsio_utils/)

*** 
*** Processing nominal (21:51:22 12/24/2023)
*** Generated by proveit 7.1.0 (Nov 05, 2020)
*** 
Context changed to /Users/cmunoz/src/PVS.gitlab/nasalib/nominal/
Parsing top
top parsed in 0.00 seconds
Typechecking top
Parsing top_syntactic_nominal_unification
top_syntactic_nominal_unification parsed in 0.00 seconds
top_syntactic_nominal_unification is already parsed
Typechecking top_syntactic_nominal_unification
Parsing syntactic_nominalunif
syntactic_nominalunif parsed in 0.00 seconds
syntactic_nominalunif is already parsed
Typechecking syntactic_nominalunif
Parsing syntactic_substitution
syntactic_substitution parsed in 0.01 seconds
syntactic_substitution is already parsed
Typechecking syntactic_substitution
Parsing syntactic_alpha_equivalence
syntactic_alpha_equivalence parsed in 0.00 seconds
syntactic_alpha_equivalence is already parsed
Typechecking syntactic_alpha_equivalence
Parsing syntactic_freshness
syntactic_freshness parsed in 0.00 seconds
syntactic_freshness is already parsed
Typechecking syntactic_freshness
Parsing nominal_syntactic_term
nominal_syntactic_term parsed in 0.00 seconds
nominal_syntactic_term is already parsed
Typechecking nominal_syntactic_term
Wrote pvs file syntactic_term_adt
In DATATYPE theory syntactic_term_adt: No TCCs generated
In DATATYPE theory syntactic_term_adt_map: No TCCs generated
In DATATYPE theory syntactic_term_adt_reduce: No TCCs generated
syntactic_term typechecked in 0.55s: No TCCs generated
Parsing atoms
atoms parsed in 0.00 seconds
atoms is already parsed
Typechecking atoms

 LET/WHERE variable d at line 40, col 24 is given type
  atom from its value expression.

Parsing list_aux_equational_reasoning
list_aux_equational_reasoning parsed in 0.05 seconds
list_aux_equational_reasoning is already parsed
Typechecking list_aux_equational_reasoning
Parsing list_aux_equational_reasoning_nat
list_aux_equational_reasoning_nat parsed in 0.00 seconds
list_aux_equational_reasoning_nat is already parsed
Typechecking list_aux_equational_reasoning_nat
list_aux_equational_reasoning_nat typechecked in 0.10s: 16 TCCs, 0 proved, 11 subsumed, 5 unproved
Parsing list2set_props
list2set_props parsed in 0.00 seconds
list2set_props is already parsed
Typechecking list2set_props
list2set_props typechecked in 0.00s: No TCCs generated
Parsing more_list_props
more_list_props parsed in 0.04 seconds
more_list_props is already parsed
Typechecking more_list_props

 LET/WHERE variable m at line 78, col 9 is given type
  nat from its value expression.


 LET/WHERE variable n at line 78, col 12 is given type
  nat from its value expression.


 In declaration every_parm:
  added conversion restrict[T, (P), bool]
             
  to Q, converting
     [T -> bool]
  to [(P) -> bool]


 LET/WHERE variable FL at line 605, col 9 is given type
  list[T] from its value expression.

more_list_props typechecked in 0.72s: 128 TCCs, 0 proved, 32 subsumed, 96 unproved; 1 conversion; 3 msgs

 LET/WHERE variable x at line 71, col 13 is given type
  nat from its value expression.


 LET/WHERE variable x at line 82, col 13 is given type
  T from its value expression.


 LET/WHERE variable y at line 82, col 28 is given type
  T from its value expression.


 LET/WHERE variable lst1 at line 89, col 8 is given type
  list[T] from its value expression.


 LET/WHERE variable lst2 at line 90, col 5 is given type
  list[T] from its value expression.


 LET/WHERE variable y at line 96, col 13 is given type
  T from its value expression.


 LET/WHERE variable x at line 104, col 13 is given type
  T from its value expression.


 LET/WHERE variable lst at line 121, col 13 is given type
  list[T] from its value expression.


 LET/WHERE variable lst at line 131, col 13 is given type
  list[T] from its value expression.


 LET/WHERE variable y at line 153, col 13 is given type
  T from its value expression.


 LET/WHERE variable bool at line 155, col 12 is given type
  bool from its value expression.


 LET/WHERE variable n at line 155, col 18 is given type
  nat from its value expression.


 LET/WHERE variable x at line 180, col 6 is given type
  T from its value expression.


 LET/WHERE variable in_lst at line 181, col 7 is given type
  bool from its value expression.


 LET/WHERE variable n at line 181, col 15 is given type
  nat from its value expression.


 LET/WHERE variable new_coef at line 183, col 7 is given type
  list[nat] from its value expression.


 LET/WHERE variable new_lst1 at line 186, col 7 is given type
  list[T] from its value expression.


 LET/WHERE variable new_coef at line 187, col 7 is given type
  list[nat] from its value expression.


 LET/WHERE variable lst at line 199, col 13 is given type
  list[T] from its value expression.


 LET/WHERE variable x at line 210, col 12 is given type
  T from its value expression.


 LET/WHERE variable x at line 218, col 12 is given type
  T from its value expression.


 LET/WHERE variable lst at line 249, col 13 is given type
  list[T] from its value expression.


 LET/WHERE variable x at line 260, col 13 is given type
  T from its value expression.


 LET/WHERE variable lst_of_lsts1 at line 262, col 6 is given type
  list[list[T]] from its value expression.


 LET/WHERE variable lst_of_lsts2 at line 264, col 6 is given type
  list[list[T]] from its value expression.


 LET/WHERE variable y at line 273, col 13 is given type
  T from its value expression.


 LET/WHERE variable y at line 283, col 13 is given type
  T from its value expression.


 LET/WHERE variable lst at line 302, col 13 is given type
  list[T] from its value expression.


 LET/WHERE variable y at line 303, col 45 is given type
  T from its value expression.


 LET/WHERE variable lst at line 314, col 13 is given type
  list[T] from its value expression.


 LET/WHERE variable x at line 325, col 13 is given type
  T from its value expression.


 LET/WHERE variable y at line 325, col 28 is given type
  T from its value expression.


 LET/WHERE variable x at line 333, col 13 is given type
  T from its value expression.


 LET/WHERE variable row at line 355, col 6 is given type
  list[T] from its value expression.


 LET/WHERE variable row1 at line 356, col 3 is given type
  list[T] from its value expression.


 LET/WHERE variable row2 at line 356, col 9 is given type
  list[T] from its value expression.


 LET/WHERE variable cdr_matrix1 at line 357, col 3 is given type
  list[list[T]] from its value expression.


 LET/WHERE variable cdr_matrix2 at line 357, col 16 is given type
  list[list[T]] from its value expression.


 LET/WHERE variable y at line 367, col 13 is given type
  T from its value expression.


 LET/WHERE variable x at line 376, col 13 is given type
  T from its value expression.


 LET/WHERE variable n at line 376, col 27 is given type
  nat from its value expression.


 LET/WHERE variable new_lst at line 376, col 42 is given type
  list[T] from its value expression.


 LET/WHERE variable x1 at line 390, col 12 is given type
  T from its value expression.


 LET/WHERE variable n1 at line 390, col 28 is given type
  nat from its value expression.


 LET/WHERE variable x at line 401, col 13 is given type
  T from its value expression.


 LET/WHERE variable lst at line 431, col 13 is given type
  list[T] from its value expression.


 LET/WHERE variable x at line 445, col 13 is given type
  T from its value expression.


 LET/WHERE variable common at line 446, col 10 is given type
  bool from its value expression.


 LET/WHERE variable i at line 446, col 18 is given type
  nat from its value expression.


 LET/WHERE variable x at line 458, col 13 is given type
  T from its value expression.


 LET/WHERE variable common at line 459, col 10 is given type
  bool from its value expression.


 LET/WHERE variable i at line 459, col 18 is given type
  nat from its value expression.


 LET/WHERE variable x at line 488, col 13 is given type
  T from its value expression.


 LET/WHERE variable bool at line 675, col 9 is given type
  bool from its value expression.


 LET/WHERE variable ind at line 675, col 15 is given type
  nat from its value expression.


 LET/WHERE variable bool at line 680, col 9 is given type
  bool from its value expression.


 LET/WHERE variable ind at line 680, col 15 is given type
  nat from its value expression.


 LET/WHERE variable new_lst at line 692, col 9 is given type
  list[T] from its value expression.


 LET/WHERE variable new_coef at line 692, col 18 is given type
  list[nat] from its value expression.


 LET/WHERE variable new_lst at line 700, col 9 is given type
  list[T] from its value expression.


 LET/WHERE variable new_coef at line 700, col 18 is given type
  list[nat] from its value expression.


 LET/WHERE variable new_lst at line 704, col 9 is given type
  list[T] from its value expression.


 LET/WHERE variable new_coef at line 704, col 18 is given type
  list[nat] from its value expression.


 LET/WHERE variable lst1 at line 942, col 8 is given type
  list[T] from its value expression.


 LET/WHERE variable lst1 at line 955, col 8 is given type
  list[T] from its value expression.


 LET/WHERE variable lst2 at line 956, col 5 is given type
  list[T] from its value expression.


 LET/WHERE variable lst1 at line 968, col 9 is given type
  list[T] from its value expression.


 LET/WHERE variable lst2 at line 968, col 15 is given type
  list[T] from its value expression.


 LET/WHERE variable bool1 at line 1213, col 9 is given type
  bool from its value expression.


 LET/WHERE variable ind1 at line 1213, col 16 is given type
  nat from its value expression.


 LET/WHERE variable bool2 at line 1214, col 9 is given type
  bool from its value expression.


 LET/WHERE variable ind2 at line 1214, col 16 is given type
  nat from its value expression.


 LET/WHERE variable bool12 at line 1215, col 2 is given type
  bool from its value expression.


 LET/WHERE variable ind12 at line 1215, col 10 is given type
  nat from its value expression.


 LET/WHERE variable bool1 at line 1219, col 9 is given type
  bool from its value expression.


 LET/WHERE variable ind1 at line 1219, col 16 is given type
  nat from its value expression.


 LET/WHERE variable bool2 at line 1220, col 9 is given type
  bool from its value expression.


 LET/WHERE variable ind2 at line 1220, col 16 is given type
  nat from its value expression.


 LET/WHERE variable bool12 at line 1221, col 2 is given type
  bool from its value expression.


 LET/WHERE variable ind12 at line 1221, col 10 is given type
  nat from its value expression.


 LET/WHERE variable new_args at line 1227, col 9 is given type
  list[T] from its value expression.


 LET/WHERE variable new_coef at line 1227, col 19 is given type
  list[nat] from its value expression.


 In declaration mem_union_lst2set:
  added conversion extend[setof[T], finite_set[T], bool, FALSE]
             
  to list2set(lst_of_fin_sets), converting
     [finite_set[T] -> bool]
  to [setof[T] -> bool]

list_aux_equational_reasoning typechecked in 2.257s: 197 TCCs, 0 proved, 114 subsumed, 83 unproved; 1 conversion; 82 msgs
atoms typechecked in 2.503s: 4 TCCs, 0 proved, 1 subsumed, 3 unproved; 1 msg
nominal_term typechecked in 2.803s: 16 TCCs, 0 proved, 12 subsumed, 4 unproved

 LET/WHERE variable Nabla at line 125, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable b at line 125, col 14 is given type
  bool from its value expression.

syntactic_freshness typechecked in 4.241s: 9 TCCs, 0 proved, 3 subsumed, 6 unproved; 2 msgs

 LET/WHERE variable Delta at line 150, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable b at line 150, col 14 is given type
  bool from its value expression.

syntactic_alpha_equivalence typechecked in 4.514s: 10 TCCs, 0 proved, 3 subsumed, 7 unproved; 2 msgs

 LET/WHERE variable Nabla at line 172, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable b at line 172, col 15 is given type
  bool from its value expression.


 LET/WHERE variable Nabla at line 179, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable b at line 179, col 15 is given type
  bool from its value expression.


 LET/WHERE variable SOL at line 201, col 7 is given type
  [fresh_context, bool] from its value expression.


 LET/WHERE variable Nabla at line 208, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable b at line 208, col 15 is given type
  bool from its value expression.


 LET/WHERE variable NABLA at line 214, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable b at line 214, col 15 is given type
  bool from its value expression.


 LET/WHERE variable Delta at line 220, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable b at line 220, col 15 is given type
  bool from its value expression.

syntactic_substitution typechecked in 4.932s: 7 TCCs, 0 proved, 0 subsumed, 7 unproved; 11 msgs

 LET/WHERE variable SOL at line 66, col 17 is given type
  [fresh_context, bool] from its value expression.


 LET/WHERE variable Delta1 at line 70, col 21 is given type
  fresh_context from its value expression.


 LET/WHERE variable sig1 at line 70, col 29 is given type
  Subs_unif(t1, term1(s)) from its value expression.


 LET/WHERE variable b1 at line 70, col 35 is given type
  bool from its value expression.


 LET/WHERE variable Delta2 at line 71, col 13 is given type
  fresh_context from its value expression.


 LET/WHERE variable sig2 at line 71, col 21 is given type
  Subs_unif(Subs(sig1)(t2), Subs(sig1)(term2(s))) from its value expression.


 LET/WHERE variable b2 at line 71, col 27 is given type
  bool from its value expression.


 LET/WHERE variable Delta3 at line 72, col 13 is given type
  fresh_context from its value expression.


 LET/WHERE variable b3 at line 72, col 21 is given type
  bool from its value expression.


 LET/WHERE variable Delta1 at line 77, col 18 is given type
  fresh_context from its value expression.


 LET/WHERE variable sig at line 77, col 26 is given type
  Subs_unif(bd, ext((: (a, abstr(s)) :))(body(s))) from its value expression.


 LET/WHERE variable b1 at line 77, col 31 is given type
  bool from its value expression.


 LET/WHERE variable Delta2 at line 78, col 11 is given type
  fresh_context from its value expression.


 LET/WHERE variable b2 at line 78, col 19 is given type
  bool from its value expression.


 LET/WHERE variable Delta at line 87, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable sig at line 87, col 15 is given type
  Subs_unif(t, s) from its value expression.


 LET/WHERE variable b at line 87, col 20 is given type
  bool from its value expression.


 LET/WHERE variable Nabla at line 99, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable gamma at line 99, col 15 is given type
  Subs_unif(t, s) from its value expression.


 LET/WHERE variable b at line 99, col 22 is given type
  bool from its value expression.

nominalunif typechecked in 5.889s: 17 TCCs, 0 proved, 0 subsumed, 17 unproved; 20 msgs
top_syntactic_nominal_unification typechecked in 6.167s: No TCCs generated
Parsing top_C_nominal_unif_match
top_C_nominal_unif_match parsed in 0.00 seconds
top_C_nominal_unif_match is already parsed
Typechecking top_C_nominal_unif_match
Parsing C_nominalunif
C_nominalunif parsed in 0.03 seconds
C_nominalunif is already parsed
Typechecking C_nominalunif
Parsing C_substitution
C_substitution parsed in 0.02 seconds
C_substitution is already parsed
Typechecking C_substitution
Parsing C_alpha_equivalence
C_alpha_equivalence parsed in 0.00 seconds
C_alpha_equivalence is already parsed
Typechecking C_alpha_equivalence
Parsing C_freshness
C_freshness parsed in 0.00 seconds
C_freshness is already parsed
Typechecking C_freshness
Parsing C_nominal_term
C_nominal_term parsed in 0.01 seconds
C_nominal_term is already parsed
Typechecking C_nominal_term
Wrote pvs file C_term_adt
In DATATYPE theory C_term_adt: No TCCs generated
In DATATYPE theory C_term_adt_map: No TCCs generated
In DATATYPE theory C_term_adt_reduce: No TCCs generated
C_term typechecked in 0.67s: No TCCs generated
C_nominal_term typechecked in 0.51s: 26 TCCs, 0 proved, 19 subsumed, 7 unproved

 LET/WHERE variable Nabla at line 129, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable b at line 129, col 14 is given type
  bool from its value expression.

C_freshness typechecked in 1.405s: 11 TCCs, 0 proved, 4 subsumed, 7 unproved; 2 msgs
C_alpha_equivalence typechecked in 1.646s: 9 TCCs, 0 proved, 1 subsumed, 8 unproved

 LET/WHERE variable Nabla at line 185, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable b at line 185, col 15 is given type
  bool from its value expression.


 LET/WHERE variable Nabla at line 192, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable b at line 192, col 15 is given type
  bool from its value expression.


 LET/WHERE variable SOL at line 214, col 7 is given type
  [fresh_context, bool] from its value expression.


 LET/WHERE variable Nabla at line 221, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable b at line 221, col 15 is given type
  bool from its value expression.


 LET/WHERE variable NABLA at line 227, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable b at line 227, col 15 is given type
  bool from its value expression.


 LET/WHERE variable Delta at line 233, col 8 is given type
  fresh_context from its value expression.


 LET/WHERE variable b at line 233, col 15 is given type
  bool from its value expression.


 LET/WHERE variable t at line 347, col 9 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 LET/WHERE variable X at line 355, col 9 is given type
  variable from its value expression.

C_substitution typechecked in 2.52s: 16 TCCs, 0 proved, 2 subsumed, 14 unproved; 13 msgs

 LET/WHERE variable t at line 62, col 9 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 LET/WHERE variable s at line 63, col 7 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 LET/WHERE variable t at line 74, col 9 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 LET/WHERE variable s at line 75, col 7 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 LET/WHERE variable new_t at line 76, col 2 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 LET/WHERE variable new_s at line 77, col 2 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 LET/WHERE variable new_unif_prb at line 78, col 2 is given type
  (cons?[[C_term[atom, perm, variable, symbol, commutative_symbol],
          C_term[atom, perm, variable, symbol, commutative_symbol]]]) from its value expression.


 LET/WHERE variable t at line 86, col 9 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 LET/WHERE variable s at line 87, col 7 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 LET/WHERE variable new_t at line 88, col 2 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 LET/WHERE variable new_unif_prb at line 89, col 2 is given type
  (cons?[[C_term[atom, perm, variable, symbol, commutative_symbol],
          C_term[atom, perm, variable, symbol, commutative_symbol]]]) from its value expression.


 LET/WHERE variable t at line 98, col 9 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 LET/WHERE variable s at line 99, col 7 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 In declaration vars_lst:
  added conversion list2set[variable]
             
  to (: :), converting
     list[variable]
  to set[variable]


 LET/WHERE variable s at line 107, col 9 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 In declaration vars_rhs_lst:
  added conversion list2set[variable]
             
  to (: :), converting
     list[variable]
  to set[variable]


 LET/WHERE variable t at line 115, col 9 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 LET/WHERE variable fix_pnt_eq at line 123, col 9 is given type
  fix_pnt_eq_typ from its value expression.


 LET/WHERE variable perm at line 124, col 7 is given type
  perm from its value expression.


 LET/WHERE variable variable at line 125, col 2 is given type
  variable from its value expression.


 LET/WHERE variable t at line 126, col 2 is given type
  (susp?) from its value expression.


 LET/WHERE variable s at line 127, col 2 is given type
  (susp?) from its value expression.


 LET/WHERE variable unif_prb at line 128, col 2 is given type
  (cons?[[(susp?), (susp?)]]) from its value expression.


 LET/WHERE variable t at line 253, col 9 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 LET/WHERE variable s at line 253, col 34 is given type
  C_term[atom, perm, variable, symbol, commutative_symbol] from its value expression.


 LET/WHERE variable sigma1 at line 259, col 10 is given type
  (cons?) from its value expression.


 LET/WHERE variable Delta1 at line 261, col 4 is given type
  fresh_context from its value expression.


 LET/WHERE variable bool1 at line 261, col 12 is given type
  bool from its value expression.


 LET/WHERE variable new_Delta at line 263, col 3 is given type
  list[[atom, variable]] from its value expression.


 LET/WHERE variable new_sigma at line 265, col 3 is given type
  list[[variable, C_term[atom, perm, variable, symbol, commutative_symbol]]] from its value expression.


 LET/WHERE variable unif_prb_lst1 at line 268, col 3 is given type
  list[unif_prb_typ] from its value expression.


 LET/WHERE variable unif_prb_lst2 at line 269, col 3 is given type
  list[unif_prb_typ] from its value expression.


 LET/WHERE variable new_unif_prb_lst at line 270, col 3 is given type
  list[unif_prb_typ] from its value expression.


 LET/WHERE variable sigma1 at line 285, col 17 is given type
  (cons?) from its value expression.


 LET/WHERE variable Delta1 at line 286, col 9 is given type
  fresh_context from its value expression.


 LET/WHERE variable bool1 at line 286, col 17 is given type
  bool from its value expression.


 LET/WHERE variable new_Delta at line 287, col 5 is given type
  list[[atom, variable]] from its value expression.


 LET/WHERE variable new_sigma at line 288, col 5 is given type
  list[[variable, C_term[atom, perm, variable, symbol, commutative_symbol]]] from its value expression.


 LET/WHERE variable unif_prb_lst1 at line 289, col 5 is given type
  list[unif_prb_typ] from its value expression.


 LET/WHERE variable unif_prb_lst2 at line 290, col 10 is given type
  list[unif_prb_typ] from its value expression.


 LET/WHERE variable new_unif_prb_lst at line 291, col 10 is given type
  list[unif_prb_typ] from its value expression.


 LET/WHERE variable new_fix_pnt_eq at line 296, col 54 is given type
  (cons?[[list[[atom, atom]], variable]]) from its value expression.


 LET/WHERE variable new_fix_pnt_eq_lst at line 297, col 25 is given type
  list[[list[[atom, atom]], variable]] from its value expression.


 LET/WHERE variable unif_prb1 at line 307, col 26 is given type
  (cons?[[C_term[atom, perm, variable, symbol, commutative_symbol],
          C_term[atom, perm, variable, symbol, commutative_symbol]]]) from its value expression.


 LET/WHERE variable unif_prb2 at line 308, col 16 is given type
  (cons?[[C_term[atom, perm, variable, symbol, commutative_symbol],
          C_term[atom, perm, variable, symbol, commutative_symbol]]]) from its value expression.


 LET/WHERE variable new_unif_prb_lst at line 309, col 19 is given type
  list[[C_term[atom, perm, variable, symbol, commutative_symbol],
        C_term[atom, perm, variable, symbol, commutative_symbol]]] from its value expression.


 LET/WHERE variable new_unif_prb at line 314, col 37 is given type
  (cons?[[C_term[atom, perm, variable, symbol, commutative_symbol],
          C_term[atom, perm, variable, symbol, commutative_symbol]]]) from its value expression.


 LET/WHERE variable new_unif_prb_lst at line 315, col 25 is given type
  list[[C_term[atom, perm, variable, symbol, commutative_symbol],
        C_term[atom, perm, variable, symbol, commutative_symbol]]] from its value expression.


 LET/WHERE variable Delta1 at line 318, col 16 is given type
  fresh_context from its value expression.


 LET/WHERE variable bool1 at line 318, col 24 is given type
  bool from its value expression.


 LET/WHERE variable new_Delta at line 320, col 10 is given type
  list[[atom, variable]] from its value expression.


 LET/WHERE variable new_unif_prb at line 322, col 10 is given type
  (cons?[[C_term[atom, perm, variable, symbol, commutative_symbol],
          C_term[atom, perm, variable, symbol, commutative_symbol]]]) from its value expression.


 LET/WHERE variable new_unif_prb_lst at line 323, col 10 is given type
  list[[C_term[atom, perm, variable, symbol, commutative_symbol],
        C_term[atom, perm, variable, symbol, commutative_symbol]]] from its value expression.


 LET/WHERE variable new_unif_prb at line 331, col 18 is given type
  (cons?[[C_term[atom, perm, variable, symbol, commutative_symbol],
          C_term[atom, perm, variable, symbol, commutative_symbol]]]) from its value expression.


 LET/WHERE variable new_unif_prb_lst at line 332, col 15 is given type
  list[[C_term[atom, perm, variable, symbol, commutative_symbol],
        C_term[atom, perm, variable, symbol, commutative_symbol]]] from its value expression.


 LET/WHERE variable unif_prb1_1 at line 338, col 7 is given type
  (cons?[[C_term
              [atom, list[[atom, atom]], variable, symbol, commutative_symbol],
          C_term[atom, perm, variable, symbol, commutative_symbol]]]) from its value expression.


 LET/WHERE variable unif_prb2_2 at line 339, col 7 is given type
  (cons?[[C_term
              [atom, list[[atom, atom]], variable, symbol, commutative_symbol],
          C_term[atom, perm, variable, symbol, commutative_symbol]]]) from its value expression.


 LET/WHERE variable unif_prb_lst1 at line 340, col 7 is given type
  list[[C_term[atom, list[[atom, atom]], variable, symbol, commutative_symbol],
        C_term[atom, perm, variable, symbol, commutative_symbol]]] from its value expression.


 LET/WHERE variable sol1 at line 341, col 7 is given type
  list[nominal_sol_typ] from its value expression.


 LET/WHERE variable unif_prb1_2 at line 343, col 7 is given type
  (cons?[[C_term
              [atom, list[[atom, atom]], variable, symbol, commutative_symbol],
          C_term[atom, perm, variable, symbol, commutative_symbol]]]) from its value expression.


 LET/WHERE variable unif_prb2_1 at line 344, col 7 is given type
  (cons?[[C_term
              [atom, list[[atom, atom]], variable, symbol, commutative_symbol],
          C_term[atom, perm, variable, symbol, commutative_symbol]]]) from its value expression.


 LET/WHERE variable unif_prb_lst2 at line 345, col 7 is given type
  list[[C_term[atom, list[[atom, atom]], variable, symbol, commutative_symbol],
        C_term[atom, perm, variable, symbol, commutative_symbol]]] from its value expression.


 LET/WHERE variable sol2 at line 346, col 7 is given type
  list[nominal_sol_typ] from its value expression.

Creating the cartesian product generates 108 elements for
  ((charstring bytestring (null?) set[variable])
   (charstring bytestring (null?)) (charstring bytestring (null?))
   ((cons?[[C_term[atom, perm, variable, symbol, commutative_symbol],
            C_term[atom, perm, variable, symbol, commutative_symbol]]]))
   (charstring bytestring (null?)))
debugger invoked on a SIMPLE-CONDITION in thread
#<THREAD "main thread" RUNNING {700F72A623}>:
  Too big - check this
