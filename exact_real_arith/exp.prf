(exp (cauchy_exp_series_TCC1 0 (cauchy_exp_series_TCC1-1 nil 3394181533 ("" (skosimp*) (("" (expand "cauchy_nzreal?") (("" (inst + "factorial(n!1)") (("" (rewrite "int_lemma") nil nil)) nil)) nil)) nil) ((cauchy_nzreal? const-decl "bool" cauchy nil) (int_lemma formula-decl nil int nil) (factorial def-decl "posnat" factorial ints) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (cauchy_exp_series subtype "int.cauchy_int(factorial.factorial(exp.n))" "cauchy_nzreal"))) (cauchy_exp_series_TCC2 0 (cauchy_exp_series_TCC2-1 nil 3394181533 ("" (skosimp*) (("" (lemma "inv_lemma" ("nzx" "factorial(n!1)" "nzcx" "cauchy_int(factorial(n!1))")) (("" (rewrite "int_lemma") (("" (expand "cauchy_nnreal?") (("" (inst + "1 / factorial(n!1)") nil nil)) nil)) nil)) nil)) nil) ((nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (factorial def-decl "posnat" factorial ints) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (cauchy_int const-decl "cauchy_real" int nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (inv_lemma formula-decl nil inv nil) (cauchy_nnreal? const-decl "bool" cauchy nil) (nnreal type-eq-decl nil real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (int_lemma formula-decl nil int nil)) nil (cauchy_exp_series subtype "inv.cauchy_inv(int.cauchy_int(factorial.factorial(exp.n)))" "cauchy_nnreal"))) (exp_series_lemma 0 (exp_series_lemma-2 "" 3790106106 ("" (skosimp) (("" (expand "cauchy_exp_series") (("" (expand "expT") (("" (case-replace "n!1=0") (("1" (expand "factorial") (("1" (lemma "inv_lemma" ("nzx" "1" "nzcx" "cauchy_int(1)")) (("1" (rewrite "int_lemma") nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "inv_lemma" ("nzx" "factorial(n!1)" "nzcx" "cauchy_int(factorial(n!1))")) (("2" (rewrite "int_lemma") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_exp_series const-decl "cauchy_nnreal" exp nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (cauchy_int const-decl "cauchy_real" int nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (inv_lemma formula-decl nil inv nil) (int_lemma formula-decl nil int nil) (factorial def-decl "posnat" factorial ints) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (expt_1i formula-decl nil exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (expT const-decl "real" ln_exp_series_alt lnexp)) shostak) (exp_series_lemma-1 nil 3394181733 ("" (skosimp) (("" (expand "cauchy_exp_series") (("" (expand "expT") (("" (case-replace "n!1=0") (("1" (expand "factorial") (("1" (lemma "inv_lemma" ("nzx" "1" "nzcx" "cauchy_int(1)")) (("1" (rewrite "int_lemma") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "expt_1i") (("2" (lemma "inv_lemma" ("nzx" "factorial(n!1)" "nzcx" "cauchy_int(factorial(n!1))")) (("2" (rewrite "int_lemma") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_exp_series const-decl "cauchy_nnreal" exp nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (cauchy_int const-decl "cauchy_real" int nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (inv_lemma formula-decl nil inv nil) (int_lemma formula-decl nil int nil) (factorial def-decl "posnat" factorial ints) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (expt_1i formula-decl nil exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (expT const-decl "real" ln_exp_series_alt lnexp)) shostak)) (exp_estimate_lemma_TCC1 0 (exp_estimate_lemma_TCC1-1 nil 3394181533 ("" (skosimp) (("" (expand "cauchys_real?") (("" (lemma "exp_series_lemma") (("" (inst + "expT(1)") (("" (expand "cauchys_prop") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((cauchys_real? const-decl "bool" sum nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (expT const-decl "real" ln_exp_series_alt lnexp) (cauchys_prop const-decl "bool" sum nil) (exp_series_lemma formula-decl nil exp nil)) nil (exp_estimate_lemma subtype "exp.cauchy_exp_series" "cauchys_real"))) (exp_estimate_lemma 0 (exp_estimate_lemma-2 "" 3790106106 ("" (skosimp) (("" (expand "exp_estimate") (("" (lemma "powerseries_lemma" ("x" "x!1" "xs" "expT(1)" "cx" "cx!1" "cxs" "cauchy_exp_series" "m" "n!1")) (("" (replace -2) (("" (lemma "exp_series_lemma") (("" (replace -1) (("" (expand "powerseries") (("" (case-replace "(LAMBDA (i:nat):
                          IF i = 0 THEN expT(1)(i)
                          ELSE expT(1)(i) * x!1 ^ i
                          ENDIF)=expT(x!1)") (("" (hide-all-but 1) (("" (apply-extensionality :hide? t) (("" (expand "expT") (("" (case-replace "x!2=0") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((exp_estimate const-decl "real" ln_exp_series_alt lnexp) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_times_real_is_real application-judgement "real" reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (expt_1i formula-decl nil exponentiation nil) (powerseries const-decl "real" powerseries nil) (exp_series_lemma formula-decl nil exp nil) (powerseries_lemma formula-decl nil powerseries nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_nnreal? const-decl "bool" cauchy nil) (cauchy_nnreal nonempty-type-eq-decl nil cauchy nil) (cauchy_exp_series const-decl "cauchy_nnreal" exp nil) (expT const-decl "real" ln_exp_series_alt lnexp)) shostak) (exp_estimate_lemma-1 nil 3394181952 ("" (skosimp) (("" (expand "exp_estimate") (("" (lemma "powerseries_lemma" ("x" "x!1" "xs" "expT(1)" "cx" "cx!1" "cxs" "cauchy_exp_series" "m" "n!1")) (("" (replace -2) (("" (lemma "exp_series_lemma") (("" (replace -1) (("" (expand "powerseries") (("" (case-replace "(LAMBDA (i:nat):
                          IF i = 0 THEN expT(1)(i)
                          ELSE expT(1)(i) * x!1 ^ i
                          ENDIF)=expT(x!1)") (("" (hide-all-but 1) (("" (apply-extensionality :hide? t) (("" (expand "expT") (("" (case-replace "x!2=0") (("" (assert) (("" (rewrite "expt_1i") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((exp_estimate const-decl "real" ln_exp_series_alt lnexp) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_times_real_is_real application-judgement "real" reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (expt_1i formula-decl nil exponentiation nil) (powerseries const-decl "real" powerseries nil) (exp_series_lemma formula-decl nil exp nil) (powerseries_lemma formula-decl nil powerseries nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_nnreal? const-decl "bool" cauchy nil) (cauchy_nnreal nonempty-type-eq-decl nil cauchy nil) (cauchy_exp_series const-decl "cauchy_nnreal" exp nil) (expT const-decl "real" ln_exp_series_alt lnexp)) shostak)) (cauchy_exp_dr_TCC1 0 (cauchy_exp_dr_TCC1-1 nil 3394183332 ("" (lemma "exp_series_lemma") (("" (expand "cauchys_real?") (("" (inst + "expT(1)") (("" (expand "cauchys_prop") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((cauchys_real? const-decl "bool" sum nil) (cauchys_prop const-decl "bool" sum nil) (expT const-decl "real" ln_exp_series_alt lnexp) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (exp_series_lemma formula-decl nil exp nil)) nil (cauchy_exp_dr subtype "exp.cauchy_exp_series" "cauchys_real"))) (exp_dr_lemma 0 (exp_dr_lemma-2 nil 3508599234 ("" (skosimp) (("" (expand "cauchy_prop" 1) (("" (skosimp) (("" (lemma "exp_estimate_lemma" ("x" "sx!1" "cx" "csx!1" "n" "p!1+3")) (("" (assert) (("" (expand "cauchy_exp_dr") (("" (expand "cauchy_prop" -1) (("" (inst - "2+p!1") (("" (name-replace "CPS" "cauchy_powerseries(csx!1, cauchy_exp_series, 3 + p!1)(2 + p!1)") (("" (flatten) (("" (case "abs(exp_estimate(sx!1,3+p!1)*2^p!1-CPS/4)<1/4") (("1" (hide -2 -3) (("1" (lemma "lemma_A2" ("r" "round(CPS / 4)" "p" "CPS" "q" "4")) (("1" (assert) (("1" (flatten) (("1" (case "abs(CPS/4-round(CPS / 4))<=1/2") (("1" (hide -2 -3) (("1" (case "abs(exp_estimate(sx!1, 3 + p!1) * 2 ^ p!1 - round(CPS / 4)) < 3 / 4") (("1" (hide -2 -3) (("1" (name-replace "RR" "round(CPS / 4)") (("1" (lemma "exp_estimate_bnd" ("x" "sx!1" "n" "3+p!1")) (("1" (case "abs((exp(sx!1) - exp_estimate(sx!1, 3 + p!1))*2^p!1) <= 1/4") (("1" (hide -2 -4) (("1" (name-replace "EXP_" "exp(sx!1)") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (lemma "abs_mult" ("x" "exp(sx!1) - exp_estimate(sx!1, 3 + p!1)" "y" "2 ^ p!1")) (("2" (replace -1) (("2" (expand "abs" 1 2) (("2" (hide -1) (("2" (case "max(exp(sx!1), 1) * abs(sx!1) ^ (3 + p!1 + 1) /
                       factorial(3 + p!1 + 1) <= 1/(4*2^p!1)") (("1" (name-replace "LHS" "abs(exp(sx!1) - exp_estimate(sx!1, 3 + p!1))") (("1" (name-replace "RHS" "max(exp(sx!1), 1) * abs(sx!1) ^ (3 + p!1 + 1) /
                   factorial(3 + p!1 + 1)") (("1" (rewrite "div_mult_pos_le2" 1) (("1" (rewrite "div_mult_pos_le2" -1) (("1" (lemma "both_sides_times_pos_le1" ("pz" "4 * 2 ^ p!1" "x" "LHS" "y" "RHS")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (case "max(exp(sx!1), 1) * abs(sx!1) ^ (3 + p!1 + 1)<exp(1)") (("1" (case "12 * 2 ^ p!1 <= factorial(4 + p!1)") (("1" (case "exp(1)<3") (("1" (case-replace "sx!1=0") (("1" (expand "abs") (("1" (expand "^" 1 1) (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "lt_div_lt_pos2" ("nnx" "max(exp(sx!1), 1) * abs(sx!1) ^ (3 + p!1 + 1)" "y" "3" "pz" "12 * 2 ^ p!1" "w" "factorial(4 + p!1)")) (("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "exp_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst - "1" "ln(3)") (("2" (rewrite "exp_ln") (("2" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (lemma "ln_bounds" ("px" "3" "n" "4")) (("2" (name-replace "LN3" "ln(3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (case "forall (m:nat): 12*2^m<factorial(4+m)") (("1" (inst - "p!1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "m") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (rewrite "expt_plus") (("2" (expand "factorial" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case-replace "sx!1=0") (("1" (rewrite "exp_0") (("1" (expand "max") (("1" (expand "abs") (("1" (expand "^") (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "exp_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst - "sx!1" "1") (("2" (assert) (("2" (lemma "both_sides_expt_pos_lt" ("px" "abs(sx!1)" "py" "1" "pm" "4+p!1")) (("2" (rewrite "expt_1i") (("2" (flatten) (("2" (hide -1) (("2" (split -1) (("1" (lemma "both_sides_times_pos_lt1" ("pz" "max(exp(sx!1), 1)" "x" "abs(sx!1) ^ (4 + p!1)" "y" "1")) (("1" (assert) (("1" (case "max(exp(sx!1), 1)<=e") (("1" (assert) nil nil) ("2" (hide-all-but (-3 1)) (("2" (name-replace "EXP_" "exp(sx!1)") (("2" (expand "max") (("2" (case-replace "EXP_ < 1") (("1" (lemma "exp_strict_increasing") (("1" (expand "strict_increasing?") (("1" (inst - "0" "1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 2) (("2" (name-replace "RR" "round(CPS / 4)") (("2" (name-replace "P2" "2^p!1") (("2" (name-replace "EST" "exp_estimate(sx!1, 3 + p!1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 2) (("2" (name-replace "RR" "round(CPS / 4)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 2) (("2" (rewrite "expt_plus") (("2" (rewrite "expt_x2") (("2" (name-replace "EST" "exp_estimate(sx!1, 3 + p!1)") (("2" (name-replace "P2" "2^p!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_exp application-judgement "posint" exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (smallreal nonempty-type-eq-decl nil prelude_aux nil) (- const-decl "[numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (cauchy_smallreal nonempty-type-eq-decl nil cauchy nil) (cauchy_smallreal? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (exp_estimate_lemma formula-decl nil exp nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cauchy_exp_dr const-decl "int" exp nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (expt_x2 formula-decl nil inv nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (even_times_int_is_even application-judgement "even_int" integers nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_abs_is_nonneg application-judgement "{r: nonneg_rat | r >= q}" real_defs nil) (<= const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (ln const-decl "real" ln_exp lnexp) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (abs_mult formula-decl nil real_props nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (factorial def-decl "posnat" factorial ints) (nnreal type-eq-decl nil real_types nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (div_mult_pos_le2 formula-decl nil real_props nil) (expt_x1 formula-decl nil exponentiation nil) (expt_plus formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (lt_div_lt_pos2 formula-decl nil real_props nil) (expt def-decl "real" exponentiation nil) (nat_exp application-judgement "nat" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nat_expt application-judgement "nat" exponentiation nil) (nzint_max application-judgement "{k: nzint | i <= k AND j <= k}" real_defs nil) (posint_max application-judgement "{k: posint | i <= k AND j <= k}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}" real_defs nil) (int_times_even_is_even application-judgement "even_int" integers nil) (hat_02n formula-decl nil power_series series) (exp_0 formula-decl nil ln_exp lnexp) (exp_1 formula-decl nil ln_exp lnexp) (exp_strict_increasing formula-decl nil ln_exp lnexp) (ln_bounds formula-decl nil ln_approx lnexp) (real_plus_real_is_real application-judgement "real" reals nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (ln_ub const-decl "real" ln_approx lnexp) (ln_gt1_alt_ub const-decl "{x: nnreal | x >= ln(xge1)}" ln_approx lnexp) (ln_2m_ub const-decl "{x: real | x >= m * ln(2)}" ln_approx lnexp) (ln12_alt_ub const-decl "{x: real | 0 <= x AND x >= ln(x12)}" ln_approx lnexp) (ln_lb const-decl "real" ln_approx lnexp) (ln_gt1_alt_lb const-decl "{x: nnreal | x <= ln(xge1)}" ln_approx lnexp) (ln_2m_lb const-decl "{x: real | x <= m * ln(2)}" ln_approx lnexp) (ln12_alt_lb const-decl "{x: real | 0 <= x AND x <= ln(x12)}" ln_approx lnexp) (ln_alt_series const-decl "posreal" ln_approx lnexp) (ln_alt_series_it def-decl "real" ln_approx lnexp) (a const-decl "{x: posreal | x > 0 AND x <= 1 / 3}" ln_approx lnexp) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals) (exp_ln formula-decl nil ln_exp lnexp) (strict_increasing? const-decl "bool" real_fun_preds reals) (expt_1i formula-decl nil exponentiation nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (e const-decl "posreal" ln_exp lnexp) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_expt_pos_lt formula-decl nil exponentiation nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_exp application-judgement "nnreal" exponentiation nil) (posreal_max application-judgement "{z: posreal | z >= x AND z >= y}" real_defs nil) (exp_estimate_bnd formula-decl nil ln_exp_series_alt lnexp) (minus_real_is_real application-judgement "real" reals nil) (minus_rat_is_rat application-judgement "rat" rationals nil) (posint nonempty-type-eq-decl nil integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (round const-decl "int" prelude_aux nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (lemma_A2 formula-decl nil appendix nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (exp_estimate const-decl "real" ln_exp_series_alt lnexp) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (cauchys_real? const-decl "bool" sum nil) (cauchys_real nonempty-type-eq-decl nil sum nil) (cauchy_powerseries const-decl "cauchy_real" powerseries nil) (cauchy_nnreal? const-decl "bool" cauchy nil) (cauchy_nnreal nonempty-type-eq-decl nil cauchy nil) (cauchy_exp_series const-decl "cauchy_nnreal" exp nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil)) nil) (exp_dr_lemma-1 nil 3394186556 ("" (skosimp) (("" (expand "cauchy_prop" 1) (("" (skosimp) (("" (lemma "exp_estimate_lemma" ("x" "sx!1" "cx" "csx!1" "n" "p!1+3")) (("" (assert) (("" (expand "cauchy_exp_dr") (("" (expand "cauchy_prop" -1) (("" (inst - "2+p!1") (("" (name-replace "CPS" "cauchy_powerseries(csx!1, cauchy_exp_series, 3 + p!1)(2 + p!1)") (("" (flatten) (("" (case "abs(exp_estimate(sx!1,3+p!1)*2^p!1-CPS/4)<1/4") (("1" (hide -2 -3) (("1" (lemma "lemma_A2" ("r" "round(CPS / 4)" "p" "CPS" "q" "4")) (("1" (assert) (("1" (flatten) (("1" (case "abs(CPS/4-round(CPS / 4))<=1/2") (("1" (hide -2 -3) (("1" (case "abs(exp_estimate(sx!1, 3 + p!1) * 2 ^ p!1 - round(CPS / 4)) < 3 / 4") (("1" (hide -2 -3) (("1" (name-replace "RR" "round(CPS / 4)") (("1" (lemma "exp_estimate_bnd" ("x" "sx!1" "n" "3+p!1")) (("1" (case "abs((exp(sx!1) - exp_estimate(sx!1, 3 + p!1))*2^p!1) <= 1/4") (("1" (hide -2 -4) (("1" (name-replace "EXP" "exp(sx!1)") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (lemma "abs_mult" ("x" "exp(sx!1) - exp_estimate(sx!1, 3 + p!1)" "y" "2 ^ p!1")) (("2" (replace -1) (("2" (expand "abs" 1 2) (("2" (hide -1) (("2" (case "max(exp(sx!1), 1) * abs(sx!1) ^ (3 + p!1 + 1) /
        factorial(3 + p!1 + 1) <= 1/(4*2^p!1)") (("1" (name-replace "LHS" "abs(exp(sx!1) - exp_estimate(sx!1, 3 + p!1))") (("1" (name-replace "RHS" "max(exp(sx!1), 1) * abs(sx!1) ^ (3 + p!1 + 1) /
       factorial(3 + p!1 + 1)") (("1" (rewrite "div_mult_pos_le2" 1) (("1" (rewrite "div_mult_pos_le2" -1) (("1" (lemma "both_sides_times_pos_le1" ("pz" "4 * 2 ^ p!1" "x" "LHS" "y" "RHS")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (case "max(exp(sx!1), 1) * abs(sx!1) ^ (3 + p!1 + 1)<exp(1)") (("1" (case "12 * 2 ^ p!1 <= factorial(4 + p!1)") (("1" (case "exp(1)<3") (("1" (case-replace "sx!1=0") (("1" (expand "abs") (("1" (expand "^" 1 1) (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "lt_div_lt_pos2" ("nnx" "max(exp(sx!1), 1) * abs(sx!1) ^ (3 + p!1 + 1)" "y" "3" "pz" "12 * 2 ^ p!1" "w" "factorial(4 + p!1)")) (("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "exp_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst - "1" "ln(3)") (("2" (rewrite "exp_ln") (("2" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (lemma "ln_bounds" ("px" "3" "n" "4")) (("2" (name-replace "LN3" "ln(3)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (case "forall (m:nat): 12*2^m<factorial(4+m)") (("1" (inst - "p!1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "m") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (rewrite "expt_plus") (("2" (expand "factorial" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case-replace "sx!1=0") (("1" (rewrite "exp_0") (("1" (expand "max") (("1" (expand "abs") (("1" (expand "^") (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "exp_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst - "sx!1" "1") (("2" (assert) (("2" (lemma "both_sides_expt_pos_lt" ("px" "abs(sx!1)" "py" "1" "pm" "4+p!1")) (("2" (rewrite "expt_1i") (("2" (flatten) (("2" (hide -1) (("2" (split -1) (("1" (lemma "both_sides_times_pos_lt1" ("pz" "max(exp(sx!1), 1)" "x" "abs(sx!1) ^ (4 + p!1)" "y" "1")) (("1" (assert) (("1" (case "max(exp(sx!1), 1)<=e") (("1" (assert) nil nil) ("2" (hide-all-but (-3 1)) (("2" (name-replace "EXP" "exp(sx!1)") (("2" (expand "max") (("2" (case-replace "EXP < 1") (("1" (lemma "exp_strict_increasing") (("1" (expand "strict_increasing?") (("1" (inst - "0" "1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 2) (("2" (name-replace "RR" "round(CPS / 4)") (("2" (name-replace "P2" "2^p!1") (("2" (name-replace "EST" "exp_estimate(sx!1, 3 + p!1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 2) (("2" (name-replace "RR" "round(CPS / 4)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 2) (("2" (rewrite "expt_plus") (("2" (rewrite "expt_x2") (("2" (name-replace "EST" "exp_estimate(sx!1, 3 + p!1)") (("2" (name-replace "P2" "2^p!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_nnreal nonempty-type-eq-decl nil cauchy nil) (cauchy_nnreal? const-decl "bool" cauchy nil) (cauchy_powerseries const-decl "cauchy_real" powerseries nil) (cauchys_real nonempty-type-eq-decl nil sum nil) (cauchys_real? const-decl "bool" sum nil) (lemma_A2 formula-decl nil appendix nil) (round const-decl "int" prelude_aux nil) (strict_increasing? const-decl "bool" real_fun_preds reals) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals) (sigma def-decl "real" sigma reals) (hat_02n formula-decl nil power_series series) (expt_x2 formula-decl nil inv nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_smallreal? const-decl "bool" cauchy nil) (cauchy_smallreal nonempty-type-eq-decl nil cauchy nil) (smallreal nonempty-type-eq-decl nil prelude_aux nil) (cauchy_prop const-decl "bool" cauchy nil)) shostak)) (cauchy_exp_dr_TCC2 0 (cauchy_exp_dr_TCC2-1 nil 3394183332 ("" (skosimp) (("" (typepred "csx!1") (("" (expand "cauchy_smallreal?") (("" (skosimp) (("" (lemma "exp_dr_lemma" ("csx" "csx!1" "sx" "sx!1")) (("" (expand "cauchy_posreal?") (("" (inst + "exp(sx!1)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_smallreal nonempty-type-eq-decl nil cauchy nil) (cauchy_smallreal? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (cauchy_posreal? const-decl "bool" cauchy nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (ln const-decl "real" ln_exp lnexp) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (exp_dr_lemma formula-decl nil exp nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (smallreal nonempty-type-eq-decl nil prelude_aux nil)) nil (cauchy_exp_dr_ subtype "exp.cauchy_exp_dr(exp.csx)" "cauchy_posreal"))) (cauchy_exp_TCC1 0 (cauchy_exp_TCC1-2 "" 3804548980 ("" (skosimp*) (("" (typepred "cx!1") (("" (expand "cauchy_real?") (("" (skosimp) (("" (lemma "div_lemma" ("x" "x!1" "cx" "cx!1" "nzy" "ln(2)" "nzcy" "cauchy_ln2")) (("1" (rewrite "cauchy_ln2_lemma") (("1" (assert) (("1" (expand "cauchy_prop" -1) (("1" (inst - "0") (("1" (replace -3 * rl) (("1" (rewrite "expt_x0") (("1" (flatten) (("1" (lemma "mul_lemma" ("x" "n!1" "cx" "cauchy_int(n!1)" "y" "ln(2)" "cy" "cauchy_ln2")) (("1" (rewrite "int_lemma") (("1" (rewrite "cauchy_ln2_lemma") (("1" (lemma "sub_lemma" ("x" "x!1" "cx" "cx!1" "y" "n!1 * ln(2)" "cy" "cauchy_mul(cauchy_int(n!1), cauchy_ln2)")) (("1" (assert) (("1" (replace -7 * rl) (("1" (rewrite "div_mult_pos_lt2" -3) (("1" (rewrite "div_mult_pos_lt1" -4) (("1" (case "ln(2)<1") (("1" (expand "cauchy_smallreal?") (("1" (inst + "x!1 - n!1 * ln(2)") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "ln_bounds" ("px" "2" "n" "2")) (("2" (flatten) (("2" (hide -1) (("2" (name-replace "LN2" "ln(2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst - "1" "2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst - "1" "2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst - "1" "2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (cauchy_exp subtype "exp.cy" "cauchy_smallreal")) (cauchy_exp_TCC1-1 nil 3394183332 ("" (skosimp*) (("" (typepred "cx!1") (("" (expand "cauchy_real?") (("" (skosimp) (("" (lemma "div_lemma" ("x" "x!1" "cx" "cx!1" "nzy" "ln(2)" "nzcy" "cauchy_ln2")) (("1" (rewrite "cauchy_ln2_lemma") (("1" (assert) (("1" (expand "cauchy_prop" -1) (("1" (inst - "0") (("1" (replace -3 * rl) (("1" (rewrite "expt_x0") (("1" (flatten) (("1" (lemma "mul_lemma" ("x" "n!1" "cx" "cauchy_int(n!1)" "y" "ln(2)" "cy" "cauchy_ln2")) (("1" (rewrite "int_lemma") (("1" (rewrite "cauchy_ln2_lemma") (("1" (lemma "sub_lemma" ("x" "x!1" "cx" "cx!1" "y" "n!1 * ln(2)" "cy" "cauchy_mul(cauchy_int(n!1), cauchy_ln2)")) (("1" (assert) (("1" (replace -8 * rl) (("1" (rewrite "div_mult_pos_lt2" -3) (("1" (rewrite "div_mult_pos_lt1" -4) (("1" (case "ln(2)<1") (("1" (expand "cauchy_smallreal?") (("1" (inst + "x!1 - n!1 * ln(2)") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "ln_bounds" ("px" "2" "n" "2")) (("2" (flatten) (("2" (hide -1) (("2" (name-replace "LN2" "ln(2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst - "1" "2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst - "1" "2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst - "1" "2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (cauchy_ln2_lemma formula-decl nil log nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (posint_exp application-judgement "posint" exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (int_lemma formula-decl nil int nil) (real_times_real_is_real application-judgement "real" reals nil) (sub_lemma formula-decl nil sub nil) (cauchy_mul const-decl "cauchy_real" mul nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (ln_ub const-decl "real" ln_approx lnexp) (ln_gt1_alt_ub const-decl "{x: nnreal | x >= ln(xge1)}" ln_approx lnexp) (ln_2m_ub const-decl "{x: real | x >= m * ln(2)}" ln_approx lnexp) (ln12_alt_ub const-decl "{x: real | 0 <= x AND x >= ln(x12)}" ln_approx lnexp) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (ln_alt_series const-decl "posreal" ln_approx lnexp) (ln_alt_series_it def-decl "real" ln_approx lnexp) (a const-decl "{x: posreal | x > 0 AND x <= 1 / 3}" ln_approx lnexp) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals) (ln_bounds formula-decl nil ln_approx lnexp) (cauchy_smallreal? const-decl "bool" cauchy nil) (real_plus_real_is_real application-judgement "real" reals nil) (n!1 skolem-const-decl "int" exp nil) (x!1 skolem-const-decl "real" exp nil) (- const-decl "[numfield -> numfield]" number_fields nil) (smallreal nonempty-type-eq-decl nil prelude_aux nil) (< const-decl "bool" reals nil) (strict_increasing? const-decl "bool" real_fun_preds reals) (ln_1 formula-decl nil ln_exp lnexp) (ln_strict_increasing formula-decl nil ln_exp lnexp) (real_minus_real_is_real application-judgement "real" reals nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (cauchy_int const-decl "cauchy_real" int nil) (mul_lemma formula-decl nil mul nil) (expt_x0 formula-decl nil exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (div_lemma formula-decl nil div nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_posreal? const-decl "bool" cauchy nil) (cauchy_posreal nonempty-type-eq-decl nil cauchy nil) (cauchy_ln2 const-decl "cauchy_posreal" log nil) (/= const-decl "boolean" notequal nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (ln const-decl "real" ln_exp lnexp)) nil (cauchy_exp subtype "exp.cy" "cauchy_smallreal"))) (cauchy_exp_TCC2 0 (cauchy_exp_TCC2-1 nil 3394183332 ("" (skosimp*) (("" (assert) nil nil)) nil) ((minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (cauchy_exp subtype "(number_fields.-)(exp.n)" "nat"))) (cauchy_exp_TCC3 0 (cauchy_exp_TCC3-2 "" 3804550026 ("" (skosimp*) (("" (hide 1) (("" (case "0<ln(2)&ln(2)<1") (("1" (flatten) (("1" (typepred "cx!1") (("1" (expand "cauchy_real?") (("1" (skosimp) (("1" (lemma "div_lemma" ("x" "x!1" "cx" "cx!1" "nzy" "ln(2)" "nzcy" "cauchy_ln2")) (("1" (rewrite "cauchy_ln2_lemma") (("1" (assert) (("1" (expand "cauchy_prop" -1) (("1" (inst - "0") (("1" (rewrite "expt_x0") (("1" (replace -5 * rl) (("1" (flatten) (("1" (assert) (("1" (rewrite "div_mult_pos_lt2" -1) (("1" (rewrite "div_mult_pos_lt1" -2) (("1" (lemma "mul_lemma" ("x" "n!1" "cx" "cauchy_int(n!1)" "y" "ln(2)" "cy" "cauchy_ln2")) (("1" (rewrite "int_lemma") (("1" (rewrite "cauchy_ln2_lemma") (("1" (lemma "sub_lemma" ("x" "x!1" "cx" "cx!1" "y" "n!1 * ln(2)" "cy" "cauchy_mul(cauchy_int(n!1), cauchy_ln2)")) (("1" (assert) (("1" (replace -9 * rl) (("1" (expand "cauchy_smallreal?") (("1" (inst + "x!1 - n!1 * ln(2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "ln_bounds" ("px" "2" "n" "1")) (("2" (name-replace "LN2" "ln(2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (cauchy_exp subtype "exp.cy" "cauchy_smallreal")) (cauchy_exp_TCC3-1 nil 3394183332 ("" (skosimp*) (("" (hide 1) (("" (case "0<ln(2)&ln(2)<1") (("1" (flatten) (("1" (typepred "cx!1") (("1" (expand "cauchy_real?") (("1" (skosimp) (("1" (lemma "div_lemma" ("x" "x!1" "cx" "cx!1" "nzy" "ln(2)" "nzcy" "cauchy_ln2")) (("1" (rewrite "cauchy_ln2_lemma") (("1" (assert) (("1" (expand "cauchy_prop" -1) (("1" (inst - "0") (("1" (rewrite "expt_x0") (("1" (replace -5 * rl) (("1" (flatten) (("1" (assert) (("1" (rewrite "div_mult_pos_lt2" -1) (("1" (rewrite "div_mult_pos_lt1" -2) (("1" (lemma "mul_lemma" ("x" "n!1" "cx" "cauchy_int(n!1)" "y" "ln(2)" "cy" "cauchy_ln2")) (("1" (rewrite "int_lemma") (("1" (rewrite "cauchy_ln2_lemma") (("1" (lemma "sub_lemma" ("x" "x!1" "cx" "cx!1" "y" "n!1 * ln(2)" "cy" "cauchy_mul(cauchy_int(n!1), cauchy_ln2)")) (("1" (assert) (("1" (replace -10 * rl) (("1" (expand "cauchy_smallreal?") (("1" (inst + "x!1 - n!1 * ln(2)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "ln_bounds" ("px" "2" "n" "1")) (("2" (name-replace "LN2" "ln(2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals) (a const-decl "{x: posreal | x > 0 AND x <= 1 / 3}" ln_approx lnexp) (ln_alt_series_it def-decl "real" ln_approx lnexp) (ln_alt_series const-decl "posreal" ln_approx lnexp) (ln12_alt_lb const-decl "{x: real | 0 <= x AND x <= ln(x12)}" ln_approx lnexp) (ln_2m_lb const-decl "{x: real | x <= m * ln(2)}" ln_approx lnexp) (ln_gt1_alt_lb const-decl "{x: nnreal | x <= ln(xge1)}" ln_approx lnexp) (ln_lb const-decl "real" ln_approx lnexp) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (ln12_alt_ub const-decl "{x: real | 0 <= x AND x >= ln(x12)}" ln_approx lnexp) (ln_2m_ub const-decl "{x: real | x >= m * ln(2)}" ln_approx lnexp) (ln_gt1_alt_ub const-decl "{x: nnreal | x >= ln(xge1)}" ln_approx lnexp) (ln_ub const-decl "real" ln_approx lnexp) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (ln_bounds formula-decl nil ln_approx lnexp) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (cauchy_ln2 const-decl "cauchy_posreal" log nil) (cauchy_posreal nonempty-type-eq-decl nil cauchy nil) (cauchy_posreal? const-decl "bool" cauchy nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (div_lemma formula-decl nil div nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (int_lemma formula-decl nil int nil) (sub_lemma formula-decl nil sub nil) (cauchy_mul const-decl "cauchy_real" mul nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (smallreal nonempty-type-eq-decl nil prelude_aux nil) (- const-decl "[numfield -> numfield]" number_fields nil) (cauchy_smallreal? const-decl "bool" cauchy nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (cauchy_int const-decl "cauchy_real" int nil) (mul_lemma formula-decl nil mul nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (expt_x0 formula-decl nil exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (posint_exp application-judgement "posint" exponentiation nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (cauchy_ln2_lemma formula-decl nil log nil) (NOT const-decl "[bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (ln const-decl "real" ln_exp lnexp)) nil (cauchy_exp subtype "exp.cy" "cauchy_smallreal"))) (cauchy_exp_TCC4 0 (cauchy_exp_TCC4-1 nil 3394183332 ("" (skosimp*) (("" (assert) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (cauchy_exp subtype "exp.n" "nat"))) (cauchy_exp_TCC5 0 (cauchy_exp_TCC5-1 nil 3394183332 ("" (skosimp*) (("" (case-replace "n!1=0") (("1" (hide -1 1 2) (("1" (lemma "mul_lemma" ("x" "0" "cx" "cauchy_int(0)" "y" "ln(2)" "cy" "cauchy_ln2")) (("1" (rewrite "int_lemma") (("1" (rewrite "cauchy_ln2_lemma") (("1" (lemma "unique_cauchy_zero3" ("cx" "cauchy_mul(cauchy_int(0), cauchy_ln2)")) (("1" (assert) (("1" (replace -1) (("1" (typepred "cx!1") (("1" (expand "cauchy_real?") (("1" (skosimp) (("1" (lemma "sub_lemma" ("x" "x!1" "cx" "cx!1" "y" "0" "cy" "cauchy_zero")) (("1" (lemma "unique_cauchy_zero" ("x" "0")) (("1" (assert) (("1" (hide -1) (("1" (replace -6 * rl) (("1" (hide -3 -4 -6) (("1" (lemma "div_lemma" ("x" "x!1" "cx" "cx!1" "nzy" "ln(2)" "nzcy" "cauchy_ln2")) (("1" (rewrite "cauchy_ln2_lemma") (("1" (assert) (("1" (expand "cauchy_prop" -1) (("1" (inst - "0") (("1" (rewrite "expt_x0") (("1" (replace -4 * rl) (("1" (flatten) (("1" (assert) (("1" (rewrite "div_mult_pos_lt2" -1) (("1" (rewrite "div_mult_pos_lt1" -2) (("1" (case "ln(2)<1") (("1" (expand "cauchy_smallreal?") (("1" (inst + "x!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "ln_bounds" ("px" "2" "n" "1")) (("2" (name-replace "LN2" "ln(2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst - "1" "2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst - "1" "2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst - "1" "2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (ln const-decl "real" ln_exp lnexp) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (cauchy_ln2 const-decl "cauchy_posreal" log nil) (cauchy_posreal nonempty-type-eq-decl nil cauchy nil) (cauchy_posreal? const-decl "bool" cauchy nil) (cauchy_int const-decl "cauchy_real" int nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (mul_lemma formula-decl nil mul nil) (cauchy_ln2_lemma formula-decl nil log nil) (real_times_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (unique_cauchy_zero formula-decl nil cauchy nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (posint_exp application-judgement "posint" exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (expt_x0 formula-decl nil exponentiation nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (ln_strict_increasing formula-decl nil ln_exp lnexp) (ln_1 formula-decl nil ln_exp lnexp) (strict_increasing? const-decl "bool" real_fun_preds reals) (< const-decl "bool" reals nil) (smallreal nonempty-type-eq-decl nil prelude_aux nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (x!1 skolem-const-decl "real" exp nil) (cauchy_smallreal? const-decl "bool" cauchy nil) (ln_bounds formula-decl nil ln_approx lnexp) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (ln_ub const-decl "real" ln_approx lnexp) (ln_gt1_alt_ub const-decl "{x: nnreal | x >= ln(xge1)}" ln_approx lnexp) (ln_2m_ub const-decl "{x: real | x >= m * ln(2)}" ln_approx lnexp) (ln12_alt_ub const-decl "{x: real | 0 <= x AND x >= ln(x12)}" ln_approx lnexp) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (ln_lb const-decl "real" ln_approx lnexp) (ln_gt1_alt_lb const-decl "{x: nnreal | x <= ln(xge1)}" ln_approx lnexp) (ln_2m_lb const-decl "{x: real | x <= m * ln(2)}" ln_approx lnexp) (ln12_alt_lb const-decl "{x: real | 0 <= x AND x <= ln(x12)}" ln_approx lnexp) (ln_alt_series const-decl "posreal" ln_approx lnexp) (ln_alt_series_it def-decl "real" ln_approx lnexp) (a const-decl "{x: posreal | x > 0 AND x <= 1 / 3}" ln_approx lnexp) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals) (div_mult_pos_lt1 formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (div_lemma formula-decl nil div nil) (cauchy_zero const-decl "cauchy_nnreal" cauchy nil) (cauchy_nnreal nonempty-type-eq-decl nil cauchy nil) (cauchy_nnreal? const-decl "bool" cauchy nil) (sub_lemma formula-decl nil sub nil) (cauchy_mul const-decl "cauchy_real" mul nil) (unique_cauchy_zero3 formula-decl nil cauchy nil) (int_lemma formula-decl nil int nil)) nil (cauchy_exp subtype "exp.cy" "cauchy_smallreal"))) (exp_lemma 0 (exp_lemma-2 nil 3508599271 ("" (skosimp) (("" (expand "cauchy_exp") (("" (name "N" "cauchy_div(cx!1, cauchy_ln2)(0)") (("" (replace -1) (("" (lemma "mul_lemma" ("x" "N" "cx" "cauchy_int(N)" "y" "ln(2)" "cy" "cauchy_ln2")) (("" (rewrite "int_lemma") (("" (rewrite "cauchy_ln2_lemma") (("" (lemma "sub_lemma" ("x" "x!1" "cx" "cx!1" "y" "N * ln(2)" "cy" "cauchy_mul(cauchy_int(N), cauchy_ln2)")) (("" (assert) (("" (case "0<ln(2)&ln(2)<1") (("1" (flatten) (("1" (lemma "div_lemma" ("x" "x!1" "cx" "cx!1" "nzy" "ln(2)" "nzcy" "cauchy_ln2")) (("1" (rewrite "cauchy_ln2_lemma") (("1" (assert) (("1" (expand "cauchy_prop" -1) (("1" (inst - "0") (("1" (rewrite "expt_x0") (("1" (replace -6) (("1" (flatten) (("1" (assert) (("1" (rewrite "div_mult_pos_lt1") (("1" (rewrite "div_mult_pos_lt2") (("1" (lemma "exp_dr_lemma" ("sx" "x!1 - N * ln(2)" "csx" "cauchy_sub(cx!1, cauchy_mul(cauchy_int(N), cauchy_ln2))")) (("1" (assert) (("1" (name-replace "EXP_" "cauchy_exp_dr(cauchy_sub(cx!1,
                                                   cauchy_mul
                                                   (cauchy_int(N), cauchy_ln2)))") (("1" (lemma "trichotomy" ("x" "N")) (("1" (split -1) (("1" (assert) (("1" (lemma "lemma_mul2n" ("x" "exp(x!1 - N * ln(2))" "cx" "EXP_" "n" "N")) (("1" (assert) (("1" (expand "mul2n") (("1" (rewrite "exp_diff" -1) (("1" (rewrite "exp_scal" -1) (("1" (assert) (("1" (rewrite "exp_ln") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) (("3" (lemma "lemma_div2n" ("x" "exp(x!1 - N * ln(2))" "cx" "EXP_" "n" "-N")) (("3" (assert) (("3" (expand "div2n") (("3" (rewrite "exp_diff") (("3" (rewrite "exp_scal") (("3" (rewrite "exp_ln") (("3" (rewrite "div_div2") (("3" (lemma "expt_plus" ("n0x" "2" "i" "N" "j" "-N")) (("3" (rewrite "expt_x0") (("3" (replace -1 -2 rl) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (expand "cauchy_smallreal?") (("3" (inst + "x!1 - N * ln(2)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "ln_bounds" ("px" "2" "n" "2")) (("2" (name-replace "LN2" "ln(2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_exp const-decl "[nat -> int]" exp nil) (int_lemma formula-decl nil int nil) (real_times_real_is_real application-judgement "real" reals nil) (sub_lemma formula-decl nil sub nil) (cauchy_mul const-decl "cauchy_real" mul nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (div_lemma formula-decl nil div nil) (/= const-decl "boolean" notequal nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (N skolem-const-decl "int" exp nil) (x!1 skolem-const-decl "real" exp nil) (real_plus_real_is_real application-judgement "real" reals nil) (trichotomy formula-decl nil real_axioms nil) (minus_int_is_int application-judgement "int" integers nil) (expt_plus formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (div_div2 formula-decl nil real_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (div2n const-decl "real" shift nil) (lemma_div2n formula-decl nil shift nil) (exp_diff formula-decl nil ln_exp lnexp) (posrat_exp application-judgement "posrat" exponentiation nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (exp_ln formula-decl nil ln_exp lnexp) (posreal_exp application-judgement "posreal" exponentiation nil) (exp_scal formula-decl nil ln_exp lnexp) (integer nonempty-type-from-decl nil integers nil) (mul2n const-decl "real" shift nil) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (lemma_mul2n formula-decl nil shift nil) (nil application-judgement "cauchy_posreal" exp nil) (cauchy_exp_dr const-decl "int" exp nil) (smallreal nonempty-type-eq-decl nil prelude_aux nil) (- const-decl "[numfield -> numfield]" number_fields nil) (cauchy_sub const-decl "cauchy_real" sub nil) (cauchy_smallreal nonempty-type-eq-decl nil cauchy nil) (cauchy_smallreal? const-decl "bool" cauchy nil) (exp_dr_lemma formula-decl nil exp nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (expt_x0 formula-decl nil exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (posint_exp application-judgement "posint" exponentiation nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (ln_bounds formula-decl nil ln_approx lnexp) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (ln_ub const-decl "real" ln_approx lnexp) (ln_gt1_alt_ub const-decl "{x: nnreal | x >= ln(xge1)}" ln_approx lnexp) (ln_2m_ub const-decl "{x: real | x >= m * ln(2)}" ln_approx lnexp) (ln12_alt_ub const-decl "{x: real | 0 <= x AND x >= ln(x12)}" ln_approx lnexp) (expt def-decl "real" exponentiation nil) (ln_lb const-decl "real" ln_approx lnexp) (ln_gt1_alt_lb const-decl "{x: nnreal | x <= ln(xge1)}" ln_approx lnexp) (ln_2m_lb const-decl "{x: real | x <= m * ln(2)}" ln_approx lnexp) (ln12_alt_lb const-decl "{x: real | 0 <= x AND x <= ln(x12)}" ln_approx lnexp) (ln_alt_series const-decl "posreal" ln_approx lnexp) (ln_alt_series_it def-decl "real" ln_approx lnexp) (a const-decl "{x: posreal | x > 0 AND x <= 1 / 3}" ln_approx lnexp) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cauchy_ln2_lemma formula-decl nil log nil) (mul_lemma formula-decl nil mul nil) (cauchy_int const-decl "cauchy_real" int nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (ln const-decl "real" ln_exp lnexp) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_div const-decl "cauchy_real" div nil) (cauchy_posreal? const-decl "bool" cauchy nil) (cauchy_posreal nonempty-type-eq-decl nil cauchy nil) (cauchy_ln2 const-decl "cauchy_posreal" log nil)) nil) (exp_lemma-1 nil 3394193300 ("" (skosimp) (("" (expand "cauchy_exp") (("" (name "N" "cauchy_div(cx!1, cauchy_ln2)(0)") (("" (replace -1) (("" (lemma "mul_lemma" ("x" "N" "cx" "cauchy_int(N)" "y" "ln(2)" "cy" "cauchy_ln2")) (("" (rewrite "int_lemma") (("" (rewrite "cauchy_ln2_lemma") (("" (lemma "sub_lemma" ("x" "x!1" "cx" "cx!1" "y" "N * ln(2)" "cy" "cauchy_mul(cauchy_int(N), cauchy_ln2)")) (("" (assert) (("" (case "0<ln(2)&ln(2)<1") (("1" (flatten) (("1" (lemma "div_lemma" ("x" "x!1" "cx" "cx!1" "nzy" "ln(2)" "nzcy" "cauchy_ln2")) (("1" (rewrite "cauchy_ln2_lemma") (("1" (assert) (("1" (expand "cauchy_prop" -1) (("1" (inst - "0") (("1" (rewrite "expt_x0") (("1" (replace -6) (("1" (flatten) (("1" (assert) (("1" (rewrite "div_mult_pos_lt1") (("1" (rewrite "div_mult_pos_lt2") (("1" (lemma "exp_dr_lemma" ("sx" "x!1 - N * ln(2)" "csx" "cauchy_sub(cx!1, cauchy_mul(cauchy_int(N), cauchy_ln2))")) (("1" (assert) (("1" (name-replace "EXP" "cauchy_exp_dr(cauchy_sub(cx!1,
                                           cauchy_mul
                                           (cauchy_int(N), cauchy_ln2)))") (("1" (lemma "trichotomy" ("x" "N")) (("1" (split -1) (("1" (assert) (("1" (lemma "lemma_mul2n" ("x" "exp(x!1 - N * ln(2))" "cx" "EXP" "n" "N")) (("1" (assert) (("1" (expand "mul2n") (("1" (rewrite "exp_diff" -1) (("1" (rewrite "exp_scal" -1) (("1" (assert) (("1" (rewrite "exp_ln") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) (("3" (lemma "lemma_div2n" ("x" "exp(x!1 - N * ln(2))" "cx" "EXP" "n" "-N")) (("3" (assert) (("3" (expand "div2n") (("3" (rewrite "exp_diff") (("3" (rewrite "exp_scal") (("3" (rewrite "exp_ln") (("3" (rewrite "div_div2") (("3" (lemma "expt_plus" ("n0x" "2" "i" "N" "j" "-N")) (("3" (rewrite "expt_x0") (("3" (replace -1 -2 rl) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (expand "cauchy_smallreal?") (("3" (inst + "x!1 - N * ln(2)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "ln_bounds" ("px" "2" "n" "2")) (("2" (name-replace "LN2" "ln(2)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_lemma formula-decl nil int nil) (sub_lemma formula-decl nil sub nil) (cauchy_mul const-decl "cauchy_real" mul nil) (div_lemma formula-decl nil div nil) (div2n const-decl "real" shift nil) (lemma_div2n formula-decl nil shift nil) (mul2n const-decl "real" shift nil) (lemma_mul2n formula-decl nil shift nil) (cauchy_smallreal? const-decl "bool" cauchy nil) (cauchy_smallreal nonempty-type-eq-decl nil cauchy nil) (cauchy_sub const-decl "cauchy_real" sub nil) (smallreal nonempty-type-eq-decl nil prelude_aux nil) (cauchy_prop const-decl "bool" cauchy nil) (sigma def-decl "real" sigma reals) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals) (cauchy_ln2_lemma formula-decl nil log nil) (mul_lemma formula-decl nil mul nil) (cauchy_int const-decl "cauchy_real" int nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_div const-decl "cauchy_real" div nil) (cauchy_posreal? const-decl "bool" cauchy nil) (cauchy_posreal nonempty-type-eq-decl nil cauchy nil) (cauchy_ln2 const-decl "cauchy_posreal" log nil)) shostak)) (cauchy_exp_is_posreal 0 (cauchy_exp_is_posreal-1 nil 3394186422 ("" (skosimp) (("" (typepred "cx!1") (("" (expand "cauchy_real?") (("" (skosimp) (("" (lemma "exp_lemma" ("x" "x!1" "cx" "cx!1")) (("" (assert) (("" (expand "cauchy_posreal?") (("" (inst + "exp(x!1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (ln const-decl "real" ln_exp lnexp) (= const-decl "[T, T -> boolean]" equalities nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (cauchy_posreal? const-decl "bool" cauchy nil) (exp_lemma formula-decl nil exp nil)) nil (cauchy_exp_is_posreal subtype "exp.cauchy_exp(exp.cx)" "cauchy_posreal"))))
