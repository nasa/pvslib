(cauchy_expr_eval (Eval_real_TCC1 0 (Eval_real_TCC1-2 "" 3790106135 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (>= const-decl "bool" reals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval_real subtype "cauchy_expr_eval.varidx" "below[length[rat](vars)]")) (Eval_real_TCC1-1 nil 3675163044 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.varidx" "below[length[rat](vars)]"))) (Eval_real_TCC2 0 (Eval_real_TCC2-1 nil 3675163044 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC3 0 (Eval_real_TCC3-1 nil 3675163044 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re2, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC4 0 (Eval_real_TCC4-2 "" 3790106135 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res1" "(Maybe[real].some?)")) (Eval_real_TCC4-1 nil 3675163044 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res1" "(Maybe[real].some?)"))) (Eval_real_TCC5 0 (Eval_real_TCC5-2 "" 3790106135 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res2" "(Maybe[real].some?)")) (Eval_real_TCC5-1 nil 3675163044 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res2" "(Maybe[real].some?)"))) (Eval_real_TCC6 0 (Eval_real_TCC6-1 nil 3675163044 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC7 0 (Eval_real_TCC7-2 "" 3790106135 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)")) (Eval_real_TCC7-1 nil 3675163044 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)"))) (Eval_real_TCC8 0 (Eval_real_TCC8-1 nil 3675163044 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC9 0 (Eval_real_TCC9-1 nil 3675163044 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re2, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC10 0 (Eval_real_TCC10-2 "" 3790106136 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res1" "(Maybe[real].some?)")) (Eval_real_TCC10-1 nil 3675163044 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res1" "(Maybe[real].some?)"))) (Eval_real_TCC11 0 (Eval_real_TCC11-2 "" 3790106136 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res2" "(Maybe[real].some?)")) (Eval_real_TCC11-1 nil 3675163044 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res2" "(Maybe[real].some?)"))) (Eval_real_TCC12 0 (Eval_real_TCC12-1 nil 3675163044 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC13 0 (Eval_real_TCC13-1 nil 3675163044 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re2, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC14 0 (Eval_real_TCC14-2 "" 3790106136 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res1" "(Maybe[real].some?)")) (Eval_real_TCC14-1 nil 3675163044 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res1" "(Maybe[real].some?)"))) (Eval_real_TCC15 0 (Eval_real_TCC15-2 "" 3790106136 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res2" "(Maybe[real].some?)")) (Eval_real_TCC15-1 nil 3675163044 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res2" "(Maybe[real].some?)"))) (Eval_real_TCC16 0 (Eval_real_TCC16-1 nil 3675163044 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC17 0 (Eval_real_TCC17-2 "" 3790106136 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (>= const-decl "bool" reals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)")) (Eval_real_TCC17-1 nil 3675163044 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)"))) (Eval_real_TCC18 0 (Eval_real_TCC18-2 "" 3790106136 ("" (termination-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) shostak (Eval_real subtype "cauchy_expr_eval.opn" "{i: integers.int | booleans.OR(Maybe[real].val(cauchy_expr_eval.res) /= 0, reals.>=(i, 0))}")) (Eval_real_TCC18-1 nil 3675163044 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.opn" "{i: integers.int | booleans.OR(Maybe[real].val(cauchy_expr_eval.res) /= 0, reals.>=(i, 0))}"))) (Eval_real_TCC19 0 (Eval_real_TCC19-1 nil 3675163044 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC20 0 (Eval_real_TCC20-2 "" 3790106137 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)")) (Eval_real_TCC20-1 nil 3675163044 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)"))) (Eval_real_TCC21 0 (Eval_real_TCC21-1 nil 3675163044 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC22 0 (Eval_real_TCC22-1 nil 3675167772 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re2, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC23 0 (Eval_real_TCC23-2 "" 3790106137 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res1" "(Maybe[real].some?)")) (Eval_real_TCC23-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res1" "(Maybe[real].some?)"))) (Eval_real_TCC24 0 (Eval_real_TCC24-2 "" 3790106137 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res2" "(Maybe[real].some?)")) (Eval_real_TCC24-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res2" "(Maybe[real].some?)"))) (Eval_real_TCC25 0 (Eval_real_TCC25-1 nil 3675167772 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC26 0 (Eval_real_TCC26-1 nil 3675167772 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re2, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC27 0 (Eval_real_TCC27-2 "" 3790106137 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res1" "(Maybe[real].some?)")) (Eval_real_TCC27-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res1" "(Maybe[real].some?)"))) (Eval_real_TCC28 0 (Eval_real_TCC28-2 "" 3790106138 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res2" "(Maybe[real].some?)")) (Eval_real_TCC28-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res2" "(Maybe[real].some?)"))) (Eval_real_TCC29 0 (Eval_real_TCC29-1 nil 3675439966 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC30 0 (Eval_real_TCC30-2 "" 3790106138 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)")) (Eval_real_TCC30-1 nil 3675439966 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)"))) (Eval_real_TCC31 0 (Eval_real_TCC31-1 nil 3675439966 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC32 0 (Eval_real_TCC32-2 "" 3790106138 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)")) (Eval_real_TCC32-1 nil 3675439966 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)"))) (Eval_real_TCC33 0 (Eval_real_TCC33-1 nil 3675439966 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC34 0 (Eval_real_TCC34-1 nil 3675439966 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re2, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC35 0 (Eval_real_TCC35-2 "" 3790106138 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res2" "(Maybe[real].some?)")) (Eval_real_TCC35-1 nil 3675504553 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res2" "(Maybe[real].some?)"))) (Eval_real_TCC36 0 (Eval_real_TCC36-2 "" 3790106138 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (Eval_real subtype "cauchy_expr_eval.res1" "(Maybe[real].some?)")) (Eval_real_TCC36-1 nil 3675504553 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res1" "(Maybe[real].some?)"))) (Eval_real_TCC37 0 (Eval_real_TCC37-2 "" 3790106139 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (/= const-decl "boolean" notequal nil)) shostak (Eval_real subtype "Maybe[real].val(cauchy_expr_eval.res2)" "nznum")) (Eval_real_TCC37-1 nil 3675504553 ("" (termination-tcc)) nil nil (Eval_real subtype "Maybe[real].val(cauchy_expr_eval.res2)" "nznum"))) (Eval_real_TCC38 0 (Eval_real_TCC38-1 nil 3675504553 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC39 0 (Eval_real_TCC39-2 "" 3790106139 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)")) (Eval_real_TCC39-1 nil 3675504553 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)"))) (Eval_real_TCC40 0 (Eval_real_TCC40-1 nil 3675504553 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC41 0 (Eval_real_TCC41-2 "" 3790106139 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)")) (Eval_real_TCC41-1 nil 3675504553 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)"))) (Eval_real_TCC42 0 (Eval_real_TCC42-2 "" 3790106139 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval_real subtype "Maybe[real].val(cauchy_expr_eval.res)" "nonneg_real")) (Eval_real_TCC42-1 nil 3675504553 ("" (termination-tcc)) nil nil (Eval_real subtype "Maybe[real].val(cauchy_expr_eval.res)" "nonneg_real"))) (Eval_real_TCC43 0 (Eval_real_TCC43-1 nil 3675504553 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC44 0 (Eval_real_TCC44-2 "" 3790106139 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)")) (Eval_real_TCC44-1 nil 3675504553 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)"))) (Eval_real_TCC45 0 (Eval_real_TCC45-2 "" 3790106139 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval_real subtype "Maybe[real].val(cauchy_expr_eval.res)" "posreal")) (Eval_real_TCC45-1 nil 3675504553 ("" (termination-tcc)) nil nil (Eval_real subtype "Maybe[real].val(cauchy_expr_eval.res)" "posreal"))) (Eval_real_TCC46 0 (Eval_real_TCC46-1 nil 3675592709 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC47 0 (Eval_real_TCC47-2 "" 3790106140 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)")) (Eval_real_TCC47-1 nil 3675592709 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)"))) (Eval_real_TCC48 0 (Eval_real_TCC48-2 "" 3790106140 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_real_is_real application-judgement "real" reals nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)) shostak (Eval_real subtype "Maybe[real].val(cauchy_expr_eval.res)" "real_abs_le1")) (Eval_real_TCC48-1 nil 3675592709 ("" (termination-tcc)) nil nil (Eval_real subtype "Maybe[real].val(cauchy_expr_eval.res)" "real_abs_le1"))) (Eval_real_TCC49 0 (Eval_real_TCC49-1 nil 3675603704 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC50 0 (Eval_real_TCC50-2 "" 3790106140 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)")) (Eval_real_TCC50-1 nil 3675603704 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)"))) (Eval_real_TCC51 0 (Eval_real_TCC51-1 nil 3675614809 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC52 0 (Eval_real_TCC52-1 nil 3675614809 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re2, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC53 0 (Eval_real_TCC53-2 "" 3790106140 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res2" "(Maybe[real].some?)")) (Eval_real_TCC53-1 nil 3675614809 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res2" "(Maybe[real].some?)"))) (Eval_real_TCC54 0 (Eval_real_TCC54-2 "" 3790106140 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (Eval_real subtype "cauchy_expr_eval.res1" "(Maybe[real].some?)")) (Eval_real_TCC54-1 nil 3675614809 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res1" "(Maybe[real].some?)"))) (Eval_real_TCC55 0 (Eval_real_TCC55-2 "" 3790106141 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (/= const-decl "boolean" notequal nil)) shostak (Eval_real subtype "Maybe[real].val(cauchy_expr_eval.res2)" "nonzero_real")) (Eval_real_TCC55-1 nil 3675614809 ("" (termination-tcc)) nil nil (Eval_real subtype "Maybe[real].val(cauchy_expr_eval.res2)" "nonzero_real"))) (Eval_real_TCC56 0 (Eval_real_TCC56-1 nil 3703422932 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC57 0 (Eval_real_TCC57-2 "" 3790106141 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)")) (Eval_real_TCC57-1 nil 3703422932 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)"))) (Eval_real_TCC58 0 (Eval_real_TCC58-2 "" 3790106141 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_real_is_real application-judgement "real" reals nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)) shostak (Eval_real subtype "Maybe[real].val(cauchy_expr_eval.res)" "real_abs_le1")) (Eval_real_TCC58-1 nil 3703422932 ("" (termination-tcc)) nil nil (Eval_real subtype "Maybe[real].val(cauchy_expr_eval.res)" "real_abs_le1"))) (Eval_real_TCC59 0 (Eval_real_TCC59-1 nil 3703422932 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval_real termination "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re1, cauchy_expr_eval.vars)" "nil"))) (Eval_real_TCC60 0 (Eval_real_TCC60-2 "" 3790106141 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rat nonempty-type-eq-decl nil rationals nil)) shostak (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)")) (Eval_real_TCC60-1 nil 3703422932 ("" (termination-tcc)) nil nil (Eval_real subtype "cauchy_expr_eval.res" "(Maybe[real].some?)"))) (Eval_TCC1 0 (Eval_TCC1-1 nil 3675163044 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval termination "cauchy_expr_eval.Eval(cauchy_expr_eval.prec)(cauchy_expr_eval.re2, cauchy_expr_eval.vars)" "nil"))) (Eval_TCC2 0 (Eval_TCC2-2 "" 3790106141 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res1" "(Maybe[cauchy_real].some?)")) (Eval_TCC2-1 nil 3675163044 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res1" "(Maybe[cauchy_real].some?)"))) (Eval_TCC3 0 (Eval_TCC3-2 "" 3790106142 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res2" "(Maybe[cauchy_real].some?)")) (Eval_TCC3-1 nil 3675163044 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res2" "(Maybe[cauchy_real].some?)"))) (Eval_TCC4 0 (Eval_TCC4-2 "" 3790106142 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)")) (Eval_TCC4-1 nil 3675163044 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)"))) (Eval_TCC5 0 (Eval_TCC5-1 nil 3675167772 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval termination "cauchy_expr_eval.Eval(cauchy_expr_eval.prec)(cauchy_expr_eval.re2, cauchy_expr_eval.vars)" "nil"))) (Eval_TCC6 0 (Eval_TCC6-2 "" 3790106142 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res1" "(Maybe[cauchy_real].some?)")) (Eval_TCC6-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res1" "(Maybe[cauchy_real].some?)"))) (Eval_TCC7 0 (Eval_TCC7-2 "" 3790106142 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res2" "(Maybe[cauchy_real].some?)")) (Eval_TCC7-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res2" "(Maybe[cauchy_real].some?)"))) (Eval_TCC8 0 (Eval_TCC8-1 nil 3675167772 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval termination "cauchy_expr_eval.Eval(cauchy_expr_eval.prec)(cauchy_expr_eval.re2, cauchy_expr_eval.vars)" "nil"))) (Eval_TCC9 0 (Eval_TCC9-2 "" 3790106142 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res1" "(Maybe[cauchy_real].some?)")) (Eval_TCC9-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res1" "(Maybe[cauchy_real].some?)"))) (Eval_TCC10 0 (Eval_TCC10-2 "" 3790106143 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res2" "(Maybe[cauchy_real].some?)")) (Eval_TCC10-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res2" "(Maybe[cauchy_real].some?)"))) (Eval_TCC11 0 (Eval_TCC11-2 "" 3790106143 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)")) (Eval_TCC11-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)"))) (Eval_TCC12 0 (Eval_TCC12-2 "" 3790106143 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.opn" "posnat")) (Eval_TCC12-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.opn" "posnat"))) (Eval_TCC13 0 (Eval_TCC13-2 "" 3790106143 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)")) (Eval_TCC13-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)"))) (Eval_TCC14 0 (Eval_TCC14-1 nil 3675167772 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval termination "cauchy_expr_eval.Eval(cauchy_expr_eval.prec)(cauchy_expr_eval.re2, cauchy_expr_eval.vars)" "nil"))) (Eval_TCC15 0 (Eval_TCC15-2 "" 3790106143 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res1" "(Maybe[cauchy_real].some?)")) (Eval_TCC15-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res1" "(Maybe[cauchy_real].some?)"))) (Eval_TCC16 0 (Eval_TCC16-2 "" 3790106143 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res2" "(Maybe[cauchy_real].some?)")) (Eval_TCC16-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res2" "(Maybe[cauchy_real].some?)"))) (Eval_TCC17 0 (Eval_TCC17-1 nil 3675167772 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval termination "cauchy_expr_eval.Eval(cauchy_expr_eval.prec)(cauchy_expr_eval.re2, cauchy_expr_eval.vars)" "nil"))) (Eval_TCC18 0 (Eval_TCC18-2 "" 3790106144 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res1" "(Maybe[cauchy_real].some?)")) (Eval_TCC18-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res1" "(Maybe[cauchy_real].some?)"))) (Eval_TCC19 0 (Eval_TCC19-2 "" 3790106144 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res2" "(Maybe[cauchy_real].some?)")) (Eval_TCC19-1 nil 3675167772 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res2" "(Maybe[cauchy_real].some?)"))) (Eval_TCC20 0 (Eval_TCC20-2 "" 3790106144 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)")) (Eval_TCC20-1 nil 3675439966 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)"))) (Eval_TCC21 0 (Eval_TCC21-2 "" 3790106144 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)")) (Eval_TCC21-1 nil 3675439966 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)"))) (Eval_TCC22 0 (Eval_TCC22-1 nil 3675504553 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval termination "cauchy_expr_eval.Eval(cauchy_expr_eval.prec)(cauchy_expr_eval.re2, cauchy_expr_eval.vars)" "nil"))) (Eval_TCC23 0 (Eval_TCC23-2 "" 3790106144 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res2" "(Maybe[cauchy_real].some?)")) (Eval_TCC23-1 nil 3675504553 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res2" "(Maybe[cauchy_real].some?)"))) (Eval_TCC24 0 (Eval_TCC24-2 "" 3790106144 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res1" "(Maybe[cauchy_real].some?)")) (Eval_TCC24-1 nil 3675504553 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res1" "(Maybe[cauchy_real].some?)"))) (Eval_TCC25 0 (Eval_TCC25-2 "" 3804542027 ("" (skeep) (("" (skeep) (("" (hide-all-but (3 4)) (("" (expand "cauchy_nzreal?") (("" (expand "cauchy_prop") (("" (typepred "val(res2)") (("" (expand "cauchy_real?") (("" (skeep) (("" (expand "cauchy_prop") (("" (inst 2 "x") (("" (inst -1 "prec") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_nzreal? const-decl "bool" cauchy nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (x skolem-const-decl "real" cauchy_expr_eval nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (cauchy_prop const-decl "bool" cauchy nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res2)" "cauchy_nzreal")) (Eval_TCC25-1 nil 3675504553 ("" (skeep) (("" (skeep) (("" (skeep) (("" (hide-all-but (2 4)) (("" (expand "cauchy_nzreal?") (("" (expand "cauchy_prop") (("" (typepred "val(res2)") (("" (expand "cauchy_real?") (("" (skeep) (("" (expand "cauchy_prop") (("" (inst 2 "x") (("" (inst -1 "prec") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_nzreal? const-decl "bool" cauchy nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_prop const-decl "bool" cauchy nil)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res2)" "cauchy_nzreal"))) (Eval_TCC26 0 (Eval_TCC26-2 "" 3790106145 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)")) (Eval_TCC26-1 nil 3675504553 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)"))) (Eval_TCC27 0 (Eval_TCC27-4 "" 3884787509 ("" (auto-rewrite-defs :always? t) (("" (assert :rewrite-flag nil :let-reduce? t :flush? nil :cases-rewrite? nil :type-constraints? t :ignore-prover-output? nil :quant-simp? nil :implicit-typepreds? nil :ignore-typepreds? nil) (("" (skolem-typepred) (("" (flatten) (("" (skolem-typepred) (("" (flatten) (("" (replace* :dir nil :hide? nil :actuals? nil :dont-delete? nil) (("" (assert :rewrite-flag nil :let-reduce? t :flush? nil :cases-rewrite? nil :type-constraints? t :ignore-prover-output? nil :quant-simp? nil :implicit-typepreds? nil :ignore-typepreds? nil) (("" (inst? :if-match t :polarity? nil :where *) (("" (skolem-typepred) (("" (replace* :dir nil :hide? nil :actuals? nil :dont-delete? nil) (("" (assert :rewrite-flag nil :let-reduce? t :flush? nil :cases-rewrite? nil :type-constraints? t :ignore-prover-output? nil :quant-simp? nil :implicit-typepreds? nil :ignore-typepreds? nil) (("" (assert :flush? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_noninteger")) (Eval_TCC27-3 "" 3804543153 ("" (auto-rewrite-defs :always? t) (("" (assert :rewrite-flag nil :let-reduce? t :flush? nil :linear? nil :cases-rewrite? nil :type-constraints? t :ignore-prover-output? nil :quant-simp? nil :implicit-typepreds? nil :ignore-typepreds? nil) (("" (skolem-typepred) (("" (flatten) (("" (skolem-typepred) (("" (flatten) (("" (replace* :dir nil :hide? nil :actuals? nil :dont-delete? nil) (("" (assert :rewrite-flag nil :let-reduce? t :flush? nil :linear? nil :cases-rewrite? nil :type-constraints? t :ignore-prover-output? nil :quant-simp? nil :implicit-typepreds? nil :ignore-typepreds? nil) (("" (inst? :if-match t :polarity? nil :where *) (("" (skolem-typepred) (("" (replace* :dir nil :hide? nil :actuals? nil :dont-delete? nil) (("" (assert :rewrite-flag nil :let-reduce? t :flush? nil :linear? nil :cases-rewrite? nil :type-constraints? t :ignore-prover-output? nil :quant-simp? nil :implicit-typepreds? nil :ignore-typepreds? nil) (("" (assert :flush? t) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posnat_expt application-judgement "posnat" exponentiation nil) (cauchy_noninteger? const-decl "bool" floor nil) (divides const-decl "bool" divides nil) (^ const-decl "real" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_times_int_is_int application-judgement "int" integers nil) (rat nonempty-type-eq-decl nil rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_noninteger")) (Eval_TCC27-2 "" 3790106145 ("" (termination-tcc) nil nil) ((cauchy_noninteger? const-decl "bool" floor nil)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_noninteger")) (Eval_TCC27-1 nil 3675504553 ("" (termination-tcc)) ((cauchy_noninteger? const-decl "bool" floor nil)) nil (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_noninteger"))) (Eval_TCC28 0 (Eval_TCC28-2 "" 3790106145 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)")) (Eval_TCC28-1 nil 3675504553 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)"))) (Eval_TCC29 0 (Eval_TCC29-2 "" 3804543226 ("" (skeep) (("" (hide-all-but (2 3)) (("" (typepred "val(res)") (("" (expand "cauchy_nnreal?") (("" (expand "cauchy_real?") (("" (skeep) (("" (inst 2 "x") (("" (expand "cauchy_prop") (("" (inst -1 "prec") (("" (flatten) (("" (typepred "val(res)(prec)") (("" (case "val(res)(prec) >= 1 AND 2 ^ prec > 0") (("1" (flatten) (("1" (lemma "lt_plus_lt1") (("1" (inst -1 "x * 2^prec" "1" "val(res)(prec)" "val(res)(prec) - 1") (("1" (split) (("1" (assert) (("1" (both-sides "-" "val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_nnreal? const-decl "bool" cauchy nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cauchy_prop const-decl "bool" cauchy nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (lt_plus_lt1 formula-decl nil real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (both_sides_minus_lt1 formula-decl nil real_props nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (x skolem-const-decl "real" cauchy_expr_eval nil) (nnreal type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_nnreal")) (Eval_TCC29-1 nil 3675504553 ("" (skeep) (("" (skeep) (("" (hide-all-but (1 3)) (("" (typepred "val(res)") (("" (expand "cauchy_nnreal?") (("" (expand "cauchy_real?") (("" (skeep) (("" (inst 2 "x") (("" (expand "cauchy_prop") (("" (inst -1 "prec") (("" (flatten) (("" (typepred "val(res)(prec)") (("" (case "val(res)(prec) >= 1 AND 2 ^ prec > 0") (("1" (flatten) (("1" (lemma "lt_plus_lt1") (("1" (inst -1 "x * 2^prec" "1" "val(res)(prec)" "val(res)(prec) - 1") (("1" (split) (("1" (assert) (("1" (both-sides "-" "val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_nnreal? const-decl "bool" cauchy nil) (cauchy_prop const-decl "bool" cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_nnreal"))) (Eval_TCC30 0 (Eval_TCC30-2 "" 3790106146 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)")) (Eval_TCC30-1 nil 3675504553 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)"))) (Eval_TCC31 0 (Eval_TCC31-2 "" 3804543350 ("" (skeep) (("" (hide-all-but (2 3)) (("" (expand "cauchy_posreal?") (("" (typepred "val(res)") (("" (expand "cauchy_real?") (("" (skeep) (("" (inst 2 "x") (("" (expand "cauchy_prop") (("" (inst -1 "prec") (("" (flatten) (("" (hide -2) (("" (case "val(res)(prec) >= 1 AND 2^prec > 0") (("1" (flatten) (("1" (lemma "lt_plus_lt1") (("1" (inst -1 "x * 2^prec" "1" "val(res)(prec)" "val(res)(prec) - 1") (("1" (split) (("1" (both-sides "-" "val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cauchy_prop const-decl "bool" cauchy nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (lt_plus_lt1 formula-decl nil real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_plus_lt1 formula-decl nil real_props nil) (both_sides_minus_lt1 formula-decl nil real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (x skolem-const-decl "real" cauchy_expr_eval nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cauchy_posreal? const-decl "bool" cauchy nil)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_posreal")) (Eval_TCC31-1 nil 3675504553 ("" (skeep) (("" (skeep) (("" (hide-all-but (1 3)) (("" (expand "cauchy_posreal?") (("" (typepred "val(res)") (("" (expand "cauchy_real?") (("" (skeep) (("" (inst 2 "x") (("" (expand "cauchy_prop") (("" (inst -1 "prec") (("" (flatten) (("" (hide -2) (("" (case "val(res)(prec) >= 1 AND 2^prec > 0") (("1" (flatten) (("1" (lemma "lt_plus_lt1") (("1" (inst -1 "x * 2^prec" "1" "val(res)(prec)" "val(res)(prec) - 1") (("1" (split) (("1" (both-sides "-" "val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_prop const-decl "bool" cauchy nil) (cauchy_posreal? const-decl "bool" cauchy nil)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_posreal"))) (Eval_TCC32 0 (Eval_TCC32-2 "" 3790106149 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)")) (Eval_TCC32-1 nil 3675592709 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)"))) (Eval_TCC33 0 (Eval_TCC33-3 "" 3884801186 ("" (skeep) (("" (expand "cauchy_real_abs_le1?") (("" (typepred "val(res)") (("" (expand "cauchy_real?") (("" (skeep) (("" (hide (-2 -3)) (("" (inst 2 "x") (("" (expand "cauchy_prop") (("" (inst -1 "prec") (("" (flatten) (("" (expand "abs") (("" (split) (("1" (case "val(res)(prec) < 0") (("1" (assert) (("1" (lemma "both_sides_times_neg_lt1") (("1" (inst -1 "-1" "2 ^ prec" "-val(res)(prec)") (("1" (flatten) (("1" (split -2) (("1" (hide (-2 2 -6)) (("1" (lemma "neg_one_times") (("1" (inst -1 "-val(res)(prec)") (("1" (replaces -1) (("1" (lemma "neg_neg") (("1" (inst -1 "val(res)(prec)") (("1" (replaces -1) (("1" (lemma "integer_lt_plus_1") (("1" (inst -1 "2 ^ prec * -1" "val(res)(prec)") (("1" (split) (("1" (both-sides "-" "1" -1) (("1" (assert) (("1" (lemma "lt_plus_lt1") (("1" (inst -1 "x * 2^prec" "2^prec * -1" "val(res)(prec) - 1" "val(res)(prec) - 1") (("1" (split) (("1" (case "2 ^ prec * -1 + (val(res)(prec) - 1) - (val(res)(prec) - 1) <
       val(res)(prec) - 1 + x * 2 ^ prec - (val(res)(prec) - 1)") (("1" (hide -2) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "x * 2^prec" "0" "val(res)(prec)" "val(res)(prec) - 1") (("2" (split) (("1" (both-sides "-" "val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "val(res)(prec) < 0") (("1" (assert) (("1" (both-sides "+" "1" -1) (("1" (lemma "lt_cut") (("1" (inst -1 "x * 2^prec" "1 + val(res)(prec)" "1") (("1" (split) (("1" (div-by -1 "2^prec") (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide (-1 1 3)) (("2" (lemma "integer_lt_plus_1") (("2" (inst -1 "val(res)(prec)" "2^prec") (("2" (assert) (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "1 + val(res)(prec)" "1 + val(res)(prec)" "2 ^ prec" "x * 2^prec") (("2" (split) (("1" (both-sides "-" "1 + val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2 ^ prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_real_abs_le1")) (Eval_TCC33-2 "" 3804543451 ("" (skeep) (("" (expand "cauchy_real_abs_le1?") (("" (typepred "val(res)") (("" (expand "cauchy_real?") (("" (skeep) (("" (hide (-2 -3)) (("" (inst 2 "x") (("" (expand "cauchy_prop") (("" (inst -1 "prec") (("" (flatten) (("" (expand "abs") (("" (split) (("1" (case "val(res)(prec) < 0") (("1" (assert) (("1" (lemma "both_sides_times_neg_lt1") (("1" (inst -1 "-1" "2 ^ prec" "-val(res)(prec)") (("1" (flatten) (("1" (split -2) (("1" (hide (-2 2 -6)) (("1" (lemma "neg_one_times") (("1" (inst -1 "-val(res)(prec)") (("1" (replaces -1) (("1" (lemma "neg_neg") (("1" (inst -1 "val(res)(prec)") (("1" (replaces -1) (("1" (lemma "integer_lt_plus_1") (("1" (inst -1 "2 ^ prec * -1" "val(res)(prec)") (("1" (split) (("1" (both-sides "-" "1" -1) (("1" (assert) (("1" (lemma "lt_plus_lt1") (("1" (inst -1 "x * 2^prec" "2^prec * -1" "val(res)(prec) - 1" "val(res)(prec) - 1") (("1" (split) (("1" (both-sides "-" "val(res)(prec) - 1" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "x * 2^prec" "0" "val(res)(prec)" "val(res)(prec) - 1") (("2" (split) (("1" (both-sides "-" "val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "val(res)(prec) < 0") (("1" (assert) (("1" (both-sides "+" "1" -1) (("1" (lemma "lt_cut") (("1" (inst -1 "x * 2^prec" "1 + val(res)(prec)" "1") (("1" (split) (("1" (div-by -1 "2^prec") (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide (-1 1 3)) (("2" (lemma "integer_lt_plus_1") (("2" (inst -1 "val(res)(prec)" "2^prec") (("2" (assert) (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "1 + val(res)(prec)" "1 + val(res)(prec)" "2 ^ prec" "x * 2^prec") (("2" (split) (("1" (both-sides "-" "1 + val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2 ^ prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_real_abs_le1? const-decl "bool" asinx nil) (posint_exp application-judgement "posint" exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (both_sides_minus_lt1 formula-decl nil real_props nil) (both_sides_plus_lt1 formula-decl nil real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nprat_div_posrat_is_nprat application-judgement "nprat" rationals nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (expt_inv_lt_1 formula-decl nil floor nil) (minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (negreal nonempty-type-eq-decl nil real_types nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (neg_one_times formula-decl nil extra_tegies nil) (TRUE const-decl "bool" booleans nil) (integer_lt_plus_1 formula-decl nil floor nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (lt_plus_lt1 formula-decl nil real_props nil) (both_sides_minus_le1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (odd? const-decl "bool" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (neg_neg formula-decl nil extra_tegies nil) (both_sides_times_neg_lt1 formula-decl nil real_props nil) (< const-decl "bool" reals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (both_sides_plus_lt2 formula-decl nil real_props nil) (both_sides_plus_le2 formula-decl nil real_props nil) (div_simp formula-decl nil real_props nil) (lt_cut formula-decl nil extra_real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (x skolem-const-decl "real" cauchy_expr_eval nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (real_abs_le1 nonempty-type-eq-decl nil trig_types trig_fnd) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_real_abs_le1")) (Eval_TCC33-1 nil 3675592709 ("" (skeep) (("" (skeep) (("" (expand "cauchy_real_abs_le1?") (("" (typepred "val(res)") (("" (expand "cauchy_real?") (("" (skeep) (("" (hide (-2 -4)) (("" (inst 2 "x") (("" (expand "cauchy_prop") (("" (inst -1 "prec") (("" (flatten) (("" (expand "abs") (("" (split) (("1" (case "val(res)(prec) < 0") (("1" (assert) (("1" (lemma "both_sides_times_neg_lt1") (("1" (inst -1 "-1" "2 ^ prec" "-val(res)(prec)") (("1" (flatten) (("1" (split -2) (("1" (hide (-2 2 -6)) (("1" (lemma "neg_one_times") (("1" (inst -1 "-val(res)(prec)") (("1" (replaces -1) (("1" (lemma "neg_neg") (("1" (inst -1 "val(res)(prec)") (("1" (replaces -1) (("1" (lemma "integer_lt_plus_1") (("1" (inst -1 "2 ^ prec * -1" "val(res)(prec)") (("1" (split) (("1" (both-sides "-" "1" -1) (("1" (assert) (("1" (lemma "lt_plus_lt1") (("1" (inst -1 "x * 2^prec" "2^prec * -1" "val(res)(prec) - 1" "val(res)(prec) - 1") (("1" (split) (("1" (both-sides "-" "val(res)(prec) - 1" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "x * 2^prec" "0" "val(res)(prec)" "val(res)(prec) - 1") (("2" (split) (("1" (both-sides "-" "val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "val(res)(prec) < 0") (("1" (assert) (("1" (both-sides "+" "1" -1) (("1" (lemma "lt_cut") (("1" (inst -1 "x * 2^prec" "1 + val(res)(prec)" "1") (("1" (split) (("1" (div-by -1 "2^prec") (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide (-1 1 3)) (("2" (lemma "integer_lt_plus_1") (("2" (inst -1 "val(res)(prec)" "2^prec") (("2" (assert) (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "1 + val(res)(prec)" "1 + val(res)(prec)" "2 ^ prec" "x * 2^prec") (("2" (split) (("1" (both-sides "-" "1 + val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2 ^ prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_real_abs_le1? const-decl "bool" asinx nil) (cauchy_prop const-decl "bool" cauchy nil) (expt_inv_lt_1 formula-decl nil floor nil) (integer_lt_plus_1 formula-decl nil floor nil) (real_abs_le1 nonempty-type-eq-decl nil trig_types trig_fnd) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_real_abs_le1"))) (Eval_TCC34 0 (Eval_TCC34-2 "" 3790106151 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)")) (Eval_TCC34-1 nil 3675603704 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)"))) (Eval_TCC35 0 (Eval_TCC35-1 nil 3675614809 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[CauchyExpr])" CauchyExpr_adt nil)) nil (Eval termination "cauchy_expr_eval.Eval(cauchy_expr_eval.prec)(cauchy_expr_eval.re2, cauchy_expr_eval.vars)" "nil"))) (Eval_TCC36 0 (Eval_TCC36-2 "" 3790106151 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res2" "(Maybe[cauchy_real].some?)")) (Eval_TCC36-1 nil 3675614809 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res2" "(Maybe[cauchy_real].some?)"))) (Eval_TCC37 0 (Eval_TCC37-2 "" 3790106152 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res1" "(Maybe[cauchy_real].some?)")) (Eval_TCC37-1 nil 3675614809 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res1" "(Maybe[cauchy_real].some?)"))) (Eval_TCC38 0 (Eval_TCC38-2 "" 3804543523 ("" (skeep*) (("" (hide (1 2)) (("" (expand "cauchy_nzreal?") (("" (typepred "val(res2)") (("" (expand "cauchy_real?") (("" (skeep) (("" (inst 2 "x") (("" (expand "cauchy_prop") (("" (inst -1 "prec") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cauchy_prop const-decl "bool" cauchy nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (x skolem-const-decl "real" cauchy_expr_eval nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res2)" "cauchy_nzreal")) (Eval_TCC38-1 nil 3675614809 ("" (skeep*) (("" (hide (1 3)) (("" (expand "cauchy_nzreal?") (("" (typepred "val(res2)") (("" (expand "cauchy_real?") (("" (skeep) (("" (inst 2 "x") (("" (expand "cauchy_prop") (("" (inst -1 "prec") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_prop const-decl "bool" cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res2)" "cauchy_nzreal"))) (Eval_TCC39 0 (Eval_TCC39-2 "" 3804543575 ("" (skeep*) (("" (hide (-1 -2 -3 1 2)) (("" (split) (("1" (hide (-1 3)) (("1" (expand "cauchy_nzreal?") (("1" (typepred "val(res2)") (("1" (expand "cauchy_real?") (("1" (skeep) (("1" (inst 1 "x") (("1" (expand "cauchy_prop") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cauchy_noninteger?") (("2" (inst 1 "prec") (("2" (expand "divides") (("2" (skeep) (("2" (replaces -2 :dir rl) (("2" (div-by -1 "2^prec") (("2" (typepred "floor(d(prec) / 2^prec)") (("2" (replaces -3) (("2" (typepred "x") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_noninteger? const-decl "bool" floor nil) (divides const-decl "bool" divides nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (<= const-decl "bool" reals nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (times_div_cancel1 formula-decl nil extra_real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (both_sides_div1 formula-decl nil real_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cauchy_prop const-decl "bool" cauchy nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (x skolem-const-decl "real" cauchy_expr_eval nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res2)" "{c: cauchy.cauchy_nzreal | floor.cauchy_noninteger?(div.cauchy_div(Maybe[cauchy_real].val(cauchy_expr_eval.res1), c))}")) (Eval_TCC39-1 nil 3675614809 ("" (skeep*) (("" (hide (-1 -2 -3 1 3)) (("" (split) (("1" (hide (-1 3)) (("1" (expand "cauchy_nzreal?") (("1" (typepred "val(res2)") (("1" (expand "cauchy_real?") (("1" (skeep) (("1" (inst 1 "x") (("1" (expand "cauchy_prop") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cauchy_noninteger?") (("2" (inst 1 "prec") (("2" (expand "divides") (("2" (skeep) (("2" (replaces -2 :dir rl) (("2" (div-by -1 "2^prec") (("2" (typepred "floor(d(prec) / 2^prec)") (("2" (replaces -3) (("2" (typepred "x") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_noninteger? const-decl "bool" floor nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_prop const-decl "bool" cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res2)" "{c: cauchy.cauchy_nzreal | floor.cauchy_noninteger?(div.cauchy_div(Maybe[cauchy_real].val(cauchy_expr_eval.res1), c))}"))) (Eval_TCC40 0 (Eval_TCC40-2 "" 3790106152 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)")) (Eval_TCC40-1 nil 3703422932 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)"))) (Eval_TCC41 0 (Eval_TCC41-5 "" 3884801658 ("" (skeep*) (("" (expand "cauchy_real_abs_le1?") (("" (typepred "val(res)") (("" (expand "cauchy_real?") (("" (skeep) (("" (hide (-2 -3)) (("" (inst 2 "x") (("" (expand "cauchy_prop") (("" (inst -1 "prec") (("" (flatten) (("" (expand "abs") (("" (split) (("1" (case "val(res)(prec) < 0") (("1" (assert) (("1" (lemma "both_sides_times_neg_lt1") (("1" (inst -1 "-1" "2 ^ prec" "-val(res)(prec)") (("1" (flatten) (("1" (split -2) (("1" (hide (-2 2 -6)) (("1" (lemma "neg_one_times") (("1" (inst -1 "-val(res)(prec)") (("1" (replaces -1) (("1" (lemma "neg_neg") (("1" (inst -1 "val(res)(prec)") (("1" (replaces -1) (("1" (lemma "integer_lt_plus_1") (("1" (inst -1 "2 ^ prec * -1" "val(res)(prec)") (("1" (split) (("1" (both-sides "-" "1" -1) (("1" (assert) (("1" (lemma "lt_plus_lt1") (("1" (inst -1 "x * 2^prec" "2^prec * -1" "val(res)(prec) - 1" "val(res)(prec) - 1") (("1" (split) (("1" (case "2 ^ prec * -1 + (val(res)(prec) - 1) - (val(res)(prec) - 1) <
       val(res)(prec) - 1 + x * 2 ^ prec - (val(res)(prec) - 1)") (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "x * 2^prec" "0" "val(res)(prec)" "val(res)(prec) - 1") (("2" (split) (("1" (both-sides "-" "val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "val(res)(prec) < 0") (("1" (assert) (("1" (both-sides "+" "1" -1) (("1" (lemma "lt_cut") (("1" (inst -1 "x * 2^prec" "1 + val(res)(prec)" "1") (("1" (split) (("1" (div-by -1 "2^prec") (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide (-1 1 3)) (("2" (lemma "integer_lt_plus_1") (("2" (inst -1 "val(res)(prec)" "2^prec") (("2" (assert) (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "1 + val(res)(prec)" "1 + val(res)(prec)" "2 ^ prec" "x * 2^prec") (("2" (split) (("1" (both-sides "-" "1 + val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2 ^ prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_real_abs_le1")) (Eval_TCC41-4 "" 3804547261 ("" (skeep*) (("" (expand "cauchy_real_abs_le1?") (("" (typepred "val(res)") (("" (expand "cauchy_real?") (("" (skeep) (("" (hide (-2 -3)) (("" (inst 2 "x") (("" (expand "cauchy_prop") (("" (inst -1 "prec") (("" (flatten) (("" (expand "abs") (("" (split) (("1" (case "val(res)(prec) < 0") (("1" (assert) (("1" (lemma "both_sides_times_neg_lt1") (("1" (inst -1 "-1" "2 ^ prec" "-val(res)(prec)") (("1" (flatten) (("1" (split -2) (("1" (hide (-2 2 -6)) (("1" (lemma "neg_one_times") (("1" (inst -1 "-val(res)(prec)") (("1" (replaces -1) (("1" (lemma "neg_neg") (("1" (inst -1 "val(res)(prec)") (("1" (replaces -1) (("1" (lemma "integer_lt_plus_1") (("1" (inst -1 "2 ^ prec * -1" "val(res)(prec)") (("1" (split) (("1" (both-sides "-" "1" -1) (("1" (assert) (("1" (lemma "lt_plus_lt1") (("1" (inst -1 "x * 2^prec" "2^prec * -1" "val(res)(prec) - 1" "val(res)(prec) - 1") (("1" (split) (("1" (both-sides "-" "val(res)(prec) - 1" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "x * 2^prec" "0" "val(res)(prec)" "val(res)(prec) - 1") (("2" (split) (("1" (both-sides "-" "val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "val(res)(prec) < 0") (("1" (assert) (("1" (both-sides "+" "1" -1) (("1" (lemma "lt_cut") (("1" (inst -1 "x * 2^prec" "1 + val(res)(prec)" "1") (("1" (split) (("1" (div-by -1 "2^prec") (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide (-1 1 3)) (("2" (lemma "integer_lt_plus_1") (("2" (inst -1 "val(res)(prec)" "2^prec") (("2" (assert) (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "1 + val(res)(prec)" "1 + val(res)(prec)" "2 ^ prec" "x * 2^prec") (("2" (split) (("1" (both-sides "-" "1 + val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2 ^ prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_real_abs_le1? const-decl "bool" asinx nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (both_sides_minus_lt1 formula-decl nil real_props nil) (both_sides_plus_lt1 formula-decl nil real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nprat_div_posrat_is_nprat application-judgement "nprat" rationals nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (expt_inv_lt_1 formula-decl nil floor nil) (minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (negreal nonempty-type-eq-decl nil real_types nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (neg_one_times formula-decl nil extra_tegies nil) (integer_lt_plus_1 formula-decl nil floor nil) (real_minus_real_is_real application-judgement "real" reals nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (lt_plus_lt1 formula-decl nil real_props nil) (both_sides_minus_le1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (odd? const-decl "bool" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (neg_neg formula-decl nil extra_tegies nil) (both_sides_times_neg_lt1 formula-decl nil real_props nil) (< const-decl "bool" reals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (both_sides_plus_lt2 formula-decl nil real_props nil) (both_sides_plus_le2 formula-decl nil real_props nil) (div_simp formula-decl nil real_props nil) (lt_cut formula-decl nil extra_real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (x skolem-const-decl "real" cauchy_expr_eval nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (real_abs_le1 nonempty-type-eq-decl nil trig_types trig_fnd) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_real_abs_le1")) (Eval_TCC41-3 nil 3703430522 ("" (skeep*) (("" (expand "cauchy_real_abs_le1?") (("" (typepred "val(res)") (("" (expand "cauchy_real?") (("" (skeep) (("" (hide (-2 -4)) (("" (inst 2 "x") (("" (expand "cauchy_prop") (("" (inst -1 "prec") (("" (flatten) (("" (expand "abs") (("" (split) (("1" (case "val(res)(prec) < 0") (("1" (assert) (("1" (lemma "both_sides_times_neg_lt1") (("1" (inst -1 "-1" "2 ^ prec" "-val(res)(prec)") (("1" (flatten) (("1" (split -2) (("1" (hide (-2 2 -6)) (("1" (lemma "neg_one_times") (("1" (inst -1 "-val(res)(prec)") (("1" (replaces -1) (("1" (lemma "neg_neg") (("1" (inst -1 "val(res)(prec)") (("1" (replaces -1) (("1" (lemma "integer_lt_plus_1") (("1" (inst -1 "2 ^ prec * -1" "val(res)(prec)") (("1" (split) (("1" (both-sides "-" "1" -1) (("1" (assert) (("1" (lemma "lt_plus_lt1") (("1" (inst -1 "x * 2^prec" "2^prec * -1" "val(res)(prec) - 1" "val(res)(prec) - 1") (("1" (split) (("1" (both-sides "-" "val(res)(prec) - 1" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "x * 2^prec" "0" "val(res)(prec)" "val(res)(prec) - 1") (("2" (split) (("1" (both-sides "-" "val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "val(res)(prec) < 0") (("1" (assert) (("1" (both-sides "+" "1" -1) (("1" (lemma "lt_cut") (("1" (inst -1 "x * 2^prec" "1 + val(res)(prec)" "1") (("1" (split) (("1" (div-by -1 "2^prec") (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide (-1 1 3)) (("2" (lemma "integer_lt_plus_1") (("2" (inst -1 "val(res)(prec)" "2^prec") (("2" (assert) (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "1 + val(res)(prec)" "1 + val(res)(prec)" "2 ^ prec" "x * 2^prec") (("2" (split) (("1" (both-sides "-" "1 + val(res)(prec)" -1) (("1" (assert) (("1" (div-by -1 "2 ^ prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_real_abs_le1? const-decl "bool" asinx nil) (cauchy_prop const-decl "bool" cauchy nil) (expt_inv_lt_1 formula-decl nil floor nil) (integer_lt_plus_1 formula-decl nil floor nil) (real_abs_le1 nonempty-type-eq-decl nil trig_types trig_fnd) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures)) shostak (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_real_abs_le1")) (Eval_TCC41-2 nil 3703430356 ("" (skeep*) (("" (hide (1 3)) (("" (expand "cauchy_nzreal?") (("" (typepred "val(res2)") (("" (expand "cauchy_real?") (("" (skeep) (("" (inst 2 "x") (("" (expand "cauchy_prop") (("" (inst -1 "prec") (("" (flatten) (("" (assert) nil)))))))))))))))))))) nil) nil nil (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_real_abs_le1")) (Eval_TCC41-1 nil 3703422932 ("" (subtype-tcc) nil nil) nil nil (Eval subtype "Maybe[cauchy_real].val(cauchy_expr_eval.res)" "cauchy_real_abs_le1"))) (Eval_TCC42 0 (Eval_TCC42-2 "" 3790106154 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)")) (Eval_TCC42-1 nil 3703422932 ("" (termination-tcc)) nil nil (Eval subtype "cauchy_expr_eval.res" "(Maybe[cauchy_real].some?)"))) (eval_lemma_aux 0 (eval_lemma_aux-2 "" 3884803617 ("" (induct "re") (("1" (skeep) (("1" (inst -1 "prec" "vars") (("1" (grind) nil nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "Eval") (("2" (expand "Eval_real") (("2" (lemma "rat_lemma") (("2" (inst -1 "CONST1_var") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (expand "Eval") (("3" (expand "Eval_real") (("3" (case "VARIDX1_var >= length(vars)") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "rat_lemma") (("2" (inst -1 "nth(vars, VARIDX1_var)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (inst -1 "prec" "vars") (("4" (expand "Eval" (-3 1)) (("4" (expand "Eval_real" (-4 1)) (("4" (inst -2 "prec" "vars") (("4" (case "some?(Eval(prec)(ADD1_var, vars)) AND some?(Eval(prec)(ADD2_var, vars)) AND some?(Eval_real(ADD1_var, vars)) AND some?(Eval_real(ADD2_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "add_lemma") (("1" (inst -1 "val(Eval(prec)(ADD1_var, vars))" "val(Eval(prec)(ADD2_var, vars))" "val(Eval_real(ADD1_var, vars))" "val(Eval_real(ADD2_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (skeep) (("5" (inst -1 "prec" "vars") (("5" (expand "Eval" (-2 1)) (("5" (expand "Eval_real" (-3 1)) (("5" (case "some?(Eval(prec)(EXP1_var, vars)) AND some?(Eval_real(EXP1_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "exp_lemma") (("1" (inst -1 "val(Eval(prec)(EXP1_var, vars))" "val(Eval_real(EXP1_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep) (("6" (skeep) (("6" (inst -1 "prec" "vars") (("6" (inst -2 "prec" "vars") (("6" (expand "Eval" (-3 1)) (("6" (expand "Eval_real" (-4 1)) (("6" (case "some?(Eval(prec)(MULT1_var, vars)) AND some?(Eval(prec)(MULT2_var, vars)) AND some?(Eval_real(MULT1_var, vars)) AND some?(Eval_real(MULT2_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "mul_lemma") (("1" (inst -1 "val(Eval(prec)(MULT1_var, vars))" "val(Eval(prec)(MULT2_var, vars))" "val(Eval_real(MULT1_var, vars))" "val(Eval_real(MULT2_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skeep) (("7" (skeep) (("7" (inst -1 "prec" "vars") (("7" (expand "Eval" (-2 1)) (("7" (expand "Eval_real" (-3 1)) (("7" (case "some?(Eval(prec)(NEG1_var, vars)) AND some?(Eval_real(NEG1_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "neg_lemma") (("1" (inst -1 "val(Eval(prec)(NEG1_var, vars))" "val(Eval_real(NEG1_var, vars))") (("1" (flatten) (("1" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skeep) (("8" (skeep) (("8" (inst -1 "prec" "vars") (("8" (expand "Eval" (-2 1)) (("8" (expand "Eval_real" (-3 1)) (("8" (case "some?(Eval(prec)(POW1_var, vars)) AND some?(Eval_real(POW1_var, vars))") (("1" (flatten) (("1" (assert) (("1" (case "POW2_var = 0") (("1" (assert) (("1" (lemma "int_lemma") (("1" (inst -1 "1") nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "power_lemma") (("2" (inst -1 "val(Eval(prec)(POW1_var, vars))" "POW2_var" "val(Eval_real(POW1_var, vars))") (("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (skeep) (("9" (skeep) (("9" (inst -1 "prec" "vars") (("9" (inst -2 "prec" "vars") (("9" (expand "Eval" (-3 1)) (("9" (expand "Eval_real" (-4 1)) (("9" (case "some?(Eval(prec)(SUB1_var, vars)) AND some?(Eval(prec)(SUB2_var, vars)) AND some?(Eval_real(SUB1_var, vars)) AND some?(Eval_real(SUB2_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "sub_lemma") (("1" (inst -1 "val(Eval(prec)(SUB1_var, vars))" "val(Eval(prec)(SUB2_var, vars))" "val(Eval_real(SUB1_var, vars))" "val(Eval_real(SUB2_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (skeep) (("10" (skeep) (("10" (inst -1 "prec" "vars") (("10" (inst -2 "prec" "vars") (("10" (expand "Eval" (-3 1)) (("10" (expand "Eval_real" (-4 1)) (("10" (case "some?(Eval(prec)(MIN1_var, vars)) AND some?(Eval(prec)(MIN2_var, vars)) AND some?(Eval_real(MIN1_var, vars)) AND some?(Eval_real(MIN2_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "min_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (skeep) (("11" (skeep) (("11" (inst -1 "prec" "vars") (("11" (inst -2 "prec" "vars") (("11" (expand "Eval" (-3 1)) (("11" (expand "Eval_real" (-4 1)) (("11" (case "some?(Eval(prec)(MAX1_var, vars)) AND some?(Eval(prec)(MAX2_var, vars)) AND some?(Eval_real(MAX1_var, vars)) AND some?(Eval_real(MAX2_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "max_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (skeep) (("12" (skeep) (("12" (inst -1 "prec" "vars") (("12" (expand "Eval" (-2 1)) (("12" (expand "Eval_real" (-3 1)) (("12" (case "some?(Eval(prec)(SIN1_var, vars)) AND some?(Eval_real(SIN1_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "sin_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("13" (skeep) (("13" (skeep) (("13" (inst -1 "prec" "vars") (("13" (expand "Eval" (-2 1)) (("13" (expand "Eval_real" (-3 1)) (("13" (case "some?(Eval(prec)(COS1_var, vars)) AND some?(Eval_real(COS1_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "cos_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("14" (skeep) (("14" (skeep) (("14" (inst -1 "prec" "vars") (("14" (expand "Eval" (-3 1)) (("14" (expand "Eval_real" (-4 1)) (("14" (case "some?(Eval(prec)(DIV1_var, vars)) AND some?(Eval(prec)(DIV2_var, vars)) AND some?(Eval_real(DIV1_var, vars)) AND some?(Eval_real(DIV2_var, vars)) AND val(Eval_real(DIV2_var, vars)) /= 0 AND val(Eval(prec)(DIV2_var, vars))(prec) /= 0") (("1" (flatten) (("1" (inst -6 "prec" "vars") (("1" (assert) (("1" (lemma "div_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("15" (skeep) (("15" (skeep) (("15" (inst -1 "prec" "vars") (("15" (expand "Eval" (-2 1)) (("15" (expand "Eval_real" (-3 1)) (("15" (case "some?(Eval(prec)(SQRT1_var, vars)) AND some?(Eval_real(SQRT1_var, vars)) AND val(Eval(prec)(SQRT1_var, vars))(prec) > 0 AND val(Eval_real(SQRT1_var, vars)) >= 0") (("1" (flatten) (("1" (assert) (("1" (lemma "sqrt_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("16" (skeep) (("16" (skeep) (("16" (inst -1 "prec" "vars") (("16" (expand "Eval" (-2 1)) (("16" (expand "Eval_real" (-3 1)) (("16" (case "some?(Eval(prec)(FLOOR1_var, vars)) AND some?(Eval_real(FLOOR1_var, vars)) AND floor(val(Eval(prec)(FLOOR1_var, vars))(prec) / 2^prec) /= val(Eval(prec)(FLOOR1_var, vars))(prec) / 2^prec") (("1" (flatten) (("1" (assert) (("1" (lemma "floor_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("17" (skeep) (("17" (skeep) (("17" (inst -1 "prec" "vars") (("17" (expand "Eval" (-2 1)) (("17" (expand "Eval_real" (-3 1)) (("17" (case "some?(Eval(prec)(LN1_var, vars)) AND some?(Eval_real(LN1_var, vars)) AND val(Eval(prec)(LN1_var, vars))(prec) > 0 AND val(Eval_real(LN1_var, vars)) > 0") (("1" (flatten) (("1" (assert) (("1" (lemma "ln_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("18" (skeep) (("18" (hide (-1 -2)) (("18" (expand "Eval_real") (("18" (expand "Eval") (("18" (lemma "pi_lemma") (("18" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("19" (skeep) (("19" (skeep) (("19" (inst -1 "prec" "vars") (("19" (expand "Eval_real" (-3 1)) (("19" (expand "Eval" (-2 1)) (("19" (case "some?(Eval(prec)(ACOS1_var, vars)) AND some?(Eval_real(ACOS1_var, vars)) AND abs(val(Eval_real(ACOS1_var, vars))) <= 1 AND abs(val(Eval(prec)(ACOS1_var, vars))(prec)) < 2^prec") (("1" (flatten) (("1" (assert) (("1" (lemma "acos_lemma") (("1" (inst -1 "val(Eval(prec)(ACOS1_var, vars))" "val(Eval_real(ACOS1_var, vars))") (("1" (split) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("20" (skeep) (("20" (skeep) (("20" (inst -1 "prec" "vars") (("20" (expand "Eval" (-2 1)) (("20" (expand "Eval_real" (-3 1)) (("20" (case "some?(Eval_real(ABS1_var, vars)) AND some?(Eval(prec)(ABS1_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "abs_lemma") (("1" (inst -1 "val(Eval(prec)(ABS1_var, vars))" "val(Eval_real(ABS1_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("21" (skeep) (("21" (skeep) (("21" (inst -1 "prec" "vars") (("21" (inst -2 "prec" "vars") (("21" (expand "Eval" (-3 1)) (("21" (expand "Eval_real" (-4 1)) (("21" (case "some?(Eval(prec)(MOD1_var, vars)) AND some?(Eval(prec)(MOD2_var, vars)) AND some?(Eval_real(MOD1_var, vars)) AND some?(Eval_real(MOD2_var, vars)) AND val(Eval(prec)(MOD2_var, vars))(prec) /= 0 AND floor(cauchy_div(val(Eval(prec)(MOD1_var, vars)), val(Eval(prec)(MOD2_var, vars)))(prec) / 2^prec) /= cauchy_div(val(Eval(prec)(MOD1_var, vars)), val(Eval(prec)(MOD2_var, vars)))(prec) / 2^prec") (("1" (flatten) (("1" (assert) (("1" (case "val(Eval_real(MOD2_var, vars)) /= 0") (("1" (assert) (("1" (lemma "mod_lemma") (("1" (inst -1 "val(Eval(prec)(MOD1_var, vars))" "val(Eval(prec)(MOD2_var, vars))" "val(Eval_real(MOD1_var, vars))" "val(Eval_real(MOD2_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (hide-all-but (1 3)) (("4" (expand "cauchy_noninteger?") (("4" (inst 1 "prec") (("4" (lemma "divides_floor") (("4" (inst -1 "cauchy_div(val(Eval(prec)(MOD1_var, vars)), val(Eval(prec)(MOD2_var, vars)))(prec)" "2^prec") (("4" (flatten) (("4" (split -2) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil)) nil) ("3" (split) (("1" (assert) (("1" (split) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (case "val(Eval_real(MOD2_var, vars)) /= 0") (("1" (assert) (("1" (hide-all-but (-1 -2 2)) (("1" (expand "cauchy_nzreal?") (("1" (inst 1 "val(Eval_real(MOD2_var, vars))") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("22" (skeep*) (("22" (inst -1 "prec" "vars") (("22" (expand "Eval_real" (-3 1)) (("22" (expand "Eval" (-2 1)) (("22" (case "some?(Eval(prec)(ASIN1_var, vars)) AND some?(Eval_real(ASIN1_var, vars)) AND abs(val(Eval_real(ASIN1_var, vars))) <= 1 AND abs(val(Eval(prec)(ASIN1_var, vars))(prec)) < 2^prec") (("1" (flatten) (("1" (assert) (("1" (lemma "asin_lemma") (("1" (inst -1 "val(Eval(prec)(ASIN1_var, vars))" "val(Eval_real(ASIN1_var, vars))") (("1" (split) (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("23" (skeep*) (("23" (inst -1 "prec" "vars") (("23" (expand "Eval" (-2 1)) (("23" (expand "Eval_real" (-3 1)) (("23" (case "some?(Eval_real(ATAN1_var, vars)) AND some?(Eval(prec)(ATAN1_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "atan_lemma") (("1" (inst -1 "val(Eval(prec)(ATAN1_var, vars))" "val(Eval_real(ATAN1_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (eval_lemma_aux-1 nil 3675513376 ("" (induct "re") (("1" (skeep) (("1" (inst -1 "prec" "vars") (("1" (grind) nil nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "Eval") (("2" (expand "Eval_real") (("2" (lemma "rat_lemma") (("2" (inst -1 "CONST1_var") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (expand "Eval") (("3" (expand "Eval_real") (("3" (case "VARIDX1_var >= length(vars)") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "rat_lemma") (("2" (inst -1 "nth(vars, VARIDX1_var)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (inst -1 "prec" "vars") (("4" (expand "Eval" (-3 1)) (("4" (expand "Eval_real" (-4 1)) (("4" (inst -2 "prec" "vars") (("4" (case "some?(Eval(prec)(ADD1_var, vars)) AND some?(Eval(prec)(ADD2_var, vars)) AND some?(Eval_real(ADD1_var, vars)) AND some?(Eval_real(ADD2_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "add_lemma") (("1" (inst -1 "val(Eval(prec)(ADD1_var, vars))" "val(Eval(prec)(ADD2_var, vars))" "val(Eval_real(ADD1_var, vars))" "val(Eval_real(ADD2_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (skeep) (("5" (inst -1 "prec" "vars") (("5" (expand "Eval" (-2 1)) (("5" (expand "Eval_real" (-3 1)) (("5" (case "some?(Eval(prec)(EXP1_var, vars)) AND some?(Eval_real(EXP1_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "exp_lemma") (("1" (inst -1 "val(Eval(prec)(EXP1_var, vars))" "val(Eval_real(EXP1_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep) (("6" (skeep) (("6" (inst -1 "prec" "vars") (("6" (inst -2 "prec" "vars") (("6" (expand "Eval" (-3 1)) (("6" (expand "Eval_real" (-4 1)) (("6" (case "some?(Eval(prec)(MULT1_var, vars)) AND some?(Eval(prec)(MULT2_var, vars)) AND some?(Eval_real(MULT1_var, vars)) AND some?(Eval_real(MULT2_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "mul_lemma") (("1" (inst -1 "val(Eval(prec)(MULT1_var, vars))" "val(Eval(prec)(MULT2_var, vars))" "val(Eval_real(MULT1_var, vars))" "val(Eval_real(MULT2_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skeep) (("7" (skeep) (("7" (inst -1 "prec" "vars") (("7" (expand "Eval" (-2 1)) (("7" (expand "Eval_real" (-3 1)) (("7" (case "some?(Eval(prec)(NEG1_var, vars)) AND some?(Eval_real(NEG1_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "neg_lemma") (("1" (inst -1 "val(Eval(prec)(NEG1_var, vars))" "val(Eval_real(NEG1_var, vars))") (("1" (flatten) (("1" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skeep) (("8" (skeep) (("8" (inst -1 "prec" "vars") (("8" (expand "Eval" (-2 1)) (("8" (expand "Eval_real" (-3 1)) (("8" (case "some?(Eval(prec)(POW1_var, vars)) AND some?(Eval_real(POW1_var, vars))") (("1" (flatten) (("1" (assert) (("1" (case "POW2_var = 0") (("1" (assert) (("1" (lemma "int_lemma") (("1" (inst -1 "1") nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "power_lemma") (("2" (inst -1 "val(Eval(prec)(POW1_var, vars))" "POW2_var" "val(Eval_real(POW1_var, vars))") (("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (skeep) (("9" (skeep) (("9" (inst -1 "prec" "vars") (("9" (inst -2 "prec" "vars") (("9" (expand "Eval" (-3 1)) (("9" (expand "Eval_real" (-4 1)) (("9" (case "some?(Eval(prec)(SUB1_var, vars)) AND some?(Eval(prec)(SUB2_var, vars)) AND some?(Eval_real(SUB1_var, vars)) AND some?(Eval_real(SUB2_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "sub_lemma") (("1" (inst -1 "val(Eval(prec)(SUB1_var, vars))" "val(Eval(prec)(SUB2_var, vars))" "val(Eval_real(SUB1_var, vars))" "val(Eval_real(SUB2_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (skeep) (("10" (skeep) (("10" (inst -1 "prec" "vars") (("10" (inst -2 "prec" "vars") (("10" (expand "Eval" (-3 1)) (("10" (expand "Eval_real" (-4 1)) (("10" (case "some?(Eval(prec)(MIN1_var, vars)) AND some?(Eval(prec)(MIN2_var, vars)) AND some?(Eval_real(MIN1_var, vars)) AND some?(Eval_real(MIN2_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "min_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (skeep) (("11" (skeep) (("11" (inst -1 "prec" "vars") (("11" (inst -2 "prec" "vars") (("11" (expand "Eval" (-3 1)) (("11" (expand "Eval_real" (-4 1)) (("11" (case "some?(Eval(prec)(MAX1_var, vars)) AND some?(Eval(prec)(MAX2_var, vars)) AND some?(Eval_real(MAX1_var, vars)) AND some?(Eval_real(MAX2_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "max_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (skeep) (("12" (skeep) (("12" (inst -1 "prec" "vars") (("12" (expand "Eval" (-2 1)) (("12" (expand "Eval_real" (-3 1)) (("12" (case "some?(Eval(prec)(SIN1_var, vars)) AND some?(Eval_real(SIN1_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "sin_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("13" (skeep) (("13" (skeep) (("13" (inst -1 "prec" "vars") (("13" (expand "Eval" (-2 1)) (("13" (expand "Eval_real" (-3 1)) (("13" (case "some?(Eval(prec)(COS1_var, vars)) AND some?(Eval_real(COS1_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "cos_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("14" (skeep) (("14" (skeep) (("14" (inst -1 "prec" "vars") (("14" (expand "Eval" (-3 1)) (("14" (expand "Eval_real" (-4 1)) (("14" (case "some?(Eval(prec)(DIV1_var, vars)) AND some?(Eval(prec)(DIV2_var, vars)) AND some?(Eval_real(DIV1_var, vars)) AND some?(Eval_real(DIV2_var, vars)) AND val(Eval_real(DIV2_var, vars)) /= 0 AND val(Eval(prec)(DIV2_var, vars))(prec) /= 0") (("1" (flatten) (("1" (inst -6 "prec" "vars") (("1" (assert) (("1" (lemma "div_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("15" (skeep) (("15" (skeep) (("15" (inst -1 "prec" "vars") (("15" (expand "Eval" (-2 1)) (("15" (expand "Eval_real" (-3 1)) (("15" (case "some?(Eval(prec)(SQRT1_var, vars)) AND some?(Eval_real(SQRT1_var, vars)) AND val(Eval(prec)(SQRT1_var, vars))(prec) > 0 AND val(Eval_real(SQRT1_var, vars)) >= 0") (("1" (flatten) (("1" (assert) (("1" (lemma "sqrt_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("16" (skeep) (("16" (skeep) (("16" (inst -1 "prec" "vars") (("16" (expand "Eval" (-2 1)) (("16" (expand "Eval_real" (-3 1)) (("16" (case "some?(Eval(prec)(FLOOR1_var, vars)) AND some?(Eval_real(FLOOR1_var, vars)) AND floor(val(Eval(prec)(FLOOR1_var, vars))(prec) / 2^prec) /= val(Eval(prec)(FLOOR1_var, vars))(prec) / 2^prec") (("1" (flatten) (("1" (assert) (("1" (lemma "floor_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("17" (skeep) (("17" (skeep) (("17" (inst -1 "prec" "vars") (("17" (expand "Eval" (-2 1)) (("17" (expand "Eval_real" (-3 1)) (("17" (case "some?(Eval(prec)(LN1_var, vars)) AND some?(Eval_real(LN1_var, vars)) AND val(Eval(prec)(LN1_var, vars))(prec) > 0 AND val(Eval_real(LN1_var, vars)) > 0") (("1" (flatten) (("1" (assert) (("1" (lemma "ln_lemma") (("1" (inst? -1) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("18" (skeep) (("18" (hide (-1 -2)) (("18" (expand "Eval_real") (("18" (expand "Eval") (("18" (lemma "pi_lemma") (("18" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("19" (skeep) (("19" (skeep) (("19" (inst -1 "prec" "vars") (("19" (expand "Eval_real" (-3 1)) (("19" (expand "Eval" (-2 1)) (("19" (case "some?(Eval(prec)(ACOS1_var, vars)) AND some?(Eval_real(ACOS1_var, vars)) AND abs(val(Eval_real(ACOS1_var, vars))) <= 1 AND abs(val(Eval(prec)(ACOS1_var, vars))(prec)) < 2^prec") (("1" (flatten) (("1" (assert) (("1" (lemma "acos_lemma") (("1" (inst -1 "val(Eval(prec)(ACOS1_var, vars))" "val(Eval_real(ACOS1_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("20" (skeep) (("20" (skeep) (("20" (inst -1 "prec" "vars") (("20" (expand "Eval" (-2 1)) (("20" (expand "Eval_real" (-3 1)) (("20" (case "some?(Eval_real(ABS1_var, vars)) AND some?(Eval(prec)(ABS1_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "abs_lemma") (("1" (inst -1 "val(Eval(prec)(ABS1_var, vars))" "val(Eval_real(ABS1_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("21" (skeep) (("21" (skeep) (("21" (inst -1 "prec" "vars") (("21" (inst -2 "prec" "vars") (("21" (expand "Eval" (-3 1)) (("21" (expand "Eval_real" (-4 1)) (("21" (case "some?(Eval(prec)(MOD1_var, vars)) AND some?(Eval(prec)(MOD2_var, vars)) AND some?(Eval_real(MOD1_var, vars)) AND some?(Eval_real(MOD2_var, vars)) AND val(Eval(prec)(MOD2_var, vars))(prec) /= 0 AND floor(cauchy_div(val(Eval(prec)(MOD1_var, vars)), val(Eval(prec)(MOD2_var, vars)))(prec) / 2^prec) /= cauchy_div(val(Eval(prec)(MOD1_var, vars)), val(Eval(prec)(MOD2_var, vars)))(prec) / 2^prec") (("1" (flatten) (("1" (assert) (("1" (case "val(Eval_real(MOD2_var, vars)) /= 0") (("1" (assert) (("1" (lemma "mod_lemma") (("1" (inst -1 "val(Eval(prec)(MOD1_var, vars))" "val(Eval(prec)(MOD2_var, vars))" "val(Eval_real(MOD1_var, vars))" "val(Eval_real(MOD2_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (hide-all-but (1 3)) (("4" (expand "cauchy_noninteger?") (("4" (inst 1 "prec") (("4" (lemma "divides_floor") (("4" (inst -1 "cauchy_div(val(Eval(prec)(MOD1_var, vars)), val(Eval(prec)(MOD2_var, vars)))(prec)" "2^prec") (("4" (flatten) (("4" (split -2) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil)) nil) ("3" (split) (("1" (assert) (("1" (split) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (case "val(Eval_real(MOD2_var, vars)) /= 0") (("1" (assert) (("1" (hide-all-but (-1 -2 2)) (("1" (expand "cauchy_nzreal?") (("1" (inst 1 "val(Eval_real(MOD2_var, vars))") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("22" (skeep*) (("22" (inst -1 "prec" "vars") (("22" (expand "Eval_real" (-3 1)) (("22" (expand "Eval" (-2 1)) (("22" (case "some?(Eval(prec)(ASIN1_var, vars)) AND some?(Eval_real(ASIN1_var, vars)) AND abs(val(Eval_real(ASIN1_var, vars))) <= 1 AND abs(val(Eval(prec)(ASIN1_var, vars))(prec)) < 2^prec") (("1" (flatten) (("1" (assert) (("1" (lemma "asin_lemma") (("1" (inst -1 "val(Eval(prec)(ASIN1_var, vars))" "val(Eval_real(ASIN1_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("23" (skeep*) (("23" (inst -1 "prec" "vars") (("23" (expand "Eval" (-2 1)) (("23" (expand "Eval_real" (-3 1)) (("23" (case "some?(Eval_real(ATAN1_var, vars)) AND some?(Eval(prec)(ATAN1_var, vars))") (("1" (flatten) (("1" (assert) (("1" (lemma "atan_lemma") (("1" (inst -1 "val(Eval(prec)(ATAN1_var, vars))" "val(Eval_real(ATAN1_var, vars))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((atan_lemma formula-decl nil atanx nil) (TRUE const-decl "bool" booleans nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}" atan_approx trig_fnd) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (asin_lemma formula-decl nil asinx nil) (cauchy_div const-decl "cauchy_real" div nil) (nzreal nonempty-type-eq-decl nil reals nil) (divides_floor formula-decl nil floor nil) (mod_lemma formula-decl nil modulo nil) (abs_lemma formula-decl nil abs nil) (acos_lemma formula-decl nil acosx nil) (cauchy_real_abs_le1? const-decl "bool" asinx nil) (cauchy_real_abs_le1 nonempty-type-eq-decl nil asinx nil) (real_abs_le1 nonempty-type-eq-decl nil trig_types trig_fnd) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (pi_lemma formula-decl nil atanx nil) (ln_lemma formula-decl nil log nil) (cauchy_posreal? const-decl "bool" cauchy nil) (cauchy_posreal nonempty-type-eq-decl nil cauchy nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (floor_lemma formula-decl nil floor nil) (cauchy_noninteger? const-decl "bool" floor nil) (cauchy_noninteger nonempty-type-eq-decl nil floor nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (integer nonempty-type-from-decl nil integers nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (sqrt_lemma formula-decl nil sqrtx nil) (cauchy_nnreal? const-decl "bool" cauchy nil) (cauchy_nnreal nonempty-type-eq-decl nil cauchy nil) (nnreal type-eq-decl nil real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (div_lemma formula-decl nil div nil) (/= const-decl "boolean" notequal nil) (cos_lemma formula-decl nil sincosx nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (sin_lemma formula-decl nil sincosx nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (max_lemma formula-decl nil max nil) (min_lemma formula-decl nil min nil) (real_minus_real_is_real application-judgement "real" reals nil) (sub_lemma formula-decl nil sub nil) (= const-decl "[T, T -> boolean]" equalities nil) (int_lemma formula-decl nil int nil) (power_lemma formula-decl nil power nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (neg_lemma formula-decl nil neg nil) (minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (mul_lemma formula-decl nil mul nil) (exp_lemma formula-decl nil exp nil) (cauchy_exp_is_posreal application-judgement "cauchy_posreal" exp nil) (real_plus_real_is_real application-judgement "real" reals nil) (add_lemma formula-decl nil add nil) (length def-decl "nat" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (posint_exp application-judgement "posint" exponentiation nil) (rat_lemma formula-decl nil computable_rat nil) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (CauchyExpr_induction formula-decl nil CauchyExpr_adt nil) (Eval def-decl "Maybe[cauchy_real]" cauchy_expr_eval nil) (Eval_real def-decl "Maybe[real]" cauchy_expr_eval nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cauchy_prop const-decl "bool" cauchy nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (rat nonempty-type-eq-decl nil rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (CauchyExpr type-decl nil CauchyExpr_adt nil)) shostak)) (eval_domain_inside_eval_real 0 (eval_domain_inside_eval_real-1 nil 3675507516 ("" (induct "re") (("1" (skeep) (("1" (skeep) (("1" (grind) nil nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (grind) nil nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (grind) nil nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (inst -1 "prec" "vars") (("4" (expand "Eval" -2) (("4" (expand "Eval_real" +) (("4" (case "some?(Eval(prec)(EXP1_var, vars))") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (skeep) (("5" (grind) nil nil)) nil)) nil) ("6" (skeep) (("6" (skeep) (("6" (grind) nil nil)) nil)) nil) ("7" (skeep) (("7" (skeep) (("7" (grind) nil nil)) nil)) nil) ("8" (skeep) (("8" (skeep) (("8" (grind) nil nil)) nil)) nil) ("9" (skeep) (("9" (skeep) (("9" (grind) nil nil)) nil)) nil) ("10" (skeep) (("10" (skeep) (("10" (grind) nil nil)) nil)) nil) ("11" (skeep) (("11" (skeep) (("11" (inst -1 "prec" "vars") (("11" (expand "Eval" -2) (("11" (expand "Eval_real" +) (("11" (assert) (("11" (case "some?(Eval(prec)(SIN1_var, vars))") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (skeep) (("12" (skeep) (("12" (expand "Eval" -2) (("12" (case "some?(Eval(prec)(COS1_var, vars))") (("1" (inst -2 "prec" "vars") (("1" (expand "Eval_real" +) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("13" (skeep) (("13" (skeep) (("13" (inst -1 "prec" "vars") (("13" (inst -2 "prec" "vars") (("13" (expand "Eval" -3) (("13" (expand "Eval_real" +) (("13" (case "some?(Eval(prec)(DIV1_var, vars)) AND some?(Eval(prec)(DIV2_var, vars))") (("1" (flatten) (("1" (assert) (("1" (case "val(Eval(prec)(DIV2_var, vars))(prec) = 0") (("1" (assert) nil nil) ("2" (hide-all-but +) (("2" (lemma "eval_lemma_aux") (("2" (inst -1 "prec" "DIV2_var" "vars") (("2" (assert) (("2" (expand "cauchy_prop") (("2" (inst -1 "prec") (("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("14" (skeep) (("14" (skeep) (("14" (inst -1 "prec" "vars") (("14" (expand "Eval" -2) (("14" (expand "Eval_real" +) (("14" (case "some?(Eval(prec)(SQRT1_var, vars))") (("1" (assert) (("1" (case "val(Eval(prec)(SQRT1_var, vars))(prec) <= 0") (("1" (assert) nil nil) ("2" (hide-all-but +) (("2" (lemma "eval_lemma_aux") (("2" (inst -1 "prec" "SQRT1_var" "vars") (("2" (assert) (("2" (expand "cauchy_prop") (("2" (inst -1 "prec") (("2" (flatten) (("2" (grind) (("2" (hide -2) (("2" (div-by -1 "expt(2, prec)") (("2" (lemma "lt_cut") (("2" (inst -1 "(val(Eval(prec)(SQRT1_var, vars))(prec) - 1) / expt(2, prec)" "val(Eval_real(SQRT1_var, vars))" "0") (("2" (split) (("1" (hide (-2 -3)) (("1" (mult-by -1 "expt(2, prec)") (("1" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("15" (skeep) (("15" (skeep) (("15" (grind) nil nil)) nil)) nil) ("16" (skeep) (("16" (skeep) (("16" (inst -1 "prec" "vars") (("16" (expand "Eval" -2) (("16" (expand "Eval_real" +) (("16" (case "some?(Eval(prec)(LN1_var, vars))") (("1" (assert) (("1" (case "val(Eval(prec)(LN1_var, vars))(prec) <= 0") (("1" (assert) nil nil) ("2" (hide-all-but +) (("2" (lemma "eval_lemma_aux") (("2" (inst -1 "prec" "LN1_var" "vars") (("2" (assert) (("2" (expand "cauchy_prop") (("2" (inst -1 "prec") (("2" (flatten) (("2" (grind) (("2" (hide -2) (("2" (div-by -1 "expt(2, prec)") (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "val(Eval_real(LN1_var, vars))" "val(Eval_real(LN1_var, vars))" "0" "(val(Eval(prec)(LN1_var, vars))(prec) - 1) / expt(2, prec)") (("2" (split) (("1" (hide (-2 -3)) (("1" (both-sides "-" "val(Eval_real(LN1_var, vars))" -1) (("1" (assert) (("1" (mult-by -1 "expt(2, prec)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("17" (skeep) (("17" (expand "Eval_real") (("17" (propax) nil nil)) nil)) nil) ("18" (skeep) (("18" (skeep) (("18" (inst -1 "prec" "vars") (("18" (expand "Eval" -2) (("18" (expand "Eval_real" +) (("18" (case "none?(Eval(prec)(ACOS1_var, vars))") (("1" (assert) nil nil) ("2" (assert) (("2" (hide 1) (("2" (case "abs(val(Eval(prec)(ACOS1_var, vars))(prec)) < 2^prec") (("1" (hide -3) (("1" (lemma "eval_lemma_aux") (("1" (inst -1 "prec" "ACOS1_var" "vars") (("1" (beta) (("1" (assert) (("1" (case "val(Eval(prec)(ACOS1_var, vars))(prec) < 0") (("1" (expand "abs" -) (("1" (assert) (("1" (expand "cauchy_prop") (("1" (inst -2 "prec") (("1" (flatten) (("1" (name "m" "val(Eval(prec)(ACOS1_var, vars))(prec)") (("1" (replaces -1) (("1" (case "abs(val(Eval_real(ACOS1_var, vars))) <= 1") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "abs") (("2" (case "val(Eval_real(ACOS1_var, vars)) < 0") (("1" (assert) (("1" (hide -6) (("1" (lemma "both_sides_times_neg_lt1") (("1" (inst -1 "-1" "val(Eval_real(ACOS1_var, vars)) * 2^prec" "m - 1") (("1" (flatten) (("1" (split -2) (("1" (hide -2) (("1" (assert) (("1" (hide-all-but (-1 -6 1)) (("1" (lemma "integer_lt_plus_1") (("1" (inst -1 "-m" "2^prec") (("1" (assert) (("1" (lemma "lt_plus_lt1") (("1" (inst -1 "1 - m" "1 - m" "2 ^ prec" "-1 * val(Eval_real(ACOS1_var, vars)) * 2^prec") (("1" (split) (("1" (both-sides "+" "m - 1" -1) (("1" (assert) (("1" (lemma "associative_mult") (("1" (inst -1 "-1" "val(Eval_real(ACOS1_var, vars))" "2^prec") (("1" (replaces -1) (("1" (div-by -1 "2^prec") (("1" (lemma "neg_one_times") (("1" (inst -1 "val(Eval_real(ACOS1_var, vars))") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 1) (("2" (lemma "lt_cut") (("2" (both-sides "+" "1" -2) (("2" (inst -1 "val(Eval_real(ACOS1_var, vars)) * 2^prec" "1+m" "1") (("2" (split) (("1" (div-by -1 "2^prec") (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs" -) (("2" (assert) (("2" (case "abs(val(Eval_real(ACOS1_var, vars))) <= 1") (("1" (assert) nil nil) ("2" (hide 3) (("2" (name "m" "val(Eval(prec)(ACOS1_var, vars))(prec)") (("2" (expand "cauchy_prop") (("2" (inst -2 "prec") (("2" (replaces -1) (("2" (name "y" "val(Eval_real(ACOS1_var, vars))") (("2" (replaces -1) (("2" (flatten) (("2" (hide -4) (("2" (expand "abs") (("2" (case "y < 0") (("1" (assert) (("1" (mult-by 1 "2^prec") (("1" (lemma "both_sides_times_neg_lt1") (("1" (inst -1 "-1" "y * 2^prec" "m - 1") (("1" (flatten) (("1" (hide -1) (("1" (split) (("1" (hide -3) (("1" (assert) (("1" (lemma "commutative_mult") (("1" (inst -1 "2 ^ prec" "y") (("1" (replaces -1) (("1" (lemma "associative_mult") (("1" (inst -1 "-1" "y" "2^prec") (("1" (replaces -1) (("1" (case "FORALL (a, b, c: real): a < b - c AND c >= 0 IMPLIES a < b") (("1" (inst -1 "(-1 * y) * 2^prec" "1" "m") (("1" (split) (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (mult-by -1 "2^prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 1) (("2" (lemma "integer_lt_plus_1") (("2" (inst -1 "m" "2^prec") (("2" (assert) (("2" (hide -4) (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "1 + m" "1 + m" "2 ^ prec" "y * 2^prec") (("2" (split) (("1" (both-sides "-" "1+m" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("19" (skeep) (("19" (skeep) (("19" (inst -1 "prec" "vars") (("19" (expand "Eval" -2) (("19" (expand "Eval_real" +) (("19" (case "none?(Eval(prec)(ABS1_var, vars))") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("20" (skeep) (("20" (skeep) (("20" (inst -1 "prec" "vars") (("20" (inst -2 "prec" "vars") (("20" (expand "Eval_real" +) (("20" (expand "Eval" -3) (("20" (name "cr1" "Eval(prec)(MOD1_var, vars)") (("20" (replaces -1) (("20" (name "cr2" "Eval(prec)(MOD2_var, vars)") (("20" (replaces -1) (("20" (case "some?(cr1) AND some?(cr2) AND val(cr2)(prec) /= 0 AND floor(cauchy_div(val(cr1), val(cr2))(prec) / 2^prec) /= cauchy_div(val(cr1), val(cr2))(prec) / 2^prec") (("1" (flatten) (("1" (assert) (("1" (case "val(Eval_real(MOD2_var, vars)) /= 0") (("1" (assert) nil nil) ("2" (lemma "eval_lemma_aux") (("2" (inst -1 "prec" "MOD2_var" "vars") (("2" (beta) (("2" (reveal -2) (("2" (replaces -1) (("2" (assert) (("2" (lemma "unique_cauchy_zero3") (("2" (inst -1 "val(cr2)") (("2" (flatten) (("2" (replaces -4) (("2" (assert) (("2" (expand "cauchy_zero") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil) ("3" (split) (("1" (assert) (("1" (split) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (hide-all-but (1 2)) (("1" (expand "cauchy_nzreal?") (("1" (typepred "val(cr2)") (("1" (expand "cauchy_real?") (("1" (skeep) (("1" (inst 2 "x") (("1" (lemma "unique_cauchy_zero2") (("1" (inst -1 "val(cr2)") (("1" (flatten) (("1" (split -1) (("1" (inst -1 "prec") (("1" (expand "cauchy_zero") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("21" (skeep*) (("21" (inst -1 "prec" "vars") (("21" (expand "Eval" -2) (("21" (expand "Eval_real" +) (("21" (case "none?(Eval(prec)(ASIN1_var, vars))") (("1" (assert) nil nil) ("2" (assert) (("2" (hide 1) (("2" (case "abs(val(Eval(prec)(ASIN1_var, vars))(prec)) < 2^prec") (("1" (hide -3) (("1" (lemma "eval_lemma_aux") (("1" (inst -1 "prec" "ASIN1_var" "vars") (("1" (beta) (("1" (assert) (("1" (case "val(Eval(prec)(ASIN1_var, vars))(prec) < 0") (("1" (expand "abs" -) (("1" (assert) (("1" (expand "cauchy_prop") (("1" (inst -2 "prec") (("1" (flatten) (("1" (name "m" "val(Eval(prec)(ASIN1_var, vars))(prec)") (("1" (replaces -1) (("1" (case "abs(val(Eval_real(ASIN1_var, vars))) <= 1") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "abs") (("2" (case "val(Eval_real(ASIN1_var, vars)) < 0") (("1" (assert) (("1" (hide -6) (("1" (lemma "both_sides_times_neg_lt1") (("1" (inst -1 "-1" "val(Eval_real(ASIN1_var, vars)) * 2^prec" "m - 1") (("1" (flatten) (("1" (split -2) (("1" (hide -2) (("1" (assert) (("1" (hide-all-but (-1 -6 1)) (("1" (lemma "integer_lt_plus_1") (("1" (inst -1 "-m" "2^prec") (("1" (assert) (("1" (lemma "lt_plus_lt1") (("1" (inst -1 "1 - m" "1 - m" "2 ^ prec" "-1 * val(Eval_real(ASIN1_var, vars)) * 2^prec") (("1" (split) (("1" (both-sides "+" "m - 1" -1) (("1" (assert) (("1" (lemma "associative_mult") (("1" (inst -1 "-1" "val(Eval_real(ASIN1_var, vars))" "2^prec") (("1" (replaces -1) (("1" (div-by -1 "2^prec") (("1" (lemma "neg_one_times") (("1" (inst -1 "val(Eval_real(ASIN1_var, vars))") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 1) (("2" (lemma "lt_cut") (("2" (both-sides "+" "1" -2) (("2" (inst -1 "val(Eval_real(ASIN1_var, vars)) * 2^prec" "1+m" "1") (("2" (split) (("1" (div-by -1 "2^prec") (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs" -) (("2" (assert) (("2" (case "abs(val(Eval_real(ASIN1_var, vars))) <= 1") (("1" (assert) nil nil) ("2" (hide 3) (("2" (name "m" "val(Eval(prec)(ASIN1_var, vars))(prec)") (("2" (expand "cauchy_prop") (("2" (inst -2 "prec") (("2" (replaces -1) (("2" (name "y" "val(Eval_real(ASIN1_var, vars))") (("2" (replaces -1) (("2" (flatten) (("2" (hide -4) (("2" (expand "abs") (("2" (case "y < 0") (("1" (assert) (("1" (mult-by 1 "2^prec") (("1" (lemma "both_sides_times_neg_lt1") (("1" (inst -1 "-1" "y * 2^prec" "m - 1") (("1" (flatten) (("1" (hide -1) (("1" (split) (("1" (hide -3) (("1" (assert) (("1" (lemma "commutative_mult") (("1" (inst -1 "2 ^ prec" "y") (("1" (replaces -1) (("1" (lemma "associative_mult") (("1" (inst -1 "-1" "y" "2^prec") (("1" (replaces -1) (("1" (case "FORALL (a, b, c: real): a < b - c AND c >= 0 IMPLIES a < b") (("1" (inst -1 "(-1 * y) * 2^prec" "1" "m") (("1" (split) (("1" (lemma "expt_inv_lt_1") (("1" (inst -1 "prec") (("1" (mult-by -1 "2^prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 1) (("2" (lemma "integer_lt_plus_1") (("2" (inst -1 "m" "2^prec") (("2" (assert) (("2" (hide -4) (("2" (lemma "lt_plus_lt1") (("2" (inst -1 "1 + m" "1 + m" "2 ^ prec" "y * 2^prec") (("2" (split) (("1" (both-sides "-" "1+m" -1) (("1" (assert) (("1" (div-by -1 "2^prec") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("22" (skeep*) (("22" (inst -1 "prec" "vars") (("22" (expand "Eval" -2) (("22" (expand "Eval_real" +) (("22" (case "none?(Eval(prec)(ATAN1_var, vars))") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb < r AND r < pi_ub}" atan_approx trig_fnd) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (integer nonempty-type-from-decl nil integers nil) (unique_cauchy_zero3 formula-decl nil cauchy nil) (cauchy_zero const-decl "cauchy_nnreal" cauchy nil) (nzreal nonempty-type-eq-decl nil reals nil) (x skolem-const-decl "real" cauchy_expr_eval nil) (unique_cauchy_zero2 formula-decl nil cauchy nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_int_is_int application-judgement "int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (expt_inv_lt_1 formula-decl nil floor nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (odd? const-decl "bool" integers nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (minus_real_is_real application-judgement "real" reals nil) (both_sides_times_neg_lt1 formula-decl nil real_props nil) (div_simp formula-decl nil real_props nil) (neg_one_times formula-decl nil extra_tegies nil) (associative_mult formula-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (both_sides_minus_le2 formula-decl nil real_props nil) (both_sides_minus_le1 formula-decl nil real_props nil) (both_sides_minus_lt2 formula-decl nil real_props nil) (both_sides_plus_lt1 formula-decl nil real_props nil) (integer_lt_plus_1 formula-decl nil floor nil) (int_times_int_is_int application-judgement "int" integers nil) (nil application-judgement "above(n)" exp2 nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (TRUE const-decl "bool" booleans nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (commutative_mult formula-decl nil number_fields nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (both_sides_plus_le1 formula-decl nil real_props nil) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (lt_plus_lt1 formula-decl nil real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (zero_times1 formula-decl nil real_props nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (both_sides_plus_lt2 formula-decl nil real_props nil) (div_mult_pos_le1 formula-decl nil real_props nil) (both_sides_plus_le2 formula-decl nil real_props nil) (both_sides_minus_lt1 formula-decl nil real_props nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (Integral const-decl "real" integral_def analysis) (ln const-decl "real" ln_exp lnexp) (cauchy_floor const-decl "{cx: cauchy_real | EXISTS i: cx = cauchy_int(i)}" floor nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_cut formula-decl nil extra_real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (div_cancel2 formula-decl nil real_props nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (<= const-decl "bool" reals nil) (cauchy_prop const-decl "bool" cauchy nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (eval_lemma_aux formula-decl nil cauchy_expr_eval nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (cauchy_sub const-decl "cauchy_real" sub nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (cauchy_exp_is_posreal application-judgement "cauchy_posreal" exp nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cauchy_inv const-decl "cauchy_nzreal" inv nil) (cauchy_div const-decl "cauchy_real" div nil) (cauchy_rat const-decl "cauchy_real" computable_rat nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (CauchyExpr_induction formula-decl nil CauchyExpr_adt nil) (Eval_real def-decl "Maybe[real]" cauchy_expr_eval nil) (Eval def-decl "Maybe[cauchy_real]" cauchy_expr_eval nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (CauchyExpr type-decl nil CauchyExpr_adt nil)) shostak)) (eval_lemma_TCC1 0 (eval_lemma_TCC1-1 nil 3675517521 ("" (skeep) (("" (lemma "eval_domain_inside_eval_real") (("" (inst -1 "prec" "re" "vars") (("" (assert) nil nil)) nil)) nil)) nil) ((eval_domain_inside_eval_real formula-decl nil cauchy_expr_eval nil) (rat nonempty-type-eq-decl nil rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (CauchyExpr type-decl nil CauchyExpr_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak (eval_lemma subtype "cauchy_expr_eval.Eval_real(cauchy_expr_eval.re, cauchy_expr_eval.vars)" "(Maybe[real].some?)"))) (eval_lemma 0 (eval_lemma-1 nil 3675517621 ("" (skeep) (("" (assert) (("" (flatten) (("" (lemma "eval_lemma_aux") (("" (inst -1 "prec" "re" "vars") (("" (assert) (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (lemma "eval_lemma_TCC1") (("3" (inst -1 "prec" "re" "vars" "Eval(prec)(re, vars)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_lemma_aux formula-decl nil cauchy_expr_eval nil) (eval_lemma_TCC1 subtype-tcc nil cauchy_expr_eval nil) (Eval def-decl "Maybe[cauchy_real]" cauchy_expr_eval nil) (Maybe type-decl nil Maybe structures) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (rat nonempty-type-eq-decl nil rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (CauchyExpr type-decl nil CauchyExpr_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)))
