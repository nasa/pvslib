(bisection_nat_sqrt (fs_lt_def 0 (fs_lt_def-1 nil 3394267943 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq const-decl "nonneg_real" sq reals) (fs_lt? const-decl "bool" bisection_nat_sqrt nil) (fs_eq? const-decl "bool" bisection_nat_sqrt nil) (fs_gt? const-decl "bool" bisection_nat_sqrt nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak)) (fs_eq_def 0 (fs_eq_def-1 nil 3394267949 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq const-decl "nonneg_real" sq reals) (fs_eq? const-decl "bool" bisection_nat_sqrt nil) (fs_lt? const-decl "bool" bisection_nat_sqrt nil) (fs_gt? const-decl "bool" bisection_nat_sqrt nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak)) (fs_gt_def 0 (fs_gt_def-1 nil 3394267959 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq const-decl "nonneg_real" sq reals) (fs_gt? const-decl "bool" bisection_nat_sqrt nil) (fs_lt? const-decl "bool" bisection_nat_sqrt nil) (fs_eq? const-decl "bool" bisection_nat_sqrt nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak)) (fs_trichotomy 0 (fs_trichotomy-1 nil 3394267964 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq const-decl "nonneg_real" sq reals) (fs_lt? const-decl "bool" bisection_nat_sqrt nil) (fs_eq? const-decl "bool" bisection_nat_sqrt nil) (fs_gt? const-decl "bool" bisection_nat_sqrt nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak)) (fs_le_ge 0 (fs_le_ge-1 nil 3394269618 ("" (skosimp) (("" (expand "fs_le?") (("" (expand "fs_ge?") (("" (expand "fs_lt?") (("" (expand "fs_eq?") (("" (expand "fs_gt?") (("" (split -1) (("1" (split) (("1" (flatten) (("1" (lemma "sq_lt" ("nna" "1+m!1" "nnb" "1+n!1")) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "sq_lt" ("nna" "1+m!1" "nnb" "n!1")) (("2" (assert) nil nil)) nil)) nil) ("2" (split) (("1" (flatten) (("1" (lemma "sq_lt" ("nna" "n!1" "nnb" "1+m!1")) (("1" (lemma "sq_lt" ("nna" "m!1" "nnb" "1+n!1")) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "sq_lt" ("nna" "m!1" "nnb" "n!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((fs_le? const-decl "bool" bisection_nat_sqrt nil) (fs_lt? const-decl "bool" bisection_nat_sqrt nil) (fs_gt? const-decl "bool" bisection_nat_sqrt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (sq_lt formula-decl nil sq reals) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sq_nz_pos application-judgement "posreal" sq reals) (fs_eq? const-decl "bool" bisection_nat_sqrt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (fs_ge? const-decl "bool" bisection_nat_sqrt nil)) shostak)) (bisection_sqrt_aux_TCC1 0 (bisection_sqrt_aux_TCC1-1 nil 3394269004 ("" (skosimp) (("" (typepred "m!1") (("" (typepred "n!1") (("" (lemma "fs_le_ge" ("x" "x!1" "m" "m!1" "n" "n!1")) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((fs_le? const-decl "bool" bisection_nat_sqrt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (fs_le_ge formula-decl nil bisection_nat_sqrt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (fs_ge? const-decl "bool" bisection_nat_sqrt nil)) nil (bisection_sqrt_aux subtype "(number_fields.+)(((number_fields.-)(bisection_nat_sqrt.n, bisection_nat_sqrt.m)), 1)" "naturalnumber"))) (bisection_sqrt_aux_TCC2 0 (bisection_sqrt_aux_TCC3-2 "" 3804550901 ("" (skosimp*) (("" (typepred "m!1") (("" (typepred "n!1") (("" (lemma "nonneg_floor_is_nat" ("x" "(n!1+m!1)/2")) (("" (assert) (("" (hide-all-but (-5 2)) (("" (expand "fs_le?") (("" (expand "fs_lt?") (("" (flatten) (("" (expand "fs_eq?") (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((fs_le? const-decl "bool" bisection_nat_sqrt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nonneg_floor_is_nat judgement-tcc nil floor_ceil nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (fs_lt? const-decl "bool" bisection_nat_sqrt nil) (fs_eq? const-decl "bool" bisection_nat_sqrt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sq_nz_pos application-judgement "posreal" sq reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (fs_ge? const-decl "bool" bisection_nat_sqrt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (bisection_sqrt_aux subtype "(number_fields.+)(bisection_nat_sqrt.t, 1)" "(bisection_nat_sqrt.fs_le?(bisection_nat_sqrt.x))")) (bisection_sqrt_aux_TCC3-1 nil 3394269004 ("" (skosimp*) (("" (typepred "m!1") (("" (typepred "n!1") (("" (lemma "nonneg_floor_is_nat" ("x" "(n!1+m!1)/2")) (("" (assert) (("" (hide-all-but (-4 2)) (("" (expand "fs_le?") (("" (expand "fs_lt?") (("" (flatten) (("" (expand "fs_eq?") (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (bisection_sqrt_aux subtype "(number_fields.+)(bisection_nat_sqrt.t, 1)" "(bisection_nat_sqrt.fs_le?(bisection_nat_sqrt.x))"))) (bisection_sqrt_aux_TCC3 0 (bisection_sqrt_aux_TCC4-1 nil 3394269004 ("" (skosimp*) (("" (lemma "fs_le_ge" ("x" "x!1" "m" "m!1" "n" "n!1")) (("" (assert) nil nil)) nil)) nil) ((fs_ge? const-decl "bool" bisection_nat_sqrt nil) (fs_le? const-decl "bool" bisection_nat_sqrt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (fs_le_ge formula-decl nil bisection_nat_sqrt nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (bisection_sqrt_aux termination "bisection_nat_sqrt.bisection_sqrt_aux(bisection_nat_sqrt.x, (number_fields.+)(bisection_nat_sqrt.t, 1), bisection_nat_sqrt.n)" "nil"))) (bisection_sqrt_aux_TCC4 0 (bisection_sqrt_aux_TCC5-1 nil 3394269004 ("" (skosimp*) (("" (lemma "fs_le_ge" ("x" "x!1" "m" "m!1" "n" "n!1")) (("" (lemma "nonneg_floor_is_nat" ("x" "(n!1+m!1)/2")) (("" (assert) (("" (expand "fs_eq?") (("" (expand "fs_lt?") (("" (expand "fs_ge?") (("" (expand "fs_gt?") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((fs_ge? const-decl "bool" bisection_nat_sqrt nil) (fs_le? const-decl "bool" bisection_nat_sqrt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (fs_le_ge formula-decl nil bisection_nat_sqrt nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (fs_lt? const-decl "bool" bisection_nat_sqrt nil) (fs_gt? const-decl "bool" bisection_nat_sqrt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq_nz_pos application-judgement "posreal" sq reals) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (fs_eq? const-decl "bool" bisection_nat_sqrt nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat judgement-tcc nil floor_ceil nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (bisection_sqrt_aux subtype "bisection_nat_sqrt.t" "(bisection_nat_sqrt.fs_ge?(bisection_nat_sqrt.x))"))) (bisection_sqrt_aux_TCC5 0 (bisection_sqrt_aux_TCC6-1 nil 3413715945 ("" (skosimp*) (("" (lemma "fs_le_ge" ("x" "x!1" "m" "m!1" "n" "n!1")) (("" (assert) nil nil)) nil)) nil) ((fs_ge? const-decl "bool" bisection_nat_sqrt nil) (fs_le? const-decl "bool" bisection_nat_sqrt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (fs_le_ge formula-decl nil bisection_nat_sqrt nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (bisection_sqrt_aux termination "bisection_nat_sqrt.bisection_sqrt_aux(bisection_nat_sqrt.x, bisection_nat_sqrt.m, bisection_nat_sqrt.t)" "nil"))) (bisection_sqrt_aux_TCC6 0 (bisection_sqrt_aux_TCC6-1 "" 3884803650 ("" (grind) nil nil) nil shostak (bisection_sqrt_aux subtype "floor_ceil.floor(number_fields./(((number_fields.+)(bisection_nat_sqrt.n, bisection_nat_sqrt.m)), 2))" "{x1: {i | booleans.&(reals.<=(floor_ceil.i, number_fields./((number_fields.+)(bisection_nat_sqrt.m, bisection_nat_sqrt.n), 2)), reals.<(number_fields./((number_fields.+)(bisection_nat_sqrt.m, bisection_nat_sqrt.n), 2), (number_fields.+)(1, floor_ceil.i)))} | reals.>=(x1, 0)}")) (bisection_sqrt_aux_TCC2-2 "" 3790105977 ("" (skosimp*) (("" (typepred "t!1") (("" (assert) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (fs_le? const-decl "bool" bisection_nat_sqrt nil) (fs_ge? const-decl "bool" bisection_nat_sqrt nil) (sq const-decl "nonneg_real" sq reals) (fs_lt? const-decl "bool" bisection_nat_sqrt nil) (fs_eq? const-decl "bool" bisection_nat_sqrt nil) (fs_gt? const-decl "bool" bisection_nat_sqrt nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (sq_nz_pos application-judgement "posreal" sq reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (bisection_sqrt_aux subtype "floor_ceil.floor(number_fields./(((number_fields.+)(bisection_nat_sqrt.n, bisection_nat_sqrt.m)), 2))" "{x1: {i | booleans.&(reals.<=(floor_ceil.i, number_fields./((number_fields.+)(bisection_nat_sqrt.m, bisection_nat_sqrt.n), 2)), reals.<(number_fields./((number_fields.+)(bisection_nat_sqrt.m, bisection_nat_sqrt.n), 2), (number_fields.+)(1, floor_ceil.i)))} | reals.>=(x1, 0)}")) (bisection_sqrt_aux_TCC2-1 nil 3394269004 ("" (skosimp*) (("" (typepred "t!1") (("" (assert) (("" (expand "fs_le?") (("" (flatten) (("" (expand "fs_lt?") (("" (expand "fs_eq?") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (bisection_sqrt_aux subtype "floor_ceil.floor(number_fields./(((number_fields.+)(bisection_nat_sqrt.n, bisection_nat_sqrt.m)), 2))" "{x1: {i | booleans.&(reals.<=(floor_ceil.i, number_fields./((number_fields.+)(bisection_nat_sqrt.m, bisection_nat_sqrt.n), 2)), reals.<(number_fields./((number_fields.+)(bisection_nat_sqrt.m, bisection_nat_sqrt.n), 2), (number_fields.+)(1, floor_ceil.i)))} | reals.>=(x1, 0)}"))) (bisection_sqrt_aux_prop 0 (bisection_sqrt_aux_prop-1 nil 3412657227 ("" (case "FORALL (k,m, n, x: nat):
        n-m<=k & fs_le?(x)(m) AND fs_ge?(x)(n) =>
         fs_eq?(x, bisection_sqrt_aux(x, m, n))") (("1" (skosimp) (("1" (inst - "n!1-m!1" "m!1" "n!1" "x!1") (("1" (assert) nil nil) ("2" (assert) (("2" (hide 2) (("2" (expand "fs_le?") (("2" (expand "fs_ge?") (("2" (expand "fs_eq?") (("2" (expand "fs_lt?") (("2" (expand "fs_gt?") (("2" (split) (("1" (split) (("1" (flatten) (("1" (lemma "sq_lt" ("nna" "1+m!1" "nnb" "1+n!1")) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "sq_lt" ("nna" "1+m!1" "nnb" "n!1")) (("2" (assert) nil nil)) nil)) nil) ("2" (split) (("1" (flatten) (("1" (lemma "sq_lt" ("nna" "m!1" "nnb" "1+n!1")) (("1" (lemma "sq_lt" ("nna" "n!1" "nnb" "1+m!1")) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "sq_lt" ("nna" "m!1" "nnb" "n!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "k") (("1" (skosimp) (("1" (expand "<=") (("1" (assert) (("1" (split) (("1" (assert) (("1" (expand "fs_le?") (("1" (hide 1) (("1" (expand "fs_ge?") (("1" (expand "fs_eq?") (("1" (expand "fs_lt?") (("1" (expand "fs_gt?") (("1" (split) (("1" (split) (("1" (flatten) (("1" (lemma "sq_lt" ("nna" "1+m!1" "nnb" "1+n!1")) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "sq_lt" ("nna" "1+m!1" "nnb" "n!1")) (("2" (assert) nil nil)) nil)) nil) ("2" (split) (("1" (flatten) (("1" (lemma "sq_lt" ("nna" "m!1" "nnb" "1+n!1")) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (lemma "sq_lt" ("nna" "m!1" "nnb" "n!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bisection_sqrt_aux") (("2" (assert) (("2" (expand "fs_le?") (("2" (expand "fs_ge?") (("2" (expand "fs_lt?") (("2" (expand "fs_gt?") (("2" (expand "fs_eq?") (("2" (lemma "sq_lt" ("nna" "m!1" "nnb" "1+m!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "bisection_sqrt_aux" 1) (("2" (case-replace "n!1=m!1") (("1" (assert) (("1" (expand "fs_le?") (("1" (expand "fs_ge?") (("1" (hide -1 -2 -3) (("1" (expand "fs_gt?") (("1" (expand "fs_lt?") (("1" (expand "fs_eq?") (("1" (lemma "sq_lt" ("nna" "1+m!1" "nnb" "m!1")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "n!1>m!1") (("1" (hide 1) (("1" (typepred "floor((m!1 + n!1) / 2)") (("1" (name-replace "N" "floor((m!1 + n!1) / 2)") (("1" (rewrite "div_mult_pos_le2") (("1" (rewrite "div_mult_pos_lt1") (("1" (case-replace "fs_lt?(x!1, N)") (("1" (inst - "1+N" "n!1" "x!1") (("1" (assert) (("1" (hide 2) (("1" (expand "fs_le?") (("1" (flatten) (("1" (expand "fs_eq?") (("1" (expand "fs_ge?") (("1" (expand "fs_lt?") (("1" (expand "fs_eq?") (("1" (expand "fs_gt?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "fs_eq?(x!1, N)") (("2" (assert) (("2" (lemma "fs_trichotomy" ("n" "x!1" "m" "N")) (("2" (assert) (("2" (hide 1 2) (("2" (inst - "m!1" "N" "x!1") (("2" (assert) (("2" (hide 2) (("2" (expand "fs_ge?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-3 -4 1 2)) (("2" (expand "fs_le?") (("2" (expand "fs_ge?") (("2" (expand "fs_eq?") (("2" (expand "fs_lt?") (("2" (expand "fs_gt?") (("2" (split) (("1" (split) (("1" (flatten) (("1" (lemma "sq_lt" ("nna" "1+m!1" "nnb" "1+n!1")) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "sq_lt" ("nna" "1+m!1" "nnb" "n!1")) (("2" (assert) nil nil)) nil)) nil) ("2" (split) (("1" (flatten) (("1" (lemma "sq_lt" ("nna" "m!1" "nnb" "1+n!1")) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (lemma "sq_lt" ("nna" "m!1" "nnb" "n!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (> const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (< const-decl "bool" reals nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (div_mult_pos_le2 formula-decl nil real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (fs_trichotomy formula-decl nil bisection_nat_sqrt nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (fs_gt? const-decl "bool" bisection_nat_sqrt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sq_lt formula-decl nil sq reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sq_nz_pos application-judgement "posreal" sq reals) (fs_lt? const-decl "bool" bisection_nat_sqrt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (m!1 skolem-const-decl "nat" bisection_nat_sqrt nil) (n!1 skolem-const-decl "nat" bisection_nat_sqrt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (fs_le? const-decl "bool" bisection_nat_sqrt nil) (fs_ge? const-decl "bool" bisection_nat_sqrt nil) (fs_eq? const-decl "bool" bisection_nat_sqrt nil) (bisection_sqrt_aux def-decl "nat" bisection_nat_sqrt nil)) shostak)) (bisection_sqrt_TCC1 0 (bisection_sqrt_TCC1-1 nil 3394269004 ("" (skosimp) (("" (expand "fs_le?") (("" (expand "fs_lt?") (("" (expand "fs_eq?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((fs_le? const-decl "bool" bisection_nat_sqrt nil) (fs_eq? const-decl "bool" bisection_nat_sqrt nil) (sq_1 formula-decl nil sq reals) (sq_0 formula-decl nil sq reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sq_nz_pos application-judgement "posreal" sq reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (fs_lt? const-decl "bool" bisection_nat_sqrt nil)) nil (bisection_sqrt subtype "0" "(bisection_nat_sqrt.fs_le?(bisection_nat_sqrt.n))"))) (bisection_sqrt_TCC2 0 (bisection_sqrt_TCC2-1 nil 3394269004 ("" (skosimp) (("" (expand "fs_ge?") (("" (expand "fs_eq?") (("" (expand "fs_gt?") (("" (flatten) (("" (assert) (("" (expand "sq") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((fs_ge? const-decl "bool" bisection_nat_sqrt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (fs_gt? const-decl "bool" bisection_nat_sqrt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sq const-decl "nonneg_real" sq reals) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (fs_eq? const-decl "bool" bisection_nat_sqrt nil)) nil (bisection_sqrt subtype "bisection_nat_sqrt.n" "(bisection_nat_sqrt.fs_ge?(bisection_nat_sqrt.n))"))) (bisection_sqrt_def 0 (bisection_sqrt_def-1 nil 3394270385 ("" (skosimp) (("" (expand "bisection_sqrt") (("" (lemma "bisection_sqrt_aux_prop" ("x" "n!1" "m" "0" "n" "n!1")) (("" (split -1) (("1" (name-replace "M" "bisection_sqrt_aux(n!1, 0, n!1)") (("1" (expand "fs_eq?") (("1" (typepred "floor(sqrt(n!1))") (("1" (name-replace "N" "floor(sqrt(n!1))") (("1" (lemma "sq_le" ("nna" "N" "nnb" "sqrt(n!1)")) (("1" (lemma "sq_lt" ("nnb" "N+1" "nna" "sqrt(n!1)")) (("1" (assert) (("1" (flatten) (("1" (lemma "sq_lt" ("nna" "M" "nnb" "1+N")) (("1" (lemma "sq_lt" ("nna" "N" "nnb" "1+M")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "fs_le?") (("2" (expand "fs_lt?") (("2" (expand "fs_eq?") (("2" (flatten) (("2" (expand "sq") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "fs_ge?") (("3" (expand "fs_eq?") (("3" (expand "fs_gt?") (("3" (flatten) (("3" (case-replace "n!1=0") (("1" (expand "sq") (("1" (propax) nil nil)) nil) ("2" (case-replace "n!1=1") (("1" (expand "sq") (("1" (propax) nil nil)) nil) ("2" (lemma "both_sides_times_pos_le1" ("x" "2" "y" "n!1" "pz" "n!1")) (("1" (rewrite "sq_rew") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((bisection_sqrt const-decl "nat" bisection_nat_sqrt nil) (fs_eq? const-decl "bool" bisection_nat_sqrt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (sq_lt formula-decl nil sq reals) (sq_sqrt formula-decl nil sqrt reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq_nz_pos application-judgement "posreal" sq reals) (sq_le formula-decl nil sq reals) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (NOT const-decl "[bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (bisection_sqrt_aux def-decl "nat" bisection_nat_sqrt nil) (fs_ge? const-decl "bool" bisection_nat_sqrt nil) (fs_le? const-decl "bool" bisection_nat_sqrt nil) (= const-decl "[T, T -> boolean]" equalities nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sq const-decl "nonneg_real" sq reals) (fs_lt? const-decl "bool" bisection_nat_sqrt nil) (fs_gt? const-decl "bool" bisection_nat_sqrt nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (sq_rew formula-decl nil sq reals) (bisection_sqrt_aux_prop formula-decl nil bisection_nat_sqrt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)))
