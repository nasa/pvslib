(atanx (cauchy_ssmallreal_TCC1 0 (cauchy_ssmallreal_TCC1-1 nil 3288497283 ("" (expand "cauchy_ssmallreal?") (("" (inst + "0") (("" (expand "cauchy_prop") (("" (propax) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (cauchy_prop const-decl "bool" cauchy nil) (posint_exp application-judgement "posint" exponentiation nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) shostak (cauchy_ssmallreal subtype "(LAMBDA p: 0)" "cauchy_ssmallreal"))) (subtype_TCC1 0 (subtype_TCC1-1 nil 3288497283 ("" (skosimp*) (("" (typepred "x!1") (("" (expand "cauchy_ssmallreal?") (("" (skosimp*) (("" (expand "cauchy_real?") (("" (inst + "x!2") nil nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_ssmallreal nonempty-type-eq-decl nil atanx nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (- const-decl "[numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cauchy_real? const-decl "bool" cauchy nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) shostak (subtype_ subtype "atanx.x" "cauchy_real"))) (cauchy_vsmallreal_TCC1 0 (cauchy_vsmallreal_TCC1-1 nil 3288497283 ("" (expand "cauchy_vsmallreal?") (("" (inst + "0") (("" (expand "cauchy_prop") (("" (propax) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (vsmallreal nonempty-type-eq-decl nil atanx nil) (cauchy_prop const-decl "bool" cauchy nil) (posint_exp application-judgement "posint" exponentiation nil) (cauchy_vsmallreal? const-decl "bool" atanx nil)) shostak (cauchy_vsmallreal subtype "(LAMBDA p: 0)" "cauchy_vsmallreal"))) (subtype_TCC2 0 (subtype_TCC2-1 nil 3288497283 ("" (skosimp*) (("" (typepred "x!1") (("" (expand "cauchy_vsmallreal?") (("" (expand "cauchy_real?") (("" (skosimp*) (("" (inst + "x!2") nil nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_vsmallreal nonempty-type-eq-decl nil atanx nil) (cauchy_vsmallreal? const-decl "bool" atanx nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (cauchy_real? const-decl "bool" cauchy nil) (vsmallreal nonempty-type-eq-decl nil atanx nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil)) shostak (subtype_ subtype "atanx.x" "cauchy_real"))) (cauchy_atan_drx_series_TCC1 0 (cauchy_atan_drx_series_TCC1-1 nil 3392689913 ("" (skosimp) (("" (expand "cauchy_nzreal?") (("" (inst + "1+2*n!1") (("" (expand "cauchy_prop") (("" (skosimp) (("" (expand "cauchy_int") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (posint_exp application-judgement "posint" exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cauchy_int const-decl "cauchy_real" int nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (cauchy_atan_drx_series subtype "int.cauchy_int((number_fields.+)(number_fields.*(2, atanx.n), 1))" "cauchy_nzreal"))) (cauchy_atan_drx_series_TCC2 0 (cauchy_atan_drx_series_TCC2-1 nil 3392689913 ("" (skosimp) (("" (hide 1) (("" (expand "cauchy_nzreal?") (("" (inst + "1+2*n!1") (("" (expand "cauchy_prop") (("" (skosimp) (("" (expand "cauchy_int") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_int const-decl "cauchy_real" int nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (cauchy_prop const-decl "bool" cauchy nil) (posint_exp application-judgement "posint" exponentiation nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil)) nil (cauchy_atan_drx_series subtype "int.cauchy_int((number_fields.+)(number_fields.*(2, atanx.n), 1))" "cauchy_nzreal"))) (atan_series_lemma 0 (atan_series_lemma-1 nil 3288496910 ("" (expand "atan_series_coef") (("" (expand "cauchy_atan_drx_series") (("" (skosimp*) (("" (lemma "int_lemma" ("n" "1+2*n!1")) (("" (lemma "int_lemma" ("n" "1")) (("" (lemma "int_lemma" ("n" "-1")) (("" (assert) (("" (typepred "n!1") (("" (lemma "expt_minus1" ("i" "n!1")) (("" (case-replace "even?(n!1)") (("1" (assert) (("1" (flatten) (("1" (replace -2) (("1" (lemma "div_lemma" ("x" "1" "cx" "cauchy_int(1)" "nzy" "1+2*n!1" "nzcy" "cauchy_int(1 + 2 * n!1)")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "even_or_odd") (("2" (assert) (("2" (replace -2) (("2" (lemma "div_lemma" ("x" "-1" "cx" "cauchy_int(-1)" "nzy" "1+2*n!1" "nzcy" "cauchy_int(1 + 2 * n!1)")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_atan_drx_series const-decl "cauchy_real" atanx nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_lemma formula-decl nil int nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (even? const-decl "bool" integers nil) (div_lemma formula-decl nil div nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_int const-decl "cauchy_real" int nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (/= const-decl "boolean" notequal nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_or_odd formula-decl nil naturalnumbers nil) (expt_minus1 formula-decl nil prelude_aux nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (atan_series_coef const-decl "rat" atan trig) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil)) shostak)) (cauchy_atan_drxx_TCC1 0 (cauchy_atan_drxx_TCC1-1 nil 3288497284 ("" (expand "cauchys_real?") (("" (inst + "atan_series_coef") (("" (expand "cauchys_prop") (("" (skosimp*) (("" (lemma "atan_series_lemma" ("n" "n!1")) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (atan_series_coef const-decl "rat" atan trig) (atan_series_lemma formula-decl nil atanx nil) (cauchys_prop const-decl "bool" sum nil) (cauchys_real? const-decl "bool" sum nil)) shostak (cauchy_atan_drxx subtype "atanx.cauchy_atan_drx_series" "cauchys_real"))) (cauchy_atan_drxx_prop_TCC1 0 (cauchy_atan_drxx_prop_TCC1-1 nil 3288506197 ("" (skosimp*) (("" (typepred "vsx!1") (("" (assert) nil nil)) nil)) nil) ((vsmallreal nonempty-type-eq-decl nil atanx nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak (cauchy_atan_drxx_prop subtype "atanx.vsx" "nonneg_real"))) (cauchy_atan_drxx_prop_TCC2 0 (cauchy_atan_drxx_prop_TCC2-1 nil 3288506197 ("" (skosimp*) (("" (typepred "vsx!1") (("" (lemma "sqrt_eq_0") (("" (inst - "vsx!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((vsmallreal nonempty-type-eq-decl nil atanx nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sqrt_eq_0 formula-decl nil sqrt reals)) shostak (cauchy_atan_drxx_prop subtype "sqrt.sqrt(atanx.vsx)" "nznum"))) (cauchy_atan_drxx_prop 0 (cauchy_atan_drxx_prop-1 nil 3288524114 ("" (skosimp*) (("" (typepred "vsx!1") (("" (expand "cauchy_atan_drxx") (("" (lemma "powerseries_lemma" ("x" "vsx!1" "cx" "cvsx!1" "xs" "atan_series_coef" "cxs" "cauchy_atan_drx_series")) (("" (replace -4) (("" (lemma "atan_series_lemma") (("" (replace -1) (("" (hide -1) (("" (expand "cauchy_prop") (("" (skosimp*) (("" (inst -1 "2+p!1") (("" (inst -1 "2+p!1") (("" (flatten -1) (("" (name-replace "CPS" "cauchy_powerseries(cvsx!1, cauchy_atan_drx_series, 2 + p!1)(2 + p!1)") (("" (case-replace "2^(2+p!1)=4*2^p!1") (("1" (lemma "lemma_A2" ("r" "round(CPS/4)" "p" "CPS" "q" "4")) (("1" (assert) (("1" (flatten -1) (("1" (lemma "atan_series" ("x" "sqrt(vsx!1)" "n" "2+p!1")) (("1" (expand "atan_series_n") (("1" (expand "atan_series_term") (("1" (case "FORALL (n:nat): sqrt(vsx!1) ^ (1 + 2 * n) = sqrt(vsx!1)* vsx!1^n") (("1" (case-replace "sigma(0, 2 + p!1,
                 LAMBDA (n: nat):
                   (sqrt(vsx!1) ^ (1 + 2 * n)) * atan_series_coef(n)) = sqrt(vsx!1)*sigma(0, 2 + p!1,LAMBDA (n: nat): vsx!1^n * atan_series_coef(n))") (("1" (hide -1) (("1" (inst - "3+p!1") (("1" (replace -1 -2) (("1" (expand "powerseries") (("1" (case-replace "(LAMBDA (i:nat):
                  IF i = 0 THEN atan_series_coef(i)
                  ELSE atan_series_coef(i) * vsx!1 ^ i
                  ENDIF) = (LAMBDA (n: nat): vsx!1 ^ n * atan_series_coef(n))") (("1" (hide -1 -2 -6) (("1" (name-replace "PS" "sigma(0, 2 + p!1,
                  LAMBDA (n: nat): vsx!1 ^ n * atan_series_coef(n))") (("1" (name-replace "RR" "round(CPS / 4)") (("1" (expand "<=" -6) (("1" (split -6) (("1" (assert) (("1" (lemma "sqrt_pos" ("px" "vsx!1")) (("1" (lemma "expt_pos" ("px" "vsx!1" "i" "3+p!1")) (("1" (lemma "sqrt_lt" ("nny" "vsx!1" "nnz" "sq(1/2)")) (("1" (rewrite "sqrt_sq") (("1" (expand "sq" -1) (("1" (rewrite "abs_mult" -5) (("1" (expand "abs" -5 2) (("1" (expand "abs" -5 2) (("1" (assert) (("1" (lemma "both_sides_div_pos_le1" ("x" "abs(atan(sqrt(vsx!1)) - sqrt(vsx!1) * PS)" "y" "(sqrt(vsx!1) * vsx!1 ^ (3 + p!1)) / (7 + 2 * p!1)" "pz" "sqrt(vsx!1)")) (("1" (replace -1 -6 rl) (("1" (hide -1) (("1" (case-replace "(sqrt(vsx!1) * vsx!1 ^ (3 + p!1)) / (7 + 2 * p!1) / sqrt(vsx!1) = vsx!1 ^ (3 + p!1) / (7 + 2 * p!1)") (("1" (hide -1) (("1" (case-replace "abs(atan(sqrt(vsx!1)) - sqrt(vsx!1) * PS) / sqrt(vsx!1) = abs(atan(sqrt(vsx!1)) / sqrt(vsx!1) -PS)") (("1" (hide -1) (("1" (name-replace "TMP1" "atan(sqrt(vsx!1)) / sqrt(vsx!1)") (("1" (lemma "both_sides_expt_pos_lt" ("px" "vsx!1" "py" "1/4" "pm" "3+p!1")) (("1" (assert) (("1" (hide -12) (("1" (case "abs(TMP1 - PS)*2^p!1 < 1/4") (("1" (expand "abs" -1) (("1" (case "TMP1<PS") (("1" (assert) (("1" (lemma "posreal_times_posreal_is_posreal" ("px" "-(TMP1 - PS)" "py" "2 ^ p!1")) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "posreal_times_posreal_is_posreal" ("px" "TMP1-PS" "py" "2 ^ p!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "both_sides_div_pos_lt2" ("pz" "vsx!1 ^ (3 + p!1)" "px" "7 + 2 * p!1" "py" "1")) (("2" (hide 2) (("2" (assert) (("2" (lemma "both_sides_expt_pos_lt" ("px" "1/4" "py" "1/2" "pm" "3+p!1")) (("2" (assert) (("2" (lemma "both_sides_expt_lt1_lt" ("lt1x" "1/2" "i" "3+p!1" "j" "2+p!1")) (("2" (assert) (("2" (lemma "inv_expt" ("n0x" "2" "i" "2+p!1")) (("2" (lemma "expt_pos" ("px" "2" "i" "p!1")) (("2" (lemma "div_mult_pos_lt2" ("py" "2^p!1" "x" "abs(TMP1 - PS)" "z" "1/4")) (("2" (replace -1 1 rl) (("2" (case-replace "1 / 4 / 2 ^ p!1 = 1 / 2 ^ (2 + p!1)") (("1" (assert) nil nil) ("2" (hide-all-but (-2 1)) (("2" (case-replace "2 ^ (2 + p!1) = 4*2^p!1") (("1" (name-replace "TMP4" "2^p!1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "expt_plus" ("n0x" "2" "i" "2" "j" "p!1")) (("2" (replace -1) (("2" (expand "^" 1 1) (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (lemma "abs_div") (("2" (inst - "sqrt(vsx!1)" "atan(sqrt(vsx!1)) - sqrt(vsx!1) * PS") (("2" (expand "abs" -1 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 * rl) (("2" (rewrite "sqrt_0") (("2" (expand "PS") (("2" (case-replace "sigma(0, 2 + p!1,
                LAMBDA (n: nat): vsx!1 ^ n * atan_series_coef(n)) =1") (("1" (assert) nil nil) ("2" (hide-all-but (-1 1)) (("2" (case "FORALL (m:nat): sigma(0,m,LAMBDA (n: nat): 0 ^ n * atan_series_coef(n)) =1") (("1" (inst - "2+p!1") (("1" (replace -2 1 rl) (("1" (propax) nil nil)) nil)) nil) ("2" (hide -1 2) (("2" (induct "m") (("1" (expand "sigma") (("1" (expand "atan_series_coef") (("1" (expand "^") (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "sigma" 1) (("2" (replace -1 1) (("2" (hide -1) (("2" (expand "^") (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -6 -7 -2 -1 -3 -4 -10 2) (("2" (rewrite "extensionality" 1) (("2" (hide 2) (("2" (skosimp*) (("2" (case "x!1=0") (("1" (replace -1) (("1" (expand "^" 1) (("1" (expand "expt" 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -6 -7 -10 -2 2 -3 -4 -5) (("2" (case "FORALL (m:nat): sigma(0, m,
            LAMBDA (n: nat):
              (sqrt(vsx!1) ^ (1 + 2 * n)) * atan_series_coef(n))
       =
       sqrt(vsx!1) *
        sigma(0, m, LAMBDA (n: nat): vsx!1 ^ n * atan_series_coef(n))
") (("1" (inst - "2+p!1") nil nil) ("2" (hide 2) (("2" (induct "m") (("1" (expand "sigma") (("1" (expand "^" 1) (("1" (expand "expt") (("1" (expand "expt") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "sigma" 1) (("2" (replace -1 1) (("2" (inst - "1+j!1") (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5 -6 -9 2) (("2" (induct "n") (("1" (expand "^" 1) (("1" (expand "expt" 1) (("1" (expand "expt" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "<=" -2) (("2" (split -2) (("1" (lemma "expt_plus") (("1" (inst-cp - "1+2*j!1" "2" "sqrt(vsx!1)") (("1" (inst - "j!1" "1" "vsx!1") (("1" (replace -1) (("1" (replace -2) (("1" (replace -4) (("1" (rewrite "expt_x1") (("1" (case-replace "sqrt(vsx!1) ^ 2 = vsx!1") (("1" (assert) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "^") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (rewrite "sq_rew") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "sqrt_pos") (("2" (inst - "vsx!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1 * rl) (("2" (rewrite "sqrt_0") (("2" (expand "^" 1) (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "expt_plus" ("n0x" "2" "i" "2" "j" "p!1")) (("2" (expand "^" -1 2) (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vsmallreal nonempty-type-eq-decl nil atanx nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (atan_series_coef const-decl "rat" atan trig) (rat nonempty-type-eq-decl nil rationals nil) (cauchy_atan_drx_series const-decl "cauchy_real" atanx nil) (cauchy_vsmallreal nonempty-type-eq-decl nil atanx nil) (cauchy_vsmallreal? const-decl "bool" atanx nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (powerseries_lemma formula-decl nil powerseries nil) (atan_series_lemma formula-decl nil atanx nil) (cauchy_powerseries const-decl "cauchy_real" powerseries nil) (cauchys_real nonempty-type-eq-decl nil sum nil) (cauchys_real? const-decl "bool" sum nil) (= const-decl "[T, T -> boolean]" equalities nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (lemma_A2 formula-decl nil appendix nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (round const-decl "int" prelude_aux nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (atan_series_n const-decl "real" atan trig) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (nnreal_expt application-judgement "nnreal" exponentiation nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nat_exp application-judgement "nat" exponentiation nil) (PS skolem-const-decl "real" atanx nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nat_expt application-judgement "nat" exponentiation nil) (sigma_0_neg formula-decl nil sigma_nat reals) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (sigma_rat application-judgement "rational" sum nil) (hat_02n formula-decl nil power_series series) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (sqrt_0 formula-decl nil sqrt reals) (real_div_nzreal_is_real application-judgement "real" reals nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (expt_pos formula-decl nil exponentiation nil) (sqrt_sq formula-decl nil sqrt reals) (abs_mult formula-decl nil real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cos const-decl "real" sincos_def trig) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig) (real_abs_lt_pi2 nonempty-type-eq-decl nil trig_types trig) (tan_restrict const-decl "real" trig_basic trig) (atan const-decl "{x: real_abs_lt_pi2 | y = tan_restrict(x)}" atan trig) (nonzero_real nonempty-type-eq-decl nil reals nil) (abs_div formula-decl nil real_props nil) (both_sides_expt_pos_lt formula-decl nil exponentiation nil) (both_sides_div_pos_lt2 formula-decl nil real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (expt def-decl "real" exponentiation nil) (expt_plus formula-decl nil exponentiation nil) (posint nonempty-type-eq-decl nil integers nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (nzreal nonempty-type-eq-decl nil reals nil) (inv_expt formula-decl nil exponentiation nil) (both_sides_expt_lt1_lt formula-decl nil exponentiation nil) (minus_real_is_real application-judgement "real" reals nil) (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil) (posrat_exp application-judgement "posrat" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (sq const-decl "nonneg_real" sq reals) (sqrt_lt formula-decl nil sqrt reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (sqrt_pos judgement-tcc nil sqrt reals) (extensionality formula-decl nil functions nil) (powerseries const-decl "real" powerseries nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (odd_minus_even_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (expt_x1 formula-decl nil exponentiation nil) (sq_rew formula-decl nil sq reals) (sq_sqrt formula-decl nil sqrt reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (vsx!1 skolem-const-decl "vsmallreal" atanx nil) (atan_series_term const-decl "[nat -> real]" atan trig) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (nnreal type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (atan_series formula-decl nil atan trig) (nnreal_exp application-judgement "nnreal" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cauchy_prop const-decl "bool" cauchy nil) (posint_exp application-judgement "posint" exponentiation nil) (cauchy_atan_drxx const-decl "[nat -> int]" atanx nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)) shostak)) (cauchy_atan_dr_TCC1 0 (cauchy_atan_dr_TCC1-2 "" 3790106038 ("" (skosimp*) (("" (typepred "cssx!1") (("" (expand "cauchy_ssmallreal?") (("" (skosimp*) (("" (lemma "mul_lemma" ("x" "x!1" "y" "x!1" "cx" "cssx!1" "cy" "cssx!1")) (("" (rewrite "sq_rew") (("" (assert) (("" (expand "cauchy_vsmallreal?") (("" (typepred "x!1") (("" (case "0 <= sq(x!1) & sq(x!1) < 1/4") (("1" (flatten -1) (("1" (inst + "sq(x!1)") nil nil)) nil) ("2" (hide -3 -4 2) (("2" (lemma "sq_pos" ("a" "x!1")) (("2" (assert) (("2" (case "0 <= x!1") (("1" (lemma "sq_lt" ("nna" "x!1" "nnb" "1/2")) (("1" (expand "sq" -1 2) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "sq_neg" ("a" "x!1")) (("2" (lemma "sq_lt" ("nna" "-x!1" "nnb" "1/2")) (("1" (expand "sq" -1 2) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_ssmallreal nonempty-type-eq-decl nil atanx nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (sq_rew formula-decl nil sq reals) (cauchy_vsmallreal? const-decl "bool" atanx nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (<= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (sq const-decl "nonneg_real" sq reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vsmallreal nonempty-type-eq-decl nil atanx nil) (x!1 skolem-const-decl "ssmallreal" atanx nil) (sq_pos formula-decl nil sq reals) (sq_lt formula-decl nil sq reals) (minus_real_is_real application-judgement "real" reals nil) (sq_neg formula-decl nil sq reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (mul_lemma formula-decl nil mul nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) shostak (cauchy_atan_dr subtype "mul.cauchy_mul(atanx.cssx, atanx.cssx)" "cauchy_vsmallreal")) (cauchy_atan_dr_TCC1-1 nil 3288505102 ("" (skosimp*) (("" (typepred "cssx!1") (("" (expand "cauchy_ssmallreal?") (("" (skosimp*) (("" (lemma "mul_lemma" ("x" "x!1" "y" "x!1" "cx" "cssx!1" "cy" "cssx!1")) (("" (rewrite "sq_rew") (("" (assert) (("" (expand "cauchy_vsmallreal?") (("" (typepred "x!1") (("" (case "0 <= sq(x!1) & sq(x!1) < 1/4") (("1" (flatten -1) (("1" (inst + "sq(x!1)") (("1" (assert) nil nil)) nil)) nil) ("2" (hide -3 -4 2) (("2" (lemma "sq_pos" ("a" "x!1")) (("2" (assert) (("2" (case "0 <= x!1") (("1" (lemma "sq_lt" ("nna" "x!1" "nnb" "1/2")) (("1" (expand "sq" -1 2) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "sq_neg" ("a" "x!1")) (("2" (lemma "sq_lt" ("nna" "-x!1" "nnb" "1/2")) (("1" (expand "sq" -1 2) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_ssmallreal nonempty-type-eq-decl nil atanx nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (sq_rew formula-decl nil sq reals) (cauchy_vsmallreal? const-decl "bool" atanx nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (<= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (sq const-decl "nonneg_real" sq reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vsmallreal nonempty-type-eq-decl nil atanx nil) nil (sq_pos formula-decl nil sq reals) (sq_lt formula-decl nil sq reals) (minus_real_is_real application-judgement "real" reals nil) (sq_neg formula-decl nil sq reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (mul_lemma formula-decl nil mul nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) shostak (cauchy_atan_dr subtype "mul.cauchy_mul(atanx.cssx, atanx.cssx)" "cauchy_vsmallreal"))) (cauchy_atan_dr_TCC2 0 (cauchy_atan_dr_TCC2-2 "" 3790106038 ("" (skosimp*) (("" (expand "cauchy_real?") (("" (typepred "cssx!1") (("" (expand "cauchy_ssmallreal?") (("" (skosimp*) (("" (lemma "mul_lemma" ("x" "x!1" "y" "x!1" "cx" "cssx!1" "cy" "cssx!1")) (("" (typepred "x!1") (("" (assert) (("" (rewrite "sq_rew") (("" (lemma "cauchy_atan_drxx_prop" ("vsx" "sq(x!1)" "cvsx" "cauchy_mul(cssx!1, cssx!1)")) (("1" (assert) (("1" (inst + "IF sq(x!1) = 0 THEN 1
                  ELSE atan(sqrt(sq(x!1))) / sqrt(sq(x!1))
                  ENDIF") (("1" (skosimp*) (("1" (rewrite "sqrt_sq" -1) (("1" (replace -1) (("1" (rewrite "sq_0" 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 -2)) (("2" (case "0<=x!1") (("1" (lemma "sq_lt" ("nna" "x!1" "nnb" "1/2")) (("1" (expand "sq" -1 2) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "sq_neg" ("a" "x!1")) (("2" (lemma "sq_lt" ("nna" "-x!1" "nnb" "1/2")) (("1" (expand "sq" -1 2) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "cauchy_vsmallreal?") (("3" (case "0<=sq(x!1) & sq(x!1) < 1/4") (("1" (flatten -1) (("1" (inst + "sq(x!1)") nil nil)) nil) ("2" (hide -3 -4 2) (("2" (lemma "sq_pos" ("a" "x!1")) (("2" (assert) (("2" (case "0<=x!1") (("1" (lemma "sq_lt" ("nna" "x!1" "nnb" "1/2")) (("1" (expand "sq" -1 2) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "sq_neg" ("a" "x!1")) (("2" (lemma "sq_lt" ("nna" "-x!1" "nnb" "1/2")) (("1" (expand "sq" -1 2) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_real? const-decl "bool" cauchy nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (- const-decl "[numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (mul_lemma formula-decl nil mul nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sq const-decl "nonneg_real" sq reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (vsmallreal nonempty-type-eq-decl nil atanx nil) (<= const-decl "bool" reals nil) (cauchy_mul const-decl "cauchy_real" mul nil) (cauchy_vsmallreal nonempty-type-eq-decl nil atanx nil) (cauchy_vsmallreal? const-decl "bool" atanx nil) (cauchy_atan_drxx_prop formula-decl nil atanx nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnreal type-eq-decl nil real_types nil) (atan const-decl "{x: real_abs_lt_pi2 | y = tan_restrict(x)}" atan trig) (tan_restrict const-decl "real" trig_basic trig) (real_abs_lt_pi2 nonempty-type-eq-decl nil trig_types trig) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig) (cos const-decl "real" sincos_def trig) (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (x!1 skolem-const-decl "ssmallreal" atanx nil) (sqrt_sq formula-decl nil sqrt reals) (sqrt_sq_neg formula-decl nil sqrt reals) (minus_real_is_real application-judgement "real" reals nil) (sq_0 formula-decl nil sq reals) (sq_lt formula-decl nil sq reals) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (sq_neg formula-decl nil sq reals) (sq_pos formula-decl nil sq reals) (sq_rew formula-decl nil sq reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (cauchy_ssmallreal nonempty-type-eq-decl nil atanx nil)) shostak (cauchy_atan_dr subtype "atanx.cauchy_atan_drxx(mul.cauchy_mul(atanx.cssx, atanx.cssx))" "cauchy_real")) (cauchy_atan_dr_TCC2-1 nil 3288506197 ("" (skosimp*) (("" (expand "cauchy_real?") (("" (typepred "cssx!1") (("" (expand "cauchy_ssmallreal?") (("" (skosimp*) (("" (lemma "mul_lemma" ("x" "x!1" "y" "x!1" "cx" "cssx!1" "cy" "cssx!1")) (("" (typepred "x!1") (("" (assert) (("" (rewrite "sq_rew") (("" (lemma "cauchy_atan_drxx_prop" ("vsx" "sq(x!1)" "cvsx" "cauchy_mul(cssx!1, cssx!1)")) (("1" (assert) (("1" (inst + "IF sq(x!1) = 0 THEN 1
                  ELSE atan(sqrt(sq(x!1))) / sqrt(sq(x!1))
                  ENDIF") (("1" (skosimp*) (("1" (rewrite "sqrt_sq" -1) (("1" (replace -1) (("1" (rewrite "sq_0" 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 -2)) (("2" (case "0<=x!1") (("1" (lemma "sq_lt" ("nna" "x!1" "nnb" "1/2")) (("1" (expand "sq" -1 2) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "sq_neg" ("a" "x!1")) (("2" (lemma "sq_lt" ("nna" "-x!1" "nnb" "1/2")) (("1" (expand "sq" -1 2) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "cauchy_vsmallreal?") (("3" (case "0<=sq(x!1) & sq(x!1) < 1/4") (("1" (flatten -1) (("1" (inst + "sq(x!1)") (("1" (assert) nil nil)) nil)) nil) ("2" (hide -3 -4 2) (("2" (lemma "sq_pos" ("a" "x!1")) (("2" (assert) (("2" (case "0<=x!1") (("1" (lemma "sq_lt" ("nna" "x!1" "nnb" "1/2")) (("1" (expand "sq" -1 2) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "sq_neg" ("a" "x!1")) (("2" (lemma "sq_lt" ("nna" "-x!1" "nnb" "1/2")) (("1" (expand "sq" -1 2) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_real? const-decl "bool" cauchy nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (- const-decl "[numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (mul_lemma formula-decl nil mul nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sq const-decl "nonneg_real" sq reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (vsmallreal nonempty-type-eq-decl nil atanx nil) (<= const-decl "bool" reals nil) (cauchy_mul const-decl "cauchy_real" mul nil) (cauchy_vsmallreal nonempty-type-eq-decl nil atanx nil) (cauchy_vsmallreal? const-decl "bool" atanx nil) (cauchy_atan_drxx_prop formula-decl nil atanx nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnreal type-eq-decl nil real_types nil) (atan const-decl "{x: real_abs_lt_pi2 | y = tan_restrict(x)}" atan trig) (tan_restrict const-decl "real" trig_basic trig) (real_abs_lt_pi2 nonempty-type-eq-decl nil trig_types trig) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig) (cos const-decl "real" sincos_def trig) (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil (sqrt_sq formula-decl nil sqrt reals) (sqrt_sq_neg formula-decl nil sqrt reals) (minus_real_is_real application-judgement "real" reals nil) (sq_0 formula-decl nil sq reals) (sq_lt formula-decl nil sq reals) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (sq_neg formula-decl nil sq reals) (sq_pos formula-decl nil sq reals) (sq_rew formula-decl nil sq reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (cauchy_ssmallreal nonempty-type-eq-decl nil atanx nil)) shostak (cauchy_atan_dr subtype "atanx.cauchy_atan_drxx(mul.cauchy_mul(atanx.cssx, atanx.cssx))" "cauchy_real"))) (atan_dr_lemma 0 (atan_dr_lemma-2 "" 3790106039 ("" (skosimp*) (("" (expand "cauchy_atan_dr") (("" (lemma "cauchy_atan_drxx_prop" ("vsx" "sq(ssx!1)" "cvsx" "cauchy_mul(cssx!1, cssx!1)")) (("1" (lemma "mul_lemma" ("x" "ssx!1" "cx" "cssx!1" "y" "ssx!1" "cy" "cssx!1")) (("1" (case-replace "sqrt(sq(ssx!1)) = abs(ssx!1)") (("1" (replace -4) (("1" (rewrite "sq_eq_0") (("1" (expand "sq" -3) (("1" (replace -2) (("1" (lemma "mul_lemma" ("x" "ssx!1" "cx" "cssx!1" "y" "IF ssx!1 = 0 THEN 1 ELSE atan(abs(ssx!1)) / abs(ssx!1) ENDIF" "cy" "cauchy_atan_drxx(cauchy_mul(cssx!1, cssx!1))")) (("1" (assert) (("1" (replace -4 -1) (("1" (case-replace "ssx!1 *
                   IF ssx!1 = 0 THEN 1
                   ELSE atan(abs(ssx!1)) / abs(ssx!1)
                   ENDIF = atan(ssx!1)") (("1" (hide-all-but 1) (("1" (expand "abs") (("1" (lemma "trichotomy" ("x" "ssx!1")) (("1" (split -1) (("1" (assert) nil nil) ("2" (assert) (("2" (replace -1) (("2" (rewrite "atan_0") nil nil)) nil)) nil) ("3" (assert) (("3" (rewrite "atan_neg") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "ssx!1") (("2" (case "0<= ssx!1") (("1" (expand "abs") (("1" (rewrite "sqrt_sq") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "abs") (("2" (lemma "sq_neg") (("2" (inst - "ssx!1") (("2" (replace -1 2 rl) (("2" (rewrite "sqrt_sq" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "sq_pos") (("2" (inst - "ssx!1") (("2" (typepred "ssx!1") (("2" (assert) (("2" (case "0<=ssx!1") (("1" (lemma "sq_lt") (("1" (inst - "ssx!1" "1/2") (("1" (expand "sq" -1 2) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (lemma "sq_neg" ("a" "ssx!1")) (("2" (lemma "sq_lt") (("2" (inst - "-ssx!1" "1/2") (("1" (expand "sq" -1 2) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_atan_dr const-decl "cauchy_real" atanx nil) (sq_lt formula-decl nil sq reals) (ssx!1 skolem-const-decl "ssmallreal" atanx nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (sq_pos formula-decl nil sq reals) (mul_lemma formula-decl nil mul nil) (sqrt_sq formula-decl nil sqrt reals) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (sq_neg formula-decl nil sq reals) (real_div_nzreal_is_real application-judgement "real" reals nil) (cauchy_atan_drxx const-decl "[nat -> int]" atanx nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (> const-decl "bool" reals nil) (cos const-decl "real" sincos_def trig) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig) (real_abs_lt_pi2 nonempty-type-eq-decl nil trig_types trig) (tan_restrict const-decl "real" trig_basic trig) (atan const-decl "{x: real_abs_lt_pi2 | y = tan_restrict(x)}" atan trig) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (trichotomy formula-decl nil real_axioms nil) (minus_real_is_real application-judgement "real" reals nil) (atan_neg formula-decl nil atan trig) (atan_0 formula-decl nil atan trig) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (sq_eq_0 formula-decl nil sq reals) (= const-decl "[T, T -> boolean]" equalities nil) (nnreal type-eq-decl nil real_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cauchy_atan_drxx_prop formula-decl nil atanx nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_vsmallreal? const-decl "bool" atanx nil) (cauchy_vsmallreal nonempty-type-eq-decl nil atanx nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_mul const-decl "cauchy_real" mul nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (cauchy_ssmallreal nonempty-type-eq-decl nil atanx nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (vsmallreal nonempty-type-eq-decl nil atanx nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (sq const-decl "nonneg_real" sq reals) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)) shostak) (atan_dr_lemma-1 nil 3288506281 ("" (skosimp*) (("" (expand "cauchy_atan_dr") (("" (lemma "cauchy_atan_drxx_prop" ("vsx" "sq(ssx!1)" "cvsx" "cauchy_mul(cssx!1, cssx!1)")) (("1" (lemma "mul_lemma" ("x" "ssx!1" "cx" "cssx!1" "y" "ssx!1" "cy" "cssx!1")) (("1" (case-replace "sqrt(sq(ssx!1)) = abs(ssx!1)") (("1" (replace -4) (("1" (rewrite "sq_eq_0") (("1" (expand "sq" -3) (("1" (replace -2) (("1" (lemma "mul_lemma" ("x" "ssx!1" "cx" "cssx!1" "y" "IF ssx!1 = 0 THEN 1 ELSE atan(abs(ssx!1)) / abs(ssx!1) ENDIF" "cy" "cauchy_atan_drxx(cauchy_mul(cssx!1, cssx!1))")) (("1" (assert) (("1" (replace -4 -1) (("1" (case-replace "ssx!1 *
                   IF ssx!1 = 0 THEN 1
                   ELSE atan(abs(ssx!1)) / abs(ssx!1)
                   ENDIF = atan(ssx!1)") (("1" (hide-all-but 1) (("1" (expand "abs") (("1" (lemma "trichotomy" ("x" "ssx!1")) (("1" (split -1) (("1" (assert) nil nil) ("2" (assert) (("2" (replace -1) (("2" (rewrite "atan_0") nil nil)) nil)) nil) ("3" (assert) (("3" (rewrite "atan_neg") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (expand "cauchy_real?") (("3" (inst + "IF ssx!1 = 0 THEN 1
                  ELSE atan(abs(ssx!1)) / abs(ssx!1)
                  ENDIF") (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "ssx!1") (("2" (case "0<= ssx!1") (("1" (expand "abs") (("1" (rewrite "sqrt_sq") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "abs") (("2" (lemma "sq_neg") (("2" (inst - "ssx!1") (("2" (replace -1 2 rl) (("2" (rewrite "sqrt_sq" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "sq_pos") (("2" (inst - "ssx!1") (("2" (typepred "ssx!1") (("2" (assert) (("2" (case "0<=ssx!1") (("1" (lemma "sq_lt") (("1" (inst - "ssx!1" "1/2") (("1" (expand "sq" -1 2) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (lemma "sq_neg" ("a" "ssx!1")) (("2" (lemma "sq_lt") (("2" (inst - "-ssx!1" "1/2") (("1" (expand "sq" -1 2) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "cauchy_vsmallreal?") (("3" (inst + "sq(ssx!1)") (("1" (lemma "mul_lemma" ("x" "ssx!1" "cx" "cssx!1" "y" "ssx!1" "cy" "cssx!1")) (("1" (expand "sq" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -1) (("2" (lemma "sq_pos" ("a" "ssx!1")) (("2" (assert) (("2" (typepred "ssx!1") (("2" (case "0<= ssx!1") (("1" (lemma "sq_lt" ("nna" "ssx!1" "nnb" "1/2")) (("1" (expand "sq" -1 2) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "sq_neg" ("a" "ssx!1")) (("2" (lemma "sq_lt" ("nna" "-ssx!1" "nnb" "1/2")) (("1" (expand "sq" -1 2) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_atan_dr const-decl "cauchy_real" atanx nil) (sq_lt formula-decl nil sq reals) nil (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (sq_pos formula-decl nil sq reals) (mul_lemma formula-decl nil mul nil) (sqrt_sq formula-decl nil sqrt reals) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (sq_neg formula-decl nil sq reals) (real_div_nzreal_is_real application-judgement "real" reals nil) (cauchy_atan_drxx const-decl "[nat -> int]" atanx nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (> const-decl "bool" reals nil) (cos const-decl "real" sincos_def trig) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig) (real_abs_lt_pi2 nonempty-type-eq-decl nil trig_types trig) (tan_restrict const-decl "real" trig_basic trig) (atan const-decl "{x: real_abs_lt_pi2 | y = tan_restrict(x)}" atan trig) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (trichotomy formula-decl nil real_axioms nil) (minus_real_is_real application-judgement "real" reals nil) (atan_neg formula-decl nil atan trig) (atan_0 formula-decl nil atan trig) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (sq_eq_0 formula-decl nil sq reals) (= const-decl "[T, T -> boolean]" equalities nil) (nnreal type-eq-decl nil real_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cauchy_atan_drxx_prop formula-decl nil atanx nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_vsmallreal? const-decl "bool" atanx nil) (cauchy_vsmallreal nonempty-type-eq-decl nil atanx nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_mul const-decl "cauchy_real" mul nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (cauchy_ssmallreal nonempty-type-eq-decl nil atanx nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (vsmallreal nonempty-type-eq-decl nil atanx nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (sq const-decl "nonneg_real" sq reals) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)) shostak)) (cauchy_pi_TCC1 0 (cauchy_pi_TCC1-1 nil 3288505102 ("" (expand "cauchy_nzreal?") (("" (inst + "5") (("" (expand "cauchy_int") (("" (expand "cauchy_prop") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (posint_exp application-judgement "posint" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (cauchy_prop const-decl "bool" cauchy nil) (cauchy_int const-decl "cauchy_real" int nil) (cauchy_nzreal? const-decl "bool" cauchy nil)) shostak (cauchy_pi subtype "int.cauchy_int(5)" "cauchy_nzreal"))) (cauchy_pi_TCC2 0 (cauchy_pi_TCC2-1 nil 3288505102 ("" (expand "cauchy_ssmallreal?") (("" (inst + "1/5") (("" (lemma "div_lemma" ("x" "1" "nzy" "5" "cx" "cauchy_int(1)" "nzcy" "cauchy_int(5)")) (("" (rewrite "int_lemma") (("" (rewrite "int_lemma") nil nil)) nil)) nil)) nil)) nil) ((posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (int_lemma formula-decl nil int nil) (div_lemma formula-decl nil div nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_int const-decl "cauchy_real" int nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) shostak (cauchy_pi subtype "div.cauchy_div(int.cauchy_int(1), int.cauchy_int(5))" "cauchy_ssmallreal"))) (cauchy_pi_TCC3 0 (cauchy_pi_TCC3-1 nil 3392689913 ("" (subtype-tcc) nil nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (^ const-decl "real" exponentiation nil) (cauchy_int const-decl "cauchy_real" int nil) (cauchy_prop const-decl "bool" cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil)) nil (cauchy_pi subtype "int.cauchy_int(239)" "cauchy_nzreal"))) (cauchy_pi_TCC4 0 (cauchy_pi_TCC4-1 nil 3392689913 ("" (expand "cauchy_ssmallreal?") (("" (inst + "1/239") (("" (lemma "div_lemma" ("x" "1" "nzy" "239" "cx" "cauchy_int(1)" "nzcy" "cauchy_int(239)")) (("" (rewrite "int_lemma") (("" (rewrite "int_lemma") nil nil)) nil)) nil)) nil)) nil) ((posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (int_lemma formula-decl nil int nil) (div_lemma formula-decl nil div nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_int const-decl "cauchy_real" int nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) nil (cauchy_pi subtype "div.cauchy_div(int.cauchy_int(1), int.cauchy_int(239))" "cauchy_ssmallreal"))) (pi_lemma 0 (pi_lemma-1 nil 3288503798 ("" (expand "cauchy_pi") (("" (lemma "atan_1") (("" (lemma "div_lemma" ("x" "1" "cx" "cauchy_int(1)" "nzy" "5" "nzcy" "cauchy_int(5)")) (("" (lemma "div_lemma" ("x" "1" "cx" "cauchy_int(1)" "nzy" "239" "nzcy" "cauchy_int(239)")) (("" (rewrite "int_lemma") (("" (rewrite "int_lemma") (("" (rewrite "int_lemma") (("" (name-replace "R5" "cauchy_div(cauchy_int(1), cauchy_int(5))") (("" (name-replace "R239" "cauchy_div(cauchy_int(1), cauchy_int(239))") (("" (lemma "atan_dr_lemma" ("ssx" "1/5" "cssx" "R5")) (("" (lemma "atan_dr_lemma" ("ssx" "1/239" "cssx" "R239")) (("" (assert) (("" (hide -1 -6) (("" (lemma "lemma_mul2n" ("x" "atan(1/5)" "cx" "cauchy_atan_dr(R5)" "n" "4")) (("" (lemma "lemma_mul2n" ("x" "atan(1/239)" "cx" "cauchy_atan_dr(R239)" "n" "2")) (("" (assert) (("" (expand "mul2n") (("" (rewrite "expt_x2") (("" (rewrite "expt_x4") (("" (lemma "sub_lemma" ("x" "16*atan(1/5)" "cx" "cauchy_mul2n(cauchy_atan_dr(R5),4)" "y" "4*atan(1/239)" "cy" "cauchy_mul2n(cauchy_atan_dr(R239),2)")) (("" (assert) (("" (rewrite "pi_value" 1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((atan_1 formula-decl nil atan trig) (cauchy_div const-decl "cauchy_real" div nil) (= const-decl "[T, T -> boolean]" equalities nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (atan_dr_lemma formula-decl nil atanx nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (cauchy_ssmallreal nonempty-type-eq-decl nil atanx nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (lemma_mul2n formula-decl nil shift nil) (cauchy_atan_dr const-decl "cauchy_real" atanx nil) (> const-decl "bool" reals nil) (cos const-decl "real" sincos_def trig) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig) (real_abs_lt_pi2 nonempty-type-eq-decl nil trig_types trig) (tan_restrict const-decl "real" trig_basic trig) (atan const-decl "{x: real_abs_lt_pi2 | y = tan_restrict(x)}" atan trig) (expt_x2 formula-decl nil inv nil) (posint_exp application-judgement "posint" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (sub_lemma formula-decl nil sub nil) (cauchy_mul2n const-decl "cauchy_real" shift nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (pi_value formula-decl nil atan trig) (expt_x4 formula-decl nil exponentiation nil) (mul2n const-decl "real" shift nil) (int_lemma formula-decl nil int nil) (div_lemma formula-decl nil div nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_int const-decl "cauchy_real" int nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (/= const-decl "boolean" notequal nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (cauchy_pi const-decl "cauchy_real" atanx nil)) shostak)) (cauchy_atan_TCC1 0 (cauchy_atan_TCC1-2 "" 3804550530 ("" (skosimp*) (("" (replace -1) (("" (hide-all-but (-6 1)) (("" (typepred "cx!1") (("" (expand "cauchy_nzreal?") (("" (expand "cauchy_real?") (("" (skosimp) (("" (expand "cauchy_prop") (("" (inst-cp - "3") (("" (rewrite "expt_x3") (("" (flatten) (("" (case "x!1<-19/8") (("1" (inst + "x!1") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (cauchy_atan subtype "atanx.cx" "cauchy_nzreal")) (cauchy_atan_TCC1-1 nil 3288505106 ("" (skosimp*) (("" (replace -1) (("" (hide-all-but (-5 1)) (("" (typepred "cx!1") (("" (expand "cauchy_nzreal?") (("" (expand "cauchy_real?") (("" (skosimp) (("" (expand "cauchy_prop") (("" (inst-cp - "3") (("" (rewrite "expt_x3") (("" (flatten) (("" (case "x!1<-19/8") (("1" (inst + "x!1") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (posint_exp application-judgement "posint" exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (expt_x3 formula-decl nil exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (x!1 skolem-const-decl "real" atanx nil) (nzreal nonempty-type-eq-decl nil reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cauchy_nzreal? const-decl "bool" cauchy nil)) shostak (cauchy_atan subtype "atanx.cx" "cauchy_nzreal"))) (cauchy_atan_TCC2 0 (cauchy_atan_TCC2-2 "" 3804550611 ("" (skosimp*) (("" (replace -1) (("" (hide-all-but (-6 1)) (("" (typepred "cx!1") (("" (expand "cauchy_real?") (("" (expand "cauchy_ssmallreal?") (("" (skosimp) (("" (expand "cauchy_prop") (("" (inst-cp - "3") (("" (rewrite "expt_x3") (("" (flatten) (("" (case "x!1<-19/8") (("1" (inst + "-(1/x!1)") (("1" (skosimp) (("1" (lemma "inv_lemma" ("nzx" "x!1" "nzcx" "cx!1")) (("1" (split -1) (("1" (lemma "neg_lemma" ("x" "1/x!1" "cx" "cauchy_inv(cx!1)")) (("1" (assert) (("1" (expand "cauchy_prop") (("1" (inst - "p!1") nil nil)) nil)) nil)) nil) ("2" (expand "cauchy_prop") (("2" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide 2) (("3" (expand "cauchy_nzreal?") (("3" (inst + "x!1") (("1" (expand "cauchy_prop") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "div_mult_pos_lt1" 1) (("2" (rewrite "div_mult_pos_lt2" 1) (("2" (lemma "both_sides_div_neg_lt3" ("nz" "-1" "nx" "x!1" "ny" "-19 / 8")) (("2" (assert) (("2" (lemma "negreal_div_negreal_is_posreal" ("nx" "-1" "ny" "x!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (cauchy_atan subtype "neg.cauchy_neg(inv.cauchy_inv(atanx.cx))" "cauchy_ssmallreal")) (cauchy_atan_TCC2-1 nil 3288505106 ("" (skosimp*) (("" (replace -1) (("" (hide-all-but (-5 1)) (("" (typepred "cx!1") (("" (expand "cauchy_real?") (("" (expand "cauchy_ssmallreal?") (("" (skosimp) (("" (expand "cauchy_prop") (("" (inst-cp - "3") (("" (rewrite "expt_x3") (("" (flatten) (("" (case "x!1<-19/8") (("1" (inst + "-(1/x!1)") (("1" (skosimp) (("1" (lemma "inv_lemma" ("nzx" "x!1" "nzcx" "cx!1")) (("1" (split -1) (("1" (lemma "neg_lemma" ("x" "1/x!1" "cx" "cauchy_inv(cx!1)")) (("1" (assert) (("1" (expand "cauchy_prop") (("1" (inst - "p!1") nil nil)) nil)) nil)) nil) ("2" (expand "cauchy_prop") (("2" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide 2) (("3" (expand "cauchy_nzreal?") (("3" (inst + "x!1") (("1" (expand "cauchy_prop") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "div_mult_pos_lt1" 1) (("2" (rewrite "div_mult_pos_lt2" 1) (("2" (lemma "both_sides_div_neg_lt3" ("nz" "-1" "nx" "x!1" "ny" "-19 / 8")) (("2" (assert) (("2" (lemma "negreal_div_negreal_is_posreal" ("nx" "-1" "ny" "x!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (posint_exp application-judgement "posint" exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (expt_x3 formula-decl nil exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (negreal_div_negreal_is_posreal judgement-tcc nil real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (both_sides_div_neg_lt3 formula-decl nil real_props nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (neg_cauchy_nzreal_is_cauchy_nzreal application-judgement "cauchy_nzreal" neg nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_even_is_even application-judgement "even_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (cauchy_inv const-decl "cauchy_nzreal" inv nil) (neg_lemma formula-decl nil neg nil) (nzreal nonempty-type-eq-decl nil reals nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (inv_lemma formula-decl nil inv nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (x!1 skolem-const-decl "real" atanx nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak (cauchy_atan subtype "neg.cauchy_neg(inv.cauchy_inv(atanx.cx))" "cauchy_ssmallreal"))) (cauchy_atan_TCC3 0 (cauchy_atan_TCC3-2 "" 3804550693 ("" (skosimp*) (("" (case "-19 <= t!1") (("1" (replace -2) (("1" (hide-all-but (-1 -3 -7 2)) (("1" (typepred "cx!1") (("1" (expand "cauchy_real?") (("1" (skosimp) (("1" (copy -1) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (flatten) (("1" (rewrite "expt_x3") (("1" (case "-20/8<x!1&x!1<-3/8") (("1" (flatten) (("1" (lemma "sub_lemma" ("x" "x!1" "cx" "cx!1" "y" "1" "cy" "cauchy_int(1)")) (("1" (rewrite "int_lemma") (("1" (assert) (("1" (expand "cauchy_nzreal?") (("1" (inst + "x!1-1") (("1" (replace -8 * rl) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) nil shostak (cauchy_atan subtype "atanx.cxm1" "cauchy_nzreal")) (cauchy_atan_TCC3-1 nil 3288505107 ("" (skosimp*) (("" (case "-19 <= t!1") (("1" (replace -2) (("1" (hide-all-but (-1 -3 -6 2)) (("1" (typepred "cx!1") (("1" (expand "cauchy_real?") (("1" (skosimp) (("1" (copy -1) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (flatten) (("1" (rewrite "expt_x3") (("1" (case "-20/8<x!1&x!1<-3/8") (("1" (flatten) (("1" (lemma "sub_lemma" ("x" "x!1" "cx" "cx!1" "y" "1" "cy" "cauchy_int(1)")) (("1" (rewrite "int_lemma") (("1" (assert) (("1" (expand "cauchy_nzreal?") (("1" (inst + "x!1-1") (("1" (replace -8 * rl) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (expt_x3 formula-decl nil exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (int_lemma formula-decl nil int nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (nzreal nonempty-type-eq-decl nil reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cauchy_int const-decl "cauchy_real" int nil) (sub_lemma formula-decl nil sub nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (cauchy_prop const-decl "bool" cauchy nil) (posint_exp application-judgement "posint" exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil)) shostak (cauchy_atan subtype "atanx.cxm1" "cauchy_nzreal"))) (cauchy_atan_TCC4 0 (cauchy_atan_TCC4-2 "" 3804550762 ("" (skosimp*) (("" (case "-19<=t!1") (("1" (replace -2) (("1" (hide (-2 1 -5 -6)) (("1" (typepred "cx!1") (("1" (expand "cauchy_real?") (("1" (skosimp) (("1" (copy -1) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "-20/8<x!1&x!1<-3/8") (("1" (flatten) (("1" (hide -3 -4 -6 -9) (("1" (lemma "sub_lemma" ("x" "x!1" "cx" "cx!1" "y" "1" "cy" "cauchy_int(1)")) (("1" (lemma "add_lemma" ("x" "x!1" "cx" "cx!1" "y" "1" "cy" "cauchy_int(1)")) (("1" (assert) (("1" (rewrite "int_lemma") (("1" (lemma "div_lemma" ("x" "1+x!1" "cx" "cauchy_add(cx!1, cauchy_int(1))" "nzy" "x!1-1" "nzcy" "cauchy_sub(cx!1, cauchy_int(1))")) (("1" (assert) (("1" (expand "cauchy_ssmallreal?") (("1" (inst + "(1 + x!1) / (x!1 - 1)") (("1" (assert) nil nil) ("2" (hide-all-but (-4 -5 1)) (("2" (lemma "div_mult_neg_lt1" ("ny" "x!1-1" "z" "1+x!1" "x" "1/2")) (("2" (lemma "div_mult_neg_lt2" ("ny" "x!1-1" "z" "1+x!1" "x" "-1/2")) (("2" (replace -1) (("2" (replace -2) (("2" (hide -1 -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cauchy_nzreal?") (("2" (inst + "x!1-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) nil shostak (cauchy_atan subtype "div.cauchy_div(atanx.cxp1, atanx.cxm1)" "cauchy_ssmallreal")) (cauchy_atan_TCC4-1 nil 3288505107 ("" (skosimp*) (("" (case "-19<=t!1") (("1" (replace -2) (("1" (hide (-2 1 -5 -7)) (("1" (typepred "cx!1") (("1" (expand "cauchy_real?") (("1" (skosimp) (("1" (copy -1) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "-20/8<x!1&x!1<-3/8") (("1" (flatten) (("1" (hide -3 -4 -6 -9) (("1" (lemma "sub_lemma" ("x" "x!1" "cx" "cx!1" "y" "1" "cy" "cauchy_int(1)")) (("1" (lemma "add_lemma" ("x" "x!1" "cx" "cx!1" "y" "1" "cy" "cauchy_int(1)")) (("1" (assert) (("1" (rewrite "int_lemma") (("1" (lemma "div_lemma" ("x" "1+x!1" "cx" "cauchy_add(cx!1, cauchy_int(1))" "nzy" "x!1-1" "nzcy" "cauchy_sub(cx!1, cauchy_int(1))")) (("1" (assert) (("1" (expand "cauchy_ssmallreal?") (("1" (inst + "(1 + x!1) / (x!1 - 1)") (("1" (assert) nil nil) ("2" (hide-all-but (-4 -5 1)) (("2" (lemma "div_mult_neg_lt1" ("ny" "x!1-1" "z" "1+x!1" "x" "1/2")) (("2" (lemma "div_mult_neg_lt2" ("ny" "x!1-1" "z" "1+x!1" "x" "-1/2")) (("2" (replace -1) (("2" (replace -2) (("2" (hide -1 -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cauchy_nzreal?") (("2" (inst + "x!1-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (sub_lemma formula-decl nil sub nil) (cauchy_int const-decl "cauchy_real" int nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_even_is_even application-judgement "even_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (div_lemma formula-decl nil div nil) (cauchy_add const-decl "cauchy_real" add nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_sub const-decl "cauchy_real" sub nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (div_mult_neg_lt2 formula-decl nil real_props nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (negreal nonempty-type-eq-decl nil real_types nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (div_mult_neg_lt1 formula-decl nil real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (x!1 skolem-const-decl "real" atanx nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nzreal nonempty-type-eq-decl nil reals nil) (int_lemma formula-decl nil int nil) (add_lemma formula-decl nil add nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (int_times_even_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (expt_x3 formula-decl nil exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (posint_exp application-judgement "posint" exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil)) shostak (cauchy_atan subtype "div.cauchy_div(atanx.cxp1, atanx.cxm1)" "cauchy_ssmallreal"))) (cauchy_atan_TCC5 0 (cauchy_atan_TCC5-2 "" 3804550820 ("" (skosimp*) (("" (case "-3<=t!1") (("1" (replace -2) (("1" (hide-all-but (-1 -7 3)) (("1" (typepred "cx!1") (("1" (expand "cauchy_real?") (("1" (skosimp) (("1" (copy -1) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "-1/2<x!1&x!1<1/2") (("1" (flatten) (("1" (expand "cauchy_ssmallreal?") (("1" (inst + "x!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) nil shostak (cauchy_atan subtype "atanx.cx" "cauchy_ssmallreal")) (cauchy_atan_TCC5-1 nil 3288505107 ("" (skosimp*) (("" (case "-3<=t!1") (("1" (replace -2) (("1" (hide-all-but (-1 -6 3)) (("1" (typepred "cx!1") (("1" (expand "cauchy_real?") (("1" (skosimp) (("1" (copy -1) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "-1/2<x!1&x!1<1/2") (("1" (flatten) (("1" (expand "cauchy_ssmallreal?") (("1" (inst + "x!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (x!1 skolem-const-decl "real" atanx nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (int_times_even_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (expt_x3 formula-decl nil exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (posint_exp application-judgement "posint" exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cauchy_real? const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (cauchy_atan subtype "atanx.cx" "cauchy_ssmallreal"))) (cauchy_atan_TCC6 0 (cauchy_atan_TCC6-1 nil 3392689913 ("" (skosimp*) (("" (case "4<=t!1") (("1" (replace -2) (("1" (typepred "cx!1") (("1" (expand "cauchy_real?") (("1" (skosimp) (("1" (copy -1) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "3/8<x!1&x!1<20/8") (("1" (flatten) (("1" (hide -3 -4 -6 -7 -11 -10 -12 -8 1 2 3) (("1" (lemma "add_lemma" ("x" "x!1" "cx" "cx!1" "y" "1" "cy" "cauchy_int(1)")) (("1" (rewrite "int_lemma") (("1" (assert) (("1" (expand "cauchy_nzreal?") (("1" (inst + "1+x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_exp application-judgement "posint" exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (expt_x3 formula-decl nil exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (int_lemma formula-decl nil int nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (nzreal nonempty-type-eq-decl nil reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cauchy_int const-decl "cauchy_real" int nil) (add_lemma formula-decl nil add nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cauchy_atan subtype "atanx.cxp1" "cauchy_nzreal"))) (cauchy_atan_TCC7 0 (cauchy_atan_TCC7-1 nil 3392689913 ("" (skosimp*) (("" (case "4<=t!1") (("1" (replace -2) (("1" (typepred "cx!1") (("1" (expand "cauchy_real?") (("1" (skosimp) (("1" (copy -1) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "3/8<x!1&x!1<20/8") (("1" (flatten) (("1" (hide -3 -4 -6 -7 -10 -11 -12 1 2 3) (("1" (lemma "add_lemma" ("x" "x!1" "cx" "cx!1" "y" "1" "cy" "cauchy_int(1)")) (("1" (lemma "sub_lemma" ("x" "x!1" "cx" "cx!1" "y" "1" "cy" "cauchy_int(1)")) (("1" (rewrite "int_lemma") (("1" (assert) (("1" (lemma "div_lemma" ("x" "x!1-1" "cx" "cxm1!1" "nzy" "1+x!1" "nzcy" "cxp1!1")) (("1" (assert) (("1" (expand "cauchy_ssmallreal?") (("1" (inst + "(x!1 - 1) / (1 + x!1)") (("1" (hide-all-but (-4 -5 1)) (("1" (rewrite "div_mult_pos_lt1") (("1" (rewrite "div_mult_pos_lt1") (("1" (lemma "div_mult_pos_lt2" ("py" "1+x!1" "z" "2*(x!1-1)" "x" "-1")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_exp application-judgement "posint" exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (expt_x3 formula-decl nil exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (sub_lemma formula-decl nil sub nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (- const-decl "[numfield -> numfield]" number_fields nil) (x!1 skolem-const-decl "real" atanx nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (div_lemma formula-decl nil div nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_lemma formula-decl nil int nil) (cauchy_int const-decl "cauchy_real" int nil) (add_lemma formula-decl nil add nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cauchy_atan subtype "div.cauchy_div(atanx.cxm1, atanx.cxp1)" "cauchy_ssmallreal"))) (cauchy_atan_TCC8 0 (cauchy_atan_TCC8-1 nil 3392689913 ("" (skosimp*) (("" (case "20<=cx!1(3)") (("1" (typepred "cx!1") (("1" (expand "cauchy_real?") (("1" (skosimp) (("1" (copy -1) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "19/8<x!1") (("1" (hide -2 -3 -5 -6 -7 -8 -9 -10 1 2 3 4) (("1" (expand "cauchy_nzreal?") (("1" (inst + "x!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nzreal nonempty-type-eq-decl nil reals nil) (x!1 skolem-const-decl "real" atanx nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (int_times_even_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (expt_x3 formula-decl nil exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (posint_exp application-judgement "posint" exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cauchy_atan subtype "atanx.cx" "cauchy_nzreal"))) (cauchy_atan_TCC9 0 (cauchy_atan_TCC9-1 nil 3392689913 ("" (skosimp*) (("" (case "20<=cx!1(3)") (("1" (hide-all-but (-1 5)) (("1" (typepred "cx!1") (("1" (expand "cauchy_real?") (("1" (skosimp) (("1" (copy -1) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "19/8<x!1") (("1" (hide -2 -3 -5) (("1" (lemma "inv_lemma" ("nzx" "x!1" "nzcx" "cx!1")) (("1" (assert) (("1" (expand "cauchy_ssmallreal?") (("1" (inst + "1/x!1") (("1" (rewrite "div_mult_pos_lt2" 1) (("1" (rewrite "div_mult_pos_lt1" 1) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_exp application-judgement "posint" exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (expt_x3 formula-decl nil exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (inv_lemma formula-decl nil inv nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (nzreal nonempty-type-eq-decl nil reals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (x!1 skolem-const-decl "real" atanx nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_even_is_even application-judgement "even_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cauchy_atan subtype "inv.cauchy_inv(atanx.cx)" "cauchy_ssmallreal"))) (atan_lemma 0 (atan_lemma-2 nil 3708424013 ("" (skosimp) (("" (expand "cauchy_atan") (("" (case-replace "cx!1(3)<=-20") (("1" (copy -2) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "x!1<-19/8") (("1" (hide -2 -3 -4) (("1" (lemma "inv_lemma" ("nzx" "x!1" "nzcx" "cx!1")) (("1" (assert) (("1" (lemma "neg_lemma" ("x" "1/x!1" "cx" "cauchy_inv(cx!1)")) (("1" (assert) (("1" (lemma "atan_dr_lemma" ("ssx" "-(1 / x!1)" "cssx" "cauchy_neg(cauchy_inv(cx!1))")) (("1" (assert) (("1" (lemma "lemma_div2n" ("x" "pi" "cx" "cauchy_pi" "n" "1")) (("1" (rewrite "pi_lemma") (("1" (expand "div2n") (("1" (rewrite "expt_x1") (("1" (lemma "sub_lemma" ("x" "atan(-(1 / x!1))" "cx" "cauchy_atan_dr(cauchy_neg(cauchy_inv(cx!1)))" "y" "pi/2" "cy" "cauchy_div2n(cauchy_pi, 1)")) (("1" (assert) (("1" (lemma "atan_inv" ("px" "-x!1")) (("1" (replace -1) (("1" (assert) (("1" (rewrite "atan_neg" -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (case "-8/19<1/x!1&1/x!1<0") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (split) (("1" (rewrite "div_mult_neg_lt2" 1) nil nil) ("2" (assert) (("2" (rewrite "div_mult_neg_lt1" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "cx!1(3)<=-4") (("1" (assert) (("1" (case "-19<=cx!1(3)") (("1" (hide 1) (("1" (copy -3) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "-20/8<x!1&x!1<-3/8") (("1" (hide -2 -3 -4 -5) (("1" (flatten) (("1" (lemma "int_lemma" ("n" "1")) (("1" (lemma "add_lemma" ("x" "x!1" "y" "1" "cx" "cx!1" "cy" "cauchy_int(1)")) (("1" (lemma "sub_lemma" ("x" "x!1" "y" "1" "cx" "cx!1" "cy" "cauchy_int(1)")) (("1" (assert) (("1" (lemma "div_lemma" ("x" "1 + x!1" "cx" "cauchy_add(cx!1, cauchy_int(1))" "nzy" "x!1 - 1" "nzcy" "cauchy_sub(cx!1, cauchy_int(1))")) (("1" (assert) (("1" (lemma "atan_dr_lemma" ("ssx" "(1 + x!1) / (x!1 - 1)" "cssx" "cauchy_div(cauchy_add(cx!1, cauchy_int(1)),
                                                   cauchy_sub(cx!1, cauchy_int(1)))")) (("1" (assert) (("1" (hide -2 -3 -4 -5 -8) (("1" (lemma "lemma_div2n" ("x" "pi" "cx" "cauchy_pi" "n" "2")) (("1" (rewrite "pi_lemma") (("1" (expand "div2n") (("1" (rewrite "expt_x2") (("1" (lemma "neg_lemma" ("x" "pi/4" "cx" "cauchy_div2n(cauchy_pi, 2)")) (("1" (assert) (("1" (lemma "atan_plus" ("x" "x!1" "y" "1")) (("1" (assert) (("1" (lemma "atan_neg" ("x" "(1 + x!1) / (1 - x!1)")) (("1" (assert) (("1" (case-replace "-((1 + x!1) / (1 - x!1)) = (1 + x!1) / (x!1 - 1)") (("1" (assert) (("1" (rewrite "pi_value") (("1" (assert) (("1" (lemma "sub_lemma" ("x" "-atan(1)" "y" "atan((1 + x!1) / (x!1 - 1))" "cx" "cauchy_neg(cauchy_div2n(cauchy_pi, 2))" "cy" "cauchy_atan_dr(cauchy_div(cauchy_add
                                                                          (cx!1, cauchy_int(1)),
                                                                          cauchy_sub
                                                                          (cx!1, cauchy_int(1))))")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (assert) (("2" (lemma "times_div1" ("x" "-1" "y" "1+x!1" "n0z" "1-x!1")) (("2" (replace -1 1) (("2" (hide -1) (("2" (rewrite "cross_mult") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -6 1)) (("2" (split) (("1" (rewrite "div_mult_neg_lt2" 1) nil nil) ("2" (rewrite "div_mult_neg_lt1" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case-replace "cx!1(3)<=3") (("1" (assert) (("1" (case "-3<=cx!1(3)") (("1" (hide 1 2) (("1" (copy -3) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "-1/2<x!1&x!1<1/2") (("1" (hide -2 -3 -4 -5) (("1" (flatten) (("1" (lemma "atan_dr_lemma" ("ssx" "x!1" "cssx" "cx!1")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case-replace "cx!1(3)<=19") (("1" (assert) (("1" (case "4<=cx!1(3)") (("1" (hide 1 2 3) (("1" (copy -3) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (flatten) (("1" (rewrite "expt_x3") (("1" (case "3/8<x!1&x!1<20/8") (("1" (hide -2 -3 -4 -5) (("1" (flatten) (("1" (lemma "int_lemma" ("n" "1")) (("1" (lemma "add_lemma" ("x" "x!1" "y" "1" "cx" "cx!1" "cy" "cauchy_int(1)")) (("1" (lemma "sub_lemma" ("x" "x!1" "y" "1" "cx" "cx!1" "cy" "cauchy_int(1)")) (("1" (assert) (("1" (lemma "div_lemma" ("x" "x!1-1" "cx" "cauchy_sub(cx!1, cauchy_int(1))" "nzy" "1 + x!1" "nzcy" "cauchy_add(cx!1, cauchy_int(1))")) (("1" (assert) (("1" (lemma "atan_dr_lemma" ("ssx" "(x!1 - 1) / (1 + x!1)" "cssx" "cauchy_div(cauchy_sub(cx!1, cauchy_int(1)),
                                                           cauchy_add(cx!1, cauchy_int(1)))")) (("1" (assert) (("1" (hide -2 -3 -4 -5 -8) (("1" (lemma "lemma_div2n" ("x" "pi" "cx" "cauchy_pi" "n" "2")) (("1" (rewrite "pi_lemma") (("1" (expand "div2n") (("1" (rewrite "expt_x2") (("1" (assert) (("1" (lemma "atan_minus" ("x" "x!1" "y" "1")) (("1" (assert) (("1" (rewrite "pi_value") (("1" (assert) (("1" (lemma "add_lemma" ("x" "atan(1)" "y" "atan((x!1 - 1) / (1 + x!1))" "cx" "cauchy_div2n(cauchy_pi, 2)" "cy" "cauchy_atan_dr(cauchy_div(cauchy_sub
                                                                              (cx!1, cauchy_int(1)),
                                                                              cauchy_add
                                                                              (cx!1, cauchy_int(1))))")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -6 1)) (("2" (split) (("1" (rewrite "div_mult_pos_lt2" 1) nil nil) ("2" (rewrite "div_mult_pos_lt1" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "20<=cx!1(3)") (("1" (hide 1 2 3 4) (("1" (copy -2) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "19/8<x!1") (("1" (hide -2 -3 -4) (("1" (lemma "inv_lemma" ("nzx" "x!1" "nzcx" "cx!1")) (("1" (assert) (("1" (lemma "atan_dr_lemma" ("ssx" "1/x!1" "cssx" "cauchy_inv(cx!1)")) (("1" (assert) (("1" (rewrite "atan_inv") (("1" (lemma "lemma_div2n" ("x" "pi" "cx" "cauchy_pi" "n" "1")) (("1" (rewrite "pi_lemma") (("1" (expand "div2n") (("1" (rewrite "expt_x1") (("1" (lemma "sub_lemma" ("x" "pi / 2" "cx" "cauchy_div2n(cauchy_pi, 1)" "y" "pi / 2 - atan(x!1)" "cy" "cauchy_atan_dr(cauchy_inv(cx!1))")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "0<1/x!1&1/x!1<8/19") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide-all-but (-2 1)) (("2" (split) (("1" (assert) (("1" (rewrite "div_mult_pos_lt2" 1) nil nil)) nil) ("2" (rewrite "div_mult_pos_lt1" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cauchy_atan const-decl "cauchy_real" atanx nil) (int_lemma formula-decl nil int nil) (real_plus_real_is_real application-judgement "real" reals nil) (div_lemma formula-decl nil div nil) (cauchy_add const-decl "cauchy_real" add nil) (cauchy_sub const-decl "cauchy_real" sub nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (cauchy_div const-decl "cauchy_real" div nil) (expt_x2 formula-decl nil inv nil) (times_div1 formula-decl nil real_props nil) (cross_mult formula-decl nil real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (pi_value formula-decl nil atan trig) (atan_plus formula-decl nil atan trig) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (cauchy_int const-decl "cauchy_real" int nil) (add_lemma formula-decl nil add nil) (atan_minus formula-decl nil atan trig) (div_mult_pos_lt2 formula-decl nil real_props nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (nprat_div_posrat_is_nprat application-judgement "nprat" rationals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (neg_cauchy_nzreal_is_cauchy_nzreal application-judgement "cauchy_nzreal" neg nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (div_mult_neg_lt2 formula-decl nil real_props nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (div_mult_neg_lt1 formula-decl nil real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pi_lemma formula-decl nil atanx nil) (expt_x1 formula-decl nil exponentiation nil) (atan_neg formula-decl nil atan trig) (real_minus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (atan_inv formula-decl nil atan trig) (minus_real_is_real application-judgement "real" reals nil) (atan const-decl "{x: real_abs_lt_pi2 | y = tan_restrict(x)}" atan trig) (tan_restrict const-decl "real" trig_basic trig) (real_abs_lt_pi2 nonempty-type-eq-decl nil trig_types trig) (cauchy_div2n const-decl "cauchy_real" shift nil) (cauchy_atan_dr const-decl "cauchy_real" atanx nil) (sub_lemma formula-decl nil sub nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (div2n const-decl "real" shift nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig) (cos const-decl "real" sincos_def trig) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (cauchy_pi const-decl "cauchy_real" atanx nil) (lemma_div2n formula-decl nil shift nil) (ssmallreal nonempty-type-eq-decl nil atanx nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cauchy_neg const-decl "cauchy_real" neg nil) (cauchy_ssmallreal nonempty-type-eq-decl nil atanx nil) (cauchy_ssmallreal? const-decl "bool" atanx nil) (atan_dr_lemma formula-decl nil atanx nil) (cauchy_inv const-decl "cauchy_nzreal" inv nil) (neg_lemma formula-decl nil neg nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzreal nonempty-type-eq-decl nil reals nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (inv_lemma formula-decl nil inv nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (< const-decl "bool" reals nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (int_times_even_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (expt_x3 formula-decl nil exponentiation nil) (cauchy_prop const-decl "bool" cauchy nil) (posint_exp application-judgement "posint" exponentiation nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_even_is_even application-judgement "even_int" integers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig)) nil) (atan_lemma-1 nil 3287978357 ("" (skosimp) (("" (expand "cauchy_atan") (("" (case-replace "cx!1(3)<=-20") (("1" (copy -2) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "x!1<-19/8") (("1" (hide -2 -3 -4) (("1" (lemma "inv_lemma" ("nzx" "x!1" "nzcx" "cx!1")) (("1" (assert) (("1" (lemma "neg_lemma" ("x" "1/x!1" "cx" "cauchy_inv(cx!1)")) (("1" (assert) (("1" (lemma "atan_dr_lemma" ("ssx" "-(1 / x!1)" "cssx" "cauchy_neg(cauchy_inv(cx!1))")) (("1" (assert) (("1" (lemma "lemma_div2n" ("x" "pi" "cx" "cauchy_pi" "n" "1")) (("1" (rewrite "pi_lemma") (("1" (expand "div2n") (("1" (rewrite "expt_x1") (("1" (lemma "sub_lemma" ("x" "atan(-(1 / x!1))" "cx" "cauchy_atan_dr(cauchy_neg(cauchy_inv(cx!1)))" "y" "pi/2" "cy" "cauchy_div2n(cauchy_pi, 1)")) (("1" (assert) (("1" (lemma "atan_inv" ("px" "-x!1")) (("1" (replace -1) (("1" (assert) (("1" (rewrite "atan_neg" -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (case "-8/19<1/x!1&1/x!1<0") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (split) (("1" (rewrite "div_mult_neg_lt2" 1) nil nil) ("2" (assert) (("2" (rewrite "div_mult_neg_lt1" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "cx!1(3)<=-4") (("1" (assert) (("1" (case "-19<=cx!1(3)") (("1" (hide 1) (("1" (copy -3) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "-20/8<x!1&x!1<-3/8") (("1" (hide -2 -3 -4 -5) (("1" (flatten) (("1" (lemma "int_lemma" ("n" "1")) (("1" (lemma "add_lemma" ("x" "x!1" "y" "1" "cx" "cx!1" "cy" "cauchy_int(1)")) (("1" (lemma "sub_lemma" ("x" "x!1" "y" "1" "cx" "cx!1" "cy" "cauchy_int(1)")) (("1" (assert) (("1" (lemma "div_lemma" ("x" "1 + x!1" "cx" "cauchy_add(cx!1, cauchy_int(1))" "nzy" "x!1 - 1" "nzcy" "cauchy_sub(cx!1, cauchy_int(1))")) (("1" (assert) (("1" (lemma "atan_dr_lemma" ("ssx" "(1 + x!1) / (x!1 - 1)" "cssx" "cauchy_div(cauchy_add(cx!1, cauchy_int(1)),
                             cauchy_sub(cx!1, cauchy_int(1)))")) (("1" (assert) (("1" (hide -2 -3 -4 -5 -8) (("1" (lemma "lemma_div2n" ("x" "pi" "cx" "cauchy_pi" "n" "2")) (("1" (rewrite "pi_lemma") (("1" (expand "div2n") (("1" (rewrite "expt_x2") (("1" (lemma "neg_lemma" ("x" "pi/4" "cx" "cauchy_div2n(cauchy_pi, 2)")) (("1" (assert) (("1" (lemma "atan_plus" ("x" "x!1" "y" "1")) (("1" (assert) (("1" (lemma "atan_neg" ("x" "(1 + x!1) / (1 - x!1)")) (("1" (assert) (("1" (case-replace "-((1 + x!1) / (1 - x!1)) = (1 + x!1) / (x!1 - 1)") (("1" (assert) (("1" (expand "pi") (("1" (assert) (("1" (expand "atan" -3 1) (("1" (assert) (("1" (lemma "sub_lemma" ("x" "-atan_value(1)" "y" "atan((1 + x!1) / (x!1 - 1))" "cx" "cauchy_neg(cauchy_div2n(cauchy_pi, 2))" "cy" "cauchy_atan_dr(cauchy_div(cauchy_add
                                            (cx!1, cauchy_int(1)),
                                            cauchy_sub
                                            (cx!1, cauchy_int(1))))")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (assert) (("2" (lemma "times_div1" ("x" "-1" "y" "1+x!1" "n0z" "1-x!1")) (("2" (replace -1 1) (("2" (hide -1) (("2" (rewrite "cross_mult") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -6 1)) (("2" (split) (("1" (rewrite "div_mult_neg_lt2" 1) nil nil) ("2" (rewrite "div_mult_neg_lt1" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case-replace "cx!1(3)<=3") (("1" (assert) (("1" (case "-3<=cx!1(3)") (("1" (hide 1 2) (("1" (copy -3) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "-1/2<x!1&x!1<1/2") (("1" (hide -2 -3 -4 -5) (("1" (flatten) (("1" (lemma "atan_dr_lemma" ("ssx" "x!1" "cssx" "cx!1")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case-replace "cx!1(3)<=19") (("1" (assert) (("1" (case "4<=cx!1(3)") (("1" (hide 1 2 3) (("1" (copy -3) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (flatten) (("1" (rewrite "expt_x3") (("1" (case "3/8<x!1&x!1<20/8") (("1" (hide -2 -3 -4 -5) (("1" (flatten) (("1" (lemma "int_lemma" ("n" "1")) (("1" (lemma "add_lemma" ("x" "x!1" "y" "1" "cx" "cx!1" "cy" "cauchy_int(1)")) (("1" (lemma "sub_lemma" ("x" "x!1" "y" "1" "cx" "cx!1" "cy" "cauchy_int(1)")) (("1" (assert) (("1" (lemma "div_lemma" ("x" "x!1-1" "cx" "cauchy_sub(cx!1, cauchy_int(1))" "nzy" "1 + x!1" "nzcy" "cauchy_add(cx!1, cauchy_int(1))")) (("1" (assert) (("1" (lemma "atan_dr_lemma" ("ssx" "(x!1 - 1) / (1 + x!1)" "cssx" "cauchy_div(cauchy_sub(cx!1, cauchy_int(1)),
                             cauchy_add(cx!1, cauchy_int(1)))")) (("1" (assert) (("1" (hide -2 -3 -4 -5 -8) (("1" (lemma "lemma_div2n" ("x" "pi" "cx" "cauchy_pi" "n" "2")) (("1" (rewrite "pi_lemma") (("1" (expand "div2n") (("1" (rewrite "expt_x2") (("1" (assert) (("1" (lemma "atan_minus" ("x" "x!1" "y" "1")) (("1" (assert) (("1" (expand "pi") (("1" (assert) (("1" (expand "atan" -1 2) (("1" (assert) (("1" (lemma "add_lemma" ("x" "atan_value(1)" "y" "atan((x!1 - 1) / (1 + x!1))" "cx" "cauchy_div2n(cauchy_pi, 2)" "cy" "cauchy_atan_dr(cauchy_div(cauchy_sub
                                            (cx!1, cauchy_int(1)),
                                            cauchy_add
                                            (cx!1, cauchy_int(1))))")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -6 1)) (("2" (split) (("1" (rewrite "div_mult_pos_lt2" 1) nil nil) ("2" (rewrite "div_mult_pos_lt1" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (case "20<=cx!1(3)") (("1" (assert) (("1" (hide 1 2 3 4) (("1" (copy -2) (("1" (expand "cauchy_prop" -1) (("1" (inst - "3") (("1" (rewrite "expt_x3") (("1" (flatten) (("1" (case "19/8<x!1") (("1" (hide -2 -3 -4) (("1" (lemma "inv_lemma" ("nzx" "x!1" "nzcx" "cx!1")) (("1" (assert) (("1" (lemma "atan_dr_lemma" ("ssx" "1/x!1" "cssx" "cauchy_inv(cx!1)")) (("1" (assert) (("1" (rewrite "atan_inv") (("1" (lemma "lemma_div2n" ("x" "pi" "cx" "cauchy_pi" "n" "1")) (("1" (rewrite "pi_lemma") (("1" (expand "div2n") (("1" (rewrite "expt_x1") (("1" (lemma "sub_lemma" ("x" "pi / 2" "cx" "cauchy_div2n(cauchy_pi, 1)" "y" "pi / 2 - atan(x!1)" "cy" "cauchy_atan_dr(cauchy_inv(cx!1))")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "0<1/x!1&1/x!1<8/19") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide-all-but (-2 1)) (("2" (split) (("1" (assert) (("1" (rewrite "div_mult_pos_lt2" 1) nil nil)) nil) ("2" (rewrite "div_mult_pos_lt1" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_lemma formula-decl nil int nil) (div_lemma formula-decl nil div nil) (cauchy_add const-decl "cauchy_real" add nil) (cauchy_sub const-decl "cauchy_real" sub nil) (cauchy_div const-decl "cauchy_real" div nil) (expt_x2 formula-decl nil inv nil) (atan_plus formula-decl nil atan trig) (cauchy_int const-decl "cauchy_real" int nil) (add_lemma formula-decl nil add nil) (atan_minus formula-decl nil atan trig) (neg_cauchy_nzreal_is_cauchy_nzreal application-judgement "cauchy_nzreal" neg nil) (atan_neg formula-decl nil atan trig) (atan_inv formula-decl nil atan trig) (atan const-decl "{x: real_abs_lt_pi2 | y = tan_restrict(x)}" atan trig) (cauchy_div2n const-decl "cauchy_real" shift nil) (sub_lemma formula-decl nil sub nil) (div2n const-decl "real" shift nil) (lemma_div2n formula-decl nil shift nil) (cauchy_neg const-decl "cauchy_real" neg nil) (cauchy_inv const-decl "cauchy_nzreal" inv nil) (neg_lemma formula-decl nil neg nil) (cauchy_nzreal nonempty-type-eq-decl nil cauchy nil) (cauchy_nzreal? const-decl "bool" cauchy nil) (inv_lemma formula-decl nil inv nil) (cauchy_prop const-decl "bool" cauchy nil) (cauchy_real nonempty-type-eq-decl nil cauchy nil) (cauchy_real? const-decl "bool" cauchy nil)) shostak)))
