(virtual_clock_1 (turns_TCC1 0 (turns_TCC1-1 nil 3399252479 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (rate const-decl "posreal" physical_clocks nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (interval_clock type-eq-decl nil interval_clocks nil) (weakly_accurate? const-decl "bool" interval_clocks nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (p_min const-decl "posreal" synch_constant_definitions nil) (p_max const-decl "posreal" synch_constant_definitions nil) (weakly_accurate_clock type-eq-decl nil synch_protocol_invariants nil) (T const-decl "int" interval_clocks nil) (t const-decl "real" interval_clocks nil) (adjustment_lower_bound? const-decl "bool" interval_clocks nil) (adjustment_upper_bound? const-decl "bool" interval_clocks nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil)) nil (turns subtype "(number_fields.-)(virtual_clock_1.k, 1)" "nat"))) (turns_increasing 0 (turns_increasing-1 nil 3399252505 ("" (expand "increasing?") (("" (skosimp*) (("" (expand "turns") (("" (rewrite "T_def") (("" (lift-if) (("" (prop) (("1" (replace*) (("1" (rewrite "clock_increasing") nil nil)) nil) ("2" (typepred "ac!1") (("2" (expand* "weakly_accurate?" "p_min") (("2" (flatten) (("2" (lemma "P_bound") (("2" (lemma "nonoverlap_round") (("2" (inst - "P" "ac!1" "ac!1" "i!1 - 1" "pi_0 + max(alpha_l, alpha_u)") (("1" (rewrite "T_def") (("1" (assert) (("1" (expand "adjustment_lower_bound?") (("1" (skosimp*) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (T_def formula-decl nil interval_clocks nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (nnreal type-eq-decl nil real_types nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (clock_increasing formula-decl nil physical_clocks nil) (T const-decl "int" interval_clocks nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (rate const-decl "posreal" physical_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (interval_clock type-eq-decl nil interval_clocks nil) (weakly_accurate? const-decl "bool" interval_clocks nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (p_min const-decl "posreal" synch_constant_definitions nil) (p_max const-decl "posreal" synch_constant_definitions nil) (weakly_accurate_clock type-eq-decl nil synch_protocol_invariants nil) (real_minus_real_is_real application-judgement "real" reals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (P_bound formula-decl nil synch_constant_definitions nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (i!1 skolem-const-decl "nat" virtual_clock_1 nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (adjustment_lower_bound? const-decl "bool" interval_clocks nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nonoverlap_round formula-decl nil interval_clocks nil) (NOT const-decl "[bool -> bool]" booleans nil) (turns const-decl "real" virtual_clock_1 nil) (increasing? const-decl "bool" event_sequences nil)) nil)) (turns_unbounded 0 (turns_unbounded-1 nil 3399252518 ("" (expand "unbounded?") (("" (skosimp*) (("" (lemma "axiom_of_archimedes") (("" (inst - "(t!1 - t(ac!1)(0))/ p_min") (("" (skosimp*) (("" (cross-mult) (("" (isolate -1 l 1) (("" (case "i!1 >= 0") (("1" (inst + "1 + i!1") (("1" (typepred "ac!1") (("1" (expand "weakly_accurate?") (("1" (flatten) (("1" (lemma "lower_interval_accuracy") (("1" (inst - "pi_0 + alpha_l" "ac!1" "i!1" "p_min" 0) (("1" (use "p_min") (("1" (assert) (("1" (prop) (("1" (expand "turns") (("1" (expand "t") (("1" (lemma "clock_nondecreasing") (("1" (inst - "T(i!1)" "T(i!1 + 1)" "ac!1(i!1)") (("1" (rewrite "T_def") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lower_accuracy_bound?") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) (("2" (inst + 0) (("2" (mult-by 1 "p_min") (("2" (assert) (("2" (expand "turns") (("2" (expand "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (rate const-decl "posreal" physical_clocks nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (interval_clock type-eq-decl nil interval_clocks nil) (t const-decl "real" interval_clocks nil) (weakly_accurate? const-decl "bool" interval_clocks nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (p_min const-decl "posreal" synch_constant_definitions nil) (p_max const-decl "posreal" synch_constant_definitions nil) (weakly_accurate_clock type-eq-decl nil synch_protocol_invariants nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (lower_accuracy_bound? const-decl "bool" interval_clocks nil) (turns const-decl "real" virtual_clock_1 nil) (clock_nondecreasing formula-decl nil physical_clocks nil) (T_def formula-decl nil interval_clocks nil) (int_minus_int_is_int application-judgement "int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (T const-decl "int" interval_clocks nil) (lower_interval_accuracy formula-decl nil interval_clocks nil) (i!1 skolem-const-decl "int" virtual_clock_1 nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (axiom_of_archimedes formula-decl nil real_props nil) (unbounded? const-decl "bool" event_sequences nil)) nil)) (turns_event_sequence 0 (turns_event_sequence-2 nil 3399252535 ("" (skosimp*) (("" (rewrite "turns_increasing") (("" (rewrite "turns_unbounded") nil nil)) nil)) nil) ((turns_increasing formula-decl nil virtual_clock_1 nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (rate const-decl "posreal" physical_clocks nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (interval_clock type-eq-decl nil interval_clocks nil) (weakly_accurate? const-decl "bool" interval_clocks nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (p_min const-decl "posreal" synch_constant_definitions nil) (p_max const-decl "posreal" synch_constant_definitions nil) (weakly_accurate_clock type-eq-decl nil synch_protocol_invariants nil) (turns_unbounded formula-decl nil virtual_clock_1 nil)) nil (turns_event_sequence subtype "virtual_clock_1.turns(virtual_clock_1.ac)" "event_sequence")) (turns_event_sequence-1 nil 3399252479 ("" (judgement-tcc) nil nil) nil nil (turns_event_sequence subtype "virtual_clock_1.turns(virtual_clock_1.ac)" "event_sequence"))) (turns_nonoverlap 0 (turns_nonoverlap-2 "" 3790105015 ("" (expand "nonoverlap?") (("" (skosimp*) (("" (use "ADJ_bound") (("" (expand "turns") (("" (rewrite "T_def") (("" (lift-if) (("" (expand "compatible?") (("" (prop) (("1" (hide-all-but (1 -6 -1 -2)) (("1" (replace*) (("1" (use "nonoverlap_peers") (("1" (expand "ADJ") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (2 1 -3 -1)) (("2" (lemma "nonoverlap_lower") (("2" (inst - _ _ _ _ _ "pi_0 + max(alpha_l, alpha_u)") (("2" (inst?) (("1" (expand "ADJ") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((turns const-decl "real" virtual_clock_1 nil) (ADJ const-decl "nat" synch_constant_definitions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (weakly_accurate_clock type-eq-decl nil synch_protocol_invariants nil) (p_max const-decl "posreal" synch_constant_definitions nil) (p_min const-decl "posreal" synch_constant_definitions nil) (weakly_accurate? const-decl "bool" interval_clocks nil) (interval_clock type-eq-decl nil interval_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (rate const-decl "posreal" physical_clocks nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T const-decl "int" interval_clocks nil) (nonoverlap_peers formula-decl nil interval_clocks nil) (nonoverlap_lower formula-decl nil interval_clocks nil) (k!1 skolem-const-decl "nat" virtual_clock_1 nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (compatible? const-decl "bool" interval_clocks nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (T_def formula-decl nil interval_clocks nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (nnreal type-eq-decl nil real_types nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (ADJ_bound formula-decl nil synch_constant_definitions nil) (nonoverlap? const-decl "bool" event_sequences nil) (nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)) shostak) (turns_nonoverlap-1 nil 3399252550 ("" (expand "nonoverlap?") (("" (skosimp*) (("" (use "ADJ_bound") (("" (expand "turns") (("" (rewrite "T_def") (("" (lift-if) (("" (expand "compatible?") (("" (prop) (("1" (hide-all-but (1 -6 -1 -2)) (("1" (replace*) (("1" (use "nonoverlap_peers") (("1" (expand "ADJ") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (2 1 -3 -1)) (("2" (lemma "nonoverlap_lower") (("2" (inst - _ _ _ _ _ "pi_0 + max(alpha_l, alpha_u)") (("2" (inst?) (("1" (inst?) (("1" (expand "ADJ") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((turns const-decl "real" virtual_clock_1 nil) (ADJ const-decl "nat" synch_constant_definitions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (weakly_accurate_clock type-eq-decl nil synch_protocol_invariants nil) (p_max const-decl "posreal" synch_constant_definitions nil) (p_min const-decl "posreal" synch_constant_definitions nil) (weakly_accurate? const-decl "bool" interval_clocks nil) (interval_clock type-eq-decl nil interval_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (rate const-decl "posreal" physical_clocks nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T const-decl "int" interval_clocks nil) (nonoverlap_peers formula-decl nil interval_clocks nil) (nonoverlap_lower formula-decl nil interval_clocks nil) nil (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (compatible? const-decl "bool" interval_clocks nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (T_def formula-decl nil interval_clocks nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (nnreal type-eq-decl nil real_types nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (ADJ_bound formula-decl nil synch_constant_definitions nil) (nonoverlap? const-decl "bool" event_sequences nil) (nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil)) nil)) (turns_early 0 (turns_early-1 nil 3399252571 ("" (skosimp*) (("" (expand "earliest_adjustment?") (("" (expand "turns") (("" (skosimp*) (("" (lift-if) (("" (prop) (("1" (replace*) (("1" (rewrite "clock_nondecreasing") nil nil)) nil) ("2" (lemma "nonoverlap_upper") (("2" (inst - "T(k!1) - ADJ - 1" "ADJ + 1" "ac!1" "ac!1" "k!1 - 1" "pi_0 + max(alpha_l, alpha_u)") (("1" (assert) (("1" (prop) (("1" (typepred "ac!1") (("1" (expand "weakly_accurate?") (("1" (flatten) (("1" (expand "p_max") (("1" (expand "adjustment_upper_bound?") (("1" (skosimp*) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (isolate 1 l 2) (("2" (expand "ADJ") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (earliest_adjustment? const-decl "bool" virtual_clocks nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (clock_nondecreasing formula-decl nil physical_clocks nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (T const-decl "int" interval_clocks nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (ADJ const-decl "nat" synch_constant_definitions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (rate const-decl "posreal" physical_clocks nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (interval_clock type-eq-decl nil interval_clocks nil) (weakly_accurate? const-decl "bool" interval_clocks nil) (p_min const-decl "posreal" synch_constant_definitions nil) (p_max const-decl "posreal" synch_constant_definitions nil) (weakly_accurate_clock type-eq-decl nil synch_protocol_invariants nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (k!1 skolem-const-decl "nat" virtual_clock_1 nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (adjustment_upper_bound? const-decl "bool" interval_clocks nil) (NOT const-decl "[bool -> bool]" booleans nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_plus_real_is_real application-judgement "real" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (drift const-decl "nonneg_real" physical_clocks nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nonoverlap_upper formula-decl nil interval_clocks nil) (turns const-decl "real" virtual_clock_1 nil)) nil)) (turns_self 0 (turns_self-1 nil 3399252589 ("" (skosimp*) (("" (expand "self_adjustment?") (("" (rewrite "turns_early") (("" (expand "latest_adjustment?") (("" (skosimp*) (("" (expand "turns") (("" (rewrite "clock_nondecreasing") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((turns_event_sequence application-judgement "event_sequence" virtual_clock_1 nil) (self_adjustment? const-decl "bool" virtual_clocks nil) (latest_adjustment? const-decl "bool" virtual_clocks nil) (turns const-decl "real" virtual_clock_1 nil) (int_plus_int_is_int application-judgement "int" integers nil) (clock_nondecreasing formula-decl nil physical_clocks nil) (T const-decl "int" interval_clocks nil) (ADJ const-decl "nat" synch_constant_definitions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (weakly_accurate_clock type-eq-decl nil synch_protocol_invariants nil) (p_max const-decl "posreal" synch_constant_definitions nil) (p_min const-decl "posreal" synch_constant_definitions nil) (pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (weakly_accurate? const-decl "bool" interval_clocks nil) (interval_clock type-eq-decl nil interval_clocks nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rate const-decl "posreal" physical_clocks nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (turns_early formula-decl nil virtual_clock_1 nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (turns_cross 0 (turns_cross-1 nil 3399252607 ("" (skosimp*) (("" (expand "compatible?") (("" (expand "cross_adjustment?") (("" (prop) (("1" (hide-all-but (1 -4)) (("1" (expand "earliest_cross_adjustment?") (("1" (skosimp*) (("1" (expand "turns") (("1" (lemma "nonoverlap_peers") (("1" (inst?) (("1" (inst - "ADJ + 1" "ac2!1" _) (("1" (inst?) (("1" (rewrite "T_def") (("1" (expand "ADJ") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "latest_cross_adjustment?") (("2" (skosimp*) (("2" (expand "turns") (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (1 -2 -1)) (("1" (replace*) (("1" (lemma "nonoverlap_peers") (("1" (inst - "T(0)" "ADJ + 1" _ _ _ _) (("1" (inst?) (("1" (inst?) (("1" (expand "ADJ") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (2 1 -5)) (("2" (lemma "nonoverlap_lower") (("2" (inst?) (("1" (inst - "pi_0 + max(alpha_l, alpha_u)") (("1" (expand "ADJ") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (compatible? const-decl "bool" interval_clocks nil) (int_minus_int_is_int application-judgement "int" integers nil) (earliest_cross_adjustment? const-decl "bool" virtual_clocks nil) (turns const-decl "real" virtual_clock_1 nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T const-decl "int" interval_clocks nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (ADJ const-decl "nat" synch_constant_definitions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (rate const-decl "posreal" physical_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (interval_clock type-eq-decl nil interval_clocks nil) (weakly_accurate? const-decl "bool" interval_clocks nil) (p_min const-decl "posreal" synch_constant_definitions nil) (p_max const-decl "posreal" synch_constant_definitions nil) (weakly_accurate_clock type-eq-decl nil synch_protocol_invariants nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (T_def formula-decl nil interval_clocks nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nonoverlap_peers formula-decl nil interval_clocks nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (nnreal type-eq-decl nil real_types nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (k!1 skolem-const-decl "nat" virtual_clock_1 nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (nonoverlap_lower formula-decl nil interval_clocks nil) (latest_cross_adjustment? const-decl "bool" virtual_clocks nil) (cross_adjustment? const-decl "bool" virtual_clocks nil) (turns_event_sequence application-judgement "event_sequence" virtual_clock_1 nil)) nil)) (VC1_j_TCC1 0 (VC1_j_TCC1-1 nil 3400103407 ("" (subtype-tcc) nil nil) nil nil (VC1_j subtype "(number_fields.-)(virtual_clock_1.j, 1)" "nat"))) (VC1_j 0 (VC1_j-1 nil 3400101188 ("" (skosimp*) (("" (expand "VC1") (("" (expand "VC") (("" (rewrite "index_rewrite") (("" (expand "turns") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((VC1 const-decl "int" virtual_clock_1 nil) (turns_event_sequence application-judgement "event_sequence" virtual_clock_1 nil) (index_rewrite formula-decl nil event_sequences nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (increasing? const-decl "bool" event_sequences nil) (unbounded? const-decl "bool" event_sequences nil) (event_sequence type-eq-decl nil event_sequences nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (rate const-decl "posreal" physical_clocks nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (interval_clock type-eq-decl nil interval_clocks nil) (weakly_accurate? const-decl "bool" interval_clocks nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (p_min const-decl "posreal" synch_constant_definitions nil) (p_max const-decl "posreal" synch_constant_definitions nil) (weakly_accurate_clock type-eq-decl nil synch_protocol_invariants nil) (turns const-decl "real" virtual_clock_1 nil) (posint nonempty-type-eq-decl nil integers nil) (VC const-decl "int" virtual_clocks nil)) nil)) (VC1_precision_TCC1 0 (VC1_precision_TCC1-3 "" 3804624084 ("" (skeep) (("" (lemma "trace_weakly_accurate") (("" (inst? :where 1) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) nil shostak (VC1_precision subtype "virtual_clock_1.ic1" "weakly_accurate_clock[P, T0, rho, alpha_l, alpha_u, pi_0]")) (VC1_precision_TCC1-2 nil 3399114837 ("" (skosimp*) (("" (use "trace_weakly_accurate") (("" (assert) nil nil)) nil)) nil) ((pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (nnreal type-eq-decl nil real_types nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (trace_weakly_accurate formula-decl nil synch_protocol_invariants nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (interval_clock type-eq-decl nil interval_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rate const-decl "posreal" physical_clocks nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (VC1_precision subtype "virtual_clock_1.ic1" "weakly_accurate_clock[P, T0, rho, alpha_l, alpha_u, pi_0]")) (VC1_precision_TCC1-1 nil 3295104218 ("" (skosimp*) (("" (expand "synch_protocol_invariants?") (("" (flatten) (("" (use "traces_lower") (("" (use "traces_upper") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((synch_protocol_invariants? const-decl "bool" synch_protocol_invariants nil) (traces_lower formula-decl nil synch_protocol_invariants nil) (interval_clock type-eq-decl nil interval_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (rate const-decl "posreal" physical_clocks nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (traces_upper formula-decl nil synch_protocol_invariants nil)) shostak (VC1_precision subtype "virtual_clock_1.ic1" "weakly_accurate_clock[P, T0, rho, alpha_l, alpha_u, pi_0]"))) (VC1_precision_TCC2 0 (VC1_precision_TCC2-3 nil 3399248060 ("" (skosimp*) (("" (lemma "trace_weakly_accurate") (("" (inst? -1 :where 1) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (nnreal type-eq-decl nil real_types nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (trace_weakly_accurate formula-decl nil synch_protocol_invariants nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (interval_clock type-eq-decl nil interval_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rate const-decl "posreal" physical_clocks nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (VC1_precision subtype "virtual_clock_1.ic2" "weakly_accurate_clock[P, T0, rho, alpha_l, alpha_u, pi_0]")) (VC1_precision_TCC2-2 nil 3399114847 ("" (skosimp*) (("" (use "trace_weakly_accurate") (("" (assert) nil nil)) nil)) nil) ((p_upper const-decl "posreal" synch_constant_definitions nil) (p_lower const-decl "posreal" synch_constant_definitions nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (interval_clock type-eq-decl nil interval_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (rate const-decl "posreal" physical_clocks nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil)) nil (VC1_precision subtype "virtual_clock_1.ic2" "weakly_accurate_clock[P, T0, rho, alpha_l, alpha_u, pi_0]")) (VC1_precision_TCC2-1 nil 3295104233 ("" (skosimp*) (("" (expand "synch_protocol_invariants?") (("" (flatten) (("" (use "traces_lower") (("" (use "traces_upper") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((synch_protocol_invariants? const-decl "bool" synch_protocol_invariants nil) (traces_lower formula-decl nil synch_protocol_invariants nil) (interval_clock type-eq-decl nil interval_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (rate const-decl "posreal" physical_clocks nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (traces_upper formula-decl nil synch_protocol_invariants nil)) shostak (VC1_precision subtype "virtual_clock_1.ic2" "weakly_accurate_clock[P, T0, rho, alpha_l, alpha_u, pi_0]"))) (VC1_precision 0 (VC1_precision-3 nil 3399113545 ("" (skosimp*) (("" (lemma "trace_weakly_accurate") (("" (inst-cp - _ "ic2!1") (("" (inst - _ "ic1!1") (("" (inst?) (("" (inst?) (("" (assert) (("" (expand "VC1") (("" (lemma "VC_precision") (("" (inst?) (("" (inst - "ADJ + 1" "max(alpha_l, alpha_u) + pi_0") (("" (expand "Pi") (("" (expand "P_max") (("" (assert) (("" (hide 2) (("" (lemma "traces_compatible") (("" (inst - "alpha_l" "alpha_u" "hst!1" _ _ "pi_0") (("" (inst-cp - "ic1!1" "ic2!1") (("" (inst - "ic2!1" "ic1!1") (("" (assert) (("" (expand "p_lower") (("" (expand "p_upper") (("" (assert) (("" (rewrite "turns_self") (("" (rewrite "turns_self") (("" (rewrite "turns_nonoverlap") (("" (rewrite "turns_nonoverlap") (("" (rewrite "turns_cross") (("" (rewrite "turns_cross") (("" (expand "turns") (("" (expand "t") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (nnreal type-eq-decl nil real_types nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (trace_weakly_accurate formula-decl nil synch_protocol_invariants nil) (VC1 const-decl "int" virtual_clock_1 nil) (turns_event_sequence application-judgement "event_sequence" virtual_clock_1 nil) (turns const-decl "real" virtual_clock_1 nil) (weakly_accurate_clock type-eq-decl nil synch_protocol_invariants nil) (p_max const-decl "posreal" synch_constant_definitions nil) (p_min const-decl "posreal" synch_constant_definitions nil) (weakly_accurate? const-decl "bool" interval_clocks nil) (event_sequence type-eq-decl nil event_sequences nil) (unbounded? const-decl "bool" event_sequences nil) (increasing? const-decl "bool" event_sequences nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (Pi const-decl "posnat" synch_constant_definitions nil) (Pi const-decl "int" virtual_clocks nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nonneg_ceiling_is_nat application-judgement "nat" floor_ceil nil) (traces_compatible formula-decl nil synch_protocol_invariants nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (p_upper const-decl "posreal" synch_constant_definitions nil) (turns_self formula-decl nil virtual_clock_1 nil) (turns_nonoverlap formula-decl nil virtual_clock_1 nil) (turns_cross formula-decl nil virtual_clock_1 nil) (t const-decl "real" interval_clocks nil) (p_lower const-decl "posreal" synch_constant_definitions nil) (P_max const-decl "posnat" synch_constant_definitions nil) (ADJ const-decl "nat" synch_constant_definitions nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (VC_precision formula-decl nil virtual_clocks nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (interval_clock type-eq-decl nil interval_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rate const-decl "posreal" physical_clocks nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil) (VC1_precision-2 nil 3286884794 ("" (skosimp*) (("" (expand "VC1") (("" (use "VC_precision") (("" (assert) (("" (rewrite "turns_self") (("" (rewrite "turns_compatible") (("" (use "traces_compatible") (("" (assert) (("" (expand "compatible?") (("" (flatten) (("" (rewrite "turns_nonoverlap") (("" (expand "t") (("" (expand "turns") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((t const-decl "real" interval_clocks nil) (compatible? const-decl "bool" interval_clocks nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (traces_compatible formula-decl nil synch_protocol_invariants nil) (rate const-decl "posreal" physical_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (interval_clock type-eq-decl nil interval_clocks nil) (increasing? const-decl "bool" event_sequences nil) (unbounded? const-decl "bool" event_sequences nil) (event_sequence type-eq-decl nil event_sequences nil)) nil) (VC1_precision-1 nil 3286802420 ("" (postpone) nil nil) nil shostak)) (VC1_accuracy_lower_TCC1 0 (VC1_accuracy_lower_TCC1-3 nil 3399248071 ("" (skosimp*) (("" (use "trace_weakly_accurate") (("" (assert) nil nil)) nil)) nil) ((trace_weakly_accurate formula-decl nil synch_protocol_invariants nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (nnreal type-eq-decl nil real_types nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (interval_clock type-eq-decl nil interval_clocks nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rate const-decl "posreal" physical_clocks nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (VC1_accuracy_lower subtype "virtual_clock_1.ic" "weakly_accurate_clock[P, T0, rho, alpha_l, alpha_u, pi_0]")) (VC1_accuracy_lower_TCC1-2 nil 3399114855 ("" (skosimp*) (("" (use "trace_weakly_accurate") (("" (assert) nil nil)) nil)) nil) ((p_upper const-decl "posreal" synch_constant_definitions nil) (p_lower const-decl "posreal" synch_constant_definitions nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (interval_clock type-eq-decl nil interval_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (rate const-decl "posreal" physical_clocks nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil)) nil (VC1_accuracy_lower subtype "virtual_clock_1.ic" "weakly_accurate_clock[P, T0, rho, alpha_l, alpha_u, pi_0]")) (VC1_accuracy_lower_TCC1-1 nil 3399106268 ("" (subtype-tcc) nil nil) nil nil (VC1_accuracy_lower subtype "virtual_clock_1.ic" "weakly_accurate_clock[P, T0, rho, alpha_l, alpha_u, pi_0]"))) (VC1_accuracy_lower 0 (VC1_accuracy_lower-3 nil 3399113793 ("" (skosimp*) (("" (use "trace_weakly_accurate") (("" (assert) (("" (expand "p_lower" -4) (("" (use "trace_lower_accuracy") (("" (assert) (("" (rewrite "p_lower" :dir rl) (("" (expand "p_upper") (("" (use "trace_upper_accuracy") (("" (assert) (("" (expand "VC1") (("" (use "turns_early") (("" (lemma "p_lower") (("" (lemma "VC_lower_accuracy") (("" (inst?) (("" (inst - "ADJ + 1" "alpha_l" "alpha_u" "p_lower" "pi_0") (("" (assert) (("" (expand "t") (("" (expand "turns") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((trace_weakly_accurate formula-decl nil synch_protocol_invariants nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (nnreal type-eq-decl nil real_types nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (interval_clock type-eq-decl nil interval_clocks nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rate const-decl "posreal" physical_clocks nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (p_lower const-decl "posreal" synch_constant_definitions nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (turns_early formula-decl nil virtual_clock_1 nil) (weakly_accurate? const-decl "bool" interval_clocks nil) (p_min const-decl "posreal" synch_constant_definitions nil) (p_max const-decl "posreal" synch_constant_definitions nil) (weakly_accurate_clock type-eq-decl nil synch_protocol_invariants nil) (VC_lower_accuracy formula-decl nil virtual_clocks nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (ADJ const-decl "nat" synch_constant_definitions nil) (t const-decl "real" interval_clocks nil) (increasing? const-decl "bool" event_sequences nil) (unbounded? const-decl "bool" event_sequences nil) (event_sequence type-eq-decl nil event_sequences nil) (turns const-decl "real" virtual_clock_1 nil) (turns_event_sequence application-judgement "event_sequence" virtual_clock_1 nil) (VC1 const-decl "int" virtual_clock_1 nil) (trace_upper_accuracy formula-decl nil synch_protocol_invariants nil) (p_upper const-decl "posreal" synch_constant_definitions nil) (trace_lower_accuracy formula-decl nil synch_protocol_invariants nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil) (VC1_accuracy_lower-2 nil 3316175040 ("" (skosimp*) (("" (expand "VC1") (("" (expand "VC") (("" (lemma "inverse_lower_accuracy_offset") (("" (inst - "add1(ADJ)" _ _ _ _) (("" (inst?) (("" (inst?) (("" (expand "synch_protocol_invariants?") (("" (prop) (("1" (mult-by (-1 1) "rate") (("1" (assert) (("1" (rewrite "div_cancel2") (("1" (rewrite "div_cancel2") (("1" (move-terms -1 l *) (("1" (isolate -1 r 5) (("1" (move-terms 1 r *) (("1" (expand "id") (("1" (move-terms 1 l (2 6 7 8)) (("1" (assert) (("1" (use "index_of_turns_bound") (("1" (expand "synch_protocol_invariants?") (("1" (mult-by -1 "alpha_u") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (invoke (name-replace "K" "%1" :hide? nil) (! 1 l 0 1)) (("2" (rewrite "index_of_char_alt") (("1" (flatten) (("1" (use "turns_self") (("1" (expand "adjust_times_self?") (("1" (inst?) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "turns") (("2" (rewrite "t") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rate const-decl "posreal" physical_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (interval_clock type-eq-decl nil interval_clocks nil) (increasing? const-decl "bool" event_sequences nil) (unbounded? const-decl "bool" event_sequences nil) (event_sequence type-eq-decl nil event_sequences nil) (index_of const-decl "nat" event_sequences nil) (synch_protocol_invariants? const-decl "bool" synch_protocol_invariants nil) (t const-decl "real" interval_clocks nil) (drift const-decl "nonneg_real" physical_clocks nil) (C const-decl "int" inverse_clocks nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil)) nil) (VC1_accuracy_lower-1 nil 3295159879 ("" (skosimp*) (("" (expand "VC1") (("" (use "VC_accuracy_lower") (("" (assert) (("" (rewrite "turns_self") (("" (expand "turns") (("" (expand "t") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((t const-decl "real" interval_clocks nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (rate const-decl "posreal" physical_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (interval_clock type-eq-decl nil interval_clocks nil) (increasing? const-decl "bool" event_sequences nil) (unbounded? const-decl "bool" event_sequences nil) (event_sequence type-eq-decl nil event_sequences nil)) shostak)) (VC1_optimal_accuracy_lower 0 (VC1_optimal_accuracy_lower-1 nil 3350858821 ("" (skosimp*) (("" (use "VC1_accuracy_lower") (("" (assert) nil nil)) nil)) nil) ((VC1_accuracy_lower formula-decl nil virtual_clock_1 nil) (interval_clock type-eq-decl nil interval_clocks nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rate const-decl "posreal" physical_clocks nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil)) shostak)) (VC1_accuracy_upper 0 (VC1_accuracy_upper-3 nil 3399114668 ("" (skosimp*) (("" (use "p_lower") (("" (use "trace_weakly_accurate") (("" (assert) (("" (expand "VC1") (("" (expand "p_lower" -5) (("" (use "trace_lower_accuracy") (("" (assert) (("" (use "turns_early") (("" (lemma "VC_upper_accuracy") (("" (inst?) (("" (inst - "ADJ + 1" "alpha_l" "p_lower" "pi_0") (("" (assert) (("" (expand "turns") (("" (expand "t") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((p_lower const-decl "posreal" synch_constant_definitions nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (nnreal type-eq-decl nil real_types nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_l formal-const-decl "nnreal" virtual_clock_1 nil) (alpha_u formal-const-decl "nnreal" virtual_clock_1 nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (P_bound? const-decl "bool" synch_parameter_constraints nil) (pi_0 formal-const-decl "{pi_0: posreal | P_bound?(P, rho, alpha_l, alpha_u, pi_0)}" virtual_clock_1 nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (turns_event_sequence application-judgement "event_sequence" virtual_clock_1 nil) (VC_upper_accuracy formula-decl nil virtual_clocks nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (ADJ const-decl "nat" synch_constant_definitions nil) (t const-decl "real" interval_clocks nil) (increasing? const-decl "bool" event_sequences nil) (unbounded? const-decl "bool" event_sequences nil) (event_sequence type-eq-decl nil event_sequences nil) (turns const-decl "real" virtual_clock_1 nil) (weakly_accurate_clock type-eq-decl nil synch_protocol_invariants nil) (p_max const-decl "posreal" synch_constant_definitions nil) (p_min const-decl "posreal" synch_constant_definitions nil) (weakly_accurate? const-decl "bool" interval_clocks nil) (turns_early formula-decl nil virtual_clock_1 nil) (p_upper const-decl "posreal" synch_constant_definitions nil) (trace_lower_accuracy formula-decl nil synch_protocol_invariants nil) (VC1 const-decl "int" virtual_clock_1 nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (rate const-decl "posreal" physical_clocks nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (interval_clock type-eq-decl nil interval_clocks nil) (trace_weakly_accurate formula-decl nil synch_protocol_invariants nil)) nil) (VC1_accuracy_upper-2 nil 3316175628 ("" (skosimp*) (("" (expand "VC1") (("" (expand "VC") (("" (lemma "inverse_upper_accuracy_offset") (("" (inst - "add1(ADJ)" _ _ _ _) (("" (inst?) (("" (inst?) (("" (use "turns_self") (("" (expand "synch_protocol_invariants?") (("" (prop) (("1" (factor 1 r) (("1" (div-by (-1 1) "rate") (("1" (expand "id") (("1" (isolate -1 r 1) (("1" (move-terms 1 r (2 5 7 8)) (("1" (use "index_of_turns_bound") (("1" (expand "synch_protocol_invariants?") (("1" (assert) (("1" (mult-by -1 "alpha_l") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (invoke (name-replace "K" "%1" :hide? nil) (! 1 l 0 1)) (("2" (hide 2) (("2" (rewrite "index_of_char_alt") (("1" (flatten) (("1" (expand "adjust_times_self?") (("1" (inst?) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "turns") (("2" (rewrite "t") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rate const-decl "posreal" physical_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (interval_clock type-eq-decl nil interval_clocks nil) (increasing? const-decl "bool" event_sequences nil) (unbounded? const-decl "bool" event_sequences nil) (event_sequence type-eq-decl nil event_sequences nil) (index_of const-decl "nat" event_sequences nil) (C const-decl "int" inverse_clocks nil) (t const-decl "real" interval_clocks nil) (drift const-decl "nonneg_real" physical_clocks nil) (synch_protocol_invariants? const-decl "bool" synch_protocol_invariants nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil)) nil) (VC1_accuracy_upper-1 nil 3295132705 ("" (skosimp*) (("" (expand "VC1") (("" (use "VC_accuracy_upper") (("" (assert) (("" (rewrite "turns_self") (("" (expand "t") (("" (expand "turns") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((t const-decl "real" interval_clocks nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (rate const-decl "posreal" physical_clocks nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (interval_clock type-eq-decl nil interval_clocks nil) (increasing? const-decl "bool" event_sequences nil) (unbounded? const-decl "bool" event_sequences nil) (event_sequence type-eq-decl nil event_sequences nil)) shostak)) (VC1_optimal_accuracy_upper 0 (VC1_optimal_accuracy_upper-1 nil 3350858847 ("" (skosimp*) (("" (use "VC1_accuracy_upper") (("" (assert) nil nil)) nil)) nil) ((VC1_accuracy_upper formula-decl nil virtual_clock_1 nil) (interval_clock type-eq-decl nil interval_clocks nil) (T0 formal-const-decl "int" virtual_clock_1 nil) (P formal-const-decl "posnat" virtual_clock_1 nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (good_clock nonempty-type-eq-decl nil physical_clocks nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rate const-decl "posreal" physical_clocks nil) (rho formal-const-decl "nnreal" virtual_clock_1 nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (non_empty_finite_set type-eq-decl nil finite_sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)))
