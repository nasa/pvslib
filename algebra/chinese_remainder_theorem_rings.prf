(chinese_remainder_theorem_rings (IMP_product_finseq_sets_ring_TCC1 0 (IMP_product_finseq_sets_ring_TCC2-1 nil 3793737450 ("" (rewrite "fullset_is_ring_with_one") nil nil) ((fullset_is_ring_with_one formula-decl nil chinese_remainder_theorem_rings nil)) nil (IMP_product_finseq_sets_ring assuming "product_finseq_sets_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero, chinese_remainder_theorem_rings.one].product_finseq_sets_ring" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[product_finseq_sets_ring.T, product_finseq_sets_ring.+, product_finseq_sets_ring.*, product_finseq_sets_ring.zero, product_finseq_sets_ring.one].ring_with_one?(sets[product_finseq_sets_ring.T].fullset)"))) (oneSet_nonempty 0 (oneSet_nonempty-1 nil 3782832502 ("" (skosimp) (("" (expand "empty?") (("" (typepred "fsA!1") (("" (expand "fsICM?") (("" (expand "finseq_appl") (("" (flatten) (("" (expand "fsRI?") (("" (expand "finseq_appl") (("" (inst-cp -1 "i!1") (("" (inst -1 "j!1") (("" (inst -3 "i!1" "j!1") (("" (assert) (("" (lemma "comaximal_ideals_equiv") (("" (inst?) (("" (assert) (("" (skeep) (("" (lemma "divby[T,+,zero]") (("" (inst -1 "one" "x" "y") (("" (assert) (("" (lemma "plus_commutative") (("" (inst?) (("" (assert) (("" (inst -10 "x") (("" (expand "oneSet") (("" (expand "extend") (("" (expand "finseq_appl") (("" (expand "member") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((empty? const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (plus_commutative formula-decl nil ring nil) (oneSet const-decl "set[T]" chinese_remainder_theorem_rings nil) (extend const-decl "R" extend nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (divby formula-decl nil group nil) (comaximal_ideals_equiv formula-decl nil comaximal_finseqs_ideals nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (fsRI? const-decl "bool" ring_ideal_def nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil)) shostak)) (surjective_aux_1_TCC1 0 (surjective_aux_1_TCC1-1 nil 3783230805 ("" (subtype-tcc) nil nil) nil nil (surjective_aux_1 subtype "chinese_remainder_theorem_rings.i" "below[length(s)]"))) (surjective_aux_1 0 (surjective_aux_1-2 nil 3807038908 ("" (skosimp) (("" (expand "finseq_appl") (("" (case "R!1(one)") (("1" (case "R!1(zero)") (("1" (typepred "fsA!1") (("1" (case "length(fsA!1) = 0") (("1" (inst 1 "empty_seq") (("1" (skosimp) (("1" (typepred "i!1") (("1" (hide 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "empty_seq") (("2" (assert) nil nil)) nil)) nil) ("2" (case "length(fsA!1) = 1") (("1" (inst 2 "#(product_fs(empty_seq))") (("1" (skosimp) (("1" (prop) (("1" (expand "#") (("1" (rewrite "product_fs_emptyseq") nil nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (prop) (("1" (skosimp) (("1" (expand "#") (("1" (rewrite "product_fs_emptyseq") nil nil)) nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "fsICM?") (("2" (flatten) (("2" (hide -2) (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst 3 "(# length := length(fsA!1),
                                                    seq := (LAMBDA (i: below[length(fsA!1)]): product_fs((# length := length(fsA!1) - 1,
                                             	                                                          seq := (LAMBDA (j: below[length(fsA!1) - 1]): (IF j < i THEN one + inv(choose(oneSet(R!1, fsA!1)(i,j))) ELSE one + inv(choose(oneSet(R!1, fsA!1)(i,j+1))) ENDIF)) #))) #)") (("1" (skosimp) (("1" (name-replace "z!1" "(# length := length(fsA!1) - 1,
                                                                                        seq
                                                                                          := (LAMBDA (j: below[length(fsA!1) - 1]):
                                                                                                (IF j < i!1
                                                                                                   THEN one
                                                                                                        +
                                                                                                        inv[T, +, zero]
                                                                                                        (choose(oneSet(R!1, fsA!1)(i!1, j)))
                                                                                                 ELSE one +
                                                                                                       inv[T, +, zero]
                                                                                                           (choose
                                                                                                            (oneSet(R!1, fsA!1)(i!1, j + 1)))
                                                                                                 ENDIF)) #)") (("1" (split) (("1" (inst?) (("1" (expand "product_fs") (("1" (lift-if) (("1" (prop) (("1" (case "FORALL(n: nat): n < length(z!1) IMPLIES product_fs_rec(z!1)(n) + fsA!1(i!1) = one + fsA!1(i!1)") (("1" (inst?) (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 3) (("2" (expand "finseq_appl") (("2" (induct "n") (("1" (assert) (("1" (expand "product_fs_rec") (("1" (expand "z!1") (("1" (lift-if) (("1" (prop) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide -2) (("1" (lemma "add_charac") (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "one" "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1,0)))") (("1" (case-replace "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1,0))) + fsA!1`seq(i!1) = fsA!1`seq(i!1)" :hide? T) (("1" (case-replace "add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1),fsA!1`seq(i!1)) = add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1), zero + fsA!1`seq(i!1))" :hide? T) (("1" (rewrite "add_charac") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (rewrite "left_zero") nil nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (rewrite "left_zero") (("3" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (lemma "inv_in") (("2" (inst -1 "fsA!1`seq(i!1)" "choose(oneSet(R!1, fsA!1)(i!1,0))") (("1" (lemma "self_coset") (("1" (inst -1 "fsA!1`seq(i!1)" "R!1" "inv(choose(oneSet(R!1, fsA!1)(i!1,0)))") (("1" (assert) (("1" (hide-all-but (-4 1)) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-4 -5 -6)) (("2" (inst -3 "choose(oneSet(R!1, fsA!1)(i!1,0))") (("2" (assert) (("2" (hide -1) (("2" (lemma "inv_in") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide -2) (("1" (lemma "add_charac") (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "one" "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1,1)))") (("1" (case-replace "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1,1))) + fsA!1`seq(i!1) = fsA!1`seq(i!1)" :hide? T) (("1" (case-replace "add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1),fsA!1`seq(i!1)) = add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1), zero + fsA!1`seq(i!1))" :hide? T) (("1" (rewrite "add_charac") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (rewrite "left_zero") nil nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (rewrite "left_zero") (("3" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil) ("2" (hide (-1 3)) (("2" (lemma "inv_in") (("2" (inst -1 "fsA!1`seq(i!1)" "choose(oneSet(R!1, fsA!1)(i!1,1))") (("1" (lemma "self_coset") (("1" (inst -1 "fsA!1`seq(i!1)" "R!1" "inv(choose(oneSet(R!1, fsA!1)(i!1,1)))") (("1" (assert) (("1" (hide-all-but (-3 1)) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-3 -4 -5)) (("2" (inst -2 "choose(oneSet(R!1, fsA!1)(i!1,1))") (("2" (assert) (("2" (hide -1) (("2" (lemma "inv_in") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) (("2" (expand "product_fs_rec" 1) (("2" (expand "z!1") (("2" (lemma "product_charac") (("2" (name-replace "b!1" "product_fs_rec((# length := length(fsA!1) - 1,
                                                                                                                                                                  seq
                                                                                                                                                                    := LAMBDA (j: below[length(fsA!1) - 1]):
                                                                                                                                                                         (IF j < i!1
                                                                                                                                                                            THEN one
                                                                                                                                                                                 +
                                                                                                                                                                                 inv[T, +, zero]
                                                                                                                                                                                 (choose(oneSet(R!1, fsA!1)(i!1, j)))
                                                                                                                                                                          ELSE one
                                                                                                                                                                               +
                                                                                                                                                                               inv[T, +, zero]
                                                                                                                                                                               (choose
                                                                                                                                                                                (oneSet(R!1, fsA!1)(i!1, 1 + j)))
                                                                                                                                                                          ENDIF) #))
                                                                                                                                                              (j!1)" :hide? T) (("1" (lift-if) (("1" (prop) (("1" (name-replace "a!1" "(one + inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 1 + j!1))))" :hide? T) (("1" (inst-cp -2 "R!1" "fsA!1`seq(i!1)" "a!1" "b!1") (("1" (replaces -4) (("1" (inst -2 "R!1" "fsA!1`seq(i!1)" "a!1" "one") (("1" (replaces -2) (("1" (rewrite "times_one") (("1" (assert) (("1" (replace -2 1 rl) (("1" (hide -2) (("1" (expand "a!1") (("1" (lemma "add_charac") (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "one" "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 1 + j!1)))") (("1" (assert) (("1" (case-replace "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 1 + j!1))) +
                                                                                                                                                                                                                                     fsA!1`seq(i!1) = fsA!1`seq(i!1)" :hide? T) (("1" (case-replace "add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1),fsA!1`seq(i!1)) = add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1), zero + fsA!1`seq(i!1))" :hide? T) (("1" (rewrite "add_charac") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "left_zero") nil nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (rewrite "left_zero") (("3" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (lemma "inv_in") (("2" (inst -1 "fsA!1`seq(i!1)" "choose(oneSet(R!1, fsA!1)(i!1, 1 + j!1))") (("1" (lemma "self_coset") (("1" (inst -1 "fsA!1`seq(i!1)" "R!1" "inv(choose(oneSet(R!1, fsA!1)(i!1, 1 + j!1)))") (("1" (assert) (("1" (hide (-1 2)) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "ideal?") (("3" (expand "left_ideal?") (("3" (expand "subring?") (("3" (expand "ring?") (("3" (expand "abelian_group?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-4 -5 -6)) (("2" (inst -3 "choose(oneSet(R!1, fsA!1)(i!1, 1 + j!1))") (("2" (assert) (("2" (prop) (("1" (lemma "inv_in") (("1" (inst?) nil nil)) nil) ("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 2)) (("2" (expand "a!1") (("2" (rewrite "product_in") (("2" (hide 2) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-4 -5 -6)) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 2)) (("2" (expand "b!1") (("2" (lemma "product_fs_rec_in_ring") (("2" (inst -1 "R!1" "(# length := length(fsA!1) - 1,
                                                                                                                                                                                                                      seq
                                                                                                                                                                                                                        := LAMBDA (j: below[length(fsA!1) - 1]):
                                                                                                                                                                                                                             (IF j < i!1
                                                                                                                                                                                                                              THEN one
                                                                                                                                                                                                                                   +
                                                                                                                                                                                                                                   inv[T, +, zero]
                                                                                                                                                                                                                                   (choose
                                                                                                                                                                                                                                    (oneSet(R!1, fsA!1)(i!1, j)))
                                                                                                                                                                                                                              ELSE one
                                                                                                                                                                                                                                   +
                                                                                                                                                                                                                                   inv[T, +, zero]
                                                                                                                                                                                                                                   (choose
                                                                                                                                                                                                                                    (oneSet(R!1, fsA!1)(i!1, 1 + j)))
                                                                                                                                                                                                                              ENDIF) #)") (("1" (assert) (("1" (prop) (("1" (inst?) nil nil) ("2" (hide 2) (("2" (expand "finseq_appl") (("2" (skosimp) (("2" (prop) (("1" (rewrite "product_in") (("1" (hide 2) (("1" (rewrite "inv_in") (("1" (hide 2) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-5 -6 -7)) (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_in") (("2" (hide 3) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-4 -5 -6)) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp) (("2" (expand "nonempty?") (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp) (("3" (assert) nil nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp) (("4" (expand "nonempty?") (("4" (lemma "oneSet_nonempty") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-2 2)) (("3" (expand "a!1") (("3" (rewrite "product_in") (("3" (hide 2) (("3" (rewrite "inv_in") (("3" (hide 2) (("3" (expand "ideal?") (("3" (expand "left_ideal?") (("3" (expand "subring?") (("3" (expand "subset?") (("3" (expand "member") (("3" (flatten) (("3" (hide (-4 -5 -6)) (("3" (inst?) (("3" (assert) (("3" (hide 1) (("3" (lemma "choose_member[T]") (("3" (inst?) (("3" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name-replace "a!1" "(one + inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 2 + j!1))))" :hide? T) (("2" (inst-cp -1 "R!1" "fsA!1`seq(i!1)" "a!1" "b!1") (("1" (replaces -3) (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "a!1" "one") (("1" (replaces -1) (("1" (rewrite "times_one") (("1" (assert) (("1" (replace -1 2 rl) (("1" (hide -1) (("1" (expand "a!1") (("1" (lemma "add_charac") (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "one" "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 2 + j!1)))") (("1" (assert) (("1" (case-replace "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 2 + j!1))) +
                                                                                                                                                                                                                                     fsA!1`seq(i!1) = fsA!1`seq(i!1)" :hide? T) (("1" (case-replace "add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1),fsA!1`seq(i!1)) = add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1), zero + fsA!1`seq(i!1))" :hide? T) (("1" (rewrite "add_charac") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "left_zero") nil nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (rewrite "left_zero") (("3" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil) ("2" (hide (-1 3)) (("2" (lemma "inv_in") (("2" (inst -1 "fsA!1`seq(i!1)" "choose(oneSet(R!1, fsA!1)(i!1, 2 + j!1))") (("1" (lemma "self_coset") (("1" (inst -1 "fsA!1`seq(i!1)" "R!1" "inv(choose(oneSet(R!1, fsA!1)(i!1, 2 + j!1)))") (("1" (assert) (("1" (hide (-1 2)) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "ideal?") (("3" (expand "left_ideal?") (("3" (expand "subring?") (("3" (expand "ring?") (("3" (expand "abelian_group?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-3 -4 -5)) (("2" (inst -2 "choose(oneSet(R!1, fsA!1)(i!1, 2 + j!1))") (("2" (assert) (("2" (prop) (("1" (lemma "inv_in") (("1" (inst?) nil nil)) nil) ("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 3)) (("2" (expand "a!1") (("2" (rewrite "product_in") (("2" (hide 2) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-3 -4 -5)) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 3)) (("2" (expand "b!1") (("2" (lemma "product_fs_rec_in_ring") (("2" (inst -1 "R!1" "(# length := length(fsA!1) - 1,
                                                                                                                                                                                                                      seq
                                                                                                                                                                                                                        := LAMBDA (j: below[length(fsA!1) - 1]):
                                                                                                                                                                                                                             (IF j < i!1
                                                                                                                                                                                                                              THEN one
                                                                                                                                                                                                                                   +
                                                                                                                                                                                                                                   inv[T, +, zero]
                                                                                                                                                                                                                                   (choose
                                                                                                                                                                                                                                    (oneSet(R!1, fsA!1)(i!1, j)))
                                                                                                                                                                                                                              ELSE one
                                                                                                                                                                                                                                   +
                                                                                                                                                                                                                                   inv[T, +, zero]
                                                                                                                                                                                                                                   (choose
                                                                                                                                                                                                                                    (oneSet(R!1, fsA!1)(i!1, 1 + j)))
                                                                                                                                                                                                                              ENDIF) #)") (("1" (assert) (("1" (prop) (("1" (inst?) nil nil) ("2" (hide 2) (("2" (expand "finseq_appl") (("2" (skosimp) (("2" (prop) (("1" (rewrite "product_in") (("1" (hide 2) (("1" (rewrite "inv_in") (("1" (hide 2) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-6 -5 -4)) (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_in") (("2" (hide 3) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-3 -5 -4)) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp) (("2" (expand "nonempty?") (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp) (("3" (assert) nil nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp) (("4" (expand "nonempty?") (("4" (lemma "oneSet_nonempty") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 3)) (("3" (expand "a!1") (("3" (rewrite "product_in") (("3" (hide 2) (("3" (rewrite "inv_in") (("3" (hide 2) (("3" (expand "ideal?") (("3" (expand "left_ideal?") (("3" (expand "subring?") (("3" (expand "subset?") (("3" (expand "member") (("3" (flatten) (("3" (hide (-3 -4 -5)) (("3" (inst?) (("3" (assert) (("3" (hide 1) (("3" (lemma "choose_member[T]") (("3" (inst?) (("3" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 2)) (("2" (skosimp) (("2" (expand "nonempty?") (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 -2 2)) (("3" (skosimp) (("3" (assert) nil nil)) nil)) nil) ("4" (hide (-1 -2 2)) (("4" (skosimp) (("4" (expand "nonempty?") (("4" (lemma "oneSet_nonempty") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil) ("5" (hide (-1 -2 2)) (("5" (skosimp) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-2 2)) (("3" (expand "z!1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 2)) (("3" (expand "z!1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "member") (("2" (inst?) (("2" (case-replace "j!1 = 0") (("1" (lemma "Product_fs_o") (("1" (inst -1 "#(first(z!1))" "rest(z!1)") (("1" (lemma "seq_first_rest_1[T]") (("1" (inst?) (("1" (prop) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (expand "rest") (("1" (lift-if) (("1" (prop) (("1" (hide (-2 1)) (("1" (expand "z!1") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "product_fs_1") (("2" (case "member(product_fs(z!1 ^ (1, z!1`length - 1)), R!1)") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "left_swallow?") (("1" (flatten) (("1" (hide -6) (("1" (expand "member") (("1" (inst -5 "product_fs(z!1 ^ (1, z!1`length - 1))" "z!1`seq(0)") (("1" (assert) nil nil) ("2" (hide (-1 -2 -4 3)) (("2" (expand "z!1") (("2" (assert) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (- 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil) ("4" (hide (- 3)) (("4" (expand "z!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 3)) (("2" (expand "member") (("2" (expand "product_fs") (("2" (prop) (("2" (lemma "product_fs_rec_in_ring") (("2" (inst?) (("1" (inst?) (("1" (prop) (("1" (inst?) (("1" (expand "member") (("1" (propax) nil nil)) nil) ("2" (hide 3) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 3) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil) ("4" (hide 3) (("4" (expand "z!1") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skosimp) (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "empty_seq") (("2" (propax) nil nil)) nil) ("3" (expand "empty_seq") (("3" (propax) nil nil)) nil) ("4" (expand "empty_seq") (("4" (propax) nil nil)) nil) ("5" (expand "z!1" 6) (("5" (prop) (("1" (rewrite "product_in") (("1" (hide 2) (("1" (rewrite "inv_in") (("1" (hide (-3 2)) (("1" (typepred "fsA!1") (("1" (expand "fsICM?") (("1" (expand "fsRI?") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (inst?) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-2 -3 -4 -5)) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_in") (("2" (hide 3) (("2" (rewrite "inv_in") (("2" (hide (-2 2)) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-2 -3 -4 -5)) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide (-2 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil) ("4" (hide (-1 3)) (("4" (expand "z!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -4 -5 -6 1)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (-1 -3 -4 2)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -3 -4 2)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide (-2 -3 -4 2)) (("3" (expand "z!1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (case "length(fsA!1) = 2") (("1" (expand "z!1") (("1" (expand "product_fs") (("1" (assert) (("1" (expand "product_fs_rec") (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "j!1 = 1") (("1" (hide 2) (("1" (lemma "Product_fs_o") (("1" (inst-cp -1 "#(z!1`seq(0))" "rest(z!1)") (("1" (inst -1 "#(rest(z!1)`seq(0))" "rest(rest(z!1))") (("1" (lemma "seq_first_rest_1[T]") (("1" (inst-cp -1 "rest(z!1)") (("1" (inst -1 "z!1") (("1" (prop) (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (replace -1 -3 rl) (("1" (replace -2 -4 rl) (("1" (replaces -3) (("1" (hide (-1 -2)) (("1" (rewrite "product_fs_1") (("1" (rewrite "product_fs_1") (("1" (lemma "rest_pos[T]") (("1" (inst?) (("1" (expand "finseq_appl") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (replaces -1) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "left_swallow?") (("1" (expand "right_ideal?") (("1" (expand "right_swallow?") (("1" (flatten) (("1" (hide (-2 -4)) (("1" (case "R!1(product_fs(rest(rest(z!1))))") (("1" (case "i!1 = 0") (("1" (expand "z!1" 2 (2 3)) (("1" (assert) (("1" (inst -4 "product_fs(rest(rest(z!1))) *
                                                                                                                                                                                           (one + inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 2))))" "(one + inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 1))))") (("1" (hide (-2 3)) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (case "R!1(one + inv[T, +, zero](choose[T](oneSet(R!1, fsA!1)(i!1, 2))))") (("1" (typepred "R!1") (("1" (expand "ring_with_one?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (expand "star_closed?") (("1" (flatten) (("1" (hide (-1 -3 -4 -5 -6 -11)) (("1" (expand "member") (("1" (inst?) (("1" (hide (-1 -3 2)) (("1" (expand "z!1") (("1" (assert) (("1" (reveal -8) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -20) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -4 2)) (("2" (rewrite "product_in") (("2" (hide 2) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-2 -3 -4 -5)) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-2 -4 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (inst -3 "product_fs(rest(rest(z!1)))" "z!1`seq(1)") (("1" (inst -4 "z!1`seq(0)" "product_fs(rest(rest(z!1))) * z!1`seq(1)") (("1" (hide (-1 -3 4)) (("1" (expand "z!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide (-1 -3 4)) (("2" (expand "z!1") (("2" (assert) (("2" (rewrite "product_in") (("2" (hide 2) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-2 -3 -4 -5)) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -3 4)) (("2" (expand "z!1") (("2" (assert) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 -3 4)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -3 3)) (("2" (expand "product_fs") (("2" (prop) (("2" (lemma "product_fs_rec_in_ring") (("2" (inst?) (("1" (inst?) (("1" (prop) (("1" (inst?) (("1" (expand "member") (("1" (propax) nil nil)) nil) ("2" (hide 3) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 3) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skosimp) (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (expand "rest") (("2" (lift-if) (("2" (lift-if) (("2" (expand "^") (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (prop) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "empty_seq") (("2" (propax) nil nil)) nil) ("3" (expand "empty_seq") (("3" (propax) nil nil)) nil) ("4" (expand "empty_seq") (("4" (propax) nil nil)) nil) ("5" (expand "empty_seq") (("5" (propax) nil nil)) nil) ("6" (expand "empty_seq") (("6" (propax) nil nil)) nil) ("7" (expand "empty_seq") (("7" (propax) nil nil)) nil) ("8" (expand "empty_seq") (("8" (propax) nil nil)) nil) ("9" (expand "empty_seq") (("9" (propax) nil nil)) nil) ("10" (expand "empty_seq") (("10" (propax) nil nil)) nil) ("11" (expand "empty_seq") (("11" (propax) nil nil)) nil) ("12" (expand "empty_seq") (("12" (propax) nil nil)) nil) ("13" (expand "empty_seq") (("13" (propax) nil nil)) nil) ("14" (expand "empty_seq") (("14" (propax) nil nil)) nil) ("15" (expand "empty_seq") (("15" (propax) nil nil)) nil) ("16" (expand "empty_seq") (("16" (propax) nil nil)) nil) ("17" (expand "empty_seq") (("17" (propax) nil nil)) nil) ("18" (expand "empty_seq") (("18" (propax) nil nil)) nil) ("19" (expand "empty_seq") (("19" (propax) nil nil)) nil) ("20" (expand "empty_seq") (("20" (propax) nil nil)) nil) ("21" (expand "empty_seq") (("21" (propax) nil nil)) nil) ("22" (expand "empty_seq") (("22" (propax) nil nil)) nil) ("23" (expand "empty_seq") (("23" (propax) nil nil)) nil) ("24" (expand "empty_seq") (("24" (propax) nil nil)) nil) ("25" (expand "z!1" 10) (("25" (prop) (("1" (rewrite "product_in") (("1" (rewrite "inv_in") (("1" (hide 2) (("1" (typepred "fsA!1") (("1" (expand "fsICM?") (("1" (expand "fsRI?") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (inst?) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-2 -3 -4 -5)) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_in") (("2" (rewrite "inv_in") (("2" (hide (2 4)) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-2 -3 -4 -5)) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -3 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (-2 -4 2)) (("2" (expand "z!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -3 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -3 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -3 -4 -6 2)) (("2" (expand "z!1") (("2" (grind) nil nil)) nil)) nil) ("3" (hide (-1 -3 -4 -6 2)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil) ("4" (hide (-1 -3 -4 -6 2)) (("4" (expand "z!1") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -5 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -4 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -3 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide (-1 -3 3)) (("3" (expand "rest") (("3" (lift-if) (("3" (prop) (("1" (expand "z!1") (("1" (assert) nil nil)) nil) ("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (expand "z!1") (("1" (assert) nil nil)) nil) ("2" (expand "z!1") (("2" (assert) nil nil)) nil) ("3" (expand "min") (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "Product_fs_o_split") (("2" (expand "finseq_appl") (("2" (case "j!1 < i!1") (("1" (inst -2 "z!1" "j!1") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "left_swallow?") (("1" (expand "right_ideal?") (("1" (expand "right_swallow?") (("1" (flatten) (("1" (hide (-3 1 2)) (("1" (case "member(product_fs(z!1 ^ (1 + j!1, length(z!1) - 1)), R!1)") (("1" (case "member(product_fs(z!1 ^ (0, j!1 - 1)), R!1)") (("1" (case "member(z!1`seq(j!1),fsA!1`seq(j!1))") (("1" (expand "member") (("1" (inst -6 "product_fs(z!1 ^ (1 + j!1, length(z!1) - 1))" "z!1`seq(j!1)") (("1" (inst -8 "product_fs(z!1 ^ (0, j!1 - 1))" "product_fs(z!1 ^ (1 + j!1, length(z!1) - 1)) * z!1`seq(j!1)") (("1" (assert) nil nil) ("2" (hide (- 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide (- 3)) (("3" (assert) nil nil)) nil) ("4" (hide (- 3)) (("4" (expand "z!1") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (- 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide (- 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -4 -5 -7 3)) (("2" (expand "member") (("2" (expand "z!1") (("2" (assert) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (hide (-1 -3 -4 -6 3)) (("2" (expand "member") (("2" (expand "product_fs") (("2" (prop) (("2" (lemma "product_fs_rec_in_ring") (("2" (inst?) (("1" (inst?) (("1" (assert) (("1" (prop) (("1" (inst?) (("1" (hide (- 3)) (("1" (expand "z!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (hide 3) (("2" (skosimp) (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "z!1" 4) (("2" (prop) (("1" (rewrite "product_in") (("1" (hide 2) (("1" (rewrite "inv_in") (("1" (hide (-3 2)) (("1" (typepred "fsA!1") (("1" (expand "fsICM?") (("1" (expand "fsRI?") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (inst?) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-2 -3 -4 -5)) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 2)) (("2" (typepred "i!2") (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide (-2 2 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (hide (-2 -3 -4 -5 3)) (("2" (expand "member") (("2" (expand "product_fs") (("2" (prop) (("2" (lemma "product_fs_rec_in_ring") (("2" (inst?) (("1" (inst?) (("1" (prop) (("1" (inst?) (("1" (assert) nil nil) ("2" (hide 3) (("2" (assert) nil nil)) nil) ("3" (hide 3) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil) ("4" (hide 3) (("4" (expand "z!1") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (hide 3) (("2" (skosimp) (("2" (expand "member") (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "empty_seq") (("2" (propax) nil nil)) nil) ("3" (expand "empty_seq") (("3" (propax) nil nil)) nil) ("4" (expand "empty_seq") (("4" (propax) nil nil)) nil) ("5" (expand "z!1" 6) (("5" (prop) (("1" (rewrite "product_in") (("1" (hide 2) (("1" (rewrite "inv_in") (("1" (hide 2) (("1" (typepred "fsA!1") (("1" (expand "fsICM?") (("1" (expand "fsRI?") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (inst?) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-2 -3 -4 -5)) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_in") (("2" (hide 3) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-2 -3 -4 -5)) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 3) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (- 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil) ("4" (hide (- 3)) (("4" (expand "z!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide (-2 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -1 "z!1" "j!1 - 1") (("1" (assert) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "left_swallow?") (("1" (expand "right_ideal?") (("1" (expand "right_swallow?") (("1" (flatten) (("1" (hide (-4 3)) (("1" (case "member(product_fs(z!1 ^ (j!1, length(z!1) - 1)), R!1)") (("1" (case "member(product_fs(z!1 ^ (0, j!1 - 2)), R!1)") (("1" (case "member(z!1`seq(j!1 - 1),fsA!1`seq(j!1))") (("1" (expand "member") (("1" (inst -6 "product_fs(z!1 ^ (j!1, length(z!1) - 1)) " "z!1`seq(j!1-1)") (("1" (inst -7 "product_fs(z!1 ^ (0, j!1 - 2))" "product_fs(z!1 ^ (j!1, length(z!1) - 1)) * z!1`seq(j!1 - 1)") (("1" (assert) nil nil) ("2" (hide (- 5)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (- 5)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -4 -5 -6 5)) (("2" (expand "member") (("2" (expand "z!1") (("2" (assert) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -4 -5 5)) (("2" (expand "member") (("2" (expand "product_fs") (("2" (prop) (("2" (lemma "product_fs_rec_in_ring") (("2" (inst?) (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (inst?) nil nil) ("2" (expand "finseq_appl") (("2" (hide 3) (("2" (skosimp) (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "z!1" 4) (("2" (prop) (("1" (rewrite "product_in") (("1" (hide 2) (("1" (rewrite "inv_in") (("1" (hide 2) (("1" (typepred "fsA!1") (("1" (expand "fsICM?") (("1" (expand "fsRI?") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (inst?) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-2 -3 -4 -5)) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_in") (("2" (hide 3) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-2 -3 -4 -5)) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -4 5)) (("2" (expand "member") (("2" (expand "product_fs") (("2" (prop) (("2" (lemma "product_fs_rec_in_ring") (("2" (inst?) (("1" (inst?) (("1" (prop) (("1" (inst?) (("1" (assert) nil nil) ("2" (hide 3) (("2" (assert) nil nil)) nil) ("3" (hide 3) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "finseq_appl") (("2" (skosimp) (("2" (expand "member") (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "empty_seq") (("2" (propax) nil nil)) nil) ("3" (expand "empty_seq") (("3" (propax) nil nil)) nil) ("4" (expand "empty_seq") (("4" (propax) nil nil)) nil) ("5" (expand "z!1" 6) (("5" (rewrite "product_in") (("5" (hide 7) (("5" (rewrite "inv_in") (("5" (hide 2) (("5" (typepred "fsA!1") (("5" (expand "fsICM?") (("5" (expand "fsRI?") (("5" (expand "finseq_appl") (("5" (flatten) (("5" (inst?) (("5" (expand "ideal?") (("5" (expand "left_ideal?") (("5" (expand "subring?") (("5" (expand "subset?") (("5" (expand "member") (("5" (flatten) (("5" (hide (-2 -3 -4 -5)) (("5" (inst?) (("5" (assert) (("5" (hide 2) (("5" (lemma "choose_member[T]") (("5" (inst?) (("5" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (- 5)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide (-1 6)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide (-1 6)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (skosimp) (("2" (expand "nonempty?") (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 4) (("3" (skosimp) (("3" (assert) nil nil)) nil)) nil) ("4" (hide 4) (("4" (skosimp) (("4" (expand "nonempty?") (("4" (lemma "oneSet_nonempty") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 4) (("5" (skosimp) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "product_fs") (("2" (assert) (("2" (lemma "product_fs_rec_in_ring") (("2" (inst?) (("1" (inst?) (("1" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (expand "finseq_appl") (("2" (skosimp) (("2" (prop) (("1" (rewrite "product_in") (("1" (hide 2) (("1" (rewrite "inv_in") (("1" (hide 2) (("1" (inst?) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-3 -4 -5)) (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_in") (("2" (hide 3) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-2 -3 -4)) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp) (("2" (expand "nonempty?") (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp) (("3" (assert) nil nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp) (("4" (expand "nonempty?") (("4" (lemma "oneSet_nonempty") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (expand "nonempty?") (("3" (lemma "oneSet_nonempty") (("3" (inst?) nil nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil) ("5" (skosimp) (("5" (expand "nonempty?") (("5" (lemma "oneSet_nonempty") (("5" (inst?) nil nil)) nil)) nil)) nil) ("6" (skosimp) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (R!1 skolem-const-decl "ring_with_one[T, +, *, zero, one]" chinese_remainder_theorem_rings nil) (empty_seq const-decl "finseq" finite_sequences nil) (fsA!1 skolem-const-decl "fsICM[T, +, *, zero, one](R!1)" chinese_remainder_theorem_rings nil) (i!1 skolem-const-decl "below[length(fsA!1)]" chinese_remainder_theorem_rings nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (choose_member formula-decl nil sets_lemmas nil) (i!1 skolem-const-decl "below[length(fsA!1)]" chinese_remainder_theorem_rings nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (subring? const-decl "bool" ring_def nil) (abelian_group? const-decl "bool" group_def nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (inv_in formula-decl nil group nil) (add const-decl "set[T]" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (right_identity formula-decl nil monad nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (subset? const-decl "bool" sets nil) (add_charac formula-decl nil quotient_rings nil) (extend const-decl "R" extend nil) (oneSet_nonempty formula-decl nil chinese_remainder_theorem_rings nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (a!1 skolem-const-decl "T" chinese_remainder_theorem_rings nil) (b!1 skolem-const-decl "T" chinese_remainder_theorem_rings nil) (times_one formula-decl nil ring_with_one nil) (j!1 skolem-const-decl "nat" chinese_remainder_theorem_rings nil) (product_in formula-decl nil group nil) (TRUE const-decl "bool" booleans nil) (product_fs_rec_in_ring formula-decl nil product_finseq_sets_ring nil) (a!1 skolem-const-decl "T" chinese_remainder_theorem_rings nil) (product_charac formula-decl nil quotient_rings nil) (z!1 skolem-const-decl "[# length: int, seq: [below[length(fsA!1) - 1] -> T] #]" chinese_remainder_theorem_rings nil) (product_fs_rec def-decl "T" product_finseq_sets_ring nil) (+ const-decl "set[T]" cosets_def nil) (rest const-decl "finseq" seq_extras structures) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (^ const-decl "finseq" finite_sequences nil) (left_swallow? const-decl "bool" ring_ideal_def nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (product_fs_1 formula-decl nil product_finseq_sets_ring nil) (seq_first_rest_1 formula-decl nil seq_extras structures) (Product_fs_o formula-decl nil product_finseq_sets_ring nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (right_swallow? const-decl "bool" ring_ideal_def nil) (monoid? const-decl "bool" monoid_def nil) (star_closed? const-decl "bool" groupoid_def nil) (monad? const-decl "bool" monad_def nil) (right_ideal? const-decl "bool" ring_ideal_def nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (nil application-judgement "above(n)" exp2 nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (rest_pos formula-decl nil seq_extras structures) (int_plus_int_is_int application-judgement "int" integers nil) (j!1 skolem-const-decl "{j_1: below[length(fsA!1)] | j_1 /= i!1}" chinese_remainder_theorem_rings nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (Product_fs_o_split formula-decl nil product_finseq_sets_ring nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (choose const-decl "(p)" sets nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonempty? const-decl "bool" sets nil) (oneSet const-decl "set[T]" chinese_remainder_theorem_rings nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (fsRI? const-decl "bool" ring_ideal_def nil) (product_fs const-decl "T" product_finseq_sets_ring nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (product_fs_emptyseq formula-decl nil product_finseq_sets_ring nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil)) nil) (surjective_aux_1-1 nil 3783230856 ("" (skosimp) (("" (expand "finseq_appl") (("" (case "R!1(one)") (("1" (case "R!1(zero)") (("1" (typepred "fsA!1") (("1" (case "length(fsA!1) = 0") (("1" (inst 1 "empty_seq") (("1" (skosimp) (("1" (typepred "i!1") (("1" (hide 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "empty_seq") (("2" (assert) nil nil)) nil)) nil) ("2" (case "length(fsA!1) = 1") (("1" (inst 2 "#(product_fs(empty_seq))") (("1" (skosimp) (("1" (prop) (("1" (expand "#") (("1" (rewrite "product_fs_emptyseq") nil nil)) nil) ("2" (skosimp) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (prop) (("1" (skosimp) (("1" (expand "#") (("1" (rewrite "product_fs_emptyseq") nil nil)) nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "fsICM?") (("2" (flatten) (("2" (hide -2) (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst 3 "(# length := length(fsA!1),
                                          seq := (LAMBDA (i: below[length(fsA!1)]): product_fs((# length := length(fsA!1) - 1,
                                   	                                                          seq := (LAMBDA (j: below[length(fsA!1) - 1]): (IF j < i THEN one - choose(oneSet(R!1, fsA!1)(i,j)) ELSE one - choose(oneSet(R!1, fsA!1)(i,j+1)) ENDIF)) #))) #)") (("1" (skosimp) (("1" (name-replace "z!1" "(# length := length(fsA!1) - 1,
                                                                            seq
                                                                              := (LAMBDA (j: below[length(fsA!1) - 1]):
                                                                                    (IF j < i!1
                                                                                       THEN one
                                                                                            +
                                                                                            inv[T, +, zero]
                                                                                            (choose(oneSet(R!1, fsA!1)(i!1, j)))
                                                                                     ELSE one +
                                                                                           inv[T, +, zero]
                                                                                               (choose
                                                                                                (oneSet(R!1, fsA!1)(i!1, j + 1)))
                                                                                     ENDIF)) #)") (("1" (split) (("1" (inst?) (("1" (expand "product_fs") (("1" (lift-if) (("1" (prop) (("1" (case "FORALL(n: nat): n < length(z!1) IMPLIES product_fs_rec(z!1)(n) + fsA!1(i!1) = one + fsA!1(i!1)") (("1" (inst?) (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 3) (("2" (expand "finseq_appl") (("2" (induct "n") (("1" (assert) (("1" (expand "product_fs_rec") (("1" (expand "z!1") (("1" (lift-if) (("1" (prop) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide -2) (("1" (lemma "add_charac") (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "one" "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1,0)))") (("1" (case-replace "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1,0))) + fsA!1`seq(i!1) = fsA!1`seq(i!1)" :hide? T) (("1" (case-replace "add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1),fsA!1`seq(i!1)) = add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1), zero + fsA!1`seq(i!1))" :hide? T) (("1" (rewrite "add_charac") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (rewrite "left_zero") nil nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (rewrite "left_zero") (("3" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (lemma "inv_in") (("2" (inst -1 "fsA!1`seq(i!1)" "choose(oneSet(R!1, fsA!1)(i!1,0))") (("1" (lemma "self_coset") (("1" (inst -1 "fsA!1`seq(i!1)" "R!1" "inv(choose(oneSet(R!1, fsA!1)(i!1,0)))") (("1" (assert) (("1" (hide-all-but (-4 1)) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-4 -5 -6)) (("2" (inst -3 "choose(oneSet(R!1, fsA!1)(i!1,0))") (("2" (assert) (("2" (hide -1) (("2" (lemma "inv_in") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide -2) (("1" (lemma "add_charac") (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "one" "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1,1)))") (("1" (case-replace "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1,1))) + fsA!1`seq(i!1) = fsA!1`seq(i!1)" :hide? T) (("1" (case-replace "add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1),fsA!1`seq(i!1)) = add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1), zero + fsA!1`seq(i!1))" :hide? T) (("1" (rewrite "add_charac") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (rewrite "left_zero") nil nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (rewrite "left_zero") (("3" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil) ("2" (hide (-1 3)) (("2" (lemma "inv_in") (("2" (inst -1 "fsA!1`seq(i!1)" "choose(oneSet(R!1, fsA!1)(i!1,1))") (("1" (lemma "self_coset") (("1" (inst -1 "fsA!1`seq(i!1)" "R!1" "inv(choose(oneSet(R!1, fsA!1)(i!1,1)))") (("1" (assert) (("1" (hide-all-but (-3 1)) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-3 -4 -5)) (("2" (inst -2 "choose(oneSet(R!1, fsA!1)(i!1,1))") (("2" (assert) (("2" (hide -1) (("2" (lemma "inv_in") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (assert) (("2" (expand "product_fs_rec" 1) (("2" (expand "z!1") (("2" (lemma "product_charac") (("2" (name-replace "b!1" "product_fs_rec((# length := length(fsA!1) - 1,
                                                                                                                                              seq
                                                                                                                                                := LAMBDA (j: below[length(fsA!1) - 1]):
                                                                                                                                                     (IF j < i!1
                                                                                                                                                        THEN one
                                                                                                                                                             +
                                                                                                                                                             inv[T, +, zero]
                                                                                                                                                             (choose(oneSet(R!1, fsA!1)(i!1, j)))
                                                                                                                                                      ELSE one
                                                                                                                                                           +
                                                                                                                                                           inv[T, +, zero]
                                                                                                                                                           (choose
                                                                                                                                                            (oneSet(R!1, fsA!1)(i!1, 1 + j)))
                                                                                                                                                      ENDIF) #))
                                                                                                                                          (j!1)" :hide? T) (("1" (lift-if) (("1" (prop) (("1" (name-replace "a!1" "(one + inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 1 + j!1))))" :hide? T) (("1" (inst-cp -2 "R!1" "fsA!1`seq(i!1)" "a!1" "b!1") (("1" (replaces -4) (("1" (inst -2 "R!1" "fsA!1`seq(i!1)" "a!1" "one") (("1" (replaces -2) (("1" (rewrite "times_one") (("1" (assert) (("1" (replace -2 1 rl) (("1" (hide -2) (("1" (expand "a!1") (("1" (lemma "add_charac") (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "one" "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 1 + j!1)))") (("1" (assert) (("1" (case-replace "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 1 + j!1))) +
                                                                                                                                                                                                       fsA!1`seq(i!1) = fsA!1`seq(i!1)" :hide? T) (("1" (case-replace "add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1),fsA!1`seq(i!1)) = add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1), zero + fsA!1`seq(i!1))" :hide? T) (("1" (rewrite "add_charac") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "left_zero") nil nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (rewrite "left_zero") (("3" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (lemma "inv_in") (("2" (inst -1 "fsA!1`seq(i!1)" "choose(oneSet(R!1, fsA!1)(i!1, 1 + j!1))") (("1" (lemma "self_coset") (("1" (inst -1 "fsA!1`seq(i!1)" "R!1" "inv(choose(oneSet(R!1, fsA!1)(i!1, 1 + j!1)))") (("1" (assert) (("1" (hide (-1 2)) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "ideal?") (("3" (expand "left_ideal?") (("3" (expand "subring?") (("3" (expand "ring?") (("3" (expand "abelian_group?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-4 -5 -6)) (("2" (inst -3 "choose(oneSet(R!1, fsA!1)(i!1, 1 + j!1))") (("2" (assert) (("2" (prop) (("1" (lemma "inv_in") (("1" (inst?) nil nil)) nil) ("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 2)) (("2" (expand "a!1") (("2" (rewrite "product_in") (("2" (hide 2) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-4 -5 -6)) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 2)) (("2" (expand "b!1") (("2" (lemma "product_fs_rec_in_ring") (("2" (inst -1 "R!1" "(# length := length(fsA!1) - 1,
                                                                                                                                                                                            seq
                                                                                                                                                                                              := LAMBDA (j: below[length(fsA!1) - 1]):
                                                                                                                                                                                                   (IF j < i!1
                                                                                                                                                                                                    THEN one
                                                                                                                                                                                                         +
                                                                                                                                                                                                         inv[T, +, zero]
                                                                                                                                                                                                         (choose
                                                                                                                                                                                                          (oneSet(R!1, fsA!1)(i!1, j)))
                                                                                                                                                                                                    ELSE one
                                                                                                                                                                                                         +
                                                                                                                                                                                                         inv[T, +, zero]
                                                                                                                                                                                                         (choose
                                                                                                                                                                                                          (oneSet(R!1, fsA!1)(i!1, 1 + j)))
                                                                                                                                                                                                    ENDIF) #)") (("1" (assert) (("1" (prop) (("1" (inst?) nil nil) ("2" (hide 2) (("2" (expand "finseq_appl") (("2" (skosimp) (("2" (prop) (("1" (rewrite "product_in") (("1" (hide 2) (("1" (rewrite "inv_in") (("1" (hide 2) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-5 -6 -7)) (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_in") (("2" (hide 3) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-4 -5 -6)) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp) (("2" (expand "nonempty?") (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp) (("3" (assert) nil nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp) (("4" (expand "nonempty?") (("4" (lemma "oneSet_nonempty") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-2 2)) (("3" (expand "a!1") (("3" (rewrite "product_in") (("3" (hide 2) (("3" (rewrite "inv_in") (("3" (hide 2) (("3" (expand "ideal?") (("3" (expand "left_ideal?") (("3" (expand "subring?") (("3" (expand "subset?") (("3" (expand "member") (("3" (flatten) (("3" (hide (-4 -5 -6)) (("3" (inst?) (("3" (assert) (("3" (hide 1) (("3" (lemma "choose_member[T]") (("3" (inst?) (("3" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name-replace "a!1" "(one + inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 2 + j!1))))" :hide? T) (("2" (inst-cp -1 "R!1" "fsA!1`seq(i!1)" "a!1" "b!1") (("1" (replaces -3) (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "a!1" "one") (("1" (replaces -1) (("1" (rewrite "times_one") (("1" (assert) (("1" (replace -1 2 rl) (("1" (hide -1) (("1" (expand "a!1") (("1" (lemma "add_charac") (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "one" "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 2 + j!1)))") (("1" (assert) (("1" (case-replace "inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 2 + j!1))) +
                                                                                                                                                                                                       fsA!1`seq(i!1) = fsA!1`seq(i!1)" :hide? T) (("1" (case-replace "add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1),fsA!1`seq(i!1)) = add(R!1, fsA!1`seq(i!1))(one + fsA!1`seq(i!1), zero + fsA!1`seq(i!1))" :hide? T) (("1" (rewrite "add_charac") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "left_zero") nil nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (rewrite "left_zero") (("3" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil) ("2" (hide (-1 3)) (("2" (lemma "inv_in") (("2" (inst -1 "fsA!1`seq(i!1)" "choose(oneSet(R!1, fsA!1)(i!1, 2 + j!1))") (("1" (lemma "self_coset") (("1" (inst -1 "fsA!1`seq(i!1)" "R!1" "inv(choose(oneSet(R!1, fsA!1)(i!1, 2 + j!1)))") (("1" (assert) (("1" (hide (-1 2)) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "ideal?") (("3" (expand "left_ideal?") (("3" (expand "subring?") (("3" (expand "ring?") (("3" (expand "abelian_group?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-3 -4 -5)) (("2" (inst -2 "choose(oneSet(R!1, fsA!1)(i!1, 2 + j!1))") (("2" (assert) (("2" (prop) (("1" (lemma "inv_in") (("1" (inst?) nil nil)) nil) ("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 3)) (("2" (expand "a!1") (("2" (rewrite "product_in") (("2" (hide 2) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-3 -4 -5)) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 3)) (("2" (expand "b!1") (("2" (lemma "product_fs_rec_in_ring") (("2" (inst -1 "R!1" "(# length := length(fsA!1) - 1,
                                                                                                                                                                                            seq
                                                                                                                                                                                              := LAMBDA (j: below[length(fsA!1) - 1]):
                                                                                                                                                                                                   (IF j < i!1
                                                                                                                                                                                                    THEN one
                                                                                                                                                                                                         +
                                                                                                                                                                                                         inv[T, +, zero]
                                                                                                                                                                                                         (choose
                                                                                                                                                                                                          (oneSet(R!1, fsA!1)(i!1, j)))
                                                                                                                                                                                                    ELSE one
                                                                                                                                                                                                         +
                                                                                                                                                                                                         inv[T, +, zero]
                                                                                                                                                                                                         (choose
                                                                                                                                                                                                          (oneSet(R!1, fsA!1)(i!1, 1 + j)))
                                                                                                                                                                                                    ENDIF) #)") (("1" (assert) (("1" (prop) (("1" (inst?) nil nil) ("2" (hide 2) (("2" (expand "finseq_appl") (("2" (skosimp) (("2" (prop) (("1" (rewrite "product_in") (("1" (hide 2) (("1" (rewrite "inv_in") (("1" (hide 2) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-6 -5 -4)) (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_in") (("2" (hide 3) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-3 -5 -4)) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp) (("2" (expand "nonempty?") (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp) (("3" (assert) nil nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp) (("4" (expand "nonempty?") (("4" (lemma "oneSet_nonempty") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 3)) (("3" (expand "a!1") (("3" (rewrite "product_in") (("3" (hide 2) (("3" (rewrite "inv_in") (("3" (hide 2) (("3" (expand "ideal?") (("3" (expand "left_ideal?") (("3" (expand "subring?") (("3" (expand "subset?") (("3" (expand "member") (("3" (flatten) (("3" (hide (-3 -4 -5)) (("3" (inst?) (("3" (assert) (("3" (hide 1) (("3" (lemma "choose_member[T]") (("3" (inst?) (("3" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 2)) (("2" (skosimp) (("2" (expand "nonempty?") (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 -2 2)) (("3" (skosimp) (("3" (assert) nil nil)) nil)) nil) ("4" (hide (-1 -2 2)) (("4" (skosimp) (("4" (expand "nonempty?") (("4" (lemma "oneSet_nonempty") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil) ("5" (hide (-1 -2 2)) (("5" (skosimp) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-2 2)) (("3" (expand "z!1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 2)) (("3" (expand "z!1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "member") (("2" (inst?) (("2" (case-replace "j!1 = 0") (("1" (lemma "Product_fs_o") (("1" (inst -1 "#(first(z!1))" "rest(z!1)") (("1" (lemma "seq_first_rest_1[T]") (("1" (inst?) (("1" (prop) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (expand "rest") (("1" (lift-if) (("1" (prop) (("1" (hide (-2 1)) (("1" (expand "z!1") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "product_fs_1") (("2" (case "member(product_fs(z!1 ^ (1, z!1`length - 1)), R!1)") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "left_swallow?") (("1" (flatten) (("1" (hide -6) (("1" (expand "member") (("1" (inst -5 "product_fs(z!1 ^ (1, z!1`length - 1))" "z!1`seq(0)") (("1" (assert) nil nil) ("2" (hide (-1 -2 -4 3)) (("2" (expand "z!1") (("2" (assert) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (- 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil) ("4" (hide (- 3)) (("4" (expand "z!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 3)) (("2" (expand "member") (("2" (expand "product_fs") (("2" (prop) (("2" (lemma "product_fs_rec_in_ring") (("2" (inst?) (("1" (inst?) (("1" (prop) (("1" (inst?) (("1" (expand "member") (("1" (propax) nil nil)) nil) ("2" (hide 3) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 3) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil) ("4" (hide 3) (("4" (expand "z!1") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skosimp) (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "empty_seq") (("2" (propax) nil nil)) nil) ("3" (expand "empty_seq") (("3" (propax) nil nil)) nil) ("4" (expand "empty_seq") (("4" (propax) nil nil)) nil) ("5" (expand "z!1" 6) (("5" (prop) (("1" (rewrite "product_in") (("1" (hide 2) (("1" (rewrite "inv_in") (("1" (hide (-3 2)) (("1" (typepred "fsA!1") (("1" (expand "fsICM?") (("1" (expand "fsRI?") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (inst?) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-2 -3 -4 -5)) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_in") (("2" (hide 3) (("2" (rewrite "inv_in") (("2" (hide (-2 2)) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-2 -3 -4 -5)) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide (-2 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil) ("4" (hide (-1 3)) (("4" (expand "z!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -4 -5 -6 1)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (-1 -3 -4 2)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -3 -4 2)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide (-2 -3 -4 2)) (("3" (expand "z!1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (case "length(fsA!1) = 2") (("1" (expand "z!1") (("1" (expand "product_fs") (("1" (assert) (("1" (expand "product_fs_rec") (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "j!1 = 1") (("1" (hide 2) (("1" (lemma "Product_fs_o") (("1" (inst-cp -1 "#(z!1`seq(0))" "rest(z!1)") (("1" (inst -1 "#(rest(z!1)`seq(0))" "rest(rest(z!1))") (("1" (lemma "seq_first_rest_1[T]") (("1" (inst-cp -1 "rest(z!1)") (("1" (inst -1 "z!1") (("1" (prop) (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (replace -1 -3 rl) (("1" (replace -2 -4 rl) (("1" (replaces -3) (("1" (hide (-1 -2)) (("1" (rewrite "product_fs_1") (("1" (rewrite "product_fs_1") (("1" (lemma "rest_pos[T]") (("1" (inst?) (("1" (expand "finseq_appl") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (replaces -1) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "left_swallow?") (("1" (expand "right_ideal?") (("1" (expand "right_swallow?") (("1" (flatten) (("1" (hide (-2 -4)) (("1" (case "R!1(product_fs(rest(rest(z!1))))") (("1" (case "i!1 = 0") (("1" (expand "z!1" 2 (2 3)) (("1" (assert) (("1" (inst -4 "product_fs(rest(rest(z!1))) *
                                                                                                                                               (one + inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 2))))" "(one + inv[T, +, zero](choose(oneSet(R!1, fsA!1)(i!1, 1))))") (("1" (hide (-2 3)) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (case "R!1(one + inv[T, +, zero](choose[T](oneSet(R!1, fsA!1)(i!1, 2))))") (("1" (typepred "R!1") (("1" (expand "ring_with_one?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (expand "star_closed?") (("1" (flatten) (("1" (hide (-1 -3 -4 -5 -6 -11)) (("1" (expand "member") (("1" (inst?) (("1" (hide (-1 -3 2)) (("1" (expand "z!1") (("1" (assert) (("1" (reveal -8) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -20) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -4 2)) (("2" (rewrite "product_in") (("2" (hide 2) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-2 -3 -4 -5)) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-2 -4 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (inst -3 "product_fs(rest(rest(z!1)))" "z!1`seq(1)") (("1" (inst -4 "z!1`seq(0)" "product_fs(rest(rest(z!1))) * z!1`seq(1)") (("1" (hide (-1 -3 4)) (("1" (expand "z!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide (-1 -3 4)) (("2" (expand "z!1") (("2" (assert) (("2" (rewrite "product_in") (("2" (hide 2) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-2 -3 -4 -5)) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -3 4)) (("2" (expand "z!1") (("2" (assert) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 -3 4)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -3 3)) (("2" (expand "product_fs") (("2" (prop) (("2" (lemma "product_fs_rec_in_ring") (("2" (inst?) (("1" (inst?) (("1" (prop) (("1" (inst?) (("1" (expand "member") (("1" (propax) nil nil)) nil) ("2" (hide 3) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 3) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (skosimp) (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (expand "rest") (("2" (lift-if) (("2" (lift-if) (("2" (expand "^") (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (prop) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "empty_seq") (("2" (propax) nil nil)) nil) ("3" (expand "empty_seq") (("3" (propax) nil nil)) nil) ("4" (expand "empty_seq") (("4" (propax) nil nil)) nil) ("5" (expand "empty_seq") (("5" (propax) nil nil)) nil) ("6" (expand "empty_seq") (("6" (propax) nil nil)) nil) ("7" (expand "empty_seq") (("7" (propax) nil nil)) nil) ("8" (expand "empty_seq") (("8" (propax) nil nil)) nil) ("9" (expand "empty_seq") (("9" (propax) nil nil)) nil) ("10" (expand "empty_seq") (("10" (propax) nil nil)) nil) ("11" (expand "empty_seq") (("11" (propax) nil nil)) nil) ("12" (expand "empty_seq") (("12" (propax) nil nil)) nil) ("13" (expand "empty_seq") (("13" (propax) nil nil)) nil) ("14" (expand "empty_seq") (("14" (propax) nil nil)) nil) ("15" (expand "empty_seq") (("15" (propax) nil nil)) nil) ("16" (expand "empty_seq") (("16" (propax) nil nil)) nil) ("17" (expand "empty_seq") (("17" (propax) nil nil)) nil) ("18" (expand "empty_seq") (("18" (propax) nil nil)) nil) ("19" (expand "empty_seq") (("19" (propax) nil nil)) nil) ("20" (expand "empty_seq") (("20" (propax) nil nil)) nil) ("21" (expand "empty_seq") (("21" (propax) nil nil)) nil) ("22" (expand "empty_seq") (("22" (propax) nil nil)) nil) ("23" (expand "empty_seq") (("23" (propax) nil nil)) nil) ("24" (expand "empty_seq") (("24" (propax) nil nil)) nil) ("25" (expand "z!1" 10) (("25" (prop) (("1" (rewrite "product_in") (("1" (rewrite "inv_in") (("1" (hide 2) (("1" (typepred "fsA!1") (("1" (expand "fsICM?") (("1" (expand "fsRI?") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (inst?) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-2 -3 -4 -5)) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_in") (("2" (rewrite "inv_in") (("2" (hide (2 4)) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-2 -3 -4 -5)) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -3 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (-2 -4 2)) (("2" (expand "z!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -3 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -3 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -3 -4 -6 2)) (("2" (expand "z!1") (("2" (grind) nil nil)) nil)) nil) ("3" (hide (-1 -3 -4 -6 2)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil) ("4" (hide (-1 -3 -4 -6 2)) (("4" (expand "z!1") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -5 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -4 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -3 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide (-1 -3 3)) (("3" (expand "rest") (("3" (lift-if) (("3" (prop) (("1" (expand "z!1") (("1" (assert) nil nil)) nil) ("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (expand "z!1") (("1" (assert) nil nil)) nil) ("2" (expand "z!1") (("2" (assert) nil nil)) nil) ("3" (expand "min") (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "Product_fs_o_split") (("2" (expand "finseq_appl") (("2" (case "j!1 < i!1") (("1" (inst -2 "z!1" "j!1") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "left_swallow?") (("1" (expand "right_ideal?") (("1" (expand "right_swallow?") (("1" (flatten) (("1" (hide (-3 1 2)) (("1" (case "member(product_fs(z!1 ^ (1 + j!1, length(z!1) - 1)), R!1)") (("1" (case "member(product_fs(z!1 ^ (0, j!1 - 1)), R!1)") (("1" (case "member(z!1`seq(j!1),fsA!1`seq(j!1))") (("1" (expand "member") (("1" (inst -6 "product_fs(z!1 ^ (1 + j!1, length(z!1) - 1))" "z!1`seq(j!1)") (("1" (inst -8 "product_fs(z!1 ^ (0, j!1 - 1))" "product_fs(z!1 ^ (1 + j!1, length(z!1) - 1)) * z!1`seq(j!1)") (("1" (assert) nil nil) ("2" (hide (- 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide (- 3)) (("3" (assert) nil nil)) nil) ("4" (hide (- 3)) (("4" (expand "z!1") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (- 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide (- 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -4 -5 -7 3)) (("2" (expand "member") (("2" (expand "z!1") (("2" (assert) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (hide (-1 -3 -4 -6 3)) (("2" (expand "member") (("2" (expand "product_fs") (("2" (prop) (("2" (lemma "product_fs_rec_in_ring") (("2" (inst?) (("1" (inst?) (("1" (assert) (("1" (prop) (("1" (inst?) (("1" (hide (- 3)) (("1" (expand "z!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (hide 3) (("2" (skosimp) (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "z!1" 4) (("2" (prop) (("1" (rewrite "product_in") (("1" (hide 2) (("1" (rewrite "inv_in") (("1" (hide (-3 2)) (("1" (typepred "fsA!1") (("1" (expand "fsICM?") (("1" (expand "fsRI?") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (inst?) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-2 -3 -4 -5)) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 2)) (("2" (typepred "i!2") (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide (-2 2 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (hide (-2 -3 -4 -5 3)) (("2" (expand "member") (("2" (expand "product_fs") (("2" (prop) (("2" (lemma "product_fs_rec_in_ring") (("2" (inst?) (("1" (inst?) (("1" (prop) (("1" (inst?) (("1" (assert) nil nil) ("2" (hide 3) (("2" (assert) nil nil)) nil) ("3" (hide 3) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil) ("4" (hide 3) (("4" (expand "z!1") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (hide 3) (("2" (skosimp) (("2" (expand "member") (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "empty_seq") (("2" (propax) nil nil)) nil) ("3" (expand "empty_seq") (("3" (propax) nil nil)) nil) ("4" (expand "empty_seq") (("4" (propax) nil nil)) nil) ("5" (expand "z!1" 6) (("5" (prop) (("1" (rewrite "product_in") (("1" (hide 2) (("1" (rewrite "inv_in") (("1" (hide 2) (("1" (typepred "fsA!1") (("1" (expand "fsICM?") (("1" (expand "fsRI?") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (inst?) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-2 -3 -4 -5)) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_in") (("2" (hide 3) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-2 -3 -4 -5)) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 3) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (- 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil) ("4" (hide (- 3)) (("4" (expand "z!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 3)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide (-2 3)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -1 "z!1" "j!1 - 1") (("1" (assert) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "left_swallow?") (("1" (expand "right_ideal?") (("1" (expand "right_swallow?") (("1" (flatten) (("1" (hide (-4 3)) (("1" (case "member(product_fs(z!1 ^ (j!1, length(z!1) - 1)), R!1)") (("1" (case "member(product_fs(z!1 ^ (0, j!1 - 2)), R!1)") (("1" (case "member(z!1`seq(j!1 - 1),fsA!1`seq(j!1))") (("1" (expand "member") (("1" (inst -6 "product_fs(z!1 ^ (j!1, length(z!1) - 1)) " "z!1`seq(j!1-1)") (("1" (inst -7 "product_fs(z!1 ^ (0, j!1 - 2))" "product_fs(z!1 ^ (j!1, length(z!1) - 1)) * z!1`seq(j!1 - 1)") (("1" (assert) nil nil) ("2" (hide (- 5)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (- 5)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -4 -5 -6 5)) (("2" (expand "member") (("2" (expand "z!1") (("2" (assert) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -4 -5 5)) (("2" (expand "member") (("2" (expand "product_fs") (("2" (prop) (("2" (lemma "product_fs_rec_in_ring") (("2" (inst?) (("2" (inst?) (("2" (assert) (("2" (prop) (("1" (inst?) nil nil) ("2" (expand "finseq_appl") (("2" (hide 3) (("2" (skosimp) (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "z!1" 4) (("2" (prop) (("1" (rewrite "product_in") (("1" (hide 2) (("1" (rewrite "inv_in") (("1" (hide 2) (("1" (typepred "fsA!1") (("1" (expand "fsICM?") (("1" (expand "fsRI?") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (inst?) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-2 -3 -4 -5)) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_in") (("2" (hide 3) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-2 -3 -4 -5)) (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 -4 5)) (("2" (expand "member") (("2" (expand "product_fs") (("2" (prop) (("2" (lemma "product_fs_rec_in_ring") (("2" (inst?) (("1" (inst?) (("1" (prop) (("1" (inst?) (("1" (assert) nil nil) ("2" (hide 3) (("2" (assert) nil nil)) nil) ("3" (hide 3) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "finseq_appl") (("2" (skosimp) (("2" (expand "member") (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "empty_seq") (("2" (propax) nil nil)) nil) ("3" (expand "empty_seq") (("3" (propax) nil nil)) nil) ("4" (expand "empty_seq") (("4" (propax) nil nil)) nil) ("5" (expand "z!1" 6) (("5" (rewrite "product_in") (("5" (hide 7) (("5" (rewrite "inv_in") (("5" (hide 2) (("5" (typepred "fsA!1") (("5" (expand "fsICM?") (("5" (expand "fsRI?") (("5" (expand "finseq_appl") (("5" (flatten) (("5" (inst?) (("5" (expand "ideal?") (("5" (expand "left_ideal?") (("5" (expand "subring?") (("5" (expand "subset?") (("5" (expand "member") (("5" (flatten) (("5" (hide (-2 -3 -4 -5)) (("5" (inst?) (("5" (assert) (("5" (hide 2) (("5" (lemma "choose_member[T]") (("5" (inst?) (("5" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (- 5)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide (-1 6)) (("2" (expand "z!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide (-1 6)) (("3" (expand "z!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (skosimp) (("2" (expand "nonempty?") (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 4) (("3" (skosimp) (("3" (assert) nil nil)) nil)) nil) ("4" (hide 4) (("4" (skosimp) (("4" (expand "nonempty?") (("4" (lemma "oneSet_nonempty") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 4) (("5" (skosimp) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "product_fs") (("2" (assert) (("2" (lemma "product_fs_rec_in_ring") (("2" (inst?) (("1" (inst?) (("1" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (expand "finseq_appl") (("2" (skosimp) (("2" (prop) (("1" (rewrite "product_in") (("1" (hide 2) (("1" (rewrite "inv_in") (("1" (hide 2) (("1" (inst?) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (expand "subset?") (("1" (expand "member") (("1" (flatten) (("1" (hide (-3 -4 -5)) (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (lemma "choose_member[T]") (("1" (inst?) (("1" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "product_in") (("2" (hide 3) (("2" (rewrite "inv_in") (("2" (hide 2) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "subset?") (("2" (expand "member") (("2" (flatten) (("2" (hide (-2 -3 -4)) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (lemma "choose_member[T]") (("2" (inst?) (("2" (prop) (("1" (expand "member") (("1" (expand "oneSet" -1 1) (("1" (expand "extend") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp) (("2" (expand "nonempty?") (("2" (lemma "oneSet_nonempty") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp) (("3" (assert) nil nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp) (("4" (expand "nonempty?") (("4" (lemma "oneSet_nonempty") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (expand "nonempty?") (("3" (lemma "oneSet_nonempty") (("3" (inst?) nil nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil) ("5" (skosimp) (("5" (expand "nonempty?") (("5" (lemma "oneSet_nonempty") (("5" (inst?) nil nil)) nil)) nil)) nil) ("6" (skosimp) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (empty_seq const-decl "finseq" finite_sequences nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (choose_member formula-decl nil sets_lemmas nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (subring? const-decl "bool" ring_def nil) (abelian_group? const-decl "bool" group_def nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (inv_in formula-decl nil group nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (right_identity formula-decl nil monad nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (subset? const-decl "bool" sets nil) (add_charac formula-decl nil quotient_rings nil) (extend const-decl "R" extend nil) (oneSet_nonempty formula-decl nil chinese_remainder_theorem_rings nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (times_one formula-decl nil ring_with_one nil) (product_in formula-decl nil group nil) (TRUE const-decl "bool" booleans nil) (product_fs_rec_in_ring formula-decl nil product_finseq_sets_ring nil) (product_charac formula-decl nil quotient_rings nil) (product_fs_rec def-decl "T" product_finseq_sets_ring nil) (rest const-decl "finseq" seq_extras structures) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (^ const-decl "finseq" finite_sequences nil) (left_swallow? const-decl "bool" ring_ideal_def nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (product_fs_1 formula-decl nil product_finseq_sets_ring nil) (seq_first_rest_1 formula-decl nil seq_extras structures) (Product_fs_o formula-decl nil product_finseq_sets_ring nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (right_swallow? const-decl "bool" ring_ideal_def nil) (monoid? const-decl "bool" monoid_def nil) (star_closed? const-decl "bool" groupoid_def nil) (monad? const-decl "bool" monad_def nil) (right_ideal? const-decl "bool" ring_ideal_def nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (rest_pos formula-decl nil seq_extras structures) (int_plus_int_is_int application-judgement "int" integers nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (Product_fs_o_split formula-decl nil product_finseq_sets_ring nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (choose const-decl "(p)" sets nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonempty? const-decl "bool" sets nil) (oneSet const-decl "set[T]" chinese_remainder_theorem_rings nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (product_fs const-decl "T" product_finseq_sets_ring nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (product_fs_emptyseq formula-decl nil product_finseq_sets_ring nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil)) shostak)) (surjective_aux_2_TCC1 0 (surjective_aux_2_TCC1-1 nil 3783346813 ("" (skosimp) (("" (typepred "fsA!1") (("" (expand "fsICM?") (("" (assert) nil nil)) nil)) nil)) nil) ((fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (set type-eq-decl nil sets nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (surjective_aux_2 subtype "chinese_remainder_theorem_rings.fsA" "fsI[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero](chinese_remainder_theorem_rings.R)"))) (surjective_aux_2_TCC2 0 (surjective_aux_2_TCC2-1 nil 3783346813 ("" (skeep) (("" (skeep) (("" (expand "member") (("" (expand "cartesian_product_n") (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (member const-decl "bool" sets nil)) nil (surjective_aux_2 subtype "chinese_remainder_theorem_rings.i" "below[length(y)]"))) (surjective_aux_2_TCC3 0 (surjective_aux_2_TCC3-1 nil 3783346813 ("" (skeep*) (("" (expand "member") (("" (typepred "r") (("" (grind) nil nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (left_coset? const-decl "bool" cosets_def nil) (right_coset? const-decl "bool" cosets_def nil) (coset? const-decl "bool" cosets_def nil) (/ const-decl "setof[set[T]]" cosets_def nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (finseq type-eq-decl nil finite_sequences nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (surjective_aux_2 subtype "chinese_remainder_theorem_rings.i" "below[length(r)]"))) (surjective_aux_2_TCC4 0 (surjective_aux_2_TCC4-1 nil 3783346813 ("" (skeep) (("" (skeep) (("" (assert) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (member const-decl "bool" sets nil)) nil (surjective_aux_2 subtype "(number_fields.-)(length(chinese_remainder_theorem_rings.fsA), 1)" "int_below_N[T, +, *, zero, length(fsA)]"))) (surjective_aux_2_TCC5 0 (surjective_aux_2_TCC5-1 nil 3783346813 ("" (skeep*) (("" (grind) nil nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (member const-decl "bool" sets nil) (/ const-decl "setof[set[T]]" cosets_def nil) (coset? const-decl "bool" cosets_def nil) (right_coset? const-decl "bool" cosets_def nil) (left_coset? const-decl "bool" cosets_def nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (surjective_aux_2 subtype "chinese_remainder_theorem_rings.i" "below[length(s)]"))) (surjective_aux_2_TCC6 0 (surjective_aux_2_TCC6-1 nil 3783346813 ("" (skeep*) (("" (grind) nil nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (member const-decl "bool" sets nil) (/ const-decl "setof[set[T]]" cosets_def nil) (coset? const-decl "bool" cosets_def nil) (right_coset? const-decl "bool" cosets_def nil) (left_coset? const-decl "bool" cosets_def nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (surjective_aux_2 subtype "chinese_remainder_theorem_rings.i" "below[length(r)]"))) (surjective_aux_2_TCC7 0 (surjective_aux_2_TCC7-1 nil 3783522603 ("" (skeep*) (("" (grind) nil nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (member const-decl "bool" sets nil) (/ const-decl "setof[set[T]]" cosets_def nil) (coset? const-decl "bool" cosets_def nil) (right_coset? const-decl "bool" cosets_def nil) (left_coset? const-decl "bool" cosets_def nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (surjective_aux_2 subtype "length(chinese_remainder_theorem_rings.fsA)" "posnat"))) (surjective_aux_2_TCC8 0 (surjective_aux_2_TCC8-1 nil 3796740329 ("" (skosimp*) (("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (assert) nil nil)) nil)) nil)) nil) ((fullset_is_ring_with_one formula-decl nil chinese_remainder_theorem_rings nil) (member const-decl "bool" sets nil) (ring_with_one? const-decl "bool" ring_with_one_def nil)) nil (surjective_aux_2 assuming "sigma_R_below[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero, length(chinese_remainder_theorem_rings.fsA)].sigma_R_below" "fullset_is_ring: ASSUMPTION ring_def[sigma_R_below.T, sigma_R_below.+, sigma_R_below.*, sigma_R_below.zero].ring?(sets[sigma_R_below.T].fullset)"))) (surjective_aux_2 0 (surjective_aux_2-2 nil 3785682497 ("" (expand* "member" "finseq_appl") (("" (skosimp) (("" (case "length(fsA!1) = 0") (("1" (grind) nil nil) ("2" (hide 1) (("2" (lemma "cartesian_product_fs_representative") (("2" (inst -1 "R!1" "fsA!1" "y!1") (("2" (expand* "member" "finseq_appl") (("2" (assert) (("2" (skosimp) (("2" (lemma "surjective_aux_1") (("2" (expand* "member" "finseq_appl") (("2" (inst -1 "R!1" "fsA!1") (("2" (skosimp) (("2" (inst 1 "s!1" "r!1") (("2" (skosimp) (("2" (prop) (("1" (hide (-1 -3)) (("1" (inst?) nil nil)) nil) ("2" (lemma "R_sigma_b_middle[T, +, *, zero, length(fsA!1)]") (("1" (inst -1 "LAMBDA (i_1: below[length(fsA!1)]):
                                             s!1`seq(i_1) * r!1`seq(i_1)" "length(fsA!1) - 1" "i!1" "0") (("1" (assert) (("1" (replaces -1) (("1" (lemma "R_sigma_b_add_zero[T, +, *, zero, length(fsA!1)]") (("1" (inst-cp -1 "LAMBDA (i_1: below[length(fsA!1)]):
                                                                s!1`seq(i_1) * r!1`seq(i_1)" "fsA!1`seq(i!1)" "R!1" "i!1 - 1" "0") (("1" (prop) (("1" (inst -2 "LAMBDA (i_1: below[length(fsA!1)]):
                                                                          s!1`seq(i_1) * r!1`seq(i_1)" "fsA!1`seq(i!1)" "R!1" "length(fsA!1) - 1" "1 + i!1") (("1" (prop) (("1" (lemma "add_charac") (("1" (inst-cp -1 "R!1" "fsA!1`seq(i!1)" "R_sigma_below[T, +, *, zero, length(fsA!1)](0, i!1 - 1,
                                                                    LAMBDA (i_1: below[length(fsA!1)]):
                                                                      s!1`seq(i_1) * r!1`seq(i_1))
                                                       + s!1`seq(i!1) * r!1`seq(i!1)" "R_sigma_below[T, +, *, zero, length(fsA!1)](1 + i!1, length(fsA!1) - 1,
                                                                     LAMBDA (i_1: below[length(fsA!1)]):
                                                                       s!1`seq(i_1) * r!1`seq(i_1))") (("1" (inst-cp -1 "R!1" "fsA!1`seq(i!1)" "R_sigma_below[T, +, *, zero, length(fsA!1)](0, i!1 - 1,
                                                                              LAMBDA (i_1: below[length(fsA!1)]):
                                                                                s!1`seq(i_1) * r!1`seq(i_1))" "s!1`seq(i!1) * r!1`seq(i!1)") (("1" (replaces -4) (("1" (replaces -4) (("1" (replace -2 -3 rl) (("1" (replace -3 1 rl) (("1" (hide (-3 -2)) (("1" (inst -2 "i!1") (("1" (flatten) (("1" (lemma "product_charac") (("1" (inst-cp -1 "R!1" "fsA!1`seq(i!1)" "s!1`seq(i!1)" "r!1`seq(i!1)") (("1" (replace -2 1 rl) (("1" (hide -2) (("1" (replaces -3) (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "one" "r!1`seq(i!1)") (("1" (replaces -1) (("1" (rewrite "one_times") (("1" (inst-cp -1 "R!1" "fsA!1`seq(i!1)" "zero" "r!1`seq(i!1)") (("1" (rewrite "left_zero") (("1" (rewrite "zero_plus") (("1" (replaces -2) (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "r!1`seq(i!1)" "zero") (("1" (rewrite "left_zero") (("1" (rewrite "plus_zero") nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (flatten) (("2" (hide (-1 -3 -4 -5 -6)) (("2" (expand "star_closed?") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "R_sigma_b_in_ideal[T, +, *, zero, length(fsA!1)]") (("3" (inst?) (("3" (inst -1 "R!1" "R!1") (("3" (assert) (("3" (hide 2) (("3" (prop) (("1" (rewrite "self_ideal") nil nil) ("2" (skosimp) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (flatten) (("2" (hide (-1 -3 -4 -5 -6)) (("2" (expand "star_closed?") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "fullset_is_ring") nil nil)) nil) ("5" (hide-all-but 1) (("5" (typepred "fsA!1") (("5" (expand "fsICM?") (("5" (expand "fsRI?") (("5" (expand "finseq_appl") (("5" (flatten) (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "R_sigma_b_in_ideal[T, +, *, zero, length(fsA!1)]") (("2" (inst?) (("2" (inst -1 "R!1" "R!1") (("2" (assert) (("2" (hide 2) (("2" (prop) (("1" (rewrite "self_ideal") nil nil) ("2" (skosimp) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (flatten) (("2" (hide (-1 -3 -4 -5 -6)) (("2" (expand "star_closed?") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "R_sigma_b_in_ideal[T, +, *, zero, length(fsA!1)]") (("3" (inst?) (("3" (inst -1 "R!1" "R!1") (("3" (assert) (("3" (prop) (("1" (assert) (("1" (typepred "R!1") (("1" (expand "ring_with_one?") (("1" (expand "ring?") (("1" (expand "star_closed?") (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (hide-all-but (-1 -16 1)) (("1" (expand "star_closed?") (("1" (expand "member") (("1" (inst?) (("1" (hide (-1 2)) (("1" (typepred "R!1") (("1" (expand "ring_with_one?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (hide (-1 -3 -4 -5 -6)) (("1" (expand "star_closed?") (("1" (expand "member") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (rewrite "fullset_is_ring") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "self_ideal") nil nil)) nil) ("3" (hide 2) (("3" (skosimp) (("3" (typepred "R!1") (("3" (expand "ring_with_one?") (("3" (expand "monoid?") (("3" (expand "monad?") (("3" (flatten) (("3" (hide (-1 -3 -4 -5 -6)) (("3" (expand "star_closed?") (("3" (expand "member") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "fullset_is_ring") nil nil)) nil) ("5" (hide-all-but 1) (("5" (typepred "fsA!1") (("5" (expand "fsICM?") (("5" (expand "fsRI?") (("5" (expand "finseq_appl") (("5" (flatten) (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 -3 -4 2)) (("3" (skosimp) (("3" (expand "member") (("3" (prop) (("1" (hide -1) (("1" (typepred "R!1") (("1" (expand "ring_with_one?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (hide (-1 -3 -4 -5 -6)) (("1" (expand "star_closed?") (("1" (expand "member") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "j!1") (("2" (flatten) (("2" (inst -2 "i!1") (("2" (hide -1) (("2" (lemma "self_coset") (("2" (inst -1 "fsA!1`seq(i!1)" "R!1" "s!1`seq(j!1)") (("2" (expand "member") (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (hide -2) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (flatten) (("2" (hide (-2 -3)) (("2" (assert) (("2" (hide (-1 -3 1)) (("2" (lemma "product_charac") (("2" (inst-cp -1 "R!1" "fsA!1`seq(i!1)" "s!1`seq(j!1)" "r!1`seq(j!1)") (("1" (replaces -3) (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "zero" "r!1`seq(j!1)") (("1" (rewrite "zero_times") (("1" (rewrite "left_zero") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 -3 -4 2)) (("3" (skosimp) (("3" (expand "member") (("3" (prop) (("1" (hide -1) (("1" (typepred "R!1") (("1" (expand "ring_with_one?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (hide (-1 -3 -4 -5 -6)) (("1" (expand "star_closed?") (("1" (expand "member") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "j!1") (("2" (flatten) (("2" (inst -2 "i!1") (("2" (hide -1) (("2" (lemma "self_coset") (("2" (inst -1 "fsA!1`seq(i!1)" "R!1" "s!1`seq(j!1)") (("2" (expand "member") (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (hide -2) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (flatten) (("2" (hide (-2 -3)) (("2" (assert) (("2" (hide (-1 -3 1)) (("2" (lemma "product_charac") (("2" (inst-cp -1 "R!1" "fsA!1`seq(i!1)" "s!1`seq(j!1)" "r!1`seq(j!1)") (("1" (replaces -3) (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "zero" "r!1`seq(j!1)") (("1" (rewrite "zero_times") (("1" (rewrite "left_zero") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "fullset_is_ring") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((y!1 skolem-const-decl "finseq[set[T]]" chinese_remainder_theorem_rings nil) (fsA!1 skolem-const-decl "fsICM[T, +, *, zero, one](R!1)" chinese_remainder_theorem_rings nil) (R!1 skolem-const-decl "ring_with_one[T, +, *, zero, one]" chinese_remainder_theorem_rings nil) (setof type-eq-decl nil defined_types nil) (fsI type-eq-decl nil ring_ideal_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (surjective_aux_1 formula-decl nil chinese_remainder_theorem_rings nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_below_N type-eq-decl nil sigma_R_below nil) (TRUE const-decl "bool" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (zero_times formula-decl nil ring nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (add_charac formula-decl nil quotient_rings nil) (product_charac formula-decl nil quotient_rings nil) (zero_plus formula-decl nil ring nil) (plus_zero formula-decl nil ring nil) (NOT const-decl "[bool -> bool]" booleans nil) (group? const-decl "bool" group_def nil) (monad? const-decl "bool" monad_def nil) (monoid? const-decl "bool" monoid_def nil) (abelian_group? const-decl "bool" group_def nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (one_times formula-decl nil ring_with_one nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (star_closed? const-decl "bool" groupoid_def nil) (R_sigma_b_in_ideal formula-decl nil sigma_R_below nil) (subrange type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (self_ideal formula-decl nil ring_ideal nil) (fullset_is_ring formula-decl nil cartesian_product_quot_ring nil) (ideal type-eq-decl nil ring_ideal_def nil) (r!1 skolem-const-decl "{r: finseq[(R!1)] | length(r) = length(fsA!1)}" chinese_remainder_theorem_rings nil) (s!1 skolem-const-decl "{s: finseq[(R!1)] | length(s) = length(fsA!1)}" chinese_remainder_theorem_rings nil) (R_sigma_below def-decl "T" sigma_R_below nil) (i!1 skolem-const-decl "below[length(fsA!1)]" chinese_remainder_theorem_rings nil) (ideal? const-decl "bool" ring_ideal_def nil) (R_sigma_b_add_zero formula-decl nil sigma_R_below nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (fullset const-decl "set" sets nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (R_sigma_b_middle formula-decl nil sigma_R_below nil) (cartesian_product_fs_representative formula-decl nil product_finseq_sets_ring nil) (empty_seq const-decl "finseq" finite_sequences nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (emptyset const-decl "set" sets nil) (finite_emptyset name-judgement "finite_set[T]" seq_extras structures) (finite_emptyset name-judgement "finite_set" finite_sets nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (member const-decl "bool" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil) (surjective_aux_2-1 nil 3783346959 ("" (expand* "member" "finseq_appl") (("" (skosimp) (("" (lemma "cartesian_product_fs_representative") (("" (inst -1 "R!1" "fsA!1" "y!1") (("" (expand* "member" "finseq_appl") (("" (assert) (("" (skosimp) (("" (lemma "surjective_aux_1") (("" (expand* "member" "finseq_appl") (("" (inst -1 "R!1" "fsA!1") (("" (skosimp) (("" (inst 1 "s!1" "r!1") (("" (skosimp) (("" (prop) (("1" (hide (-1 -3)) (("1" (inst?) nil nil)) nil) ("2" (lemma "R_sigma_b_middle[T, +, *, zero, length(fsA!1)]") (("1" (inst -1 "LAMBDA (i_1: below[length(fsA!1)]):
                                       s!1`seq(i_1) * r!1`seq(i_1)" "length(fsA!1) - 1" "i!1" "0") (("1" (assert) (("1" (replaces -1) (("1" (lemma "R_sigma_b_add_zero[T, +, *, zero, length(fsA!1)]") (("1" (inst-cp -1 "LAMBDA (i_1: below[length(fsA!1)]):
                                                          s!1`seq(i_1) * r!1`seq(i_1)" "fsA!1`seq(i!1)" "R!1" "i!1 - 1" "0") (("1" (prop) (("1" (inst -2 "LAMBDA (i_1: below[length(fsA!1)]):
                                                                  s!1`seq(i_1) * r!1`seq(i_1)" "fsA!1`seq(i!1)" "R!1" "length(fsA!1) - 1" "1 + i!1") (("1" (prop) (("1" (lemma "add_charac") (("1" (inst-cp -1 "R!1" "fsA!1`seq(i!1)" "R_sigma_below[T, +, *, zero, length(fsA!1)](0, i!1 - 1,
                                                          LAMBDA (i_1: below[length(fsA!1)]):
                                                            s!1`seq(i_1) * r!1`seq(i_1))
                                             + s!1`seq(i!1) * r!1`seq(i!1)" "R_sigma_below[T, +, *, zero, length(fsA!1)](1 + i!1, length(fsA!1) - 1,
                                                           LAMBDA (i_1: below[length(fsA!1)]):
                                                             s!1`seq(i_1) * r!1`seq(i_1))") (("1" (inst-cp -1 "R!1" "fsA!1`seq(i!1)" "R_sigma_below[T, +, *, zero, length(fsA!1)](0, i!1 - 1,
                                                                  LAMBDA (i_1: below[length(fsA!1)]):
                                                                    s!1`seq(i_1) * r!1`seq(i_1))" "s!1`seq(i!1) * r!1`seq(i!1)") (("1" (replaces -4) (("1" (replaces -4) (("1" (replace -2 -3 rl) (("1" (replace -3 1 rl) (("1" (hide (-3 -2)) (("1" (inst -2 "i!1") (("1" (flatten) (("1" (lemma "product_charac") (("1" (inst-cp -1 "R!1" "fsA!1`seq(i!1)" "s!1`seq(i!1)" "r!1`seq(i!1)") (("1" (replace -2 1 rl) (("1" (hide -2) (("1" (replaces -3) (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "one" "r!1`seq(i!1)") (("1" (replaces -1) (("1" (rewrite "one_times") (("1" (inst-cp -1 "R!1" "fsA!1`seq(i!1)" "zero" "r!1`seq(i!1)") (("1" (rewrite "left_zero") (("1" (rewrite "zero_plus") (("1" (replaces -2) (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "r!1`seq(i!1)" "zero") (("1" (rewrite "left_zero") (("1" (rewrite "plus_zero") nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (flatten) (("2" (hide (-1 -3 -4 -5 -6)) (("2" (expand "star_closed?") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "R_sigma_b_in_ideal[T, +, *, zero, length(fsA!1)]") (("3" (inst?) (("3" (inst -1 "R!1" "R!1") (("3" (assert) (("3" (hide 2) (("3" (prop) (("1" (rewrite "self_ideal") nil nil) ("2" (skosimp) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (flatten) (("2" (hide (-1 -3 -4 -5 -6)) (("2" (expand "star_closed?") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "fullset_is_ring") nil nil)) nil) ("5" (hide-all-but 1) (("5" (typepred "fsA!1") (("5" (expand "fsICM?") (("5" (expand "fsRI?") (("5" (expand "finseq_appl") (("5" (flatten) (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "R_sigma_b_in_ideal[T, +, *, zero, length(fsA!1)]") (("2" (inst?) (("2" (inst -1 "R!1" "R!1") (("2" (assert) (("2" (hide 2) (("2" (prop) (("1" (rewrite "self_ideal") nil nil) ("2" (skosimp) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (flatten) (("2" (hide (-1 -3 -4 -5 -6)) (("2" (expand "star_closed?") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "R_sigma_b_in_ideal[T, +, *, zero, length(fsA!1)]") (("3" (inst?) (("3" (inst -1 "R!1" "R!1") (("3" (assert) (("3" (prop) (("1" (assert) (("1" (typepred "R!1") (("1" (expand "ring_with_one?") (("1" (expand "ring?") (("1" (expand "star_closed?") (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (hide-all-but (-1 -16 1)) (("1" (expand "star_closed?") (("1" (expand "member") (("1" (inst?) (("1" (hide (-1 2)) (("1" (typepred "R!1") (("1" (expand "ring_with_one?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (hide (-1 -3 -4 -5 -6)) (("1" (expand "star_closed?") (("1" (expand "member") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (rewrite "fullset_is_ring") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "self_ideal") nil nil)) nil) ("3" (hide 2) (("3" (skosimp) (("3" (typepred "R!1") (("3" (expand "ring_with_one?") (("3" (expand "monoid?") (("3" (expand "monad?") (("3" (flatten) (("3" (hide (-1 -3 -4 -5 -6)) (("3" (expand "star_closed?") (("3" (expand "member") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "fullset_is_ring") nil nil)) nil) ("5" (hide-all-but 1) (("5" (typepred "fsA!1") (("5" (expand "fsICM?") (("5" (expand "fsRI?") (("5" (expand "finseq_appl") (("5" (flatten) (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 -3 -4 2)) (("3" (skosimp) (("3" (expand "member") (("3" (prop) (("1" (hide -1) (("1" (typepred "R!1") (("1" (expand "ring_with_one?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (hide (-1 -3 -4 -5 -6)) (("1" (expand "star_closed?") (("1" (expand "member") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "j!1") (("2" (flatten) (("2" (inst -2 "i!1") (("2" (hide -1) (("2" (lemma "self_coset") (("2" (inst -1 "fsA!1`seq(i!1)" "R!1" "s!1`seq(j!1)") (("2" (expand "member") (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (hide -2) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (flatten) (("2" (hide (-2 -3)) (("2" (assert) (("2" (hide (-1 -3 1)) (("2" (lemma "product_charac") (("2" (inst-cp -1 "R!1" "fsA!1`seq(i!1)" "s!1`seq(j!1)" "r!1`seq(j!1)") (("1" (replaces -3) (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "zero" "r!1`seq(j!1)") (("1" (rewrite "zero_times") (("1" (rewrite "left_zero") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 -3 -4 2)) (("3" (skosimp) (("3" (expand "member") (("3" (prop) (("1" (hide -1) (("1" (typepred "R!1") (("1" (expand "ring_with_one?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (hide (-1 -3 -4 -5 -6)) (("1" (expand "star_closed?") (("1" (expand "member") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "j!1") (("2" (flatten) (("2" (inst -2 "i!1") (("2" (hide -1) (("2" (lemma "self_coset") (("2" (inst -1 "fsA!1`seq(i!1)" "R!1" "s!1`seq(j!1)") (("2" (expand "member") (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (hide -2) (("2" (inst?) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (flatten) (("2" (hide (-2 -3)) (("2" (assert) (("2" (hide (-1 -3 1)) (("2" (lemma "product_charac") (("2" (inst-cp -1 "R!1" "fsA!1`seq(i!1)" "s!1`seq(j!1)" "r!1`seq(j!1)") (("1" (replaces -3) (("1" (inst -1 "R!1" "fsA!1`seq(i!1)" "zero" "r!1`seq(j!1)") (("1" (rewrite "zero_times") (("1" (rewrite "left_zero") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "fullset_is_ring") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (member const-decl "bool" sets nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (cartesian_product_fs_representative formula-decl nil product_finseq_sets_ring nil) (R_sigma_b_middle formula-decl nil sigma_R_below nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (fullset const-decl "set" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (R_sigma_b_add_zero formula-decl nil sigma_R_below nil) (ideal? const-decl "bool" ring_ideal_def nil) (R_sigma_below def-decl "T" sigma_R_below nil) (ideal type-eq-decl nil ring_ideal_def nil) (self_ideal formula-decl nil ring_ideal nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (subrange type-eq-decl nil integers nil) (R_sigma_b_in_ideal formula-decl nil sigma_R_below nil) (star_closed? const-decl "bool" groupoid_def nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (one_times formula-decl nil ring_with_one nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (abelian_group? const-decl "bool" group_def nil) (monoid? const-decl "bool" monoid_def nil) (monad? const-decl "bool" monad_def nil) (group? const-decl "bool" group_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (plus_zero formula-decl nil ring nil) (zero_plus formula-decl nil ring nil) (product_charac formula-decl nil quotient_rings nil) (add_charac formula-decl nil quotient_rings nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (zero_times formula-decl nil ring nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (int_below_N type-eq-decl nil sigma_R_below nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (surjective_aux_1 formula-decl nil chinese_remainder_theorem_rings nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (setof type-eq-decl nil defined_types nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil)) shostak)) (CRT_aux_1_TCC1 0 (CRT_aux_1_TCC1-1 nil 3782829257 ("" (skosimp*) (("" (prop) (("1" (skosimp) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil) ("2" (replaces -1) (("2" (expand "cartesian_product_n") (("2" (prop) (("1" (expand "fsQ") (("1" (assert) nil nil)) nil) ("2" (expand "fsQ") (("2" (propax) nil nil)) nil) ("3" (expand "finseq_appl") (("3" (expand "member") (("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "coset?") (("3" (lemma "lcoset_iff_rcoset") (("3" (inst?) (("3" (prop) (("1" (hide (2 3 4)) (("1" (expand "left_coset?") (("1" (inst?) nil nil)) nil)) nil) ("2" (hide (1 2 4)) (("2" (expand "left_coset?") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "restrict") (("3" (expand "cartesian_product_n") (("3" (expand "finseq_appl") (("3" (expand "member") (("3" (prop) (("1" (expand "fsQ") (("1" (assert) nil nil)) nil) ("2" (expand "fsQ") (("2" (assert) nil nil)) nil) ("3" (skosimp) (("3" (replaces -1) (("3" (assert) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "coset?") (("3" (lemma "lcoset_iff_rcoset") (("3" (inst?) (("1" (prop) (("1" (hide (2 3 4)) (("1" (expand "left_coset?") (("1" (inst?) nil nil)) nil)) nil) ("2" (hide (1 2 4)) (("2" (expand "left_coset?") (("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (hide (2 3)) (("2" (reveal -2) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (coset? const-decl "bool" cosets_def nil) (set type-eq-decl nil sets nil) (+ const-decl "set[T]" cosets_def nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (left_coset? const-decl "bool" cosets_def nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (lcoset_iff_rcoset formula-decl nil ring_cosets_lemmas nil) (/ const-decl "setof[set[T]]" cosets_def nil) (member const-decl "bool" sets nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below(length(phi!1(x1!1)))" chinese_remainder_theorem_rings nil) (x1!1 skolem-const-decl "(R!1)" chinese_remainder_theorem_rings nil) (phi!1 skolem-const-decl "[(R!1) -> [# length: nat, seq: [below[length(fsA!1)] -> set[T]] #]]" chinese_remainder_theorem_rings nil) (fsA!1 skolem-const-decl "{fsA: fsI(R!1) | length(fsA) /= 0}" chinese_remainder_theorem_rings nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" chinese_remainder_theorem_rings nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (restrict const-decl "R" restrict nil)) nil (CRT_aux_1 subtype "chinese_remainder_theorem_rings.phi" "[(chinese_remainder_theorem_rings.R) -> (restrict[finseq[set[T]], (cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA))), bool].restrict(cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA))))]"))) (CRT_aux_1_TCC2 0 (CRT_aux_1_TCC3-1 nil 3782829257 ("" (skosimp) (("" (inst 1 "fsA!1") (("" (expand "cartesian_product_n") (("" (prop) (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (hide -) (("2" (grind) nil nil)) nil) ("3" (hide -1) (("3" (skosimp) (("3" (expand "member") (("3" (expand "finseq_appl") (("3" (expand "fsQ") (("3" (expand "/") (("3" (rewrite "lcoset_iff_coset" :dir rl) (("3" (expand "left_coset?") (("3" (expand "finseq_appl") (("3" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (fsA!1 skolem-const-decl "{fsA: fsI(R!1) | length(fsA) /= 0}" chinese_remainder_theorem_rings nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" chinese_remainder_theorem_rings nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (/ const-decl "setof[set[T]]" cosets_def nil) (left_coset? const-decl "bool" cosets_def nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (member const-decl "bool" sets nil)) nil (CRT_aux_1 existence "" "(cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)))"))) (CRT_aux_1_TCC3 0 (CRT_aux_1_TCC4-1 nil 3782829257 ("" (skosimp) (("" (expand "cartesian_product_n") (("" (expand "finseq_appl") (("" (expand "member") (("" (skosimp) (("" (prop) (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (hide -) (("2" (grind) nil nil)) nil) ("3" (hide -) (("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "Sfs") (("3" (expand "finseq_appl") (("3" (rewrite "coset_add") (("3" (hide 2 3) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (inst -1 "i!1") (("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (member const-decl "bool" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (Sfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (add const-decl "set[T]" cosets_def nil) (lc_gen const-decl "T" cosets_def nil) (coset_add formula-decl nil quotient_rings nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (setof type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (/ const-decl "setof[set[T]]" cosets_def nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (CRT_aux_1 subtype "cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].Sfs(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)" "[[(cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA))), (cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)))] -> (cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)))]"))) (CRT_aux_1_TCC4 0 (CRT_aux_1_TCC5-1 nil 3782829257 ("" (skosimp*) (("" (expand "cartesian_product_n") (("" (prop) (("1" (expand "fsQ") (("1" (assert) nil nil)) nil) ("2" (expand "Pfs") (("2" (assert) (("2" (expand "fsQ") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (expand "finseq_appl") (("3" (expand "member") (("3" (expand "fsQ") (("3" (assert) (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "Pfs") (("3" (expand "finseq_appl") (("3" (typepred "x1!1`1" "x1!1`2") (("3" (expand "cartesian_product_n") (("3" (assert) (("3" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (inst?) (("2" (inst?) (("2" (rewrite "coset_product") (("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (member const-decl "bool" sets nil) (/ const-decl "setof[set[T]]" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (coset_product formula-decl nil quotient_rings nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (Pfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil)) nil (CRT_aux_1 subtype "cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].Pfs(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)" "[[(cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA))), (cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)))] -> (cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)))]"))) (CRT_aux_1_TCC5 0 (CRT_aux_1_TCC6-1 nil 3794237237 ("" (skosimp) (("" (expand "cartesian_product_n") (("" (expand "finseq_appl") (("" (expand "member") (("" (typepred "fsA!1") (("" (hide -3) (("" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "fsQ") (("2" (propax) nil nil)) nil) ("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (lemma "ideal_is_coset") (("3" (inst?) (("3" (hide (2 3)) (("3" (expand "fsRI?") (("3" (inst?) (("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (member const-decl "bool" sets nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" chinese_remainder_theorem_rings nil) (fsA!1 skolem-const-decl "{fsA: fsI(R!1) | length(fsA) /= 0}" chinese_remainder_theorem_rings nil) (i!1 skolem-const-decl "below(length(fsA!1))" chinese_remainder_theorem_rings nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (/ const-decl "setof[set[T]]" cosets_def nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring? const-decl "bool" ring_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (fsRI? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (fsI type-eq-decl nil ring_ideal_def nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (CRT_aux_1 subtype "chinese_remainder_theorem_rings.fsA" "(cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)))"))) (CRT_aux_1 0 (CRT_aux_1-1 nil 3782948965 ("" (skosimp) (("" (skoletin) (("" (replaces -1) (("" (expand "R_homomorphism?") (("" (prop) (("1" (typepred "R!1") (("1" (expand "ring?") (("1" (flatten) (("1" (hide (-2 -3 -4 -5 2)) (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "R!1") (("2" (expand "ring?") (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "cartesian_product_quot_ring_is_ring") (("3" (inst?) (("3" (expand "restrict") (("3" (assert) (("3" (expand "ring?") (("3" (flatten) (("3" (hide (-2 -3 -4 -5)) (("3" (expand "abelian_group?") (("3" (flatten) (("3" (hide -2) (("3" (expand "group?") (("3" (expand "monoid?") (("3" (flatten) (("3" (hide (-2 -3)) (("3" (expand "monad?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "cartesian_product_quot_ring_is_ring") (("4" (inst?) (("4" (assert) (("4" (expand "ring?") (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ("5" (expand "homomorphism?") (("5" (skosimp) (("5" (decompose-equality 1) (("1" (expand "Sfs") (("1" (propax) nil nil)) nil) ("2" (decompose-equality 1) (("2" (expand "Sfs") (("2" (expand "finseq_appl") (("2" (rewrite "add_charac") (("2" (hide (2 3)) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (expand "Sfs") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "homomorphism?") (("6" (skosimp) (("6" (decompose-equality 1) (("1" (expand "Pfs") (("1" (propax) nil nil)) nil) ("2" (decompose-equality 1) (("2" (expand "Pfs") (("2" (expand "finseq_appl") (("2" (rewrite "product_charac") (("2" (hide (2 3)) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (expand "Pfs") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "R_kernel") (("7" (expand "Intersection") (("7" (expand "restrict") (("7" (expand "finseq_appl") (("7" (decompose-equality 1) (("1" (iff) (("1" (prop) (("1" (skosimp) (("1" (typepred "a!1") (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (skosimp) (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (decompose-equality -3) (("1" (decompose-equality -1) (("1" (inst?) (("1" (lemma "self_coset") (("1" (inst -1 "fsA!1`seq(kk!1)" "R!1" "x!1") (("1" (assert) (("1" (hide (-1 -2 -3 2)) (("1" (typepred "fsA!1") (("1" (expand "fsRI?") (("1" (expand "finseq_appl") (("1" (inst?) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst -1 "0") (("2" (inst -3 "fsA!1`seq(0)") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (flatten) (("1" (hide (-2 -3 -4)) (("1" (expand "subset?") (("1" (expand "member") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "seq2set") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "cartesian_product_n") (("3" (expand "finseq_appl") (("3" (expand "member") (("3" (prop) (("1" (expand "fsQ") (("1" (typepred "fsA!1") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "fsQ") (("2" (propax) nil nil)) nil) ("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "coset?") (("3" (hide 2) (("3" (prop) (("1" (expand "left_coset?") (("1" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (hide (-1 2)) (("2" (typepred "R!1") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "right_coset?") (("2" (inst 1 "zero") (("1" (rewrite "right_zero") nil nil) ("2" (hide (-1 2)) (("2" (typepred "R!1") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (decompose-equality 1) (("4" (decompose-equality 1) (("4" (inst -1 "fsA!1`seq(x!2)") (("1" (lemma "self_coset") (("1" (inst -1 "fsA!1`seq(x!2)" "R!1" "x!1") (("1" (assert) (("1" (typepred "fsA!1") (("1" (expand "fsRI?") (("1" (expand "finseq_appl") (("1" (inst?) (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (expand "seq2set") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "cartesian_product_n") (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (hide (-1 -2 2)) (("2" (skosimp) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (expand "coset?") (("2" (lemma "lcoset_iff_rcoset") (("2" (inst?) (("2" (prop) (("1" (hide (2 3 4)) (("1" (expand "left_coset?") (("1" (inst?) nil nil)) nil)) nil) ("2" (hide (1 2 4)) (("2" (expand "left_coset?") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (+ const-decl "set[T]" cosets_def nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (setof type-eq-decl nil defined_types nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (restrict const-decl "R" restrict nil) (Sfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (Pfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (seq2set const-decl "finite_set[T]" seq2set structures) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (Intersection const-decl "set" sets nil) (setofsets type-eq-decl nil sets nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (below type-eq-decl nil naturalnumbers nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (member const-decl "bool" sets nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subring? const-decl "bool" ring_def nil) (subset? const-decl "bool" sets nil) (/ const-decl "setof[set[T]]" cosets_def nil) (right_coset? const-decl "bool" cosets_def nil) (right_zero formula-decl nil ring_cosets_lemmas nil) (left_coset? const-decl "bool" cosets_def nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (coset? const-decl "bool" cosets_def nil) (x!2 skolem-const-decl "below[length(fsA!1)]" chinese_remainder_theorem_rings nil) (b!1 skolem-const-decl "(R!1)" chinese_remainder_theorem_rings nil) (a!1 skolem-const-decl "(R!1)" chinese_remainder_theorem_rings nil) (product_charac formula-decl nil quotient_rings nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (b!1 skolem-const-decl "(R!1)" chinese_remainder_theorem_rings nil) (a!1 skolem-const-decl "(R!1)" chinese_remainder_theorem_rings nil) (fsA!1 skolem-const-decl "{fsA: fsI(R!1) | length(fsA) /= 0}" chinese_remainder_theorem_rings nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" chinese_remainder_theorem_rings nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (add_charac formula-decl nil quotient_rings nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cartesian_product_quot_ring_is_ring formula-decl nil cartesian_product_quot_ring nil) (NOT const-decl "[bool -> bool]" booleans nil) (abelian_group? const-decl "bool" group_def nil) (monoid? const-decl "bool" monoid_def nil) (monad? const-decl "bool" monad_def nil) (group? const-decl "bool" group_def nil)) shostak)) (CRT_aux_2_TCC1 0 (CRT_aux_2_TCC1-1 nil 3782949509 ("" (skosimp*) (("" (lemma "CRT_aux_1_TCC1") (("" (inst?) (("1" (assert) (("1" (inst?) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((CRT_aux_1_TCC1 subtype-tcc nil chinese_remainder_theorem_rings nil) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (fsI type-eq-decl nil ring_ideal_def nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring? const-decl "bool" ring_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (fsRI? const-decl "bool" ring_ideal_def nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (R!1 skolem-const-decl "ring_with_one[T, +, *, zero, one]" chinese_remainder_theorem_rings nil) (ring nonempty-type-eq-decl nil ring nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (fsA!1 skolem-const-decl "{fsA: fsICM(R!1) | length(fsA) /= 0}" chinese_remainder_theorem_rings nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (CRT_aux_2 subtype "chinese_remainder_theorem_rings.phi" "[(chinese_remainder_theorem_rings.R) -> (cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)))]"))) (CRT_aux_2 0 (CRT_aux_2-2 nil 3785234520 ("" (skosimp) (("" (assert) (("" (expand "surjective?") (("" (skosimp) (("" (typepred "y!1") (("" (case "length(fsA!1) = 0") (("1" (expand "cartesian_product_n") (("1" (grind) nil nil)) nil) ("2" (lemma "surjective_aux_2") (("2" (expand "finseq_appl") (("2" (inst -1 "y!1" "R!1" "fsA!1") (("2" (expand "member") (("2" (skosimp) (("2" (inst 2 "R_sigma_below[T, +, *, zero, length(fsA!1)]
                  (0, length(fsA!1) - 1,
                   LAMBDA (i_1: below[length(fsA!1)]):
                     s!1`seq(i_1) * r!1`seq(i_1))") (("1" (decompose-equality 2) (("1" (hide -1) (("1" (expand "cartesian_product_n") (("1" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (expand "fsQ") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (inst?) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -) (("2" (skosimp) (("2" (rewrite "fullset_is_ring") nil nil)) nil)) nil)) nil) ("3" (hide -1) (("3" (skosimp) (("3" (expand "cartesian_product_n") (("3" (expand "fsQ") (("3" (flatten) (("3" (hide -2) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skosimp) (("4" (rewrite "fullset_is_ring") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (lemma "R_sigma_b_in_ideal[T, +, *, zero, length(fsA!1)]") (("1" (inst?) (("1" (inst -1 "R!1" "R!1") (("1" (assert) (("1" (prop) (("1" (hide 2) (("1" (rewrite "self_ideal") nil nil)) nil) ("2" (hide 2) (("2" (skosimp) (("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (flatten) (("2" (hide (-1 -3 -4 -5)) (("2" (expand "star_closed?") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "fullset_is_ring") nil nil)) nil) ("3" (hide 2) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (hide -) (("3" (rewrite "fullset_is_ring") nil nil)) nil) ("4" (hide -) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (member const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (R!1 skolem-const-decl "ring_with_one[T, +, *, zero, one]" chinese_remainder_theorem_rings nil) (fsA!1 skolem-const-decl "{fsA: fsICM(R!1) | length(fsA) /= 0}" chinese_remainder_theorem_rings nil) (fullset const-decl "set" sets nil) (r!1 skolem-const-decl "{r: finseq[(R!1)] | length(r) = length(fsA!1)}" chinese_remainder_theorem_rings nil) (s!1 skolem-const-decl "{s: finseq[(R!1)] | length(s) = length(fsA!1)}" chinese_remainder_theorem_rings nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (R_sigma_below def-decl "T" sigma_R_below nil) (int_below_N type-eq-decl nil sigma_R_below nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (fullset_is_ring formula-decl nil cartesian_product_quot_ring nil) (emptyset const-decl "set" sets nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (y!1 skolem-const-decl "(cartesian_product_n[set[T]](fsQ(R!1)(fsA!1)))" chinese_remainder_theorem_rings nil) (+ const-decl "set[T]" cosets_def nil) (R_sigma_b_in_ideal formula-decl nil sigma_R_below nil) (self_ideal formula-decl nil ring_ideal nil) (monad? const-decl "bool" monad_def nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (subrange type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (star_closed? const-decl "bool" groupoid_def nil) (monoid? const-decl "bool" monoid_def nil) (surjective_aux_2 formula-decl nil chinese_remainder_theorem_rings nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (surjective? const-decl "bool" functions nil)) nil) (CRT_aux_2-1 nil 3782949166 ("" (skosimp) (("" (assert) (("" (expand "surjective?") (("" (skosimp) (("" (typepred "y!1") (("" (lemma "surjective_aux_2") (("" (expand "finseq_appl") (("" (inst -1 "y!1" "R!1" "fsA!1") (("" (expand "member") (("" (skosimp) (("" (inst 1 "R_sigma_below[T, +, *, zero, length(fsA!1)]
              (0, length(fsA!1) - 1,
               LAMBDA (i_1: below[length(fsA!1)]):
                 s!1`seq(i_1) * r!1`seq(i_1))") (("1" (decompose-equality 1) (("1" (hide -1) (("1" (expand "cartesian_product_n") (("1" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (expand "fsQ") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (inst?) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -) (("2" (skosimp) (("2" (rewrite "fullset_is_ring") nil nil)) nil)) nil)) nil) ("3" (hide -1) (("3" (skosimp) (("3" (expand "cartesian_product_n") (("3" (expand "fsQ") (("3" (flatten) (("3" (hide -2) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skosimp) (("4" (rewrite "fullset_is_ring") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "R_sigma_b_in_ideal[T, +, *, zero, length(fsA!1)]") (("1" (inst?) (("1" (inst -1 "R!1" "R!1") (("1" (assert) (("1" (prop) (("1" (hide 2) (("1" (rewrite "self_ideal") nil nil)) nil) ("2" (hide 2) (("2" (skosimp) (("2" (typepred "R!1") (("2" (expand "commutative_ring_with_one?") (("2" (expand "ring_with_one?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (flatten) (("2" (hide (-1 -3 -4 -5 -6)) (("2" (expand "star_closed?") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "fullset_is_ring") nil nil)) nil) ("3" (hide 2) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (hide -) (("3" (rewrite "fullset_is_ring") nil nil)) nil) ("4" (hide -) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((surjective_aux_2 formula-decl nil chinese_remainder_theorem_rings nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (monad? const-decl "bool" monad_def nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (subrange type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (star_closed? const-decl "bool" groupoid_def nil) (monoid? const-decl "bool" monoid_def nil) (self_ideal formula-decl nil ring_ideal nil) (R_sigma_b_in_ideal formula-decl nil sigma_R_below nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (emptyset const-decl "set" sets nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (int_below_N type-eq-decl nil sigma_R_below nil) (R_sigma_below def-decl "T" sigma_R_below nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (fullset const-decl "set" sets nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (setof type-eq-decl nil defined_types nil) (commutative_ring_with_one? const-decl "bool" ring_with_one_def nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (surjective? const-decl "bool" functions nil)) shostak)) (Chinese_Remainder_Theorem_TCC1 0 (Chinese_Remainder_Theorem_TCC2-1 nil 3782829257 ("" (skosimp) (("" (typepred "fsA!1") (("" (prop) (("" (inst 2 "Intersection[T](seq2set[set[T]](fsA!1))") (("" (rewrite "ideal_is_coset") (("" (hide 2) (("" (lemma "Intersection_of_ideals_is_ideal") (("" (inst?) (("" (expand "fsICM?") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (set type-eq-decl nil sets nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (coset? const-decl "bool" cosets_def nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (Intersection const-decl "set" sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (coset type-eq-decl nil cosets_def nil) (fsA!1 skolem-const-decl "{fsA: fsICM(R!1) | length(fsA) /= 0}" chinese_remainder_theorem_rings nil) (R!1 skolem-const-decl "ring_with_one[T, +, *, zero, one]" chinese_remainder_theorem_rings nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (fsI type-eq-decl nil ring_ideal_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (Intersection_of_ideals_is_ideal formula-decl nil product_finseq_sets_ring nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil)) nil (Chinese_Remainder_Theorem existence "" "coset[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+](chinese_remainder_theorem_rings.R, sets[chinese_remainder_theorem_rings.T].Intersection(seq2set[set[T]].seq2set(chinese_remainder_theorem_rings.fsA)))"))) (Chinese_Remainder_Theorem_TCC2 0 (Chinese_Remainder_Theorem_TCC3-1 nil 3782829257 ("" (skosimp*) (("" (lemma "coset_add") (("" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "Intersection_of_ideals_is_ideal") (("2" (inst?) (("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (coset_add formula-decl nil quotient_rings nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (fsI type-eq-decl nil ring_ideal_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (Intersection_of_ideals_is_ideal formula-decl nil product_finseq_sets_ring nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (Intersection const-decl "set" sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finite_sequence type-eq-decl nil finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (finseq type-eq-decl nil finite_sequences nil) (ring nonempty-type-eq-decl nil ring nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (R!1 skolem-const-decl "ring_with_one[T, +, *, zero, one]" chinese_remainder_theorem_rings nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (fsA!1 skolem-const-decl "{fsA: fsICM(R!1) | length(fsA) /= 0}" chinese_remainder_theorem_rings nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)) nil (Chinese_Remainder_Theorem subtype "cosets_def[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+].add(chinese_remainder_theorem_rings.R, sets[chinese_remainder_theorem_rings.T].Intersection(seq2set[set[T]].seq2set(chinese_remainder_theorem_rings.fsA)))" "[[coset[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+](chinese_remainder_theorem_rings.R, sets[chinese_remainder_theorem_rings.T].Intersection(seq2set[set[T]].seq2set(chinese_remainder_theorem_rings.fsA))), coset[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+](chinese_remainder_theorem_rings.R, sets[chinese_remainder_theorem_rings.T].Intersection(seq2set[set[T]].seq2set(chinese_remainder_theorem_rings.fsA)))] -> coset[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+](chinese_remainder_theorem_rings.R, sets[chinese_remainder_theorem_rings.T].Intersection(seq2set[set[T]].seq2set(chinese_remainder_theorem_rings.fsA)))]"))) (Chinese_Remainder_Theorem_TCC3 0 (Chinese_Remainder_Theorem_TCC4-1 nil 3782829257 ("" (skosimp*) (("" (lemma "coset_product") (("" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "Intersection_of_ideals_is_ideal") (("2" (inst?) (("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (coset_product formula-decl nil quotient_rings nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (fsI type-eq-decl nil ring_ideal_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (Intersection_of_ideals_is_ideal formula-decl nil product_finseq_sets_ring nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (Intersection const-decl "set" sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finite_sequence type-eq-decl nil finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (finseq type-eq-decl nil finite_sequences nil) (ring nonempty-type-eq-decl nil ring nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (R!1 skolem-const-decl "ring_with_one[T, +, *, zero, one]" chinese_remainder_theorem_rings nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (fsA!1 skolem-const-decl "{fsA: fsICM(R!1) | length(fsA) /= 0}" chinese_remainder_theorem_rings nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)) nil (Chinese_Remainder_Theorem subtype "product_coset_def[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*].product(chinese_remainder_theorem_rings.R, sets[chinese_remainder_theorem_rings.T].Intersection(seq2set[set[T]].seq2set(chinese_remainder_theorem_rings.fsA)))" "[[coset[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+](chinese_remainder_theorem_rings.R, sets[chinese_remainder_theorem_rings.T].Intersection(seq2set[set[T]].seq2set(chinese_remainder_theorem_rings.fsA))), coset[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+](chinese_remainder_theorem_rings.R, sets[chinese_remainder_theorem_rings.T].Intersection(seq2set[set[T]].seq2set(chinese_remainder_theorem_rings.fsA)))] -> coset[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+](chinese_remainder_theorem_rings.R, sets[chinese_remainder_theorem_rings.T].Intersection(seq2set[set[T]].seq2set(chinese_remainder_theorem_rings.fsA)))]"))) (Chinese_Remainder_Theorem_TCC4 0 (Chinese_Remainder_Theorem_TCC5-1 nil 3782829257 ("" (skosimp*) (("" (rewrite "lcoset_iff_coset" :dir rl) (("" (expand "left_coset?") (("" (inst 1 "zero") (("1" (assert) (("1" (rewrite "left_zero") nil nil)) nil) ("2" (typepred "R!1") (("2" (expand "ring_with_one?") (("2" (flatten) (("2" (lemma "zero_is_member_R") (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (Intersection const-decl "set" sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finite_sequence type-eq-decl nil finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (finseq type-eq-decl nil finite_sequences nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (R!1 skolem-const-decl "ring_with_one[T, +, *, zero, one]" chinese_remainder_theorem_rings nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (left_coset? const-decl "bool" cosets_def nil)) nil (Chinese_Remainder_Theorem subtype "sets[chinese_remainder_theorem_rings.T].Intersection(seq2set[set[T]].seq2set(chinese_remainder_theorem_rings.fsA))" "coset[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+](chinese_remainder_theorem_rings.R, sets[chinese_remainder_theorem_rings.T].Intersection(seq2set[set[T]].seq2set(chinese_remainder_theorem_rings.fsA)))"))) (Chinese_Remainder_Theorem_TCC5 0 (Chinese_Remainder_Theorem_TCC6-1 nil 3782829257 ("" (skosimp) (("" (inst 1 "fsA!1") (("" (expand "cartesian_product_n") (("" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skosimp) (("3" (expand "member") (("3" (expand "finseq_appl") (("3" (expand "fsQ") (("3" (expand "/") (("3" (rewrite "lcoset_iff_coset" :dir rl) (("3" (expand "left_coset?") (("3" (expand "finseq_appl") (("3" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R") (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (fsA!1 skolem-const-decl "{fsA: fsICM(R!1) | length(fsA) /= 0}" chinese_remainder_theorem_rings nil) (R!1 skolem-const-decl "ring_with_one[T, +, *, zero, one]" chinese_remainder_theorem_rings nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (member const-decl "bool" sets nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (left_coset? const-decl "bool" cosets_def nil) (/ const-decl "setof[set[T]]" cosets_def nil)) nil (Chinese_Remainder_Theorem existence "" "(cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)))"))) (Chinese_Remainder_Theorem_TCC6 0 (Chinese_Remainder_Theorem_TCC7-1 nil 3782829257 ("" (skosimp*) (("" (typepred "fsA!1") (("" (expand "cartesian_product_n") (("" (expand "finseq_appl") (("" (expand "member") (("" (assert) (("" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "Sfs") (("3" (expand "finseq_appl") (("3" (rewrite "coset_add") (("3" (hide (2 3)) (("3" (expand "fsICM?") (("3" (flatten) (("3" (hide -2) (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (set type-eq-decl nil sets nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (coset_add formula-decl nil quotient_rings nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (fsI type-eq-decl nil ring_ideal_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (/ const-decl "setof[set[T]]" cosets_def nil) (lc_gen const-decl "T" cosets_def nil) (add const-decl "set[T]" cosets_def nil) (Sfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (member const-decl "bool" sets nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil)) nil (Chinese_Remainder_Theorem subtype "cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].Sfs(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)" "[[(cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA))), (cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)))] -> (cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)))]"))) (Chinese_Remainder_Theorem_TCC7 0 (Chinese_Remainder_Theorem_TCC8-1 nil 3782829257 ("" (skosimp*) (("" (typepred "fsA!1") (("" (expand "cartesian_product_n") (("" (expand "finseq_appl") (("" (expand "member") (("" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "Pfs") (("3" (expand "finseq_appl") (("3" (rewrite "coset_product") (("3" (hide (2 3)) (("3" (expand "fsICM?") (("3" (flatten) (("3" (hide -2) (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (set type-eq-decl nil sets nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (Pfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (product const-decl "set[T]" product_coset_def nil) (lproduct const-decl "set[T]" product_coset_def nil) (lc_gen const-decl "T" cosets_def nil) (/ const-decl "setof[set[T]]" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (below type-eq-decl nil naturalnumbers nil) (setof type-eq-decl nil defined_types nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (coset_product formula-decl nil quotient_rings nil) (member const-decl "bool" sets nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil)) nil (Chinese_Remainder_Theorem subtype "cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].Pfs(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)" "[[(cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA))), (cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)))] -> (cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)))]"))) (Chinese_Remainder_Theorem_TCC8 0 (Chinese_Remainder_Theorem_TCC9-1 nil 3794237237 ("" (skosimp) (("" (expand "cartesian_product_n") (("" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skosimp) (("3" (expand "member") (("3" (expand "finseq_appl") (("3" (expand "fsQ") (("3" (expand "/") (("3" (expand "finseq_appl") (("3" (rewrite "lcoset_iff_coset" :dir rl) (("3" (expand "left_coset?") (("3" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R") (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (/ const-decl "setof[set[T]]" cosets_def nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (R!1 skolem-const-decl "ring_with_one[T, +, *, zero, one]" chinese_remainder_theorem_rings nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (left_coset? const-decl "bool" cosets_def nil) (member const-decl "bool" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (Chinese_Remainder_Theorem subtype "chinese_remainder_theorem_rings.fsA" "(cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero].fsQ(chinese_remainder_theorem_rings.R)(chinese_remainder_theorem_rings.fsA)))"))) (Chinese_Remainder_Theorem 0 (Chinese_Remainder_Theorem-4 "" 3883083264 ("" (skosimp) (("" (typepred "fsA!1") (("" (prop) (("" (lemma "CRT_aux_1") (("" (inst -1 "R!1" "fsA!1") (("" (assert) (("" (lemma "CRT_aux_2") (("" (inst -1 "R!1" "fsA!1") (("" (assert) (("" (expand "finseq_appl") (("" (name-replace "phi!1" "LAMBDA (x: (R!1)):
                        (# length := length(fsA!1),
                           seq
                             := LAMBDA (i: below[length(fsA!1)]):
                                  x + fsA!1`seq(i) #)") (("" (flatten) (("" (lemma "first_isomorphism_th[T,+,*,zero,
             	      (cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))), Sfs(R!1)(fsA!1),
                        Pfs(R!1)(fsA!1), fsA!1]") (("1" (inst -1 "R!1" "cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))" "phi!1") (("1" (expand "R_isomorphic?") (("1" (assert) (("1" (skosimp) (("1" (inst?) (("1" (expand "restrict") (("1" (assert) (("1" (expand "R_isomorphism?") (("1" (prop) (("1" (hide (-2 -3)) (("1" (expand "R_monomorphism?") (("1" (prop) (("1" (hide (-2 -3 -4 2)) (("1" (expand "injective?") (("1" (skosimp) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "R_homomorphism?") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-2 -14 +)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (assert) (("1" (inst -1 "x!1" "y!1") (("1" (expand "restrict") (("1" (replace -2 -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -14 +)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("2" (replace -2 -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-6 -14 +)) (("3" (expand "homomorphism?") (("3" (assert) (("3" (skosimp) (("3" (inst -1 "a!1" "b!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-7 -14 +)) (("4" (expand "homomorphism?") (("4" (assert) (("4" (skosimp) (("4" (inst -1 "a!1" "b!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "R_epimorphism?") (("2" (prop) (("1" (hide (-2 2)) (("1" (expand "surjective?") (("1" (skosimp) (("1" (inst -1 "y!1") (("1" (skosimp) (("1" (inst?) nil nil)) nil) ("2" (expand "extend") (("2" (hide (-2 -3 2)) (("2" (expand "image") (("2" (expand "image") (("2" (inst -1 "y!1") (("2" (skosimp) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (expand "R_homomorphism?") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-2 -9 +)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (assert) (("1" (inst -1 "x!1" "y!1") (("1" (expand "restrict") (("1" (replace -2 -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -9 +)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("2" (replace -2 -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (lemma "cartesian_product_quot_ring_is_ring") (("3" (expand "restrict") (("3" (inst?) (("1" (assert) (("1" (expand "ring?") (("1" (flatten) (("1" (assert) (("1" (hide-all-but (-1 1 2)) (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 2)) (("4" (lemma "cartesian_product_quot_ring_is_ring") (("4" (inst -1 "R!1" "fsA!1") (("1" (assert) (("1" (expand "ring?") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsICM?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-6 -9 +)) (("5" (expand "homomorphism?") (("5" (assert) (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-7 -9 +)) (("6" (expand "homomorphism?") (("6" (assert) (("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (skosimp) (("2" (prop) (("1" (hide (-2 -3 -4 -5 2)) (("1" (replaces -2) nil nil)) nil) ("2" (expand "/") (("2" (hide (-2 -3 -4 -5 2)) (("2" (replaces -2) nil nil)) nil)) nil) ("3" (assert) nil nil) ("4" (expand "/") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 3)) (("2" (expand "restrict") (("2" (lemma "cartesian_product_quot_ring_is_ring") (("2" (expand "restrict") (("2" (inst?) (("1" (assert) nil nil) ("2" (expand "fsICM?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1 2)) (("2" (lemma "cartesian_product_quot_ring_is_ring") (("2" (expand "restrict") (("2" (inst?) (("2" (inst -1 "fsA!1") (("1" (assert) (("1" (expand "ring?") (("1" (flatten) (("1" (split) (("1" (hide-all-but (-1 -6 1 2)) (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (split) (("1" (hide-all-but (-1 1 2)) (("1" (expand "star_closed?") (("1" (skeep) (("1" (inst?) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil) ("3" (hide-all-but (-3 1 2)) (("3" (expand "identity?") (("3" (expand "restrict") (("3" (skeep) (("3" (inst -1 "x") nil nil)) nil)) nil)) nil)) nil) ("4" (expand "associative?") (("4" (skeep) (("4" (expand "restrict") (("4" (inst?) nil nil)) nil)) nil)) nil) ("5" (expand "inv_exists?") (("5" (skeep) (("5" (inst -5 "x") (("5" (skeep) (("5" (inst 1 "y") (("1" (assert) nil nil) ("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "commutative?") (("6" (skeep) (("6" (expand "restrict") (("6" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 2)) (("2" (expand "star_closed?") (("2" (skeep) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1 2)) (("3" (expand "associative?") (("3" (skeep) (("3" (expand "restrict") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1 2)) (("4" (expand "left_distributive?") (("4" (skeep) (("4" (expand "restrict") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-5 1 2)) (("5" (expand "right_distributive?") (("5" (skeep) (("5" (expand "restrict") (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "fsICM?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "fullset_is_ring") nil nil) ("4" (hide-all-but (1 2 -4)) (("4" (expand "cartesian_product_n") (("4" (expand "finseq_appl") (("4" (expand "member") (("4" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (lemma "ideal_is_coset") (("3" (inst?) (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (flatten) (("3" (hide -2) (("3" (inst?) (("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide (-1 -2 -3 3)) (("5" (skosimp) (("5" (expand "cartesian_product_n") (("5" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "Pfs") (("2" (expand "fsQ") (("2" (propax) nil nil)) nil)) nil) ("3" (skosimp) (("3" (expand "finseq_appl") (("3" (expand "member") (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (lemma "coset_product") (("3" (inst -1 "R!1" "fsA!1`seq(i!1)" "x1!1`1`seq(i!1)" "x1!1`2`seq(i!1)") (("1" (expand "Pfs") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil) ("2" (hide (2 3)) (("2" (typepred "x1!1`2") (("2" (expand "cartesian_product_n") (("2" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (inst?) (("2" (expand "member") (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "i!1" "x1!1`2") (("3" (expand "cartesian_product_n") (("3" (expand "Pfs") (("3" (expand "fsQ") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "x1!1`1") (("4" (expand "cartesian_product_n") (("4" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (inst?) (("2" (expand "member") (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (typepred "i!1" "x1!1`1") (("5" (expand "cartesian_product_n") (("5" (expand "Pfs") (("5" (expand "fsQ") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide (2 3)) (("6" (expand "fsICM?") (("6" (prop) (("6" (hide -2) (("6" (expand "fsRI?") (("6" (expand "finseq_appl") (("6" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide (-1 -2 -3 3)) (("6" (skosimp) (("6" (expand "cartesian_product_n") (("6" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "Sfs") (("2" (expand "fsQ") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (expand "member") (("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "Sfs") (("3" (expand "finseq_appl") (("3" (lemma "coset_add") (("3" (inst?) (("3" (hide (2 3)) (("3" (expand "fsICM?") (("3" (prop) (("3" (hide -2) (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (inst 1 "fsA!1") (("7" (expand "cartesian_product_n") (("7" (hide 2 3) (("7" (prop) (("1" (hide -2 -3 -4) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (skosimp) (("3" (expand "member") (("3" (expand "finseq_appl") (("3" (expand "fsQ") (("3" (expand "/") (("3" (expand "finseq_appl") (("3" (rewrite "lcoset_iff_coset" :dir rl) (("3" (expand "left_coset?") (("3" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R") (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (Chinese_Remainder_Theorem-3 nil 3785233558 ("" (skosimp) (("" (typepred "fsA!1") (("" (prop) (("" (lemma "CRT_aux_1") (("" (inst -1 "R!1" "fsA!1") (("" (assert) (("" (lemma "CRT_aux_2") (("" (inst -1 "R!1" "fsA!1") (("" (assert) (("" (expand "finseq_appl") (("" (name-replace "phi!1" "LAMBDA (x: (R!1)):
                        (# length := length(fsA!1),
                           seq
                             := LAMBDA (i: below[length(fsA!1)]):
                                  x + fsA!1`seq(i) #)") (("" (flatten) (("" (lemma "first_isomorphism_th[T,+,*,zero,
             	      (cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))), Sfs(R!1)(fsA!1),
                        Pfs(R!1)(fsA!1), fsA!1]") (("1" (inst -1 "R!1" "cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))" "phi!1") (("1" (expand "R_isomorphic?") (("1" (assert) (("1" (skosimp) (("1" (inst?) (("1" (assert) (("1" (expand "R_isomorphism?") (("1" (prop) (("1" (hide (-2 -3)) (("1" (expand "R_monomorphism?") (("1" (prop) (("1" (hide (-2 -3 -4 2)) (("1" (expand "injective?") (("1" (skosimp) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "R_homomorphism?") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-2 -14 +)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (assert) (("1" (inst -1 "x!1" "y!1") (("1" (expand "restrict") (("1" (replace -2 -1) (("1" (propax) nil nil)) nil)) nil) ("2" (expand "restrict") (("2" (typepred "y!1") (("2" (expand "restrict") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "restrict") (("3" (typepred "x!1") (("3" (expand "restrict") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -14 +)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("1" (replace -2 -1) (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (typepred "y!1") (("2" (expand "restrict") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "restrict") (("3" (typepred "x!1") (("3" (expand "restrict") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-6 -14 +)) (("3" (expand "homomorphism?") (("3" (assert) (("3" (skosimp) (("3" (inst -1 "a!1" "b!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-7 -14 +)) (("4" (expand "homomorphism?") (("4" (assert) (("4" (skosimp) (("4" (inst -1 "a!1" "b!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "R_epimorphism?") (("2" (prop) (("1" (hide (-2 2)) (("1" (expand "surjective?") (("1" (skosimp) (("1" (inst -1 "y!1") (("1" (skosimp) (("1" (inst?) (("1" (expand "restrict") (("1" (expand "/") (("1" (hide -1) (("1" (typepred "x!1") (("1" (hide -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -3 2)) (("2" (expand "extend") (("2" (expand "image") (("2" (expand "image") (("2" (inst -1 "y!1") (("2" (skosimp) (("2" (inst?) (("1" (assert) nil nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (expand "R_homomorphism?") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-2 -9 +)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (assert) (("1" (inst -1 "x!1" "y!1") (("1" (expand "restrict") (("1" (replace -2 -1) (("1" (propax) nil nil)) nil)) nil) ("2" (expand "restrict") (("2" (typepred "y!1") (("2" (expand "restrict") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "restrict") (("3" (typepred "x!1") (("3" (expand "restrict") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -9 +)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("1" (replace -2 -1) (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (typepred "y!1") (("2" (expand "restrict") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "restrict") (("3" (typepred "x!1") (("3" (expand "restrict") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (lemma "cartesian_product_quot_ring_is_ring") (("3" (inst?) (("3" (assert) (("3" (expand "ring?") (("3" (flatten) (("3" (assert) (("3" (hide-all-but (-1 1 2)) (("3" (expand "abelian_group?") (("3" (expand "group?") (("3" (expand "monoid?") (("3" (expand "monad?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 2)) (("4" (lemma "cartesian_product_quot_ring_is_ring") (("4" (inst -1 "R!1" "fsA!1") (("4" (assert) (("4" (expand "ring?") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-6 -9 +)) (("5" (expand "homomorphism?") (("5" (assert) (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-7 -9 +)) (("6" (expand "homomorphism?") (("6" (assert) (("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (prop) (("1" (hide (-2 -3 -4 -5 2)) (("1" (replaces -2) nil nil)) nil) ("2" (expand "restrict") (("2" (expand "/") (("2" (hide (-2 -3 -4 -5 2)) (("2" (replaces -2) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (expand "restrict") (("4" (expand "/") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 3)) (("2" (lemma "cartesian_product_quot_ring_is_ring") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1 2)) (("2" (lemma "cartesian_product_quot_ring_is_ring") (("2" (inst?) (("2" (inst -1 "fsA!1") (("1" (assert) (("1" (expand "ring?") (("1" (flatten) (("1" (split) (("1" (hide-all-but (-1 -6 1 2)) (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (split) (("1" (hide-all-but (-1 1 2)) (("1" (expand "star_closed?") (("1" (skeep) (("1" (inst?) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil) ("3" (hide-all-but (-3 1 2)) (("3" (expand "identity?") (("3" (skeep) (("3" (expand "restrict") (("3" (inst -1 "x") nil nil)) nil)) nil)) nil)) nil) ("4" (expand "associative?") (("4" (skeep) (("4" (expand "restrict") (("4" (inst?) nil nil)) nil)) nil)) nil) ("5" (expand "inv_exists?") (("5" (skeep) (("5" (inst -5 "x") (("5" (skeep) (("5" (inst 1 "y") (("1" (assert) nil nil) ("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "commutative?") (("6" (skeep) (("6" (expand "restrict") (("6" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 2)) (("2" (expand "star_closed?") (("2" (skeep) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1 2)) (("3" (expand "associative?") (("3" (skeep) (("3" (expand "restrict") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1 2)) (("4" (expand "left_distributive?") (("4" (skeep) (("4" (expand "restrict") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-5 1 2)) (("5" (expand "right_distributive?") (("5" (skeep) (("5" (expand "restrict") (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "fsICM?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "fullset_is_ring") nil nil) ("4" (hide-all-but (1 2 -4)) (("4" (expand "cartesian_product_n") (("4" (expand "finseq_appl") (("4" (expand "member") (("4" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (lemma "ideal_is_coset") (("3" (inst?) (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (flatten) (("3" (hide -2) (("3" (inst?) (("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide (-1 -2 -3 3)) (("5" (skosimp) (("5" (expand "cartesian_product_n") (("5" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "Pfs") (("2" (expand "fsQ") (("2" (propax) nil nil)) nil)) nil) ("3" (skosimp) (("3" (expand "finseq_appl") (("3" (expand "member") (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (lemma "coset_product") (("3" (inst -1 "R!1" "fsA!1`seq(i!1)" "x1!1`1`seq(i!1)" "x1!1`2`seq(i!1)") (("1" (expand "Pfs") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil) ("2" (hide (2 3)) (("2" (typepred "x1!1`2") (("2" (expand "cartesian_product_n") (("2" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (inst?) (("2" (expand "member") (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "i!1" "x1!1`2") (("3" (expand "cartesian_product_n") (("3" (expand "Pfs") (("3" (expand "fsQ") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "x1!1`1") (("4" (expand "cartesian_product_n") (("4" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (inst?) (("2" (expand "member") (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (typepred "i!1" "x1!1`1") (("5" (expand "cartesian_product_n") (("5" (expand "Pfs") (("5" (expand "fsQ") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide (2 3)) (("6" (expand "fsICM?") (("6" (prop) (("6" (hide -2) (("6" (expand "fsRI?") (("6" (expand "finseq_appl") (("6" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide (-1 -2 -3 3)) (("6" (skosimp) (("6" (expand "cartesian_product_n") (("6" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "Sfs") (("2" (expand "fsQ") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (expand "member") (("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "Sfs") (("3" (expand "finseq_appl") (("3" (lemma "coset_add") (("3" (inst?) (("3" (hide (2 3)) (("3" (expand "fsICM?") (("3" (prop) (("3" (hide -2) (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (inst 1 "fsA!1") (("7" (expand "cartesian_product_n") (("7" (hide 2 3) (("7" (prop) (("1" (hide -2 -3 -4) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (skosimp) (("3" (expand "member") (("3" (expand "finseq_appl") (("3" (expand "fsQ") (("3" (expand "/") (("3" (expand "finseq_appl") (("3" (rewrite "lcoset_iff_coset" :dir rl) (("3" (expand "left_coset?") (("3" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R") (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (set type-eq-decl nil sets nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (CRT_aux_1 formula-decl nil chinese_remainder_theorem_rings nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (left_coset? const-decl "bool" cosets_def nil) (coset_add formula-decl nil quotient_rings nil) (i!1 skolem-const-decl "below(length(Sfs[T, +, *, zero](R!1)(fsA!1)(x1!1)))" chinese_remainder_theorem_rings nil) (x1!1 skolem-const-decl "[(cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))),
 (cartesian_product_n[set[T]](fsQ(R!1)(fsA!1)))]" chinese_remainder_theorem_rings nil) (coset_product formula-decl nil quotient_rings nil) (i!1 skolem-const-decl "below(length(Pfs[T, +, *, zero](R!1)(fsA!1)(x1!1)))" chinese_remainder_theorem_rings nil) (x1!1 skolem-const-decl "[(cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))),
 (cartesian_product_n[set[T]](fsQ(R!1)(fsA!1)))]" chinese_remainder_theorem_rings nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (i!1 skolem-const-decl "below(length(fsA!1))" chinese_remainder_theorem_rings nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (fullset_is_ring formula-decl nil cartesian_product_quot_ring nil) (commutative? const-decl "bool" operator_defs nil) (inv_exists? const-decl "bool" group_def nil) (y skolem-const-decl "(cartesian_product_n[set[T]](fsQ(R!1)(fsA!1)))" chinese_remainder_theorem_rings nil) (associative? const-decl "bool" operator_defs nil) (identity? const-decl "bool" operator_defs nil) (lc_gen const-decl "T" cosets_def nil) (add const-decl "set[T]" cosets_def nil) (product const-decl "set[T]" product_coset_def nil) (lproduct const-decl "set[T]" product_coset_def nil) (left_distributive? const-decl "bool" operator_defs_more nil) (right_distributive? const-decl "bool" operator_defs_more nil) (R!1 skolem-const-decl "ring_with_one[T, +, *, zero, one]" chinese_remainder_theorem_rings nil) (fsA!1 skolem-const-decl "{fsA: fsICM(R!1) | length(fsA) /= 0}" chinese_remainder_theorem_rings nil) (restrict const-decl "R" restrict nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (phi!2 skolem-const-decl "[(restrict
      [set[T],
       coset[T, +](R!1,
                   R_kernel(R!1,
                            restrict
                                [finseq[set[T]],
                                 (cartesian_product_n[set[T]]
                                      (fsQ[T, +, *, zero](R!1)(fsA!1))),
                                 bool]
                                (cartesian_product_n[set[T]]
                                     (fsQ(R!1)(fsA!1))))
                           (phi!1)),
       bool]
      (R!1 /
        R_kernel(R!1,
                 restrict
                     [finseq[set[T]],
                      (cartesian_product_n[set[T]]
                           (fsQ[T, +, *, zero](R!1)(fsA!1))),
                      bool]
                     (cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))))
                (phi!1))) ->
   (extend
        [(cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))),
         (restrict
              [finseq[set[T]],
               (cartesian_product_n[set[T]]
                    (fsQ[T, +, *, zero](R!1)(fsA!1))),
               bool]
              (cartesian_product_n[set[T]](fsQ(R!1)(fsA!1)))),
         bool, FALSE]
        (image(phi!1)(restrict[T, (R!1), bool](R!1))))]" chinese_remainder_theorem_rings nil) (image const-decl "set[R]" function_image nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (seq2set const-decl "finite_set[T]" seq2set structures) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (Intersection const-decl "set" sets nil) (setofsets type-eq-decl nil sets nil) (/ const-decl "setof[set[T]]" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (phi!1 skolem-const-decl "[(R!1) -> [# length: nat, seq: [below[length(fsA!1)] -> set[T]] #]]" chinese_remainder_theorem_rings nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (coset? const-decl "bool" cosets_def nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil) (star_closed? const-decl "bool" groupoid_def nil) (member const-decl "bool" sets nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (injective? const-decl "bool" functions nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (group? const-decl "bool" group_def nil) (monad? const-decl "bool" monad_def nil) (monoid? const-decl "bool" monoid_def nil) (abelian_group? const-decl "bool" group_def nil) (cartesian_product_quot_ring_is_ring formula-decl nil cartesian_product_quot_ring nil) (image const-decl "set[R]" function_image nil) (y!1 skolem-const-decl "(cartesian_product_n[set[T]](fsQ(R!1)(fsA!1)))" chinese_remainder_theorem_rings nil) (surjective? const-decl "bool" functions nil) (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_isomorphic? const-decl "bool" ring_homomorphisms_def nil) (fullset const-decl "set" sets nil) (TRUE const-decl "bool" booleans nil) (Pfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (Sfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (setof type-eq-decl nil defined_types nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (first_isomorphism_th formula-decl nil ring_1st_isomorphism_theorem nil) (+ const-decl "set[T]" cosets_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (CRT_aux_2 formula-decl nil chinese_remainder_theorem_rings nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil) (Chinese_Remainder_Theorem-2 nil 3785233533 ("" (skosimp) (("" (typepred "fsA!1") (("" (prop) (("" (lemma "CRT_aux_1") (("" (inst -1 "R!1" "fsA!1") (("" (assert) (("" (lemma "CRT_aux_2") (("" (inst -1 "R!1" "fsA!1") (("" (assert) (("" (expand "finseq_appl") (("" (name-replace "phi!1" "LAMBDA (x: (R!1)):
                      (# length := length(fsA!1),
                         seq
                           := LAMBDA (i: below[length(fsA!1)]):
                                x + fsA!1`seq(i) #)") (("" (flatten) (("" (lemma "first_isomorphism_th[T,+,*,zero,
           	      (cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))), Sfs(R!1)(fsA!1),
                      Pfs(R!1)(fsA!1), fsA!1]") (("1" (inst -1 "R!1" "cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))" "phi!1") (("1" (expand "R_isomorphic?") (("1" (assert) (("1" (skosimp) (("1" (inst?) (("1" (assert) (("1" (expand "R_isomorphism?") (("1" (prop) (("1" (hide (-2 -3)) (("1" (expand "R_monomorphism?") (("1" (prop) (("1" (hide (-2 -3 -4 2)) (("1" (expand "injective?") (("1" (skosimp) (("1" (inst?) (("1" (assert) nil))))))))) ("2" (expand "R_homomorphism?") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-2 -14 +)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (assert) (("1" (inst -1 "x!1" "y!1") (("1" (expand "restrict") (("1" (replace -2 -1) (("1" (propax) nil))))) ("2" (expand "restrict") (("2" (typepred "y!1") (("2" (expand "restrict") (("2" (assert) nil))))))) ("3" (expand "restrict") (("3" (typepred "x!1") (("3" (expand "restrict") (("3" (assert) nil))))))))))))))))) ("2" (hide-all-but (-3 -14 +)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("1" (replace -2 -1) (("1" (propax) nil))) ("2" (expand "restrict") (("2" (typepred "y!1") (("2" (expand "restrict") (("2" (assert) nil))))))) ("3" (expand "restrict") (("3" (typepred "x!1") (("3" (expand "restrict") (("3" (assert) nil))))))))))))))))))) ("3" (hide-all-but (-6 -14 +)) (("3" (expand "homomorphism?") (("3" (assert) (("3" (skosimp) (("3" (inst -1 "a!1" "b!1") (("3" (assert) nil))))))))))) ("4" (hide-all-but (-7 -14 +)) (("4" (expand "homomorphism?") (("4" (assert) (("4" (skosimp) (("4" (inst -1 "a!1" "b!1") (("4" (assert) nil))))))))))))))))))))))) ("2" (hide -1) (("2" (expand "R_epimorphism?") (("2" (prop) (("1" (hide (-2 2)) (("1" (expand "surjective?") (("1" (skosimp) (("1" (inst -1 "y!1") (("1" (skosimp) (("1" (inst?) (("1" (expand "restrict") (("1" (expand "/") (("1" (hide -1) (("1" (typepred "x!1") (("1" (hide -2) (("1" (assert) nil))))))))))))))) ("2" (hide (-2 -3 2)) (("2" (expand "extend") (("2" (expand "image") (("2" (expand "image") (("2" (inst -1 "y!1") (("2" (skosimp) (("2" (inst?) (("1" (assert) nil) ("2" (expand "restrict") (("2" (propax) nil))))))))))))))))))))))))) ("2" (hide -4) (("2" (expand "R_homomorphism?") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-2 -9 +)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (assert) (("1" (inst -1 "x!1" "y!1") (("1" (expand "restrict") (("1" (replace -2 -1) (("1" (propax) nil))))) ("2" (expand "restrict") (("2" (typepred "y!1") (("2" (expand "restrict") (("2" (assert) nil))))))) ("3" (expand "restrict") (("3" (typepred "x!1") (("3" (expand "restrict") (("3" (assert) nil))))))))))))))))) ("2" (hide-all-but (-3 -9 +)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("1" (replace -2 -1) (("1" (propax) nil))) ("2" (expand "restrict") (("2" (typepred "y!1") (("2" (expand "restrict") (("2" (assert) nil))))))) ("3" (expand "restrict") (("3" (typepred "x!1") (("3" (expand "restrict") (("3" (assert) nil))))))))))))))))))) ("3" (hide-all-but (1 2)) (("3" (lemma "cartesian_product_quot_ring_is_ring") (("3" (inst?) (("3" (assert) (("3" (expand "ring?") (("3" (flatten) (("3" (assert) (("3" (hide-all-but (-1 1 2)) (("3" (expand "abelian_group?") (("3" (expand "group?") (("3" (expand "monoid?") (("3" (expand "monad?") (("3" (propax) nil))))))))))))))))))))))))) ("4" (hide-all-but (1 2)) (("4" (lemma "cartesian_product_quot_ring_is_ring") (("4" (inst -1 "R!1" "fsA!1") (("4" (assert) (("4" (expand "ring?") (("4" (propax) nil))))))))))) ("5" (hide-all-but (-6 -9 +)) (("5" (expand "homomorphism?") (("5" (assert) (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (assert) nil))))))))))) ("6" (hide-all-but (-7 -9 +)) (("6" (expand "homomorphism?") (("6" (assert) (("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (assert) nil))))))))))))))))))))))))))))))) ("2" (assert) (("2" (prop) (("1" (skosimp) (("1" (prop) (("1" (hide (-2 -3 -4 -5 2)) (("1" (replaces -2) nil))) ("2" (expand "restrict") (("2" (expand "/") (("2" (hide (-2 -3 -4 -5 2)) (("2" (replaces -2) nil))))))) ("3" (assert) nil) ("4" (expand "restrict") (("4" (expand "/") (("4" (assert) nil))))))))) ("2" (skosimp) (("2" (expand "restrict") (("2" (propax) nil))))))))))))))))) ("2" (hide (-1 -2 -3 3)) (("2" (lemma "cartesian_product_quot_ring_is_ring") (("2" (inst?) (("2" (assert) nil))))))))) ("2" (hide (-1 -2 -3 3)) (("2" (inst 1 "fsA!1") (("2" (expand "cartesian_product_n") (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (prop) (("1" (expand "fsQ") (("1" (propax) nil))) ("2" (expand "fsQ") (("2" (propax) nil))) ("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (lemma "ideal_is_coset") (("3" (inst?) (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (flatten) (("3" (hide -2) (("3" (inst?) (("3" (expand "finseq_appl") (("3" (propax) nil))))))))))))))))))))))))))))))))))))) ("3" (hide (-1 -2 -3 3)) (("3" (lemma "cartesian_product_quot_ring_is_ring") (("3" (inst -1 "R!1" "fsA!1") (("1" (assert) (("1" (expand "restrict") (("1" (expand "fullset") (("1" (propax) nil))))))) ("2" (hide 2) (("2" (expand "fsICM?") (("2" (assert) nil))))))))))) ("4" (hide-all-but 1) (("4" (rewrite "fullset_is_ring") nil))) ("5" (hide-all-but (1 2 -4)) (("5" (expand "cartesian_product_n") (("5" (expand "finseq_appl") (("5" (expand "member") (("5" (prop) (("1" (expand "fsQ") (("1" (propax) nil))) ("2" (expand "fsQ") (("2" (propax) nil))) ("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (lemma "ideal_is_coset") (("3" (inst?) (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (flatten) (("3" (hide -2) (("3" (inst?) (("3" (expand "finseq_appl") (("3" (propax) nil))))))))))))))))))))))))))))))))))) ("6" (hide (-1 -2 -3 3)) (("6" (skosimp) (("6" (expand "cartesian_product_n") (("6" (prop) (("1" (expand "fsQ") (("1" (propax) nil))) ("2" (expand "Pfs") (("2" (expand "fsQ") (("2" (propax) nil))))) ("3" (skosimp) (("3" (expand "finseq_appl") (("3" (expand "member") (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (lemma "coset_product") (("3" (inst -1 "R!1" "fsA!1`seq(i!1)" "x1!1`1`seq(i!1)" "x1!1`2`seq(i!1)") (("1" (expand "Pfs") (("1" (expand "finseq_appl") (("1" (propax) nil))))) ("2" (hide (2 3)) (("2" (typepred "x1!1`2") (("2" (expand "cartesian_product_n") (("2" (prop) (("1" (expand "fsQ") (("1" (propax) nil))) ("2" (expand "finseq_appl") (("2" (inst?) (("2" (expand "member") (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (propax) nil))))))))))))))))))))) ("3" (hide 2) (("3" (typepred "i!1" "x1!1`2") (("3" (expand "cartesian_product_n") (("3" (expand "Pfs") (("3" (expand "fsQ") (("3" (assert) nil))))))))))) ("4" (hide 2) (("4" (typepred "x1!1`1") (("4" (expand "cartesian_product_n") (("4" (prop) (("1" (expand "fsQ") (("1" (propax) nil))) ("2" (expand "finseq_appl") (("2" (inst?) (("2" (expand "member") (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (propax) nil))))))))))))))))))))) ("5" (hide 2) (("5" (typepred "i!1" "x1!1`1") (("5" (expand "cartesian_product_n") (("5" (expand "Pfs") (("5" (expand "fsQ") (("5" (assert) nil))))))))))) ("6" (hide (2 3)) (("6" (expand "fsICM?") (("6" (prop) (("6" (hide -2) (("6" (expand "fsRI?") (("6" (expand "finseq_appl") (("6" (inst?) nil))))))))))))))))))))))))))))))))))))) ("7" (hide (-1 -2 -3 3)) (("7" (skosimp) (("7" (expand "cartesian_product_n") (("7" (prop) (("1" (expand "fsQ") (("1" (propax) nil))) ("2" (expand "Sfs") (("2" (expand "fsQ") (("2" (propax) nil))))) ("3" (expand "finseq_appl") (("3" (expand "member") (("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "Sfs") (("3" (expand "finseq_appl") (("3" (lemma "coset_add") (("3" (inst?) (("3" (hide (2 3)) (("3" (expand "fsICM?") (("3" (prop) (("3" (hide -2) (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) nil) nil nil) (Chinese_Remainder_Theorem-1 nil 3782948927 ("" (skosimp) (("" (typepred "fsA!1") (("" (prop) (("" (lemma "CRT_aux_1") (("" (inst -1 "R!1" "fsA!1") (("" (assert) (("" (lemma "CRT_aux_2") (("" (inst -1 "R!1" "fsA!1") (("" (assert) (("" (expand "finseq_appl") (("" (name-replace "phi!1" "LAMBDA (x: (R!1)):
                    (# length := length(fsA!1),
                       seq
                         := LAMBDA (i: below[length(fsA!1)]):
                              x + fsA!1`seq(i) #)") (("" (flatten) (("" (lemma "first_isomorphism_th[T,+,*,zero,
         	      (cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))), Sfs(R!1)(fsA!1),
                    Pfs(R!1)(fsA!1), fsA!1]") (("1" (inst -1 "R!1" "cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))" "phi!1") (("1" (expand "R_isomorphic?") (("1" (assert) (("1" (skosimp) (("1" (inst?) (("1" (assert) (("1" (expand "R_isomorphism?") (("1" (prop) (("1" (hide (-2 -3)) (("1" (expand "R_monomorphism?") (("1" (prop) (("1" (hide (-2 -3 -4 2)) (("1" (expand "injective?") (("1" (skosimp) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "R_homomorphism?") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-2 -14 +)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (assert) (("1" (inst -1 "x!1" "y!1") (("1" (expand "restrict") (("1" (replace -2 -1) (("1" (propax) nil nil)) nil)) nil) ("2" (expand "restrict") (("2" (typepred "y!1") (("2" (expand "restrict") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "restrict") (("3" (typepred "x!1") (("3" (expand "restrict") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -14 +)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("1" (replace -2 -1) (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (typepred "y!1") (("2" (expand "restrict") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "restrict") (("3" (typepred "x!1") (("3" (expand "restrict") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-6 -14 +)) (("3" (expand "homomorphism?") (("3" (assert) (("3" (skosimp) (("3" (inst -1 "a!1" "b!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-7 -14 +)) (("4" (expand "homomorphism?") (("4" (assert) (("4" (skosimp) (("4" (inst -1 "a!1" "b!1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "R_epimorphism?") (("2" (prop) (("1" (hide (-2 2)) (("1" (expand "surjective?") (("1" (skosimp) (("1" (inst -1 "y!1") (("1" (skosimp) (("1" (inst?) (("1" (expand "restrict") (("1" (expand "/") (("1" (hide -1) (("1" (typepred "x!1") (("1" (hide -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -3 2)) (("2" (expand "extend") (("2" (expand "image") (("2" (expand "image") (("2" (inst -1 "y!1") (("2" (skosimp) (("2" (inst?) (("1" (assert) nil nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (expand "R_homomorphism?") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-2 -9 +)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (assert) (("1" (inst -1 "x!1" "y!1") (("1" (expand "restrict") (("1" (replace -2 -1) (("1" (propax) nil nil)) nil)) nil) ("2" (expand "restrict") (("2" (typepred "y!1") (("2" (expand "restrict") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "restrict") (("3" (typepred "x!1") (("3" (expand "restrict") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -9 +)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("1" (replace -2 -1) (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (typepred "y!1") (("2" (expand "restrict") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "restrict") (("3" (typepred "x!1") (("3" (expand "restrict") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (lemma "cartesian_product_quot_ring_is_ring") (("3" (inst?) (("3" (assert) (("3" (expand "ring?") (("3" (flatten) (("3" (assert) (("3" (hide-all-but (-1 1 2)) (("3" (expand "abelian_group?") (("3" (expand "group?") (("3" (expand "monoid?") (("3" (expand "monad?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 2)) (("4" (lemma "cartesian_product_quot_ring_is_ring") (("4" (inst -1 "R!1" "fsA!1") (("4" (assert) (("4" (expand "ring?") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-6 -9 +)) (("5" (expand "homomorphism?") (("5" (assert) (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-7 -9 +)) (("6" (expand "homomorphism?") (("6" (assert) (("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (prop) (("1" (skosimp) (("1" (prop) (("1" (hide (-2 -3 -4 -5 2)) (("1" (replaces -2) nil nil)) nil) ("2" (expand "restrict") (("2" (expand "/") (("2" (hide (-2 -3 -4 -5 2)) (("2" (replaces -2) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (expand "restrict") (("4" (expand "/") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 3)) (("2" (lemma "cartesian_product_quot_ring_is_ring") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 3)) (("2" (inst 1 "fsA!1") (("2" (expand "cartesian_product_n") (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "fsQ") (("2" (propax) nil nil)) nil) ("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (lemma "ideal_is_coset") (("3" (inst?) (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (flatten) (("3" (hide -2) (("3" (inst?) (("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 -2 -3 3)) (("3" (lemma "cartesian_product_quot_ring_is_ring") (("3" (inst -1 "R!1" "fsA!1") (("1" (assert) (("1" (expand "restrict") (("1" (expand "fullset") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "fsICM?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "fullset_is_ring") nil nil)) nil) ("5" (hide-all-but (1 2 -4)) (("5" (expand "cartesian_product_n") (("5" (expand "finseq_appl") (("5" (expand "member") (("5" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "fsQ") (("2" (propax) nil nil)) nil) ("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (lemma "ideal_is_coset") (("3" (inst?) (("3" (expand "fsICM?") (("3" (expand "fsRI?") (("3" (flatten) (("3" (hide -2) (("3" (inst?) (("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide (-1 -2 -3 3)) (("6" (skosimp) (("6" (expand "cartesian_product_n") (("6" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "Pfs") (("2" (expand "fsQ") (("2" (propax) nil nil)) nil)) nil) ("3" (skosimp) (("3" (expand "finseq_appl") (("3" (expand "member") (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (lemma "coset_product") (("3" (inst -1 "R!1" "fsA!1`seq(i!1)" "x1!1`1`seq(i!1)" "x1!1`2`seq(i!1)") (("1" (expand "Pfs") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil) ("2" (hide (2 3)) (("2" (typepred "x1!1`2") (("2" (expand "cartesian_product_n") (("2" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (inst?) (("2" (expand "member") (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "i!1" "x1!1`2") (("3" (expand "cartesian_product_n") (("3" (expand "Pfs") (("3" (expand "fsQ") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "x1!1`1") (("4" (expand "cartesian_product_n") (("4" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (inst?) (("2" (expand "member") (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (typepred "i!1" "x1!1`1") (("5" (expand "cartesian_product_n") (("5" (expand "Pfs") (("5" (expand "fsQ") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide (2 3)) (("6" (expand "fsICM?") (("6" (prop) (("6" (hide -2) (("6" (expand "fsRI?") (("6" (expand "finseq_appl") (("6" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide (-1 -2 -3 3)) (("7" (skosimp) (("7" (expand "cartesian_product_n") (("7" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "Sfs") (("2" (expand "fsQ") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (expand "member") (("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "Sfs") (("3" (expand "finseq_appl") (("3" (lemma "coset_add") (("3" (inst?) (("3" (hide (2 3)) (("3" (expand "fsICM?") (("3" (prop) (("3" (hide -2) (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (commutative_ring_with_one? const-decl "bool" ring_with_one_def nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (one formal-const-decl "T" chinese_remainder_theorem_rings nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" chinese_remainder_theorem_rings nil) (* formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (+ formal-const-decl "[T, T -> T]" chinese_remainder_theorem_rings nil) (set type-eq-decl nil sets nil) (T formal-nonempty-type-decl nil chinese_remainder_theorem_rings nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (CRT_aux_1 formula-decl nil chinese_remainder_theorem_rings nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (coset_add formula-decl nil quotient_rings nil) (coset_product formula-decl nil quotient_rings nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (below type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (seq2set const-decl "finite_set[T]" seq2set structures) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (Intersection const-decl "set" sets nil) (setofsets type-eq-decl nil sets nil) (coset type-eq-decl nil cosets_def nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (coset? const-decl "bool" cosets_def nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil) (surjective? const-decl "bool" functions nil) (cartesian_product_quot_ring_is_ring formula-decl nil cartesian_product_quot_ring nil) (group? const-decl "bool" group_def nil) (monad? const-decl "bool" monad_def nil) (monoid? const-decl "bool" monoid_def nil) (abelian_group? const-decl "bool" group_def nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (injective? const-decl "bool" functions nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (member const-decl "bool" sets nil) (star_closed? const-decl "bool" groupoid_def nil) (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_isomorphic? const-decl "bool" ring_homomorphisms_def nil) (TRUE const-decl "bool" booleans nil) (fullset const-decl "set" sets nil) (Pfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (Sfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (setof type-eq-decl nil defined_types nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (first_isomorphism_th formula-decl nil ring_1st_isomorphism_theorem nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (CRT_aux_2 formula-decl nil chinese_remainder_theorem_rings nil)) shostak)))
