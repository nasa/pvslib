(ring_1st_isomorphism_theorem (IMP_ring_homomorphism_lemmas_TCC1 0 (IMP_ring_homomorphism_lemmas_TCC1-1 nil 3793737447 ("" (rewrite "fullsetT_is_ring") nil nil) ((fullsetT_is_ring formula-decl nil ring_1st_isomorphism_theorem nil)) nil (IMP_ring_homomorphism_lemmas assuming "ring_homomorphism_lemmas[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*, ring_1st_isomorphism_theorem.zero, ring_1st_isomorphism_theorem.D, ring_1st_isomorphism_theorem.s, ring_1st_isomorphism_theorem.p, ring_1st_isomorphism_theorem.zerod].ring_homomorphism_lemmas" "R1_is_ring: ASSUMPTION ring_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1, ring_homomorphism_lemmas.zero1].ring?(sets[ring_homomorphism_lemmas.T1].fullset)"))) (IMP_ring_homomorphism_lemmas_TCC2 0 (IMP_ring_homomorphism_lemmas_TCC2-1 nil 3793737447 ("" (rewrite "fullsetD_is_ring") nil nil) ((fullsetD_is_ring formula-decl nil ring_1st_isomorphism_theorem nil)) nil (IMP_ring_homomorphism_lemmas assuming "ring_homomorphism_lemmas[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*, ring_1st_isomorphism_theorem.zero, ring_1st_isomorphism_theorem.D, ring_1st_isomorphism_theorem.s, ring_1st_isomorphism_theorem.p, ring_1st_isomorphism_theorem.zerod].ring_homomorphism_lemmas" "R2_is_ring: ASSUMPTION ring_def[ring_homomorphism_lemmas.T2, ring_homomorphism_lemmas.s2, ring_homomorphism_lemmas.p2, ring_homomorphism_lemmas.zero2].ring?(sets[ring_homomorphism_lemmas.T2].fullset)"))) (first_isomorphism_th_aux_1_TCC1 0 (first_isomorphism_th_aux_1_TCC1-1 nil 3757773086 ("" (skosimp*) (("" (expand "/") (("" (rewrite "lcoset_iff_coset" :dir rl) (("" (expand "left_coset?") (("" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil) ((/ const-decl "setof[set[T]]" cosets_def nil) (left_coset? const-decl "bool" cosets_def nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (+ const-decl "set[T]" cosets_def nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil)) nil (first_isomorphism_th_aux_1 subtype "(cosets_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+].+)(ring_1st_isomorphism_theorem.x, ring_1st_isomorphism_theorem.I)" "(cosets_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+]./(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I))"))) (first_isomorphism_th_aux_1_TCC2 0 (first_isomorphism_th_aux_1_TCC2-1 nil 3757773086 ("" (skosimp*) (("" (hide -) (("" (inst 1 "I!1") (("" (expand "coset?") (("" (lemma "lcoset_iff_rcoset") (("" (inst -1 "I!1" "I!1" "R!1") (("" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((left_zero formula-decl nil ring_cosets_lemmas nil) (member const-decl "bool" sets nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (left_coset? const-decl "bool" cosets_def nil) (lcoset_iff_rcoset formula-decl nil ring_cosets_lemmas nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_1st_isomorphism_theorem nil) (I!1 skolem-const-decl "ideal[T, +, *, zero](R!1)" ring_1st_isomorphism_theorem nil) (coset type-eq-decl nil cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (coset? const-decl "bool" cosets_def nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil)) nil (first_isomorphism_th_aux_1 existence "" "coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I)"))) (first_isomorphism_th_aux_1_TCC3 0 (first_isomorphism_th_aux_1_TCC3-1 nil 3757773086 ("" (skosimp*) (("" (lemma "coset_add") (("" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("" (assert) nil nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (coset_add formula-decl nil quotient_rings nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (first_isomorphism_th_aux_1 subtype "cosets_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+].add(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I)" "[[coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I), coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I)] -> coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I)]"))) (first_isomorphism_th_aux_1_TCC4 0 (first_isomorphism_th_aux_1_TCC4-1 nil 3757773086 ("" (skosimp*) (("" (lemma "coset_product") (("" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("" (assert) nil nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (coset_product formula-decl nil quotient_rings nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (first_isomorphism_th_aux_1 subtype "product_coset_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*].product(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I)" "[[coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I), coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I)] -> coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I)]"))) (first_isomorphism_th_aux_1_TCC5 0 (first_isomorphism_th_aux_1_TCC5-1 nil 3757773086 ("" (skosimp*) (("" (rewrite "ideal_is_coset") nil nil)) nil) ((ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil)) nil (first_isomorphism_th_aux_1 subtype "ring_1st_isomorphism_theorem.I" "coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I)"))) (first_isomorphism_th_aux_1 0 (first_isomorphism_th_aux_1-2 nil 3758808639 ("" (skosimp) (("" (name "f" "(lambda(A:(R!1 / I!1)):  phi!1( gen(R!1,I!1)(A)))") (("1" (inst 1 "f") (("1" (prop) (("1" (skosimp) (("1" (decompose-equality -1) (("1" (inst -1 "x!1+ I!1") (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (lemma "gen_is_any") (("1" (inst -1 "R!1" "I!1" "x!1 + I!1" "x!1") (("1" (lemma "lcos_eq") (("1" (inst -1 "I!1" "gen(R!1, I!1)(x!1 + I!1)" "x!1") (("1" (typepred "I!1") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (flatten) (("1" (hide -1 -3 -4) (("1" (lemma "zero_is_member_R[T,+,*, zero]") (("1" (inst -1 "I!1") (("1" (expand "member") (("1" (expand "gen") (("1" (assert) (("1" (skosimp) (("1" (replace -3 1) (("1" (hide -1 -2 -3 -4) (("1" (typepred "phi!1") (("1" (expand "R_homomorphism?") (("1" (flatten) (("1" (hide-all-but (-5 -7 1)) (("1" (expand "homomorphism?") (("1" (inst -1 "x!1" "h!1") (("1" (replaces -1) (("1" (expand "subset?") (("1" (inst -1 "h!1") (("1" (expand "member") (("1" (expand "R_kernel") (("1" (flatten) (("1" (hide -1 -2) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (typepred "h!1" "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -3 -4) (("2" (expand "subset?") (("2" (inst -2 "h!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "+") (("2" (inst 1 "zero") (("1" (assert) nil nil) ("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -1 -3 -4) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 2) (("3" (expand "left_coset?") (("3" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gen") (("2" (expand "lc_gen") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "/" -1) (("3" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "R_homomorphism?") (("2" (prop) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (expand "member") (("1" (expand "restrict") (("1" (expand "/") (("1" (rewrite "coset_add") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand* "member" "restrict" "/") (("2" (rewrite "coset_product") nil nil)) nil)) nil)) nil) ("3" (expand "star_closed?") (("3" (skosimp) (("3" (hide -) (("3" (rewrite "R_sum_star_closed[D,s,p,zerod]") nil nil)) nil)) nil)) nil) ("4" (expand "star_closed?") (("4" (skosimp) (("4" (rewrite "R_prod_star_closed[D,s,p,zerod]") nil nil)) nil)) nil) ("5" (expand "homomorphism?") (("5" (skosimp) (("5" (decompose-equality -1) (("1" (typepred "a!1" "b!1") (("1" (expand "coset?") (("1" (flatten) (("1" (hide -2 -3 -5 -6) (("1" (expand "left_coset?") (("1" (skosimp*) (("1" (lemma "add_charac") (("1" (inst -1 "R!1" "I!1" "a!2" "a!3") (("1" (replace -2 -1 rl) (("1" (replace -3 -1 rl) (("1" (replace -1 1) (("1" (inst-cp -4 "a!1") (("1" (inst-cp -4 "b!1") (("1" (inst -4 "(a!2+a!3) + I!1") (("1" (lemma "gen_is_any") (("1" (lemma "lcos_eq") (("1" (inst-cp -2 "R!1" "I!1" "a!1" "a!2") (("1" (inst-cp -2 "R!1" "I!1" "b!1" "a!3") (("1" (inst -2 "R!1" "I!1" "(a!2 + a!3) + I!1" "a!2+a!3") (("1" (assert) (("1" (inst-cp -1 "I!1" "lc_gen(R!1, I!1)(a!1)" "a!2") (("1" (inst-cp -1 "I!1" "lc_gen(R!1, I!1)(b!1)" "a!3") (("1" (inst -1 "I!1" "lc_gen(R!1, I!1)((a!2 + a!3) + I!1)" "a!2+a!3") (("1" (assert) (("1" (typepred "I!1") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (flatten) (("1" (hide -1 -3 -4) (("1" (lemma "zero_is_member_R[T,+,*,zero]") (("1" (inst -1 "I!1") (("1" (expand "member") (("1" (assert) (("1" (skosimp*) (("1" (expand "gen") (("1" (replaces -3) (("1" (replaces -3) (("1" (replaces -3) (("1" (replace -9 1 rl) (("1" (replace -10 1 rl) (("1" (replace -11 1 rl) (("1" (hide -3 -4 -5 -6 -7 -8 -9 -10 -11) (("1" (typepred "phi!1") (("1" (expand "R_homomorphism?") (("1" (flatten) (("1" (hide -1 -2 -3 -4 -6) (("1" (expand "homomorphism?") (("1" (inst-cp -1 "a!2+a!3" "h!1") (("1" (inst-cp -1 "a!2" "h!3") (("1" (inst-cp -1 "a!3" "h!2") (("1" (inst -1 "a!2" "a!3") (("1" (replaces -4) (("1" (replaces -1) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "subset?") (("1" (inst-cp -3 "h!1") (("1" (inst-cp -3 "h!2") (("1" (inst -3 "h!3") (("1" (assert) (("1" (expand "R_kernel") (("1" (flatten) (("1" (hide -3 -4 -6 -7 -9 -10) (("1" (replaces -3) (("1" (replaces -3) (("1" (replaces -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -2 -3) (("2" (expand "subset?") (("2" (inst -1 "h!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -2 -3) (("2" (expand "subset?") (("2" (inst -1 "h!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -2 -3) (("2" (expand "subset?") (("2" (inst -1 "h!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "R_sum_star_closed[T,+,*,zero]") (("3" (inst -1 "R!1" "a!2" "a!3") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "+") (("2" (inst 1 "zero") (("1" (assert) nil nil) ("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -1 -3 -4) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "left_coset?") (("3" (inst 1 "a!2+a!3") (("3" (lemma "R_sum_star_closed[T,+,*,zero]") (("3" (inst -1 "R!1" "a!2" "a!3") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (replaces -1) (("2" (expand "+") (("2" (inst 1 "zero") (("1" (assert) nil nil) ("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -1 -3 -4) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-5 1)) (("3" (replaces -1) (("3" (expand "left_coset?") (("3" (inst 1 "a!3") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (replaces -1) (("2" (expand "+") (("2" (inst 1 "zero") (("1" (assert) nil nil) ("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -1 -3 -4) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (replaces -1) (("3" (expand "left_coset?") (("3" (inst 1 "a!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "gen") (("2" (expand "lc_gen") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (expand "/") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "homomorphism?") (("6" (skosimp) (("6" (decompose-equality -1) (("1" (typepred "a!1" "b!1") (("1" (expand "coset?") (("1" (flatten) (("1" (hide -2 -3 -5 -6) (("1" (expand "left_coset?") (("1" (skosimp*) (("1" (lemma "product_charac") (("1" (inst -1 "R!1" "I!1" "a!2" "a!3") (("1" (replace -2 -1 rl) (("1" (replace -3 -1 rl) (("1" (replace -1 1) (("1" (inst-cp -4 "a!1") (("1" (inst-cp -4 "b!1") (("1" (inst -4 "(a!2*a!3) + I!1") (("1" (lemma "gen_is_any") (("1" (lemma "lcos_eq") (("1" (inst-cp -2 "R!1" "I!1" "a!1" "a!2") (("1" (inst-cp -2 "R!1" "I!1" "b!1" "a!3") (("1" (inst -2 "R!1" "I!1" "(a!2 * a!3) + I!1" "a!2*a!3") (("1" (assert) (("1" (inst-cp -1 "I!1" "lc_gen(R!1, I!1)(a!1)" "a!2") (("1" (inst-cp -1 "I!1" "lc_gen(R!1, I!1)(b!1)" "a!3") (("1" (inst -1 "I!1" "lc_gen(R!1, I!1)((a!2 * a!3) + I!1)" "a!2*a!3") (("1" (assert) (("1" (typepred "I!1") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (expand "subring?") (("1" (flatten) (("1" (hide -1 -3 -4) (("1" (lemma "zero_is_member_R[T,+,*,zero]") (("1" (inst -1 "I!1") (("1" (expand "member") (("1" (assert) (("1" (skosimp*) (("1" (expand "gen") (("1" (replaces -3) (("1" (replaces -3) (("1" (replaces -3) (("1" (replace -9 1 rl) (("1" (replace -10 1 rl) (("1" (replace -11 1 rl) (("1" (hide -3 -4 -5 -6 -7 -8 -9 -10 -11) (("1" (typepred "phi!1") (("1" (expand "R_homomorphism?") (("1" (flatten) (("1" (hide -1 -2 -3 -4) (("1" (expand "homomorphism?") (("1" (inst-cp -1 "a!2*a!3" "h!1") (("1" (inst-cp -1 "a!2" "h!3") (("1" (inst -1 "a!3" "h!2") (("1" (inst -4 "a!2" "a!3") (("1" (replaces -3) (("1" (replaces -1) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "subset?") (("1" (inst-cp -3 "h!1") (("1" (inst-cp -3 "h!2") (("1" (inst -3 "h!3") (("1" (assert) (("1" (expand "R_kernel") (("1" (flatten) (("1" (hide -3 -4 -6 -7 -9 -10) (("1" (replaces -3) (("1" (replaces -3) (("1" (replaces -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -2 -3) (("2" (expand "subset?") (("2" (inst -1 "h!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -2 -3) (("2" (expand "subset?") (("2" (inst -1 "h!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -2 -3) (("2" (expand "subset?") (("2" (inst -1 "h!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "R_prod_star_closed[T,+,*,zero]") (("3" (inst -1 "R!1" "a!2" "a!3") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "+") (("2" (inst 1 "zero") (("1" (assert) nil nil) ("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -1 -3 -4) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "left_coset?") (("3" (inst 1 "a!2*a!3") (("3" (lemma "R_prod_star_closed[T,+,*,zero]") (("3" (inst -1 "R!1" "a!2" "a!3") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (replaces -1) (("2" (expand "+") (("2" (inst 1 "zero") (("1" (assert) nil nil) ("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -1 -3 -4) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-5 1)) (("3" (replaces -1) (("3" (expand "left_coset?") (("3" (inst 1 "a!3") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (replaces -1) (("2" (expand "+") (("2" (inst 1 "zero") (("1" (assert) nil nil) ("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -1 -3 -4) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (replaces -1) (("3" (expand "left_coset?") (("3" (inst 1 "a!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "gen") (("2" (expand "lc_gen") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (expand "/") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (skosimp) (("2" (expand "gen") (("2" (expand "lc_gen") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -1 2) (("3" (skosimp) (("3" (typepred "A!1") (("3" (expand "/") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gen const-decl "T" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (zerod formal-const-decl "D" ring_1st_isomorphism_theorem nil) (p formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (s formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (D formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (/ const-decl "setof[set[T]]" cosets_def nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (setof type-eq-decl nil defined_types nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (NOT const-decl "[bool -> bool]" booleans nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (gen_is_any formula-decl nil ring_cosets_lemmas nil) (lcos_eq formula-decl nil ring_cosets_lemmas nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (member const-decl "bool" sets nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (TRUE const-decl "bool" booleans nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (right_identity formula-decl nil monad nil) (subset? const-decl "bool" sets nil) (h!1 skolem-const-decl "(I!1)" ring_1st_isomorphism_theorem nil) (subring? const-decl "bool" ring_def nil) (left_coset type-eq-decl nil cosets_def nil) (x!1 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (I!1 skolem-const-decl "ideal[T, +, *, zero](R!1)" ring_1st_isomorphism_theorem nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_1st_isomorphism_theorem nil) (left_coset? const-decl "bool" cosets_def nil) (+ const-decl "set[T]" cosets_def nil) (lc_gen const-decl "T" cosets_def nil) (restrict const-decl "R" restrict nil) (coset_add formula-decl nil quotient_rings nil) (star_closed? const-decl "bool" groupoid_def nil) (coset_product formula-decl nil quotient_rings nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (add_charac formula-decl nil quotient_rings nil) (a!1 skolem-const-decl "(restrict[set[T], coset[T, +](R!1, I!1), bool](R!1 / I!1))" ring_1st_isomorphism_theorem nil) (a!2 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (h!1 skolem-const-decl "(I!1)" ring_1st_isomorphism_theorem nil) (h!2 skolem-const-decl "(I!1)" ring_1st_isomorphism_theorem nil) (h!3 skolem-const-decl "(I!1)" ring_1st_isomorphism_theorem nil) (a!3 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (b!1 skolem-const-decl "(restrict[set[T], coset[T, +](R!1, I!1), bool](R!1 / I!1))" ring_1st_isomorphism_theorem nil) (product_charac formula-decl nil quotient_rings nil) (a!1 skolem-const-decl "(restrict[set[T], coset[T, +](R!1, I!1), bool](R!1 / I!1))" ring_1st_isomorphism_theorem nil) (a!2 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (h!1 skolem-const-decl "(I!1)" ring_1st_isomorphism_theorem nil) (h!2 skolem-const-decl "(I!1)" ring_1st_isomorphism_theorem nil) (h!3 skolem-const-decl "(I!1)" ring_1st_isomorphism_theorem nil) (a!3 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (b!1 skolem-const-decl "(restrict[set[T], coset[T, +](R!1, I!1), bool](R!1 / I!1))" ring_1st_isomorphism_theorem nil)) nil) (first_isomorphism_th_aux_1-1 nil 3758808597 ("" (postpone) nil nil) nil shostak)) (first_isomorphism_th_aux_2 0 (first_isomorphism_th_aux_2-1 nil 3758808685 ("" (skosimp) (("" (expand "restrict") (("" (lemma "first_isomorphism_th_aux_1") (("" (inst -1 "R!1" "S!1" "phi!1" "I!1") (("" (assert) (("" (skosimp) (("" (inst 1 "f!1") (("" (prop) (("" (expand "image") (("" (expand "image") (("" (decompose-equality 1) (("" (iff 1) (("" (prop) (("1" (skosimp) (("1" (typepred "x!2 ") (("1" (expand "/") (("1" (expand "coset?") (("1" (expand "left_coset?") (("1" (flatten) (("1" (hide -2 -5) (("1" (skosimp) (("1" (inst 1 "a!1") (("1" (inst -3 "a!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (skosimp) (("2" (inst -2 "x!2") (("2" (inst 1 "x!2 + I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (D formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (s formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (p formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (zerod formal-const-decl "D" ring_1st_isomorphism_theorem nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (image const-decl "set[R]" function_image nil) (+ const-decl "set[T]" cosets_def nil) (left_coset? const-decl "bool" cosets_def nil) (coset? const-decl "bool" cosets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (TRUE const-decl "bool" booleans nil) (image const-decl "set[R]" function_image nil) (setof type-eq-decl nil defined_types nil) (/ const-decl "setof[set[T]]" cosets_def nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (first_isomorphism_th_aux_1 formula-decl nil ring_1st_isomorphism_theorem nil)) nil)) (first_isomorphism_th_aux_3_TCC1 0 (first_isomorphism_th_aux_3_TCC1-1 nil 3757773086 ("" (skosimp) (("" (lemma "first_isomorphism_th_aux_1") (("" (inst -1 "R!1" "S!1" "phi!1" "I!1") (("" (assert) (("" (skosimp) (("" (skosimp) (("" (split) (("1" (skosimp) (("1" (expand "restrict") (("1" (expand "/" 1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case-replace "f!1 = f!2") (("2" (hide 2) (("2" (decompose-equality 1) (("2" (typepred "x!1") (("2" (expand "/" -1) (("2" (expand "coset?" -1) (("2" (flatten) (("2" (hide -2) (("2" (expand "left_coset?") (("2" (skosimp) (("2" (inst -2 "a!1") (("2" (inst -5 "a!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((first_isomorphism_th_aux_1 formula-decl nil ring_1st_isomorphism_theorem nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (= const-decl "[T, T -> boolean]" equalities nil) (setof type-eq-decl nil defined_types nil) (left_coset? const-decl "bool" cosets_def nil) (coset? const-decl "bool" cosets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (/ const-decl "setof[set[T]]" cosets_def nil) (restrict const-decl "R" restrict nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zerod formal-const-decl "D" ring_1st_isomorphism_theorem nil) (p formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (s formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (D formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil)) nil (first_isomorphism_th_aux_3 subtype "ring_1st_isomorphism_theorem.f" "R_homomorphism[coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I), cosets_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+].add(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I), product_coset_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*].product(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I), ring_1st_isomorphism_theorem.I, ring_1st_isomorphism_theorem.D, ring_1st_isomorphism_theorem.s, ring_1st_isomorphism_theorem.p, ring_1st_isomorphism_theorem.zerod](restrict[set[T], coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I), bool].restrict(cosets_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+]./(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I)), ring_1st_isomorphism_theorem.S)"))) (first_isomorphism_th_aux_3 0 (first_isomorphism_th_aux_3-2 nil 3800372732 ("" (skosimp) (("" (lemma "first_isomorphism_th_aux_1") (("" (inst -1 "R!1" "S!1" "phi!1" "I!1") (("" (assert) (("" (skosimp) (("" (inst 1 "f!1") (("" (prop) (("" (decompose-equality) (("1" (iff) (("1" (prop) (("1" (expand "restrict") (("1" (expand "R_kernel" -1) (("1" (flatten) (("1" (expand "/") (("1" (expand "coset?") (("1" (flatten) (("1" (hide -2) (("1" (lemma "lcoset_iff_rcoset") (("1" (inst -1 "x!1" "I!1" "R_kernel(R!1, S!1)(phi!1)") (("1" (case "left_coset?(R_kernel(R!1, S!1)(phi!1), I!1)(x!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (skosimp) (("2" (inst -4 "a!1") (("2" (replace -1 -3) (("2" (replaces -3 -4) (("2" (inst 1 "a!1") (("2" (expand "R_kernel") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (expand "/" -1) (("2" (expand "coset?") (("2" (flatten) (("2" (hide -2) (("2" (expand "left_coset?") (("2" (skosimp) (("2" (expand "R_kernel") (("2" (typepred "a!1") (("2" (expand "R_kernel") (("2" (flatten) (("2" (assert) (("2" (split) (("1" (expand "/" 1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but (-3 -4 -5 1)) (("2" (inst -3 "a!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (expand "coset?") (("2" (lemma "lcoset_iff_rcoset") (("2" (inst -1 "I!1" "I!1" "R!1") (("2" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -) (("3" (skosimp) (("3" (expand "coset?") (("3" (lemma "lcoset_iff_rcoset") (("3" (inst -1 "product[T, +, *](R!1, I!1)(x1!1)" "I!1" "R!1") (("3" (case "left_coset?(R!1, I!1)(product[T, +, *](R!1, I!1)(x1!1))") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (expand "product") (("2" (typepred "x1!1`1" "x1!1`2") (("2" (expand "coset?") (("2" (expand "left_coset?") (("2" (flatten) (("2" (hide -2 -4) (("2" (skosimp*) (("2" (lemma "product_charac") (("2" (inst -1 "R!1" "I!1" "a!1" "a!2") (("2" (expand "product") (("2" (inst 1 "a!1*a!2") (("1" (assert) nil nil) ("2" (hide -) (("2" (lemma "R_prod_star_closed[T,+,*,zero]") (("2" (inst -1 "R!1" "a!1" "a!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -) (("4" (skosimp) (("4" (expand "coset?") (("4" (lemma "lcoset_iff_rcoset") (("4" (inst -1 "add[T, +](R!1, I!1)(x1!1)" "I!1" "R!1") (("4" (case "left_coset?(R!1, I!1)(add[T, +](R!1, I!1)(x1!1))") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (expand "add") (("2" (typepred "x1!1`1" "x1!1`2") (("2" (expand "coset?") (("2" (expand "left_coset?") (("2" (flatten) (("2" (hide -2 -4) (("2" (skosimp*) (("2" (lemma "add_charac") (("2" (inst -1 "R!1" "I!1" "a!1" "a!2") (("2" (expand "add") (("2" (inst 1 "a!1 + a!2") (("1" (assert) nil nil) ("2" (hide -) (("2" (lemma "R_sum_star_closed[T,+,*,zero]") (("2" (inst -1 "R!1" "a!1" "a!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide -) (("5" (inst 1 "I!1") (("5" (expand "coset?") (("5" (lemma "lcoset_iff_rcoset") (("5" (inst -1 "I!1" "I!1" "R!1") (("5" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((first_isomorphism_th_aux_1 formula-decl nil ring_1st_isomorphism_theorem nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (/ const-decl "setof[set[T]]" cosets_def nil) (setof type-eq-decl nil defined_types nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (restrict const-decl "R" restrict nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (product const-decl "set[T]" product_coset_def nil) (add const-decl "set[T]" cosets_def nil) (TRUE const-decl "bool" booleans nil) (I!1 skolem-const-decl "ideal[T, +, *, zero](R!1)" ring_1st_isomorphism_theorem nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_1st_isomorphism_theorem nil) (lcoset_iff_rcoset formula-decl nil ring_cosets_lemmas nil) (left_coset? const-decl "bool" cosets_def nil) (a!1 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (phi!1 skolem-const-decl "R_homomorphism[T, +, *, zero, D, s, p, zerod](R!1, S!1)" ring_1st_isomorphism_theorem nil) (S!1 skolem-const-decl "ring[D, s, p, zerod]" ring_1st_isomorphism_theorem nil) (NOT const-decl "[bool -> bool]" booleans nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (member const-decl "bool" sets nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (product_charac formula-decl nil quotient_rings nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (a!2 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (a!1 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (add_charac formula-decl nil quotient_rings nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (a!2 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (a!1 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zerod formal-const-decl "D" ring_1st_isomorphism_theorem nil) (p formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (s formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (D formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil)) nil) (first_isomorphism_th_aux_3-1 nil 3758808727 ("" (skosimp) (("" (lemma "first_isomorphism_th_aux_1") (("" (inst -1 "R!1" "S!1" "phi!1" "I!1") (("" (assert) (("" (skosimp) (("" (inst 1 "f!1") (("" (prop) (("" (decompose-equality) (("1" (iff) (("1" (prop) (("1" (expand "restrict") (("1" (expand "R_kernel" -1) (("1" (flatten) (("1" (expand "/") (("1" (expand "coset?") (("1" (flatten) (("1" (hide -2) (("1" (lemma "lcoset_iff_rcoset") (("1" (inst -1 "x!1" "I!1" "R_kernel(R!1, S!1)(phi!1)") (("1" (case "left_coset?(R_kernel(R!1, S!1)(phi!1), I!1)(x!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (skosimp) (("2" (inst -4 "a!1") (("2" (replace -1 -3) (("2" (replaces -3 -4) (("2" (inst 1 "a!1") (("2" (expand "R_kernel") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (expand "/" -1) (("2" (expand "coset?") (("2" (flatten) (("2" (hide -2) (("2" (expand "left_coset?") (("2" (skosimp) (("2" (expand "R_kernel") (("2" (typepred "a!1") (("2" (expand "R_kernel") (("2" (flatten) (("2" (assert) (("2" (split) (("1" (expand "/" 1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but (-3 -4 -5 1)) (("2" (inst -3 "a!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (expand "coset?") (("2" (lemma "lcoset_iff_rcoset") (("2" (inst -1 "I!1" "I!1" "R!1") (("2" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -) (("3" (skosimp) (("3" (expand "coset?") (("3" (lemma "lcoset_iff_rcoset") (("3" (inst -1 "product[T, +, *](R!1, I!1)(x1!1)" "I!1" "R!1") (("3" (case "left_coset?(R!1, I!1)(product[T, +, *](R!1, I!1)(x1!1))") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (expand "product") (("2" (typepred "x1!1`1" "x1!1`2") (("2" (expand "coset?") (("2" (expand "left_coset?") (("2" (flatten) (("2" (hide -2 -4) (("2" (skosimp*) (("2" (lemma "product_charac") (("2" (inst -1 "R!1" "I!1" "a!1" "a!2") (("2" (expand "product") (("2" (inst 1 "a!1*a!2") (("1" (assert) nil nil) ("2" (hide -) (("2" (lemma "R_prod_star_closed[T,+,*,zero]") (("2" (inst -1 "R!1" "a!1" "a!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -) (("4" (skosimp) (("4" (expand "coset?") (("4" (lemma "lcoset_iff_rcoset") (("4" (inst -1 "add[T, +, *](R!1, I!1)(x1!1)" "I!1" "R!1") (("4" (case "left_coset?(R!1, I!1)(add[T, +, *](R!1, I!1)(x1!1))") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (expand "add") (("2" (typepred "x1!1`1" "x1!1`2") (("2" (expand "coset?") (("2" (expand "left_coset?") (("2" (flatten) (("2" (hide -2 -4) (("2" (skosimp*) (("2" (lemma "add_charac") (("2" (inst -1 "R!1" "I!1" "a!1" "a!2") (("2" (expand "add") (("2" (inst 1 "a!1 + a!2") (("1" (assert) nil nil) ("2" (hide -) (("2" (lemma "R_sum_star_closed[T,+,*,zero]") (("2" (inst -1 "R!1" "a!1" "a!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide -) (("5" (inst 1 "I!1") (("5" (expand "coset?") (("5" (lemma "lcoset_iff_rcoset") (("5" (inst -1 "I!1" "I!1" "R!1") (("5" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((first_isomorphism_th_aux_1 formula-decl nil ring_1st_isomorphism_theorem nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (setof type-eq-decl nil defined_types nil) (TRUE const-decl "bool" booleans nil) (product const-decl "set[T]" product_coset_def nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (restrict const-decl "R" restrict nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (lcoset_iff_rcoset formula-decl nil ring_cosets_lemmas nil) (left_coset? const-decl "bool" cosets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (member const-decl "bool" sets nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (product_charac formula-decl nil quotient_rings nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (add_charac formula-decl nil quotient_rings nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zerod formal-const-decl "D" ring_1st_isomorphism_theorem nil) (p formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (s formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (D formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil)) nil)) (first_isomorphism_th_aux_4_TCC1 0 (first_isomorphism_th_aux_4_TCC1-1 nil 3757773086 ("" (skosimp*) (("" (expand "restrict") (("" (expand "/") (("" (grind) nil nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (/ const-decl "setof[set[T]]" cosets_def nil)) nil (first_isomorphism_th_aux_4 subtype "ring_1st_isomorphism_theorem.f" "[(restrict[set[T], coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I), bool].restrict(cosets_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+]./(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.I))) -> (ring_1st_isomorphism_theorem.S)]"))) (first_isomorphism_th_aux_4 0 (first_isomorphism_th_aux_4-1 nil 3758808765 ("" (skosimp) (("" (lemma "first_isomorphism_th_aux_1") (("" (inst -1 "R!1" "S!1" "phi!1" "I!1") (("" (assert) (("" (skosimp) (("" (inst 1 "f!1") (("" (prop) (("1" (expand "R_epimorphism?") (("1" (flatten) (("1" (hide -2) (("1" (expand "surjective?") (("1" (skosimp) (("1" (inst -1 "y!1") (("1" (skosimp) (("1" (typepred "x!1") (("1" (expand "coset?") (("1" (flatten) (("1" (hide -2) (("1" (expand "left_coset?") (("1" (skosimp) (("1" (hide -2) (("1" (inst -3 "a!1") (("1" (inst 1 "a!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "R_epimorphism?") (("2" (prop) (("2" (expand "surjective?") (("2" (skosimp) (("2" (inst -1 "y!1") (("2" (skosimp) (("2" (inst -2 "x!1") (("2" (inst 1 "x!1+I!1") (("1" (assert) nil nil) ("2" (hide -) (("2" (expand "restrict") (("2" (expand "/") (("2" (expand "coset?") (("2" (lemma "lcoset_iff_rcoset") (("2" (inst -1 "x!1 + I!1" "I!1" "R!1") (("2" (case "left_coset?(R!1, I!1)(x!1 + I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((first_isomorphism_th_aux_1 formula-decl nil ring_1st_isomorphism_theorem nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (/ const-decl "setof[set[T]]" cosets_def nil) (setof type-eq-decl nil defined_types nil) (lcoset_iff_rcoset formula-decl nil ring_cosets_lemmas nil) (x!1 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (+ const-decl "set[T]" cosets_def nil) (I!1 skolem-const-decl "ideal[T, +, *, zero](R!1)" ring_1st_isomorphism_theorem nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_1st_isomorphism_theorem nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (left_coset? const-decl "bool" cosets_def nil) (restrict const-decl "R" restrict nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (surjective? const-decl "bool" functions nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zerod formal-const-decl "D" ring_1st_isomorphism_theorem nil) (p formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (s formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (D formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil)) nil)) (first_isomorphism_th_aux_5 0 (first_isomorphism_th_aux_5-2 nil 3800372877 ("" (skosimp) (("" (lemma "first_isomorphism_th_aux_3") (("" (inst -1 "R!1" "S!1" "phi!1" "I!1") (("" (assert) (("" (skosimp) (("" (inst 1 "f!1") (("" (prop) (("1" (rewrite "monomorphism_charac[coset(R!1,I!1),add(R!1,I!1), product(R!1,I!1),I!1,D,s,p,zerod]") (("1" (decompose-equality 1) (("1" (replace -3 -1) (("1" (hide -3) (("1" (iff 1) (("1" (prop) (("1" (expand "singleton") (("1" (lemma "self_coset[T,+,*,zero]") (("1" (decompose-equality -3) (("1" (inst -1 "x!1+I!1") (("1" (expand "restrict") (("1" (inst -2 "I!1" "R!1" "x!1") (("1" (typepred "I!1") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (flatten) (("1" (assert) (("1" (hide -1 -2 -3 -6 -7 2) (("1" (iff -1) (("1" (prop) (("1" (hide 1 3) (("1" (expand "/") (("1" (expand "coset?") (("1" (lemma "lcoset_iff_rcoset") (("1" (inst -1 "x!1+I!1" "I!1" "R_kernel(R!1, S!1)(phi!1)") (("1" (case "left_coset?(R_kernel(R!1, S!1)(phi!1), I!1)(x!1 + I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3 -4 2) (("2" (lemma "lcoset_iff_rcoset") (("2" (expand "coset?") (("2" (inst -1 "x!1+I!1" "I!1" "R!1") (("2" (case "left_coset?(R!1, I!1)(x!1 + I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "x!1") (("2" (expand "R_kernel") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3) (("2" (expand "subset?") (("2" (inst -2 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "quotient_group_is_ring") (("2" (inst -1 "R!1" "I!1") nil nil)) nil)) nil) ("3" (hide - 2) (("3" (rewrite "fullsetD_is_ring") nil nil)) nil) ("4" (hide-all-but 1) (("4" (lemma "quotient_group_is_ring[T,+,*,zero]") (("4" (inst -1 "R!1" "I!1") (("4" (expand "/" -1) (("4" (expand "fullset") (("4" (expand "restrict") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide - 2) (("5" (expand "coset?") (("5" (lemma "lcoset_iff_rcoset") (("5" (inst -1 "I!1" "I!1" "R!1") (("5" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide - 2) (("6" (skosimp) (("6" (lemma "product_is_coset") (("6" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("6" (skosimp) (("6" (expand "product") (("6" (replaces -1) (("6" (expand "coset?") (("6" (lemma "lcoset_iff_rcoset") (("6" (inst -1 "a!1 + I!1" "I!1" "R!1") (("6" (case "left_coset?(R!1, I!1)(a!1 + I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "a!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide - 2) (("7" (skosimp) (("7" (lemma "add_is_coset") (("7" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("7" (skosimp) (("7" (expand "add") (("7" (replaces -1) (("7" (expand "coset?") (("7" (lemma "lcoset_iff_rcoset") (("7" (inst -1 "a!1 + I!1" "I!1" "R!1") (("7" (case "left_coset?(R!1, I!1)(a!1 + I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "a!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide - 2) (("8" (inst 1 "I!1") (("8" (expand "coset?") (("8" (lemma "lcoset_iff_rcoset") (("8" (inst -1 "I!1" "I!1" "R!1") (("8" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "monomorphism_charac" 1) (("1" (replace -3 1) (("1" (hide -2 -3) (("1" (decompose-equality 1) (("1" (iff) (("1" (prop) (("1" (expand "restrict") (("1" (expand "singleton") (("1" (replaces -2) (("1" (expand "/") (("1" (expand "coset?") (("1" (flatten) (("1" (expand "left_coset?") (("1" (skosimp) (("1" (typepred "a!1") (("1" (lemma "self_coset") (("1" (inst -1 "I!1" "R!1" "a!1") (("1" (typepred "I!1") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "singleton") (("2" (expand "restrict") (("2" (replaces -2) (("2" (expand "/") (("2" (expand "coset?") (("2" (expand "left_coset?") (("2" (expand "right_coset?") (("2" (split) (("1" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -1 -3 -4) (("2" (inst -2 "I!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "zero") (("1" (rewrite "right_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -1 -3 -4) (("2" (inst -2 "I!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "quotient_group_is_ring") (("2" (inst -1 "R!1" "I!1") nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "fullsetD_is_ring") nil nil)) nil) ("4" (hide-all-but 1) (("4" (expand "fullset") (("4" (lemma "quotient_group_is_ring") (("4" (inst -1 "R!1" "I!1") (("4" (expand "restrict") (("4" (expand "/") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (expand "coset?") (("5" (lemma "lcoset_iff_rcoset") (("5" (inst -1 "I!1" "I!1" "R!1") (("5" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but 1) (("6" (skosimp) (("6" (expand "coset?") (("6" (lemma "lcoset_iff_rcoset") (("6" (inst -1 "product[T, +, *](R!1, I!1)(x1!1)" "I!1" "R!1") (("6" (case "left_coset?(R!1, I!1)(product[T, +, *](R!1, I!1)(x1!1))") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (typepred "x1!1`1" "x1!1`2") (("2" (expand "coset?") (("2" (flatten) (("2" (hide -2 -4) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (lemma "product_charac") (("2" (inst -1 "R!1" "I!1" "a!1" "a!2") (("2" (inst 1 "a!1*a!2") (("1" (expand "product") (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (lemma "R_prod_star_closed[T,+,*,zero]") (("2" (inst -1 "R!1" "a!1" "a!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide-all-but 1) (("7" (skosimp) (("7" (expand "coset?") (("7" (lemma "lcoset_iff_rcoset") (("7" (inst -1 "add(R!1, I!1)(x1!1)" "I!1" "R!1") (("7" (case "left_coset?(R!1, I!1)(add(R!1, I!1)(x1!1))") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (typepred "x1!1`1" "x1!1`2") (("2" (expand "coset?") (("2" (flatten) (("2" (hide -2 -4) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (lemma "add_charac") (("2" (inst -1 "R!1" "I!1" "a!1" "a!2") (("2" (inst 1 "a!1+a!2") (("1" (expand "add") (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (lemma "R_sum_star_closed[T,+,*,zero]") (("2" (inst -1 "R!1" "a!1" "a!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide-all-but 1) (("8" (inst 1 "I!1") (("8" (expand "coset?") (("8" (lemma "lcoset_iff_rcoset") (("8" (inst -1 "I!1" "I!1" "R!1") (("8" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((first_isomorphism_th_aux_3 formula-decl nil ring_1st_isomorphism_theorem nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (/ const-decl "setof[set[T]]" cosets_def nil) (setof type-eq-decl nil defined_types nil) (right_coset? const-decl "bool" cosets_def nil) (right_zero formula-decl nil ring_cosets_lemmas nil) (subring? const-decl "bool" ring_def nil) (singleton? const-decl "bool" sets nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (a!2 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (a!1 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (product_charac formula-decl nil quotient_rings nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (a!2 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (a!1 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (add_charac formula-decl nil quotient_rings nil) (fullset const-decl "set" sets nil) (TRUE const-decl "bool" booleans nil) (monomorphism_charac formula-decl nil ring_homomorphism_lemmas nil) (restrict const-decl "R" restrict nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (add const-decl "set[T]" cosets_def nil) (product const-decl "set[T]" product_coset_def nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (subset? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (member const-decl "bool" sets nil) (left_coset? const-decl "bool" cosets_def nil) (lcoset_iff_rcoset formula-decl nil ring_cosets_lemmas nil) (x!1 skolem-const-decl "T" ring_1st_isomorphism_theorem nil) (+ const-decl "set[T]" cosets_def nil) (I!1 skolem-const-decl "ideal[T, +, *, zero](R!1)" ring_1st_isomorphism_theorem nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_1st_isomorphism_theorem nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (quotient_group_is_ring formula-decl nil quotient_rings nil) (fullsetD_is_ring formula-decl nil ring_1st_isomorphism_theorem nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (product_is_coset formula-decl nil quotient_rings nil) (add_is_coset formula-decl nil quotient_rings nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zerod formal-const-decl "D" ring_1st_isomorphism_theorem nil) (p formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (s formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (D formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil)) nil) (first_isomorphism_th_aux_5-1 nil 3758808799 ("" (skosimp) (("" (lemma "first_isomorphism_th_aux_3") (("" (inst -1 "R!1" "S!1" "phi!1" "I!1") (("" (assert) (("" (skosimp) (("" (inst 1 "f!1") (("" (prop) (("1" (rewrite "monomorphism_charac[coset(R!1,I!1),add(R!1,I!1), product(R!1,I!1),I!1,D,s,p,zerod]") (("1" (decompose-equality 1) (("1" (replace -3 -1) (("1" (hide -3) (("1" (iff 1) (("1" (prop) (("1" (expand "singleton") (("1" (lemma "self_coset[T,+,*,zero]") (("1" (decompose-equality -3) (("1" (inst -1 "x!1+I!1") (("1" (expand "restrict") (("1" (inst -2 "I!1" "R!1" "x!1") (("1" (typepred "I!1") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (flatten) (("1" (assert) (("1" (hide -1 -2 -3 -6 -7 2) (("1" (iff -1) (("1" (prop) (("1" (hide 1 3) (("1" (expand "/") (("1" (expand "coset?") (("1" (lemma "lcoset_iff_rcoset") (("1" (inst -1 "x!1+I!1" "I!1" "R_kernel(R!1, S!1)(phi!1)") (("1" (case "left_coset?(R_kernel(R!1, S!1)(phi!1), I!1)(x!1 + I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3 -4 2) (("2" (lemma "lcoset_iff_rcoset") (("2" (expand "coset?") (("2" (inst -1 "x!1+I!1" "I!1" "R!1") (("2" (case "left_coset?(R!1, I!1)(x!1 + I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "x!1") (("2" (expand "R_kernel") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3) (("2" (expand "subset?") (("2" (inst -2 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "quotient_group_is_ring") (("2" (inst -1 "R!1" "I!1") nil nil)) nil)) nil) ("3" (hide - 2) (("3" (rewrite "fullsetD_is_ring") nil nil)) nil) ("4" (hide-all-but 1) (("4" (lemma "quotient_group_is_ring[T,+,*,zero]") (("4" (inst -1 "R!1" "I!1") (("4" (expand "/" -1) (("4" (expand "fullset") (("4" (expand "restrict") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide - 2) (("5" (expand "coset?") (("5" (lemma "lcoset_iff_rcoset") (("5" (inst -1 "I!1" "I!1" "R!1") (("5" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide - 2) (("6" (skosimp) (("6" (lemma "product_is_coset") (("6" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("6" (skosimp) (("6" (expand "product") (("6" (replaces -1) (("6" (expand "coset?") (("6" (lemma "lcoset_iff_rcoset") (("6" (inst -1 "a!1 + I!1" "I!1" "R!1") (("6" (case "left_coset?(R!1, I!1)(a!1 + I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "a!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide - 2) (("7" (skosimp) (("7" (lemma "add_is_coset") (("7" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("7" (skosimp) (("7" (expand "add") (("7" (replaces -1) (("7" (expand "coset?") (("7" (lemma "lcoset_iff_rcoset") (("7" (inst -1 "a!1 + I!1" "I!1" "R!1") (("7" (case "left_coset?(R!1, I!1)(a!1 + I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "a!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide - 2) (("8" (inst 1 "I!1") (("8" (expand "coset?") (("8" (lemma "lcoset_iff_rcoset") (("8" (inst -1 "I!1" "I!1" "R!1") (("8" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "monomorphism_charac" 1) (("1" (replace -3 1) (("1" (hide -2 -3) (("1" (decompose-equality 1) (("1" (iff) (("1" (prop) (("1" (expand "restrict") (("1" (expand "singleton") (("1" (replaces -2) (("1" (expand "/") (("1" (expand "coset?") (("1" (flatten) (("1" (expand "left_coset?") (("1" (skosimp) (("1" (typepred "a!1") (("1" (lemma "self_coset") (("1" (inst -1 "I!1" "R!1" "a!1") (("1" (typepred "I!1") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "singleton") (("2" (expand "restrict") (("2" (replaces -2) (("2" (expand "/") (("2" (expand "coset?") (("2" (expand "left_coset?") (("2" (expand "right_coset?") (("2" (split) (("1" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -1 -3 -4) (("2" (inst -2 "I!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "zero") (("1" (rewrite "right_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (typepred "I!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -1 -3 -4) (("2" (inst -2 "I!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "quotient_group_is_ring") (("2" (inst -1 "R!1" "I!1") nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "fullsetD_is_ring") nil nil)) nil) ("4" (hide-all-but 1) (("4" (expand "fullset") (("4" (lemma "quotient_group_is_ring") (("4" (inst -1 "R!1" "I!1") (("4" (expand "restrict") (("4" (expand "/") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (expand "coset?") (("5" (lemma "lcoset_iff_rcoset") (("5" (inst -1 "I!1" "I!1" "R!1") (("5" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but 1) (("6" (skosimp) (("6" (expand "coset?") (("6" (lemma "lcoset_iff_rcoset") (("6" (inst -1 "product[T, +, *](R!1, I!1)(x1!1)" "I!1" "R!1") (("6" (case "left_coset?(R!1, I!1)(product[T, +, *](R!1, I!1)(x1!1))") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (typepred "x1!1`1" "x1!1`2") (("2" (expand "coset?") (("2" (flatten) (("2" (hide -2 -4) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (lemma "product_charac") (("2" (inst -1 "R!1" "I!1" "a!1" "a!2") (("2" (inst 1 "a!1*a!2") (("1" (expand "product") (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (lemma "R_prod_star_closed[T,+,*,zero]") (("2" (inst -1 "R!1" "a!1" "a!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide-all-but 1) (("7" (skosimp) (("7" (expand "coset?") (("7" (lemma "lcoset_iff_rcoset") (("7" (inst -1 "add[T, +, *](R!1, I!1)(x1!1)" "I!1" "R!1") (("7" (case "left_coset?(R!1, I!1)(add[T, +, *](R!1, I!1)(x1!1))") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (typepred "x1!1`1" "x1!1`2") (("2" (expand "coset?") (("2" (flatten) (("2" (hide -2 -4) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (lemma "add_charac") (("2" (inst -1 "R!1" "I!1" "a!1" "a!2") (("2" (inst 1 "a!1+a!2") (("1" (expand "add") (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (lemma "R_sum_star_closed[T,+,*,zero]") (("2" (inst -1 "R!1" "a!1" "a!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide-all-but 1) (("8" (inst 1 "I!1") (("8" (expand "coset?") (("8" (lemma "lcoset_iff_rcoset") (("8" (inst -1 "I!1" "I!1" "R!1") (("8" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((first_isomorphism_th_aux_3 formula-decl nil ring_1st_isomorphism_theorem nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (setof type-eq-decl nil defined_types nil) (right_coset? const-decl "bool" cosets_def nil) (right_zero formula-decl nil ring_cosets_lemmas nil) (singleton? const-decl "bool" sets nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (product_charac formula-decl nil quotient_rings nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (add_charac formula-decl nil quotient_rings nil) (fullset const-decl "set" sets nil) (TRUE const-decl "bool" booleans nil) (monomorphism_charac formula-decl nil ring_homomorphism_lemmas nil) (restrict const-decl "R" restrict nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (product const-decl "set[T]" product_coset_def nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set" finite_sets nil) (subset? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (member const-decl "bool" sets nil) (left_coset? const-decl "bool" cosets_def nil) (lcoset_iff_rcoset formula-decl nil ring_cosets_lemmas nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (quotient_group_is_ring formula-decl nil quotient_rings nil) (fullsetD_is_ring formula-decl nil ring_1st_isomorphism_theorem nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (product_is_coset formula-decl nil quotient_rings nil) (add_is_coset formula-decl nil quotient_rings nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zerod formal-const-decl "D" ring_1st_isomorphism_theorem nil) (p formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (s formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (D formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil)) nil)) (first_isomorphism_th_aux_6 0 (first_isomorphism_th_aux_6-1 nil 3758808837 ("" (skosimp) (("" (lemma "first_isomorphism_th_aux_4") (("" (lemma "first_isomorphism_th_aux_5") (("" (inst -1 "R!1" "S!1" "phi!1" "I!1") (("" (inst -2 "R!1" "S!1" "phi!1" "I!1") (("" (assert) (("" (skosimp*) (("" (case-replace "f!2 = f!1") (("1" (hide -1 -5) (("1" (inst 1 "f!1") (("1" (split 1) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "R_isomorphism?") (("2" (flatten) (("2" (hide -5 -7) (("2" (assert) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (hide -4 -6) (("3" (expand "R_isomorphism?") (("3" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -4 1)) (("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand "/") (("2" (expand "coset?") (("2" (flatten) (("2" (expand "left_coset?") (("2" (hide -2) (("2" (skosimp) (("2" (inst -2 "a!1") (("2" (inst -3 "a!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((first_isomorphism_th_aux_4 formula-decl nil ring_1st_isomorphism_theorem nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (D formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (s formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (p formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (zerod formal-const-decl "D" ring_1st_isomorphism_theorem nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (= const-decl "[T, T -> boolean]" equalities nil) (/ const-decl "setof[set[T]]" cosets_def nil) (setof type-eq-decl nil defined_types nil) (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil) (left_coset? const-decl "bool" cosets_def nil) (coset? const-decl "bool" cosets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (first_isomorphism_th_aux_5 formula-decl nil ring_1st_isomorphism_theorem nil)) nil)) (first_isomorphism_th_TCC1 0 (first_isomorphism_th_TCC1-1 nil 3757773086 ("" (skosimp) (("" (inst 1 " R_kernel[T, +, *, zero, D, s, p, zerod]
                                  (R!1, S!1)(phi!1)") (("" (lemma "R_kernel_is_ideal") (("" (inst -1 "R!1" "S!1" "phi!1") (("" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil)) nil) ((T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (coset? const-decl "bool" cosets_def nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (D formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (s formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (p formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (zerod formal-const-decl "D" ring_1st_isomorphism_theorem nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (coset type-eq-decl nil cosets_def nil) (phi!1 skolem-const-decl "R_homomorphism[T, +, *, zero, D, s, p, zerod](R!1, S!1)" ring_1st_isomorphism_theorem nil) (S!1 skolem-const-decl "ring[D, s, p, zerod]" ring_1st_isomorphism_theorem nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_1st_isomorphism_theorem nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (R_kernel_is_ideal formula-decl nil ring_homomorphism_lemmas nil)) nil (first_isomorphism_th existence "" "coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_homomorphisms_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*, ring_1st_isomorphism_theorem.zero, ring_1st_isomorphism_theorem.D, ring_1st_isomorphism_theorem.s, ring_1st_isomorphism_theorem.p, ring_1st_isomorphism_theorem.zerod].R_kernel(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.S)(ring_1st_isomorphism_theorem.phi))"))) (first_isomorphism_th_TCC2 0 (first_isomorphism_th_TCC2-1 nil 3757773086 ("" (skosimp*) (("" (lemma "coset_add") (("" (inst -1 "R!1" "R_kernel(R!1,S!1)(phi!1)" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "R_kernel_is_ideal") nil nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (coset_add formula-decl nil quotient_rings nil) (R_kernel_is_ideal formula-decl nil ring_homomorphism_lemmas nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (D formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (s formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (p formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (zerod formal-const-decl "D" ring_1st_isomorphism_theorem nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (ring nonempty-type-eq-decl nil ring nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_1st_isomorphism_theorem nil) (S!1 skolem-const-decl "ring[D, s, p, zerod]" ring_1st_isomorphism_theorem nil) (phi!1 skolem-const-decl "R_homomorphism[T, +, *, zero, D, s, p, zerod](R!1, S!1)" ring_1st_isomorphism_theorem nil)) nil (first_isomorphism_th subtype "cosets_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+].add(ring_1st_isomorphism_theorem.R, ring_homomorphisms_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*, ring_1st_isomorphism_theorem.zero, ring_1st_isomorphism_theorem.D, ring_1st_isomorphism_theorem.s, ring_1st_isomorphism_theorem.p, ring_1st_isomorphism_theorem.zerod].R_kernel(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.S)(ring_1st_isomorphism_theorem.phi))" "[[coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_homomorphisms_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*, ring_1st_isomorphism_theorem.zero, ring_1st_isomorphism_theorem.D, ring_1st_isomorphism_theorem.s, ring_1st_isomorphism_theorem.p, ring_1st_isomorphism_theorem.zerod].R_kernel(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.S)(ring_1st_isomorphism_theorem.phi)), coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_homomorphisms_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*, ring_1st_isomorphism_theorem.zero, ring_1st_isomorphism_theorem.D, ring_1st_isomorphism_theorem.s, ring_1st_isomorphism_theorem.p, ring_1st_isomorphism_theorem.zerod].R_kernel(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.S)(ring_1st_isomorphism_theorem.phi))] -> coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_homomorphisms_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*, ring_1st_isomorphism_theorem.zero, ring_1st_isomorphism_theorem.D, ring_1st_isomorphism_theorem.s, ring_1st_isomorphism_theorem.p, ring_1st_isomorphism_theorem.zerod].R_kernel(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.S)(ring_1st_isomorphism_theorem.phi))]"))) (first_isomorphism_th_TCC3 0 (first_isomorphism_th_TCC3-1 nil 3757773086 ("" (skosimp*) (("" (lemma "coset_product") (("" (inst -1 "R!1" "R_kernel(R!1,S!1)(phi!1)" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "R_kernel_is_ideal") nil nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (coset_product formula-decl nil quotient_rings nil) (R_kernel_is_ideal formula-decl nil ring_homomorphism_lemmas nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (D formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (s formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (p formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (zerod formal-const-decl "D" ring_1st_isomorphism_theorem nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (ring nonempty-type-eq-decl nil ring nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_1st_isomorphism_theorem nil) (S!1 skolem-const-decl "ring[D, s, p, zerod]" ring_1st_isomorphism_theorem nil) (phi!1 skolem-const-decl "R_homomorphism[T, +, *, zero, D, s, p, zerod](R!1, S!1)" ring_1st_isomorphism_theorem nil)) nil (first_isomorphism_th subtype "product_coset_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*].product(ring_1st_isomorphism_theorem.R, ring_homomorphisms_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*, ring_1st_isomorphism_theorem.zero, ring_1st_isomorphism_theorem.D, ring_1st_isomorphism_theorem.s, ring_1st_isomorphism_theorem.p, ring_1st_isomorphism_theorem.zerod].R_kernel(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.S)(ring_1st_isomorphism_theorem.phi))" "[[coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_homomorphisms_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*, ring_1st_isomorphism_theorem.zero, ring_1st_isomorphism_theorem.D, ring_1st_isomorphism_theorem.s, ring_1st_isomorphism_theorem.p, ring_1st_isomorphism_theorem.zerod].R_kernel(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.S)(ring_1st_isomorphism_theorem.phi)), coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_homomorphisms_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*, ring_1st_isomorphism_theorem.zero, ring_1st_isomorphism_theorem.D, ring_1st_isomorphism_theorem.s, ring_1st_isomorphism_theorem.p, ring_1st_isomorphism_theorem.zerod].R_kernel(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.S)(ring_1st_isomorphism_theorem.phi))] -> coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_homomorphisms_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*, ring_1st_isomorphism_theorem.zero, ring_1st_isomorphism_theorem.D, ring_1st_isomorphism_theorem.s, ring_1st_isomorphism_theorem.p, ring_1st_isomorphism_theorem.zerod].R_kernel(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.S)(ring_1st_isomorphism_theorem.phi))]"))) (first_isomorphism_th_TCC4 0 (first_isomorphism_th_TCC4-1 nil 3757773086 ("" (skosimp) (("" (lemma "R_kernel_is_ideal") (("" (inst -1 "R!1" "S!1" "phi!1") (("" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil) ((zerod formal-const-decl "D" ring_1st_isomorphism_theorem nil) (p formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (s formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (D formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (R_kernel_is_ideal formula-decl nil ring_homomorphism_lemmas nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (first_isomorphism_th subtype "ring_homomorphisms_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*, ring_1st_isomorphism_theorem.zero, ring_1st_isomorphism_theorem.D, ring_1st_isomorphism_theorem.s, ring_1st_isomorphism_theorem.p, ring_1st_isomorphism_theorem.zerod].R_kernel(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.S)(ring_1st_isomorphism_theorem.phi)" "coset[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+](ring_1st_isomorphism_theorem.R, ring_homomorphisms_def[ring_1st_isomorphism_theorem.T, ring_1st_isomorphism_theorem.+, ring_1st_isomorphism_theorem.*, ring_1st_isomorphism_theorem.zero, ring_1st_isomorphism_theorem.D, ring_1st_isomorphism_theorem.s, ring_1st_isomorphism_theorem.p, ring_1st_isomorphism_theorem.zerod].R_kernel(ring_1st_isomorphism_theorem.R, ring_1st_isomorphism_theorem.S)(ring_1st_isomorphism_theorem.phi))"))) (first_isomorphism_th 0 (first_isomorphism_th-1 nil 3758808872 ("" (skosimp) (("" (name-replace "K" "R_kernel(R!1, S!1)(phi!1)" :hide? nil) (("" (name-replace "Im" "image(phi!1)(restrict[T, (R!1), boolean](R!1))" :hide? nil) (("" (lemma "first_isomorphism_th_aux_6") (("" (inst -1 "R!1" "Im" "phi!1" "K") (("1" (split -1) (("1" (skosimp) (("1" (expand "R_isomorphic?") (("1" (inst 1 "f!1") (("1" (hide -2) (("1" (split -2) (("1" (hide -2) (("1" (expand "R_isomorphism?") (("1" (expand "R_monomorphism?") (("1" (expand "R_epimorphism?") (("1" (flatten -1) (("1" (hide -2) (("1" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "injective?") (("1" (skeep) (("1" (inst -2 "x1" "x2") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (typepred "x2") (("2" (expand* "restrict" "K") nil nil)) nil)) nil) ("3" (hide -1 2) (("3" (typepred "x1") (("3" (expand* "restrict" "K") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "R_homomorphism?") (("2" (flatten) (("2" (split) (("1" (hide-all-but (-1 1)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (inst -1 "x!1" "y!1") (("1" (expand "member") (("1" (expand "restrict") (("1" (expand "K") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "y!1") (("2" (expand* "restrict" "K") nil nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "x!1") (("3" (expand* "restrict" "K") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (inst -1 "x!1" "y!1") (("1" (expand* "member" "restrict" "K") nil nil) ("2" (hide 2) (("2" (typepred "y!1") (("2" (expand* "restrict" "K") nil nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "x!1") (("3" (expand* "restrict" "K") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (propax) nil nil) ("5" (hide-all-but (-5 1)) (("5" (expand "homomorphism?") (("5" (skeep) (("5" (inst -1 "a" "b") (("1" (expand "K") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (typepred "b") (("2" (expand* "restrict" "K") nil nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "a") (("3" (expand* "restrict" "K") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-6 1)) (("6" (expand "homomorphism?") (("6" (skeep) (("6" (inst -1 "a" "b") (("1" (expand "K") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (typepred "b") (("2" (expand* "restrict" "K") nil nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "a") (("3" (expand* "restrict" "K") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (expand "surjective?") (("3" (skeep) (("3" (inst -1 "y") (("3" (skeep) (("3" (inst 1 "x") (("3" (typepred "x") (("3" (expand* "restrict" "K") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-3 1)) (("4" (expand* "R_homomorphism?" "K") (("4" (flatten) (("4" (split) (("1" (hide-all-but (-1 1)) (("1" (reveal -9) (("1" (expand "restrict") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (reveal -9) (("2" (expand "restrict") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (propax) nil nil) ("5" (hide-all-but (-5 1)) (("5" (expand "homomorphism?") (("5" (skeep) (("5" (inst -1 "a" "b") (("1" (assert) (("1" (expand "K") (("1" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "b") (("2" (expand* "restrict" "K") nil nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "a") (("3" (expand* "restrict" "K") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-6 1)) (("6" (expand "homomorphism?") (("6" (skeep) (("6" (inst -1 "a" "b") (("1" (expand "K") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (typepred "b") (("2" (expand* "restrict" "K") nil nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "a") (("3" (expand* "restrict" "K") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "phi!1") (("2" (expand "R_epimorphism?") (("2" (expand "surjective?") (("2" (split) (("1" (skosimp) (("1" (typepred "y!1") (("1" (expand "extend") (("1" (prop) (("1" (expand* "Im" "image" "image") (("1" (skeep) (("1" (inst 1 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) (("1" (hide-all-but (-2 -4 -8 1)) (("1" (expand* "Im" "image" "image") (("1" (skosimp*) (("1" (inst 1 "x!2*x!3") (("1" (inst -3 "x!2" "x!3") (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (lemma "R_prod_star_closed[T,+,*,zero]") (("2" (inst -1 "R!1" "x!2" "x!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -4 -7 1)) (("2" (expand* "Im" "image" "image") (("2" (skosimp*) (("2" (inst 1 "x!2 + x!3") (("1" (inst -3 "x!2" "x!3") (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (lemma "R_sum_star_closed[T,+,*,zero]") (("2" (inst -1 "R!1" "x!2" "x!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "K") (("3" (decompose-equality) (("3" (expand "R_kernel") (("3" (expand "extend") (("3" (iff) (("3" (prop) (("3" (expand* "Im" "image" "image") (("3" (inst 1 "zero") (("1" (lemma "zero_to_zero") (("1" (inst -1 "R!1" "S!1" "phi!1") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "restrict") (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (skosimp) (("2" (expand "restrict") (("2" (prop) (("2" (expand* "/" "K") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "subset?") (("2" (skeep) (("2" (expand* "member" "K" "R_kernel") (("2" (expand "extend") (("2" (prop) (("2" (expand* "Im" "image" "image") (("2" (inst 1 "zero") (("1" (lemma "zero_to_zero") (("1" (inst -1 "R!1" "S!1" "phi!1") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "restrict") (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (replace -1 1 rl) (("2" (rewrite "R_kernel_is_ideal") nil nil)) nil)) nil) ("3" (hide - 2) (("3" (prop) (("1" (skosimp) (("1" (expand "extend") (("1" (expand* "Im" "image" "image") (("1" (inst 1 "x1!1") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "phi!1") (("2" (grind) (("1" (hide-all-but (-2 -4 -10 1)) (("1" (expand* "Im" "image" "image") (("1" (skosimp*) (("1" (inst 1 "x!2*x!3") (("1" (inst -3 "x!2" "x!3") (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (lemma "R_prod_star_closed[T,+,*,zero]") (("2" (inst -1 "R!1" "x!2" "x!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -4 -9 1)) (("2" (expand* "Im" "image" "image") (("2" (skosimp*) (("2" (inst 1 "x!2+x!3") (("1" (inst -3 "x!2" "x!3") (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (lemma "R_sum_star_closed[T,+,*,zero]") (("2" (inst -1 "R!1" "x!2" "x!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -2 2) (("4" (lemma "image_homo_is_subring") (("4" (inst -1 "R!1" "S!1" "phi!1") (("4" (expand "subring?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (D formal-nonempty-type-decl nil ring_1st_isomorphism_theorem nil) (+ formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_1st_isomorphism_theorem nil) (zero formal-const-decl "T" ring_1st_isomorphism_theorem nil) (s formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (p formal-const-decl "[D, D -> D]" ring_1st_isomorphism_theorem nil) (zerod formal-const-decl "D" ring_1st_isomorphism_theorem nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (first_isomorphism_th_aux_6 formula-decl nil ring_1st_isomorphism_theorem nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subring? const-decl "bool" ring_def nil) (image_homo_is_subring formula-decl nil ring_homomorphism_lemmas nil) (x!3 skolem-const-decl "(restrict[T, (R!1), boolean](R!1))" ring_1st_isomorphism_theorem nil) (x!2 skolem-const-decl "(restrict[T, (R!1), boolean](R!1))" ring_1st_isomorphism_theorem nil) (x!3 skolem-const-decl "(restrict[T, (R!1), boolean](R!1))" ring_1st_isomorphism_theorem nil) (x!2 skolem-const-decl "(restrict[T, (R!1), boolean](R!1))" ring_1st_isomorphism_theorem nil) (x1!1 skolem-const-decl "(R!1)" ring_1st_isomorphism_theorem nil) (R_kernel_is_ideal formula-decl nil ring_homomorphism_lemmas nil) (R_isomorphic? const-decl "bool" ring_homomorphisms_def nil) (zero_to_zero formula-decl nil ring_homomorphism_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (image const-decl "set[R]" function_image nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (x!3 skolem-const-decl "(restrict[T, (R!1), boolean](R!1))" ring_1st_isomorphism_theorem nil) (x!2 skolem-const-decl "(restrict[T, (R!1), boolean](R!1))" ring_1st_isomorphism_theorem nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (x!3 skolem-const-decl "(restrict[T, (R!1), boolean](R!1))" ring_1st_isomorphism_theorem nil) (x!2 skolem-const-decl "(restrict[T, (R!1), boolean](R!1))" ring_1st_isomorphism_theorem nil) (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil) (injective? const-decl "bool" functions nil) (x1 skolem-const-decl "(restrict
     [set[T],
      coset[T, +](R!1,
                  R_kernel[T, +, *, zero, D, s, p, zerod]
                      (R!1, S!1)(phi!1)),
      bool]
     (R!1 / K))" ring_1st_isomorphism_theorem nil) (x2 skolem-const-decl "(restrict
     [set[T],
      coset[T, +](R!1,
                  R_kernel[T, +, *, zero, D, s, p, zerod]
                      (R!1, S!1)(phi!1)),
      bool]
     (R!1 / K))" ring_1st_isomorphism_theorem nil) (NOT const-decl "[bool -> bool]" booleans nil) (star_closed? const-decl "bool" groupoid_def nil) (x!1 skolem-const-decl "(restrict
     [set[T],
      coset[T, +](R!1,
                  R_kernel[T, +, *, zero, D, s, p, zerod]
                      (R!1, S!1)(phi!1)),
      bool]
     (R!1 / K))" ring_1st_isomorphism_theorem nil) (y!1 skolem-const-decl "(restrict
     [set[T],
      coset[T, +](R!1,
                  R_kernel[T, +, *, zero, D, s, p, zerod]
                      (R!1, S!1)(phi!1)),
      bool]
     (R!1 / K))" ring_1st_isomorphism_theorem nil) (member const-decl "bool" sets nil) (x!1 skolem-const-decl "(restrict
     [set[T],
      coset[T, +](R!1,
                  R_kernel[T, +, *, zero, D, s, p, zerod]
                      (R!1, S!1)(phi!1)),
      bool]
     (R!1 / K))" ring_1st_isomorphism_theorem nil) (y!1 skolem-const-decl "(restrict
     [set[T],
      coset[T, +](R!1,
                  R_kernel[T, +, *, zero, D, s, p, zerod]
                      (R!1, S!1)(phi!1)),
      bool]
     (R!1 / K))" ring_1st_isomorphism_theorem nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (a skolem-const-decl "(restrict
     [set[T],
      coset[T, +](R!1,
                  R_kernel[T, +, *, zero, D, s, p, zerod]
                      (R!1, S!1)(phi!1)),
      bool]
     (R!1 / K))" ring_1st_isomorphism_theorem nil) (b skolem-const-decl "(restrict
     [set[T],
      coset[T, +](R!1,
                  R_kernel[T, +, *, zero, D, s, p, zerod]
                      (R!1, S!1)(phi!1)),
      bool]
     (R!1 / K))" ring_1st_isomorphism_theorem nil) (a skolem-const-decl "(restrict
     [set[T],
      coset[T, +](R!1,
                  R_kernel[T, +, *, zero, D, s, p, zerod]
                      (R!1, S!1)(phi!1)),
      bool]
     (R!1 / K))" ring_1st_isomorphism_theorem nil) (b skolem-const-decl "(restrict
     [set[T],
      coset[T, +](R!1,
                  R_kernel[T, +, *, zero, D, s, p, zerod]
                      (R!1, S!1)(phi!1)),
      bool]
     (R!1 / K))" ring_1st_isomorphism_theorem nil) (surjective? const-decl "bool" functions nil) (x skolem-const-decl "(restrict[set[T], coset[T, +](R!1, K), bool](R!1 / K))" ring_1st_isomorphism_theorem nil) (lc_gen const-decl "T" cosets_def nil) (add const-decl "set[T]" cosets_def nil) (lproduct const-decl "set[T]" product_coset_def nil) (product const-decl "set[T]" product_coset_def nil) (a skolem-const-decl "(restrict
     [set[T],
      coset[T, +](R!1,
                  R_kernel[T, +, *, zero, D, s, p, zerod]
                      (R!1, S!1)(phi!1)),
      bool]
     (R!1 / R_kernel(R!1, S!1)(phi!1)))" ring_1st_isomorphism_theorem nil) (b skolem-const-decl "(restrict
     [set[T],
      coset[T, +](R!1,
                  R_kernel[T, +, *, zero, D, s, p, zerod]
                      (R!1, S!1)(phi!1)),
      bool]
     (R!1 / R_kernel(R!1, S!1)(phi!1)))" ring_1st_isomorphism_theorem nil) (a skolem-const-decl "(restrict
     [set[T],
      coset[T, +](R!1,
                  R_kernel[T, +, *, zero, D, s, p, zerod]
                      (R!1, S!1)(phi!1)),
      bool]
     (R!1 / R_kernel(R!1, S!1)(phi!1)))" ring_1st_isomorphism_theorem nil) (b skolem-const-decl "(restrict
     [set[T],
      coset[T, +](R!1,
                  R_kernel[T, +, *, zero, D, s, p, zerod]
                      (R!1, S!1)(phi!1)),
      bool]
     (R!1 / R_kernel(R!1, S!1)(phi!1)))" ring_1st_isomorphism_theorem nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (/ const-decl "setof[set[T]]" cosets_def nil) (setof type-eq-decl nil defined_types nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (ideal type-eq-decl nil ring_ideal_def nil) (K skolem-const-decl "set[T]" ring_1st_isomorphism_theorem nil) (ideal? const-decl "bool" ring_ideal_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_1st_isomorphism_theorem nil) (phi!1 skolem-const-decl "R_homomorphism[T, +, *, zero, D, s, p, zerod](R!1, S!1)" ring_1st_isomorphism_theorem nil) (Im skolem-const-decl "set[(S!1)]" ring_1st_isomorphism_theorem nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (S!1 skolem-const-decl "ring[D, s, p, zerod]" ring_1st_isomorphism_theorem nil) (restrict const-decl "R" restrict nil) (image const-decl "set[R]" function_image nil)) nil)))(ring_2nd_3rd_isomorphism_theorems (IMP_quotient_rings_TCC1 0 (IMP_quotient_rings_TCC1-1 nil 3757773133 ("" (rewrite "fullsetT_is_ring") nil nil) ((fullsetT_is_ring formula-decl nil ring_2nd_3rd_isomorphism_theorems nil)) nil (IMP_quotient_rings assuming "quotient_rings[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+, ring_2nd_3rd_isomorphism_theorems.*, ring_2nd_3rd_isomorphism_theorems.zero].quotient_rings" "fullset_is_ring: ASSUMPTION ring_def[quotient_rings.T, quotient_rings.+, quotient_rings.*, quotient_rings.zero].ring?(sets[quotient_rings.T].fullset)"))) (S_TCC1 0 (S_TCC1-1 nil 3757773133 ("" (rewrite "fullsetD_is_ring") nil nil) ((fullsetD_is_ring formula-decl nil ring_2nd_3rd_isomorphism_theorems nil)) nil (S assuming "ring[ring_2nd_3rd_isomorphism_theorems.D, ring_2nd_3rd_isomorphism_theorems.s, ring_2nd_3rd_isomorphism_theorems.p, ring_2nd_3rd_isomorphism_theorems.zerod].ring" "fullset_is_ring: ASSUMPTION ring_def[ring.T, ring.+, ring.*, ring.zero].ring?(sets[ring.T].fullset)"))) (second_isomorphism_th_ax_TCC1 0 (second_isomorphism_th_ax_TCC1-1 nil 3757773133 ("" (skosimp*) (("" (inst 1 "I!1") (("" (rewrite "ideal_is_coset") (("1" (hide 2) (("1" (lemma "sum_is_ideal") (("1" (inst?) (("1" (inst -1 "R!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "sum_subring_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) (("2" (expand "subring?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (coset? const-decl "bool" cosets_def nil) (sum const-decl "set[T]" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (H!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (subring? const-decl "bool" ring_def nil) (sum_subring_ideal formula-decl nil ring_cosets_lemmas nil) (sum_is_ideal formula-decl nil ring_cosets_lemmas nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil)) nil (second_isomorphism_th_ax existence "" "coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)"))) (second_isomorphism_th_ax_TCC2 0 (second_isomorphism_th_ax_TCC2-1 nil 3757773133 ("" (skosimp*) (("" (lemma "coset_add") (("" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "sum_is_ideal") (("2" (inst -1 "H!1" "I!1" "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "sum_subring_ideal") (("3" (inst -1 "H!1" "I!1" "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_add formula-decl nil quotient_rings nil) (subring? const-decl "bool" ring_def nil) (sum_subring_ideal formula-decl nil ring_cosets_lemmas nil) (sum_is_ideal formula-decl nil ring_cosets_lemmas nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ideal? const-decl "bool" ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (sum const-decl "set[T]" cosets_def nil) (H!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil)) nil (second_isomorphism_th_ax subtype "cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)" "[[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I), coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)] -> coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)]"))) (second_isomorphism_th_ax_TCC3 0 (second_isomorphism_th_ax_TCC3-1 nil 3757773133 ("" (skosimp*) (("" (lemma "coset_product") (("" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "sum_is_ideal") (("2" (inst -1 "H!1" "I!1" "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "sum_subring_ideal") (("3" (inst -1 "H!1" "I!1" "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_product formula-decl nil quotient_rings nil) (subring? const-decl "bool" ring_def nil) (sum_subring_ideal formula-decl nil ring_cosets_lemmas nil) (sum_is_ideal formula-decl nil ring_cosets_lemmas nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ideal? const-decl "bool" ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (sum const-decl "set[T]" cosets_def nil) (H!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil)) nil (second_isomorphism_th_ax subtype "product_coset_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+, ring_2nd_3rd_isomorphism_theorems.*].product(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)" "[[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I), coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)] -> coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)]"))) (second_isomorphism_th_ax_TCC4 0 (second_isomorphism_th_ax_TCC4-1 nil 3757773133 ("" (skosimp*) (("" (rewrite "ideal_is_coset") (("1" (hide 2) (("1" (lemma "sum_is_ideal") (("1" (inst -1 "H!1" "I!1" "R!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "sum_subring_ideal") (("2" (inst -1 "H!1" "I!1" "R!1") (("2" (assert) (("2" (expand "subring?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (sum const-decl "set[T]" cosets_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (sum_is_ideal formula-decl nil ring_cosets_lemmas nil) (sum_subring_ideal formula-decl nil ring_cosets_lemmas nil) (subring? const-decl "bool" ring_def nil)) nil (second_isomorphism_th_ax subtype "ring_2nd_3rd_isomorphism_theorems.I" "coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)"))) (second_isomorphism_th_ax_TCC5 0 (second_isomorphism_th_ax_TCC5-1 nil 3757773133 ("" (skosimp*) (("" (split) (("1" (skosimp) (("1" (expand "restrict") (("1" (typepred "phi!1(x1!1)") (("1" (expand "/" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (grind) nil nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (set type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (/ const-decl "setof[set[T]]" cosets_def nil) (sum const-decl "set[T]" cosets_def nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (surjective? const-decl "bool" functions nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (product const-decl "set[T]" product_coset_def nil) (lproduct const-decl "set[T]" product_coset_def nil) (coset? const-decl "bool" cosets_def nil) (right_coset? const-decl "bool" cosets_def nil) (left_coset? const-decl "bool" cosets_def nil) (add const-decl "set[T]" cosets_def nil) (lc_gen const-decl "T" cosets_def nil) (star_closed? const-decl "bool" groupoid_def nil) (member const-decl "bool" sets nil)) nil (second_isomorphism_th_ax subtype "ring_2nd_3rd_isomorphism_theorems.phi" "R_homomorphism[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+, ring_2nd_3rd_isomorphism_theorems.*, ring_2nd_3rd_isomorphism_theorems.zero, coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I), cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I), product_coset_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+, ring_2nd_3rd_isomorphism_theorems.*].product(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I](ring_2nd_3rd_isomorphism_theorems.H, restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)))"))) (second_isomorphism_th_ax 0 (second_isomorphism_th_ax-3 "" 3883100092 ("" (skosimp) (("" (inst 1 "(LAMBDA (h:(H!1)): h+I!1)") (("1" (case "R_homomorphism?[T, +, *, zero, coset[T, +](sum(H!1, I!1), I!1),
                                      add(sum(H!1, I!1), I!1), product(sum(H!1, I!1), I!1), I!1](H!1,sum(H!1, I!1) / I!1)(LAMBDA (h: (H!1)): h + I!1)") (("1" (split) (("1" (expand "R_epimorphism?") (("1" (split) (("1" (expand "surjective?") (("1" (skosimp) (("1" (typepred "y!1") (("1" (lemma "lcoset_iff_coset") (("1" (inst -1 "y!1" "I!1" "sum(H!1, I!1)") (("1" (assert) (("1" (expand "left_coset?") (("1" (skosimp) (("1" (typepred "a!1") (("1" (expand "sum") (("1" (skosimp) (("1" (replaces -1) (("1" (replaces -1) (("1" (inst 1 "h!1") (("1" (hide -1 -2) (("1" (decompose-equality) (("1" (iff) (("1" (prop) (("1" (expand "+") (("1" (skosimp) (("1" (inst 1 "inv(k!1)+h!2") (("1" (rewrite "plus_associative") (("1" (rewrite "plus_associative" :dir rl) nil nil)) nil) ("2" (rewrite "ideal_equiv") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "h!2" "k!1" "h!1") (("1" (rewrite "plus_commutative" 1) (("1" (assert) nil nil)) nil) ("2" (expand "subring?") (("2" (expand "subset?") (("2" (flatten) (("2" (inst -3 "h!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "+") (("2" (skosimp) (("2" (inst 1 "k!1 + h!2") (("1" (rewrite "plus_associative" -1) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide-all-but (-5 1)) (("2" (lemma "R_sum_star_closed[T,+,*,zero]") (("2" (inst -1 "I!1" "k!1" "h!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (decompose-equality) (("1" (iff) (("1" (prop) (("1" (expand "R_kernel") (("1" (flatten) (("1" (expand "intersection") (("1" (hide -2 -4) (("1" (assert) (("1" (lemma "self_coset") (("1" (inst -1 "I!1" "R!1" "x!1") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "R_kernel") (("2" (expand "intersection") (("2" (expand "member") (("2" (prop) (("1" (expand "restrict") (("1" (expand "/") (("1" (lemma "lcoset_iff_coset") (("1" (inst -1 "I!1" "I!1" "sum(H!1,I!1)") (("1" (assert) (("1" (expand "left_coset?") (("1" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (expand "sum") (("2" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (hide-all-but (-4 1)) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (hide-all-but (-4 1)) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst -1 "H!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "self_coset") (("2" (inst -1 "I!1" "R!1" "x!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (inst 1 "zero+I!1") (("2" (lemma "lcoset_iff_coset") (("2" (inst -1 "zero+I!1" "I!1" "sum(H!1,I!1)") (("2" (assert) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("2" (expand "sum") (("2" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst -1 "H!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1) (("3" (lemma "lcoset_iff_coset") (("3" (inst -1 "I!1" "I!1" "sum(H!1,I!1)") (("3" (assert) (("3" (expand "left_coset?") (("3" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (expand "sum") (("2" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (hide 2) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst -1 "H!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (lemma "coset_product") (("4" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide -1) (("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skosimp) (("5" (lemma "coset_add") (("5" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -1 2) (("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (lemma "lcoset_iff_coset") (("6" (expand "restrict") (("6" (expand "/") (("6" (hide -1 -2) (("6" (skosimp) (("6" (case "coset?[T, +](sum[T, +](H!1, I!1), I!1)((+[T, +])(h!1, I!1))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "lcoset_iff_coset" :dir rl) (("2" (expand "left_coset?") (("2" (inst 1 "h!1") (("2" (expand "sum") (("2" (typepred "h!1") (("2" (inst 1 "h!1" "zero") (("1" (assert) nil nil) ("2" (lemma "zero_is_member_R") (("2" (inst -1 "I!1") (("1" (expand "member") (("1" (propax) nil nil)) nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "R_homomorphism?") (("2" (split) (("1" (expand "subring?") (("1" (expand "star_closed?") (("1" (expand "ring?") (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (hide-all-but (-2 1)) (("1" (expand "star_closed?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subring?") (("2" (expand "ring?") (("2" (flatten) nil nil)) nil)) nil) ("3" (expand "star_closed?") (("3" (skosimp) (("3" (expand "member") (("3" (expand "restrict") (("3" (lemma "quotient_group_is_abelian_group") (("3" (inst -1 "sum(H!1,I!1)" "I!1") (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (hide-all-but (-1 1)) (("1" (expand "star_closed?") (("1" (inst -1 "x!1" "y!1") (("1" (expand "member") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "quotient_group_is_ring") (("4" (inst -1 "sum(H!1, I!1)" "I!1") (("1" (expand "ring?") (("1" (flatten) nil nil)) nil) ("2" (lemma "sum_is_ideal") (("2" (inst -1 "H!1" "I!1" "R!1") (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst -1 "H!1" "I!1" "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "homomorphism?") (("5" (lemma "add_charac") (("5" (skosimp) (("5" (inst -1 "sum(H!1, I!1)" "I!1" "a!1" "b!1") (("1" (assert) nil nil) ("2" (expand "sum") (("2" (inst 1 "b!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -3 -5 -6) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "sum") (("3" (inst 1 "a!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -3 -5 -6) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "sum_is_ideal") (("4" (inst -1 "H!1" "I!1" "R!1") (("4" (assert) nil nil)) nil)) nil) ("5" (lemma "sum_subring_ideal") (("5" (inst -1 "H!1" "I!1" "R!1") (("5" (assert) (("5" (expand "subring?") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "homomorphism?") (("6" (skosimp) (("6" (lemma "product_charac") (("6" (inst -1 "sum(H!1, I!1)" "I!1" "a!1" "b!1") (("1" (assert) nil nil) ("2" (expand "sum") (("2" (inst 1 "b!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -3 -5 -6) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "sum") (("3" (inst 1 "a!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -3 -5 -6) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "sum_is_ideal") (("4" (inst?) (("4" (inst -1 "R!1") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (lemma "sum_subring_ideal") (("5" (inst?) (("5" (inst -1 "R!1") (("5" (assert) (("5" (expand "subring?") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "lcoset_iff_coset") (("3" (inst -1 "I!1" "I!1" "sum(H!1,I!1)") (("3" (assert) (("3" (expand "left_coset?") (("3" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (expand "sum") (("2" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst -1 "H!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp) (("4" (lemma "coset_product") (("4" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (lemma "coset_add") (("5" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (inst 1 "zero+I!1") (("6" (lemma "lcoset_iff_coset") (("6" (inst -1 "zero+I!1" "I!1" "sum(H!1,I!1)") (("6" (assert) (("6" (expand "left_coset?") (("6" (inst 1 "zero") (("6" (expand "sum") (("6" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst -1 "H!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (expand "/") (("7" (skosimp) (("7" (lemma "lcoset_iff_coset") (("7" (inst -1 "h!1+I!1" "I!1" "sum(H!1,I!1)") (("7" (assert) (("7" (expand "left_coset?") (("7" (inst 1 "h!1") (("7" (expand "sum") (("7" (inst 1 "h!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "/") (("2" (lemma "lcoset_iff_coset") (("2" (inst -1 "h!1+I!1" "I!1" "sum(H!1,I!1)") (("2" (assert) (("2" (expand "left_coset?") (("2" (inst 1 "h!1") (("2" (expand "sum") (("2" (inst 1 "h!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (second_isomorphism_th_ax-2 nil 3807094236 ("" (skosimp) (("" (inst 1 "(LAMBDA (h:(H!1)): h+I!1)") (("1" (case "R_homomorphism?[T, +, *, zero, coset[T, +](sum(H!1, I!1), I!1),
                                      add(sum(H!1, I!1), I!1), product(sum(H!1, I!1), I!1), I!1](H!1,sum(H!1, I!1) / I!1)(LAMBDA (h: (H!1)): h + I!1)") (("1" (split) (("1" (expand "R_epimorphism?") (("1" (split) (("1" (expand "surjective?") (("1" (skosimp) (("1" (typepred "y!1") (("1" (lemma "lcoset_iff_coset") (("1" (inst -1 "y!1" "I!1" "sum(H!1, I!1)") (("1" (assert) (("1" (expand "left_coset?") (("1" (skosimp) (("1" (typepred "a!1") (("1" (expand "sum") (("1" (skosimp) (("1" (replaces -1) (("1" (replaces -1) (("1" (inst 1 "h!1") (("1" (hide -1 -2) (("1" (decompose-equality) (("1" (iff) (("1" (prop) (("1" (expand "+") (("1" (skosimp) (("1" (inst 1 "inv(k!1)+h!2") (("1" (rewrite "plus_associative") (("1" (rewrite "plus_associative" :dir rl) nil nil)) nil) ("2" (rewrite "ideal_equiv") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "h!2" "k!1" "h!1") (("1" (rewrite "plus_commutative" 1) (("1" (assert) nil nil)) nil) ("2" (expand "subring?") (("2" (expand "subset?") (("2" (flatten) (("2" (inst -3 "h!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "+") (("2" (skosimp) (("2" (inst 1 "k!1 + h!2") (("1" (rewrite "plus_associative" -1) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide-all-but (-5 1)) (("2" (lemma "R_sum_star_closed[T,+,*,zero]") (("2" (inst -1 "I!1" "k!1" "h!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (decompose-equality) (("1" (iff) (("1" (prop) (("1" (expand "R_kernel") (("1" (flatten) (("1" (expand "intersection") (("1" (hide -2 -4) (("1" (assert) (("1" (lemma "self_coset") (("1" (inst -1 "I!1" "R!1" "x!1") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "R_kernel") (("2" (expand "intersection") (("2" (expand "member") (("2" (prop) (("1" (expand "restrict") (("1" (expand "/") (("1" (lemma "lcoset_iff_coset") (("1" (inst -1 "I!1" "I!1" "sum(H!1,I!1)") (("1" (assert) (("1" (expand "left_coset?") (("1" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (expand "sum") (("2" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (hide-all-but (-4 1)) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (hide-all-but (-4 1)) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst -1 "H!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "self_coset") (("2" (inst -1 "I!1" "R!1" "x!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma "lcoset_iff_coset") (("2" (inst -1 "I!1" "I!1" "sum(H!1,I!1)") (("2" (assert) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (expand "sum") (("2" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (hide 2) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst -1 "H!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (lemma "coset_product") (("3" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide -1) (("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (lemma "coset_add") (("4" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -1 2) (("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (lemma "lcoset_iff_coset") (("5" (expand "restrict") (("5" (expand "/") (("5" (hide -1 -2) (("5" (skosimp) (("5" (case "coset?[T, +](sum[T, +](H!1, I!1), I!1)((+[T, +])(h!1, I!1))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "lcoset_iff_coset" :dir rl) (("2" (expand "left_coset?") (("2" (inst 1 "h!1") (("2" (expand "sum") (("2" (typepred "h!1") (("2" (inst 1 "h!1" "zero") (("1" (assert) nil nil) ("2" (lemma "zero_is_member_R") (("2" (inst -1 "I!1") (("1" (expand "member") (("1" (propax) nil nil)) nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "R_homomorphism?") (("2" (split) (("1" (expand "subring?") (("1" (expand "star_closed?") (("1" (expand "ring?") (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (hide-all-but (-2 1)) (("1" (expand "star_closed?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subring?") (("2" (expand "ring?") (("2" (flatten) nil nil)) nil)) nil) ("3" (expand "star_closed?") (("3" (skosimp) (("3" (expand "member") (("3" (expand "restrict") (("3" (lemma "quotient_group_is_abelian_group") (("3" (inst -1 "sum(H!1,I!1)" "I!1") (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (hide-all-but (-1 1)) (("1" (expand "star_closed?") (("1" (inst -1 "x!1" "y!1") (("1" (expand "member") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "quotient_group_is_ring") (("4" (inst -1 "sum(H!1, I!1)" "I!1") (("1" (expand "ring?") (("1" (flatten) nil nil)) nil) ("2" (lemma "sum_is_ideal") (("2" (inst -1 "H!1" "I!1" "R!1") (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst -1 "H!1" "I!1" "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "homomorphism?") (("5" (lemma "add_charac") (("5" (skosimp) (("5" (inst -1 "sum(H!1, I!1)" "I!1" "a!1" "b!1") (("1" (assert) nil nil) ("2" (expand "sum") (("2" (inst 1 "b!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -3 -5 -6) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "sum") (("3" (inst 1 "a!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -3 -5 -6) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "sum_is_ideal") (("4" (inst -1 "H!1" "I!1" "R!1") (("4" (assert) nil nil)) nil)) nil) ("5" (lemma "sum_subring_ideal") (("5" (inst -1 "H!1" "I!1" "R!1") (("5" (assert) (("5" (expand "subring?") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "homomorphism?") (("6" (skosimp) (("6" (lemma "product_charac") (("6" (inst -1 "sum(H!1, I!1)" "I!1" "a!1" "b!1") (("1" (assert) nil nil) ("2" (expand "sum") (("2" (inst 1 "b!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -3 -5 -6) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "sum") (("3" (inst 1 "a!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -3 -5 -6) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "sum_is_ideal") (("4" (inst?) (("4" (inst -1 "R!1") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (lemma "sum_subring_ideal") (("5" (inst?) (("5" (inst -1 "R!1") (("5" (assert) (("5" (expand "subring?") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "lcoset_iff_coset") (("3" (inst -1 "I!1" "I!1" "sum(H!1,I!1)") (("3" (assert) (("3" (expand "left_coset?") (("3" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (expand "sum") (("2" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst -1 "H!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp) (("4" (lemma "coset_product") (("4" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (lemma "coset_add") (("5" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (inst 1 "zero+I!1") (("6" (lemma "lcoset_iff_coset") (("6" (inst -1 "zero+I!1" "I!1" "sum(H!1,I!1)") (("6" (assert) (("6" (expand "left_coset?") (("6" (inst 1 "zero") (("6" (expand "sum") (("6" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst -1 "H!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (expand "/") (("7" (skosimp) (("7" (lemma "lcoset_iff_coset") (("7" (inst -1 "h!1+I!1" "I!1" "sum(H!1,I!1)") (("7" (assert) (("7" (expand "left_coset?") (("7" (inst 1 "h!1") (("7" (expand "sum") (("7" (inst 1 "h!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "/") (("2" (lemma "lcoset_iff_coset") (("2" (inst -1 "h!1+I!1" "I!1" "sum(H!1,I!1)") (("2" (assert) (("2" (expand "left_coset?") (("2" (inst 1 "h!1") (("2" (expand "sum") (("2" (inst 1 "h!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((+ const-decl "set[T]" cosets_def nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (sum const-decl "set[T]" cosets_def nil) (/ const-decl "setof[set[T]]" cosets_def nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (setof type-eq-decl nil defined_types nil) (H!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (h!1 skolem-const-decl "(H!1)" ring_2nd_3rd_isomorphism_theorems nil) (star_closed? const-decl "bool" groupoid_def nil) (abelian_group? const-decl "bool" group_def nil) (monoid? const-decl "bool" monoid_def nil) (monad? const-decl "bool" monad_def nil) (group? const-decl "bool" group_def nil) (quotient_group_is_abelian_group formula-decl nil quotient_rings nil) (quotient_group_is_ring formula-decl nil quotient_rings nil) (add_charac formula-decl nil quotient_rings nil) (a!1 skolem-const-decl "(H!1)" ring_2nd_3rd_isomorphism_theorems nil) (b!1 skolem-const-decl "(H!1)" ring_2nd_3rd_isomorphism_theorems nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (a!1 skolem-const-decl "(H!1)" ring_2nd_3rd_isomorphism_theorems nil) (b!1 skolem-const-decl "(H!1)" ring_2nd_3rd_isomorphism_theorems nil) (product_charac formula-decl nil quotient_rings nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (ideal_equiv formula-decl nil ring_ideal nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (subring? const-decl "bool" ring_def nil) (subset? const-decl "bool" sets nil) (plus_commutative formula-decl nil ring nil) (h!1 skolem-const-decl "(H!1)" ring_2nd_3rd_isomorphism_theorems nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil) (plus_associative formula-decl nil ring nil) (negate_is_right_inv formula-decl nil ring nil) (zero_plus formula-decl nil ring nil) (h!2 skolem-const-decl "(I!1)" ring_2nd_3rd_isomorphism_theorems nil) (k!1 skolem-const-decl "(I!1)" ring_2nd_3rd_isomorphism_theorems nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (h!2 skolem-const-decl "(I!1)" ring_2nd_3rd_isomorphism_theorems nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (ideal? const-decl "bool" ring_ideal_def nil) (left_coset? const-decl "bool" cosets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (surjective? const-decl "bool" functions nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (h!1 skolem-const-decl "(H!1)" ring_2nd_3rd_isomorphism_theorems nil) (coset_add formula-decl nil quotient_rings nil) (ideal type-eq-decl nil ring_ideal_def nil) (sum_is_ideal formula-decl nil ring_cosets_lemmas nil) (sum_subring_ideal formula-decl nil ring_cosets_lemmas nil) (coset_product formula-decl nil quotient_rings nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (plus_zero formula-decl nil ring nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (intersection const-decl "set" sets nil) (TRUE const-decl "bool" booleans nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (add const-decl "set[T]" cosets_def nil) (product const-decl "set[T]" product_coset_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (restrict const-decl "R" restrict nil) (h!1 skolem-const-decl "(H!1)" ring_2nd_3rd_isomorphism_theorems nil)) nil) (second_isomorphism_th_ax-1 nil 3758880532 ("" (skosimp) (("" (inst 1 "(LAMBDA (h:(H!1)): h+I!1)") (("1" (case "R_homomorphism?[T, +, *, zero, coset[T, +](sum(H!1, I!1), I!1),
                             add(sum(H!1, I!1), I!1), product(sum(H!1, I!1), I!1), I!1](H!1,sum(H!1, I!1) / I!1)(LAMBDA (h: (H!1)): h + I!1)") (("1" (split) (("1" (expand "R_epimorphism?") (("1" (split) (("1" (expand "surjective?") (("1" (skosimp) (("1" (typepred "y!1") (("1" (lemma "lcoset_iff_coset") (("1" (inst -1 "y!1" "I!1" "sum(H!1, I!1)") (("1" (assert) (("1" (expand "left_coset?") (("1" (skosimp) (("1" (typepred "a!1") (("1" (expand "sum") (("1" (skosimp) (("1" (replaces -1) (("1" (replaces -1) (("1" (inst 1 "h!1") (("1" (hide -1 -2) (("1" (decompose-equality) (("1" (iff) (("1" (prop) (("1" (expand "+") (("1" (skosimp) (("1" (inst 1 "-k!1+h!2") (("1" (rewrite "plus_associative") (("1" (rewrite "plus_associative" :dir rl) nil nil)) nil) ("2" (rewrite "ideal_equiv") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "h!2" "k!1" "h!1") (("1" (rewrite "plus_commutative" 1) (("1" (assert) nil nil)) nil) ("2" (expand "subring?") (("2" (expand "subset?") (("2" (flatten) (("2" (inst -3 "h!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "+") (("2" (skosimp) (("2" (inst 1 "k!1 + h!2") (("1" (rewrite "plus_associative" -1) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide-all-but (-5 1)) (("2" (lemma "R_sum_star_closed[T,+,*,zero]") (("2" (inst -1 "I!1" "k!1" "h!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (decompose-equality) (("1" (iff) (("1" (prop) (("1" (expand "R_kernel") (("1" (flatten) (("1" (expand "intersection") (("1" (hide -2 -4) (("1" (assert) (("1" (lemma "self_coset") (("1" (inst -1 "I!1" "R!1" "x!1") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "R_kernel") (("2" (expand "intersection") (("2" (expand "member") (("2" (prop) (("1" (expand "restrict") (("1" (expand "/") (("1" (lemma "lcoset_iff_coset") (("1" (inst -1 "I!1" "I!1" "sum(H!1,I!1)") (("1" (assert) (("1" (expand "left_coset?") (("1" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (expand "sum") (("2" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (hide-all-but (-4 1)) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (hide-all-but (-4 1)) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst -1 "H!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "self_coset") (("2" (inst -1 "I!1" "R!1" "x!1") (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma "lcoset_iff_coset") (("2" (inst -1 "I!1" "I!1" "sum(H!1,I!1)") (("2" (assert) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (expand "sum") (("2" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (hide 2) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst -1 "H!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (lemma "coset_product") (("3" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide -1) (("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (lemma "coset_add") (("4" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -1 2) (("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (lemma "lcoset_iff_coset") (("5" (expand "restrict") (("5" (expand "/") (("5" (hide -1 -2) (("5" (skosimp) (("5" (case "coset?[T, +](sum[T, +](H!1, I!1), I!1)((+[T, +])(h!1, I!1))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "lcoset_iff_coset" :dir rl) (("2" (expand "left_coset?") (("2" (inst 1 "h!1") (("2" (expand "sum") (("2" (typepred "h!1") (("2" (inst 1 "h!1" "zero") (("1" (assert) nil nil) ("2" (lemma "zero_is_member_R") (("2" (inst -1 "I!1") (("1" (expand "member") (("1" (propax) nil nil)) nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "R_homomorphism?") (("2" (split) (("1" (expand "subring?") (("1" (expand "star_closed?") (("1" (expand "ring?") (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (hide-all-but (-2 1)) (("1" (expand "star_closed?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subring?") (("2" (expand "ring?") (("2" (flatten) nil nil)) nil)) nil) ("3" (expand "star_closed?") (("3" (skosimp) (("3" (expand "member") (("3" (expand "restrict") (("3" (lemma "quotient_group_is_abelian_group") (("3" (inst -1 "sum(H!1,I!1)" "I!1") (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (hide-all-but (-1 1)) (("1" (expand "star_closed?") (("1" (inst -1 "x!1" "y!1") (("1" (expand "member") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "quotient_group_is_ring") (("4" (inst -1 "sum(H!1, I!1)" "I!1") (("1" (expand "ring?") (("1" (flatten) nil nil)) nil) ("2" (lemma "sum_is_ideal") (("2" (inst -1 "H!1" "I!1" "R!1") (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst -1 "H!1" "I!1" "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "homomorphism?") (("5" (lemma "add_charac") (("5" (skosimp) (("5" (inst -1 "sum(H!1, I!1)" "I!1" "a!1" "b!1") (("1" (assert) nil nil) ("2" (expand "sum") (("2" (inst 1 "b!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -3 -5 -6) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "sum") (("3" (inst 1 "a!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -3 -5 -6) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "sum_is_ideal") (("4" (inst -1 "H!1" "I!1" "R!1") (("4" (assert) nil nil)) nil)) nil) ("5" (lemma "sum_subring_ideal") (("5" (inst -1 "H!1" "I!1" "R!1") (("5" (assert) (("5" (expand "subring?") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "homomorphism?") (("6" (skosimp) (("6" (lemma "product_charac") (("6" (inst -1 "sum(H!1, I!1)" "I!1" "a!1" "b!1") (("1" (assert) nil nil) ("2" (expand "sum") (("2" (inst 1 "b!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -3 -5 -6) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "sum") (("3" (inst 1 "a!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -3 -5 -6) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "sum_is_ideal") (("4" (inst?) (("4" (inst -1 "R!1") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (lemma "sum_subring_ideal") (("5" (inst?) (("5" (inst -1 "R!1") (("5" (assert) (("5" (expand "subring?") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "lcoset_iff_coset") (("3" (inst -1 "I!1" "I!1" "sum(H!1,I!1)") (("3" (assert) (("3" (expand "left_coset?") (("3" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (expand "sum") (("2" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst -1 "H!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp) (("4" (lemma "coset_product") (("4" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (lemma "coset_add") (("5" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (lemma "sum_is_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst?) (("3" (inst -1 "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (inst 1 "zero+I!1") (("6" (lemma "lcoset_iff_coset") (("6" (inst -1 "zero+I!1" "I!1" "sum(H!1,I!1)") (("6" (assert) (("6" (expand "left_coset?") (("6" (inst 1 "zero") (("6" (expand "sum") (("6" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst -1 "H!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (expand "/") (("7" (skosimp) (("7" (lemma "lcoset_iff_coset") (("7" (inst -1 "h!1+I!1" "I!1" "sum(H!1,I!1)") (("7" (assert) (("7" (expand "left_coset?") (("7" (inst 1 "h!1") (("7" (expand "sum") (("7" (inst 1 "h!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "/") (("2" (lemma "lcoset_iff_coset") (("2" (inst -1 "h!1+I!1" "I!1" "sum(H!1,I!1)") (("2" (assert) (("2" (expand "left_coset?") (("2" (inst 1 "h!1") (("2" (expand "sum") (("2" (inst 1 "h!1" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "I!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sum const-decl "set[T]" cosets_def nil) (/ const-decl "setof[set[T]]" cosets_def nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (setof type-eq-decl nil defined_types nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (quotient_group_is_abelian_group formula-decl nil quotient_rings nil) (quotient_group_is_ring formula-decl nil quotient_rings nil) (add_charac formula-decl nil quotient_rings nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (product_charac formula-decl nil quotient_rings nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (ideal_equiv formula-decl nil ring_ideal nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (ideal? const-decl "bool" ring_ideal_def nil) (left_coset? const-decl "bool" cosets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (surjective? const-decl "bool" functions nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (coset_add formula-decl nil quotient_rings nil) (ideal type-eq-decl nil ring_ideal_def nil) (sum_is_ideal formula-decl nil ring_cosets_lemmas nil) (sum_subring_ideal formula-decl nil ring_cosets_lemmas nil) (coset_product formula-decl nil quotient_rings nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (intersection const-decl "set" sets nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (TRUE const-decl "bool" booleans nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (add const-decl "set[T]" cosets_def nil) (product const-decl "set[T]" product_coset_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (restrict const-decl "R" restrict nil)) nil)) (second_isomorphism_th_TCC1 0 (second_isomorphism_th_TCC1-1 nil 3757773133 ("" (skosimp) (("" (inst 1 " intersection(H!1, I!1)") (("" (rewrite "ideal_is_coset") (("1" (hide 2) (("1" (lemma "intersection_subring_ideal") (("1" (inst -1 "H!1" "I!1" "R!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subring?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (coset? const-decl "bool" cosets_def nil) (intersection const-decl "set" sets nil) (coset type-eq-decl nil cosets_def nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (H!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (subring? const-decl "bool" ring_def nil) (intersection_subring_ideal formula-decl nil ring_ideal nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil)) nil (second_isomorphism_th existence "" "coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.H, sets[ring_2nd_3rd_isomorphism_theorems.T].intersection(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I))"))) (second_isomorphism_th_TCC2 0 (second_isomorphism_th_TCC2-1 nil 3757773133 ("" (skosimp*) (("" (lemma "coset_add") (("" (inst -1 "H!1" "intersection(H!1, I!1)" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "intersection_subring_ideal") (("2" (inst -1 "H!1" "I!1" "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "subring?") (("3" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_add formula-decl nil quotient_rings nil) (subring? const-decl "bool" ring_def nil) (intersection_subring_ideal formula-decl nil ring_ideal nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ideal? const-decl "bool" ring_ideal_def nil) (intersection const-decl "set" sets nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (H!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil)) nil (second_isomorphism_th subtype "cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.H, sets[ring_2nd_3rd_isomorphism_theorems.T].intersection(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I))" "[[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.H, sets[ring_2nd_3rd_isomorphism_theorems.T].intersection(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I)), coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.H, sets[ring_2nd_3rd_isomorphism_theorems.T].intersection(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I))] -> coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.H, sets[ring_2nd_3rd_isomorphism_theorems.T].intersection(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I))]"))) (second_isomorphism_th_TCC3 0 (second_isomorphism_th_TCC3-1 nil 3757773133 ("" (skosimp*) (("" (lemma "coset_product") (("" (inst -1 "H!1" "intersection(H!1, I!1)" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "intersection_subring_ideal") (("2" (inst -1 "H!1" "I!1" "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "subring?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_product formula-decl nil quotient_rings nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subring? const-decl "bool" ring_def nil) (intersection_subring_ideal formula-decl nil ring_ideal nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ideal? const-decl "bool" ring_ideal_def nil) (intersection const-decl "set" sets nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (H!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil)) nil (second_isomorphism_th subtype "product_coset_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+, ring_2nd_3rd_isomorphism_theorems.*].product(ring_2nd_3rd_isomorphism_theorems.H, sets[ring_2nd_3rd_isomorphism_theorems.T].intersection(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I))" "[[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.H, sets[ring_2nd_3rd_isomorphism_theorems.T].intersection(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I)), coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.H, sets[ring_2nd_3rd_isomorphism_theorems.T].intersection(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I))] -> coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.H, sets[ring_2nd_3rd_isomorphism_theorems.T].intersection(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I))]"))) (second_isomorphism_th_TCC4 0 (second_isomorphism_th_TCC4-1 nil 3757773133 ("" (skosimp) (("" (rewrite "ideal_is_coset") (("1" (hide 2) (("1" (lemma "intersection_subring_ideal") (("1" (inst -1 "H!1" "I!1" "R!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subring?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ((ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (intersection const-decl "set" sets nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (intersection_subring_ideal formula-decl nil ring_ideal nil) (subring? const-decl "bool" ring_def nil)) nil (second_isomorphism_th subtype "sets[ring_2nd_3rd_isomorphism_theorems.T].intersection(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I)" "coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.H, sets[ring_2nd_3rd_isomorphism_theorems.T].intersection(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I))"))) (second_isomorphism_th_TCC5 0 (second_isomorphism_th_TCC6-1 nil 3757773133 ("" (skosimp*) (("" (lemma "coset_add") (("" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "sum_is_ideal") (("2" (inst -1 "H!1" "I!1" "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "sum_subring_ideal") (("3" (inst -1 "H!1" "I!1" "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_add formula-decl nil quotient_rings nil) (subring? const-decl "bool" ring_def nil) (sum_subring_ideal formula-decl nil ring_cosets_lemmas nil) (sum_is_ideal formula-decl nil ring_cosets_lemmas nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ideal? const-decl "bool" ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (sum const-decl "set[T]" cosets_def nil) (H!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil)) nil (second_isomorphism_th subtype "cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)" "[[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I), coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)] -> coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)]"))) (second_isomorphism_th_TCC6 0 (second_isomorphism_th_TCC7-1 nil 3757773133 ("" (skosimp*) (("" (lemma "coset_product") (("" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "sum_is_ideal") (("2" (inst -1 "H!1" "I!1" "R!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "sum_subring_ideal") (("3" (inst -1 "H!1" "I!1" "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_product formula-decl nil quotient_rings nil) (subring? const-decl "bool" ring_def nil) (sum_subring_ideal formula-decl nil ring_cosets_lemmas nil) (sum_is_ideal formula-decl nil ring_cosets_lemmas nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ideal? const-decl "bool" ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (sum const-decl "set[T]" cosets_def nil) (H!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil)) nil (second_isomorphism_th subtype "product_coset_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+, ring_2nd_3rd_isomorphism_theorems.*].product(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)" "[[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I), coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)] -> coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)]"))) (second_isomorphism_th_TCC7 0 (second_isomorphism_th_TCC8-1 nil 3757773133 ("" (skosimp) (("" (rewrite "ideal_is_coset") (("1" (hide 2) (("1" (lemma "sum_is_ideal") (("1" (inst?) (("1" (inst -1 "R!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "sum_subring_ideal") (("2" (inst?) (("2" (inst -1 "R!1") (("2" (assert) (("2" (expand "subring?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (sum const-decl "set[T]" cosets_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (sum_is_ideal formula-decl nil ring_cosets_lemmas nil) (sum_subring_ideal formula-decl nil ring_cosets_lemmas nil) (subring? const-decl "bool" ring_def nil)) nil (second_isomorphism_th subtype "ring_2nd_3rd_isomorphism_theorems.I" "coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].sum(ring_2nd_3rd_isomorphism_theorems.H, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I)"))) (second_isomorphism_th 0 (second_isomorphism_th-1 nil 3757773174 ("" (skosimp) (("" (name-replace "A" "restrict
                   [set[T], coset[T, +](H!1, intersection(H!1, I!1)), boolean]
                   (H!1 / intersection(H!1, I!1))" :hide? nil) (("" (name-replace "B" "restrict[set[T], coset[T, +](sum(H!1, I!1), I!1), boolean]
                   (sum(H!1, I!1) / I!1)" :hide? nil) (("" (lemma "second_isomorphism_th_ax") (("" (inst -1 "H!1" "I!1" "R!1") (("" (assert) (("" (skosimp) (("" (replace -3) (("" (lemma "first_isomorphism_th[T, +, *, zero, coset[T, +](sum(H!1, I!1), I!1),
               add(sum(H!1, I!1), I!1), product(sum(H!1, I!1), I!1), I!1]") (("1" (inst -1 "H!1" "B" "phi!1") (("1" (replace -3 -1) (("1" (expand "R_isomorphic?") (("1" (skosimp) (("1" (inst 1 "phi!2") (("1" (expand "R_isomorphism?") (("1" (expand "R_monomorphism?") (("1" (expand "R_epimorphism?") (("1" (case "R_homomorphism?[coset(H!1,intersection(H!1,I!1)),add(H!1,intersection(H!1,I!1)),product(H!1,intersection(H!1,I!1)),intersection(H!1,I!1),coset(sum(H!1,I!1),I!1),add(sum(H!1,I!1),I!1),product(sum(H!1,I!1),I!1),I!1](A, B)(phi!2)") (("1" (assert) (("1" (flatten) (("1" (split) (("1" (hide-all-but (-2 1)) (("1" (expand "injective?") (("1" (skosimp) (("1" (inst -2 "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -6 1)) (("2" (expand "surjective?") (("2" (skosimp) (("2" (inst -1 "y!1") (("1" (hide -2) (("1" (skosimp) (("1" (inst 1 "x!1") (("1" (typepred "x!1") (("1" (expand "restrict") (("1" (expand "A") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (expand "image") (("2" (expand "image") (("2" (inst -1 "y!1") (("2" (skosimp) (("2" (inst 1 "x!1") (("1" (assert) nil nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide-all-but (-2 -5 -6 -7 -10 -11 1)) (("2" (expand "R_homomorphism?") (("2" (flatten) (("2" (split) (("1" (hide-all-but (-1 -7 -14 -15 -16 1)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (inst -1 "x!1" "y!1") (("1" (expand "member") (("1" (expand "restrict") (("1" (expand "A") (("1" (expand "restrict") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (expand "/") (("2" (typepred "y!1") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (expand "restrict") (("3" (expand "/") (("3" (typepred "x!1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -8 -9 -14 -15 -16 1)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (inst -1 "x!1" "y!1") (("1" (expand "member") (("1" (expand "restrict") (("1" (expand "A") (("1" (expand "restrict") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (expand "/") (("2" (typepred "y!1") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (expand "restrict") (("3" (expand "/") (("3" (typepred "x!1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (propax) nil nil) ("5" (expand "homomorphism?") (("5" (hide-all-but (-1-2 -5 -12 -14 -15 -16 1)) (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("6" (expand "homomorphism?") (("6" (hide-all-but (-1 -2 -6 -13 -14 -15 -16 1)) (("6" (skosimp) (("6" (inst -3 "a!1" "b!1") (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 2) (("3" (lemma "lcoset_iff_coset") (("3" (inst -1 "intersection[T](H!1, I!1)" "intersection[T](H!1, I!1)" "H!1") (("3" (assert) (("3" (expand "left_coset?") (("3" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (expand "subring?") (("2" (flatten) (("2" (hide-all-but (-5 1)) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (lemma "coset_product") (("4" (hide-all-but (-1 -8 -11 -12 1)) (("4" (inst -1 "H!1" "intersection(H!1, I!1)" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (lemma "intersection_subring_ideal" ("H" "H!1" "R" "R!1" "I" "I!1")) (("2" (assert) nil nil)) nil) ("3" (expand "subring?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-3 -6 -7 1)) (("5" (skosimp) (("5" (lemma "coset_add") (("5" (inst -1 "H!1" " intersection[T](H!1, I!1)" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (lemma "intersection_subring_ideal" ("H" "H!1" "R" "R!1" "I" "I!1")) (("2" (assert) nil nil)) nil) ("3" (expand "subring?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide -1 -2 2) (("6" (inst 1 "intersection(H!1,I!1)") (("6" (lemma "lcoset_iff_coset") (("6" (inst -1 "intersection[T](H!1, I!1)" "intersection[T](H!1, I!1)" "H!1") (("6" (assert) (("6" (expand "left_coset?") (("6" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (expand "subring?") (("2" (flatten) (("2" (hide-all-but (-5 1)) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (split) (("1" (expand "restrict") (("1" (expand "/" 1) (("1" (skosimp) (("1" (hide -1 -2 -3 -4 -5 -6 -8 -9 2) (("1" (prop) (("1" (expand "A") (("1" (expand "restrict") (("1" (expand "/") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "B" 1) (("2" (expand "restrict") (("2" (expand "surjective?" -5) (("2" (typepred "x1!1") (("2" (expand "/" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (split) (("1" (expand "/" 1) (("1" (skosimp) (("1" (prop) (("1" (expand "A") (("1" (expand "restrict") (("1" (expand "/" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "B" 1) (("2" (expand "restrict") (("2" (hide -4 -5) (("2" (expand "/" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "B" 1) (("2" (lemma "quotient_group_is_ring") (("2" (inst -1 "sum(H!1,I!1)" "I!1") (("1" (lemma "sum_is_ideal") (("1" (inst -1 "H!1" "I!1" "R!1") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "sum_subring_ideal") (("2" (inst -1 "H!1" "I!1" "R!1") (("2" (assert) (("2" (expand "subring?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (assert) nil nil)) nil)) nil) ("2" (lemma "quotient_group_is_ring") (("2" (inst -1 "sum(H!1, I!1)" "I!1") (("1" (expand "/") (("1" (expand "ring?") (("1" (flatten) (("1" (split) (("1" (hide-all-but (-1 -6 -7 1)) (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (flatten) (("1" (split) (("1" (hide-all-but (-1 1)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (inst -1 "x!1" "y!1") (("1" (expand "member") (("1" (expand "restrict") (("1" (expand "fullset") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil) ("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "identity?") (("3" (hide-all-but (-3 1)) (("3" (skosimp) (("3" (inst -1 "x!1") (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand "associative?") (("4" (skosimp) (("4" (inst -1 "x!1" "y!1" "z!1") (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil) ("3" (expand "restrict") (("3" (propax) nil nil)) nil) ("4" (expand "restrict") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-5 1)) (("5" (expand "inv_exists?") (("5" (skosimp) (("5" (inst -1 "x!1") (("1" (skosimp) (("1" (inst 1 "y!1") (("1" (assert) nil nil) ("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-6 1)) (("6" (expand "commutative?") (("6" (skosimp) (("6" (inst -1 "x!1" "y!1") (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil) ("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (inst -1 "x!1" "y!1") (("1" (expand "member") (("1" (expand "restrict") (("1" (expand "fullset") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil) ("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (expand "associative?") (("3" (skosimp) (("3" (inst -1 "x!1" "y!1" "z!1") (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil) ("3" (expand "restrict") (("3" (propax) nil nil)) nil) ("4" (expand "restrict") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand "left_distributive?") (("4" (skosimp) (("4" (inst -1 "x!1" "y!1" "z!1") (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil) ("3" (expand "restrict") (("3" (propax) nil nil)) nil) ("4" (expand "restrict") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-5 1)) (("5" (expand "right_distributive?") (("5" (skosimp) (("5" (inst -1 "x!1" "y!1" "z!1") (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil) ("3" (expand "restrict") (("3" (propax) nil nil)) nil) ("4" (expand "restrict") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sum_is_ideal") (("2" (inst -1 "H!1" "I!1" "R!1") (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst -1 "H!1" "I!1" "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "fullsetT_is_ring") nil nil)) nil) ("4" (hide -1 -2 -3 -4 2) (("4" (lemma "lcoset_iff_coset") (("4" (inst -1 "I!1" "I!1" "sum(H!1,I!1)") (("4" (assert) (("4" (expand "left_coset?") (("4" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (expand "sum") (("2" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide-all-but (-4 1)) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skosimp) (("5" (hide-all-but (-5 -6 1)) (("5" (lemma "coset_product") (("5" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (lemma "sum_is_ideal") (("2" (inst -1 "H!1" "I!1" "R!1") (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst -1 "H!1" "I!1" "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-5 -6 1)) (("6" (skosimp) (("6" (lemma "coset_add") (("6" (inst -1 "sum(H!1,I!1)" "I!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (lemma "sum_is_ideal") (("2" (inst -1 "H!1" "I!1" "R!1") (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "sum_subring_ideal") (("3" (inst -1 "H!1" "I!1" "R!1") (("3" (assert) (("3" (expand "subring?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide -1 -2 -3 -4 2) (("7" (inst 1 "zero+I!1") (("7" (lemma "lcoset_iff_coset") (("7" (inst -1 "zero+I!1" "I!1" "sum(H!1,I!1)") (("7" (assert) (("7" (expand "left_coset?") (("7" (inst 1 "zero") (("7" (expand "sum") (("7" (inst 1 "zero" "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -1 -2 -3 -5 -6 2) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subring?") (("3" (flatten) (("3" (lemma "zero_is_member_R[T,+,*,zero]") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (coset? const-decl "bool" cosets_def nil) (intersection const-decl "set" sets nil) (coset type-eq-decl nil cosets_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (restrict const-decl "R" restrict nil) (setof type-eq-decl nil defined_types nil) (/ const-decl "setof[set[T]]" cosets_def nil) (second_isomorphism_th_ax formula-decl nil ring_2nd_3rd_isomorphism_theorems nil) (+ const-decl "set[T]" cosets_def nil) (fullsetT_is_ring formula-decl nil ring_2nd_3rd_isomorphism_theorems nil) (z!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (y!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (x!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (z!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (y!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (x!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (z!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (y!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (x!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (y!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (x!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (x!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (y!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (x!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (x!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (y!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (z!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (x!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (y!1 skolem-const-decl "(restrict[set[T], coset[T, +](sum(H!1, I!1), I!1), bool]
     ({s: set[T] | coset?[T, +](sum(H!1, I!1), I!1)(s)}))" ring_2nd_3rd_isomorphism_theorems nil) (x!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (y!1 skolem-const-decl "(fullset[coset[T, +](sum[T, +](H!1, I!1), I!1)])" ring_2nd_3rd_isomorphism_theorems nil) (H!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (B skolem-const-decl "[coset[T, +](sum(H!1, I!1), I!1) -> boolean]" ring_2nd_3rd_isomorphism_theorems nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_isomorphic? const-decl "bool" ring_homomorphisms_def nil) (phi!2 skolem-const-decl "[(restrict[set[T], coset[T, +](H!1, R_kernel(H!1, B)(phi!1)), bool]
      (H!1 / intersection(H!1, I!1))) ->
   (extend[coset[T, +](sum(H!1, I!1), I!1), (B), bool, FALSE]
        (image(phi!1)(restrict[T, (H!1), bool](H!1))))]" ring_2nd_3rd_isomorphism_theorems nil) (image const-decl "set[R]" function_image nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (A skolem-const-decl "[coset[T, +](H!1, intersection(H!1, I!1)) -> boolean]" ring_2nd_3rd_isomorphism_theorems nil) (phi!1 skolem-const-decl "[(H!1) -> (sum(H!1, I!1) / I!1)]" ring_2nd_3rd_isomorphism_theorems nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil) (image const-decl "set[R]" function_image nil) (x!1 skolem-const-decl "(H!1)" ring_2nd_3rd_isomorphism_theorems nil) (x!1 skolem-const-decl "(restrict[set[T], coset[T, +](H!1, R_kernel(H!1, B)(phi!1)), bool]
     (H!1 / intersection(H!1, I!1)))" ring_2nd_3rd_isomorphism_theorems nil) (NOT const-decl "[bool -> bool]" booleans nil) (y!1 skolem-const-decl "(B)" ring_2nd_3rd_isomorphism_theorems nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (lproduct const-decl "set[T]" product_coset_def nil) (y!1 skolem-const-decl "(A)" ring_2nd_3rd_isomorphism_theorems nil) (x!1 skolem-const-decl "(A)" ring_2nd_3rd_isomorphism_theorems nil) (member const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (lc_gen const-decl "T" cosets_def nil) (left_coset? const-decl "bool" cosets_def nil) (right_coset? const-decl "bool" cosets_def nil) (subset? const-decl "bool" sets nil) (plus_zero formula-decl nil ring nil) (zero_plus formula-decl nil ring nil) (identity? const-decl "bool" operator_defs nil) (monad? const-decl "bool" monad_def nil) (associative? const-decl "bool" operator_defs nil) (monoid? const-decl "bool" monoid_def nil) (inv_exists? const-decl "bool" group_def nil) (group? const-decl "bool" group_def nil) (commutative? const-decl "bool" operator_defs nil) (abelian_group? const-decl "bool" group_def nil) (left_distributive? const-decl "bool" operator_defs_more nil) (right_distributive? const-decl "bool" operator_defs_more nil) (subring? const-decl "bool" ring_def nil) (left_swallow? const-decl "bool" ring_ideal_def nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (right_swallow? const-decl "bool" ring_ideal_def nil) (right_ideal? const-decl "bool" ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (y!1 skolem-const-decl "(A)" ring_2nd_3rd_isomorphism_theorems nil) (x!1 skolem-const-decl "(A)" ring_2nd_3rd_isomorphism_theorems nil) (star_closed? const-decl "bool" groupoid_def nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (coset_product formula-decl nil quotient_rings nil) (ideal type-eq-decl nil ring_ideal_def nil) (intersection_subring_ideal formula-decl nil ring_ideal nil) (coset_add formula-decl nil quotient_rings nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil) (quotient_group_is_ring formula-decl nil quotient_rings nil) (sum_subring_ideal formula-decl nil ring_cosets_lemmas nil) (sum_is_ideal formula-decl nil ring_cosets_lemmas nil) (fullset const-decl "set" sets nil) (TRUE const-decl "bool" booleans nil) (product const-decl "set[T]" product_coset_def nil) (add const-decl "set[T]" cosets_def nil) (first_isomorphism_th formula-decl nil ring_1st_isomorphism_theorem nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (sum const-decl "set[T]" cosets_def nil)) shostak)) (third_isomorphism_th_ax_TCC1 0 (third_isomorphism_th_ax_TCC1-1 nil 3757773133 ("" (skosimp*) (("" (inst 1 "J!1") (("" (rewrite "ideal_is_coset") nil nil)) nil)) nil) ((T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (coset? const-decl "bool" cosets_def nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (coset type-eq-decl nil cosets_def nil) (J!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil)) nil (third_isomorphism_th_ax existence "" "coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)"))) (third_isomorphism_th_ax_TCC2 0 (third_isomorphism_th_ax_TCC2-1 nil 3757773133 ("" (skosimp*) (("" (lemma "coset_add") (("" (inst?) (("" (inst -1 "x1!1`1" "x1!1`2") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_add formula-decl nil quotient_rings nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (ideal type-eq-decl nil ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (J!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (ring nonempty-type-eq-decl nil ring nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil)) nil (third_isomorphism_th_ax subtype "cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)" "[[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)] -> coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)]"))) (third_isomorphism_th_ax_TCC3 0 (third_isomorphism_th_ax_TCC3-1 nil 3757773133 ("" (skosimp*) (("" (lemma "coset_product") (("" (inst?) (("" (inst -1 "x1!1`1" "x1!1`2") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_product formula-decl nil quotient_rings nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (ideal type-eq-decl nil ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (J!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (ring nonempty-type-eq-decl nil ring nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil)) nil (third_isomorphism_th_ax subtype "product_coset_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+, ring_2nd_3rd_isomorphism_theorems.*].product(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)" "[[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)] -> coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)]"))) (third_isomorphism_th_ax_TCC4 0 (third_isomorphism_th_ax_TCC4-1 nil 3757773133 ("" (skosimp*) (("" (rewrite "ideal_is_coset") nil nil)) nil) ((ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil)) nil (third_isomorphism_th_ax subtype "ring_2nd_3rd_isomorphism_theorems.J" "coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)"))) (third_isomorphism_th_ax_TCC5 0 (third_isomorphism_th_ax_TCC5-1 nil 3757773133 ("" (skosimp*) (("" (inst 1 "I!1") (("" (rewrite "ideal_is_coset") nil nil)) nil)) nil) ((T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (coset? const-decl "bool" cosets_def nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (coset type-eq-decl nil cosets_def nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil)) nil (third_isomorphism_th_ax existence "" "coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)"))) (third_isomorphism_th_ax_TCC6 0 (third_isomorphism_th_ax_TCC6-1 nil 3757773133 ("" (skosimp*) (("" (lemma "coset_add") (("" (inst?) (("" (inst -1 "x1!1`1" "x1!1`2") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_add formula-decl nil quotient_rings nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (ideal type-eq-decl nil ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (ring nonempty-type-eq-decl nil ring nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil)) nil (third_isomorphism_th_ax subtype "cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)" "[[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I), coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)] -> coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)]"))) (third_isomorphism_th_ax_TCC7 0 (third_isomorphism_th_ax_TCC7-1 nil 3757773133 ("" (skosimp*) (("" (lemma "coset_product") (("" (inst?) (("" (inst -1 "x1!1`1" "x1!1`2") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_product formula-decl nil quotient_rings nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (ideal type-eq-decl nil ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (ring nonempty-type-eq-decl nil ring nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil)) nil (third_isomorphism_th_ax subtype "product_coset_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+, ring_2nd_3rd_isomorphism_theorems.*].product(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)" "[[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I), coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)] -> coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)]"))) (third_isomorphism_th_ax_TCC8 0 (third_isomorphism_th_ax_TCC8-1 nil 3757773133 ("" (skosimp*) (("" (rewrite "ideal_is_coset") nil nil)) nil) ((ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil)) nil (third_isomorphism_th_ax subtype "ring_2nd_3rd_isomorphism_theorems.I" "coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)"))) (third_isomorphism_th_ax_TCC9 0 (third_isomorphism_th_ax_TCC9-1 nil 3757773133 ("" (skosimp*) (("" (split) (("1" (skosimp) (("1" (expand "/" 1 1) (("1" (expand "restrict" 1) (("1" (expand "/" 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "restrict" 1) (("2" (typepred "phi!1(x1!1)") (("2" (hide -2 -3 -4 -5) (("2" (expand "/") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "R_epimorphism?") (("3" (flatten) nil nil)) nil)) nil)) nil) ((/ const-decl "setof[set[T]]" cosets_def nil) (restrict const-decl "R" restrict nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (set type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil)) nil (third_isomorphism_th_ax subtype "ring_2nd_3rd_isomorphism_theorems.phi" "R_homomorphism[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), product_coset_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+, ring_2nd_3rd_isomorphism_theorems.*].product(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), ring_2nd_3rd_isomorphism_theorems.J, coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I), cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I), product_coset_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+, ring_2nd_3rd_isomorphism_theorems.*].product(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I), ring_2nd_3rd_isomorphism_theorems.I](restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)), restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)))"))) (third_isomorphism_th_ax 0 (third_isomorphism_th_ax-1 nil 3757924668 ("" (skosimp) (("" (inst 1 "LAMBDA(A:coset(R!1,J!1)):gen(R!1,J!1)(A)+I!1") (("1" (expand "R_epimorphism?") (("1" (case "R_homomorphism?[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1,coset(R!1,I!1),add(R!1,I!1),product(R!1,I!1),I!1]((R!1/J!1),(R!1/I!1))((LAMBDA (A: coset(R!1, J!1)):
                                   gen(R!1, J!1)(A) + I!1))") (("1" (split) (("1" (hide -1) (("1" (expand "surjective?") (("1" (skosimp) (("1" (typepred "y!1") (("1" (expand "coset?") (("1" (expand "left_coset?") (("1" (flatten) (("1" (skosimp) (("1" (inst 1 "a!1+J!1") (("1" (replace -1) (("1" (expand "gen") (("1" (rewrite "lcos_eq2") (("1" (hide 2) (("1" (expand "lc_gen") (("1" (typepred "choose({a: T | R!1(a) AND a!1 + J!1 = a + J!1})") (("1" (name-replace "gen" "choose({a: T | R!1(a) AND a!1 + J!1 = a + J!1})") (("1" (expand "+" -2) (("1" (decompose-equality -2) (("1" (inst -1 "gen") (("1" (iff) (("1" (prop) (("1" (skosimp -1) (("1" (inst 1 "h!1") (("1" (hide-all-but (-9 1)) (("1" (expand "subset?") (("1" (inst -1 "h!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (inst 1 "zero") (("1" (assert) nil nil) ("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide -1 -3 -4) (("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "a!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (expand "/") (("2" (case "coset?(R!1, J!1)(a!1+J!1)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "lcoset_iff_coset" :dir rl) (("2" (expand "left_coset?") (("2" (inst 1 "a!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (decompose-equality) (("1" (iff) (("1" (prop) (("1" (expand "restrict") (("1" (hide -2) (("1" (expand "R_kernel") (("1" (flatten) (("1" (expand "/" 1) (("1" (rewrite "lcoset_iff_coset" :dir rl) (("1" (expand "left_coset?") (("1" (lemma "self_coset") (("1" (inst -1 "I!1" "R!1" "gen(R!1, J!1)(x!1)") (("1" (expand "ideal?") (("1" (expand "left_ideal?") (("1" (flatten) (("1" (hide -6 -7) (("1" (assert) (("1" (inst 1 "gen(R!1, J!1)(x!1)") (("1" (expand "gen") (("1" (hide -1) (("1" (expand "/" -1) (("1" (expand "coset?") (("1" (flatten) (("1" (hide -2) (("1" (expand "left_coset?") (("1" (skosimp) (("1" (lemma "lc_gen_eq") (("1" (inst -1 "J!1" "R!1" "a!1") (("1" (assert) (("1" (skosimp) (("1" (replace -2) (("1" (replace -1) (("1" (rewrite "lcos_eq2") (("1" (inst 1 "inv(h!1)") (("1" (hide -1 -2 -3 -4 2) (("1" (rewrite "plus_associative") nil nil)) nil) ("2" (expand "subring?") (("2" (flatten) (("2" (hide-all-but (-8 1)) (("2" (lemma "inv_is_member_R[T,+,*,zero]") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subring?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "R_kernel") (("2" (expand "restrict") (("2" (split) (("1" (expand "/") (("1" (propax) nil nil)) nil) ("2" (expand "/" 1) (("2" (rewrite "ideal_is_coset") nil nil)) nil) ("3" (lemma "self_coset") (("3" (inst -1 "I!1" "R!1" "gen(R!1,J!1)(x!1)") (("3" (expand "ideal?") (("3" (expand "left_ideal?") (("3" (flatten) (("3" (assert) (("3" (hide -3 -4 -6 -7 2) (("3" (expand "gen") (("3" (expand "/" -1) (("3" (expand "coset?") (("3" (flatten) (("3" (hide -2) (("3" (expand "left_coset?") (("3" (skosimp) (("3" (replace -1) (("3" (typepred "a!1") (("3" (lemma "lc_gen_eq") (("3" (inst -1 "J!1" "R!1" "a!1") (("3" (assert) (("3" (expand "subring?") (("3" (flatten) (("3" (expand "subset?" -4) (("3" (inst -4 "a!1") (("3" (assert) (("3" (assert) (("3" (skosimp) (("3" (replaces -1) (("3" (expand "subset?") (("3" (hide -2) (("3" (inst -6 "h!1") (("3" (assert) (("3" (lemma "R_sum_star_closed[T,+,*,zero]") (("3" (inst -1 "I!1" "a!1" "h!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "ideal_is_coset") nil nil) ("3" (skosimp) (("3" (lemma "coset_product") (("3" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (lemma "coset_add") (("4" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (rewrite "ideal_is_coset") nil nil) ("6" (hide -1) (("6" (skosimp) (("6" (lemma "coset_product") (("6" (inst -1 "R!1" "J!1" "x1!1`1" "x1!1`2") (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (skosimp) (("7" (lemma "coset_product") (("7" (inst -1 "R!1" "J!1" "x1!1`1" "x1!1`2") (("7" (assert) (("7" (hide -1 -2) (("7" (lemma "coset_add") (("7" (inst -1 "R!1" "J!1" "x1!1`1" "x1!1`2") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (skosimp) (("8" (lemma "coset_add") (("8" (assert) (("8" (expand "restrict") (("8" (hide -1 -2) (("8" (typepred "x!1") (("8" (expand "/") (("8" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (expand "restrict") (("9" (expand "/") (("9" (skosimp) (("9" (hide -1) (("9" (case "coset?[T, +](R!1, I!1)((+[T, +])(gen[T, +](R!1, J!1)(A!1), I!1))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "lcoset_iff_coset" :dir rl) (("2" (expand "left_coset?") (("2" (inst 1 "gen[T, +](R!1, J!1)(A!1)") (("2" (expand "gen") (("2" (expand "lc_gen") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "R_homomorphism?") (("2" (case "coset?(R!1,J!1)(J!1)") (("1" (case "coset?(R!1,I!1)(I!1)") (("1" (case "ring?[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1](fullset[coset(R!1,J!1)])") (("1" (case "ring?[coset(R!1, I!1), add(R!1, I!1), product(R!1, I!1), I!1]
                                                                 (fullset[coset(R!1, I!1)])") (("1" (split) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (rewrite "R_sum_star_closed[coset(R!1, J!1), add(R!1, J!1), product(R!1, J!1), J!1]") (("1" (hide 2 3) (("1" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (rewrite "R_prod_star_closed[coset(R!1, J!1), add(R!1, J!1), product(R!1, J!1), J!1]") (("2" (hide 2) (("2" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "star_closed?") (("3" (skosimp) (("3" (rewrite "R_sum_star_closed[coset(R!1, I!1), add(R!1, I!1), product(R!1, I!1), I!1]") (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (expand "star_closed?") (("4" (skosimp) (("4" (rewrite "R_prod_star_closed[coset(R!1, I!1), add(R!1, I!1), product(R!1, I!1), I!1]") (("4" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (expand "homomorphism?") (("5" (skosimp) (("5" (lemma "add_charac") (("5" (inst -1 "R!1" "I!1" "gen(R!1, J!1)(a!1)" "gen(R!1, J!1)(b!1)") (("1" (replaces -1) (("1" (rewrite "lcos_eq2") (("1" (hide 2) (("1" (typepred "a!1" "b!1") (("1" (hide -2 -4) (("1" (expand "coset?") (("1" (expand "left_coset?") (("1" (flatten) (("1" (hide -2 -4) (("1" (skosimp*) (("1" (expand "gen") (("1" (expand "add") (("1" (replace -1 1) (("1" (replace -2 1) (("1" (lemma "lc_gen_eq") (("1" (inst -1 "J!1" "R!1" "(lc_gen(R!1, J!1)(a!2 + J!1) + lc_gen(R!1, J!1)(a!3 + J!1))") (("1" (assert) (("1" (case " R!1((lc_gen(R!1, J!1)(a!2 + J!1) + lc_gen(R!1, J!1)(a!3 + J!1)))") (("1" (assert) (("1" (skosimp) (("1" (inst 1 "h!1") (("1" (typepred "h!1") (("1" (hide-all-but (-1 -14 1)) (("1" (expand "subset?") (("1" (inst -2 "h!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3) (("2" (lemma "R_sum_star_closed[T,+,*,zero]") (("2" (inst -1 "R!1" "lc_gen(R!1, J!1)(a!2 + J!1)" " lc_gen(R!1, J!1)(a!3 + J!1)") (("2" (assert) (("2" (hide 2 3) (("2" (expand "lc_gen") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 -3 2) (("3" (expand "left_coset?") (("3" (inst 1 "a!3") nil nil)) nil)) nil) ("4" (hide -1 -2 -3 2) (("4" (expand "left_coset?") (("4" (inst 1 "a!2") nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (expand "left_coset?") (("2" (inst 1 "a!3") nil nil)) nil)) nil) ("3" (expand "left_coset?") (("3" (inst 1 "a!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gen") (("2" (expand "lc_gen") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "gen") (("3" (expand "lc_gen") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (expand "homomorphism?") (("6" (skosimp) (("6" (lemma "product_charac") (("6" (inst -1 "R!1" "I!1" "gen(R!1, J!1)(a!1)" "gen(R!1, J!1)(b!1)") (("1" (replaces -1) (("1" (rewrite "lcos_eq2") (("1" (hide 2) (("1" (typepred "a!1" "b!1") (("1" (hide -2 -4) (("1" (expand "coset?") (("1" (expand "left_coset?") (("1" (flatten) (("1" (hide -2 -4) (("1" (skosimp*) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "product" 1) (("1" (expand "lproduct") (("1" (case "R!1(lc_gen(R!1, J!1)(a!2 + J!1) * lc_gen(R!1, J!1)(a!3 + J!1))") (("1" (lemma "lc_gen_eq") (("1" (inst -1 "J!1" "R!1" "lc_gen(R!1, J!1)(a!2 + J!1) * lc_gen(R!1, J!1)(a!3 + J!1)") (("1" (assert) (("1" (skosimp) (("1" (inst 1 "h!1") (("1" (expand "gen") (("1" (propax) nil nil)) nil) ("2" (typepred "h!1") (("2" (hide-all-but (-1 -12 1)) (("2" (expand "subset?") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "R_prod_star_closed[T,+,*,zero]") (("2" (inst -1 "R!1" "lc_gen(R!1, J!1)(a!2 + J!1)" "lc_gen(R!1, J!1)(a!3 + J!1)") (("2" (assert) (("2" (expand "lc_gen") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "left_coset?") (("3" (inst 1 "a!3") nil nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (expand "left_coset?") (("4" (inst 1 "a!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "gen") (("2" (expand "lc_gen") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "gen") (("3" (expand "lc_gen") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (rewrite "fullset_quot_group_is_ring") nil nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (rewrite "fullset_quot_group_is_ring") nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (rewrite "ideal_is_coset") nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil) ("3" (rewrite "ideal_is_coset") nil nil) ("4" (hide 2) (("4" (skosimp) (("4" (lemma "coset_product") (("4" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (lemma "coset_add") (("5" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("6" (inst 1 "I!1") (("6" (rewrite "ideal_is_coset") nil nil)) nil) ("7" (rewrite "ideal_is_coset") nil nil) ("8" (hide 2) (("8" (skosimp) (("8" (lemma "coset_product") (("8" (inst -1 "R!1" "J!1" "x1!1`1" "x1!1`2") (("8" (assert) nil nil)) nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skosimp) (("9" (lemma "coset_add") (("9" (inst -1 "R!1" "J!1" "x1!1`1" "x1!1`2") (("9" (assert) nil nil)) nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (inst 1 "J!1") (("10" (rewrite "ideal_is_coset") nil nil)) nil)) nil) ("11" (hide 2) (("11" (skosimp) (("11" (expand "/") (("11" (propax) nil nil)) nil)) nil)) nil) ("12" (hide 2) (("12" (skosimp) (("12" (expand "/") (("12" (rewrite "lcoset_iff_coset" :dir rl) (("12" (expand "left_coset?") (("12" (inst 1 "gen[T, +](R!1, J!1)(A!1)") (("12" (expand "gen") (("12" (expand "lc_gen") (("12" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "/") (("2" (propax) nil nil)) nil)) nil) ("3" (skosimp) (("3" (expand "/") (("3" (rewrite "lcoset_iff_coset" :dir rl) (("3" (expand "left_coset?") (("3" (inst 1 "gen[T, +](R!1, J!1)(A!1)") (("3" (expand "gen") (("3" (expand "lc_gen") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gen const-decl "T" cosets_def nil) (+ const-decl "set[T]" cosets_def nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (/ const-decl "setof[set[T]]" cosets_def nil) (setof type-eq-decl nil defined_types nil) (coset type-eq-decl nil cosets_def nil) (J!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (coset? const-decl "bool" cosets_def nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (add const-decl "set[T]" cosets_def nil) (product const-decl "set[T]" product_coset_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (restrict const-decl "R" restrict nil) (TRUE const-decl "bool" booleans nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (lc_gen_eq formula-decl nil ring_cosets_lemmas nil) (right_distributive? const-decl "bool" operator_defs_more nil) (left_distributive? const-decl "bool" operator_defs_more nil) (commutative? const-decl "bool" operator_defs nil) (group? const-decl "bool" group_def nil) (inv_exists? const-decl "bool" group_def nil) (monoid? const-decl "bool" monoid_def nil) (associative? const-decl "bool" operator_defs nil) (monad? const-decl "bool" monad_def nil) (identity? const-decl "bool" operator_defs nil) (zero_plus formula-decl nil ring nil) (star_closed? const-decl "bool" groupoid_def nil) (inv_is_member_R formula-decl nil ring_basic_properties nil) (plus_associative formula-decl nil ring nil) (negate_is_right_inv formula-decl nil ring nil) (h!1 skolem-const-decl "(J!1)" ring_2nd_3rd_isomorphism_theorems nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (coset_product formula-decl nil quotient_rings nil) (coset_add formula-decl nil quotient_rings nil) (A!1 skolem-const-decl "coset[T, +](R!1, J!1)" ring_2nd_3rd_isomorphism_theorems nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (a!1 skolem-const-decl "(R!1)" ring_2nd_3rd_isomorphism_theorems nil) (abelian_group? const-decl "bool" group_def nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (h!1 skolem-const-decl "(J!1)" ring_2nd_3rd_isomorphism_theorems nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (plus_zero formula-decl nil ring nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (subring? const-decl "bool" ring_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (empty? const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (lcos_eq2 formula-decl nil ring_cosets_lemmas nil) (left_coset type-eq-decl nil cosets_def nil) (lc_gen const-decl "T" cosets_def nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (left_coset? const-decl "bool" cosets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (surjective? const-decl "bool" functions nil) (fullset const-decl "set" sets nil) (fullset_quot_group_is_ring formula-decl nil quotient_rings nil) (quotient_group_is_ring formula-decl nil quotient_rings nil) (R_prod_star_closed formula-decl nil ring_basic_properties nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (add_charac formula-decl nil quotient_rings nil) (h!1 skolem-const-decl "(J!1)" ring_2nd_3rd_isomorphism_theorems nil) (a!3 skolem-const-decl "(R!1)" ring_2nd_3rd_isomorphism_theorems nil) (a!2 skolem-const-decl "(R!1)" ring_2nd_3rd_isomorphism_theorems nil) (b!1 skolem-const-decl "(restrict[set[T], coset[T, +](R!1, J!1), bool]((R!1 / J!1)))" ring_2nd_3rd_isomorphism_theorems nil) (a!1 skolem-const-decl "(restrict[set[T], coset[T, +](R!1, J!1), bool]((R!1 / J!1)))" ring_2nd_3rd_isomorphism_theorems nil) (product_charac formula-decl nil quotient_rings nil) (h!1 skolem-const-decl "(J!1)" ring_2nd_3rd_isomorphism_theorems nil) (lproduct const-decl "set[T]" product_coset_def nil) (b!1 skolem-const-decl "(restrict[set[T], coset[T, +](R!1, J!1), bool]((R!1 / J!1)))" ring_2nd_3rd_isomorphism_theorems nil) (a!1 skolem-const-decl "(restrict[set[T], coset[T, +](R!1, J!1), bool]((R!1 / J!1)))" ring_2nd_3rd_isomorphism_theorems nil) (A!1 skolem-const-decl "coset[T, +](R!1, J!1)" ring_2nd_3rd_isomorphism_theorems nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (A!1 skolem-const-decl "coset[T, +](R!1, J!1)" ring_2nd_3rd_isomorphism_theorems nil)) shostak)) (third_isomorphism_th_TCC1 0 (third_isomorphism_th_TCC2-1 nil 3758294722 ("" (skosimp) (("" (rewrite "lcoset_iff_coset" :dir rl) (("" (expand "left_coset?") (("" (expand "add") (("" (inst 1 "lc_gen(R!1, J!1)(x1!1`1) + lc_gen(R!1, J!1)(x1!1`2)") (("1" (lemma "R_sum_star_closed") (("1" (inst -1 "R!1" "lc_gen[T, +](R!1, J!1)(x1!1`1)" "lc_gen[T, +](R!1, J!1)(x1!1`2)") (("1" (assert) (("1" (hide 2) (("1" (expand "lc_gen") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x1!1`2") (("2" (expand "coset?") (("2" (assert) nil nil)) nil)) nil) ("3" (typepred "x1!1`1") (("3" (expand "coset?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (add const-decl "set[T]" cosets_def nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (NOT const-decl "[bool -> bool]" booleans nil) (R_sum_star_closed formula-decl nil ring_basic_properties nil) (member const-decl "bool" sets nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil) (J!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (x1!1 skolem-const-decl "[coset[T, +](R!1, J!1), coset[T, +](R!1, J!1)]" ring_2nd_3rd_isomorphism_theorems nil) (lc_gen const-decl "T" cosets_def nil) (left_coset type-eq-decl nil cosets_def nil) (left_coset? const-decl "bool" cosets_def nil)) nil (third_isomorphism_th subtype "cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)" "[[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)] -> coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)]"))) (third_isomorphism_th_TCC2 0 (third_isomorphism_th_TCC4-1 nil 3758294722 ("" (skosimp) (("" (inst 1 "I!1/J!1") (("" (rewrite "ideal_is_coset[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1]") (("1" (hide 2) (("1" (rewrite "coset_ideal") nil nil)) nil) ("2" (hide 2) (("2" (rewrite "quotient_group_is_ring") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "fullset_quot_group_is_ring") nil nil)) nil) ("4" (hide 2) (("4" (rewrite "ideal_is_coset") nil nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (lemma "coset_product") (("5" (inst?) (("5" (inst -1 "x1!1`1" "x1!1`2") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp) (("6" (lemma "coset_add") (("6" (inst?) (("6" (inst -1 "x1!1`1" "x1!1`2") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (inst 1 "J!1") (("7" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil)) nil)) nil) ((T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (coset? const-decl "bool" cosets_def nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (coset type-eq-decl nil cosets_def nil) (add const-decl "set[T]" cosets_def nil) (restrict const-decl "R" restrict nil) (setof type-eq-decl nil defined_types nil) (/ const-decl "setof[set[T]]" cosets_def nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (J!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil) (coset_add formula-decl nil quotient_rings nil) (coset_product formula-decl nil quotient_rings nil) (fullset_quot_group_is_ring formula-decl nil quotient_rings nil) (quotient_group_is_ring formula-decl nil quotient_rings nil) (coset_ideal formula-decl nil quotient_rings nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (product const-decl "set[T]" product_coset_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (TRUE const-decl "bool" booleans nil) (fullset const-decl "set" sets nil)) nil (third_isomorphism_th existence "" "coset[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)](restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)), restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.I, ring_2nd_3rd_isomorphism_theorems.J)))"))) (third_isomorphism_th_TCC3 0 (third_isomorphism_th_TCC5-1 nil 3758294722 ("" (skosimp*) (("" (lemma "coset_add[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1]") (("1" (inst -1 "R!1/J!1" "I!1/J!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "coset_ideal") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "fullset_quot_group_is_ring") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "ideal_is_coset") nil nil)) nil) ("4" (hide 2) (("4" (skosimp) (("4" (lemma "coset_product") (("4" (inst -1 "R!1" "J!1" "x1!2`1" "x1!2`2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (lemma "coset_add") (("5" (inst -1 "R!1" "J!1" "x1!2`1" "x1!2`2") (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (inst 1 "J!1") (("6" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil)) nil) ((product const-decl "set[T]" product_coset_def nil) (add const-decl "set[T]" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (coset? const-decl "bool" cosets_def nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_add formula-decl nil quotient_rings nil) (TRUE const-decl "bool" booleans nil) (fullset const-decl "set" sets nil) (quotient_group_is_ring formula-decl nil quotient_rings nil) (coset_ideal formula-decl nil quotient_rings nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil) (J!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (restrict const-decl "R" restrict nil) (setof type-eq-decl nil defined_types nil) (/ const-decl "setof[set[T]]" cosets_def nil) (fullset_quot_group_is_ring formula-decl nil quotient_rings nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (coset_product formula-decl nil quotient_rings nil)) nil (third_isomorphism_th subtype "cosets_def[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)].add(restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)), restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.I, ring_2nd_3rd_isomorphism_theorems.J)))" "[[coset[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)](restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)), restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.I, ring_2nd_3rd_isomorphism_theorems.J))), coset[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)](restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)), restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.I, ring_2nd_3rd_isomorphism_theorems.J)))] -> coset[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)](restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)), restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.I, ring_2nd_3rd_isomorphism_theorems.J)))]"))) (third_isomorphism_th_TCC4 0 (third_isomorphism_th_TCC3-1 nil 3758294722 ("" (skosimp*) (("" (lemma "coset_product") (("" (inst?) (("" (inst -1 "x1!1`1" "x1!1`2") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_product formula-decl nil quotient_rings nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (ideal type-eq-decl nil ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (J!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (ring nonempty-type-eq-decl nil ring nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil)) nil (third_isomorphism_th subtype "product_coset_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+, ring_2nd_3rd_isomorphism_theorems.*].product(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)" "[[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)] -> coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)]"))) (third_isomorphism_th_TCC5 0 (third_isomorphism_th_TCC6-1 nil 3758294722 ("" (skosimp*) (("" (lemma "coset_product[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1]") (("1" (inst -1 "R!1/J!1" "I!1/J!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "coset_ideal") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "fullset_quot_group_is_ring") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "ideal_is_coset") nil nil)) nil) ("4" (hide 2) (("4" (skosimp) (("4" (lemma "coset_product") (("4" (inst -1 "R!1" "J!1" "x1!2`1" "x1!2`2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (lemma "coset_add") (("5" (inst -1 "R!1" "J!1" "x1!2`1" "x1!2`2") (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (inst 1 "J!1") (("6" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil)) nil) ((product const-decl "set[T]" product_coset_def nil) (add const-decl "set[T]" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (coset? const-decl "bool" cosets_def nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_product formula-decl nil quotient_rings nil) (TRUE const-decl "bool" booleans nil) (fullset const-decl "set" sets nil) (quotient_group_is_ring formula-decl nil quotient_rings nil) (coset_ideal formula-decl nil quotient_rings nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil) (J!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (restrict const-decl "R" restrict nil) (setof type-eq-decl nil defined_types nil) (/ const-decl "setof[set[T]]" cosets_def nil) (fullset_quot_group_is_ring formula-decl nil quotient_rings nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (coset_add formula-decl nil quotient_rings nil)) nil (third_isomorphism_th subtype "product_coset_def[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), product_coset_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+, ring_2nd_3rd_isomorphism_theorems.*].product(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)].product(restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)), restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.I, ring_2nd_3rd_isomorphism_theorems.J)))" "[[coset[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)](restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)), restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.I, ring_2nd_3rd_isomorphism_theorems.J))), coset[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)](restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)), restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.I, ring_2nd_3rd_isomorphism_theorems.J)))] -> coset[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)](restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)), restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.I, ring_2nd_3rd_isomorphism_theorems.J)))]"))) (third_isomorphism_th_TCC6 0 (third_isomorphism_th_TCC7-1 nil 3758294722 ("" (skosimp) (("" (rewrite "ideal_is_coset[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1]") (("1" (hide 2) (("1" (rewrite "coset_ideal") nil nil)) nil) ("2" (hide 2) (("2" (rewrite "quotient_group_is_ring") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "fullset_quot_group_is_ring") nil nil)) nil) ("4" (hide 2) (("4" (rewrite "ideal_is_coset") nil nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (lemma "coset_product") (("5" (inst?) (("5" (inst -1 "x1!1`1" "x1!1`2") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp) (("6" (lemma "coset_add") (("6" (inst?) (("6" (inst -1 "x1!1`1" "x1!1`2") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (inst 1 "J!1") (("7" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil)) nil) ((fullset const-decl "set" sets nil) (TRUE const-decl "bool" booleans nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (restrict const-decl "R" restrict nil) (setof type-eq-decl nil defined_types nil) (/ const-decl "setof[set[T]]" cosets_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (coset? const-decl "bool" cosets_def nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (coset type-eq-decl nil cosets_def nil) (add const-decl "set[T]" cosets_def nil) (product const-decl "set[T]" product_coset_def nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (coset_ideal formula-decl nil quotient_rings nil) (quotient_group_is_ring formula-decl nil quotient_rings nil) (fullset_quot_group_is_ring formula-decl nil quotient_rings nil) (coset_product formula-decl nil quotient_rings nil) (coset_add formula-decl nil quotient_rings nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil) (J!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil)) nil (third_isomorphism_th subtype "restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.I, ring_2nd_3rd_isomorphism_theorems.J))" "coset[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)](restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J)), restrict[set[T], coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.J), bool].restrict(cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+]./(ring_2nd_3rd_isomorphism_theorems.I, ring_2nd_3rd_isomorphism_theorems.J)))"))) (third_isomorphism_th_TCC7 0 (third_isomorphism_th_TCC9-1 nil 3758294722 ("" (skosimp*) (("" (lemma "coset_add") (("" (inst?) (("" (inst -1 "x1!1`1" "x1!1`2") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_add formula-decl nil quotient_rings nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (ideal type-eq-decl nil ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (ring nonempty-type-eq-decl nil ring nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil)) nil (third_isomorphism_th subtype "cosets_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+].add(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)" "[[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I), coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)] -> coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)]"))) (third_isomorphism_th_TCC8 0 (third_isomorphism_th_TCC10-1 nil 3758294722 ("" (skosimp*) (("" (lemma "coset_product") (("" (inst?) (("" (inst -1 "x1!1`1" "x1!1`2") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (coset_product formula-decl nil quotient_rings nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (ideal type-eq-decl nil ring_ideal_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (ring nonempty-type-eq-decl nil ring nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil)) nil (third_isomorphism_th subtype "product_coset_def[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+, ring_2nd_3rd_isomorphism_theorems.*].product(ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)" "[[coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I), coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)] -> coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)]"))) (third_isomorphism_th_TCC9 0 (third_isomorphism_th_TCC11-1 nil 3758294722 ("" (skosimp) (("" (rewrite "ideal_is_coset") nil nil)) nil) ((ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil)) nil (third_isomorphism_th subtype "ring_2nd_3rd_isomorphism_theorems.I" "coset[ring_2nd_3rd_isomorphism_theorems.T, ring_2nd_3rd_isomorphism_theorems.+](ring_2nd_3rd_isomorphism_theorems.R, ring_2nd_3rd_isomorphism_theorems.I)"))) (third_isomorphism_th 0 (third_isomorphism_th-3 nil 3800114967 ("" (skosimp) (("" (lemma "third_isomorphism_th_ax") (("" (inst -1 "I!1" "J!1" "R!1") (("" (assert) (("" (skosimp) (("" (lemma "first_isomorphism_th[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1,
           		    coset(R!1,I!1),add(R!1,I!1),product(R!1,I!1),I!1]") (("1" (inst -1 "R!1/J!1" "R!1/I!1" "phi!1") (("1" (expand "R_isomorphic?") (("1" (skosimp) (("1" (inst 1 "phi!2") (("1" (expand "R_isomorphism?") (("1" (expand "R_monomorphism?") (("1" (expand "R_epimorphism?") (("1" (case "R_homomorphism?[coset[coset(R!1,J!1),add(R!1,J!1)](R!1/J!1,I!1/J!1),
                                                                                      add[coset(R!1,J!1),add(R!1,J!1)](R!1/J!1,I!1/J!1),
                                                                  		    product[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1)](R!1/J!1,I!1/J!1),
                                                                  		    I!1/J!1,
                                                                  		    coset(R!1,I!1),add(R!1,I!1),product(R!1,I!1),I!1](/[coset(R!1,J!1),add(R!1,J!1)](R!1/J!1,I!1/J!1),R!1/I!1)
                                                                                         (phi!2)") (("1" (assert) (("1" (hide -1) (("1" (flatten) (("1" (hide -2 -4) (("1" (split) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (expand "surjective?") (("2" (skosimp) (("2" (inst -2 "y!1") (("1" (skosimp) (("1" (inst 1 "x!1") (("1" (expand "restrict" 1 1) (("1" (expand "/" 1 1) (("1" (lemma "lcoset_iff_coset[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1]") (("1" (inst -1 "x!1" "I!1/J!1" "R!1/J!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (inst -2 "y!1") (("2" (expand "extend") (("2" (expand "/") (("2" (expand "image") (("2" (expand "image") (("2" (skosimp) (("2" (inst 1 "x!1") (("1" (assert) nil nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (hide -1 -2 -3 -5) (("2" (expand "R_homomorphism?") (("2" (flatten) (("2" (split) (("1" (hide-all-but (-1 -13 -14 -15 -16 1)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (inst -1 "x!1" "y!1") (("1" (grind) nil nil) ("2" (hide 2) (("2" (expand "restrict" 1 4) (("2" (expand "/" 1 4) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "restrict" 1 4) (("3" (expand "/" 1 4) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -13 -14 -15 -16 1)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (inst -1 "x!1" "y!1") (("1" (grind) nil nil) ("2" (hide 2) (("2" (expand "restrict" 1 4) (("2" (expand "/" 1 4) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "restrict" 1 4) (("3" (expand "/" 1 4) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (propax) nil nil) ("5" (hide-all-but (-5 -13 -14 -15 -16 1)) (("5" (expand "homomorphism?") (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-6 -13 -14 -15 -16 1)) (("6" (expand "homomorphism?") (("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 -3 2) (("3" (rewrite "ideal_is_coset[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1]") (("1" (hide 2) (("1" (rewrite "coset_ideal") nil nil)) nil) ("2" (hide 2) (("2" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil) ("4" (hide -1 -2 -3 2) (("4" (skosimp) (("4" (lemma "coset_product[coset(R!1, J!1), add(R!1, J!1),
                                                        product(R!1, J!1), J!1]") (("4" (inst -1 "R!1/J!1" "I!1/J!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "coset_ideal") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide -1 -2 -3 2) (("5" (skosimp) (("5" (lemma "coset_add[coset(R!1, J!1), add(R!1, J!1),
                                                        product(R!1, J!1), J!1]") (("5" (inst -1 "R!1/J!1" "I!1/J!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "coset_ideal") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide -1 -2 2) (("6" (inst 1 "I!1/J!1") (("6" (lemma "lcoset_iff_coset[coset(R!1, J!1), add(R!1, J!1), product(R!1,J!1), J!1]") (("6" (inst -1 "I!1/J!1" "I!1/J!1" "R!1/J!1") (("6" (assert) (("6" (hide 2) (("6" (expand "left_coset?") (("6" (inst 1 "zero+J!1") (("1" (lemma "self_coset[coset(R!1, J!1), add(R!1, J!1), product(R!1, J!1), J!1]") (("1" (inst -1 "I!1/J!1" "R!1/J!1" "J!1") (("1" (rewrite "left_zero") (("1" (case "subring?[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1](I!1/J!1, R!1/J!1)") (("1" (assert) (("1" (hide -1 2) (("1" (expand "restrict" 1) (("1" (expand "/" 1) (("1" (rewrite "lcoset_iff_coset" :dir rl) (("1" (expand "left_coset?") (("1" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (hide-all-but (-2 1)) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide-all-but (-2 1)) (("2" (lemma "zero_is_member_R") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "coset_subring") (("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil) ("2" (hide -1 -2 -4 2) (("2" (rewrite "ideal_is_coset") nil nil)) nil) ("3" (hide -1 -2 -4 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil) ("2" (hide -1 -2 -4) (("2" (expand "restrict") (("2" (expand "/") (("2" (rewrite "left_zero") (("2" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide -1 -2 2) (("7" (split) (("1" (expand "restrict" 1 4) (("1" (expand "/" 1 4) (("1" (skosimp) (("1" (replace -1 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "/" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (skosimp) (("1" (expand "restrict" 1 4) (("1" (expand "restrict" 1 9) (("1" (expand* "/" 1 (4 10)) (("1" (hide -1 -2) (("1" (replace -1 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand* "restrict" "/" 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "quotient_group_is_ring") nil nil)) nil) ("3" (hide -1 -2 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "fullset_quot_group_is_ring") nil nil)) nil) ("3" (hide -1 -2 2) (("3" (rewrite "fullset_quot_group_is_ring") nil nil)) nil) ("4" (hide -1 -2 2) (("4" (rewrite "ideal_is_coset") nil nil)) nil) ("5" (hide -1 -2 2) (("5" (skosimp) (("5" (lemma "coset_product") (("5" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("6" (hide -1 -2 2) (("6" (skosimp) (("6" (lemma "coset_add") (("6" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (hide -1 -2 2) (("7" (inst 1 "I!1") (("7" (expand "coset?") (("7" (lemma "lcoset_iff_rcoset") (("7" (inst -1 "I!1" "I!1" "R!1") (("7" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide -1 -2 2) (("8" (rewrite "ideal_is_coset") nil nil)) nil) ("9" (hide -1 -2 2) (("9" (skosimp) (("9" (lemma "coset_product") (("9" (inst -1 "R!1" "J!1" "x1!1`1" "x1!1`2") (("9" (assert) nil nil)) nil)) nil)) nil)) nil) ("10" (hide -1 -2 2) (("10" (skosimp) (("10" (lemma "coset_add") (("10" (inst -1 "R!1" "J!1" "x1!1`1" "x1!1`2") (("10" (assert) nil nil)) nil)) nil)) nil)) nil) ("11" (hide -1 -2 2) (("11" (inst 1 "J!1") (("11" (expand "coset?") (("11" (lemma "lcoset_iff_rcoset") (("11" (inst -1 "J!1" "J!1" "R!1") (("11" (case "left_coset?(R!1, J!1)(J!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((third_isomorphism_th_ax formula-decl nil ring_2nd_3rd_isomorphism_theorems nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (product const-decl "set[T]" product_coset_def nil) (add const-decl "set[T]" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (first_isomorphism_th formula-decl nil ring_1st_isomorphism_theorem nil) (TRUE const-decl "bool" booleans nil) (fullset const-decl "set" sets nil) (R_isomorphic? const-decl "bool" ring_homomorphisms_def nil) (phi!2 skolem-const-decl "[(restrict
      [set[coset[T, +](R!1, J!1)],
       coset[coset[T, +](R!1, J!1),
             add(R!1, J!1)](restrict[set[T], coset[T, +](R!1, J!1), bool]
                                (R!1 / J!1),
                            R_kernel(restrict
                                     [set[T], coset[T, +](R!1, J!1), bool]
                                     (R!1 / J!1),
                                     restrict
                                     [set[T], coset[T, +](R!1, I!1), bool]
                                     (R!1 / I!1))
                                    (phi!1)),
       bool]
      (restrict[set[T], coset[T, +](R!1, J!1), bool](R!1 / J!1) /
        R_kernel(restrict[set[T], coset[T, +](R!1, J!1), bool](R!1 / J!1),
                 restrict[set[T], coset[T, +](R!1, I!1), bool](R!1 / I!1))
                (phi!1))) ->
   (extend
        [coset[T, +](R!1, I!1),
         (restrict[set[T], coset[T, +](R!1, I!1), bool](R!1 / I!1)), bool,
         FALSE]
        (image(phi!1)
              (restrict
                   [coset[T, +](R!1, J!1),
                    (restrict[set[T], coset[T, +](R!1, J!1), bool]
                         (R!1 / J!1)),
                    bool]
                   (restrict[set[T], coset[T, +](R!1, J!1), bool]
                        (R!1 / J!1)))))]" ring_2nd_3rd_isomorphism_theorems nil) (image const-decl "set[R]" function_image nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (phi!1 skolem-const-decl "[(R!1 / J!1) -> (R!1 / I!1)]" ring_2nd_3rd_isomorphism_theorems nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil) (surjective? const-decl "bool" functions nil) (y!1 skolem-const-decl "(restrict[set[T], coset[T, +](R!1, I!1), bool](R!1 / I!1))" ring_2nd_3rd_isomorphism_theorems nil) (x!1 skolem-const-decl "(restrict
     [set[coset[T, +](R!1, J!1)],
      coset[coset[T, +](R!1, J!1),
            add(R!1, J!1)](restrict[set[T], coset[T, +](R!1, J!1), bool]
                               (R!1 / J!1),
                           R_kernel(restrict
                                    [set[T], coset[T, +](R!1, J!1), bool]
                                    (R!1 / J!1),
                                    restrict
                                    [set[T], coset[T, +](R!1, I!1), bool]
                                    (R!1 / I!1))
                                   (phi!1)),
      bool]
     (restrict[set[T], coset[T, +](R!1, J!1), bool](R!1 / J!1) /
       R_kernel(restrict[set[T], coset[T, +](R!1, J!1), bool](R!1 / J!1),
                restrict[set[T], coset[T, +](R!1, I!1), bool](R!1 / I!1))
               (phi!1)))" ring_2nd_3rd_isomorphism_theorems nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (image const-decl "set[R]" function_image nil) (x!1 skolem-const-decl "(restrict[set[T], coset[T, +](R!1, J!1), bool](R!1 / J!1))" ring_2nd_3rd_isomorphism_theorems nil) (NOT const-decl "[bool -> bool]" booleans nil) (left_coset? const-decl "bool" cosets_def nil) (right_coset? const-decl "bool" cosets_def nil) (injective? const-decl "bool" functions nil) (star_closed? const-decl "bool" groupoid_def nil) (x!1 skolem-const-decl "(restrict
     [set[coset[T, +](R!1, J!1)],
      coset[coset[T, +](R!1, J!1),
            add[T, +](R!1, J!1)](restrict
                                     [set[T], coset[T, +](R!1, J!1), bool]
                                     (/[T, +](R!1, J!1)),
                                 restrict
                                     [set[T], coset[T, +](R!1, J!1), bool]
                                     (/[T, +](I!1, J!1))),
      bool]
     (/[coset[T, +](R!1, J!1), add(R!1, J!1)]
          (restrict[set[T], coset[T, +](R!1, J!1), bool](R!1 / J!1),
           restrict[set[T], coset[T, +](R!1, J!1), bool](I!1 / J!1))))" ring_2nd_3rd_isomorphism_theorems nil) (y!1 skolem-const-decl "(restrict
     [set[coset[T, +](R!1, J!1)],
      coset[coset[T, +](R!1, J!1),
            add[T, +](R!1, J!1)](restrict
                                     [set[T], coset[T, +](R!1, J!1), bool]
                                     (/[T, +](R!1, J!1)),
                                 restrict
                                     [set[T], coset[T, +](R!1, J!1), bool]
                                     (/[T, +](I!1, J!1))),
      bool]
     (/[coset[T, +](R!1, J!1), add(R!1, J!1)]
          (restrict[set[T], coset[T, +](R!1, J!1), bool](R!1 / J!1),
           restrict[set[T], coset[T, +](R!1, J!1), bool](I!1 / J!1))))" ring_2nd_3rd_isomorphism_theorems nil) (ideal? const-decl "bool" ring_ideal_def nil) (right_ideal? const-decl "bool" ring_ideal_def nil) (right_swallow? const-decl "bool" ring_ideal_def nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (left_swallow? const-decl "bool" ring_ideal_def nil) (subring? const-decl "bool" ring_def nil) (right_distributive? const-decl "bool" operator_defs_more nil) (left_distributive? const-decl "bool" operator_defs_more nil) (abelian_group? const-decl "bool" group_def nil) (commutative? const-decl "bool" operator_defs nil) (group? const-decl "bool" group_def nil) (inv_exists? const-decl "bool" group_def nil) (monoid? const-decl "bool" monoid_def nil) (associative? const-decl "bool" operator_defs nil) (monad? const-decl "bool" monad_def nil) (identity? const-decl "bool" operator_defs nil) (zero_plus formula-decl nil ring nil) (plus_zero formula-decl nil ring nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (lc_gen const-decl "T" cosets_def nil) (x!1 skolem-const-decl "(restrict
     [set[coset[T, +](R!1, J!1)],
      coset[coset[T, +](R!1, J!1),
            add[T, +](R!1, J!1)](restrict
                                     [set[T], coset[T, +](R!1, J!1), bool]
                                     (/[T, +](R!1, J!1)),
                                 restrict
                                     [set[T], coset[T, +](R!1, J!1), bool]
                                     (/[T, +](I!1, J!1))),
      bool]
     (/[coset[T, +](R!1, J!1), add(R!1, J!1)]
          (restrict[set[T], coset[T, +](R!1, J!1), bool](R!1 / J!1),
           restrict[set[T], coset[T, +](R!1, J!1), bool](I!1 / J!1))))" ring_2nd_3rd_isomorphism_theorems nil) (y!1 skolem-const-decl "(restrict
     [set[coset[T, +](R!1, J!1)],
      coset[coset[T, +](R!1, J!1),
            add[T, +](R!1, J!1)](restrict
                                     [set[T], coset[T, +](R!1, J!1), bool]
                                     (/[T, +](R!1, J!1)),
                                 restrict
                                     [set[T], coset[T, +](R!1, J!1), bool]
                                     (/[T, +](I!1, J!1))),
      bool]
     (/[coset[T, +](R!1, J!1), add(R!1, J!1)]
          (restrict[set[T], coset[T, +](R!1, J!1), bool](R!1 / J!1),
           restrict[set[T], coset[T, +](R!1, J!1), bool](I!1 / J!1))))" ring_2nd_3rd_isomorphism_theorems nil) (lproduct const-decl "set[T]" product_coset_def nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (coset_ideal formula-decl nil quotient_rings nil) (quotient_group_is_ring formula-decl nil quotient_rings nil) (coset_product formula-decl nil quotient_rings nil) (coset_add formula-decl nil quotient_rings nil) (+ const-decl "set[T]" cosets_def nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (coset_subring formula-decl nil quotient_rings nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (I!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" ring_2nd_3rd_isomorphism_theorems nil) (J!1 skolem-const-decl "set[T]" ring_2nd_3rd_isomorphism_theorems nil) (restrict const-decl "R" restrict nil) (setof type-eq-decl nil defined_types nil) (/ const-decl "setof[set[T]]" cosets_def nil) (fullset_quot_group_is_ring formula-decl nil quotient_rings nil) (lcoset_iff_rcoset formula-decl nil ring_cosets_lemmas nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil)) nil) (third_isomorphism_th-2 nil 3758877077 ("" (skosimp) (("" (lemma "third_isomorphism_th_ax") (("" (inst -1 "I!1" "J!1" "R!1") (("" (assert) (("" (skosimp) (("" (lemma "first_isomorphism_th[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1,
         		    coset(R!1,I!1),add(R!1,I!1),product(R!1,I!1),I!1]") (("1" (inst -1 "R!1/J!1" "R!1/I!1" "phi!1") (("1" (expand "R_isomorphic?") (("1" (skosimp) (("1" (inst 1 "phi!2") (("1" (expand "R_isomorphism?") (("1" (expand "R_monomorphism?") (("1" (expand "R_epimorphism?") (("1" (case "R_homomorphism?[coset[coset(R!1,J!1),add(R!1,J!1)](R!1/J!1,I!1/J!1),
                                                                         add[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1)](R!1/J!1,I!1/J!1),
                                                     		    product[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1)](R!1/J!1,I!1/J!1),
                                                     		    I!1/J!1,
                                                     		    coset(R!1,I!1),add(R!1,I!1),product(R!1,I!1),I!1](/[coset(R!1,J!1),add(R!1,J!1)](R!1/J!1,I!1/J!1),R!1/I!1)
                                                                            (phi!2)") (("1" (assert) (("1" (hide -1) (("1" (flatten) (("1" (hide -2 -4) (("1" (split) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (expand "surjective?") (("2" (skosimp) (("2" (inst -2 "y!1") (("1" (skosimp) (("1" (inst 1 "x!1") (("1" (expand "restrict" 1 1) (("1" (expand "/" 1 1) (("1" (lemma "lcoset_iff_coset[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1]") (("1" (inst -1 "x!1" "I!1/J!1" "R!1/J!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (inst -2 "y!1") (("2" (expand "extend") (("2" (expand "/") (("2" (expand "image") (("2" (expand "image") (("2" (skosimp) (("2" (inst 1 "x!1") (("1" (assert) nil nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (hide -1 -2 -3 -5) (("2" (expand "R_homomorphism?") (("2" (flatten) (("2" (split) (("1" (hide-all-but (-1 -13 -14 -15 -16 1)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (inst -1 "x!1" "y!1") (("1" (grind) nil nil) ("2" (hide 2) (("2" (expand "restrict" 1 4) (("2" (expand "/" 1 4) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "restrict" 1 4) (("3" (expand "/" 1 4) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -13 -14 -15 -16 1)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (inst -1 "x!1" "y!1") (("1" (grind) nil nil) ("2" (hide 2) (("2" (expand "restrict" 1 4) (("2" (expand "/" 1 4) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "restrict" 1 4) (("3" (expand "/" 1 4) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (propax) nil nil) ("5" (hide-all-but (-5 -13 -14 -15 -16 1)) (("5" (expand "homomorphism?") (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-6 -13 -14 -15 -16 1)) (("6" (expand "homomorphism?") (("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 -3 2) (("3" (rewrite "ideal_is_coset[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1]") (("1" (hide 2) (("1" (rewrite "coset_ideal") nil nil)) nil) ("2" (hide 2) (("2" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil) ("4" (hide -1 -2 -3 2) (("4" (skosimp) (("4" (lemma "coset_product[coset(R!1, J!1), add(R!1, J!1),
                                              product(R!1, J!1), J!1]") (("4" (inst -1 "R!1/J!1" "I!1/J!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "coset_ideal") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide -1 -2 -3 2) (("5" (skosimp) (("5" (lemma "coset_add[coset(R!1, J!1), add(R!1, J!1),
                                              product(R!1, J!1), J!1]") (("5" (inst -1 "R!1/J!1" "I!1/J!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "coset_ideal") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide -1 -2 2) (("6" (inst 1 "I!1/J!1") (("6" (lemma "lcoset_iff_coset[coset(R!1, J!1), add(R!1, J!1), product(R!1,J!1), J!1]") (("6" (inst -1 "I!1/J!1" "I!1/J!1" "R!1/J!1") (("6" (assert) (("6" (hide 2) (("6" (expand "left_coset?") (("6" (inst 1 "zero+J!1") (("1" (lemma "self_coset[coset(R!1, J!1), add(R!1, J!1), product(R!1, J!1), J!1]") (("1" (inst -1 "I!1/J!1" "R!1/J!1" "J!1") (("1" (rewrite "left_zero") (("1" (case "subring?[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1](I!1/J!1, R!1/J!1)") (("1" (assert) (("1" (hide -1 2) (("1" (expand "restrict" 1) (("1" (expand "/" 1) (("1" (rewrite "lcoset_iff_coset" :dir rl) (("1" (expand "left_coset?") (("1" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (hide-all-but (-2 1)) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide-all-but (-2 1)) (("2" (lemma "zero_is_member_R") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "coset_subring") (("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil) ("2" (hide -1 -2 -4 2) (("2" (rewrite "ideal_is_coset") nil nil)) nil) ("3" (hide -1 -2 -4 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil) ("2" (hide -1 -2 -4) (("2" (expand "restrict") (("2" (expand "/") (("2" (rewrite "left_zero") (("2" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide -1 -2 2) (("7" (split) (("1" (expand "restrict" 1 4) (("1" (expand "/" 1 4) (("1" (skosimp) (("1" (replace -1 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "/" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (skosimp) (("1" (expand "restrict" 1 4) (("1" (expand "restrict" 1 9) (("1" (expand* "/" 1 (4 10)) (("1" (hide -1 -2) (("1" (replace -1 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand* "restrict" "/" 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "quotient_group_is_ring") nil nil)) nil) ("3" (hide -1 -2 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "fullset_quot_group_is_ring") nil nil)) nil) ("3" (hide -1 -2 2) (("3" (rewrite "fullset_quot_group_is_ring") nil nil)) nil) ("4" (hide -1 -2 2) (("4" (rewrite "ideal_is_coset") nil nil)) nil) ("5" (hide -1 -2 2) (("5" (skosimp) (("5" (lemma "coset_product") (("5" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("6" (hide -1 -2 2) (("6" (skosimp) (("6" (lemma "coset_add") (("6" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (hide -1 -2 2) (("7" (inst 1 "I!1") (("7" (expand "coset?") (("7" (lemma "lcoset_iff_rcoset") (("7" (inst -1 "I!1" "I!1" "R!1") (("7" (case "left_coset?(R!1, I!1)(I!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide -1 -2 2) (("8" (rewrite "ideal_is_coset") nil nil)) nil) ("9" (hide -1 -2 2) (("9" (skosimp) (("9" (lemma "coset_product") (("9" (inst -1 "R!1" "J!1" "x1!1`1" "x1!1`2") (("9" (assert) nil nil)) nil)) nil)) nil)) nil) ("10" (hide -1 -2 2) (("10" (skosimp) (("10" (lemma "coset_add") (("10" (inst -1 "R!1" "J!1" "x1!1`1" "x1!1`2") (("10" (assert) nil nil)) nil)) nil)) nil)) nil) ("11" (hide -1 -2 2) (("11" (inst 1 "J!1") (("11" (expand "coset?") (("11" (lemma "lcoset_iff_rcoset") (("11" (inst -1 "J!1" "J!1" "R!1") (("11" (case "left_coset?(R!1, J!1)(J!1)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "left_coset?") (("2" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (lemma "zero_is_member_R[T,+,*,zero]") (("2" (inst -1 "R!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((third_isomorphism_th_ax formula-decl nil ring_2nd_3rd_isomorphism_theorems nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (product const-decl "set[T]" product_coset_def nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (first_isomorphism_th formula-decl nil ring_1st_isomorphism_theorem nil) (TRUE const-decl "bool" booleans nil) (fullset const-decl "set" sets nil) (R_isomorphic? const-decl "bool" ring_homomorphisms_def nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil) (surjective? const-decl "bool" functions nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (NOT const-decl "[bool -> bool]" booleans nil) (left_coset? const-decl "bool" cosets_def nil) (right_coset? const-decl "bool" cosets_def nil) (injective? const-decl "bool" functions nil) (ideal? const-decl "bool" ring_ideal_def nil) (right_ideal? const-decl "bool" ring_ideal_def nil) (right_swallow? const-decl "bool" ring_ideal_def nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (left_swallow? const-decl "bool" ring_ideal_def nil) (commutative? const-decl "bool" operator_defs nil) (associative? const-decl "bool" operator_defs nil) (identity? const-decl "bool" operator_defs nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (lc_gen const-decl "T" cosets_def nil) (lproduct const-decl "set[T]" product_coset_def nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (coset_ideal formula-decl nil quotient_rings nil) (quotient_group_is_ring formula-decl nil quotient_rings nil) (coset_product formula-decl nil quotient_rings nil) (coset_add formula-decl nil quotient_rings nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (coset_subring formula-decl nil quotient_rings nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (restrict const-decl "R" restrict nil) (setof type-eq-decl nil defined_types nil) (/ const-decl "setof[set[T]]" cosets_def nil) (fullset_quot_group_is_ring formula-decl nil quotient_rings nil) (lcoset_iff_rcoset formula-decl nil ring_cosets_lemmas nil) (zero formal-const-decl "T" ring_2nd_3rd_isomorphism_theorems nil) (* formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (+ formal-const-decl "[T, T -> T]" ring_2nd_3rd_isomorphism_theorems nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-nonempty-type-decl nil ring_2nd_3rd_isomorphism_theorems nil)) nil) (third_isomorphism_th-1 nil 3758294867 ("" (skosimp) (("" (lemma "third_isomorphism_th_ax") (("" (inst -1 "I!1" "J!1" "R!1") (("" (assert) (("" (skosimp) (("" (lemma "first_isomorphism_th[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1,
   		    coset(R!1,I!1),add(R!1,I!1),product(R!1,I!1),I!1]") (("1" (inst -1 "R!1/J!1" "R!1/I!1" "phi!1") (("1" (expand "R_isomorphic?") (("1" (skosimp) (("1" (inst 1 "phi!2") (("1" (expand "R_isomorphism?") (("1" (expand "R_monomorphism?") (("1" (expand "R_epimorphism?") (("1" (case "R_homomorphism?[coset[coset(R!1,J!1),add(R!1,J!1)](R!1/J!1,I!1/J!1),
                                  add[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1)](R!1/J!1,I!1/J!1),
              		    product[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1)](R!1/J!1,I!1/J!1),
              		    I!1/J!1,
              		    coset(R!1,I!1),add(R!1,I!1),product(R!1,I!1),I!1](/[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1)](R!1/J!1,I!1/J!1),R!1/I!1)
                                     (phi!2)") (("1" (assert) (("1" (hide -1) (("1" (flatten) (("1" (hide -2 -4) (("1" (split) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (expand "surjective?") (("2" (skosimp) (("2" (inst -2 "y!1") (("1" (skosimp) (("1" (inst 1 "x!1") (("1" (expand "restrict" 1 1) (("1" (expand "/" 1 1) (("1" (lemma "lcoset_iff_coset[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1]") (("1" (inst -1 "x!1" "I!1/J!1" "R!1/J!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (inst -2 "y!1") (("2" (expand "extend") (("2" (expand "/") (("2" (expand "image") (("2" (expand "image") (("2" (skosimp) (("2" (inst 1 "x!1") (("1" (assert) nil nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (hide -1 -2 -3 -5) (("2" (expand "R_homomorphism?") (("2" (flatten) (("2" (split) (("1" (hide-all-but (-1 -13 -14 -15 -16 1)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (inst -1 "x!1" "y!1") (("1" (grind) nil nil) ("2" (hide 2) (("2" (expand "restrict" 1 4) (("2" (expand "/" 1 4) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "restrict" 1 4) (("3" (expand "/" 1 4) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -13 -14 -15 -16 1)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (inst -1 "x!1" "y!1") (("1" (grind) nil nil) ("2" (hide 2) (("2" (expand "restrict" 1 4) (("2" (expand "/" 1 4) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "restrict" 1 4) (("3" (expand "/" 1 4) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (propax) nil nil) ("5" (hide-all-but (-5 -13 -14 -15 -16 1)) (("5" (expand "homomorphism?") (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-6 -13 -14 -15 -16 1)) (("6" (expand "homomorphism?") (("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 2) (("3" (inst 1 "I!1/J!1") (("3" (lemma "lcoset_iff_coset[coset(R!1, J!1), add(R!1, J!1), product(R!1,J!1), J!1]") (("3" (inst -1 "I!1/J!1" "I!1/J!1" "R!1/J!1") (("3" (assert) (("3" (hide 2) (("3" (expand "left_coset?") (("3" (inst 1 "zero+J!1") (("1" (lemma "self_coset[coset(R!1, J!1), add(R!1, J!1), product(R!1, J!1), J!1]") (("1" (inst -1 "I!1/J!1" "R!1/J!1" "J!1") (("1" (rewrite "left_zero") (("1" (case "subring?[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1](I!1/J!1, R!1/J!1)") (("1" (assert) (("1" (hide -1 2) (("1" (expand "restrict" 1) (("1" (expand "/" 1) (("1" (rewrite "lcoset_iff_coset" :dir rl) (("1" (expand "left_coset?") (("1" (inst 1 "zero") (("1" (rewrite "left_zero") nil nil) ("2" (hide-all-but (-2 1)) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (expand "subring?") (("2" (flatten) (("2" (hide-all-but (-2 1)) (("2" (lemma "zero_is_member_R") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "coset_subring") (("2" (hide 2) (("2" (expand "ideal?") (("2" (expand "left_ideal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil) ("2" (hide -1 -2 -4 2) (("2" (rewrite "ideal_is_coset") nil nil)) nil) ("3" (hide -1 -2 -4 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil) ("2" (hide -1 -2 -4) (("2" (expand "restrict") (("2" (expand "/") (("2" (rewrite "left_zero") (("2" (rewrite "ideal_is_coset") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 -2 -3 2) (("4" (rewrite "ideal_is_coset[coset(R!1,J!1),add(R!1,J!1),product(R!1,J!1),J!1]") (("1" (hide 2) (("1" (rewrite "coset_ideal") nil nil)) nil) ("2" (hide 2) (("2" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil) ("5" (hide -1 -2 -3 2) (("5" (skosimp) (("5" (lemma "coset_product[coset(R!1, J!1), add(R!1, J!1),
                product(R!1, J!1), J!1]") (("5" (inst -1 "R!1/J!1" "I!1/J!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "coset_ideal") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide -1 -2 -3 2) (("6" (skosimp) (("6" (lemma "coset_add[coset(R!1, J!1), add(R!1, J!1),
                product(R!1, J!1), J!1]") (("6" (inst -1 "R!1/J!1" "I!1/J!1" "x1!1`1" "x1!1`2") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "coset_ideal") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide -1 -2 2) (("7" (split) (("1" (expand "restrict" 1 4) (("1" (expand "/" 1 4) (("1" (skosimp) (("1" (replace -1 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "/" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (skosimp) (("1" (expand "restrict" 1 4) (("1" (expand "restrict" 1 9) (("1" (expand* "/" 1 (4 10)) (("1" (hide -1 -2) (("1" (replace -1 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand* "restrict" "/" 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "quotient_group_is_ring") nil nil)) nil) ("3" (hide -1 -2 2) (("3" (rewrite "quotient_group_is_ring") nil nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (inst 1 "I!1") (("2" (rewrite "ideal_is_coset") nil nil)) nil)) nil) ("3" (hide -1 -2 2) (("3" (inst 1 "J!1") (("3" (rewrite "ideal_is_coset") nil nil)) nil)) nil) ("4" (hide -1 -2 2) (("4" (rewrite "fullset_quot_group_is_ring") nil nil)) nil) ("5" (hide -1 -2 2) (("5" (rewrite "fullset_quot_group_is_ring") nil nil)) nil) ("6" (hide -1 -2 2) (("6" (rewrite "ideal_is_coset") nil nil)) nil) ("7" (hide -1 -2 2) (("7" (skosimp) (("7" (lemma "coset_product") (("7" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("7" (assert) nil nil)) nil)) nil)) nil)) nil) ("8" (hide -1 -2 2) (("8" (skosimp) (("8" (lemma "coset_add") (("8" (inst -1 "R!1" "I!1" "x1!1`1" "x1!1`2") (("8" (assert) nil nil)) nil)) nil)) nil)) nil) ("9" (hide -1 -2 2) (("9" (rewrite "ideal_is_coset") nil nil)) nil) ("10" (hide -1 -2 2) (("10" (skosimp) (("10" (lemma "coset_product") (("10" (inst -1 "R!1" "J!1" "x1!1`1" "x1!1`2") (("10" (assert) nil nil)) nil)) nil)) nil)) nil) ("11" (hide -1 -2 2) (("11" (skosimp) (("11" (lemma "coset_add") (("11" (inst -1 "R!1" "J!1" "x1!1`1" "x1!1`2") (("11" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((fullset_quot_group_is_ring formula-decl nil quotient_rings nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (coset_add formula-decl nil quotient_rings nil) (coset_product formula-decl nil quotient_rings nil) (coset_ideal formula-decl nil quotient_rings nil) (self_coset formula-decl nil ring_cosets_lemmas nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (quotient_group_is_ring formula-decl nil quotient_rings nil) (ideal type-eq-decl nil ring_ideal_def nil) (coset_subring formula-decl nil quotient_rings nil) (zero_is_member_R formula-decl nil ring_basic_properties nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (lproduct const-decl "set[T]" product_coset_def nil) (lc_gen const-decl "T" cosets_def nil) (left_swallow? const-decl "bool" ring_ideal_def nil) (left_ideal? const-decl "bool" ring_ideal_def nil) (right_swallow? const-decl "bool" ring_ideal_def nil) (right_ideal? const-decl "bool" ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (right_coset? const-decl "bool" cosets_def nil) (left_coset? const-decl "bool" cosets_def nil) (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil) (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil) (R_isomorphic? const-decl "bool" ring_homomorphisms_def nil) (first_isomorphism_th formula-decl nil ring_1st_isomorphism_theorem nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (product const-decl "set[T]" product_coset_def nil)) shostak)))
