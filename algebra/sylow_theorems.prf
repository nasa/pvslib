(sylow_theorems (IMP_finite_groups_TCC1 0 (IMP_finite_groups_TCC1-1 nil 3807089562 ("" (rewrite "T_is_group") nil nil) ((T_is_group formula-decl nil sylow_theorems nil)) nil (IMP_finite_groups assuming "finite_groups[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one].finite_groups" "fullset_is_group: ASSUMPTION group_def[finite_groups.T, finite_groups.*, finite_groups.one].group?(sets[finite_groups.T].fullset)"))) (p_subgroup_sylow?_TCC1 0 (p_subgroup_sylow?_TCC1-1 nil 3531141392 ("" (skosimp*) (("" (typepred "P!1" "G!1") (("" (hide -1) (("" (lemma "finite_subgroups") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((subgroup type-eq-decl nil group nil) (finite_group nonempty-type-eq-decl nil group nil) (finite_group? const-decl "bool" group_def nil) (subgroup? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (group? const-decl "bool" group_def nil) (one formal-const-decl "T" sylow_theorems nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil sylow_theorems nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finite_subgroups formula-decl nil group nil)) nil (p_subgroup_sylow? subtype "sylow_theorems.P" "finite_group[T, *, one]"))) (p_subgroup_sylow?_TCC2 0 (p_subgroup_sylow?_TCC2-1 nil 3531141392 ("" (skosimp*) (("" (hide -1) (("" (typepred "H!1" "G!1") (("" (hide -1) (("" (lemma "finite_subgroups") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_subgroups formula-decl nil group nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sylow_theorems nil) (set type-eq-decl nil sets nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (finite_group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (subgroup type-eq-decl nil group nil)) nil (p_subgroup_sylow? subtype "sylow_theorems.H" "finite_group[T, *, one]"))) (subgroup_is_factor_TCC1 0 (subgroup_is_factor_TCC1-1 nil 3530954477 ("" (skosimp) (("" (inst 1 "one") (("1" (rewrite "left_coset_one[T,*,one]") nil nil) ("2" (typepred "G!1") (("2" (expand* "group?" "monoid?" "monad?" "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((G!1 skolem-const-decl "group[T, *, one]" sylow_theorems nil) (group nonempty-type-eq-decl nil group nil) (group? const-decl "bool" group_def nil) (one formal-const-decl "T" sylow_theorems nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sylow_theorems nil) (normal_subgroup type-eq-decl nil normal_subgroups nil) (normal_subgroup? const-decl "boolean" normal_subgroups nil) (left_coset_one formula-decl nil cosets nil) (monoid? const-decl "bool" monoid_def nil) (member const-decl "bool" sets nil) (monad? const-decl "bool" monad_def nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil (subgroup_is_factor subtype "sylow_theorems.N" "left_cosets[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one](sylow_theorems.G, sylow_theorems.N)"))) (subgroup_is_factor_TCC2 0 (subgroup_is_factor_TCC2-1 nil 3883052818 ("" (skeep) (("" (rewrite "left_cosets_group[T, *, one]") nil nil)) nil) ((left_cosets_group formula-decl nil factor_groups nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (normal_subgroup? const-decl "boolean" normal_subgroups nil) (normal_subgroup type-eq-decl nil normal_subgroups nil) (T formal-type-decl nil sylow_theorems nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil)) nil (subgroup_is_factor assuming "group[left_cosets[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one](sylow_theorems.G, sylow_theorems.N), factor_groups[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one].mult(sylow_theorems.G, sylow_theorems.N), sylow_theorems.N].group" "fullset_is_group: ASSUMPTION group_def[group.T, group.*, group.one].group?(sets[group.T].fullset)"))) (subgroup_is_factor_TCC3 0 (subgroup_is_factor_TCC3-1 nil 3530954477 ("" (skosimp*) (("" (typepred "N!1") (("" (hide -1) (("" (lemma "normal_subgroup_tran[T, *, one]") (("1" (inst -1 "G!1" "H!1" "N!1") (("1" (assert) nil nil)) nil) ("2" (hide (-1 -2 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil) ((normal_subgroup type-eq-decl nil normal_subgroups nil) (normal_subgroup? const-decl "boolean" normal_subgroups nil) (group nonempty-type-eq-decl nil group nil) (group? const-decl "bool" group_def nil) (one formal-const-decl "T" sylow_theorems nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil sylow_theorems nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (normal_subgroup_tran formula-decl nil groups_scaf nil) (fullset const-decl "set" sets nil) (subgroup type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (T_is_group formula-decl nil sylow_theorems nil)) nil (subgroup_is_factor subtype "sylow_theorems.N" "normal_subgroup[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one](sylow_theorems.H)"))) (subgroup_is_factor_TCC4 0 (subgroup_is_factor_TCC4-1 nil 3530981159 ("" (skosimp*) (("" (prop) (("1" (hide (-2 -3)) (("1" (skosimp) (("1" (inst?) (("1" (hide -1) (("1" (typepred "a!1" "H!1") (("1" (expand* "subgroup?" "subset?" "member") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "/") (("2" (expand "restrict") (("2" (expand "left_cosets") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (G!1 skolem-const-decl "group[T, *, one]" sylow_theorems nil) (H!1 skolem-const-decl "subgroup[T, *, one](G!1)" sylow_theorems nil) (a!1 skolem-const-decl "(H!1)" sylow_theorems nil) (subgroup type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (group? const-decl "bool" group_def nil) (one formal-const-decl "T" sylow_theorems nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sylow_theorems nil) (/ const-decl "group[left_cosets[T, *, one](G, N), mult(G, N), N]" right_left_cosets nil) (left_cosets const-decl "setofsets[T]" right_left_cosets nil) (restrict const-decl "R" restrict nil)) nil (subgroup_is_factor subtype "right_left_cosets[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one]./(sylow_theorems.H, sylow_theorems.N)" "set[left_cosets[T, *, one](G, N)]"))) (subgroup_is_factor 0 (subgroup_is_factor-2 "" 3790334595 ("" (skosimp*) (("" (lemma "natural_homo[T, *, one,T, *, one]") (("1" (inst -1 "G!1" "N!1") (("1" (skosimp) (("1" (lemma "correspondence_theorem[T,*,one,left_cosets(G!1,N!1),mult(G!1,N!1),N!1]") (("1" (inst?) (("1" (assert) (("1" (skosimp) (("1" (expand "bijective?") (("1" (flatten) (("1" (hide -7) (("1" (expand "surjective?") (("1" (inst -3 "S!1") (("1" (skosimp) (("1" (inst 1 "x!1") (("1" (prop) (("1" (typepred "x!1") (("1" (hide-all-but (-1 -3 -10 1)) (("1" (replace -3 -2 rl) (("1" (hide -3) (("1" (expand "subgroup?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -4)) (("2" (replaces -1) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality 1) (("1" (iff) (("1" (prop) (("1" (expand "extend") (("1" (prop) (("1" (hide -1) (("1" (expand "image") (("1" (skosimp) (("1" (decompose-equality -2) (("1" (inst -1 "x!3") (("1" (expand "/") (("1" (expand* "restrict" "left_cosets") (("1" (inst?) (("1" (assert) nil nil) ("2" (typepred "x!3") (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (prop) (("1" (expand "image") (("1" (hide -1) (("1" (expand* "/" "restrict" "left_cosets") (("1" (skosimp) (("1" (inst 1 "a!1") (("1" (decompose-equality -2) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "a!1" "x!1") (("2" (hide (-2 -4 -5 -6)) (("2" (expand* "subgroup?" "subset?" "member") (("2" (inst?) (("2" (expand "restrict") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand* "/" "restrict" "left_cosets") (("2" (skosimp) (("2" (typepred "a!1" "x!1") (("2" (hide (-2 -4)) (("2" (expand* "subgroup?" "subset?" "member") (("2" (inst?) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "left_cosets_group[T, *, one]") nil nil)) nil) ("3" (hide-all-but 1) (("3" (inst 1 "one") (("1" (rewrite "left_coset_one[T, *, one]") nil nil) ("2" (rewrite "one_in") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil) ((one formal-const-decl "T" sylow_theorems nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (T formal-type-decl nil sylow_theorems nil) (natural_homo formula-decl nil homomorphism_lemmas nil) (fullset const-decl "set" sets nil) (group? const-decl "bool" group_def nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (monad nonempty-type-eq-decl nil monad nil) (monad? const-decl "bool" monad_def nil) (one_in formula-decl nil monad nil) (left_coset_one formula-decl nil cosets nil) (left_cosets_group formula-decl nil factor_groups nil) (/ const-decl "group[left_cosets[T, *, one](G, N), mult(G, N), N]" right_left_cosets nil) (homomorphism? const-decl "bool" homomorphisms nil) (homomorphism type-eq-decl nil homomorphisms nil) (surjective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (T_is_group formula-decl nil sylow_theorems nil) (a!1 skolem-const-decl "(x!1)" sylow_theorems nil) (a!1 skolem-const-decl "(x!1)" sylow_theorems nil) (member const-decl "bool" sets nil) (left_cosets const-decl "setofsets[T]" right_left_cosets nil) (x!3 skolem-const-decl "(restrict[T, (G!1), bool](x!1))" sylow_theorems nil) (x!1 skolem-const-decl "subgroup_contain[T, *, one](G!1, kernel(G!1, G!1 / N!1)(pi!1))" sylow_theorems nil) (pi!1 skolem-const-decl "[(G!1) -> (G!1 / N!1)]" sylow_theorems nil) (N!1 skolem-const-decl "normal_subgroup[T, *, one](G!1)" sylow_theorems nil) (G!1 skolem-const-decl "group[T, *, one]" sylow_theorems nil) (restrict const-decl "R" restrict nil) (image const-decl "set[R]" function_image nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (subgroup_contain type-eq-decl nil groups_scaf nil) (kernel const-decl "subgroup[T1, *, one1](G)" homomorphisms nil) (subset? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subgroup? const-decl "bool" group_def nil) (subgroup type-eq-decl nil group nil) (bijective? const-decl "bool" functions nil) (correspondence_theorem formula-decl nil isomorphism_theorems nil) (= const-decl "[T, T -> boolean]" equalities nil) (* const-decl "set[T]" cosets nil) (left_cosets type-eq-decl nil cosets nil) (mult const-decl "left_cosets(G, H)" factor_groups nil) (normal_subgroup type-eq-decl nil normal_subgroups nil) (normal_subgroup? const-decl "boolean" normal_subgroups nil) (group nonempty-type-eq-decl nil group nil)) shostak) (subgroup_is_factor-1 nil 3530954523 ("" (skosimp*) (("" (lemma "natural_homo[T, *, one,T, *, one]") (("1" (inst -1 "G!1" "N!1") (("1" (skosimp) (("1" (lemma "correspondence_theorem[T,*,one,left_cosets(G!1,N!1),mult(G!1,N!1),N!1]") (("1" (inst?) (("1" (assert) (("1" (skosimp) (("1" (expand "bijective?") (("1" (flatten) (("1" (hide -7) (("1" (expand "surjective?") (("1" (inst -3 "S!1") (("1" (skosimp) (("1" (inst 1 "x!1") (("1" (prop) (("1" (typepred "x!1") (("1" (hide-all-but (-1 -3 -10 1)) (("1" (replace -3 -2 rl) (("1" (hide -3) (("1" (expand "subgroup?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -4)) (("2" (replaces -1) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality 1) (("1" (iff) (("1" (prop) (("1" (expand "extend") (("1" (prop) (("1" (hide -1) (("1" (expand "image") (("1" (skosimp) (("1" (decompose-equality -2) (("1" (inst -1 "x!3") (("1" (expand "/") (("1" (expand* "restrict" "left_cosets") (("1" (inst?) (("1" (assert) nil nil) ("2" (typepred "x!3") (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (prop) (("1" (expand "image") (("1" (hide -1) (("1" (expand* "/" "restrict" "left_cosets") (("1" (skosimp) (("1" (inst 1 "a!1") (("1" (decompose-equality -2) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "a!1" "x!1") (("2" (hide (-2 -4 -5 -6)) (("2" (expand* "subgroup?" "subset?" "member") (("2" (inst?) (("2" (expand "restrict") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand* "/" "restrict" "left_cosets") (("2" (skosimp) (("2" (typepred "a!1" "x!1") (("2" (hide (-2 -4)) (("2" (expand* "subgroup?" "subset?" "member") (("2" (inst?) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (skosimp) (("2" (rewrite "T_is_group") nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "left_cosets_group[T, *, one]") nil nil)) nil) ("3" (hide-all-but 1) (("3" (inst 1 "one") (("1" (rewrite "left_coset_one[T, *, one]") nil nil) ("2" (rewrite "one_in") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil) ((natural_homo formula-decl nil homomorphism_lemmas nil) (fullset const-decl "set" sets nil) (set type-eq-decl nil sets nil) (/ const-decl "group[left_cosets[T, *, one](G, N), mult(G, N), N]" right_left_cosets nil) (member const-decl "bool" sets nil) (left_cosets const-decl "setofsets[T]" right_left_cosets nil) (subgroup_contain type-eq-decl nil groups_scaf nil) (subset? const-decl "bool" sets nil) (correspondence_theorem formula-decl nil isomorphism_theorems nil)) shostak)) (First_Sylow_Theorem_TCC1 0 (First_Sylow_Theorem_TCC2-1 nil 3531043400 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (divides const-decl "bool" divides nil) (prime? const-decl "bool" primes ints) (order const-decl "posnat" monad nil) (posnat_expt application-judgement "posnat" exponentiation nil)) nil (First_Sylow_Theorem subtype "sylow_theorems.m" "{jj: integers.int | booleans.=>(sylow_theorems.p = 0, jj /= 0)}"))) (First_Sylow_Theorem_TCC2 0 (First_Sylow_Theorem_TCC3-1 nil 3531043400 ("" (skosimp*) (("" (hide -) (("" (typepred "G!1" "H!1") (("" (lemma "finite_subgroups[T, *, one]") (("" (inst?) (("" (assert) (("" (hide (-2 -4)) (("" (expand* "group?" "finite_group?" "finite_monad?") (("" (expand "monoid?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_subgroups formula-decl nil group nil) (finite_monad? const-decl "bool" monad_def nil) (monoid? const-decl "bool" monoid_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sylow_theorems nil) (set type-eq-decl nil sets nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil) (finite_group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (subgroup type-eq-decl nil group nil)) nil (First_Sylow_Theorem subtype "sylow_theorems.H" "finite_monad[T, *, one]"))) (First_Sylow_Theorem_TCC3 0 (First_Sylow_Theorem_TCC1-1 nil 3531043400 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (divides const-decl "bool" divides nil) (prime? const-decl "bool" primes ints) (order const-decl "posnat" monad nil) (gcd const-decl "{k: posnat | divides(k, i) AND divides(k, j)}" gcd ints) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil)) nil (First_Sylow_Theorem subtype "(number_fields.-)(sylow_theorems.i, 1)" "nat"))) (First_Sylow_Theorem_TCC4 0 (First_Sylow_Theorem_TCC6-1 nil 3531043400 ("" (skosimp*) (("" (hide -) (("" (typepred "G!1" "K!1") (("" (lemma "finite_subgroups[T, *, one]") (("" (inst?) (("" (assert) (("" (hide (-2 -4)) (("" (expand* "group?" "finite_group?" "finite_monad?") (("" (expand "monoid?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_subgroups formula-decl nil group nil) (finite_monad? const-decl "bool" monad_def nil) (monoid? const-decl "bool" monoid_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sylow_theorems nil) (set type-eq-decl nil sets nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil) (finite_group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (subgroup type-eq-decl nil group nil)) nil (First_Sylow_Theorem subtype "sylow_theorems.K" "finite_monad[T, *, one]"))) (First_Sylow_Theorem 0 (First_Sylow_Theorem-3 "" 3883105476 ("" (induct "i") (("1" (hide 2) (("1" (typepred "i!1") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (skosimp*) (("3" (case-replace "j!1 = 0" :hide? T) (("1" (hide (-1 -2 -5 -6)) (("1" (lemma "cauchy_cor[T,*,one]") (("1" (inst -1 "G!1" "p!1") (("1" (prop) (("1" (rewrite "expt_x1_aux") nil nil) ("2" (skosimp*) (("2" (assert) (("2" (rewrite "expt_x1_aux") (("2" (rewrite "expt_x0_aux") (("2" (inst 1 "H!1") (("2" (assert) (("2" (lemma "one_is_subgroup") (("2" (inst -1 "H!1") (("2" (lemma "order_is_1") (("2" (inst?) (("2" (assert) (("2" (expand "one_group") (("2" (replace -1 -2 rl) (("2" (expand "normal_subgroup?") (("2" (assert) (("2" (skosimp*) (("2" (expand* "subset?" "member") (("2" (skosimp) (("2" (expand "*") (("2" (skosimp) (("2" (typepred "h!1") (("2" (skosimp) (("2" (typepred "h!2") (("2" (replaces -3) (("2" (expand "singleton") (("2" (replaces -1) (("2" (replaces -1) (("2" (rewrite "one_right") (("2" (rewrite "one_right") (("2" (rewrite "inv_left") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 1) (("3" (lemma "divides_power") (("3" (expand "^") (("3" (inst?) (("3" (replaces -3) (("3" (hide -2) (("3" (rewrite "divides_prod1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 1) (("4" (lemma "divides_power") (("4" (expand "^") (("4" (inst?) (("4" (replaces -3) (("4" (hide -2) (("4" (rewrite "divides_prod1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (prop) (("1" (inst -1 "m!1" "n!1" "p!1" "G!1") (("1" (assert) (("1" (flatten) (("1" (hide -2) (("1" (skosimp) (("1" (lemma "normalizer_index[T,*,one]") (("1" (inst -1 "p!1" "G!1" "H!1") (("1" (prop) (("1" (lemma "card_factor[T,*,one]") (("1" (inst?) (("1" (prop) (("1" (rewrite "card_extend[set[T], left_cosets[T, *, one](normalizer(G!1, H!1), H!1)]") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (lemma "cauchy_cor[left_cosets(normalizer(G!1, H!1),H!1),mult(normalizer(G!1, H!1),H!1),H!1]") (("1" (inst -1 "normalizer(G!1, H!1) / H!1" "p!1") (("1" (prop) (("1" (skosimp) (("1" (lemma "subgroup_is_factor") (("1" (inst -1 "normalizer(G!1, H!1)" "H!1" "H!2") (("1" (skosimp) (("1" (hide -4) (("1" (replaces -2) (("1" (lemma "Lagrange_index[T,*,one]") (("1" (inst -1 "H!3" "H!1") (("1" (assert) (("1" (lemma "card_factor[T,*,one]") (("1" (inst -1 "H!3" "H!1") (("1" (prop) (("1" (rewrite "card_extend[set[T], left_cosets[T, *, one](H!3, H!1)]") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (replace -4 -1) (("1" (case-replace "card(H!3 / H!1) = p!1" :hide? T) (("1" (inst 1 "H!3") (("1" (hide-all-but (-1 1 2)) (("1" (rewrite "expt_plus_aux") (("1" (rewrite "expt_x1_aux") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!3") (("2" (hide -1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_transitive[T, *, one]") (("1" (inst -1 "G!1" "normalizer(G!1, H!1)" "H!3") (("1" (assert) nil nil)) nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "order") (("2" (rewrite "card_def[left_cosets(normalizer(G!1, H!1), H!1)]") (("2" (rewrite "card_def[left_cosets[T, *, one](H!3, H!1)]") (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (expand "Card") (("2" (expand "inj_set") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (lemma "restrict_finite[setof[T], left_cosets[T, *, one](H!3, H!1)]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "left_cosets_partition[T,*,one]") (("2" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (typepred "H!3") (("2" (hide (-1 2)) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) (("2" (lemma "finite_subgroups") (("2" (inst -1 "H!3" "normalizer(G!1, H!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!3") (("2" (hide -1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) (("2" (lemma "finite_subgroups") (("2" (inst -1 "H!3" "normalizer(G!1, H!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (typepred "H!3" "H!1") (("3" (hide (-1 -3)) (("3" (lemma "normal_in_normalizer[T, *, one]") (("3" (inst?) (("3" (assert) (("3" (lemma "normal_subgroup_tran[T, *, one]") (("1" (inst -1 "normalizer(G!1, H!1)" "H!3" "H!1") (("1" (assert) nil nil)) nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!1" "G!1") (("2" (hide -1) (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "H!3") (("3" (hide -1) (("3" (lemma "normalizer_is_subgroup[T, *, one]") (("3" (inst?) (("3" (assert) (("3" (typepred "G!1") (("3" (lemma "finite_subgroups") (("3" (inst?) (("3" (assert) (("3" (lemma "finite_subgroups") (("3" (inst -1 "H!3" "normalizer(G!1, H!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "order") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (expand "finite_group?") (("2" (prop) (("1" (lemma "right_left_cosets[T,*,one].divide_TCC4") (("1" (inst?) (("1" (hide 2) (("1" (lemma "normal_in_normalizer[T, *, one]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "restrict_finite[setof[T],left_cosets[T, *, one](normalizer[T, *, one](G!1, H!1), H!1)]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "left_cosets_partition[T,*,one]") (("2" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "left_cosets_group[T, *, one]") (("2" (inst?) (("1" (hide 2) (("1" (lemma "normal_in_normalizer[T, *, one]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_is_group[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (inst 1 "one") (("1" (rewrite "left_coset_one") nil nil) ("2" (expand "normalizer") (("2" (expand "extend") (("2" (prop) (("1" (rewrite "inv_one") (("1" (rewrite "left_coset_one") (("1" (rewrite "right_coset_one") nil nil)) nil)) nil) ("2" (rewrite "one_in") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (lemma "restrict_finite[setof[T],left_cosets[T, *, one](normalizer[T, *, one](G!1, H!1), H!1)]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "left_cosets_partition[T,*,one]") (("2" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "normal_in_normalizer[T, *, one]") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_is_group[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 1)) (("2" (lemma "p_group_iff_power[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -4 -6 1)) (("3" (lemma "Lagrange_index[T,*,one]") (("3" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "divides") (("1" (lemma "div_cancel4") (("1" (inst -1 "expt(p!1, j!1)" "index(G!1, H!1)" "expt(p!1, n!1) * m!1") (("1" (prop) (("1" (hide (-2 -3)) (("1" (rewrite "times_div2" :dir rl) (("1" (lemma "exponentiation.expt_div") (("1" (inst -1 "n!1" "j!1" "p!1") (("1" (expand "^") (("1" (lemma "expt_plus") (("1" (inst -1 "1" "n!1 - j!1 - 1" "p!1") (("1" (assert) (("1" (rewrite "expt_x1") (("1" (expand "^") (("1" (replaces -1) (("1" (inst 1 "expt(p!1, -1 - j!1 + n!1) * m!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!1") (("2" (hide -1) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (skosimp) (("2" (lemma "normalizer_index[T,*,one]") (("2" (inst -1 "p!1" "G!1" "S!1") (("2" (prop) (("1" (lemma "card_factor[T,*,one]") (("1" (inst?) (("1" (prop) (("1" (rewrite "card_extend[set[T], left_cosets[T, *, one](normalizer(G!1, S!1), S!1)]") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (lemma "cauchy_cor[left_cosets(normalizer(G!1, S!1),S!1),mult(normalizer(G!1, S!1),S!1),S!1]") (("1" (inst -1 "normalizer(G!1, S!1) / S!1" "p!1") (("1" (prop) (("1" (skosimp) (("1" (lemma "subgroup_is_factor") (("1" (inst -1 "normalizer(G!1, S!1)" "S!1" "H!1") (("1" (skosimp) (("1" (hide -4) (("1" (replaces -2) (("1" (lemma "Lagrange_index[T,*,one]") (("1" (inst -1 "H!2" "S!1") (("1" (assert) (("1" (lemma "card_factor[T,*,one]") (("1" (inst -1 "H!2" "S!1") (("1" (prop) (("1" (rewrite "card_extend[set[T], left_cosets[T, *, one](H!2, S!1)]") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (replace -4 -1) (("1" (case-replace "card(H!2 / S!1) = p!1" :hide? T) (("1" (inst 1 "H!2") (("1" (hide-all-but (-1 1 2)) (("1" (rewrite "expt_plus_aux") (("1" (rewrite "expt_x1_aux") (("1" (assert) (("1" (hide (- 2)) (("1" (typepred "H!2") (("1" (hide -1) (("1" (lemma "normal_in_normalizer[T,*,one]") (("1" (inst?) (("1" (assert) (("1" (lemma "normal_subgroup_tran[T, *, one]") (("1" (inst -1 "normalizer(G!1, S!1)" "H!2" "S!1") (("1" (assert) nil nil)) nil) ("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!2") (("2" (hide -1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_transitive[T, *, one]") (("1" (inst -1 "G!1" "normalizer(G!1, S!1)" "H!2") (("1" (assert) nil nil)) nil) ("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "order") (("2" (rewrite "card_def[left_cosets(normalizer(G!1, S!1), S!1)]") (("2" (rewrite "card_def[left_cosets[T, *, one](H!2, S!1)]") (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (expand "Card") (("2" (expand "inj_set") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (lemma "restrict_finite[setof[T], left_cosets[T, *, one](H!2, S!1)]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "left_cosets_partition[T,*,one]") (("2" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (typepred "H!2") (("2" (hide (-1 2)) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) (("2" (lemma "finite_subgroups") (("2" (inst -1 "H!2" "normalizer(G!1, S!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!2") (("2" (hide -1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) (("2" (lemma "finite_subgroups") (("2" (inst -1 "H!2" "normalizer(G!1, S!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (typepred "H!2" "S!1") (("3" (hide (-1 -3)) (("3" (lemma "normal_in_normalizer[T, *, one]") (("3" (inst?) (("3" (assert) (("3" (lemma "normal_subgroup_tran[T, *, one]") (("1" (inst -1 "normalizer(G!1, S!1)" "H!2" "S!1") (("1" (assert) nil nil)) nil) ("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "S!1" "G!1") (("2" (hide -1) (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "H!2") (("3" (hide -1) (("3" (lemma "normalizer_is_subgroup[T, *, one]") (("3" (inst?) (("3" (assert) (("3" (typepred "G!1") (("3" (lemma "finite_subgroups") (("3" (inst?) (("3" (assert) (("3" (lemma "finite_subgroups") (("3" (inst -1 "H!2" "normalizer(G!1, S!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "order") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (expand "finite_group?") (("2" (prop) (("1" (lemma "normal_in_normalizer[T, *, one]") (("1" (inst?) (("1" (assert) (("1" (lemma "right_left_cosets[T, *, one].divide_TCC4") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "restrict_finite[setof[T],left_cosets[T, *, one](normalizer[T, *, one](G!1, S!1), S!1)]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "left_cosets_partition[T,*,one]") (("2" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "left_cosets_group[T, *, one]") (("2" (inst?) (("1" (hide 2) (("1" (lemma "normal_in_normalizer[T, *, one]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_is_group[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (inst 1 "one") (("1" (rewrite "left_coset_one") nil nil) ("2" (expand "normalizer") (("2" (expand "extend") (("2" (prop) (("1" (rewrite "inv_one") (("1" (rewrite "left_coset_one") (("1" (rewrite "right_coset_one") nil nil)) nil)) nil) ("2" (rewrite "one_in") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (lemma "restrict_finite[setof[T],left_cosets[T, *, one](normalizer[T, *, one](G!1, S!1), S!1)]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "left_cosets_partition[T,*,one]") (("2" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "normal_in_normalizer[T, *, one]") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_is_group[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 1)) (("2" (lemma "p_group_iff_power[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -4 -6 1)) (("3" (lemma "Lagrange_index[T,*,one]") (("3" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "divides") (("1" (lemma "div_cancel4") (("1" (inst -1 "expt(p!1, j!1)" "index(G!1, S!1)" "expt(p!1, n!1) * m!1") (("1" (prop) (("1" (hide (-2 -3)) (("1" (rewrite "times_div2" :dir rl) (("1" (lemma "exponentiation.expt_div") (("1" (inst -1 "n!1" "j!1" "p!1") (("1" (expand "^") (("1" (lemma "expt_plus_aux") (("1" (inst -1 "1" "n!1 - j!1 - 1" "p!1") (("1" (assert) (("1" (rewrite "expt_x1_aux") (("1" (replaces -1) (("1" (inst 1 "expt(p!1, -1 - j!1 + n!1) * m!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "S!1") (("2" (hide -1) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (hide-all-but 1) (("4" (typepred "K!1") (("4" (typepred "G!1") (("4" (lemma "finite_subgroups") (("4" (inst?) (("4" (assert) (("4" (expand* "group?" "monoid?" "finite_monad?" "finite_group?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (hide-all-but 1) (("6" (typepred "S!1") (("6" (typepred "G!1") (("6" (lemma "finite_subgroups") (("6" (inst?) (("6" (assert) (("6" (expand* "group?" "monoid?" "finite_monad?" "finite_group?") (("6" (flatten) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skosimp*) (("7" (typepred "H!1") (("7" (typepred "G!1") (("7" (lemma "finite_subgroups") (("7" (inst?) (("7" (assert) (("7" (expand* "group?" "monoid?" "finite_monad?" "finite_group?") (("7" (flatten) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (First_Sylow_Theorem-2 "" 3757886237 ("" (induct "i") (("1" (hide 2) (("1" (typepred "i!1") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (skosimp*) (("3" (case-replace "j!1 = 0" :hide? T) (("1" (hide (-1 -2 -5 -6)) (("1" (lemma "cauchy_cor[T,*,one]") (("1" (inst -1 "G!1" "p!1") (("1" (prop) (("1" (rewrite "expt_x1_aux") nil nil) ("2" (skosimp*) (("2" (assert) (("2" (rewrite "expt_x1_aux") (("2" (rewrite "expt_x0_aux") (("2" (inst 1 "H!1") (("2" (assert) (("2" (lemma "one_is_subgroup") (("2" (inst -1 "H!1") (("2" (lemma "order_is_1") (("2" (inst?) (("2" (assert) (("2" (expand "one_group") (("2" (replace -1 -2 rl) (("2" (expand "normal_subgroup?") (("2" (assert) (("2" (skosimp*) (("2" (expand* "subset?" "member") (("2" (skosimp) (("2" (expand "*") (("2" (skosimp) (("2" (typepred "h!1") (("2" (skosimp) (("2" (typepred "h!2") (("2" (replaces -3) (("2" (expand "singleton") (("2" (replaces -1) (("2" (replaces -1) (("2" (rewrite "one_right") (("2" (rewrite "one_right") (("2" (rewrite "inv_left") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 1) (("3" (lemma "divides_power") (("3" (expand "^") (("3" (inst?) (("3" (replaces -3) (("3" (hide -2) (("3" (rewrite "divides_prod1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 1) (("4" (lemma "divides_power") (("4" (expand "^") (("4" (inst?) (("4" (replaces -3) (("4" (hide -2) (("4" (rewrite "divides_prod1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (prop) (("1" (inst -1 "m!1" "n!1" "p!1" "G!1") (("1" (assert) (("1" (flatten) (("1" (hide -2) (("1" (skosimp) (("1" (lemma "normalizer_index[T,*,one]") (("1" (inst -1 "p!1" "G!1" "H!1") (("1" (prop) (("1" (lemma "card_factor[T,*,one]") (("1" (inst?) (("1" (prop) (("1" (rewrite "card_extend[set[T], left_cosets[T, *, one](normalizer(G!1, H!1), H!1)]") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (lemma "cauchy_cor[left_cosets(normalizer(G!1, H!1),H!1),mult(normalizer(G!1, H!1),H!1),H!1]") (("1" (inst -1 "normalizer(G!1, H!1) / H!1" "p!1") (("1" (prop) (("1" (skosimp) (("1" (lemma "subgroup_is_factor") (("1" (inst -1 "normalizer(G!1, H!1)" "H!1" "H!2") (("1" (skosimp) (("1" (hide -4) (("1" (replaces -2) (("1" (lemma "Lagrange_index[T,*,one]") (("1" (inst -1 "H!3" "H!1") (("1" (assert) (("1" (lemma "card_factor[T,*,one]") (("1" (inst -1 "H!3" "H!1") (("1" (prop) (("1" (rewrite "card_extend[set[T], left_cosets[T, *, one](H!3, H!1)]") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (replace -4 -1) (("1" (case-replace "card(H!3 / H!1) = p!1" :hide? T) (("1" (inst 1 "H!3") (("1" (hide-all-but (-1 1 2)) (("1" (rewrite "expt_plus_aux") (("1" (rewrite "expt_x1_aux") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!3") (("2" (hide -1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_transitive[T, *, one]") (("1" (inst -1 "G!1" "normalizer(G!1, H!1)" "H!3") (("1" (assert) nil nil)) nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "order") (("2" (rewrite "card_def[left_cosets(normalizer(G!1, H!1), H!1)]") (("2" (rewrite "card_def[left_cosets[T, *, one](H!3, H!1)]") (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (expand "Card") (("2" (expand "inj_set") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (lemma "restrict_finite[setof[T], left_cosets[T, *, one](H!3, H!1)]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "left_cosets_partition[T,*,one]") (("2" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (typepred "H!3") (("2" (hide (-1 2)) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) (("2" (lemma "finite_subgroups") (("2" (inst -1 "H!3" "normalizer(G!1, H!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!3") (("2" (hide -1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) (("2" (lemma "finite_subgroups") (("2" (inst -1 "H!3" "normalizer(G!1, H!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (typepred "H!3" "H!1") (("3" (hide (-1 -3)) (("3" (lemma "normal_in_normalizer[T, *, one]") (("3" (inst?) (("3" (assert) (("3" (lemma "normal_subgroup_tran[T, *, one]") (("1" (inst -1 "normalizer(G!1, H!1)" "H!3" "H!1") (("1" (assert) nil nil)) nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!1" "G!1") (("2" (hide -1) (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "H!3") (("3" (hide -1) (("3" (lemma "normalizer_is_subgroup[T, *, one]") (("3" (inst?) (("3" (assert) (("3" (typepred "G!1") (("3" (lemma "finite_subgroups") (("3" (inst?) (("3" (assert) (("3" (lemma "finite_subgroups") (("3" (inst -1 "H!3" "normalizer(G!1, H!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "order") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (expand "finite_group?") (("2" (prop) (("1" (lemma "right_left_cosets[T,*,one].divide_TCC3") (("1" (inst?) (("1" (hide 2) (("1" (lemma "normal_in_normalizer[T, *, one]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "restrict_finite[setof[T],left_cosets[T, *, one](normalizer[T, *, one](G!1, H!1), H!1)]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "left_cosets_partition[T,*,one]") (("2" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "left_cosets_group[T, *, one]") (("2" (inst?) (("1" (hide 2) (("1" (lemma "normal_in_normalizer[T, *, one]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_is_group[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (inst 1 "one") (("1" (rewrite "left_coset_one") nil nil) ("2" (expand "normalizer") (("2" (expand "extend") (("2" (prop) (("1" (rewrite "inv_one") (("1" (rewrite "left_coset_one") (("1" (rewrite "right_coset_one") nil nil)) nil)) nil) ("2" (rewrite "one_in") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (lemma "restrict_finite[setof[T],left_cosets[T, *, one](normalizer[T, *, one](G!1, H!1), H!1)]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "left_cosets_partition[T,*,one]") (("2" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "normal_in_normalizer[T, *, one]") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_is_group[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 1)) (("2" (lemma "p_group_iff_power[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -4 -6 1)) (("3" (lemma "Lagrange_index[T,*,one]") (("3" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "divides") (("1" (lemma "div_cancel4") (("1" (inst -1 "expt(p!1, j!1)" "index(G!1, H!1)" "expt(p!1, n!1) * m!1") (("1" (prop) (("1" (hide (-2 -3)) (("1" (rewrite "times_div2" :dir rl) (("1" (lemma "exponentiation.expt_div") (("1" (inst -1 "n!1" "j!1" "p!1") (("1" (expand "^") (("1" (lemma "expt_plus") (("1" (inst -1 "1" "n!1 - j!1 - 1" "p!1") (("1" (assert) (("1" (rewrite "expt_x1") (("1" (expand "^") (("1" (replaces -1) (("1" (inst 1 "expt(p!1, -1 - j!1 + n!1) * m!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!1") (("2" (hide -1) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (skosimp) (("2" (lemma "normalizer_index[T,*,one]") (("2" (inst -1 "p!1" "G!1" "S!1") (("2" (prop) (("1" (lemma "card_factor[T,*,one]") (("1" (inst?) (("1" (prop) (("1" (rewrite "card_extend[set[T], left_cosets[T, *, one](normalizer(G!1, S!1), S!1)]") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (lemma "cauchy_cor[left_cosets(normalizer(G!1, S!1),S!1),mult(normalizer(G!1, S!1),S!1),S!1]") (("1" (inst -1 "normalizer(G!1, S!1) / S!1" "p!1") (("1" (prop) (("1" (skosimp) (("1" (lemma "subgroup_is_factor") (("1" (inst -1 "normalizer(G!1, S!1)" "S!1" "H!1") (("1" (skosimp) (("1" (hide -4) (("1" (replaces -2) (("1" (lemma "Lagrange_index[T,*,one]") (("1" (inst -1 "H!2" "S!1") (("1" (assert) (("1" (lemma "card_factor[T,*,one]") (("1" (inst -1 "H!2" "S!1") (("1" (prop) (("1" (rewrite "card_extend[set[T], left_cosets[T, *, one](H!2, S!1)]") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (replace -4 -1) (("1" (case-replace "card(H!2 / S!1) = p!1" :hide? T) (("1" (inst 1 "H!2") (("1" (hide-all-but (-1 1 2)) (("1" (rewrite "expt_plus_aux") (("1" (rewrite "expt_x1_aux") (("1" (assert) (("1" (hide (- 2)) (("1" (typepred "H!2") (("1" (hide -1) (("1" (lemma "normal_in_normalizer[T,*,one]") (("1" (inst?) (("1" (assert) (("1" (lemma "normal_subgroup_tran[T, *, one]") (("1" (inst -1 "normalizer(G!1, S!1)" "H!2" "S!1") (("1" (assert) nil nil)) nil) ("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!2") (("2" (hide -1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_transitive[T, *, one]") (("1" (inst -1 "G!1" "normalizer(G!1, S!1)" "H!2") (("1" (assert) nil nil)) nil) ("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "order") (("2" (rewrite "card_def[left_cosets(normalizer(G!1, S!1), S!1)]") (("2" (rewrite "card_def[left_cosets[T, *, one](H!2, S!1)]") (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (expand "Card") (("2" (expand "inj_set") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (lemma "restrict_finite[setof[T], left_cosets[T, *, one](H!2, S!1)]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "left_cosets_partition[T,*,one]") (("2" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (typepred "H!2") (("2" (hide (-1 2)) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) (("2" (lemma "finite_subgroups") (("2" (inst -1 "H!2" "normalizer(G!1, S!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!2") (("2" (hide -1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) (("2" (lemma "finite_subgroups") (("2" (inst -1 "H!2" "normalizer(G!1, S!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (typepred "H!2" "S!1") (("3" (hide (-1 -3)) (("3" (lemma "normal_in_normalizer[T, *, one]") (("3" (inst?) (("3" (assert) (("3" (lemma "normal_subgroup_tran[T, *, one]") (("1" (inst -1 "normalizer(G!1, S!1)" "H!2" "S!1") (("1" (assert) nil nil)) nil) ("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "S!1" "G!1") (("2" (hide -1) (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "H!2") (("3" (hide -1) (("3" (lemma "normalizer_is_subgroup[T, *, one]") (("3" (inst?) (("3" (assert) (("3" (typepred "G!1") (("3" (lemma "finite_subgroups") (("3" (inst?) (("3" (assert) (("3" (lemma "finite_subgroups") (("3" (inst -1 "H!2" "normalizer(G!1, S!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "order") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (expand "finite_group?") (("2" (prop) (("1" (lemma "normal_in_normalizer[T, *, one]") (("1" (inst?) (("1" (assert) (("1" (lemma "right_left_cosets[T, *, one].divide_TCC3") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "restrict_finite[setof[T],left_cosets[T, *, one](normalizer[T, *, one](G!1, S!1), S!1)]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "left_cosets_partition[T,*,one]") (("2" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "left_cosets_group[T, *, one]") (("2" (inst?) (("1" (hide 2) (("1" (lemma "normal_in_normalizer[T, *, one]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_is_group[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (inst 1 "one") (("1" (rewrite "left_coset_one") nil nil) ("2" (expand "normalizer") (("2" (expand "extend") (("2" (prop) (("1" (rewrite "inv_one") (("1" (rewrite "left_coset_one") (("1" (rewrite "right_coset_one") nil nil)) nil)) nil) ("2" (rewrite "one_in") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (lemma "restrict_finite[setof[T],left_cosets[T, *, one](normalizer[T, *, one](G!1, S!1), S!1)]") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (lemma "left_cosets_partition[T,*,one]") (("2" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "normal_in_normalizer[T, *, one]") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_is_group[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 1)) (("2" (lemma "p_group_iff_power[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -4 -6 1)) (("3" (lemma "Lagrange_index[T,*,one]") (("3" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "divides") (("1" (lemma "div_cancel4") (("1" (inst -1 "expt(p!1, j!1)" "index(G!1, S!1)" "expt(p!1, n!1) * m!1") (("1" (prop) (("1" (hide (-2 -3)) (("1" (rewrite "times_div2" :dir rl) (("1" (lemma "exponentiation.expt_div") (("1" (inst -1 "n!1" "j!1" "p!1") (("1" (expand "^") (("1" (lemma "expt_plus_aux") (("1" (inst -1 "1" "n!1 - j!1 - 1" "p!1") (("1" (assert) (("1" (rewrite "expt_x1_aux") (("1" (replaces -1) (("1" (inst 1 "expt(p!1, -1 - j!1 + n!1) * m!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "S!1") (("2" (hide -1) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (hide-all-but 1) (("4" (typepred "K!1") (("4" (typepred "G!1") (("4" (lemma "finite_subgroups") (("4" (inst?) (("4" (assert) (("4" (expand* "group?" "monoid?" "finite_monad?" "finite_group?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (hide-all-but 1) (("6" (typepred "S!1") (("6" (typepred "G!1") (("6" (lemma "finite_subgroups") (("6" (inst?) (("6" (assert) (("6" (expand* "group?" "monoid?" "finite_monad?" "finite_group?") (("6" (flatten) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skosimp*) (("7" (typepred "H!1") (("7" (typepred "G!1") (("7" (lemma "finite_subgroups") (("7" (inst?) (("7" (assert) (("7" (expand* "group?" "monoid?" "finite_monad?" "finite_group?") (("7" (flatten) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((monoid? const-decl "bool" monoid_def nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (S!1 skolem-const-decl "subgroup[T, *, one](G!1)" sylow_theorems nil) (H!2 skolem-const-decl "subgroup[T, *, one](normalizer(G!1, S!1))" sylow_theorems nil) (index const-decl "nat" right_left_cosets nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (expt_div formula-decl nil exponentiation nil) (expt_x1 formula-decl nil exponentiation nil) (nil application-judgement "above(n)" exp2 nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (expt_plus formula-decl nil exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (times_div2 formula-decl nil real_props nil) (div_cancel4 formula-decl nil real_props nil) (p_group_iff_power formula-decl nil p_groups nil) (card_factor formula-decl nil right_left_cosets nil) (divide_TCC4 subtype-tcc nil right_left_cosets nil) (subgroup_is_factor formula-decl nil sylow_theorems nil) (H!3 skolem-const-decl "subgroup[T, *, one](normalizer(G!1, H!1))" sylow_theorems nil) (restrict_finite formula-decl nil restrict_set_props nil) (setof type-eq-decl nil defined_types nil) (left_cosets_partition formula-decl nil right_left_cosets nil) (finite_subgroups formula-decl nil group nil) (finite_partition? const-decl "bool" lagrange_scaf nil) (setofsets type-eq-decl nil sets nil) (left_cosets const-decl "setofsets[T]" right_left_cosets nil) (card_def formula-decl nil finite_sets nil) (inj_set const-decl "(nonempty?[nat])" finite_sets nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_plus_aux formula-decl nil exponentiation nil) (normalizer_is_subgroup formula-decl nil normalizer_centralizer nil) (T_is_group formula-decl nil sylow_theorems nil) (subgroup_transitive formula-decl nil groups_scaf nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (normal_in_normalizer formula-decl nil normalizer_centralizer nil) (normal_subgroup_tran formula-decl nil groups_scaf nil) (Lagrange_index formula-decl nil lagrange_index nil) (left_cosets_group formula-decl nil factor_groups nil) (subgroup_is_group formula-decl nil group nil) (left_coset_one formula-decl nil cosets nil) (extend const-decl "R" extend nil) (monad nonempty-type-eq-decl nil monad nil) (monad? const-decl "bool" monad_def nil) (one_in formula-decl nil monad nil) (inv_one formula-decl nil group nil) (right_coset_one formula-decl nil cosets nil) (card_extend formula-decl nil extend_set_props nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (normal_subgroup type-eq-decl nil normal_subgroups nil) (mult const-decl "left_cosets(G, H)" factor_groups nil) (/ const-decl "group[left_cosets[T, *, one](G, N), mult(G, N), N]" right_left_cosets nil) (left_cosets type-eq-decl nil cosets nil) (H!1 skolem-const-decl "subgroup[T, *, one](G!1)" sylow_theorems nil) (G!1 skolem-const-decl "finite_group[T, *, one]" sylow_theorems nil) (normalizer const-decl "{S: set[T] | subset?(S, G)}" normalizer_centralizer nil) (normalizer_index formula-decl nil p_groups nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (^ const-decl "real" exponentiation nil) (divides_prod1 formula-decl nil divides nil) (divides_power formula-decl nil general_properties nil) (one_is_subgroup formula-decl nil group nil) (order_is_1 formula-decl nil monad nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[T]" countable_props sets_aux) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (* const-decl "set[T]" cosets nil) (* const-decl "set[T]" cosets nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (singleton const-decl "(singleton?)" sets nil) (fullset const-decl "set" sets nil) (inv_left formula-decl nil group nil) (one_right formula-decl nil group nil) (TRUE const-decl "bool" booleans nil) (one_group const-decl "finite_group" group nil) (expt_x0_aux formula-decl nil exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (expt_x1_aux formula-decl nil exponentiation nil) (cauchy_cor formula-decl nil cauchy nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat_induction formula-decl nil naturalnumbers nil) (normal_subgroup? const-decl "boolean" normal_subgroups nil) (pred type-eq-decl nil defined_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (T formal-type-decl nil sylow_theorems nil) (set type-eq-decl nil sets nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil) (finite_group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (prime? const-decl "bool" primes ints) (= const-decl "[T, T -> boolean]" equalities nil) (finite_monad? const-decl "bool" monad_def nil) (finite_monad nonempty-type-eq-decl nil monad nil) (order const-decl "posnat" monad nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt def-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (divides const-decl "bool" divides nil) (gcd const-decl "{k: posnat | divides(k, i) AND divides(k, j)}" gcd ints) (<= const-decl "bool" reals nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (subgroup type-eq-decl nil group nil) (int_minus_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak) (First_Sylow_Theorem-1 nil 3531043866 ("" (induct "i") (("1" (hide 2) (("1" (typepred "i!1") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (skosimp*) (("3" (case-replace "j!1 = 0" :hide? T) (("1" (hide (-1 -2 -5 -6)) (("1" (lemma "cauchy_cor[T,*,one]") (("1" (inst -1 "G!1" "p!1") (("1" (prop) (("1" (rewrite "expt_x1") nil nil) ("2" (skosimp*) (("2" (assert) (("2" (rewrite "expt_x1") (("2" (rewrite "expt_x0") (("2" (inst 1 "H!1") (("2" (assert) (("2" (lemma "one_is_subgroup") (("2" (inst -1 "H!1") (("2" (lemma "order_is_1") (("2" (inst?) (("2" (assert) (("2" (expand "one_group") (("2" (replace -1 -2 rl) (("2" (expand "normal_subgroup?") (("2" (assert) (("2" (skosimp*) (("2" (expand* "subset?" "member") (("2" (skosimp) (("2" (expand "*") (("2" (skosimp) (("2" (typepred "h!1") (("2" (skosimp) (("2" (typepred "h!2") (("2" (replaces -3) (("2" (expand "singleton") (("2" (replaces -1) (("2" (replaces -1) (("2" (rewrite "one_right") (("2" (rewrite "inv_left") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 1) (("3" (lemma "divides_power") (("3" (inst?) (("3" (replaces -3) (("3" (hide -2) (("3" (rewrite "divides_prod1") nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 1) (("4" (lemma "divides_power") (("4" (inst?) (("4" (replaces -3) (("4" (hide -2) (("4" (rewrite "divides_prod1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (prop) (("1" (inst -1 "m!1" "n!1" "p!1" "G!1") (("1" (assert) (("1" (flatten) (("1" (hide -2) (("1" (skosimp) (("1" (lemma "normalizer_index[T,*,one]") (("1" (inst -1 "p!1" "G!1" "H!1") (("1" (prop) (("1" (lemma "card_factor[T,*,one]") (("1" (inst?) (("1" (prop) (("1" (rewrite "card_extend[set[T], left_cosets[T, *, one](normalizer(G!1, H!1), H!1)]") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (lemma "cauchy_cor[left_cosets(normalizer(G!1, H!1),H!1),mult(normalizer(G!1, H!1),H!1),H!1]") (("1" (inst -1 "normalizer(G!1, H!1) / H!1" "p!1") (("1" (prop) (("1" (skosimp) (("1" (lemma "subgroup_is_factor") (("1" (inst -1 "normalizer(G!1, H!1)" "H!1" "H!2") (("1" (skosimp) (("1" (hide -4) (("1" (replaces -2) (("1" (lemma "Lagrange_index[T,*,one]") (("1" (inst -1 "H!3" "H!1") (("1" (assert) (("1" (lemma "card_factor[T,*,one]") (("1" (inst -1 "H!3" "H!1") (("1" (prop) (("1" (rewrite "card_extend[set[T], left_cosets[T, *, one](H!3, H!1)]") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (replace -4 -1) (("1" (case-replace "card(H!3 / H!1) = p!1" :hide? T) (("1" (inst 1 "H!3") (("1" (hide-all-but (-1 1 2)) (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!3") (("2" (hide -1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_transitive[T, *, one]") (("2" (inst -1 "G!1" "normalizer(G!1, H!1)" "H!3") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "order") (("2" (rewrite "card_def[left_cosets(normalizer(G!1, H!1), H!1)]") (("2" (rewrite "card_def[left_cosets[T, *, one](H!3, H!1)]") (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (expand "Card") (("2" (expand "inj_set") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (lemma "restrict_finite[setof[T], left_cosets[T, *, one](H!3, H!1)]") (("2" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "left_cosets_partition[T,*,one]") (("1" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (typepred "H!3") (("2" (hide (-1 2)) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("1" (assert) (("1" (lemma "finite_subgroups") (("1" (inst -1 "H!3" "normalizer(G!1, H!1)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!3") (("2" (hide -1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("1" (assert) (("1" (lemma "finite_subgroups") (("1" (inst -1 "H!3" "normalizer(G!1, H!1)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (typepred "H!3" "H!1") (("3" (hide (-1 -3)) (("3" (lemma "normal_in_normalizer[T, *, one]") (("3" (inst?) (("3" (assert) (("3" (lemma "normal_subgroup_tran[T, *, one]") (("3" (inst -1 "normalizer(G!1, H!1)" "H!3" "H!1") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!1" "G!1") (("2" (hide -1) (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "H!3") (("3" (hide -1) (("3" (lemma "normalizer_is_subgroup[T, *, one]") (("3" (inst?) (("3" (assert) (("3" (typepred "G!1") (("3" (lemma "finite_subgroups") (("3" (inst?) (("1" (assert) (("1" (lemma "finite_subgroups") (("1" (inst -1 "H!3" "normalizer(G!1, H!1)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "order") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (expand "finite_group?") (("2" (prop) (("1" (lemma "divide_TCC5[T, *, one]") (("1" (inst?) (("1" (hide 2) (("1" (lemma "normal_in_normalizer[T, *, one]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil) ("2" (lemma "restrict_finite[setof[T],left_cosets[T, *, one](normalizer[T, *, one](G!1, H!1), H!1)]") (("2" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "left_cosets_partition[T,*,one]") (("1" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("1" (assert) nil nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "T_is_group") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "left_cosets_group[T, *, one]") (("2" (inst?) (("1" (hide 2) (("1" (lemma "normal_in_normalizer[T, *, one]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_is_group[T, *, one]") (("2" (inst?) (("1" (assert) nil nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (inst 1 "one") (("1" (rewrite "left_coset_one") nil nil) ("2" (expand "normalizer") (("2" (expand "extend") (("2" (prop) (("1" (rewrite "inv_one") (("1" (rewrite "left_coset_one") (("1" (rewrite "right_coset_one") nil nil)) nil)) nil) ("2" (rewrite "one_in") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (lemma "restrict_finite[setof[T],left_cosets[T, *, one](normalizer[T, *, one](G!1, H!1), H!1)]") (("2" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "left_cosets_partition[T,*,one]") (("1" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("1" (assert) nil nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "normal_in_normalizer[T, *, one]") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_is_group[T, *, one]") (("2" (inst?) (("1" (assert) nil nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "T_is_group") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil) ("2" (hide-all-but (-1 -3 1)) (("2" (lemma "p_group_iff_power[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -4 -6 1)) (("3" (lemma "Lagrange_index[T,*,one]") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "divides") (("1" (lemma "div_cancel4") (("1" (inst -1 "p!1 ^ j!1" "index(G!1, H!1)" "p!1 ^ n!1 * m!1") (("1" (prop) (("1" (hide (-2 -3)) (("1" (rewrite "times_div2" :dir rl) (("1" (rewrite "exponentiation.expt_div") (("1" (lemma "expt_plus") (("1" (inst -1 "1" "n!1 - j!1 - 1" "p!1") (("1" (assert) (("1" (rewrite "expt_x1") (("1" (replaces -1) (("1" (inst 1 "p!1 ^ (-1 - j!1 + n!1) * m!1") (("1" (assert) nil nil) ("2" (hide -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!1") (("2" (hide -1) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (skosimp) (("2" (lemma "normalizer_index[T,*,one]") (("2" (inst -1 "p!1" "G!1" "S!1") (("2" (prop) (("1" (lemma "card_factor[T,*,one]") (("1" (inst?) (("1" (prop) (("1" (rewrite "card_extend[set[T], left_cosets[T, *, one](normalizer(G!1, S!1), S!1)]") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (lemma "cauchy_cor[left_cosets(normalizer(G!1, S!1),S!1),mult(normalizer(G!1, S!1),S!1),S!1]") (("1" (inst -1 "normalizer(G!1, S!1) / S!1" "p!1") (("1" (prop) (("1" (skosimp) (("1" (lemma "subgroup_is_factor") (("1" (inst -1 "normalizer(G!1, S!1)" "S!1" "H!1") (("1" (skosimp) (("1" (hide -4) (("1" (replaces -2) (("1" (lemma "Lagrange_index[T,*,one]") (("1" (inst -1 "H!2" "S!1") (("1" (assert) (("1" (lemma "card_factor[T,*,one]") (("1" (inst -1 "H!2" "S!1") (("1" (prop) (("1" (rewrite "card_extend[set[T], left_cosets[T, *, one](H!2, S!1)]") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (replace -4 -1) (("1" (case-replace "card(H!2 / S!1) = p!1" :hide? T) (("1" (inst 1 "H!2") (("1" (hide-all-but (-1 1 2)) (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (assert) (("1" (hide (- 2)) (("1" (typepred "H!2") (("1" (hide -1) (("1" (lemma "normal_in_normalizer[T,*,one]") (("1" (inst?) (("1" (assert) (("1" (lemma "normal_subgroup_tran[T, *, one]") (("1" (inst -1 "normalizer(G!1, S!1)" "H!2" "S!1") (("1" (assert) nil nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!2") (("2" (hide -1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_transitive[T, *, one]") (("2" (inst -1 "G!1" "normalizer(G!1, S!1)" "H!2") (("1" (assert) nil nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "order") (("2" (rewrite "card_def[left_cosets(normalizer(G!1, S!1), S!1)]") (("2" (rewrite "card_def[left_cosets[T, *, one](H!2, S!1)]") (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (expand "Card") (("2" (expand "inj_set") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (lemma "restrict_finite[setof[T], left_cosets[T, *, one](H!2, S!1)]") (("2" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "left_cosets_partition[T,*,one]") (("1" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (typepred "H!2") (("2" (hide (-1 2)) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("1" (assert) (("1" (lemma "finite_subgroups") (("1" (inst -1 "H!2" "normalizer(G!1, S!1)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "H!2") (("2" (hide -1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("1" (assert) (("1" (lemma "finite_subgroups") (("1" (inst -1 "H!2" "normalizer(G!1, S!1)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (typepred "H!2" "S!1") (("3" (hide (-1 -3)) (("3" (lemma "normal_in_normalizer[T, *, one]") (("3" (inst?) (("3" (assert) (("3" (lemma "normal_subgroup_tran[T, *, one]") (("3" (inst -1 "normalizer(G!1, S!1)" "H!2" "S!1") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "S!1" "G!1") (("2" (hide -1) (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "H!2") (("3" (hide -1) (("3" (lemma "normalizer_is_subgroup[T, *, one]") (("3" (inst?) (("3" (assert) (("3" (typepred "G!1") (("3" (lemma "finite_subgroups") (("3" (inst?) (("1" (assert) (("1" (lemma "finite_subgroups") (("1" (inst -1 "H!2" "normalizer(G!1, S!1)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "order") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (expand "finite_group?") (("2" (prop) (("1" (lemma "divide_TCC5[T, *, one]") (("1" (inst?) (("1" (hide 2) (("1" (lemma "normal_in_normalizer[T, *, one]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil) ("2" (lemma "restrict_finite[setof[T],left_cosets[T, *, one](normalizer[T, *, one](G!1, S!1), S!1)]") (("2" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "left_cosets_partition[T,*,one]") (("1" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("1" (assert) nil nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "T_is_group") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "left_cosets_group[T, *, one]") (("2" (inst?) (("1" (hide 2) (("1" (lemma "normal_in_normalizer[T, *, one]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_is_group[T, *, one]") (("2" (inst?) (("1" (assert) nil nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (inst 1 "one") (("1" (rewrite "left_coset_one") nil nil) ("2" (expand "normalizer") (("2" (expand "extend") (("2" (prop) (("1" (rewrite "inv_one") (("1" (rewrite "left_coset_one") (("1" (rewrite "right_coset_one") nil nil)) nil)) nil) ("2" (rewrite "one_in") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "/") (("2" (lemma "restrict_finite[setof[T],left_cosets[T, *, one](normalizer[T, *, one](G!1, S!1), S!1)]") (("2" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "left_cosets_partition[T,*,one]") (("1" (inst?) (("1" (expand "finite_partition?") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("1" (assert) nil nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "normal_in_normalizer[T, *, one]") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "subgroup_is_group[T, *, one]") (("2" (inst?) (("1" (assert) nil nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "T_is_group") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil) ("2" (hide-all-but (-1 -3 1)) (("2" (lemma "p_group_iff_power[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -4 -6 1)) (("3" (lemma "Lagrange_index[T,*,one]") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "divides") (("1" (lemma "div_cancel4") (("1" (inst -1 "p!1 ^ j!1" "index(G!1, S!1)" "p!1 ^ n!1 * m!1") (("1" (prop) (("1" (hide (-2 -3)) (("1" (rewrite "times_div2" :dir rl) (("1" (rewrite "exponentiation.expt_div") (("1" (lemma "expt_plus") (("1" (inst -1 "1" "n!1 - j!1 - 1" "p!1") (("1" (assert) (("1" (rewrite "expt_x1") (("1" (replaces -1) (("1" (inst 1 "p!1 ^ (-1 - j!1 + n!1) * m!1") (("1" (assert) nil nil) ("2" (hide -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "S!1") (("2" (hide -1) (("2" (typepred "G!1") (("2" (lemma "finite_subgroups") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (hide-all-but 1) (("4" (typepred "K!1") (("4" (typepred "G!1") (("4" (lemma "finite_subgroups") (("4" (inst?) (("4" (assert) (("4" (expand* "group?" "monoid?" "finite_monad?" "finite_group?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (hide-all-but 1) (("5" (typepred "S!1") (("5" (typepred "G!1") (("5" (lemma "finite_subgroups") (("5" (inst?) (("5" (assert) (("5" (expand* "group?" "monoid?" "finite_monad?" "finite_group?") (("5" (flatten) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (typepred "H!1") (("6" (typepred "G!1") (("6" (lemma "finite_subgroups") (("6" (inst?) (("6" (assert) (("6" (expand* "group?" "monoid?" "finite_monad?" "finite_group?") (("6" (flatten) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gcd const-decl "{k: posnat | divides(k, i) AND divides(k, j)}" gcd ints) (prime? const-decl "bool" primes ints) (set type-eq-decl nil sets nil) (cauchy_cor formula-decl nil cauchy nil) (fullset const-decl "set" sets nil) (singleton const-decl "(singleton?)" sets nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (divides_power formula-decl nil general_properties nil) (normalizer_index formula-decl nil p_groups nil) (normalizer const-decl "{S: set[T] | subset?(S, G)}" normalizer_centralizer nil) (/ const-decl "group[left_cosets[T, *, one](G, N), mult(G, N), N]" right_left_cosets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (Lagrange_index formula-decl nil lagrange_index nil) (normal_subgroup_tran formula-decl nil groups_scaf nil) (normal_in_normalizer formula-decl nil normalizer_centralizer nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (subgroup_transitive formula-decl nil groups_scaf nil) (normalizer_is_subgroup formula-decl nil normalizer_centralizer nil) (inj_set const-decl "(nonempty?[nat])" finite_sets nil) (card_def formula-decl nil finite_sets nil) (left_cosets const-decl "setofsets[T]" right_left_cosets nil) (setofsets type-eq-decl nil sets nil) (left_cosets_partition formula-decl nil right_left_cosets nil) (card_factor formula-decl nil right_left_cosets nil) (p_group_iff_power formula-decl nil p_groups nil) (index const-decl "nat" right_left_cosets nil)) shostak)) (p_group_is_subgroup_TCC1 0 (p_group_is_subgroup_TCC1-1 nil 3531303927 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (divides const-decl "bool" divides nil) (prime? const-decl "bool" primes ints)) nil (p_group_is_subgroup subtype "sylow_theorems.m" "{jj: integers.int | booleans.=>(sylow_theorems.p = 0, jj /= 0)}"))) (p_group_is_subgroup_TCC2 0 (p_group_is_subgroup_TCC2-1 nil 3531303927 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (T formal-type-decl nil sylow_theorems nil) (set type-eq-decl nil sets nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil) (finite_group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (subgroup type-eq-decl nil group nil) (member const-decl "bool" sets nil) (star_closed? const-decl "bool" groupoid_def nil) (one_member formula-decl nil monad nil) (one_right formula-decl nil group nil) (restrict const-decl "R" restrict nil) (one_left formula-decl nil group nil) (identity? const-decl "bool" operator_defs nil) (monad? const-decl "bool" monad_def nil) (associative? const-decl "bool" operator_defs nil) (monoid? const-decl "bool" monoid_def nil) (inv_exists? const-decl "bool" group_def nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (subset? const-decl "bool" sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (divides const-decl "bool" divides nil) (prime? const-decl "bool" primes ints) (gcd const-decl "{k: posnat | divides(k, i) AND divides(k, j)}" gcd ints) (order const-decl "posnat" monad nil) (posnat_expt application-judgement "posnat" exponentiation nil)) nil (p_group_is_subgroup subtype "(number_fields.-)(sylow_theorems.n, sylow_theorems.i)" "nat"))) (p_group_is_subgroup_TCC3 0 (p_group_is_subgroup_TCC3-1 nil 3531304355 ("" (skosimp*) (("" (hide -) (("" (typepred "G!1" "K!1") (("" (lemma "finite_subgroups[T, *, one]") (("" (inst?) (("" (assert) (("" (hide (-2 -4)) (("" (expand* "group?" "finite_group?" "finite_monad?") (("" (expand "monoid?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_subgroups formula-decl nil group nil) (finite_monad? const-decl "bool" monad_def nil) (monoid? const-decl "bool" monoid_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sylow_theorems nil) (set type-eq-decl nil sets nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil) (finite_group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (subgroup type-eq-decl nil group nil)) nil (p_group_is_subgroup subtype "sylow_theorems.K" "finite_monad[T, *, one]"))) (p_group_is_subgroup 0 (p_group_is_subgroup-1 nil 3531303962 ("" (induct "i") (("1" (hide 2) (("1" (typepred "i!1") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (skosimp*) (("3" (case-replace "j!1 = 0" :hide? T) (("1" (hide (-1 -2 -5)) (("1" (assert) (("1" (lemma "First_Sylow_Theorem") (("1" (inst?) (("1" (inst -1 "n!1") (("1" (assert) (("1" (flatten) (("1" (hide -1) (("1" (inst -1 "H!1") (("1" (assert) (("1" (skosimp) (("1" (hide (-3 -4 -5 -6)) (("1" (expand "normal_subgroup?") (("1" (flatten) (("1" (hide -3) (("1" (inst 1 "K!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "First_Sylow_Theorem") (("2" (inst?) (("2" (inst -1 "n!1 - j!1") (("2" (assert) (("2" (flatten) (("2" (hide -1) (("2" (inst -1 "H!1") (("2" (assert) (("2" (skosimp) (("2" (inst -3 "m!1" "n!1" "p!1" "G!1" "K!1") (("2" (assert) (("2" (skosimp) (("2" (hide-all-but (-2 -3 -4 2)) (("2" (expand "normal_subgroup?") (("2" (flatten) (("2" (hide -2) (("2" (inst 1 "K!2") (("2" (lemma "subgroup_transitive[T,*,one]") (("1" (inst -1 "K!2" "K!1" "H!1") (("1" (assert) nil nil)) nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (lemma "p_group_is_subgroup_TCC3") (("4" (inst -1 "i!2" "m!1" "n!1" "p!1" "G!1" "H!1") (("4" (assert) (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skosimp*) (("6" (hide -) (("6" (typepred "G!1" "H!1") (("6" (lemma "finite_subgroups[T, *, one]") (("6" (inst?) (("6" (assert) (("6" (hide (-2 -4)) (("6" (expand* "group?" "finite_group?" "finite_monad?") (("6" (expand "monoid?") (("6" (flatten) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_subgroups formula-decl nil group nil) (monoid? const-decl "bool" monoid_def nil) (p_group_is_subgroup_TCC3 subtype-tcc nil sylow_theorems nil) (i!2 skolem-const-decl "nat" sylow_theorems nil) (nil application-judgement "above(n)" exp2 nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (subgroup_transitive formula-decl nil groups_scaf nil) (fullset const-decl "set" sets nil) (T_is_group formula-decl nil sylow_theorems nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (First_Sylow_Theorem formula-decl nil sylow_theorems nil) (normal_subgroup? const-decl "boolean" normal_subgroups nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (T formal-type-decl nil sylow_theorems nil) (set type-eq-decl nil sets nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil) (finite_group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (subgroup type-eq-decl nil group nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (prime? const-decl "bool" primes ints) (= const-decl "[T, T -> boolean]" equalities nil) (/= const-decl "boolean" notequal nil) (divides const-decl "bool" divides nil) (gcd const-decl "{k: posnat | divides(k, i) AND divides(k, j)}" gcd ints) (<= const-decl "bool" reals nil) (finite_monad? const-decl "bool" monad_def nil) (finite_monad nonempty-type-eq-decl nil monad nil) (order const-decl "posnat" monad nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt def-decl "real" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil)) shostak)) (p_subgroup_sylow_order_TCC1 0 (p_subgroup_sylow_order_TCC1-1 nil 3531210392 ("" (skosimp*) (("" (hide -) (("" (typepred "G!1" "P!1") (("" (lemma "finite_subgroups[T, *, one]") (("" (inst?) (("" (assert) (("" (hide (-2 -4)) (("" (expand* "group?" "finite_group?" "finite_monad?") (("" (expand "monoid?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_subgroups formula-decl nil group nil) (finite_monad? const-decl "bool" monad_def nil) (monoid? const-decl "bool" monoid_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sylow_theorems nil) (set type-eq-decl nil sets nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil) (finite_group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (subgroup type-eq-decl nil group nil)) nil (p_subgroup_sylow_order subtype "sylow_theorems.P" "finite_monad[T, *, one]"))) (p_subgroup_sylow_order 0 (p_subgroup_sylow_order-1 nil 3531210414 ("" (skosimp*) (("" (prop) (("1" (expand "p_subgroup_sylow?") (("1" (flatten) (("1" (lemma "p_group_iff_power[T, *, one]") (("1" (inst?) (("1" (assert) (("1" (skosimp) (("1" (case "m!2 > n!1") (("1" (hide (-3 -4)) (("1" (lemma "gcd_1_nd") (("1" (inst -1 "m!1" "p!1") (("1" (rewrite "gcd_sym") (("1" (assert) (("1" (hide (-3 -5 2)) (("1" (lemma "Lagrange") (("1" (inst -1 "G!1" "P!1") (("1" (assert) (("1" (replaces -3) (("1" (replaces -3) (("1" (expand "divides") (("1" (skosimp) (("1" (lemma "both_sides_div1") (("1" (inst -1 "expt(p!1, n!1)" "expt(p!1, n!1) * m!1" "expt(p!1, m!2) * x!1") (("1" (prop) (("1" (hide (-2 -3)) (("1" (rewrite "times_div1" :dir rl) (("1" (rewrite "div_cancel1") (("1" (rewrite "times_div2" :dir rl) (("1" (lemma "exponentiation.expt_minus_aux") (("1" (inst?) (("1" (assert) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (lemma "expt_plus_aux") (("1" (inst -1 "1" "m!2 - n!1 - 1" "p!1") (("1" (rewrite "expt_x1_aux") (("1" (assert) (("1" (replaces -1) (("1" (inst 1 " expt(p!1, -1 - n!1 + m!2) * x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (lemma "finite_subgroups") (("2" (inst -1 "P!1" "G!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "p_group_is_subgroup") (("2" (inst -1 "n!1 - m!2" "m!1" "n!1" "p!1" "G!1" "P!1") (("1" (assert) (("1" (skosimp) (("1" (lemma "p_group_iff_power[T, *, one]") (("1" (inst -1 "p!1" "K!1") (("1" (assert) (("1" (prop) (("1" (hide -2) (("1" (inst -6 "K!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (hide (- 2 3)) (("2" (lemma "finite_subgroups") (("2" (inst -1 "K!1" "G!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "m!2 = n!1" :hide? T) (("2" (hide (- 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "p_subgroup_sylow?") (("2" (prop) (("1" (lemma "p_group_iff_power[T, *, one]") (("1" (inst -1 "p!1" "P!1") (("1" (assert) (("1" (inst?) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (lemma "p_group_iff_power[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (skosimp) (("2" (case "m!2 > n!1") (("1" (hide (-3 -4 -5)) (("1" (lemma "gcd_1_nd") (("1" (inst -1 "m!1" "p!1") (("1" (rewrite "gcd_sym") (("1" (assert) (("1" (hide (-3 -5 2)) (("1" (lemma "Lagrange") (("1" (inst -1 "G!1" "H!1") (("1" (assert) (("1" (replaces -3) (("1" (replaces -3) (("1" (expand "divides") (("1" (skosimp) (("1" (lemma "both_sides_div1") (("1" (inst -1 "expt(p!1, n!1)" "expt(p!1, n!1) * m!1" "expt(p!1, m!2) * x!1") (("1" (prop) (("1" (hide (-2 -3)) (("1" (rewrite "times_div1" :dir rl) (("1" (rewrite "div_cancel1") (("1" (rewrite "times_div2" :dir rl) (("1" (lemma "exponentiation.expt_minus_aux") (("1" (inst?) (("1" (assert) (("1" (lemma "expt_plus_aux") (("1" (inst -1 "1" "m!2 - n!1 - 1" "p!1") (("1" (rewrite "expt_x1_aux") (("1" (assert) (("1" (replaces -1) (("1" (replace -1 -2 rl) (("1" (inst 1 " expt(p!1, -1 - n!1 + m!2) * x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (lemma "finite_subgroups") (("2" (inst -1 "H!1" "G!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "m!2 = n!1" :hide? T) (("1" (hide-all-but (-1 -3 -4 2)) (("1" (lemma "orders_equal[T, *, one]") (("1" (inst -1 "H!1" "P!1") (("1" (assert) nil nil) ("2" (hide (- 2)) (("2" (lemma "finite_subgroups") (("2" (inst -1 "P!1" "G!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide (- 2)) (("3" (lemma "finite_subgroups") (("3" (inst -1 "H!1" "G!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "p_group_is_subgroup") (("2" (inst -1 "n!1 - m!2" "m!1" "n!1" "p!1" "G!1" "H!1") (("1" (assert) (("1" (skosimp) (("1" (hide (-3 -4 -7 -8 -9 1 2)) (("1" (lemma "subgroup_transitive[T,*,one]") (("1" (inst -1 "K!1" "H!1" "P!1") (("1" (assert) (("1" (lemma "orders_equal[T,*,one]") (("1" (inst -1 "K!1" "P!1") (("1" (assert) (("1" (replaces -1) (("1" (hide (-1 -2 -5)) (("1" (expand "subgroup?") (("1" (lemma "subset_antisymmetric[T]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (lemma "finite_subgroups") (("2" (inst -1 "P!1" "G!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide (- 2)) (("3" (lemma "finite_subgroups") (("3" (inst -1 "K!1" "G!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (set type-eq-decl nil sets nil) (finite_group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (subgroup type-eq-decl nil group nil) (p_group_is_subgroup formula-decl nil sylow_theorems nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (K!1 skolem-const-decl "subgroup[T, *, one](G!1)" sylow_theorems nil) (m!2 skolem-const-decl "nat" sylow_theorems nil) (n!1 skolem-const-decl "posnat" sylow_theorems nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Lagrange formula-decl nil lagrange nil) (finite_subgroups formula-decl nil group nil) (int_times_int_is_int application-judgement "int" integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expt def-decl "real" exponentiation nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (div_cancel1 formula-decl nil real_props nil) (expt_minus_aux formula-decl nil exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nil application-judgement "above(n)" exp2 nil) (expt_x1_aux formula-decl nil exponentiation nil) (expt_plus_aux formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (times_div2 formula-decl nil real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (times_div1 formula-decl nil real_props nil) (both_sides_div1 formula-decl nil real_props nil) (divides const-decl "bool" divides nil) (TRUE const-decl "bool" booleans nil) (P!1 skolem-const-decl "subgroup[T, *, one](G!1)" sylow_theorems nil) (G!1 skolem-const-decl "finite_group[T, *, one]" sylow_theorems nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (gcd_sym formula-decl nil gcd ints) (gcd_1_nd formula-decl nil general_properties nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (p_group_iff_power formula-decl nil p_groups nil) (T formal-type-decl nil sylow_theorems nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil) (p_subgroup_sylow? const-decl "bool" sylow_theorems nil) (H!1 skolem-const-decl "subgroup[T, *, one](G!1)" sylow_theorems nil) (T_is_group formula-decl nil sylow_theorems nil) (subset_antisymmetric formula-decl nil sets_lemmas nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (K!1 skolem-const-decl "subgroup[T, *, one](G!1)" sylow_theorems nil) (fullset const-decl "set" sets nil) (subgroup_transitive formula-decl nil groups_scaf nil) (m!2 skolem-const-decl "nat" sylow_theorems nil) (orders_equal formula-decl nil finite_groups nil)) shostak)) (conjugate_is_p_subgroup_sylow_TCC1 0 (conjugate_is_p_subgroup_sylow_TCC1-1 nil 3531324060 ("" (skosimp*) (("" (lemma "conjugate_is_subgroup[T,*,one]") (("1" (inst?) (("1" (hide-all-but (-1 1)) (("1" (assert) (("1" (lemma "subgroup_is_group[T,*,one]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil) ((one formal-const-decl "T" sylow_theorems nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (T formal-type-decl nil sylow_theorems nil) (conjugate_is_subgroup formula-decl nil groups_scaf nil) (fullset const-decl "set" sets nil) (group? const-decl "bool" group_def nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (subgroup_is_group formula-decl nil group nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "set[T]" cosets nil) (* const-decl "set[T]" cosets nil) (subgroup type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (finite_group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (T_is_group formula-decl nil sylow_theorems nil)) nil (conjugate_is_p_subgroup_sylow subtype "cosets[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one].*(cosets[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one].*(sylow_theorems.a, sylow_theorems.P), group[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one].inv(sylow_theorems.a))" "subgroup[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one](sylow_theorems.G)"))) (conjugate_is_p_subgroup_sylow 0 (conjugate_is_p_subgroup_sylow-1 nil 3531345595 ("" (skosimp*) (("" (lemma "card_eq_bij[T,T]") (("" (inst -1 "P!1" "a!1 * P!1 * inv(a!1)") (("1" (prop) (("1" (hide -2) (("1" (lemma "p_subgroup_sylow_order") (("1" (inst-cp -1 "m!1" "n!1" "p!1" "G!1" "P!1") (("1" (inst -1 "m!1" "n!1" "p!1" "G!1" "a!1 * P!1 * inv(a!1)") (("1" (expand "order") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2 3)) (("2" (inst 1 "LAMBDA (x: (P!1)): a!1 * x * inv(a!1)") (("1" (expand "bijective?") (("1" (prop) (("1" (expand "injective?") (("1" (skosimp*) (("1" (rewrite "cancel_right") (("1" (rewrite "cancel_left") nil nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skosimp) (("2" (typepred "y!1") (("2" (expand "*") (("2" (skosimp) (("2" (typepred "h!1") (("2" (skosimp) (("2" (replaces -1) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "*") (("2" (inst?) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (lemma "conjugate_is_subgroup[T, *, one]") (("1" (inst?) (("1" (lemma "finite_subgroups[T, *, one]") (("1" (inst?) (("1" (assert) (("1" (expand "finite_group?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil) ("3" (hide (- 2)) (("3" (lemma "finite_subgroups[T, *, one]") (("3" (inst -1 "P!1" "G!1") (("3" (assert) (("3" (expand "finite_group?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil sylow_theorems nil) (card_eq_bij formula-decl nil finite_sets_card_eq finite_sets) (T_is_group formula-decl nil sylow_theorems nil) (finite_subgroups formula-decl nil group nil) (fullset const-decl "set" sets nil) (conjugate_is_subgroup formula-decl nil groups_scaf nil) (p_subgroup_sylow_order formula-decl nil sylow_theorems nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (order const-decl "posnat" monad nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cancel_left formula-decl nil group nil) (cancel_right formula-decl nil group nil) (injective? const-decl "bool" functions nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil) (x!1 skolem-const-decl "(P!1)" sylow_theorems nil) (finite_set type-eq-decl nil finite_sets nil) (* const-decl "set[T]" cosets nil) (* const-decl "set[T]" cosets nil) (a!1 skolem-const-decl "(G!1)" sylow_theorems nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (finite_group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (G!1 skolem-const-decl "finite_group[T, *, one]" sylow_theorems nil) (subgroup type-eq-decl nil group nil) (P!1 skolem-const-decl "subgroup[T, *, one](G!1)" sylow_theorems nil)) shostak)) (unique_is_normal 0 (unique_is_normal-1 nil 3531346917 ("" (skosimp*) (("" (decompose-equality -4) (("" (lemma "conjugate_is_p_subgroup_sylow") (("" (inst -1 "m!1" "n!1" "p!1" "G!1" "P!1") (("" (assert) (("" (inst-cp -2 "P!1") (("" (iff) (("" (expand* "extend" "singleton") (("" (expand "p_subgroup_sylow" -3) (("" (expand "extend") (("" (prop) (("" (expand "normal_subgroup?") (("" (skosimp) (("" (inst -1 "inv(a!1)") (("1" (rewrite "inv_inv") (("1" (inst -2 "inv(a!1) * P!1 * a!1") (("1" (lift-if) (("1" (prop) (("1" (expand "p_subgroup_sylow") (("1" (expand "extend") (("1" (lift-if) (("1" (prop) (("1" (iff) (("1" (prop) (("1" (hide-all-but (-2 1)) (("1" (replaces -1) (("1" (rewrite "subset_reflexive") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (lemma "conjugate_is_subgroup[T,*,one]") (("1" (inst -1 "G!1" "inv(a!1)" "P!1") (("1" (rewrite "inv_inv") (("1" (lemma "subgroup_is_group[T,*,one]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "inv_in") nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil) ("3" (hide (- 2)) (("3" (lemma "conjugate_is_subgroup[T,*,one]") (("1" (inst -1 "G!1" "inv(a!1)" "P!1") (("1" (rewrite "inv_inv") nil nil) ("2" (hide 2) (("2" (rewrite "inv_in") nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (rewrite "inv_in") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nonempty_extend application-judgement "(nonempty?[T])" extend_set_props nil) (finite_extend application-judgement "finite_set[T]" extend_set_props nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[T]" countable_props sets_aux) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (subgroup type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (group? const-decl "bool" group_def nil) (p_subgroup_sylow const-decl "setofsets[T]" sylow_theorems nil) (setofsets type-eq-decl nil sets nil) (prime? const-decl "bool" primes ints) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_group nonempty-type-eq-decl nil group nil) (finite_group? const-decl "bool" group_def nil) (one formal-const-decl "T" sylow_theorems nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (setof type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil sylow_theorems nil) (normal_subgroup? const-decl "boolean" normal_subgroups nil) (G!1 skolem-const-decl "finite_group[T, *, one]" sylow_theorems nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (a!1 skolem-const-decl "(G!1)" sylow_theorems nil) (* const-decl "set[T]" cosets nil) (* const-decl "set[T]" cosets nil) (TRUE const-decl "bool" booleans nil) (subset_reflexive formula-decl nil sets_lemmas nil) (conjugate_is_subgroup formula-decl nil groups_scaf nil) (fullset const-decl "set" sets nil) (inv_in formula-decl nil group nil) (subgroup_is_group formula-decl nil group nil) (T_is_group formula-decl nil sylow_theorems nil) (inv_inv formula-decl nil group nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (conjugate_is_p_subgroup_sylow formula-decl nil sylow_theorems nil)) shostak)) (Second_Sylow_Theorem_TCC1 0 (Second_Sylow_Theorem_TCC1-1 nil 3531143488 ("" (skosimp*) (("" (hide -) (("" (typepred "K!1" "G!1") (("" (hide -1) (("" (lemma "finite_subgroups") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_subgroups formula-decl nil group nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sylow_theorems nil) (set type-eq-decl nil sets nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (finite_group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (subgroup type-eq-decl nil group nil)) nil (Second_Sylow_Theorem subtype "sylow_theorems.K" "finite_group[T, *, one]"))) (Second_Sylow_Theorem_TCC2 0 (Second_Sylow_Theorem_TCC2-1 nil 3531143488 ("" (skosimp*) (("" (hide -) (("" (lemma "conjugate_is_subgroup[T,*,one]") (("1" (inst?) (("1" (lemma "subgroup_is_group[T, *, one]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil) ((T_is_group formula-decl nil sylow_theorems nil) (group nonempty-type-eq-decl nil group nil) (finite_group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (subgroup type-eq-decl nil group nil) (* const-decl "set[T]" cosets nil) (* const-decl "set[T]" cosets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (subgroup_is_group formula-decl nil group nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (group? const-decl "bool" group_def nil) (fullset const-decl "set" sets nil) (conjugate_is_subgroup formula-decl nil groups_scaf nil) (T formal-type-decl nil sylow_theorems nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil)) nil (Second_Sylow_Theorem subtype "cosets[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one].*(cosets[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one].*(sylow_theorems.a, sylow_theorems.P), group[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one].inv(sylow_theorems.a))" "(group_def[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one].group?)"))) (Second_Sylow_Theorem 0 (Second_Sylow_Theorem-2 "" 3790334618 ("" (skosimp*) (("" (lemma "p_group_iff_power[T,*,one]") (("" (inst?) (("" (assert) (("" (skosimp) (("" (lemma "Fix_congruence[T,*,one,set[T]]") (("" (inst -1 "K!1" "left_cosets(G!1,P!1)" "m!2" "p!1" "alt(G!1,K!1,P!1)") (("1" (prop) (("1" (case "card(Fix(K!1, left_cosets(G!1, P!1))(alt(G!1, K!1, P!1))) /= 0") (("1" (hide -2) (("1" (prop) (("1" (lemma "nonempty_card[set[T]]") (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (expand* "nonempty?" "empty?" "member") (("1" (skosimp) (("1" (copy -1) (("1" (expand "Fix" -1) (("1" (expand "extend") (("1" (prop) (("1" (hide -2) (("1" (expand "left_cosets" -1) (("1" (skosimp) (("1" (replaces -1) (("1" (lemma "Fix_iff_subset[T, *, one]") (("1" (inst -1 "G!1" "K!1" "P!1" "a!1") (("1" (assert) (("1" (inst?) (("1" (prop) (("1" (expand "subgroup?") (("1" (propax) nil nil)) nil) ("2" (hide -3) (("2" (lemma "finite_subgroups") (("2" (inst-cp -1 "P!1" "G!1") (("2" (inst -1 "K!1" "G!1") (("2" (assert) (("2" (expand "finite_group?") (("2" (case "card(K!1) = card(P!1)") (("1" (lemma "left_coset_correspondence_inv[T, *, one]") (("1" (inst -1 "G!1" "P!1" "a!1") (("1" (assert) (("1" (lemma "bijection_finite_set2[T,T]") (("1" (inst?) (("1" (prop) (("1" (lemma "card_eq_bij[T,T]") (("1" (inst -1 "P!1" "a!1 * P!1 * inv(a!1)") (("1" (prop) (("1" (hide-all-but (-1 -5 -9 1)) (("1" (replace -2 -1 rl) (("1" (hide -2) (("1" (expand "is_conjugate") (("1" (inst?) (("1" (rewrite "same_card_subset") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -4 -5 -10 2)) (("2" (lemma "p_subgroup_sylow_order") (("2" (inst-cp -1 "m!1" "n!1" "p!1" "G!1" "P!1") (("2" (inst -1 "m!1" "n!1" "p!1" "G!1" "K!1") (("2" (assert) (("2" (hide-all-but (-1 -2 1)) (("2" (expand "order") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "p_subgroup_sylow_order") (("2" (inst -1 "m!1" "n!1" "p!1" "G!1" "P!1") (("2" (assert) (("2" (hide (-7 -8)) (("2" (lemma "Lagrange_index[T, *, one]") (("2" (inst -1 "G!1" "P!1") (("1" (assert) (("1" (replaces -2) (("1" (replaces -5) (("1" (rewrite "commutative_mult") (("1" (rewrite "both_sides_times1") (("1" (expand "index") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (prop) (("1" (replaces -1) (("1" (hide -2) (("1" (assert) (("1" (lemma "gcd_1_nd") (("1" (inst?) (("1" (rewrite "gcd_sym") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (lemma "finite_subgroups") (("2" (inst -1 "P!1" "G!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "K!1") (("2" (hide -1) (("2" (lemma "finite_subgroups") (("2" (inst -1 "K!1" "G!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (- 2)) (("3" (lemma "left_cosets_partition[T,*,one]") (("3" (inst?) (("3" (expand "finite_partition?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide (- 2)) (("4" (expand* "nonempty?" "empty?" "member" "left_cosets") (("4" (inst?) (("4" (inst 1 "one") (("1" (rewrite "left_coset_one") nil nil) ("2" (rewrite "one_in") nil nil)) nil)) nil)) nil)) nil) ("5" (hide (- 2)) (("5" (lemma "alt_is_action[T,*,one]") (("5" (inst?) nil nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (skosimp) (("2" (expand* "left_cosets" "alt") (("2" (typepred "x1!1`2") (("2" (expand "left_cosets") (("2" (skosimp) (("2" (replaces -1) (("2" (inst 1 "x1!1`1 * a!1") (("1" (rewrite "left_coset_assoc") nil nil) ("2" (rewrite "product_in") (("2" (hide 2) (("2" (typepred "x1!1`1" "K!1") (("2" (hide -2) (("2" (expand* "subgroup?" "subset?" "member") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((one formal-const-decl "T" sylow_theorems nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (T formal-type-decl nil sylow_theorems nil) (p_group_iff_power formula-decl nil p_groups nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (Fix_congruence formula-decl nil group_action nil) (product_in formula-decl nil group nil) (left_coset_assoc formula-decl nil cosets nil) (a!1 skolem-const-decl "(G!1)" sylow_theorems nil) (x1!1 skolem-const-decl "[(K!1), (left_cosets[T, *, one](G!1, P!1))]" sylow_theorems nil) (expt def-decl "real" exponentiation nil) (numfield nonempty-type-eq-decl nil number_fields nil) (commutative_mult formula-decl nil number_fields nil) (gcd_sym formula-decl nil gcd ints) (gcd_1_nd formula-decl nil general_properties nil) (both_sides_times1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (index const-decl "nat" right_left_cosets nil) (Lagrange_index formula-decl nil lagrange_index nil) (int_minus_int_is_int application-judgement "int" integers nil) (nonempty_card formula-decl nil finite_sets nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (extend const-decl "R" extend nil) (Fix_iff_subset formula-decl nil p_groups nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (finite_subgroups formula-decl nil group nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (order const-decl "posnat" monad nil) (p_subgroup_sylow_order formula-decl nil sylow_theorems nil) (left_coset_correspondence_inv formula-decl nil right_left_cosets nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "set[T]" cosets nil) (* const-decl "set[T]" cosets nil) (card_eq_bij formula-decl nil finite_sets_card_eq finite_sets) (is_conjugate const-decl "bool" sylow_theorems nil) (same_card_subset formula-decl nil finite_sets nil) (a!1 skolem-const-decl "(G!1)" sylow_theorems nil) (bijection_finite_set2 formula-decl nil finite_sets_eq finite_sets) (TRUE const-decl "bool" booleans nil) (Fix const-decl "{Y: set[T1] | subset?(Y, X)}" group_action nil) (subset? const-decl "bool" sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (/= const-decl "boolean" notequal nil) (NOT const-decl "[bool -> bool]" booleans nil) (left_cosets_partition formula-decl nil right_left_cosets nil) (finite_partition? const-decl "bool" lagrange_scaf nil) (left_coset_one formula-decl nil cosets nil) (one_in formula-decl nil monad nil) (monad? const-decl "bool" monad_def nil) (monad nonempty-type-eq-decl nil monad nil) (alt_is_action formula-decl nil p_groups nil) (F type-eq-decl nil group_action nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (alt const-decl "set[T]" p_groups nil) (P!1 skolem-const-decl "subgroup[T, *, one](G!1)" sylow_theorems nil) (left_cosets const-decl "setofsets[T]" right_left_cosets nil) (setofsets type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (K!1 skolem-const-decl "subgroup[T, *, one](G!1)" sylow_theorems nil) (G!1 skolem-const-decl "finite_group[T, *, one]" sylow_theorems nil) (subgroup type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (finite_group? const-decl "bool" group_def nil) (set type-eq-decl nil sets nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak) (Second_Sylow_Theorem-1 nil 3531204559 ("" (skosimp*) (("" (lemma "p_group_iff_power[T,*,one]") (("" (inst?) (("" (assert) (("" (skosimp) (("" (lemma "Fix_congruence[T,*,one,set[T]]") (("1" (inst -1 "K!1" "left_cosets(G!1,P!1)" "m!2" "p!1" "alt(G!1,K!1,P!1)") (("1" (prop) (("1" (case "card(Fix(K!1, left_cosets(G!1, P!1))(alt(G!1, K!1, P!1))) /= 0") (("1" (hide -2) (("1" (prop) (("1" (lemma "nonempty_card[set[T]]") (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (expand* "nonempty?" "empty?" "member") (("1" (skosimp) (("1" (copy -1) (("1" (expand "Fix" -1) (("1" (expand "extend") (("1" (prop) (("1" (hide -2) (("1" (expand "left_cosets" -1) (("1" (skosimp) (("1" (replaces -1) (("1" (lemma "Fix_iff_subset[T, *, one]") (("1" (inst -1 "G!1" "K!1" "P!1" "a!1") (("1" (assert) (("1" (inst?) (("1" (prop) (("1" (expand "subgroup?") (("1" (propax) nil nil)) nil) ("2" (hide -3) (("2" (lemma "finite_subgroups") (("2" (inst-cp -1 "P!1" "G!1") (("2" (inst -1 "K!1" "G!1") (("2" (assert) (("2" (expand "finite_group?") (("2" (case "card(K!1) = card(P!1)") (("1" (lemma "left_coset_correspondence_inv[T, *, one]") (("1" (inst -1 "G!1" "P!1" "a!1") (("1" (assert) (("1" (lemma "bijection_finite_set2[T,T]") (("1" (inst?) (("1" (prop) (("1" (lemma "card_eq_bij[T,T]") (("1" (inst -1 "P!1" "a!1 * P!1 * inv(a!1)") (("1" (prop) (("1" (hide-all-but (-1 -5 -9 1)) (("1" (replace -2 -1 rl) (("1" (hide -2) (("1" (expand "is_conjugate") (("1" (inst?) (("1" (rewrite "same_card_subset") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -4 -5 -10 2)) (("2" (lemma "p_subgroup_sylow_order") (("2" (inst-cp -1 "m!1" "n!1" "p!1" "G!1" "P!1") (("2" (inst -1 "m!1" "n!1" "p!1" "G!1" "K!1") (("2" (assert) (("2" (hide-all-but (-1 -2 1)) (("2" (expand "order") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "p_subgroup_sylow_order") (("2" (inst -1 "m!1" "n!1" "p!1" "G!1" "P!1") (("2" (assert) (("2" (hide (-7 -8)) (("2" (lemma "Lagrange_index[T, *, one]") (("2" (inst -1 "G!1" "P!1") (("1" (assert) (("1" (replaces -2) (("1" (replaces -5) (("1" (rewrite "commutative_mult") (("1" (rewrite "both_sides_times1") (("1" (expand "index") (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (prop) (("1" (replaces -1) (("1" (hide -2) (("1" (assert) (("1" (lemma "gcd_1_nd") (("1" (inst?) (("1" (rewrite "gcd_sym") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (lemma "finite_subgroups") (("2" (inst -1 "P!1" "G!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "K!1") (("2" (hide -1) (("2" (lemma "finite_subgroups") (("2" (inst -1 "K!1" "G!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (- 2)) (("3" (lemma "left_cosets_partition[T,*,one]") (("3" (inst?) (("3" (expand "finite_partition?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide (- 2)) (("4" (expand* "nonempty?" "empty?" "member" "left_cosets") (("4" (inst?) (("4" (inst 1 "one") (("1" (rewrite "left_coset_one") nil nil) ("2" (rewrite "one_in") nil nil)) nil)) nil)) nil)) nil) ("5" (hide (- 2)) (("5" (lemma "alt_is_action[T,*,one]") (("5" (inst?) nil nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (skosimp) (("2" (expand* "left_cosets" "alt") (("2" (typepred "x1!1`2") (("2" (expand "left_cosets") (("2" (skosimp) (("2" (replaces -1) (("2" (inst 1 "x1!1`1 * a!1") (("1" (rewrite "left_coset_assoc") nil nil) ("2" (rewrite "product_in") (("2" (hide 2) (("2" (typepred "x1!1`1" "K!1") (("2" (hide -2) (("2" (expand* "subgroup?" "subset?" "member") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "T_is_group") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((p_group_iff_power formula-decl nil p_groups nil) (Fix_congruence formula-decl nil group_action nil) (gcd_sym formula-decl nil gcd ints) (gcd_1_nd formula-decl nil general_properties nil) (index const-decl "nat" right_left_cosets nil) (Lagrange_index formula-decl nil lagrange_index nil) (nonempty_card formula-decl nil finite_sets nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (Fix_iff_subset formula-decl nil p_groups nil) (left_coset_correspondence_inv formula-decl nil right_left_cosets nil) (card_eq_bij formula-decl nil finite_sets_card_eq finite_sets) (same_card_subset formula-decl nil finite_sets nil) (bijection_finite_set2 formula-decl nil finite_sets_eq finite_sets) (Fix const-decl "{Y: set[T1] | subset?(Y, X)}" group_action nil) (subset? const-decl "bool" sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (left_cosets_partition formula-decl nil right_left_cosets nil) (alt_is_action formula-decl nil p_groups nil) (F type-eq-decl nil group_action nil) (alt const-decl "set[T]" p_groups nil) (left_cosets const-decl "setofsets[T]" right_left_cosets nil) (setofsets type-eq-decl nil sets nil) (set type-eq-decl nil sets nil)) shostak)) (Third_Sylow_Theorem_TCC1 0 (Third_Sylow_Theorem_TCC1-1 nil 3531324060 ("" (skosimp*) (("" (hide -) (("" (typepred "G!1") (("" (expand "finite_group?") (("" (flatten) (("" (hide -1) (("" (lemma "powerset_finite[T]") (("" (inst?) (("" (lemma "finite_subset[set[T]]") (("" (inst -1 "powerset[T](G!1)" "p_subgroup_sylow(G!1, p!1)") (("" (assert) (("" (hide (- 2)) (("" (expand* "subset?" "member") (("" (skosimp) (("" (expand "p_subgroup_sylow") (("" (expand "extend") (("" (prop) (("" (hide (-1 -3)) (("" (expand "subgroup?") (("" (flatten) (("" (hide -2) (("" (expand "powerset") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (powerset_finite application-judgement "finite_set[set[T]]" finite_sets_of_sets nil) (nonempty_powerset application-judgement "(nonempty?[set[T]])" sets_lemmas nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (powerset const-decl "setofsets" sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (prime? const-decl "bool" primes ints) (p_subgroup_sylow const-decl "setofsets[T]" sylow_theorems nil) (extend const-decl "R" extend nil) (subgroup? const-decl "bool" group_def nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (finite_subset formula-decl nil finite_sets nil) (powerset_finite judgement-tcc nil finite_sets_of_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sylow_theorems nil) (set type-eq-decl nil sets nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil) (finite_group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil)) nil (Third_Sylow_Theorem subtype "sylow_theorems.p_subgroup_sylow(sylow_theorems.G, sylow_theorems.p)" "finite_set[setof[T]]"))) (Third_Sylow_Theorem_TCC2 0 (Third_Sylow_Theorem_TCC2-2 "" 3790334619 ("" (skosimp*) (("" (hide -) (("" (lemma "normalizer_is_subgroup[T, *, one]") (("" (inst?) (("" (assert) (("" (lemma "subgroup_is_group[T, *, one]") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (finite_group? const-decl "bool" group_def nil) (finite_group nonempty-type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (subgroup type-eq-decl nil group nil) (subgroup_is_group formula-decl nil group nil) (normalizer const-decl "{S: set[T] | subset?(S, G)}" normalizer_centralizer nil) (subset? const-decl "bool" sets nil) (normalizer_is_subgroup formula-decl nil normalizer_centralizer nil) (T formal-type-decl nil sylow_theorems nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (one formal-const-decl "T" sylow_theorems nil)) shostak (Third_Sylow_Theorem subtype "normalizer_centralizer[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one].normalizer(sylow_theorems.G, sylow_theorems.P)" "subgroup[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one](sylow_theorems.G)")) (Third_Sylow_Theorem_TCC2-1 nil 3531324060 ("" (skosimp*) (("" (hide -) (("" (lemma "normalizer_is_subgroup[T, *, one]") (("1" (inst?) (("1" (assert) (("1" (lemma "subgroup_is_group[T, *, one]") (("1" (inst?) (("1" (assert) nil nil) ("2" (hide (-1 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil) ((set type-eq-decl nil sets nil) (normalizer const-decl "{S: set[T] | subset?(S, G)}" normalizer_centralizer nil) (subset? const-decl "bool" sets nil) (normalizer_is_subgroup formula-decl nil normalizer_centralizer nil)) nil (Third_Sylow_Theorem subtype "normalizer_centralizer[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one].normalizer(sylow_theorems.G, sylow_theorems.P)" "subgroup[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one](sylow_theorems.G)"))) (Third_Sylow_Theorem 0 (Third_Sylow_Theorem-1 nil 3531324107 ("" (skosimp*) (("" (skoletin* 1 "!1") (("" (case "stabilizer[T,*,one, set[T]](G!1, p_subgroup_sylow(G!1, p!1))(action_by_c(G!1,p_subgroup_sylow(G!1,p!1)), P!1) = normalizer(G!1, P!1)") (("1" (case "orbit[T, *, one, set[T]](G!1,p_subgroup_sylow(G!1, p!1))(action_by_c(G!1, p_subgroup_sylow(G!1, p!1)), P!1) = p_subgroup_sylow(G!1, p!1)") (("1" (lemma "orbits_eq_index[T, *, one, set[T]]") (("1" (inst?) (("1" (split -1) (("1" (prop) (("1" (assert) nil nil) ("2" (replaces -2) (("2" (replaces -2) (("2" (replace -2 -1 rl) (("2" (hide -2) (("2" (lemma "p_subgroup_sylow_order") (("2" (inst -1 "m!1" "n!1" "p!1" "G!1" "P!1") (("2" (assert) (("2" (lemma "Lagrange_index[T,*,one]") (("2" (inst-cp -1 "G!1" "normalizer(G!1, P!1)") (("1" (inst -1 "normalizer(G!1, P!1)" "P!1") (("1" (prop) (("1" (hide (-5 -7 -8)) (("1" (replaces -2) (("1" (replaces -2) (("1" (replaces -3) (("1" (rewrite "commutative_mult") (("1" (rewrite "associative_mult") (("1" (rewrite "both_sides_times1") (("1" (replaces -2) (("1" (rewrite "commutative_mult") (("1" (expand "divides") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide (- 2)) (("3" (expand "subgroup?" 1) (("3" (lemma "subset_of_normalizer[T, *, one]") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide (- 2 3)) (("4" (lemma "normalizer_is_subgroup[T, *, one]") (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (typepred "P!1") (("2" (hide -1) (("2" (lemma "finite_subgroups[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (- 2)) (("3" (lemma "normalizer_is_subgroup[T, *, one]") (("3" (inst?) (("3" (assert) (("3" (lemma "finite_subgroups[T, *, one]") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (lemma "finite_subgroups[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 -2 -3)) (("3" (lemma "Fix_congruence[T,*,one, set[T]]") (("3" (inst -1 "P!1" "p_subgroup_sylow(G!1, p!1)" "n!1" "p!1" "action_by_c(P!1,p_subgroup_sylow(G!1,p!1))") (("1" (prop) (("1" (replace -2 -1 rl) (("1" (case-replace "Fix(P!1, p_subgroup_sylow(G!1, p!1))(action_by_c(P!1, p_subgroup_sylow(G!1, p!1))) = singleton(P!1)" :hide? T) (("1" (rewrite "card_extend[setof[T], subgroup[T, *, one](G!1)]") (("1" (rewrite "card_singleton") nil nil)) nil) ("2" (hide (-1 -2 2)) (("2" (decompose-equality 1) (("2" (iff) (("2" (prop) (("1" (expand "Fix") (("1" (expand "extend") (("1" (expand "p_subgroup_sylow" -1 1) (("1" (expand "extend") (("1" (prop) (("1" (hide (-1 -2)) (("1" (expand* "action_by_c" "singleton") (("1" (lemma "p_subgroup_sylow_order") (("1" (inst -1 "m!1" "n!1" "p!1" "G!1" "P!1") (("1" (assert) (("1" (lemma "p_group_iff_power[T,*,one]") (("1" (inst -1 "p!1" "P!1") (("1" (assert) (("1" (prop) (("1" (hide -2) (("1" (case "subgroup?(P!1, normalizer[T,*,one](G!1, x!1))") (("1" (lemma "Lagrange") (("1" (inst-cp -1 "normalizer[T, *, one](G!1, x!1)" "P!1") (("1" (inst -1 "G!1" "normalizer[T, *, one](G!1, x!1)") (("1" (assert) (("1" (prop) (("1" (expand "divides") (("1" (skosimp*) (("1" (replace -2 -1) (("1" (replaces -5) (("1" (replaces -10) (("1" (lemma "both_sides_times2") (("1" (inst -1 "expt(p!1, n!1)" "m!1" "x!3 * x!2") (("1" (assert) (("1" (hide -2) (("1" (lemma "gcd_1_gcd_1") (("1" (inst -1 "m!1" "p!1" "x!3" "x!2") (("1" (rewrite "gcd_sym") (("1" (assert) (("1" (flatten) (("1" (hide (-2 -3)) (("1" (rewrite "gcd_sym") (("1" (lemma "Second_Sylow_Theorem") (("1" (inst -1 "x!3" "n!1" "p!1" "normalizer[T, *, one](G!1, x!1)" "x!1" "P!1") (("1" (assert) (("1" (prop) (("1" (skosimp) (("1" (hide -1) (("1" (prop) (("1" (expand "is_conjugate") (("1" (skosimp) (("1" (lemma "normal_in_normalizer[T, *, one]") (("1" (inst?) (("1" (prop) (("1" (expand "normal_subgroup?") (("1" (flatten) (("1" (lemma "normal_prep[T, *, one]") (("1" (inst -1 "normalizer[T, *, one](G!1, x!1)" "x!1") (("1" (prop) (("1" (hide -3) (("1" (inst -1 "a!2") (("1" (hide-all-but (-1 -3 1)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 -11 1)) (("2" (expand "p_subgroup_sylow?") (("2" (skosimp) (("2" (inst?) (("1" (assert) nil nil) ("2" (typepred "H!1") (("2" (hide (-1 -3 -4 2)) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (hide -3) (("2" (lemma "subgroup_transitive[T, *, one]") (("1" (inst -1 "G!1" "normalizer[T, *, one](G!1, x!1)" "H!1") (("1" (assert) nil nil)) nil) ("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 -7 1)) (("2" (expand "p_subgroup_sylow?") (("2" (flatten) (("2" (assert) (("2" (skosimp) (("2" (inst?) (("1" (assert) nil nil) ("2" (typepred "H!1") (("2" (hide (-1 -3 -4 -6 2)) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (hide -3) (("2" (lemma "subgroup_transitive[T, *, one]") (("1" (inst -1 "G!1" "normalizer[T, *, one](G!1, x!1)" "H!1") (("1" (assert) nil nil)) nil) ("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (expand "subgroup?" 1) (("2" (lemma "subset_of_normalizer[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-6 1)) (("3" (lemma "finite_subgroups[T, *, one]") (("3" (inst -1 "normalizer[T, *, one](G!1, x!1)" "G!1") (("3" (assert) (("3" (hide 2) (("3" (lemma "normalizer_is_subgroup[T, *, one]") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-2 -9 1)) (("4" (typepred "order(normalizer[T, *, one](G!1, x!1))") (("4" (replaces -2) (("4" (lemma "prime_gt_1") (("4" (inst?) (("4" (assert) (("4" (hide -3) (("4" (lemma "expt_pos_aux") (("4" (inst?) (("4" (expand* ">=" ">") (("4" (lemma "pos_times_lt") (("4" (inst -1 "expt(p!1, n!1)" "x!3") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (hide -2) (("2" (lemma "finite_subgroups[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (lemma "normalizer_is_subgroup[T, *, one]") (("2" (inst?) (("2" (assert) (("2" (hide -2) (("2" (lemma "finite_subgroups[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (expand* "subgroup?" "subset?" "member") (("2" (skosimp) (("2" (expand "normalizer") (("2" (expand "extend") (("2" (prop) (("1" (inst -3 "inv(x!2)") (("1" (rewrite "inv_inv") nil nil) ("2" (hide (-1 2)) (("2" (rewrite "inv_in") nil nil)) nil)) nil) ("2" (typepred "P!1") (("2" (hide (-1 -4)) (("2" (expand* "subgroup?" "subset?" "member") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (lemma "normalizer_is_subgroup[T, *, one]") (("3" (inst?) (("3" (assert) (("3" (hide -2) (("3" (lemma "subgroup_is_group[T, *, one]") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (inst?) nil nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (typepred "P!1") (("2" (hide -1) (("2" (lemma "finite_subgroups[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "extend") (("2" (prop) (("2" (expand* "singleton" "Fix") (("2" (expand "extend") (("2" (prop) (("1" (skosimp) (("1" (expand "action_by_c") (("1" (replaces -4) (("1" (hide -) (("1" (typepred "g!1") (("1" (lemma "lc_is_eq[T, *, one]") (("1" (inst -1 "G!1" "P!1" "g!1" "one") (("1" (assert) (("1" (prop) (("1" (rewrite "left_coset_one") (("1" (replaces -1) (("1" (lemma "rc_is_eq[T, *, one]") (("1" (inst -1 "G!1" "P!1" "inv[T, *, one](g!1)" "one") (("1" (assert) (("1" (prop) (("1" (rewrite "right_coset_one") nil nil) ("2" (hide 2) (("2" (inst 1 "inv[T, *, one](g!1)") (("2" (rewrite "inv_in") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -7 1)) (("2" (expand "p_subgroup_sylow") (("2" (expand "extend") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (typepred "P!1") (("2" (hide -1) (("2" (lemma "finite_subgroups[T, *, one]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 2)) (("3" (lemma "p_subgroup_sylow_order") (("3" (inst -1 "m!1" "n!1" "p!1" "G!1" "P!1") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (lemma "Third_Sylow_Theorem_TCC1") (("4" (inst -1 "m!1" "n!1" "p!1" "G!1" "P!1") (("4" (assert) nil nil)) nil)) nil) ("5" (hide-all-but (-5 1)) (("5" (expand* "nonempty?" "empty?" "member") (("5" (inst -1 "P!1") (("5" (expand "p_subgroup_sylow") (("5" (expand "extend") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide (- 2)) (("6" (expand "group_action?") (("6" (skosimp*) (("6" (prop) (("1" (expand "action_by_c") (("1" (rewrite "left_coset_one") (("1" (rewrite "inv_one") (("1" (rewrite "right_coset_one") nil nil)) nil)) nil)) nil) ("2" (expand "action_by_c") (("2" (rewrite "inv_star") (("2" (rewrite "right_coset_assoc" :dir rl) (("2" (rewrite "left_coset_assoc" :dir rl) (("2" (rewrite "lr_coset_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (skosimp) (("2" (expand "action_by_c") (("2" (expand "p_subgroup_sylow") (("2" (expand "extend") (("2" (lemma "conjugate_is_subgroup[T, *, one]") (("1" (inst -1 "G!1" "x1!1`1" "x1!1`2") (("1" (lemma "subgroup_is_group[T, *, one]") (("1" (inst?) (("1" (assert) (("1" (typepred "x1!1`2") (("1" (hide (-2 -7)) (("1" (expand "p_subgroup_sylow") (("1" (expand "extend") (("1" (prop) (("1" (hide (-1 -2 -4)) (("1" (lemma "conjugate_is_p_subgroup_sylow") (("1" (inst -1 "m!1" "n!1" "p!1" "G!1" "x1!1`2") (("1" (assert) (("1" (inst -1 "x1!1`1") (("1" (hide (- 2)) (("1" (typepred "x1!1`1" "P!1") (("1" (hide -2) (("1" (expand* "subgroup?" "subset?" "member") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "x1!1`2") (("2" (expand "p_subgroup_sylow") (("2" (expand "extend") (("2" (prop) nil nil)) nil)) nil)) nil)) nil) ("3" (hide (- 2)) (("3" (typepred "x1!1`1" "P!1") (("3" (hide -2) (("3" (expand* "subgroup?" "subset?" "member") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (- 2)) (("3" (typepred "P!1") (("3" (hide -1) (("3" (lemma "finite_subgroups[T, *, one]") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 2)) (("2" (lemma "Third_Sylow_Theorem_TCC1") (("2" (inst -1 "m!1" "n!1" "p!1" "G!1" "P!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide (-1 -2 -3 2)) (("3" (expand "group_action?") (("3" (skosimp*) (("3" (prop) (("1" (expand "action_by_c") (("1" (rewrite "left_coset_one") (("1" (rewrite "inv_one") (("1" (rewrite "right_coset_one") nil nil)) nil)) nil)) nil) ("2" (expand "action_by_c") (("2" (rewrite "inv_star") (("2" (rewrite "right_coset_assoc" :dir rl) (("2" (rewrite "left_coset_assoc" :dir rl) (("2" (rewrite "lr_coset_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 2)) (("2" (decompose-equality 1) (("2" (iff) (("2" (prop) (("1" (expand "orbit") (("1" (expand "extend") (("1" (assert) nil nil)) nil)) nil) ("2" (expand* "orbit" "extend") (("2" (assert) (("2" (expand "action_by_c") (("2" (expand "p_subgroup_sylow") (("2" (expand "extend") (("2" (prop) (("2" (hide (-1 -2)) (("2" (lemma "Second_Sylow_Theorem") (("2" (inst -1 "m!1" "n!1" "p!1" "G!1" "P!1" "x!1") (("2" (assert) (("2" (hide (-3 -4 -5 -6)) (("2" (expand "p_subgroup_sylow?") (("2" (flatten) (("2" (hide -3) (("2" (assert) (("2" (skosimp) (("2" (hide (-1 -3)) (("2" (expand "is_conjugate") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (decompose-equality 1) (("2" (iff) (("2" (prop) (("1" (expand* "stabilizer" "normalizer") (("1" (expand "extend") (("1" (prop) (("1" (hide (-1 -2)) (("1" (expand "action_by_c") (("1" (replace -1 1 rl) (("1" (rewrite "lr_coset_assoc") (("1" (rewrite "lr_coset_assoc") (("1" (rewrite "lr_coset_assoc") (("1" (rewrite "right_coset_assoc") (("1" (rewrite "right_coset_one") (("1" (rewrite "left_coset_assoc") (("1" (rewrite "left_coset_one") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "stabilizer" "normalizer") (("2" (expand "extend") (("2" (prop) (("2" (hide (-1 -2)) (("2" (expand "action_by_c") (("2" (replace -1 1 rl) (("2" (rewrite "lr_coset_assoc") (("2" (rewrite "lr_coset_assoc") (("2" (rewrite "lr_coset_assoc") (("2" (rewrite "right_coset_assoc") (("2" (rewrite "right_coset_one") (("2" (rewrite "left_coset_assoc") (("2" (rewrite "left_coset_one") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "p_subgroup_sylow") (("3" (expand "extend") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (hide (-1 2)) (("4" (skosimp) (("4" (expand "p_subgroup_sylow" 1 1) (("4" (expand "extend") (("4" (prop) (("1" (hide (-1 -2)) (("1" (expand "action_by_c") (("1" (typepred "x1!1`2") (("1" (expand "p_subgroup_sylow") (("1" (expand "extend") (("1" (prop) (("1" (hide (-1 -2)) (("1" (lemma "conjugate_is_p_subgroup_sylow") (("1" (inst -1 "m!1" "n!1" "p!1" "G!1" "x1!1`2") (("1" (assert) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "action_by_c") (("2" (lemma "conjugate_is_subgroup[T, *, one]") (("1" (inst?) (("1" (hide-all-but (-1 1)) (("1" (lemma "subgroup_is_group[T, *, one]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (typepred "x1!1`2") (("2" (expand "p_subgroup_sylow") (("2" (expand "extend") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 2)) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil) ("3" (hide -) (("3" (expand "action_by_c") (("3" (lemma "conjugate_is_subgroup[T, *, one]") (("1" (inst?) (("1" (hide 2) (("1" (typepred "x1!1`2") (("1" (expand "p_subgroup_sylow") (("1" (expand "extend") (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "T_is_group") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((p_subgroup_sylow const-decl "setofsets[T]" sylow_theorems nil) (setofsets type-eq-decl nil sets nil) (prime? const-decl "bool" primes ints) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finite_group nonempty-type-eq-decl nil group nil) (finite_group? const-decl "bool" group_def nil) (one formal-const-decl "T" sylow_theorems nil) (* formal-const-decl "[T, T -> T]" sylow_theorems nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil) (T formal-type-decl nil sylow_theorems nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (Card const-decl "nat" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (group? const-decl "bool" group_def nil) (group nonempty-type-eq-decl nil group nil) (subgroup? const-decl "bool" group_def nil) (subgroup type-eq-decl nil group nil) (subset? const-decl "bool" sets nil) (normalizer const-decl "{S: set[T] | subset?(S, G)}" normalizer_centralizer nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (index const-decl "nat" right_left_cosets nil) (divides const-decl "bool" divides nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (x1!1 skolem-const-decl "[(G!1), (p_subgroup_sylow(G!1, p!1))]" sylow_theorems nil) (inv_right formula-decl nil group nil) (inv_left formula-decl nil group nil) (orbit const-decl "{Y: set[T1] | subset?(Y, X)}" group_action nil) (Lagrange_index formula-decl nil lagrange_index nil) (subset_of_normalizer formula-decl nil normalizer_centralizer nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (normalizer_is_subgroup formula-decl nil normalizer_centralizer nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (expt def-decl "real" exponentiation nil) (commutative_mult formula-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (both_sides_times1 formula-decl nil real_props nil) (associative_mult formula-decl nil number_fields nil) (finite_subgroups formula-decl nil group nil) (P!1 skolem-const-decl "subgroup[T, *, one](G!1)" sylow_theorems nil) (G!1 skolem-const-decl "finite_group[T, *, one]" sylow_theorems nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (p_subgroup_sylow_order formula-decl nil sylow_theorems nil) (Fix_congruence formula-decl nil group_action nil) (x1!1 skolem-const-decl "[(P!1), (p_subgroup_sylow(G!1, p!1))]" sylow_theorems nil) (* const-decl "set[T]" cosets nil) (conjugate_is_p_subgroup_sylow formula-decl nil sylow_theorems nil) (conjugate_is_subgroup formula-decl nil groups_scaf nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (Fix const-decl "{Y: set[T1] | subset?(Y, X)}" group_action nil) (finite_extend application-judgement "finite_set[T]" extend_set_props nil) (nonempty_extend application-judgement "(nonempty?[T])" extend_set_props nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[T]" countable_props sets_aux) (card_singleton formula-decl nil finite_sets nil) (card_extend formula-decl nil extend_set_props nil) (x!1 skolem-const-decl "setof[T]" sylow_theorems nil) (Second_Sylow_Theorem formula-decl nil sylow_theorems nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pos_times_lt formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (expt_pos_aux formula-decl nil exponentiation nil) (prime_gt_1 formula-decl nil primes ints) (order const-decl "posnat" monad nil) (finite_monad nonempty-type-eq-decl nil monad nil) (finite_monad? const-decl "bool" monad_def nil) (H!1 skolem-const-decl "subgroup[T, *, one](normalizer[T, *, one](G!1, x!1))" sylow_theorems nil) (normal_subgroup? const-decl "boolean" normal_subgroups nil) (normal_prep formula-decl nil normal_subgroups nil) (normal_in_normalizer formula-decl nil normalizer_centralizer nil) (is_conjugate const-decl "bool" sylow_theorems nil) (p_subgroup_sylow? const-decl "bool" sylow_theorems nil) (H!1 skolem-const-decl "subgroup[T, *, one](normalizer[T, *, one](G!1, x!1))" sylow_theorems nil) (T_is_group formula-decl nil sylow_theorems nil) (fullset const-decl "set" sets nil) (subgroup_transitive formula-decl nil groups_scaf nil) (x!3 skolem-const-decl "int" sylow_theorems nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gcd_sym formula-decl nil gcd ints) (gcd_1_gcd_1 formula-decl nil general_properties nil) (both_sides_times2 formula-decl nil real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (Lagrange formula-decl nil lagrange nil) (member const-decl "bool" sets nil) (inv_in formula-decl nil group nil) (inv_inv formula-decl nil group nil) (x!2 skolem-const-decl "T" sylow_theorems nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (subgroup_is_group formula-decl nil group nil) (p_group_iff_power formula-decl nil p_groups nil) (right_coset_one formula-decl nil cosets nil) (g!1 skolem-const-decl "(P!1)" sylow_theorems nil) (one_right formula-decl nil group nil) (rc_is_eq formula-decl nil cosets nil) (left_coset_one formula-decl nil cosets nil) (one_left formula-decl nil group nil) (lc_is_eq formula-decl nil cosets nil) (Third_Sylow_Theorem_TCC1 subtype-tcc nil sylow_theorems nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (group_action? const-decl "bool" group_action nil) (inv_one formula-decl nil group nil) (inv_star formula-decl nil group nil) (left_coset_assoc formula-decl nil cosets nil) (lr_coset_assoc formula-decl nil cosets nil) (right_coset_assoc formula-decl nil cosets nil) (* const-decl "set[T]" cosets nil) (p!1 skolem-const-decl "posnat" sylow_theorems nil) (orbits_eq_index formula-decl nil group_action nil) (action_by_c const-decl "set[T]" sylow_theorems nil) (stabilizer const-decl "{S: set[T] | subset?(S, G)}" group_action nil) (F type-eq-decl nil group_action nil)) shostak)))
