(cartesian_product_quot_ring (IMP_quotient_rings_TCC1 0 (IMP_quotient_rings_TCC1-1 nil 3796722930 ("" (rewrite "fullset_is_ring") nil nil) ((fullset_is_ring formula-decl nil cartesian_product_quot_ring nil)) nil (IMP_quotient_rings assuming "quotient_rings[cartesian_product_quot_ring.T, cartesian_product_quot_ring.+, cartesian_product_quot_ring.*, cartesian_product_quot_ring.zero].quotient_rings" "fullset_is_ring: ASSUMPTION ring_def[quotient_rings.T, quotient_rings.+, quotient_rings.*, quotient_rings.zero].ring?(sets[quotient_rings.T].fullset)"))) (Sfs_TCC1 0 (Sfs_TCC1-1 nil 3782485679 ("" (skosimp*) (("" (typepred "i!1" "fsx!1") (("" (expand "cartesian_product_n") (("" (expand "fsQ") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (setof type-eq-decl nil defined_types nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (fsI type-eq-decl nil ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (fsRI? const-decl "bool" ring_ideal_def nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" cartesian_product_quot_ring nil) (* formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (+ formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (finseq type-eq-decl nil finite_sequences nil) (set type-eq-decl nil sets nil) (T formal-nonempty-type-decl nil cartesian_product_quot_ring nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member const-decl "bool" sets nil)) nil (Sfs subtype "cartesian_product_quot_ring.i" "below[length(fsx)]"))) (Sfs_TCC2 0 (Sfs_TCC2-1 nil 3782485679 ("" (skosimp*) (("" (expand "finseq_appl") (("" (typepred "fsx!1") (("" (expand "cartesian_product_n") (("" (expand "fsQ") (("" (assert) (("" (prop) (("" (expand "finseq_appl") (("" (inst?) (("" (expand "/") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (member const-decl "bool" sets nil) (/ const-decl "setof[set[T]]" cosets_def nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-nonempty-type-decl nil cartesian_product_quot_ring nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (+ formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (* formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (zero formal-const-decl "T" cartesian_product_quot_ring nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil)) nil (Sfs subtype "finite_sequences[set[T]].finseq_appl(cartesian_product_quot_ring.fsx)(cartesian_product_quot_ring.i)" "coset[cartesian_product_quot_ring.T, cartesian_product_quot_ring.+](cartesian_product_quot_ring.R, finite_sequences[set[T]].finseq_appl(cartesian_product_quot_ring.fsA)(cartesian_product_quot_ring.i))"))) (Sfs_TCC3 0 (Sfs_TCC3-1 nil 3782485679 ("" (skosimp*) (("" (typepred "i!1" "fsy!1") (("" (expand "cartesian_product_n") (("" (expand "fsQ") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (setof type-eq-decl nil defined_types nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (fsI type-eq-decl nil ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (fsRI? const-decl "bool" ring_ideal_def nil) (ring? const-decl "bool" ring_def nil) (zero formal-const-decl "T" cartesian_product_quot_ring nil) (* formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (+ formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (finseq type-eq-decl nil finite_sequences nil) (set type-eq-decl nil sets nil) (T formal-nonempty-type-decl nil cartesian_product_quot_ring nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member const-decl "bool" sets nil)) nil (Sfs subtype "cartesian_product_quot_ring.i" "below[length(fsy)]"))) (Sfs_TCC4 0 (Sfs_TCC4-1 nil 3782485679 ("" (skosimp*) (("" (expand "finseq_appl") (("" (typepred "fsy!1") (("" (expand "cartesian_product_n") (("" (expand "finseq_appl") (("" (expand "member") (("" (expand "fsQ") (("" (prop) (("" (expand "finseq_appl") (("" (inst?) (("" (expand "/") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (member const-decl "bool" sets nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (/ const-decl "setof[set[T]]" cosets_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-nonempty-type-decl nil cartesian_product_quot_ring nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (+ formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (* formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (zero formal-const-decl "T" cartesian_product_quot_ring nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil)) nil (Sfs subtype "finite_sequences[set[T]].finseq_appl(cartesian_product_quot_ring.fsy)(cartesian_product_quot_ring.i)" "coset[cartesian_product_quot_ring.T, cartesian_product_quot_ring.+](cartesian_product_quot_ring.R, finite_sequences[set[T]].finseq_appl(cartesian_product_quot_ring.fsA)(cartesian_product_quot_ring.i))"))) (cartesian_product_quot_ring_is_ring_TCC1 0 (cartesian_product_quot_ring_is_ring_TCC2-1 nil 3782485679 ("" (skosimp) (("" (inst 2 "fsA!1") (("" (expand "cartesian_product_n") (("" (assert) (("" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "fsQ") (("2" (propax) nil nil)) nil) ("3" (expand "finseq_appl") (("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (rewrite "ideal_is_coset") (("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-nonempty-type-decl nil cartesian_product_quot_ring nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (+ formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (* formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (zero formal-const-decl "T" cartesian_product_quot_ring nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (fsA!1 skolem-const-decl "fsI[T, +, *, zero](R!1)" cartesian_product_quot_ring nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" cartesian_product_quot_ring nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (member const-decl "bool" sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (/ const-decl "setof[set[T]]" cosets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil)) nil (cartesian_product_quot_ring_is_ring existence "" "(cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring.fsQ(cartesian_product_quot_ring.R)(cartesian_product_quot_ring.fsA)))"))) (cartesian_product_quot_ring_is_ring_TCC2 0 (cartesian_product_quot_ring_is_ring_TCC3-1 nil 3782485679 ("" (skosimp*) (("" (expand "cartesian_product_n") (("" (prop) (("1" (expand "fsQ") (("1" (assert) nil nil)) nil) ("2" (expand "Sfs") (("2" (assert) (("2" (expand "fsQ") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (expand "finseq_appl") (("3" (expand "member") (("3" (expand "fsQ") (("3" (assert) (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "Sfs") (("3" (expand "finseq_appl") (("3" (typepred "x1!1`1" "x1!1`2") (("3" (expand "cartesian_product_n") (("3" (assert) (("3" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (inst?) (("2" (inst?) (("2" (rewrite "coset_add") (("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (member const-decl "bool" sets nil) (/ const-decl "setof[set[T]]" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (coset_add formula-decl nil quotient_rings nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-nonempty-type-decl nil cartesian_product_quot_ring nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (+ formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (* formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (zero formal-const-decl "T" cartesian_product_quot_ring nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (Sfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" seq_extras structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cartesian_product_quot_ring_is_ring subtype "cartesian_product_quot_ring.Sfs(cartesian_product_quot_ring.R)(cartesian_product_quot_ring.fsA)" "[[(cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring.fsQ(cartesian_product_quot_ring.R)(cartesian_product_quot_ring.fsA))), (cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring.fsQ(cartesian_product_quot_ring.R)(cartesian_product_quot_ring.fsA)))] -> (cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring.fsQ(cartesian_product_quot_ring.R)(cartesian_product_quot_ring.fsA)))]"))) (cartesian_product_quot_ring_is_ring_TCC3 0 (cartesian_product_quot_ring_is_ring_TCC4-1 nil 3782485679 ("" (skosimp*) (("" (expand "cartesian_product_n") (("" (prop) (("1" (expand "fsQ") (("1" (assert) nil nil)) nil) ("2" (expand "Pfs") (("2" (assert) (("2" (expand "fsQ") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (expand "finseq_appl") (("3" (expand "member") (("3" (expand "fsQ") (("3" (assert) (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "Pfs") (("3" (expand "finseq_appl") (("3" (rewrite "coset_product") (("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (member const-decl "bool" sets nil) (/ const-decl "setof[set[T]]" cosets_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (zero formal-const-decl "T" cartesian_product_quot_ring nil) (* formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (+ formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (T formal-nonempty-type-decl nil cartesian_product_quot_ring nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (below type-eq-decl nil naturalnumbers nil) (setof type-eq-decl nil defined_types nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (fsI type-eq-decl nil ring_ideal_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (coset_product formula-decl nil quotient_rings nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (Pfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" seq_extras structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cartesian_product_quot_ring_is_ring subtype "cartesian_product_quot_ring.Pfs(cartesian_product_quot_ring.R)(cartesian_product_quot_ring.fsA)" "[[(cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring.fsQ(cartesian_product_quot_ring.R)(cartesian_product_quot_ring.fsA))), (cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring.fsQ(cartesian_product_quot_ring.R)(cartesian_product_quot_ring.fsA)))] -> (cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring.fsQ(cartesian_product_quot_ring.R)(cartesian_product_quot_ring.fsA)))]"))) (cartesian_product_quot_ring_is_ring_TCC4 0 (cartesian_product_quot_ring_is_ring_TCC5-1 nil 3794235899 ("" (skosimp) (("" (expand "cartesian_product_n") (("" (assert) (("" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "fsQ") (("2" (propax) nil nil)) nil) ("3" (expand "finseq_appl") (("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (lemma "ideal_is_coset") (("3" (inst?) (("3" (hide (2 3)) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (inst?) (("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (T formal-nonempty-type-decl nil cartesian_product_quot_ring nil) (+ formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (* formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (zero formal-const-decl "T" cartesian_product_quot_ring nil) (NOT const-decl "[bool -> bool]" booleans nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" cartesian_product_quot_ring nil) (fsA!1 skolem-const-decl "fsI[T, +, *, zero](R!1)" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below(length(fsA!1))" cartesian_product_quot_ring nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (fsI type-eq-decl nil ring_ideal_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (/ const-decl "setof[set[T]]" cosets_def nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (member const-decl "bool" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cartesian_product_quot_ring_is_ring subtype "cartesian_product_quot_ring.fsA" "(cartesian_product_finite[set[T]].cartesian_product_n(cartesian_product_quot_ring.fsQ(cartesian_product_quot_ring.R)(cartesian_product_quot_ring.fsA)))"))) (cartesian_product_quot_ring_is_ring 0 (cartesian_product_quot_ring_is_ring-2 "" 3883097278 ("" (skosimp) (("" (expand "ring?") (("" (prop) (("1" (expand "abelian_group?") (("1" (prop) (("1" (expand "group?") (("1" (prop) (("1" (expand "monoid?") (("1" (prop) (("1" (expand "restrict") (("1" (expand "monad?") (("1" (prop) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (propax) nil nil)) nil) ("3" (expand "identity?") (("3" (skosimp) (("3" (expand "restrict") (("3" (typepred "x!1") (("3" (expand "cartesian_product_n") (("3" (assert) (("3" (expand "finseq_appl") (("3" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "fsQ") (("2" (propax) nil nil)) nil) ("3" (decompose-equality 1) (("1" (expand "Sfs") (("1" (expand "fsQ") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "Sfs") (("2" (expand "finseq_appl") (("2" (decompose-equality 1) (("1" (inst?) (("1" (expand "fsQ") (("1" (expand "finseq_appl") (("1" (expand "/") (("1" (expand "coset?") (("1" (flatten) (("1" (expand "left_coset?") (("1" (skosimp) (("1" (replace -2 1) (("1" (lemma "add_charac") (("1" (inst -1 "R!1" "fsA!1`seq(x!2)" "a!1" "zero") (("1" (lemma "left_zero") (("1" (inst -1 "fsA!1`seq(x!2)") (("1" (replaces -1) (("1" (rewrite "plus_zero") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (prop) (("1" (expand "fsQ") (("1" (assert) nil nil)) nil) ("2" (expand "fsQ") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (rewrite "ideal_is_coset") (("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (inst?) (("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (inst?) (("4" (expand "fsQ") (("4" (expand "finseq_appl") (("4" (expand "/") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skosimp) (("5" (typepred "i!1") (("5" (expand "fsQ") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (decompose-equality 1) (("1" (expand "Sfs") (("1" (expand "fsQ") (("1" (assert) nil nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand "Sfs") (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (expand "coset?") (("2" (flatten) (("2" (expand "left_coset?") (("2" (skosimp) (("2" (replace -2 1) (("2" (lemma "add_charac") (("2" (inst -1 "R!1" "fsA!1`seq(x!2)" "zero" "a!1") (("1" (lemma "left_zero") (("1" (inst -1 "fsA!1`seq(x!2)") (("1" (replaces -1) (("1" (rewrite "zero_plus") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "associative?") (("2" (expand "restrict") (("2" (skosimp) (("2" (typepred "x!1" "y!1" "z!1") (("2" (expand "restrict") (("2" (hide -2 -4 -6) (("2" (expand "cartesian_product_n") (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (assert) (("2" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (hide (1 2)) (("2" (decompose-equality 2) (("1" (expand "Sfs") (("1" (propax) nil nil)) nil) ("2" (decompose-equality 1) (("2" (expand "Sfs") (("2" (expand "finseq_appl") (("2" (inst?) (("2" (inst?) (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (expand "coset?") (("2" (flatten) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (replaces -2) (("2" (replaces -4) (("2" (replaces -6) (("2" (hide-all-but 1) (("2" (typepred "a!1" "a!2" "a!3" "R!1") (("2" (rewrite "add_charac") (("1" (rewrite "add_charac") (("1" (rewrite "add_charac") (("1" (rewrite "add_charac") (("1" (expand "ring?") (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (flatten) (("1" (hide (-4 -6 -7 -8 -9 -10 -11)) (("1" (expand "associative?") (("1" (expand "restrict") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "star_closed?") (("2" (flatten) (("2" (hide-all-but (-1 -2 -4 1)) (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "star_closed?") (("2" (expand "member") (("2" (flatten) (("2" (hide-all-but (-2 -3 -4 1)) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "inv_exists?") (("2" (skosimp) (("2" (typepred "x!1") (("2" (expand "cartesian_product_n") (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (prop) (("1" (hide 1) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil)) nil) ("2" (hide -1) (("2" (hide 2) (("2" (inst 2 "(# length := length(x!1), seq := (LAMBDA (i:below[length(x!1)]): inv[coset(R!1, fsA!1`seq(i)),add(R!1, fsA!1`seq(i)),fsA!1`seq(i)](x!1`seq(i))) #)") (("1" (assert) (("1" (expand "Sfs") (("1" (expand "finseq_appl") (("1" (split) (("1" (decompose-equality 1) (("1" (decompose-equality 1) (("1" (skosimp) (("1" (lemma "quotient_group_is_abelian_group") (("1" (inst -1 "R!1" "fsA!1`seq(i!1)") (("1" (expand "abelian_group?") (("1" (flatten) (("1" (hide -2) (("1" (expand "/") (("1" (assert) (("1" (expand "fullset") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (hide (- 2 3)) (("2" (lemma "ideal_is_coset") (("2" (inst?) (("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (lemma "coset_add") (("3" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (hide-all-but (-1 1)) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (inst 1 "fsA!1`seq(i!1)") (("4" (hide-all-but 1) (("4" (lemma "ideal_is_coset") (("4" (inst?) (("4" (hide 2) (("4" (typepred "fsA!1") (("4" (expand "fsRI?") (("4" (expand "finseq_appl") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skosimp) (("5" (inst -2 "i!1") (("5" (expand "fsQ") (("5" (expand "/") (("5" (expand "finseq_appl") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (skosimp) (("6" (expand "fsQ") (("6" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (hide (-1 -2 2 3)) (("2" (lemma "quotient_group_is_abelian_group") (("2" (inst -1 "R!1" "fsA!1`seq(i!1)") (("1" (expand "abelian_group?") (("1" (flatten) (("1" (hide -2) (("1" (expand "/") (("1" (assert) (("1" (expand "fullset") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (hide (- 2 3)) (("3" (lemma "ideal_is_coset") (("3" (inst?) (("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (lemma "coset_add") (("4" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (hide-all-but (-1 1)) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skosimp) (("5" (inst 1 "fsA!1`seq(i!1)") (("5" (rewrite "ideal_is_coset") (("5" (hide 2) (("5" (typepred "fsA!1") (("5" (expand "fsRI?") (("5" (expand "finseq_appl") (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skosimp) (("6" (inst?) (("6" (expand "fsQ") (("6" (expand "finseq_appl") (("6" (expand "/") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (skosimp) (("7" (expand "fsQ") (("7" (assert) nil nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (decompose-equality 1) (("1" (skosimp) (("1" (hide (-1 -2 2 3)) (("1" (lemma "quotient_group_is_abelian_group") (("1" (inst -1 "R!1" "fsA!1`seq(i!1)") (("1" (expand "abelian_group?") (("1" (flatten) (("1" (hide -2) (("1" (expand "/") (("1" (assert) (("1" (expand "fullset") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (lemma "ideal_is_coset") (("2" (inst?) (("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (lemma "coset_add") (("3" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (hide-all-but (-1 1)) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (inst 1 "fsA!1`seq(i!1)") (("4" (hide-all-but 1) (("4" (lemma "ideal_is_coset") (("4" (inst?) (("4" (hide 2) (("4" (typepred "fsA!1") (("4" (expand "fsRI?") (("4" (expand "finseq_appl") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skosimp) (("5" (inst?) (("5" (expand "fsQ") (("5" (expand "finseq_appl") (("5" (expand "/") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (skosimp) (("6" (expand "fsQ") (("6" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (hide (-1 -2 2 3)) (("2" (lemma "quotient_group_is_abelian_group") (("2" (inst -1 "R!1" "fsA!1`seq(i!1)") (("1" (expand "abelian_group?") (("1" (flatten) (("1" (hide -2) (("1" (expand "/") (("1" (assert) (("1" (expand "fullset") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (hide (- 2 3)) (("3" (lemma "ideal_is_coset") (("3" (inst?) (("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (lemma "coset_add") (("4" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (hide-all-but (-1 1)) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (skosimp) (("5" (inst 1 "fsA!1`seq(i!1)") (("5" (rewrite "ideal_is_coset") (("5" (hide 2) (("5" (typepred "fsA!1") (("5" (expand "fsRI?") (("5" (expand "finseq_appl") (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skosimp) (("6" (inst?) (("6" (expand "fsQ") (("6" (expand "finseq_appl") (("6" (expand "/") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (skosimp) (("7" (expand "fsQ") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (assert) (("2" (expand "cartesian_product_n") (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (bddsimp) (("2" (skosimp) (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (rewrite "inv_in") (("1" (hide (- 2 3 4)) (("1" (prop) (("1" (skosimp) (("1" (expand "/") (("1" (propax) nil nil)) nil)) nil) ("2" (lemma "quotient_group_is_abelian_group") (("2" (inst?) (("1" (expand "abelian_group?") (("1" (flatten) (("1" (hide -2) (("1" (expand "group?") (("1" (prop) (("1" (hide -2) (("1" (expand "monoid?") (("1" (prop) (("1" (hide -2) (("1" (expand "monad?") (("1" (prop) (("1" (hide (-2 -3)) (("1" (expand "star_closed?") (("1" (expand "member") (("1" (skosimp) (("1" (expand "/") (("1" (expand "restrict") (("1" (inst?) (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -3)) (("2" (expand "member") (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide (-1 -2)) (("3" (expand "identity?") (("3" (skosimp) (("3" (expand "restrict") (("3" (inst?) (("3" (expand "restrict") (("3" (hide 2) (("3" (typepred "x!2") (("3" (expand "/") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "associative?") (("2" (expand "restrict") (("2" (skosimp) (("2" (inst?) (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil) ("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "inv_exists?") (("2" (skosimp) (("2" (inst -1 "x!2") (("1" (skosimp) (("1" (inst?) (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (expand "/") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "/") (("2" (expand "restrict") (("2" (typepred "x!2") (("2" (expand "/") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "fullset_quot_group_is_ring") (("2" (inst -1 "R!1" "fsA!1`seq(i!1)") (("1" (expand "ring?") (("1" (expand "abelian_group?") (("1" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "ideal_is_coset") (("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skosimp) (("4" (lemma "coset_add") (("4" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (inst 1 "fsA!1`seq(i!1)") (("5" (rewrite "ideal_is_coset") (("5" (hide 2) (("5" (typepred "fsA!1") (("5" (expand "fsRI?") (("5" (expand "finseq_appl") (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (lemma "fullset_quot_group_is_ring") (("3" (inst -1 "R!1" "fsA!1`seq(i!1)") (("1" (expand "ring?") (("1" (flatten) (("1" (expand "abelian_group?") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide (-2 2 3)) (("3" (expand "fsQ") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skosimp) (("4" (rewrite "ideal_is_coset") (("4" (hide 2) (("4" (typepred "fsA!1") (("4" (expand "fsRI?") (("4" (expand "finseq_appl") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide (-2 2)) (("5" (skosimp*) (("5" (lemma "coset_add") (("5" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (assert) nil nil)) nil) ("2" (hide (- 2 3)) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skosimp) (("6" (inst 1 "fsA!1`seq(i!1)") (("1" (rewrite "ideal_is_coset") (("1" (hide 2) (("1" (typepred "fsA!1") (("1" (expand "fsRI?") (("1" (expand "finseq_appl") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (hide (-3 2)) (("2" (expand "fsQ") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide (-2 2)) (("7" (skosimp) (("7" (expand "fsQ") (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (skosimp) (("8" (inst?) (("8" (expand "fsQ") (("8" (assert) (("8" (expand "finseq_appl") (("8" (expand "/") (("8" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "commutative?") (("2" (expand "restrict") (("2" (skosimp) (("2" (expand "Sfs") (("2" (assert) (("2" (expand "finseq_appl") (("2" (decompose-equality 1) (("1" (typepred "x!1" "y!1") (("1" (expand "cartesian_product_n") (("1" (assert) (("1" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (hide -1 -4 2 4) (("2" (expand "finseq_appl") (("2" (inst?) (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (expand "coset?") (("2" (flatten) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (replaces -2) (("2" (replaces -4) (("2" (rewrite "add_charac") (("1" (rewrite "add_charac") (("1" (hide-all-but 3) (("1" (typepred "a!1" "a!2" "R!1") (("1" (expand "ring?") (("1" (expand "abelian_group?") (("1" (flatten) (("1" (hide (-3 -5 -6 -7 -8)) (("1" (expand "commutative?") (("1" (expand "restrict") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "y!1") (("2" (expand "cartesian_product_n") (("2" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (hide -1 1) (("2" (expand "finseq_appl") (("2" (inst?) (("2" (expand "member") (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (typepred "y!1") (("3" (expand "cartesian_product_n") (("3" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (hide -1 1) (("2" (hide (-2 1)) (("2" (expand "fsQ") (("2" (typepred "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (typepred "x!1") (("4" (expand "cartesian_product_n") (("4" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "member") (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skosimp) (("5" (typepred "x!1") (("5" (expand "cartesian_product_n") (("5" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (hide -1 1) (("2" (hide (-2 1)) (("2" (expand "fsQ") (("2" (typepred "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "associative?") (("3" (skosimp) (("3" (expand "restrict") (("3" (decompose-equality 1) (("1" (expand "Pfs") (("1" (propax) nil nil)) nil) ("2" (decompose-equality 1) (("2" (expand "Pfs") (("2" (expand "finseq_appl") (("2" (typepred "x!1" "y!1" "z!1") (("2" (expand "cartesian_product_n") (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (assert) (("2" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (hide -1 -4 -7 1 2 3) (("2" (hide (1 2)) (("2" (inst?) (("2" (inst?) (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (expand "coset?") (("2" (flatten) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (replaces -2) (("2" (replaces -4) (("2" (replaces -6) (("2" (hide-all-but 2) (("2" (typepred "a!1" "a!2" "a!3" "R!1") (("2" (rewrite "product_charac") (("1" (rewrite "product_charac") (("1" (rewrite "product_charac") (("1" (rewrite "product_charac") (("1" (expand "ring?") (("1" (flatten) (("1" (hide (-4 -5 -7 -8)) (("1" (expand "associative?") (("1" (expand "restrict") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ring?") (("2" (flatten) (("2" (expand "star_closed?") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ring?") (("2" (flatten) (("2" (expand "star_closed?") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "left_distributive?") (("4" (skosimp) (("4" (expand "restrict") (("4" (decompose-equality 1) (("1" (expand "Pfs") (("1" (expand "Sfs") (("1" (propax) nil nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand "Pfs") (("2" (expand "Sfs") (("2" (expand "finseq_appl") (("2" (typepred "x!1" "y!1" "z!1") (("2" (expand "cartesian_product_n") (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (assert) (("2" (prop) (("1" (hide -2 -3 -6 -7 -10 -11) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil)) nil) ("2" (hide -1 -4 -7 1 2 3 4 5) (("2" (inst?) (("2" (inst?) (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (expand "coset?") (("2" (flatten) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (replaces -2) (("2" (replaces -4) (("2" (replaces -6) (("2" (hide-all-but 2) (("2" (typepred "a!1" "a!2" "a!3" "R!1") (("2" (rewrite "product_charac") (("1" (rewrite "product_charac") (("1" (rewrite "add_charac") (("1" (rewrite "add_charac") (("1" (rewrite "product_charac") (("1" (expand "ring?") (("1" (flatten) (("1" (hide (-4 -5 -6 -8)) (("1" (expand "left_distributive?") (("1" (expand "restrict") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "star_closed?") (("2" (flatten) (("2" (hide-all-but (-1 -2 -4 1)) (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ring?") (("2" (expand "star_closed?") (("2" (expand "member") (("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "ring?") (("3" (expand "star_closed?") (("3" (expand "member") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "fsA!1") (("4" (expand "fsRI?") (("4" (expand "finseq_appl") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "right_distributive?") (("5" (skosimp) (("5" (expand "restrict") (("5" (decompose-equality 1) (("1" (expand "Pfs") (("1" (expand "Sfs") (("1" (propax) nil nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand "Pfs") (("2" (expand "Sfs") (("2" (expand "finseq_appl") (("2" (typepred "x!1" "y!1" "z!1") (("2" (hide -2 -4 -6) (("2" (expand "cartesian_product_n") (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (assert) (("2" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (hide (1 2)) (("2" (inst?) (("2" (inst?) (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (expand "coset?") (("2" (flatten) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (replaces -2) (("2" (replaces -4) (("2" (replaces -6) (("2" (hide-all-but 2) (("2" (typepred "a!1" "a!2" "a!3" "R!1") (("2" (rewrite "product_charac") (("1" (rewrite "product_charac") (("1" (rewrite "add_charac") (("1" (rewrite "add_charac") (("1" (rewrite "product_charac") (("1" (expand "ring?") (("1" (flatten) (("1" (hide (-4 -5 -6 -7)) (("1" (expand "right_distributive?") (("1" (expand "restrict") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "star_closed?") (("2" (flatten) (("2" (hide-all-but (-1 -2 -4 1)) (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ring?") (("2" (expand "star_closed?") (("2" (expand "member") (("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "ring?") (("3" (expand "star_closed?") (("3" (expand "member") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "fsA!1") (("4" (expand "fsRI?") (("4" (expand "finseq_appl") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (cartesian_product_quot_ring_is_ring-1 nil 3782486571 ("" (skosimp) (("" (expand "ring?") (("" (prop) (("1" (expand "abelian_group?") (("1" (prop) (("1" (expand "group?") (("1" (prop) (("1" (expand "monoid?") (("1" (prop) (("1" (expand "monad?") (("1" (prop) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (expand "member") (("1" (expand "cartesian_product_n") (("1" (prop) (("1" (expand "fsQ") (("1" (assert) nil nil)) nil) ("2" (expand "Sfs") (("2" (expand "fsQ") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (skosimp) (("3" (expand "member") (("3" (expand "fsQ") (("3" (assert) (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "Sfs") (("3" (expand "finseq_appl") (("3" (lemma "coset_add") (("3" (inst?) (("3" (hide (2 3)) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member") (("2" (expand "cartesian_product_n") (("2" (expand "finseq_appl") (("2" (prop) (("1" (expand "fsQ") (("1" (assert) nil nil)) nil) ("2" (expand "fsQ") (("2" (assert) nil nil)) nil) ("3" (skosimp) (("3" (expand "member") (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (lemma "ideal_is_coset") (("3" (inst?) (("3" (hide (2 3)) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (inst?) (("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "identity?") (("3" (skosimp) (("3" (expand "restrict") (("3" (typepred "x!1") (("3" (expand "cartesian_product_n") (("3" (assert) (("3" (expand "finseq_appl") (("3" (prop) (("1" (expand "fsQ") (("1" (propax) nil nil)) nil) ("2" (expand "fsQ") (("2" (propax) nil nil)) nil) ("3" (decompose-equality 1) (("1" (expand "Sfs") (("1" (expand "fsQ") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "Sfs") (("2" (expand "finseq_appl") (("2" (decompose-equality 1) (("1" (inst?) (("1" (expand "fsQ") (("1" (expand "finseq_appl") (("1" (expand "/") (("1" (expand "coset?") (("1" (flatten) (("1" (expand "left_coset?") (("1" (skosimp) (("1" (replace -2 1) (("1" (lemma "add_charac") (("1" (inst -1 "R!1" "fsA!1`seq(x!2)" "a!1" "zero") (("1" (lemma "left_zero") (("1" (inst -1 "fsA!1`seq(x!2)") (("1" (replaces -1) (("1" (rewrite "plus_zero") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (prop) (("1" (expand "fsQ") (("1" (assert) nil nil)) nil) ("2" (expand "fsQ") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (rewrite "ideal_is_coset") (("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (inst?) (("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (inst?) (("4" (expand "fsQ") (("4" (expand "finseq_appl") (("4" (expand "/") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skosimp) (("5" (typepred "i!1") (("5" (expand "fsQ") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (decompose-equality 1) (("1" (expand "Sfs") (("1" (expand "fsQ") (("1" (assert) nil nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand "Sfs") (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (expand "coset?") (("2" (flatten) (("2" (expand "left_coset?") (("2" (skosimp) (("2" (replace -2 1) (("2" (lemma "add_charac") (("2" (inst -1 "R!1" "fsA!1`seq(x!2)" "zero" "a!1") (("1" (lemma "left_zero") (("1" (inst -1 "fsA!1`seq(x!2)") (("1" (replaces -1) (("1" (rewrite "zero_plus") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "R!1") (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "associative?") (("2" (expand "restrict") (("2" (skosimp) (("2" (typepred "x!1" "y!1" "z!1") (("2" (expand "cartesian_product_n") (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (assert) (("2" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (hide (1 2)) (("2" (decompose-equality 2) (("1" (expand "Sfs") (("1" (propax) nil nil)) nil) ("2" (decompose-equality 1) (("2" (expand "Sfs") (("2" (expand "finseq_appl") (("2" (inst?) (("2" (inst?) (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (expand "coset?") (("2" (flatten) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (replaces -2) (("2" (replaces -4) (("2" (replaces -6) (("2" (hide-all-but 1) (("2" (typepred "a!1" "a!2" "a!3" "R!1") (("2" (rewrite "add_charac") (("1" (rewrite "add_charac") (("1" (rewrite "add_charac") (("1" (rewrite "add_charac") (("1" (expand "ring?") (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (flatten) (("1" (hide (-4 -6 -7 -8 -9 -10 -11)) (("1" (expand "associative?") (("1" (expand "restrict") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "star_closed?") (("2" (flatten) (("2" (hide-all-but (-1 -2 -4 1)) (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "star_closed?") (("2" (expand "member") (("2" (flatten) (("2" (hide-all-but (-2 -3 -4 1)) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "inv_exists?") (("2" (skosimp) (("2" (typepred "x!1") (("2" (expand "cartesian_product_n") (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (prop) (("1" (hide 1) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil)) nil) ("2" (inst 2 "(# length := length(x!1), seq := (LAMBDA (i:below[length(x!1)]): inv[coset(R!1, fsA!1`seq(i)),add(R!1, fsA!1`seq(i)),fsA!1`seq(i)](x!1`seq(i))) #)") (("1" (assert) (("1" (expand "Sfs") (("1" (expand "finseq_appl") (("1" (split) (("1" (decompose-equality 1) (("1" (decompose-equality 1) (("1" (skosimp) (("1" (lemma "quotient_group_is_abelian_group") (("1" (inst -1 "R!1" "fsA!1`seq(i!1)") (("1" (expand "abelian_group?") (("1" (flatten) (("1" (hide -2) (("1" (expand "/") (("1" (assert) (("1" (expand "fullset") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (hide (- 2 3)) (("2" (lemma "ideal_is_coset") (("2" (inst?) (("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (lemma "coset_add") (("3" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (hide-all-but (-1 1)) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (inst 1 "fsA!1`seq(i!1)") (("4" (hide-all-but 1) (("4" (lemma "ideal_is_coset") (("4" (inst?) (("4" (hide 2) (("4" (typepred "fsA!1") (("4" (expand "fsRI?") (("4" (expand "finseq_appl") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skosimp) (("5" (inst -2 "i!1") (("5" (expand "fsQ") (("5" (expand "/") (("5" (expand "finseq_appl") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (skosimp) (("6" (expand "fsQ") (("6" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (hide (-1 -2 2 3)) (("2" (lemma "quotient_group_is_abelian_group") (("2" (inst -1 "R!1" "fsA!1`seq(i!1)") (("1" (expand "abelian_group?") (("1" (flatten) (("1" (hide -2) (("1" (expand "/") (("1" (assert) (("1" (expand "fullset") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (hide (- 2 3)) (("3" (lemma "ideal_is_coset") (("3" (inst?) (("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (lemma "coset_add") (("4" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (hide-all-but (-1 1)) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skosimp) (("5" (inst 1 "fsA!1`seq(i!1)") (("5" (rewrite "ideal_is_coset") (("5" (hide 2) (("5" (typepred "fsA!1") (("5" (expand "fsRI?") (("5" (expand "finseq_appl") (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skosimp) (("6" (inst?) (("6" (expand "fsQ") (("6" (expand "finseq_appl") (("6" (expand "/") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (skosimp) (("7" (expand "fsQ") (("7" (assert) nil nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (decompose-equality 1) (("1" (skosimp) (("1" (hide (-1 -2 2 3)) (("1" (lemma "quotient_group_is_abelian_group") (("1" (inst -1 "R!1" "fsA!1`seq(i!1)") (("1" (expand "abelian_group?") (("1" (flatten) (("1" (hide -2) (("1" (expand "/") (("1" (assert) (("1" (expand "fullset") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (lemma "ideal_is_coset") (("2" (inst?) (("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (lemma "coset_add") (("3" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (hide-all-but (-1 1)) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (inst 1 "fsA!1`seq(i!1)") (("4" (hide-all-but 1) (("4" (lemma "ideal_is_coset") (("4" (inst?) (("4" (hide 2) (("4" (typepred "fsA!1") (("4" (expand "fsRI?") (("4" (expand "finseq_appl") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skosimp) (("5" (inst?) (("5" (expand "fsQ") (("5" (expand "finseq_appl") (("5" (expand "/") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (skosimp) (("6" (expand "fsQ") (("6" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (hide (-1 -2 2 3)) (("2" (lemma "quotient_group_is_abelian_group") (("2" (inst -1 "R!1" "fsA!1`seq(i!1)") (("1" (expand "abelian_group?") (("1" (flatten) (("1" (hide -2) (("1" (expand "/") (("1" (assert) (("1" (expand "fullset") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (hide (- 2 3)) (("3" (lemma "ideal_is_coset") (("3" (inst?) (("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (lemma "coset_add") (("4" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (hide-all-but (-1 1)) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (skosimp) (("5" (inst 1 "fsA!1`seq(i!1)") (("5" (rewrite "ideal_is_coset") (("5" (hide 2) (("5" (typepred "fsA!1") (("5" (expand "fsRI?") (("5" (expand "finseq_appl") (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skosimp) (("6" (inst?) (("6" (expand "fsQ") (("6" (expand "finseq_appl") (("6" (expand "/") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (skosimp) (("7" (expand "fsQ") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cartesian_product_n") (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (assert) (("2" (skosimp) (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (rewrite "inv_in") (("1" (hide (- 2 3 4)) (("1" (prop) (("1" (skosimp) (("1" (expand "/") (("1" (propax) nil nil)) nil)) nil) ("2" (lemma "quotient_group_is_abelian_group") (("2" (inst?) (("1" (expand "abelian_group?") (("1" (flatten) (("1" (hide -2) (("1" (expand "group?") (("1" (prop) (("1" (hide -2) (("1" (expand "monoid?") (("1" (prop) (("1" (hide -2) (("1" (expand "monad?") (("1" (prop) (("1" (hide (-2 -3)) (("1" (expand "star_closed?") (("1" (expand "member") (("1" (skosimp) (("1" (expand "/") (("1" (expand "restrict") (("1" (inst?) (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -3)) (("2" (expand "member") (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide (-1 -2)) (("3" (expand "identity?") (("3" (skosimp) (("3" (expand "restrict") (("3" (inst?) (("3" (expand "restrict") (("3" (hide 2) (("3" (typepred "x!2") (("3" (expand "/") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "associative?") (("2" (expand "restrict") (("2" (skosimp) (("2" (inst?) (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil) ("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "inv_exists?") (("2" (skosimp) (("2" (inst -1 "x!2") (("1" (skosimp) (("1" (inst?) (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (expand "/") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "/") (("2" (expand "restrict") (("2" (typepred "x!2") (("2" (expand "/") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "fullset_quot_group_is_ring") (("2" (inst -1 "R!1" "fsA!1`seq(i!1)") (("1" (expand "ring?") (("1" (expand "abelian_group?") (("1" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "ideal_is_coset") (("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skosimp) (("4" (lemma "coset_add") (("4" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (inst 1 "fsA!1`seq(i!1)") (("5" (rewrite "ideal_is_coset") (("5" (hide 2) (("5" (typepred "fsA!1") (("5" (expand "fsRI?") (("5" (expand "finseq_appl") (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (lemma "fullset_quot_group_is_ring") (("3" (inst -1 "R!1" "fsA!1`seq(i!1)") (("1" (expand "ring?") (("1" (flatten) (("1" (expand "abelian_group?") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("3" (hide (-2 2 3)) (("3" (expand "fsQ") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skosimp) (("4" (rewrite "ideal_is_coset") (("4" (hide 2) (("4" (typepred "fsA!1") (("4" (expand "fsRI?") (("4" (expand "finseq_appl") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide (-2 2)) (("5" (skosimp*) (("5" (lemma "coset_add") (("5" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (assert) nil nil)) nil) ("2" (hide (- 2 3)) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skosimp) (("6" (inst 1 "fsA!1`seq(i!1)") (("1" (rewrite "ideal_is_coset") (("1" (hide 2) (("1" (typepred "fsA!1") (("1" (expand "fsRI?") (("1" (expand "finseq_appl") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (hide (-3 2)) (("2" (expand "fsQ") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide (-2 2)) (("7" (skosimp) (("7" (expand "fsQ") (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (skosimp) (("8" (inst?) (("8" (expand "fsQ") (("8" (assert) (("8" (expand "finseq_appl") (("8" (expand "/") (("8" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "commutative?") (("2" (expand "restrict") (("2" (skosimp) (("2" (expand "Sfs") (("2" (assert) (("2" (expand "finseq_appl") (("2" (decompose-equality 1) (("1" (typepred "x!1" "y!1") (("1" (expand "cartesian_product_n") (("1" (assert) (("1" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (inst?) (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (expand "coset?") (("2" (flatten) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (replaces -2) (("2" (replaces -4) (("2" (rewrite "add_charac") (("1" (rewrite "add_charac") (("1" (hide-all-but 3) (("1" (typepred "a!1" "a!2" "R!1") (("1" (expand "ring?") (("1" (expand "abelian_group?") (("1" (flatten) (("1" (hide (-3 -5 -6 -7 -8)) (("1" (expand "commutative?") (("1" (expand "restrict") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "y!1") (("2" (expand "cartesian_product_n") (("2" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (inst?) (("2" (expand "member") (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (typepred "y!1") (("3" (expand "cartesian_product_n") (("3" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (hide (-2 1)) (("2" (expand "fsQ") (("2" (typepred "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (typepred "x!1") (("4" (expand "cartesian_product_n") (("4" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "member") (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skosimp) (("5" (typepred "x!1") (("5" (expand "cartesian_product_n") (("5" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (hide (-2 1)) (("2" (expand "fsQ") (("2" (typepred "i!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "cartesian_product_n") (("2" (prop) (("1" (expand "emptyset") (("1" (expand "fsQ") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "Pfs") (("2" (assert) (("2" (expand "fsQ") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (expand "member") (("3" (skosimp) (("3" (expand "fsQ") (("3" (assert) (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "Pfs") (("3" (expand "finseq_appl") (("3" (rewrite "coset_product") (("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "associative?") (("3" (skosimp) (("3" (expand "restrict") (("3" (decompose-equality 1) (("1" (expand "Pfs") (("1" (propax) nil nil)) nil) ("2" (decompose-equality 1) (("2" (expand "Pfs") (("2" (expand "finseq_appl") (("2" (typepred "x!1" "y!1" "z!1") (("2" (expand "cartesian_product_n") (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (assert) (("2" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (hide (1 2)) (("2" (inst?) (("2" (inst?) (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (expand "coset?") (("2" (flatten) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (replaces -2) (("2" (replaces -4) (("2" (replaces -6) (("2" (hide-all-but 2) (("2" (typepred "a!1" "a!2" "a!3" "R!1") (("2" (rewrite "product_charac") (("1" (rewrite "product_charac") (("1" (rewrite "product_charac") (("1" (rewrite "product_charac") (("1" (expand "ring?") (("1" (flatten) (("1" (hide (-4 -5 -7 -8)) (("1" (expand "associative?") (("1" (expand "restrict") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ring?") (("2" (flatten) (("2" (expand "star_closed?") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ring?") (("2" (flatten) (("2" (expand "star_closed?") (("2" (expand "member") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "left_distributive?") (("4" (skosimp) (("4" (expand "restrict") (("4" (decompose-equality 1) (("1" (expand "Pfs") (("1" (expand "Sfs") (("1" (propax) nil nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand "Pfs") (("2" (expand "Sfs") (("2" (expand "finseq_appl") (("2" (typepred "x!1" "y!1" "z!1") (("2" (expand "cartesian_product_n") (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (assert) (("2" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (hide (1 2)) (("2" (inst?) (("2" (inst?) (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (expand "coset?") (("2" (flatten) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (replaces -2) (("2" (replaces -4) (("2" (replaces -6) (("2" (hide-all-but 2) (("2" (typepred "a!1" "a!2" "a!3" "R!1") (("2" (rewrite "product_charac") (("1" (rewrite "product_charac") (("1" (rewrite "add_charac") (("1" (rewrite "add_charac") (("1" (rewrite "product_charac") (("1" (expand "ring?") (("1" (flatten) (("1" (hide (-4 -5 -6 -8)) (("1" (expand "left_distributive?") (("1" (expand "restrict") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "star_closed?") (("2" (flatten) (("2" (hide-all-but (-1 -2 -4 1)) (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ring?") (("2" (expand "star_closed?") (("2" (expand "member") (("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "ring?") (("3" (expand "star_closed?") (("3" (expand "member") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "fsA!1") (("4" (expand "fsRI?") (("4" (expand "finseq_appl") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "right_distributive?") (("5" (skosimp) (("5" (expand "restrict") (("5" (decompose-equality 1) (("1" (expand "Pfs") (("1" (expand "Sfs") (("1" (propax) nil nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand "Pfs") (("2" (expand "Sfs") (("2" (expand "finseq_appl") (("2" (typepred "x!1" "y!1" "z!1") (("2" (expand "cartesian_product_n") (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (assert) (("2" (prop) (("1" (expand "emptyset") (("1" (propax) nil nil)) nil) ("2" (hide (1 2)) (("2" (inst?) (("2" (inst?) (("2" (inst?) (("2" (expand "fsQ") (("2" (expand "finseq_appl") (("2" (expand "/") (("2" (expand "coset?") (("2" (flatten) (("2" (expand "left_coset?") (("2" (skosimp*) (("2" (replaces -2) (("2" (replaces -4) (("2" (replaces -6) (("2" (hide-all-but 2) (("2" (typepred "a!1" "a!2" "a!3" "R!1") (("2" (rewrite "product_charac") (("1" (rewrite "product_charac") (("1" (rewrite "add_charac") (("1" (rewrite "add_charac") (("1" (rewrite "product_charac") (("1" (expand "ring?") (("1" (flatten) (("1" (hide (-4 -5 -6 -7)) (("1" (expand "right_distributive?") (("1" (expand "restrict") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ring?") (("2" (expand "abelian_group?") (("2" (expand "group?") (("2" (expand "monoid?") (("2" (expand "monad?") (("2" (expand "star_closed?") (("2" (flatten) (("2" (hide-all-but (-1 -2 -4 1)) (("2" (inst?) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "fsA!1") (("3" (expand "fsRI?") (("3" (expand "finseq_appl") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ring?") (("2" (expand "star_closed?") (("2" (expand "member") (("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "ring?") (("3" (expand "star_closed?") (("3" (expand "member") (("3" (flatten) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "fsA!1") (("4" (expand "fsRI?") (("4" (expand "finseq_appl") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "fsA!1") (("2" (expand "fsRI?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ring? const-decl "bool" ring_def nil) (right_distributive? const-decl "bool" operator_defs_more nil) (left_distributive? const-decl "bool" operator_defs_more nil) (product_charac formula-decl nil quotient_rings nil) (Pfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (abelian_group? const-decl "bool" group_def nil) (commutative? const-decl "bool" operator_defs nil) (y!1 skolem-const-decl "(restrict
     [finseq[set[T]], (cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))), bool]
     (cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))))" cartesian_product_quot_ring nil) (x!1 skolem-const-decl "(restrict
     [finseq[set[T]], (cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))), bool]
     (cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))))" cartesian_product_quot_ring nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" seq_extras structures) (group? const-decl "bool" group_def nil) (inv_exists? const-decl "bool" group_def nil) (i!1 skolem-const-decl "below[length(x!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(x!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(x!1)]" cartesian_product_quot_ring nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (inv_in formula-decl nil group nil) (group nonempty-type-eq-decl nil group nil) (i!1 skolem-const-decl "below(length(x!1))" cartesian_product_quot_ring nil) (y!1 skolem-const-decl "(restrict[set[T], coset[T, +](R!1, fsA!1`seq(i!1)), bool]
     (R!1 / fsA!1`seq(i!1)))" cartesian_product_quot_ring nil) (x!2 skolem-const-decl "(/[T, +](R!1, fsA!1`seq(i!1)))" cartesian_product_quot_ring nil) (x!2 skolem-const-decl "(/[T, +](R!1, fsA!1`seq(i!1)))" cartesian_product_quot_ring nil) (x!2 skolem-const-decl "(/[T, +](R!1, fsA!1`seq(i!1)))" cartesian_product_quot_ring nil) (y!1 skolem-const-decl "(/[T, +](R!1, fsA!1`seq(i!1)))" cartesian_product_quot_ring nil) (z!1 skolem-const-decl "(/[T, +](R!1, fsA!1`seq(i!1)))" cartesian_product_quot_ring nil) (y!1 skolem-const-decl "(/[T, +](R!1, fsA!1`seq(i!1)))" cartesian_product_quot_ring nil) (x!2 skolem-const-decl "(/[T, +](R!1, fsA!1`seq(i!1)))" cartesian_product_quot_ring nil) (fullset_quot_group_is_ring formula-decl nil quotient_rings nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (coset_add formula-decl nil quotient_rings nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (quotient_group_is_abelian_group formula-decl nil quotient_rings nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (i!1 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (inv const-decl "{y | x * y = one AND y * x = one}" group nil) (fullset const-decl "set" sets nil) (x!1 skolem-const-decl "(restrict
     [finseq[set[T]], (cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))), bool]
     (cartesian_product_n[set[T]](fsQ(R!1)(fsA!1))))" cartesian_product_quot_ring nil) (monoid? const-decl "bool" monoid_def nil) (associative? const-decl "bool" operator_defs nil) (emptyset const-decl "set" sets nil) (restrict const-decl "R" restrict nil) (member const-decl "bool" sets nil) (star_closed? const-decl "bool" groupoid_def nil) (TRUE const-decl "bool" booleans nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (setof type-eq-decl nil defined_types nil) (fsI type-eq-decl nil ring_ideal_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (zero formal-const-decl "T" cartesian_product_quot_ring nil) (* formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (+ formal-const-decl "[T, T -> T]" cartesian_product_quot_ring nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (finseq type-eq-decl nil finite_sequences nil) (set type-eq-decl nil sets nil) (T formal-nonempty-type-decl nil cartesian_product_quot_ring nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (coset type-eq-decl nil cosets_def nil) (add const-decl "set[T]" cosets_def nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (coset? const-decl "bool" cosets_def nil) (x!1 skolem-const-decl "(cartesian_product_n[set[T]](fsQ(R!1)(fsA!1)))" cartesian_product_quot_ring nil) (fsA!1 skolem-const-decl "fsI[T, +, *, zero](R!1)" cartesian_product_quot_ring nil) (R!1 skolem-const-decl "ring[T, +, *, zero]" cartesian_product_quot_ring nil) (/ const-decl "setof[set[T]]" cosets_def nil) (add_charac formula-decl nil quotient_rings nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (plus_zero formula-decl nil ring nil) (ideal type-eq-decl nil ring_ideal_def nil) (x!2 skolem-const-decl "below[length(fsA!1)]" cartesian_product_quot_ring nil) (ideal? const-decl "bool" ring_ideal_def nil) (left_coset? const-decl "bool" cosets_def nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (Sfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (x!2 skolem-const-decl "below[Sfs(R!1)(fsA!1)(fsA!1, x!1)`length]" cartesian_product_quot_ring nil) (zero_plus formula-decl nil ring nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (identity? const-decl "bool" operator_defs nil) (monad? const-decl "bool" monad_def nil)) shostak)))
