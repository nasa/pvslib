(chinese_remainder_theorem_Z (IMP_quotient_rings_with_one_TCC1 0 (IMP_quotient_rings_with_one_TCC1-1 nil 3797607478 ("" (expand "ring_with_one?") (("" (expand "ring?") (("" (split) (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (expand "monad?") (("1" (split) (("1" (expand "star_closed?") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) (("5" (expand "inv_exists?") (("5" (skosimp) (("5" (inst 1 "-x!1") (("5" (grind) nil nil)) nil)) nil)) nil)) nil) ("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "star_closed?") (("2" (grind) nil nil)) nil) ("3" (grind) nil nil) ("4" (expand "left_distributive?") (("4" (grind) nil nil)) nil) ("5" (expand "right_distributive?") (("5" (grind) nil nil)) nil) ("6" (expand "monoid?") (("6" (expand "monad?") (("6" (split) (("1" (expand "star_closed?") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ring? const-decl "bool" ring_def nil) (right_distributive? const-decl "bool" operator_defs_more nil) (left_distributive? const-decl "bool" operator_defs_more nil) (int_times_int_is_int application-judgement "int" integers nil) (abelian_group? const-decl "bool" group_def nil) (monoid? const-decl "bool" monoid_def nil) (fullset const-decl "set" sets nil) (member const-decl "bool" sets nil) (int_plus_int_is_int application-judgement "int" integers nil) (star_closed? const-decl "bool" groupoid_def nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (identity? const-decl "bool" operator_defs nil) (restrict const-decl "R" restrict nil) (associative? const-decl "bool" operator_defs nil) (inv_exists? const-decl "bool" group_def nil) (minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (commutative? const-decl "bool" operator_defs nil) (monad? const-decl "bool" monad_def nil) (group? const-decl "bool" group_def nil) (ring_with_one? const-decl "bool" ring_with_one_def nil)) nil (IMP_quotient_rings_with_one assuming "quotient_rings_with_one[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0, 1].quotient_rings_with_one" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[quotient_rings_with_one.T, quotient_rings_with_one.+, quotient_rings_with_one.*, quotient_rings_with_one.zero, quotient_rings_with_one.one].ring_with_one?(sets[quotient_rings_with_one.T].fullset)"))) (nZ_mZ_comaximal_TCC1 0 (nZ_mZ_comaximal_TCC1-1 nil 3797607478 ("" (subtype-tcc) nil nil) nil nil (nZ_mZ_comaximal subtype "chinese_remainder_theorem_Z.m" "{jj: integers.int | booleans.=>(chinese_remainder_theorem_Z.n = 0, jj /= 0)}"))) (nZ_mZ_comaximal 0 (nZ_mZ_comaximal-2 nil 3793215851 ("" (stop-rewrite "plus_zero" "zero_plus" "one_right" "one_left" "right_identity" "left_identity") (("" (skosimp) (("" (prop) (("1" (lemma "rel_prime_lem") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "comaximal_ideals_equiv") (("1" (inst?) (("1" (assert) (("1" (skosimp) (("1" (hide -4) (("1" (expand "nZ") (("1" (skosimp*) (("1" (replaces -1) (("1" (replaces -1) (("1" (inst 1 "k!2" "k!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (lemma "nZ_ideal") (("2" (inst?) nil nil)) nil)) nil) ("3" (hide (-1 2)) (("3" (lemma "nZ_ideal") (("3" (inst?) nil nil)) nil)) nil) ("4" (hide (-1 2)) (("4" (lemma "Z_commutative_ring_w_one") (("4" (expand "commutative_ring_with_one?") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "comaximal_ideals?") (("2" (expand "rel_prime") (("2" (split) (("1" (lemma "nZ_ideal") (("1" (inst?) nil nil)) nil) ("2" (lemma "nZ_ideal") (("2" (inst?) nil nil)) nil) ("3" (lemma "nZ_mZ_sum") (("3" (inst?) (("3" (replaces -2) (("3" (rewrite "Z1_is_Z") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((comaximal_ideals? const-decl "bool" comaximal_finseqs_ideals nil) (Z1_is_Z formula-decl nil ring_zn nil) (nZ_mZ_sum formula-decl nil ring_zn nil) (rel_prime const-decl "bool" gcd ints) (rel_prime_lem formula-decl nil gcd ints) (int_times_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (comaximal_ideals_equiv formula-decl nil comaximal_finseqs_ideals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (commutative_ring_with_one? const-decl "bool" ring_with_one_def nil) (Z_commutative_ring_w_one formula-decl nil ring_zn nil) (nZ_ideal formula-decl nil ring_zn nil) (member const-decl "bool" sets nil) (int_plus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (ideal type-eq-decl nil ring_ideal_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (m!1 skolem-const-decl "posnat" chinese_remainder_theorem_Z nil) (ideal? const-decl "bool" ring_ideal_def nil) (nZ const-decl "set[int]" ring_zn nil) (n!1 skolem-const-decl "posnat" chinese_remainder_theorem_Z nil) (Z const-decl "ring[int, restrict[[numfield, numfield], [int, int], numfield](+),
     restrict[[numfield, numfield], [int, int], numfield](*), 0]" ring_zn nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (set type-eq-decl nil sets nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil) (nZ_mZ_comaximal-1 nil 3784646736 ("" (stop-rewrite "plus_zero" "zero_plus" "one_right" "one_left" "right_identity" "left_identity") (("" (skosimp) (("" (prop) (("1" (lemma "rel_prime_lem") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (lemma "comaximal_ideals_equiv") (("1" (inst?) (("1" (assert) (("1" (skosimp) (("1" (hide -4) (("1" (expand "nZ") (("1" (skosimp*) (("1" (replaces -1) (("1" (replaces -1) (("1" (inst 1 "k!2" "k!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (lemma "nZ_ideal") (("2" (inst?) nil nil)) nil)) nil) ("3" (hide (-1 2)) (("3" (lemma "nZ_ideal") (("3" (inst?) nil nil)) nil)) nil) ("4" (hide (-1 2)) (("4" (lemma "Z_commutative_ring_w_one") (("4" (expand "commutative_ring_with_one?") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "comaximal_ideals?") (("2" (expand "rel_prime") (("2" (split) (("1" (lemma "nZ_ideal") (("1" (inst?) nil nil)) nil) ("2" (lemma "nZ_ideal") (("2" (inst?) nil nil)) nil) ("3" (lemma "nZ_mZ_sum") (("3" (inst?) (("3" (replaces -2) (("3" (rewrite "Z1_is_Z") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((comaximal_ideals? const-decl "bool" comaximal_finseqs_ideals nil) (rel_prime const-decl "bool" gcd ints) (rel_prime_lem formula-decl nil gcd ints) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (comaximal_ideals_equiv formula-decl nil comaximal_finseqs_ideals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (commutative_ring_with_one? const-decl "bool" ring_with_one_def nil) (member const-decl "bool" sets nil) (int_plus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (ideal type-eq-decl nil ring_ideal_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (ideal? const-decl "bool" ring_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (set type-eq-decl nil sets nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (Intersection_add_first 0 (Intersection_add_first-1 nil 3784545237 ("" (stop-rewrite "plus_zero" "zero_plus" "one_right" "one_left" "right_identity" "left_identity") (("" (skosimp) (("" (decompose-equality 1) (("" (iff) (("" (prop) (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Intersection") (("1" (split) (("1" (inst -1 "A!1") (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst 1 "0") (("1" (expand "add_first") (("1" (expand "insert?") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "add_first") (("2" (expand "insert?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "a!1") (("2" (expand "seq2set") (("2" (expand "finseq_appl") (("2" (skosimp) (("2" (inst -2 "a!1") (("2" (expand "seq2set") (("2" (expand "finseq_appl") (("2" (hide 2) (("2" (inst 1 "kk!1+1") (("1" (expand "add_first") (("1" (expand "insert?") (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "add_first") (("2" (expand "insert?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "intersection") (("2" (expand "member") (("2" (expand "Intersection") (("2" (flatten) (("2" (skosimp) (("2" (inst -2 "a!1") (("2" (typepred "a!1") (("2" (expand "seq2set") (("2" (skosimp) (("2" (expand "finseq_appl") (("2" (expand "add_first") (("2" (expand "insert?") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (expand "finseq_appl") (("2" (inst 2 "kk!1-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((kk!1 skolem-const-decl "below(length(add_first(A!1, fsS!1)))" chinese_remainder_theorem_Z nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (a!1 skolem-const-decl "(seq2set(add_first(A!1, fsS!1)))" chinese_remainder_theorem_Z nil) (kk!1 skolem-const-decl "below(length(fsS!1))" chinese_remainder_theorem_Z nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (a!1 skolem-const-decl "(seq2set(fsS!1))" chinese_remainder_theorem_Z nil) (NOT const-decl "[bool -> bool]" booleans nil) (A!1 skolem-const-decl "setof[int]" chinese_remainder_theorem_Z nil) (fsS!1 skolem-const-decl "finseq[setof[int]]" chinese_remainder_theorem_Z nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (insert? const-decl "finseq" seq_extras structures) (>= const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (bool nonempty-type-eq-decl nil booleans nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (set type-eq-decl nil sets nil) (Intersection const-decl "set" sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finite_sequence type-eq-decl nil finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (finseq type-eq-decl nil finite_sequences nil) (add_first const-decl "finseq" seq_extras structures) (intersection const-decl "set" sets nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (nZ_fs_intersection 0 (nZ_fs_intersection-2 nil 3797004004 ("" (expand "finseq_appl") (("" (measure-induct+ "length(fsn)" "fsn") (("" (case "length(x!1) = 1") (("1" (hide (-2 1)) (("1" (replace -1 1) (("1" (decompose-equality 1) (("1" (iff) (("1" (prop) (("1" (expand "Intersection") (("1" (expand "product") (("1" (expand "product_rec") (("1" (inst -1 "nZ(seq(x!1)(0))") (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst 1 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Intersection") (("2" (skosimp) (("2" (expand "product") (("2" (expand "product_rec") (("2" (typepred "a!1") (("2" (expand "seq2set") (("2" (skosimp) (("2" (expand "finseq_appl") (("2" (typepred "kk!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (name-replace "fsnZ!1" "(# length := length(x!1),
                                                                                                          seq
                                                                                                            := LAMBDA (i: below[length(x!1)]):
                                                                                                                 nZ(x!1`seq(i)) #)") (("2" (lemma "Intersection_add_first") (("2" (inst -1 "fsnZ!1(0)" "rest[set[int]](fsnZ!1)") (("1" (expand "finseq_appl") (("1" (lemma "seq_first_rest[set[int]]") (("1" (inst?) (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (prop) (("1" (replace -1 -2 rl) (("1" (replace -2 3) (("1" (hide (-1 -2)) (("1" (inst -1 "rest(x!1)") (("1" (prop) (("1" (case-replace "(# length := length(rest(x!1)),
                                                                                                                                                          seq
                                                                                                                                                            := LAMBDA (i: below[length(rest(x!1))]):
                                                                                                                                                                 nZ(rest(x!1)`seq(i)) #) = rest[set[int]](fsnZ!1)" :hide? T) (("1" (replaces -1) (("1" (expand "fsnZ!1") (("1" (lemma "nZ_mZ_rel_prime_intersection") (("1" (inst?) (("1" (prop) (("1" (replaces -1) (("1" (hide -1) (("1" (lemma "seq_first_rest_1[posnat]") (("1" (inst?) (("1" (assert) (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (name-replace "Temp!1" "nZ(x!1`seq(0) * product(rest(x!1)))") (("1" (replace -1 3) (("1" (expand "Temp!1") (("1" (lemma "product_mult") (("1" (inst -1 "#(x!1`seq(0))" "rest(x!1)") (("1" (expand "product" -1 2) (("1" (lift-if) (("1" (prop) (("1" (hide (-2 -3 +)) (("1" (expand "#") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "product_rec") (("2" (lift-if) (("2" (prop) (("1" (expand "#" -2 2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "#") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "fs_rel_prime?") (("2" (lemma "fs_rel_prime_i") (("2" (inst?) (("2" (expand "finseq_appl") (("2" (inst -1 "0") (("2" (prop) (("1" (hide -2) (("1" (lemma "delete_rest[posnat]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "fs_rel_prime?") (("2" (expand "finseq_appl") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 4)) (("2" (expand "fsnZ!1") (("2" (decompose-equality 1) (("1" (expand "rest") (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand "rest") (("2" (expand "^") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (- 4)) (("3" (skosimp) (("3" (expand "fsnZ!1") (("3" (prop) (("1" (expand "rest") (("1" (assert) (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "rest") (("2" (assert) (("2" (expand "^") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 3)) (("2" (expand "rest") (("2" (expand "^") (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 4) (("3" (expand "fs_rel_prime?") (("3" (expand "finseq_appl") (("3" (skosimp) (("3" (expand "rest") (("3" (lift-if) (("3" (prop) (("3" (expand "^") (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (inst?) (("3" (prop) (("3" (hide 3) (("3" (rewrite "both_sides_plus2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide (- 4)) (("4" (expand "rest") (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -3 -4 3)) (("2" (expand "fsnZ!1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 4)) (("2" (expand "fsnZ!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (finseq type-eq-decl nil finite_sequences nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (fs_rel_prime? const-decl "bool" prop_primes_extra nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (Intersection const-decl "set" sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (nZ const-decl "set[int]" ring_zn nil) (product const-decl "posnat" product_seq reals) (fsnZ!1 skolem-const-decl "[# length: nat, seq: [below[length(x!1)] -> set[int]] #]" chinese_remainder_theorem_Z nil) (rest const-decl "finseq" seq_extras structures) (seq_first_rest formula-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (both_sides_plus2 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (fs_rel_prime_i formula-decl nil prop_primes_extra nil) (delete_rest formula-decl nil seq_extras structures) (seq_first_rest_1 formula-decl nil seq_extras structures) (posint_times_posint_is_posint application-judgement "posint" integers nil) (product_mult formula-decl nil product_seq reals) (int_minus_int_is_int application-judgement "int" integers nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (Temp!1 skolem-const-decl "set[int]" chinese_remainder_theorem_Z nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nZ_mZ_rel_prime_intersection formula-decl nil ring_zn nil) (TRUE const-decl "bool" booleans nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (Intersection_add_first formula-decl nil chinese_remainder_theorem_Z nil) (x!1 skolem-const-decl "finseq[posnat]" chinese_remainder_theorem_Z nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (nil application-judgement "(nonempty?[T])" seq2set structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (below type-eq-decl nil naturalnumbers nil) (product_rec def-decl "posnat" product_seq_scaf reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil) (nZ_fs_intersection-1 nil 3784488652 ("" (expand "finseq_appl") (("" (measure-induct+ "length(fsn)" "fsn") (("" (case "length(x!1) = 1") (("1" (hide (-2 1)) (("1" (replace -1 1) (("1" (decompose-equality 1) (("1" (iff) (("1" (prop) (("1" (expand "Intersection") (("1" (expand "product") (("1" (expand "product_rec") (("1" (inst -1 "nZ(seq(x!1)(0))") (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst 1 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Intersection") (("2" (skosimp) (("2" (expand "product") (("2" (expand "product_rec") (("2" (typepred "a!1") (("2" (expand "seq2set") (("2" (skosimp) (("2" (expand "finseq_appl") (("2" (typepred "kk!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (name-replace "fsnZ!1" "(# length := length(x!1),
                                                                                                      seq
                                                                                                        := LAMBDA (i: below[length(x!1)]):
                                                                                                             nZ(x!1`seq(i)) #)") (("2" (lemma "Intersection_add_first") (("2" (inst -1 "fsnZ!1(0)" "rest[set[int]](fsnZ!1)") (("1" (expand "finseq_appl") (("1" (lemma "seq_first_rest[set[int]]") (("1" (inst?) (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (prop) (("1" (replace -1 -2 rl) (("1" (replace -2 3) (("1" (hide (-1 -2)) (("1" (inst -1 "rest(x!1)") (("1" (prop) (("1" (case-replace "(# length := length(rest(x!1)),
                                                                                                                                                seq
                                                                                                                                                  := LAMBDA (i: below[length(rest(x!1))]):
                                                                                                                                                       nZ(rest(x!1)`seq(i)) #) = rest[set[int]](fsnZ!1)" :hide? T) (("1" (replaces -1) (("1" (expand "fsnZ!1") (("1" (lemma "nZ_mZ_rel_prime_intersection") (("1" (inst?) (("1" (prop) (("1" (replaces -1) (("1" (hide -1) (("1" (lemma "seq_first_rest_1[posnat]") (("1" (inst?) (("1" (assert) (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (name-replace "Temp!1" "nZ(x!1`seq(0) * product(rest(x!1)))") (("1" (replace -1 3) (("1" (expand "Temp!1") (("1" (lemma "product_mult") (("1" (inst -1 "#(x!1`seq(0))" "rest(x!1)") (("1" (expand "product" -1 2) (("1" (lift-if) (("1" (prop) (("1" (hide (-2 -3 +)) (("1" (expand "#") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "product_rec") (("2" (lift-if) (("2" (prop) (("1" (expand "#" -2 2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "#") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "fs_rel_primes") (("2" (lemma "fs_rel_prime_i") (("2" (inst?) (("2" (expand "finseq_appl") (("2" (inst -1 "0") (("2" (prop) (("1" (hide -2) (("1" (lemma "delete_rest[posnat]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "fs_rel_prime?") (("2" (expand "finseq_appl") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 4)) (("2" (expand "fsnZ!1") (("2" (decompose-equality 1) (("1" (expand "rest") (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand "rest") (("2" (expand "^") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (- 4)) (("3" (skosimp) (("3" (expand "fsnZ!1") (("3" (prop) (("1" (expand "rest") (("1" (assert) (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "rest") (("2" (assert) (("2" (expand "^") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 3)) (("2" (expand "rest") (("2" (expand "^") (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 4) (("3" (expand "fs_rel_primes") (("3" (expand "finseq_appl") (("3" (skosimp) (("3" (expand "rest") (("3" (lift-if) (("3" (prop) (("3" (expand "^") (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (inst?) (("3" (prop) (("3" (hide 3) (("3" (rewrite "both_sides_plus2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide (- 4)) (("4" (expand "rest") (("4" (expand "^") (("4" (expand "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -3 -4 3)) (("2" (expand "fsnZ!1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (- 4)) (("2" (expand "fsnZ!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (finseq type-eq-decl nil finite_sequences nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (Intersection const-decl "set" sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (product const-decl "posnat" product_seq reals) (rest const-decl "finseq" seq_extras structures) (seq_first_rest formula-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (both_sides_plus2 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (fs_rel_prime_i formula-decl nil prop_primes_extra nil) (delete_rest formula-decl nil seq_extras structures) (fs_rel_prime? const-decl "bool" prop_primes_extra nil) (seq_first_rest_1 formula-decl nil seq_extras structures) (posint_times_posint_is_posint application-judgement "posint" integers nil) (product_mult formula-decl nil product_seq reals) (int_minus_int_is_int application-judgement "int" integers nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (TRUE const-decl "bool" booleans nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (Intersection_add_first formula-decl nil chinese_remainder_theorem_Z nil) (nil application-judgement "(nonempty?[T])" seq2set structures) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (product_rec def-decl "posnat" product_seq_scaf reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak)) (Chinese_Remainder_Theorem_for_int_TCC1 0 (Chinese_Remainder_Theorem_for_int_TCC1-2 nil 3794182078 ("" (skosimp) (("" (expand "fsRI?") (("" (skosimp) (("" (expand "finseq_appl") (("" (expand "fsnZ") (("" (expand "finseq_appl") (("" (lemma "nZ_ideal") (("" (inst?) nil)))))))))))))) nil) ((fsRI? const-decl "bool" ring_ideal_def nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (set type-eq-decl nil sets nil) (< const-decl "bool" reals nil) (fs_rel_prime? const-decl "bool" prop_primes_extra nil) (/= const-decl "boolean" notequal nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nZ_ideal formula-decl nil ring_zn nil) (fsnZ const-decl "finseq[set[int]]" ring_zn nil)) nil (Chinese_Remainder_Theorem_for_int subtype "ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn)" "fsI[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0](ring_zn.Z)")) (Chinese_Remainder_Theorem_for_int_TCC1-1 nil 3784745094 ("" (skosimp) (("" (expand "fsRI?") (("" (skosimp) (("" (expand "finseq_appl") (("" (expand "fsnZ") (("" (expand "finseq_appl") (("" (lemma "nZ_ideal") (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (set type-eq-decl nil sets nil) (< const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (Chinese_Remainder_Theorem_for_int subtype "ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn)" "fsI[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0](ring_zn.Z)"))) (Chinese_Remainder_Theorem_for_int_TCC2 0 (Chinese_Remainder_Theorem_for_int_TCC3-1 nil 3784745094 ("" (skosimp) (("" (inst 1 "nZ(product(fspn!1))") (("" (lemma "ideal_is_coset") (("" (inst?) (("" (hide 2) (("" (lemma "nZ_ideal") (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (coset? const-decl "bool" cosets_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (Z const-decl "ring[int, restrict[[numfield, numfield], [int, int], numfield](+),
     restrict[[numfield, numfield], [int, int], numfield](*), 0]" ring_zn nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nZ const-decl "set[int]" ring_zn nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finite_sequence type-eq-decl nil finite_sequences nil) (product const-decl "posnat" product_seq reals) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (fs_rel_prime? const-decl "bool" prop_primes_extra nil) (coset type-eq-decl nil cosets_def nil) (fspn!1 skolem-const-decl "{fspn: finseq[posnat] | length(fspn) /= 0 AND fs_rel_prime?(fspn)}" chinese_remainder_theorem_Z nil) (ideal type-eq-decl nil ring_ideal_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (nZ_ideal formula-decl nil ring_zn nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil)) nil (Chinese_Remainder_Theorem_for_int existence "" "coset[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+)](ring_zn.Z, ring_zn.nZ(product_seq.product(chinese_remainder_theorem_Z.fspn)))"))) (Chinese_Remainder_Theorem_for_int_TCC3 0 (Chinese_Remainder_Theorem_for_int_TCC2-1 nil 3784745094 ("" (skosimp*) (("" (lemma "coset_add") (("" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "nZ_ideal") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ((* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (coset_add formula-decl nil quotient_rings nil) (nZ_ideal formula-decl nil ring_zn nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nZ const-decl "set[int]" ring_zn nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finite_sequence type-eq-decl nil finite_sequences nil) (product const-decl "posnat" product_seq reals) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (fs_rel_prime? const-decl "bool" prop_primes_extra nil) (fspn!1 skolem-const-decl "{fspn: finseq[posnat] | length(fspn) /= 0 AND fs_rel_prime?(fspn)}" chinese_remainder_theorem_Z nil) (ring nonempty-type-eq-decl nil ring nil) (Z const-decl "ring[int, restrict[[numfield, numfield], [int, int], numfield](+),
     restrict[[numfield, numfield], [int, int], numfield](*), 0]" ring_zn nil)) nil (Chinese_Remainder_Theorem_for_int subtype "cosets_def[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+)].add(ring_zn.Z, ring_zn.nZ(product_seq.product(chinese_remainder_theorem_Z.fspn)))" "[[coset[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+)](ring_zn.Z, ring_zn.nZ(product_seq.product(chinese_remainder_theorem_Z.fspn))), coset[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+)](ring_zn.Z, ring_zn.nZ(product_seq.product(chinese_remainder_theorem_Z.fspn)))] -> coset[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+)](ring_zn.Z, ring_zn.nZ(product_seq.product(chinese_remainder_theorem_Z.fspn)))]"))) (Chinese_Remainder_Theorem_for_int_TCC4 0 (Chinese_Remainder_Theorem_for_int_TCC5-1 nil 3784745094 ("" (skosimp*) (("" (lemma "coset_product") (("" (inst?) (("1" (inst -1 "x1!1`1" "x1!1`2") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "nZ_ideal") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ((* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (coset_product formula-decl nil quotient_rings nil) (nZ_ideal formula-decl nil ring_zn nil) (coset type-eq-decl nil cosets_def nil) (coset? const-decl "bool" cosets_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ideal? const-decl "bool" ring_ideal_def nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nZ const-decl "set[int]" ring_zn nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finite_sequence type-eq-decl nil finite_sequences nil) (product const-decl "posnat" product_seq reals) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (fs_rel_prime? const-decl "bool" prop_primes_extra nil) (fspn!1 skolem-const-decl "{fspn: finseq[posnat] | length(fspn) /= 0 AND fs_rel_prime?(fspn)}" chinese_remainder_theorem_Z nil) (ring nonempty-type-eq-decl nil ring nil) (Z const-decl "ring[int, restrict[[numfield, numfield], [int, int], numfield](+),
     restrict[[numfield, numfield], [int, int], numfield](*), 0]" ring_zn nil)) nil (Chinese_Remainder_Theorem_for_int subtype "product_coset_def[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*)].product(ring_zn.Z, ring_zn.nZ(product_seq.product(chinese_remainder_theorem_Z.fspn)))" "[[coset[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+)](ring_zn.Z, ring_zn.nZ(product_seq.product(chinese_remainder_theorem_Z.fspn))), coset[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+)](ring_zn.Z, ring_zn.nZ(product_seq.product(chinese_remainder_theorem_Z.fspn)))] -> coset[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+)](ring_zn.Z, ring_zn.nZ(product_seq.product(chinese_remainder_theorem_Z.fspn)))]"))) (Chinese_Remainder_Theorem_for_int_TCC5 0 (Chinese_Remainder_Theorem_for_int_TCC6-1 nil 3784745094 ("" (skosimp) (("" (expand "coset?") (("" (prop) (("1" (expand "left_coset?") (("1" (inst 1 "0") (("1" (assert) (("1" (rewrite "left_zero") nil nil)) nil) ("2" (expand "Z") (("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "right_coset?") (("2" (inst 1 "0") (("1" (assert) (("1" (rewrite "right_zero") nil nil)) nil) ("2" (expand "Z") (("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((coset? const-decl "bool" cosets_def nil) (right_coset? const-decl "bool" cosets_def nil) (right_zero formula-decl nil ring_cosets_lemmas nil) (left_coset? const-decl "bool" cosets_def nil) (fullset const-decl "set" sets nil) (fs_rel_prime? const-decl "bool" prop_primes_extra nil) (/= const-decl "boolean" notequal nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (product const-decl "posnat" product_seq reals) (finite_sequence type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nZ const-decl "set[int]" ring_zn nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (left_zero formula-decl nil ring_cosets_lemmas nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (Z const-decl "ring[int, restrict[[numfield, numfield], [int, int], numfield](+),
     restrict[[numfield, numfield], [int, int], numfield](*), 0]" ring_zn nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (Chinese_Remainder_Theorem_for_int subtype "ring_zn.nZ(product_seq.product(chinese_remainder_theorem_Z.fspn))" "coset[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+)](ring_zn.Z, ring_zn.nZ(product_seq.product(chinese_remainder_theorem_Z.fspn)))"))) (Chinese_Remainder_Theorem_for_int_TCC6 0 (Chinese_Remainder_Theorem_for_int_TCC7-1 nil 3784745094 ("" (skosimp) (("" (inst 1 "fsnZ(fspn!1)") (("" (expand "fsnZ") (("" (expand "cartesian_product_n") (("" (expand "finseq_appl") (("" (expand "member") (("" (prop) (("1" (expand "fsQ") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (expand "fsQ") (("2" (propax) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (rewrite "ideal_is_coset") (("3" (hide 2) (("3" (lemma "nZ_ideal") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (Z const-decl "ring[int, restrict[[numfield, numfield], [int, int], numfield](+),
     restrict[[numfield, numfield], [int, int], numfield](*), 0]" ring_zn nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (fsnZ const-decl "finseq[set[int]]" ring_zn nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (fs_rel_prime? const-decl "bool" prop_primes_extra nil) (fspn!1 skolem-const-decl "{fspn: finseq[posnat] | length(fspn) /= 0 AND fs_rel_prime?(fspn)}" chinese_remainder_theorem_Z nil) (member const-decl "bool" sets nil) (/ const-decl "setof[set[T]]" cosets_def nil) (nZ_ideal formula-decl nil ring_zn nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (nZ const-decl "set[int]" ring_zn nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (Chinese_Remainder_Theorem_for_int existence "" "(cartesian_product_finite[set[int]].cartesian_product_n(cartesian_product_quot_ring[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].fsQ(ring_zn.Z)(ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn))))"))) (Chinese_Remainder_Theorem_for_int_TCC7 0 (Chinese_Remainder_Theorem_for_int_TCC8-2 nil 3794182316 ("" (skosimp*) (("" (expand "fsnZ") (("" (expand "cartesian_product_n") (("" (expand "finseq_appl") (("" (expand "member") (("" (assert) (("" (prop) (("1" (expand "fsQ") (("1" (assert) nil nil)) nil) ("2" (expand "fsQ") (("2" (expand "Sfs") (("2" (propax) nil nil)) nil)) nil) ("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "Sfs") (("3" (expand "finseq_appl") (("3" (rewrite "coset_add") (("3" (hide (2 3)) (("3" (lemma "nZ_ideal") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((fsnZ const-decl "finseq[set[int]]" ring_zn nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (coset_add formula-decl nil quotient_rings nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (Z const-decl "ring[int, restrict[[numfield, numfield], [int, int], numfield](+),
     restrict[[numfield, numfield], [int, int], numfield](*), 0]" ring_zn nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nZ const-decl "set[int]" ring_zn nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (fs_rel_prime? const-decl "bool" prop_primes_extra nil) (< const-decl "bool" reals nil) (fsI type-eq-decl nil ring_ideal_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nZ_ideal formula-decl nil ring_zn nil) (/ const-decl "setof[set[T]]" cosets_def nil) (Sfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (member const-decl "bool" sets nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil)) nil (Chinese_Remainder_Theorem_for_int subtype "cartesian_product_quot_ring[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].Sfs(ring_zn.Z)(ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn))" "[[(cartesian_product_finite[set[int]].cartesian_product_n(cartesian_product_quot_ring[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].fsQ(ring_zn.Z)(ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn)))), (cartesian_product_finite[set[int]].cartesian_product_n(cartesian_product_quot_ring[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].fsQ(ring_zn.Z)(ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn))))] -> (cartesian_product_finite[set[int]].cartesian_product_n(cartesian_product_quot_ring[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].fsQ(ring_zn.Z)(ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn))))]")) (Chinese_Remainder_Theorem_for_int_TCC8-1 nil 3784745094 ("" (skosimp) (("" (inst 1 "nZ(product(fspn!1))") (("" (lemma "Chinese_Remainder_Theorem_for_int_TCC4") (("" (inst?) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (coset? const-decl "bool" cosets_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finite_sequence type-eq-decl nil finite_sequences nil) (product const-decl "posnat" product_seq reals) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (coset type-eq-decl nil cosets_def nil) (Chinese_Remainder_Theorem_for_int_TCC4 subtype-tcc nil chinese_remainder_theorem_Z nil)) nil (Chinese_Remainder_Theorem_for_int subtype "cartesian_product_quot_ring[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].Sfs(ring_zn.Z)(ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn))" "[[(cartesian_product_finite[set[int]].cartesian_product_n(cartesian_product_quot_ring[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].fsQ(ring_zn.Z)(ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn)))), (cartesian_product_finite[set[int]].cartesian_product_n(cartesian_product_quot_ring[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].fsQ(ring_zn.Z)(ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn))))] -> (cartesian_product_finite[set[int]].cartesian_product_n(cartesian_product_quot_ring[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].fsQ(ring_zn.Z)(ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn))))]"))) (Chinese_Remainder_Theorem_for_int_TCC8 0 (Chinese_Remainder_Theorem_for_int_TCC9-1 nil 3784745094 ("" (skosimp*) (("" (expand "fsnZ") (("" (expand "cartesian_product_n") (("" (expand "finseq_appl") (("" (expand "member") (("" (assert) (("" (prop) (("1" (expand "fsQ") (("1" (assert) nil nil)) nil) ("2" (expand "fsQ") (("2" (expand "Pfs") (("2" (propax) nil nil)) nil)) nil) ("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (expand "Pfs") (("3" (expand "finseq_appl") (("3" (rewrite "coset_product") (("3" (hide (2 3)) (("3" (lemma "nZ_ideal") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((fsnZ const-decl "finseq[set[int]]" ring_zn nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (coset_product formula-decl nil quotient_rings nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (Z const-decl "ring[int, restrict[[numfield, numfield], [int, int], numfield](+),
     restrict[[numfield, numfield], [int, int], numfield](*), 0]" ring_zn nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nZ const-decl "set[int]" ring_zn nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (fs_rel_prime? const-decl "bool" prop_primes_extra nil) (< const-decl "bool" reals nil) (fsI type-eq-decl nil ring_ideal_def nil) (fsRI? const-decl "bool" ring_ideal_def nil) (setof type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nZ_ideal formula-decl nil ring_zn nil) (/ const-decl "setof[set[T]]" cosets_def nil) (Pfs const-decl "finseq[set[T]]" cartesian_product_quot_ring nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (member const-decl "bool" sets nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil)) nil (Chinese_Remainder_Theorem_for_int subtype "cartesian_product_quot_ring[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].Pfs(ring_zn.Z)(ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn))" "[[(cartesian_product_finite[set[int]].cartesian_product_n(cartesian_product_quot_ring[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].fsQ(ring_zn.Z)(ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn)))), (cartesian_product_finite[set[int]].cartesian_product_n(cartesian_product_quot_ring[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].fsQ(ring_zn.Z)(ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn))))] -> (cartesian_product_finite[set[int]].cartesian_product_n(cartesian_product_quot_ring[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].fsQ(ring_zn.Z)(ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn))))]"))) (Chinese_Remainder_Theorem_for_int_TCC9 0 (Chinese_Remainder_Theorem_for_int_TCC10-1 nil 3794168216 ("" (skosimp) (("" (expand "fsnZ") (("" (expand "cartesian_product_n") (("" (expand "finseq_appl") (("" (expand "member") (("" (prop) (("1" (expand "fsQ") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (expand "fsQ") (("2" (propax) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp) (("3" (expand "fsQ") (("3" (expand "finseq_appl") (("3" (expand "/") (("3" (rewrite "ideal_is_coset") (("3" (hide 2) (("3" (lemma "nZ_ideal") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((fsnZ const-decl "finseq[set[int]]" ring_zn nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (ring? const-decl "bool" ring_def nil) (ring nonempty-type-eq-decl nil ring nil) (Z const-decl "ring[int, restrict[[numfield, numfield], [int, int], numfield](+),
     restrict[[numfield, numfield], [int, int], numfield](*), 0]" ring_zn nil) (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nZ const-decl "set[int]" ring_zn nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (fs_rel_prime? const-decl "bool" prop_primes_extra nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nZ_ideal formula-decl nil ring_zn nil) (/ const-decl "setof[set[T]]" cosets_def nil) (member const-decl "bool" sets nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil)) nil (Chinese_Remainder_Theorem_for_int subtype "ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn)" "(cartesian_product_finite[set[int]].cartesian_product_n(cartesian_product_quot_ring[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].fsQ(ring_zn.Z)(ring_zn.fsnZ(chinese_remainder_theorem_Z.fspn))))"))) (Chinese_Remainder_Theorem_for_int 0 (Chinese_Remainder_Theorem_for_int-4 "" 3883063593 ("" (skosimp*) (("" (lemma "nZ_fs_intersection") (("" (inst?) (("" (prop) (("1" (skoletin* -1) (("1" (hide -2) (("1" (replace -1 1 rl) (("1" (lemma "Chinese_Remainder_Theorem") (("1" (inst?) (("1" (expand "R_isomorphic?") (("1" (skosimp) (("1" (inst?) (("1" (assert) (("1" (expand "R_isomorphism?") (("1" (flatten) (("1" (prop) (("1" (hide -2) (("1" (expand "R_monomorphism?") (("1" (prop) (("1" (hide -2) (("1" (expand "injective?") (("1" (skosimp) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "R_homomorphism?") (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (expand "member") (("1" (expand "restrict") (("1" (inst -1 "x!1" "y!1") (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide (-1 2)) (("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide (-1 2)) (("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (expand "restrict") (("3" (expand "star_closed?") (("3" (skosimp) (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-3 1)) (("4" (expand "star_closed?") (("4" (expand "restrict") (("4" (skosimp) (("4" (expand "member") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "restrict") (("5" (expand "homomorphism?") (("5" (replace -7) (("5" (hide-all-but (-5 1)) (("5" (expand "fsnZ") (("5" (expand "fsnZ_1") (("5" (assert) (("5" (skeep) (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "restrict") (("6" (replace -7) (("6" (hide-all-but (-5 -6 -7 1)) (("6" (expand "homomorphism?") (("6" (skeep) (("6" (replace -3) (("6" (inst? -2) (("6" (expand "fsnZ") (("6" (expand "fsnZ_1") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (hide -1) (("2" (expand "R_epimorphism?") (("2" (flatten) (("2" (prop) (("1" (hide (-2 -3)) (("1" (assert) (("1" (expand "surjective?") (("1" (skosimp) (("1" (inst?) (("1" (skosimp) (("1" (inst?) nil nil)) nil) ("2" (typepred "y!1") (("2" (hide 2) (("2" (expand "fsnZ_1") (("2" (expand "fsnZ") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "R_homomorphism?") (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (expand "member") (("1" (inst -1 "x!1" "y!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (inst -1 "x!1" "y!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (expand "star_closed?") (("3" (skosimp) (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand "star_closed?") (("4" (skosimp) (("4" (expand "member") (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-5 -7 1)) (("5" (expand "homomorphism?") (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (replaces -2 -1) (("5" (expand "fsnZ") (("5" (expand "fsnZ_1") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-6 -7 1)) (("6" (expand "homomorphism?") (("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (replaces -2 -1) (("6" (expand "fsnZ") (("6" (expand "fsnZ_1") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (hide -1) (("2" (split) (("1" (skosimp) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "phi!1(x1!1)") (("2" (hide -2) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (hide 2) (("2" (split) (("1" (expand "fsICM?") (("1" (split) (("1" (expand "fsRI?") (("1" (skosimp) (("1" (expand "finseq_appl") (("1" (expand "fsnZ_1" 1) (("1" (expand "finseq_appl") (("1" (lemma "nZ_ideal") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "finseq_appl") (("2" (expand "fsnZ_1" 2) (("2" (expand "finseq_appl") (("2" (lemma "nZ_mZ_comaximal") (("2" (inst?) (("2" (assert) (("2" (hide 3) (("2" (typepred "fspn!1") (("2" (expand "fs_rel_prime?") (("2" (expand "finseq_appl") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "fspn!1") (("2" (hide (-2 -3)) (("2" (expand "fsnZ_1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "restrict") (("3" (hide 2) (("3" (lemma "Z_commutative_ring_w_one") (("3" (expand "commutative_ring_with_one?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (typepred "fspn!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "fspn!1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (Chinese_Remainder_Theorem_for_int-3 nil 3797004118 ("" (skosimp*) (("" (lemma "nZ_fs_intersection") (("" (inst?) (("" (prop) (("1" (skoletin* -1) (("1" (hide -2) (("1" (replace -1 1 rl) (("1" (lemma "Chinese_Remainder_Theorem") (("1" (inst?) (("1" (expand "R_isomorphic?") (("1" (skosimp) (("1" (inst?) (("1" (assert) (("1" (expand "R_isomorphism?") (("1" (flatten) (("1" (prop) (("1" (hide -2) (("1" (expand "R_monomorphism?") (("1" (prop) (("1" (hide -2) (("1" (expand "injective?") (("1" (skosimp) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "R_homomorphism?") (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (expand "member") (("1" (expand "restrict") (("1" (inst -1 "x!1" "y!1") (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide (-1 2)) (("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide (-1 2)) (("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (expand "star_closed?") (("3" (skosimp) (("3" (expand "member") (("3" (inst -1 "x!1" "y!1") (("1" (expand "fsnZ_1") (("1" (expand "fsnZ") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "y!1") (("2" (hide 2) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide 2) (("3" (expand "fsnZ") (("3" (expand "fsnZ_1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand "star_closed?") (("4" (skosimp) (("4" (expand "member") (("4" (inst -1 "x!1" "y!1") (("1" (expand "fsnZ_1") (("1" (expand "fsnZ") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "y!1") (("2" (hide 2) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide 2) (("3" (expand "fsnZ") (("3" (expand "fsnZ_1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-5 -7 1)) (("5" (expand "homomorphism?") (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (expand "fsnZ") (("5" (expand "fsnZ_1") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-6 -7 1)) (("6" (expand "homomorphism?") (("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (expand "fsnZ") (("6" (expand "fsnZ_1") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "R_epimorphism?") (("2" (flatten) (("2" (prop) (("1" (hide (-2 -3)) (("1" (assert) (("1" (expand "surjective?") (("1" (skosimp) (("1" (inst?) (("1" (skosimp) (("1" (inst?) (("1" (expand "restrict") (("1" (expand "/") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "y!1") (("2" (hide 2) (("2" (expand "fsnZ_1") (("2" (expand "fsnZ") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "R_homomorphism?") (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (expand "member") (("1" (expand "restrict") (("1" (inst -1 "x!1" "y!1") (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide (-1 2)) (("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide (-1 2)) (("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (expand "star_closed?") (("3" (skosimp) (("3" (expand "member") (("3" (inst -1 "x!1" "y!1") (("1" (expand "fsnZ_1") (("1" (expand "fsnZ") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "y!1") (("2" (hide 2) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide 2) (("3" (expand "fsnZ") (("3" (expand "fsnZ_1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand "star_closed?") (("4" (skosimp) (("4" (expand "member") (("4" (inst -1 "x!1" "y!1") (("1" (expand "fsnZ_1") (("1" (expand "fsnZ") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "y!1") (("2" (hide 2) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide 2) (("3" (expand "fsnZ") (("3" (expand "fsnZ_1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-5 -7 1)) (("5" (expand "homomorphism?") (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (replaces -2 -1) (("5" (expand "fsnZ") (("5" (expand "fsnZ_1") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-6 -7 1)) (("6" (expand "homomorphism?") (("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (replaces -2 -1) (("6" (expand "fsnZ") (("6" (expand "fsnZ_1") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "restrict") (("2" (split) (("1" (skosimp) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "phi!1(x1!1)") (("2" (hide -2) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split) (("1" (expand "fsICM?") (("1" (split) (("1" (expand "fsRI?") (("1" (skosimp) (("1" (expand "finseq_appl") (("1" (expand "fsnZ_1" 1) (("1" (expand "finseq_appl") (("1" (lemma "nZ_ideal") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "finseq_appl") (("2" (expand "fsnZ_1" 2) (("2" (expand "finseq_appl") (("2" (lemma "nZ_mZ_comaximal") (("2" (inst?) (("2" (assert) (("2" (hide 3) (("2" (typepred "fspn!1") (("2" (expand "fs_rel_prime?") (("2" (expand "finseq_appl") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "fspn!1") (("2" (hide (-2 -3)) (("2" (expand "fsnZ_1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "Z_commutative_ring_w_one") (("3" (expand "commutative_ring_with_one?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (typepred "fspn!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "fspn!1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nZ_fs_intersection formula-decl nil chinese_remainder_theorem_Z nil) (Chinese_Remainder_Theorem formula-decl nil chinese_remainder_theorem_rings nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (Z_commutative_ring_w_one formula-decl nil ring_zn nil) (commutative_ring_with_one? const-decl "bool" ring_with_one_def nil) (nZ_ideal formula-decl nil ring_zn nil) (nZ_mZ_comaximal formula-decl nil chinese_remainder_theorem_Z nil) (R_isomorphic? const-decl "bool" ring_homomorphisms_def nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) (/ const-decl "setof[set[T]]" cosets_def nil) (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (fsRI? const-decl "bool" ring_ideal_def nil) (fsI type-eq-decl nil ring_ideal_def nil) (fsQ const-decl "finseq[setof[set[T]]]" cartesian_product_quot_ring nil) (fsnZ const-decl "finseq[set[int]]" ring_zn nil) (phi!1 skolem-const-decl "[(restrict
      [set[int],
       coset[int,
             restrict[[numfield, numfield], [int, int], numfield](+)](Z,
                                                                      Intersection
                                                                      (seq2set
                                                                       (fsnZ_1))),
       bool]
      (Z / Intersection(seq2set(fsnZ_1)))) ->
   (restrict
        [finseq[set[int]], (cartesian_product_n[set[int]](fsQ(Z)(fsnZ_1))),
         bool]
        ((cartesian_product_n[set[int]](fsQ(Z)(fsnZ_1)))))]" chinese_remainder_theorem_Z nil) (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil) (star_closed? const-decl "bool" groupoid_def nil) (member const-decl "bool" sets nil) (x!1 skolem-const-decl "(restrict
     [set[int],
      coset[int,
            restrict[[numfield, numfield], [int, int], numfield](+)](Z,
                                                                     nZ
                                                                     (product
                                                                      (fspn!1))),
      bool]
     (Z / Intersection(seq2set(fsnZ_1))))" chinese_remainder_theorem_Z nil) (y!1 skolem-const-decl "(restrict
     [set[int],
      coset[int,
            restrict[[numfield, numfield], [int, int], numfield](+)](Z,
                                                                     nZ
                                                                     (product
                                                                      (fspn!1))),
      bool]
     (Z / Intersection(seq2set(fsnZ_1))))" chinese_remainder_theorem_Z nil) (NOT const-decl "[bool -> bool]" booleans nil) (x!1 skolem-const-decl "(restrict
     [set[int],
      coset[int,
            restrict[[numfield, numfield], [int, int], numfield](+)](Z,
                                                                     nZ
                                                                     (product
                                                                      (fspn!1))),
      bool]
     (Z / Intersection(seq2set(fsnZ_1))))" chinese_remainder_theorem_Z nil) (y!1 skolem-const-decl "(restrict
     [set[int],
      coset[int,
            restrict[[numfield, numfield], [int, int], numfield](+)](Z,
                                                                     nZ
                                                                     (product
                                                                      (fspn!1))),
      bool]
     (Z / Intersection(seq2set(fsnZ_1))))" chinese_remainder_theorem_Z nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (y!1 skolem-const-decl "(cartesian_product_n[set[int]](fsQ(Z)(fsnZ(fspn!1))))" chinese_remainder_theorem_Z nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (fsnZ_1 skolem-const-decl "[# length: nat, seq: [below[length(fspn!1)] -> set[int]] #]" chinese_remainder_theorem_Z nil) (fspn!1 skolem-const-decl "{fspn: finseq[posnat] | length(fspn) /= 0 AND fs_rel_prime?(fspn)}" chinese_remainder_theorem_Z nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (Z const-decl "ring[int, restrict[[numfield, numfield], [int, int], numfield](+),
     restrict[[numfield, numfield], [int, int], numfield](*), 0]" ring_zn nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (Intersection const-decl "set" sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (product const-decl "posnat" product_seq reals) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (nZ const-decl "set[int]" ring_zn nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (< const-decl "bool" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (fs_rel_prime? const-decl "bool" prop_primes_extra nil) (/= const-decl "boolean" notequal nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil) (Chinese_Remainder_Theorem_for_int-2 nil 3792710361 ("" (skosimp*) (("" (lemma "nZ_fs_intersection") (("" (inst?) (("" (prop) (("1" (skoletin* -1) (("1" (hide -2) (("1" (replace -1 1 rl) (("1" (lemma "Chinese_Remainder_Theorem") (("1" (inst?) (("1" (expand "R_isomorphic?") (("1" (skosimp) (("1" (inst?) (("1" (assert) (("1" (expand "R_isomorphism?") (("1" (flatten) (("1" (prop) (("1" (hide -2) (("1" (expand "R_monomorphism?") (("1" (prop) (("1" (hide -2) (("1" (expand "injective?") (("1" (skosimp) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "R_homomorphism?") (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (expand "member") (("1" (expand "restrict") (("1" (inst -1 "x!1" "y!1") (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide (-1 2)) (("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide (-1 2)) (("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (expand "star_closed?") (("3" (skosimp) (("3" (expand "member") (("3" (inst -1 "x!1" "y!1") (("1" (expand "fsnZ_1") (("1" (expand "fsnZ") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "y!1") (("2" (hide 2) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide 2) (("3" (expand "fsnZ") (("3" (expand "fsnZ_1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand "star_closed?") (("4" (skosimp) (("4" (expand "member") (("4" (inst -1 "x!1" "y!1") (("1" (expand "fsnZ_1") (("1" (expand "fsnZ") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "y!1") (("2" (hide 2) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide 2) (("3" (expand "fsnZ") (("3" (expand "fsnZ_1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-5 -7 1)) (("5" (expand "homomorphism?") (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (expand "fsnZ") (("5" (expand "fsnZ_1") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-6 -7 1)) (("6" (expand "homomorphism?") (("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (expand "fsnZ") (("6" (expand "fsnZ_1") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "R_epimorphism?") (("2" (flatten) (("2" (prop) (("1" (hide (-2 -3)) (("1" (assert) (("1" (expand "surjective?") (("1" (skosimp) (("1" (inst?) (("1" (skosimp) (("1" (inst?) (("1" (expand "restrict") (("1" (expand "/") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "y!1") (("2" (hide 2) (("2" (expand "fsnZ_1") (("2" (expand "fsnZ") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "R_homomorphism?") (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (expand "member") (("1" (expand "restrict") (("1" (inst -1 "x!1" "y!1") (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide (-1 2)) (("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide (-1 2)) (("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (expand "star_closed?") (("3" (skosimp) (("3" (expand "member") (("3" (inst -1 "x!1" "y!1") (("1" (expand "fsnZ_1") (("1" (expand "fsnZ") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "y!1") (("2" (hide 2) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide 2) (("3" (expand "fsnZ") (("3" (expand "fsnZ_1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand "star_closed?") (("4" (skosimp) (("4" (expand "member") (("4" (inst -1 "x!1" "y!1") (("1" (expand "fsnZ_1") (("1" (expand "fsnZ") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "y!1") (("2" (hide 2) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide 2) (("3" (expand "fsnZ") (("3" (expand "fsnZ_1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-5 -7 1)) (("5" (expand "homomorphism?") (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (replaces -2 -1) (("5" (expand "fsnZ") (("5" (expand "fsnZ_1") (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-6 -7 1)) (("6" (expand "homomorphism?") (("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (replaces -2 -1) (("6" (expand "fsnZ") (("6" (expand "fsnZ_1") (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "restrict") (("2" (split) (("1" (skosimp) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "phi!1(x1!1)") (("2" (hide -2) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split) (("1" (expand "fsICM?") (("1" (split) (("1" (expand "fsRI?") (("1" (skosimp) (("1" (expand "finseq_appl") (("1" (expand "fsnZ_1" 1) (("1" (expand "finseq_appl") (("1" (lemma "nZ_ideal") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "finseq_appl") (("2" (expand "fsnZ_1" 2) (("2" (expand "finseq_appl") (("2" (lemma "nZ_mZ_comaximal") (("2" (inst?) (("2" (assert) (("2" (hide 3) (("2" (typepred "fspn!1") (("2" (expand "fs_rel_primes") (("2" (expand "finseq_appl") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "fspn!1") (("2" (hide (-2 -3)) (("2" (expand "fsnZ_1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "Z_commutative_ring_w_one") (("3" (expand "commutative_ring_with_one?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (typepred "fspn!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "fspn!1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nZ_fs_intersection formula-decl nil chinese_remainder_theorem_Z nil) (Chinese_Remainder_Theorem formula-decl nil chinese_remainder_theorem_rings nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (commutative_ring_with_one? const-decl "bool" ring_with_one_def nil) (nZ_mZ_comaximal formula-decl nil chinese_remainder_theorem_Z nil) (R_isomorphic? const-decl "bool" ring_homomorphisms_def nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) nil (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil) (star_closed? const-decl "bool" groupoid_def nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (injective? const-decl "bool" functions nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (surjective? const-decl "bool" functions nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (Intersection const-decl "set" sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (product const-decl "posnat" product_seq reals) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (< const-decl "bool" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (/= const-decl "boolean" notequal nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil) (Chinese_Remainder_Theorem_for_int-1 nil 3784745110 ("" (skosimp*) (("" (lemma "nZ_fs_intersection") (("" (inst?) (("" (prop) (("1" (skoletin* -1) (("1" (hide -2) (("1" (replace -1 1 rl) (("1" (lemma "Chinese_Remainder_Theorem") (("1" (inst?) (("1" (expand "R_isomorphic?") (("1" (skosimp) (("1" (inst?) (("1" (assert) (("1" (expand "R_isomorphism?") (("1" (flatten) (("1" (prop) (("1" (hide -2) (("1" (expand "R_monomorphism?") (("1" (prop) (("1" (hide -2) (("1" (expand "injective?") (("1" (skosimp) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "R_homomorphism?") (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (expand "member") (("1" (expand "restrict") (("1" (inst -1 "x!1" "y!1") (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide (-1 2)) (("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide (-1 2)) (("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (expand "star_closed?") (("3" (skosimp) (("3" (expand "member") (("3" (expand "restrict") (("3" (inst -1 "x!1" "y!1") (("1" (expand "fsnZ_1") (("1" (expand "fsnZ") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "y!1") (("2" (expand "restrict") (("2" (hide (-1 2)) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (expand "restrict") (("3" (hide (-1 2)) (("3" (expand "fsnZ") (("3" (expand "fsnZ_1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand "star_closed?") (("4" (skosimp) (("4" (expand "member") (("4" (expand "restrict") (("4" (inst -1 "x!1" "y!1") (("1" (expand "fsnZ_1") (("1" (expand "fsnZ") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "y!1") (("2" (expand "restrict") (("2" (hide (-1 2)) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (expand "restrict") (("3" (hide (-1 2)) (("3" (expand "fsnZ") (("3" (expand "fsnZ_1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-5 -7 1)) (("5" (expand "homomorphism?") (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (expand "fsnZ") (("5" (expand "fsnZ_1") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-6 -7 1)) (("6" (expand "homomorphism?") (("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (expand "fsnZ") (("6" (expand "fsnZ_1") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "R_epimorphism?") (("2" (flatten) (("2" (prop) (("1" (hide (-2 -3)) (("1" (expand "surjective?") (("1" (skosimp) (("1" (inst?) (("1" (skosimp) (("1" (inst?) (("1" (expand "restrict") (("1" (expand "/") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (expand "fsnZ_1") (("2" (expand "fsnZ") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "R_homomorphism?") (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "star_closed?") (("1" (skosimp) (("1" (expand "member") (("1" (expand "restrict") (("1" (inst -1 "x!1" "y!1") (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide (-1 2)) (("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "star_closed?") (("2" (skosimp) (("2" (expand "member") (("2" (expand "restrict") (("2" (inst -1 "x!1" "y!1") (("1" (assert) nil nil) ("2" (typepred "y!1") (("2" (hide (-1 2)) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide (-1 2)) (("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (expand "star_closed?") (("3" (skosimp) (("3" (expand "member") (("3" (expand "restrict") (("3" (inst -1 "x!1" "y!1") (("1" (expand "fsnZ_1") (("1" (expand "fsnZ") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "y!1") (("2" (expand "restrict") (("2" (hide (-1 2)) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (expand "restrict") (("3" (hide (-1 2)) (("3" (expand "fsnZ") (("3" (expand "fsnZ_1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand "star_closed?") (("4" (skosimp) (("4" (expand "member") (("4" (expand "restrict") (("4" (inst -1 "x!1" "y!1") (("1" (expand "fsnZ_1") (("1" (expand "fsnZ") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "y!1") (("2" (expand "restrict") (("2" (hide (-1 2)) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (expand "restrict") (("3" (hide (-1 2)) (("3" (expand "fsnZ") (("3" (expand "fsnZ_1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-5 -7 1)) (("5" (expand "homomorphism?") (("5" (skosimp) (("5" (inst -1 "a!1" "b!1") (("5" (expand "fsnZ") (("5" (expand "fsnZ_1") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-6 -7 1)) (("6" (expand "homomorphism?") (("6" (skosimp) (("6" (inst -1 "a!1" "b!1") (("6" (expand "fsnZ") (("6" (expand "fsnZ_1") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "restrict") (("2" (split) (("1" (skosimp) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (skosimp) (("2" (typepred "phi!1(x1!1)") (("2" (hide -2) (("2" (expand "fsnZ") (("2" (expand "fsnZ_1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split) (("1" (expand "fsICM?") (("1" (split) (("1" (expand "fsRI?") (("1" (skosimp) (("1" (expand "finseq_appl") (("1" (expand "fsnZ_1" 1) (("1" (expand "finseq_appl") (("1" (lemma "nZ_ideal") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "finseq_appl") (("2" (expand "fsnZ_1" 2) (("2" (expand "finseq_appl") (("2" (lemma "nZ_mZ_comaximal") (("2" (inst?) (("2" (assert) (("2" (hide 3) (("2" (typepred "fspn!1") (("2" (expand "fs_rel_primes") (("2" (expand "finseq_appl") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "fspn!1") (("2" (hide (-2 -3)) (("2" (expand "fsnZ_1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "Z_commutative_ring_w_one") (("3" (expand "commutative_ring_with_one?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (typepred "fspn!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "fspn!1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nZ_fs_intersection formula-decl nil chinese_remainder_theorem_Z nil) (Chinese_Remainder_Theorem formula-decl nil chinese_remainder_theorem_rings nil) (numfield nonempty-type-eq-decl nil number_fields nil) (restrict const-decl "R" restrict nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (commutative_ring_with_one? const-decl "bool" ring_with_one_def nil) (nZ_mZ_comaximal formula-decl nil chinese_remainder_theorem_Z nil) (R_isomorphic? const-decl "bool" ring_homomorphisms_def nil) (coset? const-decl "bool" cosets_def nil) (coset type-eq-decl nil cosets_def nil) nil (cartesian_product_n const-decl "set[finseq[T]]" cartesian_product_finite nil) (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil) (star_closed? const-decl "bool" groupoid_def nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (homomorphism? const-decl "bool" homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (injective? const-decl "bool" functions nil) (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil) (surjective? const-decl "bool" functions nil) (ring_with_one nonempty-type-eq-decl nil ring_with_one nil) (fsICM type-eq-decl nil comaximal_finseqs_ideals nil) (fsICM? const-decl "bool" comaximal_finseqs_ideals nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (ring_with_one? const-decl "bool" ring_with_one_def nil) (Intersection_surjective name-judgement "(surjective?[setofsets[T], set[T]])" sets_lemmas nil) (setof type-eq-decl nil defined_types nil) (setofsets type-eq-decl nil sets nil) (Intersection const-decl "set" sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (product const-decl "posnat" product_seq reals) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (< const-decl "bool" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (/= const-decl "boolean" notequal nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)))
