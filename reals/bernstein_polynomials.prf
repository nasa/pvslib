(bernstein_polynomials (Bern_TCC1 0 (Bern_TCC1-1 nil 3479200111 ("" (subtype-tcc) nil nil) nil nil (Bern subtype "bernstein_polynomials.n" "nat"))) (Bern_TCC2 0 (Bern_TCC2-1 nil 3479200111 ("" (subtype-tcc) nil nil) nil nil (Bern subtype "bernstein_polynomials.i" "{i: naturalnumbers.nat | reals.<=(i, bernstein_polynomials.n)}"))) (Bern_TCC3 0 (Bern_TCC3-1 nil 3479200111 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (Bern subtype "bernstein_polynomials.i" "{i: integers.int | booleans.OR(bernstein_polynomials.x /= 0, reals.>=(i, 0))}"))) (Bern_TCC4 0 (Bern_TCC4-1 nil 3479200335 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (Bern subtype "((number_fields.-)(bernstein_polynomials.n, bernstein_polynomials.i))" "{i: integers.int | booleans.OR(((number_fields.-)(1, bernstein_polynomials.x)) /= 0, reals.>=(i, 0))}"))) (Bern_top_TCC1 0 (Bern_top_TCC1-1 nil 3479206792 ("" (subtype-tcc) nil nil) nil nil (Bern_top subtype "bernstein_polynomials.p" "integers.above((number_fields.-)(bernstein_polynomials.p, 1))"))) (Bern_top 0 (Bern_top-1 nil 3479206793 ("" (skeep) (("" (expand "Bern") (("" (expand "C") (("" (expand "^" 1 1) (("" (expand "expt") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Bern const-decl "real" bernstein_polynomials nil) (^ const-decl "real" exponentiation nil) (factorial_0 formula-decl nil factorial ints) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_times_real_is_real application-judgement "real" reals nil) (expt def-decl "real" exponentiation nil) (C const-decl "posnat" binomial nil) (posint_times_posint_is_posint application-judgement "posint" integers nil)) shostak)) (Bern_bottom_TCC1 0 (Bern_bottom_TCC1-1 nil 3479206860 ("" (subtype-tcc) nil nil) nil nil (Bern_bottom subtype "bernstein_polynomials.k" "integers.above(-1)"))) (Bern_bottom_TCC2 0 (Bern_bottom_TCC2-1 nil 3479206860 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (Bern_bottom subtype "bernstein_polynomials.k" "{i: integers.int | booleans.OR(((number_fields.-)(1, bernstein_polynomials.x)) /= 0, reals.>=(i, 0))}"))) (Bern_bottom 0 (Bern_bottom-1 nil 3479206860 ("" (skeep) (("" (expand "Bern") (("" (expand "C") (("" (expand "^" 1 2) (("" (expand "expt") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Bern const-decl "real" bernstein_polynomials nil) (^ const-decl "real" exponentiation nil) (factorial_0 formula-decl nil factorial ints) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (expt def-decl "real" exponentiation nil) (C const-decl "posnat" binomial nil) (posint_times_posint_is_posint application-judgement "posint" integers nil)) shostak)) (Bern_middle_zero 0 (Bern_middle_zero-1 nil 3480419658 ("" (skeep) (("" (expand "Bern") (("" (case "0^i = 0") (("1" (assert) nil nil) ("2" (expand "^" 1) (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Bern const-decl "real" bernstein_polynomials nil) (nat_expt application-judgement "nat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (expt def-decl "real" exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat_exp application-judgement "nat" exponentiation nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (Bern_middle_one 0 (Bern_middle_one-1 nil 3480419912 ("" (skeep) (("" (expand "Bern") (("" (case "0^(nn-i) = 0") (("1" (assert) nil nil) ("2" (expand "^" 1) (("2" (expand "expt" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Bern const-decl "real" bernstein_polynomials nil) (int_plus_int_is_int application-judgement "int" integers nil) (nat_expt application-judgement "nat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (expt def-decl "real" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat_exp application-judgement "nat" exponentiation nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil)) shostak)) (Bern_Polynomial_TCC1 0 (Bern_Polynomial_TCC1-1 nil 3479653703 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (above nonempty-type-eq-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bern_Polynomial subtype "bernstein_polynomials.j" "{i: naturalnumbers.nat | reals.<=(i, bernstein_polynomials.nn)}"))) (Bern_Polynomial_TCC2 0 (Bern_Polynomial_TCC2-1 nil 3479653703 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (above nonempty-type-eq-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bern_Polynomial subtype "bernstein_polynomials.i" "{i: naturalnumbers.nat | reals.<=(i, bernstein_polynomials.j)}"))) (Bern_Polynomial 0 (Bern_Polynomial-2 "" 3790089202 ("" (skeep) (("" (decompose-equality) (("1" (expand "Bern") (("1" (lemma "neg_power_polynomial") (("1" (case "FORALL (n: nat):
                          (LAMBDA (x: real): (1 - x) ^ n) = polynomial(neg_power_fs(n), n)") (("1" (hide -2) (("1" (case "nn>=i") (("1" (inst - "nn-i") (("1" (decompose-equality) (("1" (inst - "x!1") (("1" (replace -1) (("1" (hide -1) (("1" (expand "polynomial") (("1" (rewrite "sigma_scal" :dir rl) (("1" (name "Bfun" "LAMBDA (i_1: nat):
                                                     neg_power_fs(nn - i)(i_1) * C(nn, i) * x!1 ^ i *
                                                      (IF i_1 = 0 THEN 1 ELSE x!1 ^ i_1 ENDIF)") (("1" (replace -1) (("1" (name "Afun" "LAMBDA (i_1: nat):
                                                      IF i_1 < i OR i_1 > nn THEN 0
                                                      ELSE C(i_1, i) * C(nn, i_1) * (-1) ^ (i_1 - i)
                                                      ENDIF
                                                       * (IF i_1 = 0 THEN 1 ELSE x!1 ^ i_1 ENDIF)") (("1" (replace -1) (("1" (lemma "sigma_shift_T2") (("1" (inst - "lambda (iz:nat):IF iz < i THEN 0 ELSE Bfun(iz-i) ENDIF" "nn-i" "0" "i") (("1" (assert) (("1" (case "(LAMBDA (i_1: nat): Bfun(i_1)) = Bfun") (("1" (replace -1) (("1" (hide -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst - "Afun" "nn" "0" "i-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (name "Bfun2" "LAMBDA (iz: nat): IF iz < i THEN 0 ELSE Bfun(iz - i) ENDIF") (("1" (replace -1) (("1" (case "sigma(0,i-1,Afun) = 0") (("1" (replace -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "Bfun2" "Afun" "nn" "i") (("1" (assert) (("1" (hide 2) (("1" (expand "restrict") (("1" (decompose-equality +) (("1" (lift-if) (("1" (ground) (("1" (replace -3 :dir rl) (("1" (replace -4 :dir rl) (("1" (replace -2 :dir rl) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (replace -1) (("1" (case "i = 0") (("1" (replace -1) (("1" (assert) (("1" (expand "neg_power_fs") (("1" (expand "C") (("1" (assert) (("1" (expand "^") (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (replace -1) (("2" (case "x!2 = i") (("1" (replace -1) (("1" (expand "neg_power_fs") (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (expand "neg_power_fs") (("3" (expand "C") (("3" (hide -) (("3" (lemma "expt_plus") (("3" (inst - "x!2-i" "i" "x!1") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (expand "^") (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_zero") (("2" (inst - "i-1" "0") (("2" (lemma "sigma_restrict_eq") (("2" (inst - "(LAMBDA (i: nat): 0)" "Afun" "i-1" "0") (("2" (assert) (("2" (hide (2 3)) (("2" (decompose-equality +) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (replace -3 :dir rl) (("2" (assert) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality +) nil nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (case "n>0") (("1" (inst - "n") nil nil) ("2" (case "n = 0") (("1" (replace -1) (("1" (hide-all-but 2) (("1" (decompose-equality +) (("1" (expand "^") (("1" (expand "expt") (("1" (expand "polynomial") (("1" (expand "sigma") (("1" (assert) (("1" (expand "neg_power_fs") (("1" (expand "C") (("1" (assert) (("1" (expand "^") (("1" (expand "expt") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (<= const-decl "bool" reals nil) (nn skolem-const-decl "above(i - 1)" bernstein_polynomials nil) (above nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (i skolem-const-decl "nat" bernstein_polynomials nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (Bern const-decl "real" bernstein_polynomials nil) (sequence type-eq-decl nil sequences nil) (polynomial const-decl "[real -> real]" polynomials nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (- const-decl "[numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (C const-decl "posnat" binomial nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (neg_power_polynomial formula-decl nil polynomials nil) (n skolem-const-decl "nat" bernstein_polynomials nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (sigma_scal formula-decl nil sigma nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma def-decl "real" sigma nil) (sigma_restrict_eq formula-decl nil sigma nil) (real_plus_real_is_real application-judgement "real" reals nil) (restrict const-decl "[T -> real]" sigma nil) (x!1 skolem-const-decl "real" bernstein_polynomials nil) (nzreal nonempty-type-eq-decl nil reals nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (expt_plus formula-decl nil exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (factorial_0 formula-decl nil factorial ints) (expt def-decl "real" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (int_exp application-judgement "int" exponentiation nil) (sigma_0_neg formula-decl nil sigma_nat nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (sigma_nat application-judgement "nat" sigma_nat nil) (sigma_zero formula-decl nil sigma nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_split formula-decl nil sigma nil) (int_times_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (sigma_shift_T2 formula-decl nil sigma nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (rat_exp application-judgement "rat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (neg_power_fs const-decl "[nat -> int]" polynomials nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_minus_real_is_real application-judgement "real" reals nil)) shostak) (Bern_Polynomial-1 nil 3479653689 ("" (skeep) (("" (decompose-equality) (("1" (expand "Bern") (("1" (lemma "neg_power_polynomial") (("1" (case "FORALL (n: nat):
                          (LAMBDA (x: real): (1 - x) ^ n) = polynomial(neg_power_fs(n), n)") (("1" (hide -2) (("1" (case "nn>=i") (("1" (inst - "nn-i") (("1" (decompose-equality) (("1" (inst - "x!1") (("1" (replace -1) (("1" (hide -1) (("1" (expand "polynomial") (("1" (rewrite "sigma_scal" :dir rl) (("1" (name "Bfun" "LAMBDA (i_1: nat):
                                                     neg_power_fs(nn - i)(i_1) * C(nn, i) * x!1 ^ i *
                                                      (IF i_1 = 0 THEN 1 ELSE x!1 ^ i_1 ENDIF)") (("1" (replace -1) (("1" (name "Afun" "LAMBDA (i_1: nat):
                                                      IF i_1 < i OR i_1 > nn THEN 0
                                                      ELSE C(i_1, i) * C(nn, i_1) * (-1) ^ (i_1 - i)
                                                      ENDIF
                                                       * (IF i_1 = 0 THEN 1 ELSE x!1 ^ i_1 ENDIF)") (("1" (replace -1) (("1" (lemma "sigma_shift_T2") (("1" (inst - "lambda (iz:nat):IF iz < i THEN 0 ELSE Bfun(iz-i) ENDIF" "nn-i" "0" "i") (("1" (assert) (("1" (case "(LAMBDA (i_1: nat): Bfun(i_1)) = Bfun") (("1" (replace -1) (("1" (hide -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst - "Afun" "nn" "0" "i-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (name "Bfun2" "LAMBDA (iz: nat): IF iz < i THEN 0 ELSE Bfun(iz - i) ENDIF") (("1" (replace -1) (("1" (case "sigma(0,i-1,Afun) = 0") (("1" (replace -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "Bfun2" "Afun" "nn" "i") (("1" (assert) (("1" (hide 2) (("1" (expand "restrict") (("1" (decompose-equality +) (("1" (lift-if) (("1" (ground) (("1" (replace -3 :dir rl) (("1" (replace -4 :dir rl) (("1" (replace -2 :dir rl) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (replace -1) (("1" (case "i = 0") (("1" (replace -1) (("1" (assert) (("1" (expand "neg_power_fs") (("1" (expand "C") (("1" (assert) (("1" (expand "^") (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (replace -1) (("2" (case "x!2 = i") (("1" (replace -1) (("1" (expand "neg_power_fs") (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (expand "neg_power_fs") (("3" (expand "C") (("3" (hide -) (("3" (lemma "expt_plus") (("3" (inst - "x!2-i" "i" "x!1") (("1" (assert) nil nil) ("2" (flatten) (("2" (replace -1) (("2" (expand "^") (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_zero") (("2" (inst - "i-1" "0") (("2" (lemma "sigma_restrict_eq") (("2" (inst - "(LAMBDA (i: nat): 0)" "Afun" "i-1" "0") (("2" (assert) (("2" (hide (2 3)) (("2" (decompose-equality +) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (replace -3 :dir rl) (("2" (assert) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality +) nil nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (case "n>0") (("1" (inst - "n") nil nil) ("2" (case "n = 0") (("1" (replace -1) (("1" (hide-all-but 2) (("1" (decompose-equality +) (("1" (expand "^") (("1" (expand "expt") (("1" (expand "polynomial") (("1" (expand "sigma") (("1" (assert) (("1" (expand "neg_power_fs") (("1" (expand "C") (("1" (assert) (("1" (expand "^") (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil) ((polynomial const-decl "[real -> real]" polynomials nil) (C const-decl "posnat" binomial nil) (neg_power_polynomial formula-decl nil polynomials nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (sigma_scal formula-decl nil sigma nil) (sigma def-decl "real" sigma nil) (sigma_restrict_eq formula-decl nil sigma nil) (restrict const-decl "[T -> real]" sigma nil) (factorial_0 formula-decl nil factorial ints) (sigma_0_neg formula-decl nil sigma_nat nil) (sigma_zero formula-decl nil sigma nil) (sigma_split formula-decl nil sigma nil) (sigma_shift_T2 formula-decl nil sigma nil) (neg_power_fs const-decl "[nat -> int]" polynomials nil)) nil)) (Bernstein_Recursion_TCC1 0 (Bernstein_Recursion_TCC1-1 nil 3479211177 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (Bernstein_Recursion subtype "bernstein_polynomials.k" "integers.above((number_fields.-)(bernstein_polynomials.r, 1))"))) (Bernstein_Recursion_TCC2 0 (Bernstein_Recursion_TCC2-1 nil 3479211177 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (Bernstein_Recursion subtype "(number_fields.-)(bernstein_polynomials.k, 1)" "integers.above((number_fields.-)(bernstein_polynomials.r, 1))"))) (Bernstein_Recursion_TCC3 0 (Bernstein_Recursion_TCC3-1 nil 3479211177 ("" (subtype-tcc) nil nil) nil nil (Bernstein_Recursion subtype "(number_fields.-)(bernstein_polynomials.r, 1)" "nat"))) (Bernstein_Recursion_TCC4 0 (Bernstein_Recursion_TCC4-1 nil 3479211177 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (Bernstein_Recursion subtype "(number_fields.-)(bernstein_polynomials.k, 1)" "integers.above((number_fields.-)(bernstein_polynomials.r, 2))"))) (Bernstein_Recursion 0 (Bernstein_Recursion-2 "" 3790089203 ("" (skeep) (("" (case "C(k,r) = C(k-1,r) + C(k-1,r-1)") (("1" (mult-by -1 "x^r*(1-x)^(k-r)") (("1" (expand "Bern") (("1" (case "x^r = x^(r-1)*x") (("1" (case "(1-x)^(k-r) = (1-x)*(1-x)^(k-r-1)") (("1" (assert) nil nil) ("2" (expand "^" 1) (("2" (assert) (("2" (expand "expt" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (expand "^" 1) (("2" (expand "expt" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "C_n_plus_1") (("2" (inst - "k-1" "r") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (C const-decl "posnat" binomial nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Bern const-decl "real" bernstein_polynomials nil) (int_plus_int_is_int application-judgement "int" integers nil) (expt def-decl "real" exponentiation nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (x skolem-const-decl "real" bernstein_polynomials nil) (k skolem-const-decl "posnat" bernstein_polynomials nil) (r skolem-const-decl "posnat" bernstein_polynomials nil) (^ const-decl "real" exponentiation nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (C_n_plus_1 formula-decl nil binomial nil)) shostak) (Bernstein_Recursion-1 nil 3479211177 ("" (skeep) (("" (case "C(k,r) = C(k-1,r) + C(k-1,r-1)") (("1" (mult-by -1 "x^r*(1-x)^(k-r)") (("1" (expand "Bern") (("1" (case "x^r = x^(r-1)*x") (("1" (case "(1-x)^(k-r) = (1-x)*(1-x)^(k-r-1)") (("1" (assert) nil nil) ("2" (expand "^" 1) (("2" (assert) (("2" (expand "expt" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (expand "^" 1) (("2" (expand "expt" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "C_n_plus_1") (("2" (inst - "k-1" "r") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil) ("5" (assert) nil nil)) nil)) nil) ((C const-decl "posnat" binomial nil) (C_n_plus_1 formula-decl nil binomial nil)) shostak)) (Bern_nonnegative 0 (Bern_nonnegative-1 nil 3479211589 ("" (skeep) (("" (skeep) (("" (expand "Bern") (("" (typepred "C(nn,i)") (("" (lemma "nnreal_expt") (("" (inst-cp - "i" "x") (("1" (inst - "nn-i" "1-x") (("1" (expand "^") (("1" (assert) (("1" (lemma "nnreal_times_nnreal_is_nnreal") (("1" (inst?) (("1" (lemma "nnreal_times_nnreal_is_nnreal") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((above nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (C const-decl "posnat" binomial nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (x skolem-const-decl "real" bernstein_polynomials nil) (nnreal type-eq-decl nil real_types nil) (^ const-decl "real" exponentiation nil) (nnreal_times_nnreal_is_nnreal judgement-tcc nil real_types nil) (nn skolem-const-decl "above(i - 1)" bernstein_polynomials nil) (i skolem-const-decl "nat" bernstein_polynomials nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt def-decl "real" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (nnreal_expt judgement-tcc nil exponentiation nil) (Bern const-decl "real" bernstein_polynomials nil)) shostak)) (Bern_positive 0 (Bern_positive-1 nil 3479211969 ("" (skeep) (("" (skeep) (("" (expand "Bern") (("" (typepred "C(nn,i)") (("" (lemma "posreal_expt") (("" (inst-cp - "i" "x") (("1" (inst - "nn-i" "1-x") (("1" (expand "^") (("1" (assert) (("1" (lemma "posreal_times_posreal_is_posreal") (("1" (inst?) (("1" (case "C(nn, i) * expt((1 - x), (nn - i)) > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "posreal_times_posreal_is_posreal") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((above nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (C const-decl "posnat" binomial nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (x skolem-const-decl "real" bernstein_polynomials nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (^ const-decl "real" exponentiation nil) (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil) (nn skolem-const-decl "above(i - 1)" bernstein_polynomials nil) (i skolem-const-decl "nat" bernstein_polynomials nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt def-decl "real" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (posreal_expt judgement-tcc nil exponentiation nil) (Bern const-decl "real" bernstein_polynomials nil)) nil)) (Bernstein_degree_raise_TCC1 0 (Bernstein_degree_raise_TCC1-1 nil 3479477346 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (Bernstein_degree_raise subtype "(number_fields.-)(bernstein_polynomials.k, 1)" "integers.above((number_fields.-)(bernstein_polynomials.p, 1))"))) (Bernstein_degree_raise_TCC2 0 (Bernstein_degree_raise_TCC2-1 nil 3479477346 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (Bernstein_degree_raise subtype "bernstein_polynomials.k" "integers.above((number_fields.-)(bernstein_polynomials.p, 1))"))) (Bernstein_degree_raise 0 (Bernstein_degree_raise-2 "" 3790089205 ("" (skeep) (("" (case "C(k-1,p) = ((k-p)/k)*C(k,p) AND ((k-p)/k)*C(k,p) = ((p+1)/k)*C(k,p+1)") (("1" (flatten) (("1" (mult-by -1 "x^p*(1-x)^(k-p-1)") (("1" (mult-by -2 "x^(p+1)*(1-x)^(k-p-1)") (("1" (expand "Bern") (("1" (case "(1-x)^(k-p) = (1-x)*(1-x)^(k-p-1)") (("1" (replace -1 1) (("1" (hide -1) (("1" (case "x^(p+1) = x*x^p") (("1" (assert) nil nil) ("2" (expand "^" 1) (("2" (expand "expt" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^" 1) (("2" (assert) (("2" (expand "expt" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split) (("1" (expand "C") (("1" (expand "factorial" 1 4) (("1" (expand "factorial" 1 6) (("1" (assert) (("1" (cross-mult 1) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "C") (("2" (expand "factorial" 1 3) (("2" (assert) (("2" (expand "factorial" 1 7) (("2" (cross-mult 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil)) nil)) nil) ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (C const-decl "posnat" binomial nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (^ const-decl "real" exponentiation nil) (k skolem-const-decl "posnat" bernstein_polynomials nil) (p skolem-const-decl "nat" bernstein_polynomials nil) (x skolem-const-decl "real" bernstein_polynomials nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (Bern const-decl "real" bernstein_polynomials nil) (int_plus_int_is_int application-judgement "int" integers nil) (expt def-decl "real" exponentiation nil) (factorial def-decl "posnat" factorial ints) (int_times_int_is_int application-judgement "int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (div_cancel4 formula-decl nil real_props nil) (div_cancel3 formula-decl nil real_props nil) (times_div2 formula-decl nil real_props nil) (times_div1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil)) shostak) (Bernstein_degree_raise-1 nil 3479213227 ("" (skeep) (("" (case "C(k-1,p) = ((k-p)/k)*C(k,p) AND ((k-p)/k)*C(k,p) = ((p+1)/k)*C(k,p+1)") (("1" (flatten) (("1" (mult-by -1 "x^p*(1-x)^(k-p-1)") (("1" (mult-by -2 "x^(p+1)*(1-x)^(k-p-1)") (("1" (expand "Bern") (("1" (case "(1-x)^(k-p) = (1-x)*(1-x)^(k-p-1)") (("1" (replace -1 1) (("1" (hide -1) (("1" (case "x^(p+1) = x*x^p") (("1" (assert) nil nil) ("2" (expand "^" 1) (("2" (expand "expt" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^" 1) (("2" (assert) (("2" (expand "expt" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split) (("1" (expand "C") (("1" (expand "factorial" 1 4) (("1" (expand "factorial" 1 6) (("1" (assert) (("1" (cross-mult 1) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "C") (("2" (expand "factorial" 1 3) (("2" (assert) (("2" (expand "factorial" 1 7) (("2" (cross-mult 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil)) nil)) nil) ((C const-decl "posnat" binomial nil) (factorial def-decl "posnat" factorial ints)) shostak)) (degree_raise_TCC1 0 (degree_raise_TCC1-1 nil 3480405695 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (degree_raise subtype "0" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (degree_raise_TCC2 0 (degree_raise_TCC2-1 nil 3480405695 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (degree_raise subtype "bernstein_polynomials.m" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (degree_raise_TCC3 0 (degree_raise_TCC3-1 nil 3480405695 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (degree_raise subtype "bernstein_polynomials.i" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (degree_raise_TCC4 0 (degree_raise_TCC4-1 nil 3480405695 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (degree_raise subtype "(number_fields.-)(bernstein_polynomials.i, 1)" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (degree_raise_power_TCC1 0 (degree_raise_power_TCC1-1 nil 3480410715 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (degree_raise_power subtype "(number_fields.-)(bernstein_polynomials.j, 1)" "nat"))) (degree_raise_power_TCC2 0 (degree_raise_power_TCC2-1 nil 3480410715 ("" (termination-tcc) nil nil) nil nil (degree_raise_power termination "bernstein_polynomials.degree_raise_power(bernstein_polynomials.b, (number_fields.-)(bernstein_polynomials.j, 1))" "nil"))) (Bernstein_index_degree_raise_TCC1 0 (Bernstein_index_degree_raise_TCC1-1 nil 3479472990 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (Bernstein_index_degree_raise subtype "bernstein_polynomials.k" "integers.above((number_fields.-)(bernstein_polynomials.p, 1))"))) (Bernstein_index_degree_raise_TCC2 0 (Bernstein_index_degree_raise_TCC2-1 nil 3479476400 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (Bernstein_index_degree_raise subtype "(number_fields.+)(bernstein_polynomials.k, 1)" "integers.above(bernstein_polynomials.p)"))) (Bernstein_index_degree_raise 0 (RWBf "RWB - (field 1) on leaf removed to prevent infinite loop" 3508838184 ("" (skeep) (("" (case "k > p") (("1" (hide -2) (("1" (lemma "Bernstein_Recursion") (("1" (inst - "k+1" "p+1" "x") (("1" (name "A" "1-x") (("1" (replace -1) (("1" (assert) (("1" (case "A*Bern(1+p,k)(x) = (C(k,p+1)/C(k+1,p+1))*Bern(1+p,1+k)(x)") (("1" (replace -1) (("1" (hide -1) (("1" (expand "C" -2) (("1" (expand "factorial" -2 4) (("1" (expand "factorial" -2 7) (("1" (name "const1" "Bern(p,k)(x)") (("1" (replace -1) (("1" (name "const2" "Bern(1+p,1+k)(x)") (("1" (replace -1) (("1" (name "const3" "factorial(k)") (("1" (replace -1) (("1" (name "const4" "factorial(1+p)") (("1" (replace -1) (("1" (name "const5" "factorial(-1-p+k)") (("1" (replace -1) (("1" (hide -1) (("1" (hide -1) (("1" (hide -1) (("1" (hide -1) (("1" (hide -1) (("1" (case "(const3 / (const4 * const5) /
                                                              ((const3 + const3 * k) /
                                                                (const4 * const5 * k - const4 * const5 * p))) = (k-p)/(1+k)") (("1" (replace -1) (("1" (hide -1) (("1" (both-sides "-" "((k-p)/(1+k))*const2" -2) (("1" (assert) (("1" (replace -2 :dir rl) (("1" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (name "apz1" "(const3 / (const4 * const5) /
        ((const3 + const3 * k) /
          (const4 * const5 * k - const4 * const5 * p)))") (("2" (replace -1) (("2" (mult-by 1 "const4*const5") (("2" (case "apz1*(const4*const5) = 1/((1 + k) /
          (const4 * const5 * k - const4 * const5 * p))") (("1" (replace -1) (("1" (hide -1) (("1" (hide -1) (("1" (field 1) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (cross-mult 1) (("2" (replace -1 :dir rl) (("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 2)) (("2" (expand "Bern") (("2" (case "A*(1-x)^(k-p-1) = (1-x)^(k-p)") (("1" (assert) nil nil) ("2" (replace -1 :dir rl) (("2" (expand "^") (("2" (expand "expt" 1 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k = p") (("1" (replace -1) (("1" (hide -1) (("1" (hide -1) (("1" (hide 1) (("1" (lemma "Bern_top") (("1" (inst-cp - "p" "x") (("1" (inst - "p+1" "x") (("1" (replace -1) (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (expand "^") (("1" (expand "expt" 1 2) (("1" (field) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Bernstein_Recursion formula-decl nil bernstein_polynomials nil) (real_minus_real_is_real application-judgement "real" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (posint nonempty-type-eq-decl nil integers nil) (div_cancel2 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (both_sides_times1 formula-decl nil real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (times_div2 formula-decl nil real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil) (nzrat nonempty-type-eq-decl nil rationals nil) (cross_mult formula-decl nil real_props nil) (div_div2 formula-decl nil real_props nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (div_cancel3 formula-decl nil real_props nil) (times_div1 formula-decl nil real_props nil) (div_cancel4 formula-decl nil real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (div_div1 formula-decl nil real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (factorial def-decl "posnat" factorial ints) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (C const-decl "posnat" binomial nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (Bern_top formula-decl nil bernstein_polynomials nil) (div_simp formula-decl nil real_props nil)) shostak) (Bernstein_index_degree_raise-1 nil 3479472990 ("" (skeep) (("" (case "k > p") (("1" (hide -2) (("1" (lemma "Bernstein_Recursion") (("1" (inst - "k+1" "p+1" "x") (("1" (name "A" "1-x") (("1" (replace -1) (("1" (assert) (("1" (case "A*Bern(1+p,k)(x) = (C(k,p+1)/C(k+1,p+1))*Bern(1+p,1+k)(x)") (("1" (replace -1) (("1" (hide -1) (("1" (expand "C" -2) (("1" (expand "factorial" -2 4) (("1" (expand "factorial" -2 7) (("1" (name "const1" "Bern(p,k)(x)") (("1" (replace -1) (("1" (name "const2" "Bern(1+p,1+k)(x)") (("1" (replace -1) (("1" (name "const3" "factorial(k)") (("1" (replace -1) (("1" (name "const4" "factorial(1+p)") (("1" (replace -1) (("1" (name "const5" "factorial(-1-p+k)") (("1" (replace -1) (("1" (hide -1) (("1" (hide -1) (("1" (hide -1) (("1" (hide -1) (("1" (hide -1) (("1" (case "(const3 / (const4 * const5) /
                                        ((const3 + const3 * k) /
                                          (const4 * const5 * k - const4 * const5 * p))) = (k-p)/(1+k)") (("1" (replace -1) (("1" (hide -1) (("1" (both-sides "-" "((k-p)/(1+k))*const2" -2) (("1" (assert) (("1" (replace -2 :dir rl) (("1" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 2)) (("2" (expand "Bern") (("2" (case "A*(1-x)^(k-p-1) = (1-x)^(k-p)") (("1" (assert) nil nil) ("2" (replace -1 :dir rl) (("2" (expand "^") (("2" (expand "expt" 1 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "k = p") (("1" (replace -1) (("1" (hide -1) (("1" (hide -1) (("1" (hide 1) (("1" (lemma "Bern_top") (("1" (inst-cp - "p" "x") (("1" (inst - "p+1" "x") (("1" (replace -1) (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (expand "^") (("1" (expand "expt" 1 2) (("1" (field) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((factorial def-decl "posnat" factorial ints) (C const-decl "posnat" binomial nil)) shostak)) (Bernstein_partition_of_unity_TCC1 0 (Bernstein_partition_of_unity_TCC1-1 nil 3479214531 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bernstein_partition_of_unity subtype "bernstein_polynomials.p" "integers.above((number_fields.-)(bernstein_polynomials.i, 1))"))) (Bernstein_partition_of_unity 0 (Bernstein_partition_of_unity-1 nil 3479214531 ("" (skeep) (("" (expand "Bern") (("" (lemma "binomial_theorem") (("" (inst - "p" "x" "(1-x)") (("" (replace -1 :dir rl) (("" (hide -1) (("" (assert) (("" (rewrite "expt_1i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern const-decl "real" bernstein_polynomials nil) (real_minus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt_1i formula-decl nil exponentiation nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (binomial_theorem formula-decl nil polynomials nil)) shostak)) (Bern_le_1 0 (Bern_le_1-1 nil 3479546101 ("" (skeep) (("" (skeep) (("" (lemma "Bernstein_partition_of_unity") (("" (inst - "nn" "x") (("" (name "AA" "LAMBDA (i: nat): IF i > nn THEN 0 ELSE Bern(i, nn)(x) ENDIF") (("1" (case "FORALL (ijk:nat): AA(ijk)>=0") (("1" (replace -2) (("1" (lemma "sigma_split") (("1" (inst - "AA" "nn" "0" "i-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst - "AA" "nn" "i" "i") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (label "Ann" -1) (("1" (hide "Ann") (("1" (expand "sigma" -2 3) (("1" (lemma "sigma_le") (("1" (inst - "lambda (ij: nat): 0" "AA" "i-1" "0") (("1" (split -1) (("1" (lemma "sigma_le") (("1" (inst - "lambda (ij: nat): 0" "AA" "nn" "1+i") (("1" (split -1) (("1" (lemma "sigma_zero") (("1" (inst - "nn" "1+i") (("1" (lemma "sigma_zero") (("1" (inst - "i-1" "0") (("1" (expand "sigma" -6 3) (("1" (replace -5 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "Ann") (("2" (skosimp*) (("2" (inst-cp - "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "Ann") (("2" (skosimp*) (("2" (inst-cp - "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (replace -1 :dir rl) (("2" (assert) (("2" (lift-if) (("2" (ground) (("2" (lemma "Bern_nonnegative") (("2" (inst - "x") (("2" (assert) (("2" (inst - "ijk" "nn") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (above nonempty-type-eq-decl nil integers nil) (sigma_split formula-decl nil sigma nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma def-decl "real" sigma nil) (sigma_nat application-judgement "nat" sigma_nat nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_zero formula-decl nil sigma nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sigma_le formula-decl nil sigma nil) (real_plus_real_is_real application-judgement "real" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (Bern_nonnegative formula-decl nil bernstein_polynomials nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (Bern const-decl "real" bernstein_polynomials nil) (Bernstein_partition_of_unity formula-decl nil bernstein_polynomials nil)) shostak)) (Bernstein_conversion_TCC1 0 (Bernstein_conversion_TCC1-1 nil 3479457319 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bernstein_conversion subtype "bernstein_polynomials.p" "{i_1: naturalnumbers.nat | reals.<=(i_1, bernstein_polynomials.i)}"))) (Bernstein_conversion_TCC2 0 (Bernstein_conversion_TCC2-1 nil 3479457319 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bernstein_conversion subtype "bernstein_polynomials.p" "{i: naturalnumbers.nat | reals.<=(i, bernstein_polynomials.k)}"))) (Bernstein_conversion_TCC3 0 (Bernstein_conversion_TCC3-1 nil 3479457319 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (Bernstein_conversion subtype "bernstein_polynomials.k" "integers.above((number_fields.-)(bernstein_polynomials.i, 1))"))) (Bernstein_conversion 0 (Bernstein_conversion-2 "" 3790089221 ("" (skeep) (("" (case "FORALL (nn: nat): x ^ nn =
                            sigma(nn, k-p+nn,
                                  LAMBDA (i: nat):
                                    IF i < nn OR i > k-p+nn THEN 0
                                    ELSE (C(i, nn) / C(k-p+nn, nn)) * Bern(i, k-p+nn)(x)
                                    ENDIF)") (("1" (inst - "p") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "nn") (("1" (expand "^") (("1" (expand "expt") (("1" (case "k = p") (("1" (replace -1) (("1" (assert) (("1" (expand "sigma") (("1" (assert) (("1" (expand "C") (("1" (expand "Bern") (("1" (expand "^") (("1" (expand "expt") (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "Bernstein_partition_of_unity") (("2" (inst - "k-p" "x") (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (i: nat):
                                   IF i > k - p THEN 0
                                   ELSE (C(i, 0) / C(k - p, 0)) * Bern(i, k - p)(x)
                                   ENDIF" "LAMBDA (i: nat):
                                  IF i > k - p THEN 0 ELSE Bern(i, k - p)(x) ENDIF" "k-p" "0") (("1" (assert) (("1" (hide 3) (("1" (hide -1) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (name "F" "LAMBDA (i: nat):
               IF i < j OR i > k - p + j THEN 0
               ELSE (C(i, j) / C(k - p + j, j)) * Bern(i, k - p + j)(x)
               ENDIF") (("1" (replace -1) (("1" (name "G" "LAMBDA (i: nat):
               IF i < j + 1 OR i > k - p + (j + 1) THEN 0
               ELSE (C(i, j + 1) / C(k - p + (j + 1), j + 1)) *
                     Bern(i, k - p + (j + 1))(x)
               ENDIF") (("1" (replace -1) (("1" (mult-by -3 "x") (("1" (expand "^") (("1" (expand "expt" +) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_scal") (("1" (inst - "F" "x" "j-p+k" "j") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (name "H" "LAMBDA (i: nat): x * F(i)") (("1" (replace -1) (("1" (lemma "sigma_shift_T2") (("1" (inst - "H" "j-p+k+1" "1+j" "-1") (("1" (assert) (("1" (replace -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (hide -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (assert) (("1" (hide -1) (("1" (replace -1 :dir rl) (("1" (assert) (("1" (hide -1) (("1" (lemma "Bernstein_index_degree_raise") (("1" (inst - "j-p+k" "x!1-1" "x") (("1" (assert) (("1" (mult-by -1 "(C(x!1 - 1, j) / C(j - p + k, j))") (("1" (replace -1) (("1" (hide -1) (("1" (case "(x!1 / (1 - p + j + k)) * 
       (C(x!1 - 1, j) / C(j - p + k, j))
       =
       (C(x!1, 1 + j) / C(1 - p + j + k, 1 + j)) ") (("1" (mult-by -1 "Bern(x!1,1-p+j+k)(x)") (("1" (assert) nil nil)) nil) ("2" (hide 4) (("2" (expand "C") (("2" (expand "factorial" 1 7) (("2" (cross-mult 1) (("2" (field) (("2" (expand "factorial" 1 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (case "NOT x!1 = 0") (("1" (case "k = p") (("1" (replace -1) (("1" (assert) (("1" (case "x!1 = 1") (("1" (replace -1) (("1" (assert) (("1" (lemma "Bern_top") (("1" (inst-cp - "0" "x") (("1" (inst - "1" "x") (("1" (replace -1) (("1" (replace -2) (("1" (expand "^") (("1" (expand "expt") (("1" (expand "expt") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (skeep) (("5" (assert) nil nil)) nil) ("6" (skeep) (("6" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (skeep) (("5" (assert) nil nil)) nil) ("6" (skeep) (("6" (assert) nil nil)) nil)) nil)) nil) ((Bern const-decl "real" bernstein_polynomials nil) (above nonempty-type-eq-decl nil integers nil) (C const-decl "posnat" binomial nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (sigma def-decl "real" sigma nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (p skolem-const-decl "nat" bernstein_polynomials nil) (k skolem-const-decl "posnat" bernstein_polynomials nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (expt def-decl "real" exponentiation nil) (Bernstein_partition_of_unity formula-decl nil bernstein_polynomials nil) (sigma_restrict_eq formula-decl nil sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (restrict const-decl "[T -> real]" sigma nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (factorial_0 formula-decl nil factorial ints) (sigma_0_neg formula-decl nil sigma_nat nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (j skolem-const-decl "nat" bernstein_polynomials nil) (factorial def-decl "posnat" factorial ints) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (both_sides_times1 formula-decl nil real_props nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (div_cancel3 formula-decl nil real_props nil) (times_div2 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div1 formula-decl nil real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (Bern_top formula-decl nil bernstein_polynomials nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (Bernstein_index_degree_raise formula-decl nil bernstein_polynomials nil) (sigma_shift_T2 formula-decl nil sigma nil) (sigma_scal formula-decl nil sigma nil)) shostak) (Bernstein_conversion-1 nil 3479457319 ("" (skeep) (("" (case "FORALL (nn: nat): x ^ nn =
                            sigma(nn, k-p+nn,
                                  LAMBDA (i: nat):
                                    IF i < nn OR i > k-p+nn THEN 0
                                    ELSE (C(i, nn) / C(k-p+nn, nn)) * Bern(i, k-p+nn)(x)
                                    ENDIF)") (("1" (inst - "p") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "nn") (("1" (expand "^") (("1" (expand "expt") (("1" (case "k = p") (("1" (replace -1) (("1" (assert) (("1" (expand "sigma") (("1" (assert) (("1" (expand "C") (("1" (expand "Bern") (("1" (expand "^") (("1" (expand "expt") (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "Bernstein_partition_of_unity") (("2" (inst - "k-p" "x") (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (i: nat):
                                   IF i > k - p THEN 0
                                   ELSE (C(i, 0) / C(k - p, 0)) * Bern(i, k - p)(x)
                                   ENDIF" "LAMBDA (i: nat):
                                  IF i > k - p THEN 0 ELSE Bern(i, k - p)(x) ENDIF" "k-p" "0") (("1" (assert) (("1" (hide 3) (("1" (hide -1) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (name "F" "LAMBDA (i: nat):
               IF i < j OR i > k - p + j THEN 0
               ELSE (C(i, j) / C(k - p + j, j)) * Bern(i, k - p + j)(x)
               ENDIF") (("1" (replace -1) (("1" (name "G" "LAMBDA (i: nat):
               IF i < j + 1 OR i > k - p + (j + 1) THEN 0
               ELSE (C(i, j + 1) / C(k - p + (j + 1), j + 1)) *
                     Bern(i, k - p + (j + 1))(x)
               ENDIF") (("1" (replace -1) (("1" (mult-by -3 "x") (("1" (expand "^") (("1" (expand "expt" +) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_scal") (("1" (inst - "F" "x" "j-p+k" "j") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (name "H" "LAMBDA (i: nat): x * F(i)") (("1" (replace -1) (("1" (lemma "sigma_shift_T2") (("1" (inst - "H" "j-p+k+1" "1+j" "-1") (("1" (assert) (("1" (replace -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (hide -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (assert) (("1" (replace -1 :dir rl) (("1" (assert) (("1" (hide -1) (("1" (replace -1 :dir rl) (("1" (assert) (("1" (hide -1) (("1" (lemma "Bernstein_index_degree_raise") (("1" (inst - "j-p+k" "x!1-1" "x") (("1" (assert) (("1" (mult-by -1 "(C(x!1 - 1, j) / C(j - p + k, j))") (("1" (replace -1) (("1" (hide -1) (("1" (case "(x!1 / (1 - p + j + k)) * 
       (C(x!1 - 1, j) / C(j - p + k, j))
       =
       (C(x!1, 1 + j) / C(1 - p + j + k, 1 + j)) ") (("1" (mult-by -1 "Bern(x!1,1-p+j+k)(x)") (("1" (assert) nil nil)) nil) ("2" (hide 4) (("2" (expand "C") (("2" (expand "factorial" 1 7) (("2" (cross-mult 1) (("2" (field) (("2" (expand "factorial" 1 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (case "NOT x!1 = 0") (("1" (case "k = p") (("1" (replace -1) (("1" (assert) (("1" (case "x!1 = 1") (("1" (replace -1) (("1" (assert) (("1" (lemma "Bern_top") (("1" (inst-cp - "0" "x") (("1" (inst - "1" "x") (("1" (replace -1) (("1" (replace -2) (("1" (expand "^") (("1" (expand "expt") (("1" (expand "expt") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst + "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (skeep) (("5" (assert) nil nil)) nil) ("6" (skeep) (("6" (assert) nil nil)) nil) ("7" (skeep) (("7" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (skeep) (("5" (assert) nil nil)) nil) ("6" (skeep) (("6" (assert) nil nil)) nil) ("7" (skeep) (("7" (assert) nil nil)) nil)) nil)) nil) ((C const-decl "posnat" binomial nil) (sigma def-decl "real" sigma nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (sigma_restrict_eq formula-decl nil sigma nil) (restrict const-decl "[T -> real]" sigma nil) (factorial_0 formula-decl nil factorial ints) (sigma_0_neg formula-decl nil sigma_nat nil) (factorial def-decl "posnat" factorial ints) (sigma_shift_T2 formula-decl nil sigma nil) (sigma_scal formula-decl nil sigma nil)) shostak)) (Bernstein_conversion_2 0 (Bernstein_conversion_2-1 nil 3479543185 ("" (skeep) (("" (lemma "Bernstein_conversion") (("" (inst - "k" "p" "x") (("" (assert) (("" (case "p = 0") (("1" (assert) nil nil) ("2" (lemma "sigma_split") (("2" (inst - "LAMBDA (i: nat):
               IF i < p OR i > k THEN 0
               ELSE (C(i, p) / C(k, p)) * Bern(i, k)(x)
               ENDIF" "k" "0" "p-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (i: nat):
               IF i < p OR i > k THEN 0
               ELSE (C(i, p) / C(k, p)) * Bern(i, k)(x)
               ENDIF" "LAMBDA (i: nat):
               0" "p-1" "0") (("1" (lemma "sigma_zero") (("1" (inst - "p-1" "0") (("1" (assert) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bernstein_conversion formula-decl nil bernstein_polynomials nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sigma_split formula-decl nil sigma nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (restrict const-decl "[T -> real]" sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_nat application-judgement "nat" sigma_nat nil) (real_plus_real_is_real application-judgement "real" reals nil) (sigma_zero formula-decl nil sigma nil) (sigma_restrict_eq formula-decl nil sigma nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (Bern const-decl "real" bernstein_polynomials nil) (above nonempty-type-eq-decl nil integers nil) (C const-decl "posnat" binomial nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (k skolem-const-decl "posnat" bernstein_polynomials nil) (p skolem-const-decl "nat" bernstein_polynomials nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (Bern_poly_TCC1 0 (Bern_poly_TCC1-1 nil 3479481006 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bern_poly subtype "bernstein_polynomials.i" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (Bern_poly_TCC2 0 (Bern_poly_TCC2-1 nil 3479481006 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bern_poly subtype "bernstein_polynomials.b`index" "integers.above((number_fields.-)(bernstein_polynomials.i, 1))"))) (degree_raise_id 0 (degree_raise_id-2 "" 3790089223 ("" (skeep) (("" (decompose-equality) (("" (expand "Bern_poly") (("" (name "mm" "b`index") (("" (replace -1) (("" (case "degree_raise(b)`index = mm+1") (("1" (replace -1) (("1" (name "AA" "LAMBDA (i: nat):
                                                           IF i > mm THEN 0 ELSE b`bern_seq(i) * Bern(i, mm)(x!1) ENDIF") (("1" (replace -1) (("1" (name "BB" "LAMBDA (i: nat):
                                                                      IF i > mm + 1 THEN 0
                                                                      ELSE degree_raise(b)`bern_seq(i) * Bern(i, mm + 1)(x!1)
                                                                      ENDIF") (("1" (replace -1) (("1" (name "Aleft" "LAMBDA (i:nat): IF i>mm THEN 0 ELSE b`bern_seq(i)*((mm+1-i)/(mm+1))*Bern(i,mm+1)(x!1) ENDIF") (("1" (name "Aright" "LAMBDA (i:nat): IF i > mm+1 OR i = 0 THEN 0 ELSE b`bern_seq(i-1)*(i/(mm+1))*Bern(i,mm+1)(x!1) ENDIF") (("1" (case "NOT BB = Aleft+Aright") (("1" (hide 2) (("1" (hide -4) (("1" (decompose-equality) (("1" (expand "+" +) (("1" (expand "BB" +) (("1" (expand "Aleft" +) (("1" (expand "Aright" +) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "degree_raise" +) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (hide -3) (("2" (expand "+" +) (("2" (rewrite "sigma_sum" :dir rl) (("2" (lemma "sigma_split") (("2" (inst - "Aleft" "mm+1" "0" "mm") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (case "NOT sigma(1+mm,1+mm,Aleft) = 0") (("1" (hide 2) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (expand "Aleft" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (assert) (("2" (lemma "sigma_split") (("2" (inst - "Aright" "mm+1" "0" "0") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (case "NOT sigma(0,0,Aright) = 0") (("1" (hide 2) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "Aright" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (assert) (("2" (lemma "sigma_shift_T2") (("2" (inst - "Aright" "mm" "0" "1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (name "DD" "LAMBDA (i: nat): Aright(1 + i)") (("2" (replace -1) (("2" (case "NOT AA = Aleft + DD") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "+" +) (("1" (expand "AA" +) (("1" (expand "Aleft" +) (("1" (expand "DD" +) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "Aright" +) (("1" (propax) nil nil)) nil) ("2" (expand "Aright" +) (("2" (lemma "Bernstein_degree_raise") (("2" (inst - "1+mm" "x!2" "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_sum") (("2" (inst - "Aleft" "DD" "mm" "0") (("2" (expand "+" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "degree_raise") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (degree_raise const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (Bern const-decl "real" bernstein_polynomials nil) (above nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (real_times_real_is_real application-judgement "real" reals nil) (<= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (+ const-decl "[T -> real]" real_fun_ops nil) (Aleft skolem-const-decl "[nat -> real]" bernstein_polynomials nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (real_plus_real_is_real application-judgement "real" reals nil) (Aright skolem-const-decl "[nat -> real]" bernstein_polynomials nil) (BB skolem-const-decl "[nat -> real]" bernstein_polynomials nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (sigma_split formula-decl nil sigma nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_shift_T2 formula-decl nil sigma nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Bernstein_degree_raise formula-decl nil bernstein_polynomials nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (DD skolem-const-decl "[nat -> real]" bernstein_polynomials nil) (AA skolem-const-decl "[nat -> real]" bernstein_polynomials nil) (sigma def-decl "real" sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_sum formula-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak) (degree_raise_id-1 nil 3480405695 ("" (skeep) (("" (decompose-equality) (("" (expand "Bern_poly") (("" (name "mm" "b`index") (("" (replace -1) (("" (case "degree_raise(b)`index = mm+1") (("1" (replace -1) (("1" (name "AA" "LAMBDA (i: nat):
                                                           IF i > mm THEN 0 ELSE b`bern_seq(i) * Bern(i, mm)(x!1) ENDIF") (("1" (replace -1) (("1" (name "BB" "LAMBDA (i: nat):
                                                                      IF i > mm + 1 THEN 0
                                                                      ELSE degree_raise(b)`bern_seq(i) * Bern(i, mm + 1)(x!1)
                                                                      ENDIF") (("1" (replace -1) (("1" (name "Aleft" "LAMBDA (i:nat): IF i>mm THEN 0 ELSE b`bern_seq(i)*((mm+1-i)/(mm+1))*Bern(i,mm+1)(x!1) ENDIF") (("1" (name "Aright" "LAMBDA (i:nat): IF i > mm+1 OR i = 0 THEN 0 ELSE b`bern_seq(i-1)*(i/(mm+1))*Bern(i,mm+1)(x!1) ENDIF") (("1" (case "NOT BB = Aleft+Aright") (("1" (hide 2) (("1" (hide -4) (("1" (decompose-equality) (("1" (expand "+" +) (("1" (expand "BB" +) (("1" (expand "Aleft" +) (("1" (expand "Aright" +) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "degree_raise" +) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (hide -3) (("2" (expand "+" +) (("2" (rewrite "sigma_sum" :dir rl) (("2" (lemma "sigma_split") (("2" (inst - "Aleft" "mm+1" "0" "mm") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case "NOT sigma(1+mm,1+mm,Aleft) = 0") (("1" (hide 2) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (expand "Aleft" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (assert) (("2" (lemma "sigma_split") (("2" (inst - "Aright" "mm+1" "0" "0") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (case "NOT sigma(0,0,Aright) = 0") (("1" (hide 2) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "Aright" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (assert) (("2" (lemma "sigma_shift_T2") (("2" (inst - "Aright" "mm" "0" "1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (name "DD" "LAMBDA (i: nat): Aright(1 + i)") (("2" (replace -1) (("2" (case "NOT AA = Aleft + DD") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "+" +) (("1" (expand "AA" +) (("1" (expand "Aleft" +) (("1" (expand "DD" +) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (expand "Aright" +) (("1" (propax) nil nil)) nil) ("2" (expand "Aright" +) (("2" (lemma "Bernstein_degree_raise") (("2" (inst - "1+mm" "x!2" "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_sum") (("2" (inst - "Aleft" "DD" "mm" "0") (("2" (expand "+" 1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "degree_raise") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma_split formula-decl nil sigma nil) (sigma_shift_T2 formula-decl nil sigma nil) (sigma def-decl "real" sigma nil) (sigma_sum formula-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil)) shostak)) (degree_raise_power_id 0 (degree_raise_power_id-1 nil 3480666697 ("" (skeep) (("" (case "FORALL (jj:nat): Bern_poly(b) = Bern_poly(degree_raise_power(b, jj))") (("1" (inst - "j") nil nil) ("2" (hide 2) (("2" (induct "jj") (("1" (expand "degree_raise_power") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (expand "degree_raise_power" +) (("2" (lemma "degree_raise_id") (("2" (inst - "degree_raise_power(b,j!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((degree_raise_power def-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (degree_raise_id formula-decl nil bernstein_polynomials nil)) nil)) (Bern_poly_reverse_TCC1 0 (Bern_poly_reverse_TCC1-1 nil 3485881402 ("" (subtype-tcc) nil nil) nil nil (Bern_poly_reverse subtype "(number_fields.-)(bernstein_polynomials.b`index, bernstein_polynomials.i)" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (Bern_poly_reverse_sym_half 0 (Bern_poly_reverse_sym_half-2 "" 3790089224 ("" (skeep) (("" (expand "Bern_poly") (("" (case "Bern_poly_reverse(b)`index = b`index") (("1" (replace -1) (("1" (lemma "sigma_reverse") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (hide -) (("1" (expand "Bern_poly_reverse") (("1" (case "Bern(b`index - x!1, b`index)(1 / 2 + x) =
                      Bern(x!1, b`index)(1 / 2 - x)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "Bern") (("2" (lemma "C_symmetry") (("2" (inst - "b`index" "x!1") (("2" (replace -1 :dir rl) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "Bern_poly_reverse") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (<= const-decl "bool" reals nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (> const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_restrict_eq formula-decl nil sigma nil) (restrict const-decl "[T -> real]" sigma nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (C_symmetry formula-decl nil binomial nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_reverse formula-decl nil sigma_nat nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (Bern_poly_reverse const-decl "Bernstein_Polynomial" bernstein_polynomials nil)) shostak) (Bern_poly_reverse_sym_half-1 nil 3485881746 ("" (skeep) (("" (expand "Bern_poly") (("" (case "Bern_poly_reverse(b)`index = b`index") (("1" (replace -1) (("1" (lemma "sigma_reverse") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (hide -) (("1" (expand "Bern_poly_reverse") (("1" (case "Bern(b`index - x!1, b`index)(1 / 2 + x) =
                      Bern(x!1, b`index)(1 / 2 - x)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "Bern") (("2" (lemma "C_symmetry") (("2" (inst - "b`index" "x!1") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "Bern_poly_reverse") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((sigma_restrict_eq formula-decl nil sigma nil) (restrict const-decl "[T -> real]" sigma nil) (C_symmetry formula-decl nil binomial nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (sigma_reverse formula-decl nil sigma_nat nil)) nil)) (Bern_poly_reverse_sym 0 (Bern_poly_reverse_sym-1 nil 3485881402 ("" (skeep) (("" (lemma "Bern_poly_reverse_sym_half") (("" (inst - "b" "x-1/2") (("" (assert) nil nil)) nil)) nil)) nil) ((Bern_poly_reverse_sym_half formula-decl nil bernstein_polynomials nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_plus_real_is_real application-judgement "real" reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real nonempty-type-from-decl nil reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_minus_real_is_real application-judgement "real" reals nil)) shostak)) (Bern_poly_inverse_TCC1 0 (Bern_poly_inverse_TCC1-1 nil 3479635199 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bern_poly_inverse subtype "bernstein_polynomials.i" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (Bern_poly_inverse_TCC2 0 (Bern_poly_inverse_TCC2-1 nil 3479644701 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bern_poly_inverse subtype "bernstein_polynomials.j" "{i: naturalnumbers.nat | reals.<=(i, bernstein_polynomials.b`index)}"))) (Bern_poly_inverse_TCC3 0 (Bern_poly_inverse_TCC3-1 nil 3479644701 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bern_poly_inverse subtype "bernstein_polynomials.i" "{i: naturalnumbers.nat | reals.<=(i, bernstein_polynomials.j)}"))) (Bern_structural_decomp_TCC1 0 (Bern_structural_decomp_TCC1-1 nil 3480943595 ("" (subtype-tcc) nil nil) ((Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (Bern_structural_decomp subtype "bernstein_polynomials.i" "naturalnumbers.upto(bernstein_polynomials.b2`index)"))) (Bern_structural_decomp 0 (Bern_structural_decomp-1 nil 3480943595 ("" (skeep) (("" (case "FORALL (mm: nat): (FORALL (bb:Bernstein_Polynomial): ((bb`index >= mm AND (FORALL (j:upto(bb`index)): j>mm IMPLIES bb`bern_seq(j) = 0)) IMPLIES P(bb)))") (("1" (skeep) (("1" (inst - "b`index") (("1" (inst - "b") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "mm") (("1" (skeep) (("1" (inst -4 "0" "bb`index" "bb`bern_seq(0)") (("1" (assert) (("1" (case "bb = (# index := bb`index,
                        bern_seq
                          := LAMBDA (j: upto(bb`index)):
                               IF j = 0 THEN bb`bern_seq(0) ELSE 0 ENDIF #)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (decompose-equality) (("2" (decompose-equality) (("2" (lift-if) (("2" (ground) (("2" (inst - "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (name "bb1" "(# index := bb!1`index, bern_seq := (LAMBDA (i:upto(bb!1`index)): IF i <= j!1 THEN bb!1`bern_seq(i) ELSE 0 ENDIF) #)") (("2" (name "bb2" "(# index := bb!1`index, bern_seq := (LAMBDA (i:upto(bb!1`index)): IF i = 1+j!1 THEN bb!1`bern_seq(1+j!1) ELSE 0 ENDIF) #)") (("1" (inst - "bb1") (("1" (assert) (("1" (split -3) (("1" (inst -6 "bb1" "bb2") (("1" (inst -7 "1+j!1" "bb!1`index" "bb!1`bern_seq(1+j!1)") (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (case "bb!1 = (# index := bb1`index,
                                bern_seq
                                  := LAMBDA (i: upto(bb1`index)):
                                       bb1`bern_seq(i) + bb2`bern_seq(i) #)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (decompose-equality) (("2" (decompose-equality) (("1" (expand "bb1" +) (("1" (expand "bb2" +) (("1" (lift-if) (("1" (lift-if) (("1" (ground) (("1" (typepred "x!1") (("1" (inst - "x!1") (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (ground) nil nil)) nil)) nil) ("2" (skeep) (("2" (expand "bb1" 1) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (ground) nil nil)) nil)) nil) ("2" (skeep) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (bb skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (bb!1 skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (bb1 skolem-const-decl "[# bern_seq: [upto(bb!1`index) -> real], index: nat #]" bernstein_polynomials nil) (real_plus_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bb2 skolem-const-decl "[# bern_seq: [upto(bb!1`index) -> real], index: nat #]" bernstein_polynomials nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak)) (Bernstein_polynomial_TCC1 0 (Bernstein_polynomial_TCC1-1 nil 3479481006 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bernstein_polynomial subtype "bernstein_polynomials.i" "{i: naturalnumbers.nat | reals.<=(i, bernstein_polynomials.s)}"))) (Bernstein_polynomial_TCC2 0 (Bernstein_polynomial_TCC2-1 nil 3479481006 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bernstein_polynomial subtype "bernstein_polynomials.i" "{i: naturalnumbers.nat | reals.<=(i, bernstein_polynomials.m)}"))) (Bernstein_equivalence 0 (Bernstein_equivalence-1 nil 3479481006 ("" (skeep) (("" (case "FORALL (pp: nat): m>=pp IMPLIES polynomial(a, pp) = Bern_poly(Bernstein_polynomial(a, pp, m))") (("1" (inst - "p") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "NAT_induction") (("2" (inst?) (("2" (skeep) (("2" (split -) (("1" (inst - "pp") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (case "j = 0") (("1" (replace -1) (("1" (hide -1) (("1" (hide -1) (("1" (decompose-equality) (("1" (expand "polynomial") (("1" (expand "sigma") (("1" (assert) (("1" (expand "Bern_poly") (("1" (expand "Bernstein_polynomial") (("1" (name "AA" "LAMBDA (i: nat):
                                                                                                            IF i > m THEN 0
                                                                                                            ELSE sigma(0, i,
                                                                                                                       LAMBDA (i_1: nat):
                                                                                                                         IF i_1 > i OR i_1 > 0 THEN 0
                                                                                                                         ELSE a(i_1) * (C(i, i_1) / C(m, i_1))
                                                                                                                         ENDIF)
                                                                                                                  * Bern(i, m)(x!1)
                                                                                                            ENDIF") (("1" (replace -1) (("1" (case "AA = LAMBDA (i: nat): IF i>m THEN 0 ELSE a(0)*Bern(i,m)(x!1) ENDIF") (("1" (replace -1) (("1" (lemma "sigma_scal") (("1" (name "BB" "LAMBDA (i: nat):
                                                                                                                                   IF i > m THEN 0 ELSE Bern(i, m)(x!1) ENDIF") (("1" (inst - "BB" "a(0)" "m" "0") (("1" (case "(LAMBDA (i: nat): a(0) * BB(i)) = AA") (("1" (replace -1) (("1" (replace -4 :dir rl) (("1" (replace -3) (("1" (case "sigma(0,m,BB) = 1") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide (-3 -4 -5)) (("2" (lemma "Bernstein_partition_of_unity") (("2" (inst - "m" "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -3) (("2" (decompose-equality) (("1" (replace -1 :dir rl) (("1" (assert) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1 :dir rl) (("2" (decompose-equality) (("1" (lift-if) (("1" (ground) (("1" (lemma "sigma_split") (("1" (inst - "LAMBDA (i_1: nat):
                                                                  IF i_1 > x!2 OR i_1 > 0 THEN 0
                                                                  ELSE a(i_1) * (C(x!2, i_1) / C(m, i_1))
                                                                  ENDIF" "x!2" "0" "0") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (expand "sigma" 2 1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (i_1: nat):
                                                                           IF i_1 > x!2 OR i_1 > 0 THEN 0
                                                                           ELSE a(i_1) * (C(x!2, i_1) / C(m, i_1))
                                                                           ENDIF" "LAMBDA (i_1: nat):
                                                                           0" "x!2" "1") (("1" (split -) (("1" (lemma "sigma_zero") (("1" (inst - "x!2" "1") (("1" (replace -1) (("1" (mult-by -2 "Bern(x!2, m)(x!1)") (("1" (replace -1) (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "j-1") (("1" (assert) (("1" (name "aa" "LAMBDA (kz:nat): IF kz/=j THEN 0 ELSE a(j) ENDIF") (("1" (case "polynomial(a,j) = polynomial(a,j-1) + polynomial(aa,j)") (("1" (case "Bern_poly(Bernstein_polynomial(a, j, m))=Bern_poly(Bernstein_polynomial(a, j-1, m))+Bern_poly(Bernstein_polynomial(aa, j, m))") (("1" (case "polynomial(aa,j) = Bern_poly(Bernstein_polynomial(aa,j,m))") (("1" (assert) nil nil) ("2" (hide 3) (("2" (hide -1) (("2" (hide -1) (("2" (hide -2) (("2" (decompose-equality) (("2" (expand "polynomial") (("2" (expand "Bernstein_polynomial") (("2" (expand "Bern_poly") (("2" (assert) (("2" (lemma "sigma_split") (("2" (inst - "LAMBDA (i: nat): aa(i) * (IF i = 0 THEN 1 ELSE x!1 ^ i ENDIF)" "j" "0" "j-1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (i: nat): aa(i) * (IF i = 0 THEN 1 ELSE x!1 ^ i ENDIF)" "LAMBDA (i: nat): 0" "j-1" "0") (("2" (split -1) (("1" (lemma "sigma_zero") (("1" (inst?) (("1" (replace -1) (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (expand "sigma" 1 1) (("1" (assert) (("1" (expand "sigma" 1 1) (("1" (case "aa(j) = a(j)") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "Bernstein_conversion_2") (("1" (inst - "m" "j" "x!1") (("1" (assert) (("1" (mult-by -1 "a(j)") (("1" (lemma "sigma_scal") (("1" (inst?) (("1" (inst - "a(j)") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (i_1: nat):
                                       a(j) *
                                        IF i_1 < j OR i_1 > m THEN 0
                                        ELSE (C(i_1, j) / C(m, j)) * Bern(i_1, m)(x!1)
                                        ENDIF" "LAMBDA (i_1: nat):
                                       IF i_1 > m THEN 0
                                       ELSE sigma(0, i_1,
                                                  LAMBDA (i: nat):
                                                    IF i > i_1 OR i > j THEN 0
                                                    ELSE aa(i) * (C(i_1, i) / C(m, i))
                                                    ENDIF)
                                             * Bern(i_1, m)(x!1)
                                       ENDIF" "m" "0") (("1" (assert) (("1" (hide 2) (("1" (hide -1) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (i: nat):
                                             IF i > x!2 OR i > j THEN 0
                                             ELSE aa(i) * (C(x!2, i) / C(m, i))
                                             ENDIF" "LAMBDA (i: nat): 0" "x!2" "0") (("1" (split -1) (("1" (lemma "sigma_zero") (("1" (inst - "x!2" "0") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "restrict") (("2" (decompose-equality) (("1" (lift-if) (("1" (ground) (("1" (replace -2 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (name "BB" "LAMBDA (i: nat):
                                                  IF i > x!2 OR i > j THEN 0
                                                  ELSE aa(i) * (C(x!2, i) / C(m, i))
                                                  ENDIF") (("1" (replace -1) (("1" (lemma "sigma_split") (("1" (inst - "BB" "x!2" "0" "j-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(0,j-1,BB) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (case "x!2 = j") (("1" (replace -1) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (replace -2 :dir rl) (("1" (assert) (("1" (replace -3 + :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_split") (("2" (inst - "BB" "x!2" "j" "j") (("2" (assert) (("2" (case "sigma(1+j,x!2,BB) = 0") (("1" (replace -1) (("1" (assert) (("1" (replace -2) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (replace -3 + :dir rl) (("1" (assert) (("1" (replace -4 + :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_restrict_eq") (("2" (inst - "BB" "LAMBDA (i:nat): 0" "x!2" "1+j") (("2" (split -1) (("1" (lemma "sigma_zero") (("1" (inst - "x!2" "1+j") (("1" (assert) nil nil)) nil)) nil) ("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (replace -2 + :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_restrict_eq") (("2" (inst - "BB" "LAMBDA (i:nat): 0" "j-1" "0") (("2" (split -1) (("1" (lemma "sigma_zero") (("1" (inst - "j-1" "0") (("1" (assert) nil nil)) nil)) nil) ("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (replace -1 + :dir rl) (("2" (assert) (("2" (replace -2 :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("1" (replace -2 :dir rl) (("1" (assert) nil nil)) nil) ("2" (replace -1 :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (expand "+" 1) (("2" (expand "Bern_poly" 1) (("2" (expand "Bernstein_polynomial" 1) (("2" (name "AA" "LAMBDA (i: nat):
                                 IF i > m THEN 0
                                 ELSE sigma(0, i,
                                            LAMBDA (i_1: nat):
                                              IF i_1 > i OR i_1 > j THEN 0
                                              ELSE a(i_1) * (C(i, i_1) / C(m, i_1))
                                              ENDIF)
                                       * Bern(i, m)(x!1)
                                 ENDIF") (("1" (replace -1) (("1" (name "BB" "LAMBDA (i: nat):
                                    IF i > m THEN 0
                                    ELSE sigma(0, i,
                                               LAMBDA (i_1: nat):
                                                 IF i_1 > i OR i_1 > j THEN 0
                                                 ELSE aa(i_1) * (C(i, i_1) / C(m, i_1))
                                                 ENDIF)
                                          * Bern(i, m)(x!1)
                                    ENDIF") (("1" (replace -1) (("1" (name "CC" "LAMBDA (i: nat):
                                     IF i > m THEN 0
                                     ELSE sigma(0, i,
                                                LAMBDA (i_1: nat):
                                                  IF i_1 > i OR i_1 > j - 1 THEN 0
                                                  ELSE a(i_1) * (C(i, i_1) / C(m, i_1))
                                                  ENDIF)
                                           * Bern(i, m)(x!1)
                                     ENDIF") (("1" (replace -1) (("1" (case "AA = (LAMBDA (i:nat): BB(i)+CC(i))") (("1" (lemma "sigma_sum") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide 3) (("2" (decompose-equality) (("2" (replace -1 :dir rl) (("2" (assert) (("2" (replace -2 :dir rl) (("2" (assert) (("2" (replace -3 :dir rl) (("2" (assert) (("2" (lift-if) (("2" (ground) (("2" (hide -1) (("2" (hide -1) (("2" (hide -1) (("2" (name "DD" "LAMBDA (i_1: nat):
                                       IF i_1 > x!2 OR i_1 > j THEN 0
                                       ELSE a(i_1) * (C(x!2, i_1) / C(m, i_1))
                                       ENDIF") (("1" (replace -1) (("1" (name "EE" "LAMBDA (i_1: nat):
                                          IF i_1 > x!2 OR i_1 > j - 1 THEN 0
                                          ELSE a(i_1) * (C(x!2, i_1) / C(m, i_1))
                                          ENDIF") (("1" (replace -1) (("1" (name "FF" "LAMBDA (i_1: nat):
                                             IF i_1 > x!2 OR i_1 > j THEN 0
                                             ELSE aa(i_1) * (C(x!2, i_1) / C(m, i_1))
                                             ENDIF") (("1" (replace -1) (("1" (case "DD = (LAMBDA (i:nat): EE(i)+FF(i))") (("1" (lemma "sigma_sum") (("1" (inst - "EE" "FF" "x!2" "0") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 3) (("2" (decompose-equality) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (assert) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (ground) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (replace -3 :dir rl) (("1" (assert) nil nil)) nil) ("2" (replace -2 :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (expand "+" 1) (("2" (expand "polynomial" 1) (("2" (expand "sigma" 1 1) (("2" (lemma "sigma_split") (("2" (inst - "LAMBDA (i: nat): aa(i) * (IF i = 0 THEN 1 ELSE x!1 ^ i ENDIF)" "j" "0" "j-1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (expand "sigma" 1 2) (("2" (expand "sigma" 1 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (i: nat): aa(i) * (IF i = 0 THEN 1 ELSE x!1 ^ i ENDIF)" "LAMBDA (i: nat): 0" "j-1" "0") (("2" (lemma "sigma_zero") (("2" (inst - "j-1" "0") (("2" (assert) (("2" (replace -3 :dir rl) (("2" (assert) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bernstein_polynomial const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (polynomial const-decl "[real -> real]" polynomials nil) (sequence type-eq-decl nil sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NAT_induction formula-decl nil naturalnumbers nil) (sigma def-decl "real" sigma nil) (Bern const-decl "real" bernstein_polynomials nil) (above nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (C const-decl "posnat" binomial nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (sigma_scal formula-decl nil sigma nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (m skolem-const-decl "nat" bernstein_polynomials nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (Bernstein_partition_of_unity formula-decl nil bernstein_polynomials nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (x!2 skolem-const-decl "nat" bernstein_polynomials nil) (sigma_restrict_eq formula-decl nil sigma nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (sigma_nat application-judgement "nat" sigma_nat nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (factorial_0 formula-decl nil factorial ints) (sigma_zero formula-decl nil sigma nil) (restrict const-decl "[T -> real]" sigma nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_split formula-decl nil sigma nil) (sigma_0_neg formula-decl nil sigma_nat nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (+ const-decl "[T -> real]" real_fun_ops nil) (sigma_sum formula-decl nil sigma nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (< const-decl "bool" reals nil) (x!2 skolem-const-decl "nat" bernstein_polynomials nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Bernstein_conversion_2 formula-decl nil bernstein_polynomials nil) (^ const-decl "real" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (j skolem-const-decl "nat" bernstein_polynomials nil) (pred type-eq-decl nil defined_types nil)) shostak)) (Bern_poly_inverse_def 0 (Bern_poly_inverse_def-1 nil 3479635199 ("" (skeep) (("" (decompose-equality) (("" (expand "polynomial") (("" (case "NOT (LAMBDA (i: nat):
                            Bern_poly_inverse(b)(i) *
                             (IF i = 0 THEN 1 ELSE x!1 ^ i ENDIF)) = (LAMBDA (i: nat):
                            Bern_poly_inverse(b)(i) * x!1^i)") (("1" (hide 2) (("1" (decompose-equality) (("1" (lift-if) (("1" (ground) (("1" (replace -1) (("1" (expand "^") (("1" (expand "expt") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (expand "Bern_poly") (("2" (lemma "Bern_Polynomial") (("2" (expand "polynomial") (("2" (case "NOT (LAMBDA (i: nat):
                                 IF i > b`index THEN 0
                                 ELSE b`bern_seq(i) * Bern(i, b`index)(x!1)
                                 ENDIF) =
                               (LAMBDA (i: nat):
                                 sigma(i,b`index,(LAMBDA (j:nat): IF j < i OR j > b`index OR i>b`index THEN 0 ELSE b`bern_seq(i)*(-1)^(j-i)*(C(b`index,j)*C(j,i))*x!1^j ENDIF)))") (("1" (hide 2) (("1" (decompose-equality) (("1" (lift-if) (("1" (ground) (("1" (lemma "sigma_zero") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst - "x!2" "b`index") (("2" (replace -1) (("2" (hide -1) (("2" (assert) (("2" (name "AA" "LAMBDA (i_1: nat):
                              IF i_1 < x!2 OR i_1 > b`index THEN 0
                              ELSE C(i_1, x!2) * C(b`index, i_1) * (-1) ^ (i_1 - x!2)
                              ENDIF
                               * (IF i_1 = 0 THEN 1 ELSE x!1 ^ i_1 ENDIF)") (("1" (name "BB" "LAMBDA (j: nat):
                                IF j < x!2 OR j > b`index THEN 0
                                ELSE b`bern_seq(x!2) * (-1) ^ (j - x!2) * x!1 ^ j *
                                      (C(b`index, j) * C(j, x!2))
                                ENDIF") (("1" (replace -1) (("1" (replace -2) (("1" (lemma "sigma_split") (("1" (inst - "AA" "b`index" "0" "x!2-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(0,x!2-1,AA) = 0") (("1" (replace -1) (("1" (assert) (("1" (hide -1) (("1" (rewrite "sigma_scal" :dir rl) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 3) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (replace -1 :dir rl) (("1" (replace -2 :dir rl) (("1" (assert) (("1" (case "IF x!3 = 0 THEN 1 ELSE x!1 ^ x!3 ENDIF = x!1^x!3") (("1" (assert) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 4) (("2" (lift-if) (("2" (ground) (("2" (replace -1) (("2" (expand "^") (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_zero") (("2" (inst - "x!2-1" "0") (("2" (lemma "sigma_restrict_eq") (("2" (inst - "AA" "LAMBDA (i:nat): 0" "x!2-1" "0") (("2" (assert) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (replace -3 2 :dir rl) (("2" (assert) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (name "F" "(LAMBDA (i,j:nat): IF j < i OR j > b`index OR i > b`index THEN 0
                         ELSE b`bern_seq(i) * (-1) ^ (j - i) *
                               (C(b`index, j) * C(j, i))
                               * x!1 ^ j
                         ENDIF)") (("2" (lemma "sigma_swap_triangle") (("2" (inst - "F" "b`index" "b`index" "0") (("2" (assert) (("2" (case "(LAMBDA (i: nat):
                sigma(i, b`index,
                      (LAMBDA (j: nat):
                         IF j < i OR j > b`index OR i > b`index THEN 0
                         ELSE b`bern_seq(i) * C(j, i) * C(b`index, j) *
                               (-1) ^ (j - i)
                               * x!1 ^ j
                         ENDIF))) = (LAMBDA (i: nat): sigma(i, b`index, LAMBDA (j: nat): F(i, j)))") (("1" (replace -1) (("1" (hide -1) (("1" (replace -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "(LAMBDA (i: nat): Bern_poly_inverse(b)(i) * x!1 ^ i)" "(LAMBDA (j: nat): sigma(0, j, LAMBDA (i: nat): F(i, j)))" "b`index" "0") (("1" (assert) (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (expand "Bern_poly_inverse") (("1" (name "CC" "LAMBDA (i: nat):
              IF i > x!2 THEN 0
              ELSE b`bern_seq(i) * C(b`index, x!2) * C(x!2, i) *
                    (-1) ^ (x!2 - i)
              ENDIF") (("1" (replace -1) (("1" (lemma "sigma_scal") (("1" (inst - "CC" "x!1^x!2" "x!2" "0") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 3) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (expand "CC" +) (("1" (expand "F" +) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (decompose-equality) (("1" (lemma "sigma_eq") (("1" (inst - "LAMBDA (j: nat):
              IF j < x!2 OR j > b`index OR x!2 > b`index THEN 0
              ELSE b`bern_seq(x!2) * C(j, x!2) * C(b`index, j) *
                    (-1) ^ (j - x!2)
                    * x!1 ^ j
              ENDIF" "LAMBDA (j: nat): F(x!2, j)" "b`index" "x!2") (("1" (assert) (("1" (hide 2) (("1" (skosimp*) (("1" (expand "F" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil) ("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sequence type-eq-decl nil sequences nil) (polynomial const-decl "[real -> real]" polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (Bern_poly_inverse const-decl "sequence[real]" bernstein_polynomials nil) (Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (expt def-decl "real" exponentiation nil) (Bern_Polynomial formula-decl nil bernstein_polynomials nil) (C const-decl "posnat" binomial nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (sigma def-decl "real" sigma nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (Bern const-decl "real" bernstein_polynomials nil) (above nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (sigma_nat application-judgement "nat" sigma_nat nil) (sigma_zero formula-decl nil sigma nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (rat_exp application-judgement "rat" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (sigma_split formula-decl nil sigma nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (sigma_restrict_eq formula-decl nil sigma nil) (restrict const-decl "[T -> real]" sigma nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (sigma_scal formula-decl nil sigma nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_swap_triangle formula-decl nil sigma_swap nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (x!2 skolem-const-decl "nat" bernstein_polynomials nil) (sigma_eq formula-decl nil sigma nil) (CC skolem-const-decl "[nat -> real]" bernstein_polynomials nil) (F skolem-const-decl "[[nat, nat] -> real]" bernstein_polynomials nil)) shostak)) (Bern_subdiv_left_TCC1 0 (Bern_subdiv_left_TCC1-1 nil 3485777030 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bern_subdiv_left subtype "bernstein_polynomials.j" "{i_1: naturalnumbers.nat | reals.<=(i_1, bernstein_polynomials.i)}"))) (Bern_subdiv_left_TCC2 0 (Bern_subdiv_left_TCC2-1 nil 3485777030 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bern_subdiv_left subtype "bernstein_polynomials.j" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (Bern_subdiv_right_TCC1 0 (Bern_subdiv_right_TCC1-1 nil 3485768080 ("" (subtype-tcc) nil nil) nil nil (Bern_subdiv_right subtype "(number_fields.-)(bernstein_polynomials.b`index, bernstein_polynomials.i)" "nat"))) (Bern_subdiv_right_TCC2 0 (Bern_subdiv_right_TCC2-1 nil 3485768080 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bern_subdiv_right subtype "bernstein_polynomials.j" "{i_1: naturalnumbers.nat | reals.<=(i_1, (number_fields.-)(bernstein_polynomials.b`index, bernstein_polynomials.i))}"))) (Bern_subdiv_right_TCC3 0 (Bern_subdiv_right_TCC3-1 nil 3485768080 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bern_subdiv_right subtype "(number_fields.-)(bernstein_polynomials.b`index, bernstein_polynomials.j)" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (Bern_subdiv_left_id 0 (Bern_subdiv_left_id-2 nil 3485777078 ("" (skeep) (("" (case "FORALL (xx :real): Bern_poly(Bern_subdiv_left(b))(xx) =
                                   (Bern_poly(b) o (LAMBDA (x: real): (1 / 2) * x))(xx)") (("1" (decompose-equality 1) nil nil) ("2" (hide 2) (("2" (skeep 1) (("2" (name "aa" "Bern_poly_inverse(b)") (("2" (lemma "Bern_poly_inverse_def") (("2" (inst - "b") (("2" (replace -2) (("2" (replace -1 :dir rl) (("2" (expand "o") (("2" (name "nn" "b`index") (("2" (replace -1) (("2" (name "az" "(LAMBDA (i:nat): (1/2^i)*aa(i))") (("2" (case "NOT polynomial(az,nn)(xx) = polynomial(aa,nn)((1/2)*xx)") (("1" (hide 2) (("1" (expand "polynomial" +) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (replace -1) (("1" (expand "az" +) (("1" (expand "^" +) (("1" (expand "expt" +) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "mult_expt") (("2" (inst - "x!1" "1/2" "xx") (("1" (replace -1) (("1" (hide -1) (("1" (expand "az" +) (("1" (lemma "div_expt") (("1" (inst - "x!1" "1" "2") (("1" (replace -1) (("1" (hide -1) (("1" (case "1^x!1 = 1") (("1" (assert) nil nil) ("2" (case "FORALL (jjj:nat): 1^jjj = 1") (("1" (inst - "x!1") nil nil) ("2" (induct "jjj") (("1" (expand "^" 1) (("1" (expand "expt" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (skeep 1) (("2" (expand "^") (("2" (expand "expt" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (expand "^" +) (("2" (expand "expt" +) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (lemma "Bernstein_equivalence") (("2" (inst - "az" "nn" "nn") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (expand "Bernstein_polynomial") (("2" (assert) (("2" (expand "az" 1) (("2" (expand "aa" 1) (("2" (expand "Bern_poly_inverse" 1) (("2" (case "Bern_subdiv_left(b) = (# index := nn,
                                                                bern_seq
                                                                  := LAMBDA (s: upto(nn)):
                                                                       sigma(0, s,
                                                                             LAMBDA (i: nat):
                                                                               IF i > s OR i > nn THEN 0
                                                                               ELSE sigma
                                                                                    (0,
                                                                                     i,
                                                                                     LAMBDA
                                                                                     (i_1: nat):
                                                                                     IF i_1 > i
                                                                                     THEN 0
                                                                                     ELSE b`bern_seq(i_1) * C(i, i_1)
                                                                                          *
                                                                                          C(b`index, i)
                                                                                          *
                                                                                          (-1) ^ (i - i_1)
                                                                                     ENDIF)
                                                                                    *
                                                                                    (1 / 2 ^ i)
                                                                                    *
                                                                                    (C(s, i) / C(nn, i))
                                                                               ENDIF) #)") (("1" (replaces -1) nil nil) ("2" (hide 2) (("2" (expand "Bern_subdiv_left") (("2" (replace -2) (("2" (decompose-equality 1) (("1" (lemma "sigma_swap_triangle") (("1" (name "F" "LAMBDA (j,i:nat): IF i > x!1 OR i > nn OR j > i THEN 0 ELSE (1/2^i)*(C(x!1, i) / C(nn, i))*b`bern_seq(j) * C(i, j) * C(nn, i) *
                                                                                              (-1) ^ (i - j) ENDIF") (("1" (case "NOT sigma(0, x!1,
                                                                                 LAMBDA (i: nat):
                                                                                   IF i > x!1 OR i > nn THEN 0
                                                                                   ELSE sigma(0, i,
                                                                                              LAMBDA (i_1: nat):
                                                                                                IF i_1 > i THEN 0
                                                                                                ELSE b`bern_seq(i_1) * C(i, i_1) * C(nn, i) *
                                                                                                      (-1) ^ (i - i_1)
                                                                                                ENDIF)
                                                                                         * (1 / 2 ^ i)
                                                                                         * (C(x!1, i) / C(nn, i))
                                                                                   ENDIF) = sigma(0,x!1,(LAMBDA (i:nat): sigma(0,i,(LAMBDA (j:nat):F(j,i)))))") (("1" (hide 2) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (lemma "sigma_scal") (("1" (inst - "LAMBDA (i_2: nat):
                                                                                      IF i_2 > x!2 THEN 0
                                                                                      ELSE b`bern_seq(i_2) * C(nn, x!2) * C(x!2, i_2) *
                                                                                            (-1) ^ (x!2 - i_2)
                                                                                      ENDIF" "(1 / 2 ^ x!2)
                                                                               * (C(x!1, x!2) / C(nn, x!2))" "x!2" "0") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 3) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (expand "F" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (inst - "F" "x!1" "x!1" "0") (("2" (assert) (("2" (case "(1 / 2 ^ x!1) *
                                                                                   sigma(0, x!1,
                                                                                         LAMBDA (j: nat):
                                                                                           IF j > x!1 THEN 0 ELSE C(x!1, j) * b`bern_seq(j) ENDIF) = sigma(0, x!1,
                                                                                        LAMBDA (j: nat): sigma(j, x!1, LAMBDA (i: nat): F(j, i)))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "sigma_scal") (("2" (inst - "LAMBDA (j: nat):
                                                                               IF j > x!1 THEN 0 ELSE C(x!1, j) * b`bern_seq(j) ENDIF" "1/2^x!1" "x!1" "0") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict" 1) (("1" (lift-if) (("1" (ground) (("1" (expand "F" +) (("1" (hide -1) (("1" (hide -1) (("1" (case "C(x!1, x!2) =
                                                                                                                   sigma(x!2, x!1,
                                                                                                                         LAMBDA (i: nat):
                                                                                                                           IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                                                                                           ELSE C(i, x!2) * C(nn, i) *
                                                                                                                                 (-1) ^ (i - x!2)
                                                                                                                                 * (1 / 2 ^ (i-x!1))
                                                                                                                                 * (C(x!1, i) / C(nn, i))
                                                                                                                           ENDIF)") (("1" (mult-by -1 "1/2^x!1 * b`bern_seq(x!2)") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_scal") (("1" (inst - "LAMBDA (i: nat):
                                                                                                                      IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                                                                                      ELSE C(i, x!2) * C(nn, i) * (-1) ^ (i - x!2) *
                                                                                                                            (1 / 2 ^ (i - x!1))
                                                                                                                            * (C(x!1, i) / C(nn, i))
                                                                                                                      ENDIF" "(1 / 2 ^ x!1 * b`bern_seq(x!2))" "x!1" "x!2") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 3) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case " (1 / 2 ^ (x!3 - x!1))
                                                                                                       * (1 / 2 ^ x!1) = 1/2^x!3") (("1" (replace -1 :dir rl) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 2 3)) (("2" (case "2^(x!3-x!1)*2^x!1 = 2^x!3") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "expt_plus") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("2" (hide 3) (("2" (case "C(x!1, x!2) =
                                                                                              sigma(x!2, x!1,
                                                                                                    LAMBDA (i: nat):
                                                                                                      IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                                                                      ELSE C(i, x!2)*C(x!1, i) * (-1) ^ (i - x!2) *
                                                                                                            (1 / 2 ^ (i - x!1))
                                                                                                      ENDIF)") (("1" (assert) (("1" (replace -1 +) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "binom_trinomial_revision") (("2" (case "NOT (LAMBDA (i: nat):
                                                                                                            IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                                                                            ELSE C(i, x!2) * C(x!1, i) * (-1) ^ (i - x!2) *
                                                                                                                  (1 / 2 ^ (i - x!1))
                                                                                                            ENDIF) = (LAMBDA (i: nat):
                                                                                                            IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                                                                            ELSE C(x!1,x!2)*C(x!1-x!2,i-x!2) * (-1) ^ (i - x!2) *
                                                                                                                  (1 / 2 ^ (i - x!1))
                                                                                                            ENDIF)") (("1" (hide 2) (("1" (decompose-equality 1) (("1" (lift-if) (("1" (ground) (("1" (inst - "x!2" "x!3" "x!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (case "sigma(x!2, x!1,
                                                                                                                (LAMBDA (i: nat):
                                                                                                                   IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                                                                                   ELSE C(x!1 - x!2, i - x!2) * (-1) ^ (i - x!2)
                                                                                                                         * (1 / 2 ^ (i - x!1))
                                                                                                                   ENDIF)) = 1") (("1" (mult-by -1 "C(x!1,x!2)") (("1" (case "sigma(x!2, x!1,
                                                                                                            (LAMBDA (i: nat):
                                                                                                               IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                                                                               ELSE C(x!1 - x!2, i - x!2) * (-1) ^ (i - x!2) *
                                                                                                                     (1 / 2 ^ (i - x!1))
                                                                                                               ENDIF))
                                                                                                       * C(x!1, x!2) = sigma(x!2, x!1,
                                                                                                             (LAMBDA (i: nat):
                                                                                                                IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                                                                                ELSE C(x!1, x!2) * C(x!1 - x!2, i - x!2) * (-1) ^ (i - x!2)
                                                                                                                      * (1 / 2 ^ (i - x!1))
                                                                                                                ENDIF))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (lemma "sigma_scal") (("2" (inst - "(LAMBDA (i: nat):
                                                                                                                     IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                                                                                     ELSE C(x!1 - x!2, i - x!2) * (-1) ^ (i - x!2) *
                                                                                                                           (1 / 2 ^ (i - x!1))
                                                                                                                     ENDIF)" "C(x!1,x!2)" "x!1" "x!2") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -1) (("2" (lemma "sigma_shift_T2") (("2" (inst - "(LAMBDA (i: nat):
                                                                                                         IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                                                                         ELSE C(x!1 - x!2, i - x!2) * (-1) ^ (i - x!2) *
                                                                                                               (1 / 2 ^ (i - x!1))
                                                                                                         ENDIF)" "x!1-x!2" "0" "x!2") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "binomial_theorem") (("1" (inst - "x!1-x!2" "-1" "2") (("1" (assert) (("1" (lemma "expt_1i") (("1" (inst - "x!1-x!2") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (i: nat):
                                                                                                               IF i > x!1 - x!2 THEN 0
                                                                                                               ELSE (C(x!1 - x!2, i) * 2 ^ (-1 * i - x!2 + x!1)) * (-1) ^ i
                                                                                                               ENDIF" "LAMBDA (i_1: nat):
                                                                                                              IF i_1 + x!2 > x!1 OR i_1 + x!2 > nn THEN 0
                                                                                                              ELSE C(x!1 - x!2, i_1) * (-1) ^ i_1 *
                                                                                                                    (1 / 2 ^ (i_1 - x!1 + x!2))
                                                                                                              ENDIF" "x!1-x!2" "0") (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (lemma "expt_plus") (("1" (inst - "x!2-x!1+x!3" "x!1-x!2-x!3" "2") (("1" (lemma "expt_x0") (("1" (inst - "2") (("1" (assert) (("1" (replace -1) (("1" (cross-mult 2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil) ("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (ground) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil) ("7" (skosimp*) (("7" (assert) nil nil)) nil) ("8" (skosimp*) (("8" (assert) nil nil)) nil) ("9" (skosimp*) (("9" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil) ("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (O const-decl "T3" function_props nil) (Bern_subdiv_left const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_times_real_is_real application-judgement "real" reals nil) (Bern_poly_inverse_def formula-decl nil bernstein_polynomials nil) (NOT const-decl "[bool -> bool]" booleans nil) (polynomial const-decl "[real -> real]" polynomials nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (<= const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (az skolem-const-decl "[nat -> real]" bernstein_polynomials nil) (expt def-decl "real" exponentiation nil) (xx skolem-const-decl "real" bernstein_polynomials nil) (nzreal nonempty-type-eq-decl nil reals nil) (div_expt formula-decl nil exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (mult_expt formula-decl nil exponentiation nil) (restrict const-decl "[T -> real]" sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (sigma_restrict_eq formula-decl nil sigma nil) (Bernstein_polynomial const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (rat_exp application-judgement "rat" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (sigma_swap_triangle formula-decl nil sigma_swap nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_scal formula-decl nil sigma nil) (F skolem-const-decl "[[nat, nat] -> real]" bernstein_polynomials nil) (x!2 skolem-const-decl "nat" bernstein_polynomials nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (x!1 skolem-const-decl "upto(b`index)" bernstein_polynomials nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (sigma_rat application-judgement "rational" sigma_nat nil) (expt_plus formula-decl nil exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (x!2 skolem-const-decl "nat" bernstein_polynomials nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (binom_trinomial_revision formula-decl nil binomial_identities nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (sigma_shift_T2 formula-decl nil sigma nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (expt_1i formula-decl nil exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (expt_x0 formula-decl nil exponentiation nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div1 formula-decl nil real_props nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (div_cancel4 formula-decl nil real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (binomial_theorem formula-decl nil polynomials nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (nn skolem-const-decl "nat" bernstein_polynomials nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (C const-decl "posnat" binomial nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (sigma def-decl "real" sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (aa skolem-const-decl "sequence[real]" bernstein_polynomials nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Bernstein_equivalence formula-decl nil bernstein_polynomials nil) (^ const-decl "real" exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (posint_exp application-judgement "posint" exponentiation nil) (Bern_poly_inverse const-decl "sequence[real]" bernstein_polynomials nil) (sequence type-eq-decl nil sequences nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil)) nil) (Bern_subdiv_left_id-1 nil 3485777043 ("" (skeep) (("" (case "FORALL (xx :real): Bern_poly(Bern_subdiv_right(b))(xx) =
                     (Bern_poly(b) o (LAMBDA (x: real): (1 / 2) * x))(xx)") (("1" (decompose-equality 1) nil) ("2" (hide 2) (("2" (skeep 1) (("2" (name "aa" "Bern_poly_inverse(b)") (("2" (lemma "Bern_poly_inverse_def") (("2" (inst - "b") (("2" (replace -2) (("2" (replace -1 :dir rl) (("2" (expand "o") (("2" (name "nn" "b`index") (("2" (replace -1) (("2" (name "az" "(LAMBDA (i:nat): (1/2^i)*aa(i))") (("2" (case "NOT polynomial(az,nn)(xx) = polynomial(aa,nn)((1/2)*xx)") (("1" (hide 2) (("1" (expand "polynomial" +) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (replace -1) (("1" (expand "az" +) (("1" (expand "^" +) (("1" (expand "expt" +) (("1" (assert) nil))))))))) ("2" (lemma "mult_expt") (("2" (inst - "x!1" "1/2" "xx") (("1" (replace -1) (("1" (hide -1) (("1" (expand "az" +) (("1" (lemma "div_expt") (("1" (inst - "x!1" "1" "2") (("1" (replace -1) (("1" (hide -1) (("1" (case "1^x!1 = 1") (("1" (assert) nil) ("2" (case "FORALL (jjj:nat): 1^jjj = 1") (("1" (inst - "x!1") nil) ("2" (induct "jjj") (("1" (expand "^" 1) (("1" (expand "expt" 1) (("1" (propax) nil))))) ("2" (skeep 1) (("2" (expand "^") (("2" (expand "expt" 1) (("2" (assert) nil))))))))))))))))))))))))))) ("2" (flatten) (("2" (replace -1) (("2" (expand "^" +) (("2" (expand "expt" +) (("2" (propax) nil))))))))))))))))))))))))))))))))) ("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (lemma "Bernstein_equivalence") (("2" (inst - "az" "nn" "nn") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (expand "Bernstein_polynomial") (("2" (assert) (("2" (expand "az" 1) (("2" (expand "aa" 1) (("2" (expand "Bern_poly_inverse" 1) (("2" (case "Bern_subdiv_right(b) = (# index := nn,
                                          bern_seq
                                            := LAMBDA (s: upto(nn)):
                                                 sigma(0, s,
                                                       LAMBDA (i: nat):
                                                         IF i > s OR i > nn THEN 0
                                                         ELSE sigma
                                                              (0,
                                                               i,
                                                               LAMBDA
                                                               (i_1: nat):
                                                               IF i_1 > i
                                                               THEN 0
                                                               ELSE b`bern_seq(i_1) * C(i, i_1)
                                                                    *
                                                                    C(b`index, i)
                                                                    *
                                                                    (-1) ^ (i - i_1)
                                                               ENDIF)
                                                              *
                                                              (1 / 2 ^ i)
                                                              *
                                                              (C(s, i) / C(nn, i))
                                                         ENDIF) #)") (("1" (assert) nil) ("2" (hide 2) (("2" (expand "Bern_subdiv_right") (("2" (replace -2) (("2" (decompose-equality 1) (("1" (lemma "sigma_swap_triangle") (("1" (name "F" "LAMBDA (j,i:nat): IF i > x!1 OR i > nn OR j > i THEN 0 ELSE (1/2^i)*(C(x!1, i) / C(nn, i))*b`bern_seq(j) * C(i, j) * C(nn, i) *
                                                                (-1) ^ (i - j) ENDIF") (("1" (case "NOT sigma(0, x!1,
                                               LAMBDA (i: nat):
                                                 IF i > x!1 OR i > nn THEN 0
                                                 ELSE sigma(0, i,
                                                            LAMBDA (i_1: nat):
                                                              IF i_1 > i THEN 0
                                                              ELSE b`bern_seq(i_1) * C(i, i_1) * C(nn, i) *
                                                                    (-1) ^ (i - i_1)
                                                              ENDIF)
                                                       * (1 / 2 ^ i)
                                                       * (C(x!1, i) / C(nn, i))
                                                 ENDIF) = sigma(0,x!1,(LAMBDA (i:nat): sigma(0,i,(LAMBDA (j:nat):F(j,i)))))") (("1" (hide 2) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (lemma "sigma_scal") (("1" (inst - "LAMBDA (i_2: nat):
                                                  IF i_2 > x!2 THEN 0
                                                  ELSE b`bern_seq(i_2) * C(nn, x!2) * C(x!2, i_2) *
                                                        (-1) ^ (x!2 - i_2)
                                                  ENDIF" "(1 / 2 ^ x!2)
                                           * (C(x!1, x!2) / C(nn, x!2))" "x!2" "0") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 3) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (expand "F" +) (("1" (propax) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))))))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))) ("5" (skosimp*) (("5" (assert) nil))) ("6" (skosimp*) (("6" (assert) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))) ("5" (skosimp*) (("5" (assert) nil))) ("6" (skosimp*) (("6" (assert) nil))))))))) ("2" (replace -1) (("2" (hide -1) (("2" (inst - "F" "x!1" "x!1" "0") (("2" (assert) (("2" (case "(1 / 2 ^ x!1) *
                                             sigma(0, x!1,
                                                   LAMBDA (j: nat):
                                                     IF j > x!1 THEN 0 ELSE C(x!1, j) * b`bern_seq(j) ENDIF) = sigma(0, x!1,
                                                  LAMBDA (j: nat): sigma(j, x!1, LAMBDA (i: nat): F(j, i)))") (("1" (assert) nil) ("2" (hide 2) (("2" (lemma "sigma_scal") (("2" (inst - "LAMBDA (j: nat):
                                               IF j > x!1 THEN 0 ELSE C(x!1, j) * b`bern_seq(j) ENDIF" "1/2^x!1" "x!1" "0") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict" 1) (("1" (lift-if) (("1" (ground) (("1" (expand "F" +) (("1" (hide -1) (("1" (hide -1) (("1" (case "C(x!1, x!2) =
                                                             sigma(x!2, x!1,
                                                                   LAMBDA (i: nat):
                                                                     IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                                     ELSE C(i, x!2) * C(nn, i) *
                                                                           (-1) ^ (i - x!2)
                                                                           * (1 / 2 ^ (i-x!1))
                                                                           * (C(x!1, i) / C(nn, i))
                                                                     ENDIF)") (("1" (mult-by -1 "1/2^x!1 * b`bern_seq(x!2)") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_scal") (("1" (inst - "LAMBDA (i: nat):
                                                                  IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                                  ELSE C(i, x!2) * C(nn, i) * (-1) ^ (i - x!2) *
                                                                        (1 / 2 ^ (i - x!1))
                                                                        * (C(x!1, i) / C(nn, i))
                                                                  ENDIF" "(1 / 2 ^ x!1 * b`bern_seq(x!2))" "x!1" "x!2") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 3) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case " (1 / 2 ^ (x!3 - x!1))
                                       * (1 / 2 ^ x!1) = 1/2^x!3") (("1" (replace -1 :dir rl) (("1" (assert) nil))) ("2" (hide-all-but (1 2 3)) (("2" (case "2^(x!3-x!1)*2^x!1 = 2^x!3") (("1" (assert) nil) ("2" (hide 2) (("2" (lemma "expt_plus") (("2" (inst?) (("2" (assert) nil))))))))))))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))))) ("2" (hide 3) (("2" (case "C(x!1, x!2) =
                                    sigma(x!2, x!1,
                                          LAMBDA (i: nat):
                                            IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                            ELSE C(i, x!2)*C(x!1, i) * (-1) ^ (i - x!2) *
                                                  (1 / 2 ^ (i - x!1))
                                            ENDIF)") (("1" (assert) (("1" (replace -1 +) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) nil))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))))))))))) ("2" (hide 2) (("2" (lemma "binom_trinomial_revision") (("2" (case "NOT (LAMBDA (i: nat):
                                              IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                              ELSE C(i, x!2) * C(x!1, i) * (-1) ^ (i - x!2) *
                                                    (1 / 2 ^ (i - x!1))
                                              ENDIF) = (LAMBDA (i: nat):
                                              IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                              ELSE C(x!1,x!2)*C(x!1-x!2,i-x!2) * (-1) ^ (i - x!2) *
                                                    (1 / 2 ^ (i - x!1))
                                              ENDIF)") (("1" (hide 2) (("1" (decompose-equality 1) (("1" (lift-if) (("1" (ground) (("1" (inst - "x!2" "x!3" "x!1") (("1" (assert) nil))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))))))) ("2" (replace -1) (("2" (hide -1) (("2" (case "sigma(x!2, x!1,
                                              (LAMBDA (i: nat):
                                                 IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                 ELSE C(x!1 - x!2, i - x!2) * (-1) ^ (i - x!2)
                                                       * (1 / 2 ^ (i - x!1))
                                                 ENDIF)) = 1") (("1" (mult-by -1 "C(x!1,x!2)") (("1" (case "sigma(x!2, x!1,
                                            (LAMBDA (i: nat):
                                               IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                               ELSE C(x!1 - x!2, i - x!2) * (-1) ^ (i - x!2) *
                                                     (1 / 2 ^ (i - x!1))
                                               ENDIF))
                                       * C(x!1, x!2) = sigma(x!2, x!1,
                                             (LAMBDA (i: nat):
                                                IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                ELSE C(x!1, x!2) * C(x!1 - x!2, i - x!2) * (-1) ^ (i - x!2)
                                                      * (1 / 2 ^ (i - x!1))
                                                ENDIF))") (("1" (assert) nil) ("2" (hide 2) (("2" (lemma "sigma_scal") (("2" (inst - "(LAMBDA (i: nat):
                                                 IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                                 ELSE C(x!1 - x!2, i - x!2) * (-1) ^ (i - x!2) *
                                                       (1 / 2 ^ (i - x!1))
                                                 ENDIF)" "C(x!1,x!2)" "x!1" "x!2") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) nil))))) ("2" (skosimp*) (("2" (assert) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))))))))))) ("2" (skosimp*) (("2" (assert) nil))))))))))) ("2" (skosimp*) (("2" (assert) nil))))) ("2" (assert) (("2" (hide 2) (("2" (hide -1) (("2" (lemma "sigma_shift_T2") (("2" (inst - "(LAMBDA (i: nat):
                                             IF i > x!1 OR i > nn OR x!2 > i THEN 0
                                             ELSE C(x!1 - x!2, i - x!2) * (-1) ^ (i - x!2) *
                                                   (1 / 2 ^ (i - x!1))
                                             ENDIF)" "x!1-x!2" "0" "x!2") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "binomial_theorem") (("1" (inst - "x!1-x!2" "-1" "2") (("1" (assert) (("1" (lemma "expt_1i") (("1" (inst - "x!1-x!2") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (i: nat):
                                               IF i > x!1 - x!2 THEN 0
                                               ELSE (C(x!1 - x!2, i) * 2 ^ (-1 * i - x!2 + x!1)) * (-1) ^ i
                                               ENDIF" "LAMBDA (i_1: nat):
                                              IF i_1 + x!2 > x!1 OR i_1 + x!2 > nn THEN 0
                                              ELSE C(x!1 - x!2, i_1) * (-1) ^ i_1 *
                                                    (1 / 2 ^ (i_1 - x!1 + x!2))
                                              ENDIF" "x!1-x!2" "0") (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (lemma "expt_plus") (("1" (inst - "x!2-x!1+x!3" "x!1-x!2-x!3" "2") (("1" (lemma "expt_x0") (("1" (inst - "2") (("1" (assert) (("1" (replace -1) (("1" (cross-mult 2) nil))))))))))))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))))))))))))))))))))))))))) ("2" (skosimp*) (("2" (assert) nil))))))))))))))))))) ("3" (skosimp*) (("3" (assert) nil))))))))))))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))) ("5" (skosimp*) (("5" (assert) nil))))))))))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))))))))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))))))))))))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))) ("5" (skosimp*) (("5" (assert) nil))) ("6" (skosimp*) (("6" (assert) nil))) ("7" (skosimp*) (("7" (assert) nil))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))) ("5" (skosimp*) (("5" (assert) nil))))))) ("2" (skosimp*) (("2" (assert) (("2" (ground) nil))))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))) ("5" (skosimp*) (("5" (assert) nil))) ("6" (skosimp*) (("6" (assert) nil))) ("7" (skosimp*) (("7" (assert) nil))) ("8" (skosimp*) (("8" (assert) nil))) ("9" (skosimp*) (("9" (assert) nil))))))))))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))) ("5" (skosimp*) (("5" (assert) nil))) ("6" (skosimp*) (("6" (assert) nil))) ("7" (skosimp*) (("7" (assert) nil)))))))))))))))))))))))))))))))))))))))))))))))))))))))) nil) nil nil)) (Bern_subdiv_left_reverse 0 (Bern_subdiv_left_reverse-1 nil 3485882655 ("" (skeep) (("" (lemma "Bern_poly_reverse_sym_half") (("" (decompose-equality +) (("" (expand "o" +) (("" (inst - "b" "(1/2)*x!1") (("" (replace -1) (("" (hide -1) (("" (lemma "Bern_subdiv_left_id") (("" (inst - "Bern_poly_reverse(b)") (("" (decompose-equality -) (("" (inst - "1-x!1") (("" (expand "o") (("" (replace -1 :dir rl) (("" (hide -1) (("" (lemma "Bern_poly_reverse_sym") (("" (inst - "Bern_subdiv_left(Bern_poly_reverse(b))" "1-x!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_poly_reverse_sym_half formula-decl nil bernstein_polynomials nil) (Bern_subdiv_left_id formula-decl nil bernstein_polynomials nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_minus_real_is_real application-judgement "real" reals nil) (Bern_poly_reverse_sym formula-decl nil bernstein_polynomials nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (O const-decl "T3" function_props nil) (Bern_subdiv_left const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bern_poly_reverse const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_times_real_is_real application-judgement "real" reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_plus_real_is_real application-judgement "real" reals nil)) shostak)) (Bern_subdiv_right_id 0 (Bern_subdiv_right_id-2 nil 3485883526 ("" (skeep) (("" (lemma "Bern_subdiv_left_reverse") (("" (inst - "b") (("" (replace -1 :dir rl) (("" (hide -1) (("" (case "Bern_subdiv_right(b) = Bern_poly_reverse(Bern_subdiv_left(Bern_poly_reverse(b)))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "Bern_subdiv_right") (("2" (expand "Bern_poly_reverse") (("2" (assert) (("2" (ground) (("1" (expand "Bern_subdiv_left") (("1" (propax) nil nil)) nil) ("2" (decompose-equality +) (("1" (expand "Bern_subdiv_left") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (expand "Bern_subdiv_left") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_subdiv_left_reverse formula-decl nil bernstein_polynomials nil) (Bern_subdiv_left const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bern_poly_reverse const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bern_subdiv_right const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (sigma def-decl "real" sigma nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (C const-decl "posnat" binomial nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real nonempty-type-from-decl nil reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil) (Bern_subdiv_right_id-1 nil 3485768080 ("" (skeep) (("" (case "FORALL (xx :real): Bern_poly(Bern_subdiv_right(b))(xx) =
                     (Bern_poly(b) o (LAMBDA (x: real): (1 / 2) * (x+1)))(xx)") (("1" (decompose-equality 1) nil nil) ("2" (hide 2) (("2" (skeep 1) (("2" (name "aa" "Bern_poly_inverse(b)") (("2" (lemma "Bern_poly_inverse_def") (("2" (inst - "b") (("2" (replace -2) (("2" (replace -1 :dir rl) (("2" (expand "o") (("2" (name "nn" "b`index") (("2" (replace -1) (("2" (name "az" "(LAMBDA (i:nat): (1/2^i)*aa(i))") (("2" (case "NOT polynomial(az,nn)(xx+1) = polynomial(aa,nn)((1/2)*(xx+1))") (("1" (hide 2) (("1" (expand "polynomial" +) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (replace -1) (("1" (expand "az" +) (("1" (expand "^" +) (("1" (expand "expt" +) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "mult_expt") (("2" (inst - "x!1" "1/2" "xx+1") (("1" (replace -1) (("1" (hide -1) (("1" (expand "az" +) (("1" (lemma "div_expt") (("1" (inst - "x!1" "1" "2") (("1" (replace -1) (("1" (hide -1) (("1" (case "1^x!1 = 1") (("1" (assert) nil nil) ("2" (case "FORALL (jjj:nat): 1^jjj = 1") (("1" (inst - "x!1") nil nil) ("2" (induct "jjj") (("1" (expand "^" 1) (("1" (expand "expt" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (skeep 1) (("2" (expand "^") (("2" (expand "expt" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (expand "^" +) (("2" (case "xx = -1") (("1" (replace -1) (("1" (assert) (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "azshift" "poly_shift(az,nn)(1)") (("2" (lemma "poly_shift_id") (("2" (inst - "az" "1" "nn" "xx") (("2" (replace -2 -1) (("2" (replace -1) (("2" (replace -3 + :dir rl) (("2" (lemma "Bernstein_equivalence") (("2" (inst - "azshift" "nn" "nn") (("2" (assert) (("2" (replace -1 1) (("2" (case "Bern_subdiv_right(b) = Bernstein_polynomial(azshift, nn, nn)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide -1) (("2" (hide -1) (("2" (expand "Bernstein_polynomial" 1) (("2" (expand "Bern_subdiv_right") (("2" (decompose-equality 1) (("1" (name "mm" "b`index - x!1") (("1" (lemma "sigma_shift_T2") (("1" (inst - "LAMBDA (j: nat):
               IF j > b`index - x!1 THEN 0
               ELSE C(b`index - x!1, j) * b`bern_seq(b`index - j)
               ENDIF" "b`index" "x!1" "-x!1") (("1" (assert) (("1" (replace -1 +) (("1" (hide -1) (("1" (expand "azshift") (("1" (expand "poly_shift") (("1" (expand "az") (("1" (lemma "sigma_swap_triangle") (("1" (name "F" "(LAMBDA (i,j:nat): 
               IF i > x!1 OR i > nn OR j < i OR j > nn THEN 0
                            ELSE aa(j) * C(j, i) * 1 ^ (j - i) *
                                  (1 / 2 ^ j)* (C(x!1, i) / C(nn, i))
               ENDIF)") (("1" (inst - "F" "nn" "nn" "0") (("1" (assert) (("1" (case "NOT sigma(0, nn, LAMBDA (i: nat): sigma(i, nn, LAMBDA (j: nat): F(i, j))) = sigma(0, x!1, LAMBDA (i: nat): sigma(i, nn, LAMBDA (j: nat): F(i, j)))") (("1" (hide 2) (("1" (lemma "sigma_split") (("1" (inst - "LAMBDA (i: nat): sigma(i, nn, LAMBDA (j: nat): F(i, j))" "nn" "0" "x!1") (("1" (assert) (("1" (replace -1 +) (("1" (case "sigma(1 + x!1, nn,
             LAMBDA (i: nat): sigma(i, nn, LAMBDA (j: nat): F(i, j))) = sigma(1+x!1,nn,LAMBDA (i:nat): 0)") (("1" (lemma "sigma_zero") (("1" (inst - "nn" "1+x!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (decompose-equality 1) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (expand "F") (("2" (lemma "sigma_zero") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (case "NOT (LAMBDA (i: nat):
               IF i > x!1 OR i > nn THEN 0
               ELSE sigma(i, nn,
                          LAMBDA (i_1: nat):
                            IF (i_1 < i OR i_1 > nn) THEN 0
                            ELSE aa(i_1) * C(i_1, i) * 1 ^ (i_1 - i) *
                                  (1 / 2 ^ i_1)
                            ENDIF)
                     * (C(x!1, i) / C(nn, i))
               ENDIF) = (LAMBDA (i: nat): sigma(i, nn, LAMBDA (j: nat): F(i, j)))") (("1" (hide 2) (("1" (decompose-equality 1) (("1" (lift-if) (("1" (ground) (("1" (expand "F" +) (("1" (lemma "sigma_zero") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "F" +) (("2" (lemma "sigma_zero") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "F" +) (("3" (assert) (("3" (lemma "sigma_scal") (("3" (inst - "LAMBDA (i_1: nat):
              IF (i_1 < x!2 OR i_1 > nn) THEN 0
              ELSE aa(i_1) * C(i_1, x!2) * 1 ^ (i_1 - x!2) * (1 / 2 ^ i_1)
              ENDIF" "(C(x!1, x!2) / C(nn, x!2))" "nn" "x!2") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (replace -3) (("2" (case "NOT sigma(0, nn, LAMBDA (j: nat): sigma(0, j, LAMBDA (i: nat): F(i, j))) = sigma(x!1, nn, LAMBDA (j: nat): sigma(0, j, LAMBDA (i: nat): F(i, j)))") (("1" (hide 2) (("1" (lemma "sigma_split") (("1" (inst - "LAMBDA (j: nat): sigma(0, j, LAMBDA (i: nat): F(i, j))" "nn" "0" "x!1-1") (("1" (assert) (("1" (case "sigma(0, x!1 - 1,
             LAMBDA (j: nat): sigma(0, j, LAMBDA (i: nat): F(i, j))) = sigma(0, x!1 - 1,
             LAMBDA (j: nat): 0)") (("1" (lemma "sigma_zero") (("1" (inst - "x!1-1" "0") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "sigma_restrict_eq") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (decompose-equality 1) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "sigma(0, x!2, LAMBDA (i: nat): F(i, x!2)) = sigma(0, x!2, LAMBDA (i: nat): 0)") (("1" (lemma "sigma_zero") (("1" (inst - "x!2" "0") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "sigma_restrict_eq") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (decompose-equality 1) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma def-decl "real" sigma nil) (C const-decl "posnat" binomial nil) (binomial_theorem formula-decl nil polynomials nil) (sigma_shift_T2 formula-decl nil sigma nil) (binom_trinomial_revision formula-decl nil binomial_identities nil) (sigma_scal formula-decl nil sigma nil) (sigma_swap_triangle formula-decl nil sigma_swap nil) (sigma_restrict_eq formula-decl nil sigma nil) (restrict const-decl "[T -> real]" sigma nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (polynomial const-decl "[real -> real]" polynomials nil)) shostak)) (Bern_subdiv_ge 0 (Bern_subdiv_ge-1 nil 3486719404 ("" (skeep) (("" (lemma "Bern_subdiv_left_id") (("" (inst - "b") (("" (decompose-equality -1) (("" (inst - "2*x") (("" (expand "o") (("" (case "2*((1/2)*x) = x") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "Bern_subdiv_right_id") (("1" (inst - "b") (("1" (decompose-equality -1) (("1" (inst - "2*x-1") (("1" (expand "o") (("1" (assert) (("1" (case "2*((1/2)*x) = x") (("1" (replace -1) (("1" (hide -1) (("1" (inst - "2*x-1") (("1" (inst - "2*x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_subdiv_left_id formula-decl nil bernstein_polynomials nil) (real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (Bern_subdiv_left const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (O const-decl "T3" function_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (Bern_subdiv_right_id formula-decl nil bernstein_polynomials nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Bern_subdiv_right const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (real_plus_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_minus_real_is_real application-judgement "real" reals nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real nonempty-type-from-decl nil reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (Bern_sweep_TCC1 0 (Bern_sweep_TCC1-1 nil 3480422881 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (Bern_sweep subtype "(number_fields.-)(bernstein_polynomials.p, 1)" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (Bern_sweep_TCC2 0 (Bern_sweep_TCC2-1 nil 3480422881 ("" (subtype-tcc) nil nil) nil nil (Bern_sweep termination "bernstein_polynomials.Bern_sweep(bernstein_polynomials.b)((number_fields.-)(bernstein_polynomials.p, 1))" "nil"))) (Bern_sweep_TCC3 0 (Bern_sweep_TCC3-1 nil 3480422881 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (Bern_sweep subtype "bernstein_polynomials.i" "naturalnumbers.upto(bernstein_polynomials.Bern_sweep(bernstein_polynomials.b)((number_fields.-)(bernstein_polynomials.p, 1))`index)"))) (Bern_sweep_TCC4 0 (Bern_sweep_TCC4-1 nil 3480422881 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (Bern_sweep subtype "(number_fields.-)(bernstein_polynomials.i, 1)" "naturalnumbers.upto(bernstein_polynomials.Bern_sweep(bernstein_polynomials.b)((number_fields.-)(bernstein_polynomials.p, 1))`index)"))) (Bern_sweep_TCC5 0 (Bern_sweep_TCC5-1 nil 3480422881 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (Bern_sweep subtype "(number_fields.-)(bernstein_polynomials.p, 1)" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (Bern_sweep_TCC6 0 (Bern_sweep_TCC6-1 nil 3480422881 ("" (termination-tcc) nil nil) nil nil (Bern_sweep termination "bernstein_polynomials.Bern_sweep(bernstein_polynomials.b)((number_fields.-)(bernstein_polynomials.p, 1))" "nil"))) (Bern_sweep_TCC7 0 (Bern_sweep_TCC7-1 nil 3480422881 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (Bern_sweep subtype "bernstein_polynomials.i" "naturalnumbers.upto(bernstein_polynomials.Bern_sweep(bernstein_polynomials.b)((number_fields.-)(bernstein_polynomials.p, 1))`index)"))) (Bern_sweep_expand_TCC1 0 (Bern_sweep_expand_TCC1-1 nil 3480673888 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (Bern_sweep_expand subtype "(number_fields.+)(bernstein_polynomials.j, ((number_fields.-)(bernstein_polynomials.i, bernstein_polynomials.p)))" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (Bern_sweep_expand_TCC2 0 (Bern_sweep_expand_TCC2-1 nil 3480673888 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil)) nil (Bern_sweep_expand subtype "bernstein_polynomials.j" "{i: naturalnumbers.nat | reals.<=(i, bernstein_polynomials.p)}"))) (Bern_sweep_expand 0 (Bern_sweep_expand-2 "" 3790089254 ("" (induct "p") (("1" (skeep) (("1" (decompose-equality) (("1" (decompose-equality) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (case "x!1 = 0") (("1" (replace -1) (("1" (hide -1) (("1" (hide -1) (("1" (hide -1) (("1" (case "2^0 = 1") (("1" (replace -1) (("1" (hide -1) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "C") (("1" (expand "Bern_sweep") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^" 1) (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (case "2^0 = 1") (("1" (replace -1) (("1" (hide -1) (("1" (hide -1) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "Bern_sweep") (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^" 1) (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (typepred "Bern_sweep(b)(0)") (("2" (ground) nil nil)) nil)) nil) ("3" (hide -1) (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (decompose-equality) (("1" (decompose-equality) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (expand "Bern_sweep" +) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (inst - "b!1") (("1" (assert) (("1" (replace -3 +) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "NOT x!1 = 1+j!1") (("1" (assert) nil nil) ("2" (hide -2) (("2" (hide 1) (("2" (replace -1) (("2" (hide -1) (("2" (assert) (("2" (inst - "b!1") (("2" (assert) (("2" (replace -1 1) (("2" (assert) (("2" (hide -1) (("2" (case "NOT (1 / 2)
                                                                * (1 / (2 ^ j!1)) = (1 / (2 ^ (1 + j!1)))") (("1" (hide 2) (("1" (cross-mult 1) (("1" (expand "^") (("1" (expand "expt" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (case "sigma(0, j!1,
                                                                           LAMBDA (j: nat):
                                                                             IF j > j!1 THEN 0
                                                                             ELSE b!1`bern_seq(1 + j) * C(j!1, j)
                                                                             ENDIF)
                                                                      +
                                                                      sigma(0, j!1,
                                                                            LAMBDA (j: nat):
                                                                              IF j > j!1 THEN 0 ELSE b!1`bern_seq(j) * C(j!1, j) ENDIF)
                                                                      =
                                                                       sigma(0, 1 + j!1,
                                                                             LAMBDA (j: nat):
                                                                               IF j > 1 + j!1 THEN 0
                                                                               ELSE b!1`bern_seq(j) * C(1 + j!1, j)
                                                                               ENDIF)") (("1" (mult-by -1 "(1 / (2 ^ (1 + j!1)))") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (lemma "sigma_shift_T2") (("2" (inst - "LAMBDA (j: nat):
                                                                    IF j > j!1 THEN 0
                                                                    ELSE b!1`bern_seq(1 + j) * C(j!1, j)
                                                                    ENDIF" "1+j!1" "1" "-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (name "AA" "LAMBDA (j: nat):
                                                                 IF j > 1 + j!1 THEN 0
                                                                 ELSE b!1`bern_seq(j) * C(1 + j!1, j)
                                                                 ENDIF") (("1" (replace -1) (("1" (name "BB" "LAMBDA (j: nat):
                                                                 IF j > j!1 THEN 0 ELSE b!1`bern_seq(j) * C(j!1, j) ENDIF") (("1" (replace -1) (("1" (name "CC" "LAMBDA (i: nat):
                                                                IF i - 1 >= 0
                                                                  THEN IF i - 1 > j!1 THEN 0
                                                                       ELSE b!1`bern_seq(i) * C(j!1, i - 1)
                                                                       ENDIF
                                                                ELSE 0
                                                                ENDIF") (("1" (replace -1) (("1" (lemma "sigma_split") (("1" (inst - "CC" "1+j!1" "0" "0") (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "sigma" -1 2) (("1" (expand "CC" -1 2) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst - "BB" "1+j!1" "0" "j!1") (("1" (assert) (("1" (expand "sigma" -1 3) (("1" (expand "sigma" -1 3) (("1" (expand "BB" -1 2) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (case "AA = BB + CC") (("1" (replace -1) (("1" (lemma "sigma_sum") (("1" (expand "+" 1 5) (("1" (inst - "BB" "CC" "1+j!1" "0") nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "+" +) (("2" (decompose-equality) (("2" (expand "AA" +) (("2" (expand "BB" +) (("2" (expand "CC" +) (("2" (hide -1) (("2" (hide -1) (("2" (hide -1) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (ground) (("2" (case "NOT x!2 = j!1+1") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (lemma "C_n_plus_1") (("1" (inst - "j!1" "x!2") (("1" (mult-by -1 "b!1`bern_seq(x!2)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "x!2 = 0") (("1" (replace -1) (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -1) (("2" (expand "C") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil) ("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst - "b!1") (("2" (assert) (("2" (expand "Bern_sweep" +) (("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (case "NOT (1 / 2)
                       * (1 / (2 ^ j!1)) = (1 / (2 ^ (1 + j!1)))") (("1" (hide 3) (("1" (cross-mult 1) (("1" (expand "^") (("1" (expand "expt" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (case "sigma(0, j!1,
                             LAMBDA (j: nat):
                               IF j > j!1 THEN 0
                               ELSE b!1`bern_seq(j - 1 - j!1 + x!1) * C(j!1, j)
                               ENDIF)
                        +
                        sigma(0, j!1,
                              LAMBDA (j: nat):
                                IF j > j!1 THEN 0
                                ELSE b!1`bern_seq(j - j!1 + x!1) * C(j!1, j)
                                ENDIF)
                        =
                         sigma(0, 1 + j!1,
                               LAMBDA (j: nat):
                                 IF j > 1 + j!1 THEN 0
                                 ELSE b!1`bern_seq(j - 1 - j!1 + x!1) * C(1 + j!1, j)
                                 ENDIF)") (("1" (mult-by -1 "(1 / (2 ^ (1 + j!1)))") (("1" (assert) nil nil)) nil) ("2" (hide 3) (("2" (hide -1) (("2" (lemma "sigma_shift_T2") (("2" (inst - "LAMBDA (j: nat):
                             IF j > j!1 THEN 0
                             ELSE b!1`bern_seq(j - j!1 + x!1) * C(j!1, j)
                             ENDIF" "1+j!1" "1" "-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (name "AA" "LAMBDA (j: nat):
                                    IF j > 1 + j!1 THEN 0
                                    ELSE b!1`bern_seq(j - 1 - j!1 + x!1) * C(1 + j!1, j)
                                    ENDIF") (("1" (replace -1) (("1" (name "BB" "LAMBDA (j: nat):
                                     IF j > j!1 THEN 0
                                     ELSE b!1`bern_seq(j - 1 - j!1 + x!1) * C(j!1, j)
                                     ENDIF") (("1" (replace -1) (("1" (name "CC" "LAMBDA (i: nat):
                                        IF i - 1 >= 0
                                          THEN IF i - 1 > j!1 THEN 0
                                               ELSE b!1`bern_seq(i - 1 - j!1 + x!1) * C(j!1, i - 1)
                                               ENDIF
                                        ELSE 0
                                        ENDIF") (("1" (replace -1) (("1" (lemma "sigma_split") (("1" (inst - "CC" "1+j!1" "0" "0") (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "sigma" -1 2) (("1" (expand "CC" -1 2) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst - "BB" "1+j!1" "0" "j!1") (("1" (assert) (("1" (expand "sigma" -1 3) (("1" (expand "sigma" -1 3) (("1" (expand "BB" -1 2) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (case "AA = BB+CC") (("1" (replace -1 +) (("1" (expand "+" 1 5) (("1" (lemma "sigma_sum") (("1" (inst - "BB" "CC" "1+j!1" "0") nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "+" 1) (("2" (decompose-equality) (("2" (expand "AA" +) (("2" (expand "BB" +) (("2" (expand "CC" +) (("2" (hide -1) (("2" (hide -1) (("2" (hide -1) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (case "NOT x!2 = 1+j!1") (("1" (assert) nil nil) ("2" (replace -1) (("2" (hide -1) (("2" (hide -1) (("2" (hide -1) (("2" (hide 2) (("2" (assert) (("2" (expand "C" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "C_n_plus_1") (("2" (inst - "j!1" "x!2") (("2" (mult-by -1 "b!1`bern_seq(-1 - j!1 + x!1 + x!2)") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (case "x!2 = 0") (("1" (replace -1) (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil) ("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (ground) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (sigma_split formula-decl nil sigma nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (+ const-decl "[T -> real]" real_fun_ops nil) (sigma_sum formula-decl nil sigma nil) (AA skolem-const-decl "[nat -> number_field]" bernstein_polynomials nil) (C_n_plus_1 formula-decl nil binomial nil) (BB skolem-const-decl "[nat -> number_field]" bernstein_polynomials nil) (CC skolem-const-decl "[nat -> real]" bernstein_polynomials nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (sigma_shift_T2 formula-decl nil sigma nil) (int_times_even_is_even application-judgement "even_int" integers nil) (div_cancel4 formula-decl nil real_props nil) (times_div2 formula-decl nil real_props nil) (div_cancel3 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div1 formula-decl nil real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (CC skolem-const-decl "[nat -> real]" bernstein_polynomials nil) (BB skolem-const-decl "[nat -> real]" bernstein_polynomials nil) (AA skolem-const-decl "[nat -> number_field]" bernstein_polynomials nil) (x!1 skolem-const-decl "upto(Bern_sweep(b!1)(1 + j!1)`index)" bernstein_polynomials nil) (j!1 skolem-const-decl "nat" bernstein_polynomials nil) (b!1 skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (expt def-decl "real" exponentiation nil) (factorial_0 formula-decl nil factorial ints) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_induction formula-decl nil naturalnumbers nil) (C const-decl "posnat" binomial nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (sigma def-decl "real" sigma nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (^ const-decl "real" exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (Bern_sweep def-decl "{bp: Bernstein_Polynomial | bp`index = b`index}" bernstein_polynomials nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (posint_exp application-judgement "posint" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak) (Bern_sweep_expand-1 nil 3480673889 ("" (induct "p") (("1" (skeep) (("1" (decompose-equality) (("1" (decompose-equality) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (case "x!1 = 0") (("1" (replace -1) (("1" (hide -1) (("1" (hide -1) (("1" (hide -1) (("1" (case "2^0 = 1") (("1" (replace -1) (("1" (hide -1) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "C") (("1" (expand "Bern_sweep") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^" 1) (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (case "2^0 = 1") (("1" (replace -1) (("1" (hide -1) (("1" (hide -1) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "Bern_sweep") (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^" 1) (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (typepred "Bern_sweep(b)(0)") (("2" (ground) nil nil)) nil)) nil) ("3" (hide -1) (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (decompose-equality) (("1" (decompose-equality) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (expand "Bern_sweep" +) (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (inst - "b!1") (("1" (assert) (("1" (replace -3 +) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "NOT x!1 = 1+j!1") (("1" (assert) nil nil) ("2" (hide -2) (("2" (hide 1) (("2" (replace -1) (("2" (hide -1) (("2" (assert) (("2" (inst - "b!1") (("2" (assert) (("2" (replace -1 1) (("2" (assert) (("2" (hide -1) (("2" (case "NOT (1 / 2)
                                                                * (1 / (2 ^ j!1)) = (1 / (2 ^ (1 + j!1)))") (("1" (hide 2) (("1" (cross-mult 1) (("1" (expand "^") (("1" (expand "expt" 1 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (case "sigma(0, j!1,
                                                                           LAMBDA (j: nat):
                                                                             IF j > j!1 THEN 0
                                                                             ELSE b!1`bern_seq(1 + j) * C(j!1, j)
                                                                             ENDIF)
                                                                      +
                                                                      sigma(0, j!1,
                                                                            LAMBDA (j: nat):
                                                                              IF j > j!1 THEN 0 ELSE b!1`bern_seq(j) * C(j!1, j) ENDIF)
                                                                      =
                                                                       sigma(0, 1 + j!1,
                                                                             LAMBDA (j: nat):
                                                                               IF j > 1 + j!1 THEN 0
                                                                               ELSE b!1`bern_seq(j) * C(1 + j!1, j)
                                                                               ENDIF)") (("1" (mult-by -1 "(1 / (2 ^ (1 + j!1)))") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (lemma "sigma_shift_T2") (("2" (inst - "LAMBDA (j: nat):
                                                                    IF j > j!1 THEN 0
                                                                    ELSE b!1`bern_seq(1 + j) * C(j!1, j)
                                                                    ENDIF" "1+j!1" "1" "-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (name "AA" "LAMBDA (j: nat):
                                                                 IF j > 1 + j!1 THEN 0
                                                                 ELSE b!1`bern_seq(j) * C(1 + j!1, j)
                                                                 ENDIF") (("1" (replace -1) (("1" (name "BB" "LAMBDA (j: nat):
                                                                 IF j > j!1 THEN 0 ELSE b!1`bern_seq(j) * C(j!1, j) ENDIF") (("1" (replace -1) (("1" (name "CC" "LAMBDA (i: nat):
                                                                IF i - 1 >= 0
                                                                  THEN IF i - 1 > j!1 THEN 0
                                                                       ELSE b!1`bern_seq(i) * C(j!1, i - 1)
                                                                       ENDIF
                                                                ELSE 0
                                                                ENDIF") (("1" (replace -1) (("1" (lemma "sigma_split") (("1" (inst - "CC" "1+j!1" "0" "0") (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "sigma" -1 2) (("1" (expand "CC" -1 2) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst - "BB" "1+j!1" "0" "j!1") (("1" (assert) (("1" (expand "sigma" -1 3) (("1" (expand "sigma" -1 3) (("1" (expand "BB" -1 2) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (case "AA = BB + CC") (("1" (replace -1) (("1" (lemma "sigma_sum") (("1" (expand "+" 1 5) (("1" (inst - "BB" "CC" "1+j!1" "0") nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "+" +) (("2" (decompose-equality) (("2" (expand "AA" +) (("2" (expand "BB" +) (("2" (expand "CC" +) (("2" (hide -1) (("2" (hide -1) (("2" (hide -1) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (ground) (("2" (case "NOT x!2 = j!1+1") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (lemma "C_n_plus_1") (("1" (inst - "j!1" "x!2") (("1" (mult-by -1 "b!1`bern_seq(x!2)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "x!2 = 0") (("1" (replace -1) (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -1) (("2" (expand "C") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil) ("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst - "b!1") (("2" (assert) (("2" (expand "Bern_sweep" +) (("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (case "NOT (1 / 2)
                       * (1 / (2 ^ j!1)) = (1 / (2 ^ (1 + j!1)))") (("1" (hide 3) (("1" (cross-mult 1) (("1" (expand "^") (("1" (expand "expt" 1 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (case "sigma(0, j!1,
                             LAMBDA (j: nat):
                               IF j > j!1 THEN 0
                               ELSE b!1`bern_seq(j - 1 - j!1 + x!1) * C(j!1, j)
                               ENDIF)
                        +
                        sigma(0, j!1,
                              LAMBDA (j: nat):
                                IF j > j!1 THEN 0
                                ELSE b!1`bern_seq(j - j!1 + x!1) * C(j!1, j)
                                ENDIF)
                        =
                         sigma(0, 1 + j!1,
                               LAMBDA (j: nat):
                                 IF j > 1 + j!1 THEN 0
                                 ELSE b!1`bern_seq(j - 1 - j!1 + x!1) * C(1 + j!1, j)
                                 ENDIF)") (("1" (mult-by -1 "(1 / (2 ^ (1 + j!1)))") (("1" (assert) nil nil)) nil) ("2" (hide 3) (("2" (hide -1) (("2" (lemma "sigma_shift_T2") (("2" (inst - "LAMBDA (j: nat):
                             IF j > j!1 THEN 0
                             ELSE b!1`bern_seq(j - j!1 + x!1) * C(j!1, j)
                             ENDIF" "1+j!1" "1" "-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (name "AA" "LAMBDA (j: nat):
                                    IF j > 1 + j!1 THEN 0
                                    ELSE b!1`bern_seq(j - 1 - j!1 + x!1) * C(1 + j!1, j)
                                    ENDIF") (("1" (replace -1) (("1" (name "BB" "LAMBDA (j: nat):
                                     IF j > j!1 THEN 0
                                     ELSE b!1`bern_seq(j - 1 - j!1 + x!1) * C(j!1, j)
                                     ENDIF") (("1" (replace -1) (("1" (name "CC" "LAMBDA (i: nat):
                                        IF i - 1 >= 0
                                          THEN IF i - 1 > j!1 THEN 0
                                               ELSE b!1`bern_seq(i - 1 - j!1 + x!1) * C(j!1, i - 1)
                                               ENDIF
                                        ELSE 0
                                        ENDIF") (("1" (replace -1) (("1" (lemma "sigma_split") (("1" (inst - "CC" "1+j!1" "0" "0") (("1" (assert) (("1" (expand "sigma" -1 2) (("1" (expand "sigma" -1 2) (("1" (expand "CC" -1 2) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst - "BB" "1+j!1" "0" "j!1") (("1" (assert) (("1" (expand "sigma" -1 3) (("1" (expand "sigma" -1 3) (("1" (expand "BB" -1 2) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (case "AA = BB+CC") (("1" (replace -1 +) (("1" (expand "+" 1 5) (("1" (lemma "sigma_sum") (("1" (inst - "BB" "CC" "1+j!1" "0") nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "+" 1) (("2" (decompose-equality) (("2" (expand "AA" +) (("2" (expand "BB" +) (("2" (expand "CC" +) (("2" (hide -1) (("2" (hide -1) (("2" (hide -1) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (case "NOT x!2 = 1+j!1") (("1" (assert) nil nil) ("2" (replace -1) (("2" (hide -1) (("2" (hide -1) (("2" (hide -1) (("2" (hide 2) (("2" (assert) (("2" (expand "C" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "C_n_plus_1") (("2" (inst - "j!1" "x!2") (("2" (mult-by -1 "b!1`bern_seq(-1 - j!1 + x!1 + x!2)") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (case "x!2 = 0") (("1" (replace -1) (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil) ("7" (skosimp*) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (ground) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ((sigma_split formula-decl nil sigma nil) (sigma_sum formula-decl nil sigma nil) (C_n_plus_1 formula-decl nil binomial nil) (sigma_shift_T2 formula-decl nil sigma nil) (factorial_0 formula-decl nil factorial ints) (C const-decl "posnat" binomial nil) (sigma def-decl "real" sigma nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil)) shostak)) (Bern_subdiv_l_TCC1 0 (Bern_subdiv_l_TCC1-1 nil 3480781016 ("" (subtype-tcc) nil nil) nil nil (Bern_subdiv_l subtype "bernstein_polynomials.b`index" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (Bern_subdiv_r_TCC1 0 (Bern_subdiv_r_TCC1-1 nil 3480422881 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (Bern_subdiv_r subtype "bernstein_polynomials.b`index" "naturalnumbers.upto(bernstein_polynomials.Bern_sweep(bernstein_polynomials.b)((number_fields.-)(bernstein_polynomials.b`index, bernstein_polynomials.i))`index)"))) (Bern_subdiv_l_id 0 (Bern_subdiv_l_id-3 nil 3486109684 ("" (skeep) (("" (lemma "Bern_poly_inverse_def") (("" (inst - "Bern_subdiv_l(b)") (("" (replace -1 :dir rl) (("" (hide -1) (("" (expand "Bern_poly_inverse") (("" (expand "polynomial") (("" (assert) (("" (expand "Bern_subdiv_l") (("" (assert) (("" (lemma "Bern_sweep_expand") (("" (inst - "b" "b`index") (("" (assert) (("" (replace -1) (("" (hide -1) (("" (assert) (("" (lemma "Bern_poly_inverse_def") (("" (inst - "b") (("" (replace -1 :dir rl) (("" (hide -1) (("" (expand "polynomial") (("" (expand "o") (("" (assert) (("" (decompose-equality) (("1" (expand "Bern_poly_inverse") (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (replace -1) (("1" (hide -1) (("1" (hide 2) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (case "2^0 = 1") (("1" (expand "C") (("1" (assert) nil nil)) nil) ("2" (expand "^") (("2" (expand "expt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sigma_swap_triangle") (("2" (name "F" "(LAMBDA (j,i:nat): IF i > x!2 OR j > i THEN 0 ELSE C(b`index, x!2) * C(x!2, i) * (-1) ^ (x!2 - i) * (1 / (2 ^ i)) * b`bern_seq(j) * C(i, j) ENDIF)") (("1" (inst - "F" "x!2" "x!2" "0") (("1" (assert) (("1" (case "NOT (LAMBDA (j: nat): sigma(0, j, LAMBDA (i: nat): F(i, j))) = (LAMBDA (i: nat):
                                                                                                   IF i > x!2 THEN 0
                                                                                                   ELSE C(b`index, x!2) * C(x!2, i) * (-1) ^ (x!2 - i) *
                                                                                                         sigma(0, i,
                                                                                                               LAMBDA (j: nat):
                                                                                                                 IF j > i THEN 0
                                                                                                                 ELSE b`bern_seq(j) * C(i, j)
                                                                                                                 ENDIF)
                                                                                                         * (1 / (2 ^ i))
                                                                                                   ENDIF)") (("1" (hide 3) (("1" (decompose-equality) (("1" (lift-if) (("1" (ground) (("1" (expand "F" +) (("1" (rewrite "sigma_zero") nil nil)) nil) ("2" (lemma "sigma_scal") (("2" (inst?) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_scal") (("1" (inst - "LAMBDA (i: nat):
                                                                                                                   C(b`index, x!2) * C(x!2, x!3) * (-1) ^ (x!2 - x!3) *
                                                                                                                    IF i > x!3 THEN 0 ELSE b`bern_seq(i) * C(x!3, i) ENDIF" "(1 / (2 ^ x!3))" "x!3" "0") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 3) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (expand "F" +) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (replace -2 :dir rl) (("2" (hide -2) (("2" (case "((1 / 2) * x!1) ^ x!2 = (1/(2^x!2))*x!1^x!2") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_scal") (("1" (case "sigma(0, x!2,
                                                                                                                     LAMBDA (i: nat): sigma(i, x!2, LAMBDA (j: nat): F(i, j)))
                                                                                                                =
                                                                                                                sigma(0, x!2,
                                                                                                                      LAMBDA (i_2: nat):
                                                                                                                        IF i_2 > x!2 THEN 0
                                                                                                                        ELSE b`bern_seq(i_2) * C(b`index, x!2) * C(x!2, i_2) *
                                                                                                                              (-1) ^ (x!2 - i_2)
                                                                                                                        ENDIF)
                                                                                                                 * ((1 / (2 ^ x!2)))") (("1" (mult-by -1 "x!1^x!2") (("1" (assert) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("2" (hide 3) (("2" (inst - "LAMBDA (i_2: nat):
                                                                                                         IF i_2 > x!2 THEN 0
                                                                                                         ELSE b`bern_seq(i_2) * C(b`index, x!2) * C(x!2, i_2) *
                                                                                                               (-1) ^ (x!2 - i_2)
                                                                                                         ENDIF" "((1 / (2 ^ x!2)))" "x!2" "0") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (expand "F" +) (("1" (hide -1) (("1" (case "NOT (LAMBDA (j: nat):
                                                                                                                                                               IF j > x!2 OR x!3 > j THEN 0
                                                                                                                                                               ELSE b`bern_seq(x!3) * C(j, x!3) * C(b`index, x!2) *
                                                                                                                                                                     C(x!2, j)
                                                                                                                                                                     * (-1) ^ (x!2 - j)
                                                                                                                                                                     * (1 / (2 ^ j))
                                                                                                                                                               ENDIF) = (LAMBDA (j: nat):
                                                                                                                                                               IF j > x!2 OR x!3 > j THEN 0
                                                                                                                                                               ELSE b`bern_seq(x!3) * C(x!2,x!3) * C(b`index, x!2) *
                                                                                                                                                                     C(x!2-x!3, j-x!3)
                                                                                                                                                                     * (-1) ^ (x!2 - j)
                                                                                                                                                                     * (1 / (2 ^ j))
                                                                                                                                                               ENDIF)") (("1" (hide 3) (("1" (decompose-equality) (("1" (lift-if) (("1" (ground) (("1" (case "C(x!2, x!4) * C(x!4, x!3)
                                                                                                                                                                            = C(x!2 - x!3, x!4 - x!3) *
                                                                                                                                                                             C(x!2, x!3)") (("1" (mult-by -1 "b`bern_seq(x!3) * C(b`index, x!2) *
                                                                                                                                                             (-1) ^ (x!2 - x!4)
                                                                                                                                                             * (1 / (2 ^ x!4))") (("1" (assert) nil nil)) nil) ("2" (hide 4) (("2" (expand "C") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (assert) (("2" (lemma "sigma_shift_T2") (("2" (inst - "(LAMBDA (j: nat):
                                                                                                                                                 IF j > x!2 OR x!3 > j THEN 0
                                                                                                                                                 ELSE b`bern_seq(x!3) * C(b`index, x!2) *
                                                                                                                                                       C(x!2 - x!3, j - x!3)
                                                                                                                                                       * C(x!2, x!3)
                                                                                                                                                       * (-1) ^ (x!2 - j)
                                                                                                                                                       * (1 / (2 ^ j))
                                                                                                                                                 ENDIF)" "x!2-x!3" "0" "x!3") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "binomial_theorem") (("1" (inst - "x!2-x!3" "1/2" "-1") (("1" (case "NOT (((-1)/2) ^ (x!2 - x!3) = (((1 / (2 ^ x!2)))/(1/2^x!3)) *
                                                                                                             (-1) ^ (x!2 - x!3))") (("1" (hide 3) (("1" (hide -1) (("1" (lemma "div_expt") (("1" (inst -1 "x!2-x!3" "-1" "2") (("1" (replaces -1) (("1" (lemma "expt_div") (("1" (inst -1 "x!2" "x!3" "2") (("1" (replaces -1 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (case "NOT ((1 / (2 ^ x!2)))  * (-1) ^ (x!2 - x!3) =
                                                                                                                (1 / 2 ^ x!3)*sigma(0, x!2 - x!3,
                                                                                                                      LAMBDA (i: nat):
                                                                                                                        IF i > x!2 - x!3 THEN 0
                                                                                                                        ELSE C(x!2 - x!3, i) * (1 / 2) ^ i * (-1) ^ (x!2 - x!3 - i)
                                                                                                                        ENDIF)") (("1" (cross-mult -1) (("1" (cross-mult 1) (("1" (hide-all-but 1) (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (mult-by -1 "(b`bern_seq(x!3) * C(b`index, x!2) * C(x!2, x!3))") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_scal") (("1" (inst - "LAMBDA (i: nat):
                                                                                                                      IF i > x!2 - x!3 THEN 0
                                                                                                                      ELSE C(x!2 - x!3, i) * (1 / 2) ^ i * (-1) ^ (x!2 - x!3 - i)
                                                                                                                      ENDIF" "(1 / 2 ^ x!3) *(b`bern_seq(x!3) * C(b`index, x!2) * C(x!2, x!3))" "x!2-x!3" "0") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 3) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (lemma "inv_expt") (("1" (inst -1 "x!4" "2") (("1" (replaces -1) (("1" (lemma "expt_plus") (("1" (inst -1 "x!3" "x!4" "2") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (case-replace "x!1=0") (("1" (expand "^") (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "mult_expt") (("2" (lemma "inv_expt") (("2" (inst -1 "x!2" "2") (("2" (replaces -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_poly_inverse_def formula-decl nil bernstein_polynomials nil) (Bern_poly_inverse const-decl "sequence[real]" bernstein_polynomials nil) (real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (O const-decl "T3" function_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_low type-eq-decl nil sigma nil) (T_high type-eq-decl nil sigma nil) (sigma def-decl "real" sigma nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (C const-decl "posnat" binomial nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (sequence type-eq-decl nil sequences nil) (sigma_restrict_eq formula-decl nil sigma nil) (restrict const-decl "[T -> real]" sigma nil) (int_exp application-judgement "int" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (factorial_0 formula-decl nil factorial ints) (expt def-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (rat_exp application-judgement "rat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (binomial_theorem formula-decl nil polynomials nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_div formula-decl nil exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (TRUE const-decl "bool" booleans nil) (div_expt formula-decl nil exponentiation nil) (inv_expt formula-decl nil exponentiation nil) (expt_plus formula-decl nil exponentiation nil) (times_div2 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_cancel3 formula-decl nil real_props nil) (sigma_rat application-judgement "rational" sigma_nat nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (times_div1 formula-decl nil real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (div_cancel4 formula-decl nil real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (sigma_shift_T2 formula-decl nil sigma nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (x!3 skolem-const-decl "nat" bernstein_polynomials nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nat_expt application-judgement "nat" exponentiation nil) (mult_expt formula-decl nil exponentiation nil) (sigma_scal formula-decl nil sigma nil) (x!3 skolem-const-decl "nat" bernstein_polynomials nil) (F skolem-const-decl "[[nat, nat] -> real]" bernstein_polynomials nil) (sigma_zero formula-decl nil sigma nil) (x!2 skolem-const-decl "nat" bernstein_polynomials nil) (sigma_swap_triangle formula-decl nil sigma_swap nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (Bern_sweep_expand formula-decl nil bernstein_polynomials nil) (polynomial const-decl "[real -> real]" polynomials nil) (Bern_subdiv_l const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real nonempty-type-from-decl nil reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil) (Bern_subdiv_l_id-2 nil 3480843273 ("" (case "NOT (FORALL (av,bv:[nat->real],mv:nat): (FORALL (iv:upto(mv)): av(iv) = bv(mv-iv)) IMPLIES sigma(0,mv,av) = sigma(0,mv,bv))") (("1" (hide 2) (("1" (induct "mv") (("1" (skeep) (("1" (inst - "0") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "sigma" 1 1) (("2" (lemma "sigma_split") (("2" (inst - "bv" "1+j" "0" "0") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (copy -2) (("2" (inst - "1+j") (("2" (assert) (("2" (replace -1 1) (("2" (expand "sigma" 1 2) (("2" (expand "sigma" 1 2) (("2" (hide -1) (("2" (lemma "sigma_shift_T2") (("2" (inst - "bv" "j" "0" "1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (inst - "av" "LAMBDA (i: nat): bv(1 + i)") (("2" (assert) (("2" (hide 2) (("2" (skeep) (("2" (inst - "iv") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "swaplem" -1) (("2" (hide -1) (("2" (skeep) (("2" (case "NOT (FORALL (f,g:[nat->real],n:nat,x:real): (FORALL (m:upto(n)): factorial(m)*f(m) = sigma(m,n,(LAMBDA (k:nat): IF k < m OR k>n THEN 0 ELSE (factorial(k)/factorial(k-m))*g(k) ENDIF))) IMPLIES polynomial(f,n)(x) = polynomial(g,n)(x+1))") (("1" (hide 2) (("1" (skeep) (("1" (expand "polynomial" 1 2) (("1" (case "(LAMBDA (i: nat):
                                                                  g(i) * (IF i = 0 THEN 1 ELSE (1 + x) ^ i ENDIF)) =(LAMBDA (i: nat):
                                                                  g(i) * (1 + x) ^ i)") (("1" (replace -1) (("1" (hide -1) (("1" (case "NOT (LAMBDA (i: nat): g(i) * (1 + x) ^ i) = (LAMBDA (i: nat): g(i) * sigma(0, i,
                                                                          LAMBDA (j: nat):
                                                                            IF j > i THEN 0 ELSE C(i, j)  * x ^ j ENDIF))") (("1" (hide 2) (("1" (decompose-equality) (("1" (lemma "binomial_theorem") (("1" (inst - "x!1" "x" "1") (("1" (replace -1) (("1" (case "(LAMBDA (i: nat):
                                                 IF i > x!1 THEN 0
                                                 ELSE C(x!1, i) * x ^ i * 1 ^ (x!1 - i)
                                                 ENDIF) = (LAMBDA (j: nat):
                                                  IF j > x!1 THEN 0 ELSE C(x!1, j) * x ^ j ENDIF)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (lift-if) (("1" (ground) (("1" (case "FORALL (jj:nat): 1^jj = 1") (("1" (inst - "x!1-x!2") (("1" (assert) nil nil)) nil) ("2" (induct "jj") (("1" (expand "^") (("1" (expand "expt") (("1" (propax) nil nil)) nil)) nil) ("2" (skeep) (("2" (expand "^") (("2" (expand "expt" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (name "F" "(LAMBDA (j,i:nat): IF j > i THEN 0 ELSE g(i)*C(i,j)*x^j ENDIF)") (("1" (lemma "sigma_swap_triangle") (("1" (inst - "F" "n" "n" "0") (("1" (assert) (("1" (case "NOT ((LAMBDA (j: nat): sigma(0, j, LAMBDA (i: nat): F(i, j))) = (LAMBDA (i: nat):
                                                  g(i) *
                                                   sigma(0, i,
                                                         LAMBDA (j: nat):
                                                           IF j > i THEN 0 ELSE C(i, j) * x ^ j ENDIF)))") (("1" (hide 2) (("1" (decompose-equality) (("1" (lemma "sigma_scal") (("1" (inst - "LAMBDA (j: nat):
                                                IF j > x!1 THEN 0 ELSE C(x!1, j) * x ^ j ENDIF" "g(x!1)" "x!1" "0") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (expand "F" +) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (expand "polynomial") (("2" (lemma "sigma_restrict_eq") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("1" (expand "F" 1) (("1" (replace -1) (("1" (expand "^" +) (("1" (expand "expt" +) (("1" (inst - "0") (("1" (assert) (("1" (replace -3) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "F" +) (("2" (inst - "x!1") (("2" (mult-by -2 "x^x!1") (("1" (mult-by 2 "factorial(x!1)") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_scal") (("1" (inst-cp - "LAMBDA (k: nat):
                                   IF k < x!1 OR k > n THEN 0
                                   ELSE (factorial(k) / factorial(k - x!1)) * g(k)
                                   ENDIF" "x^x!1" "n" "x!1") (("1" (replace -2 :dir rl) (("1" (hide -2) (("1" (inst - "LAMBDA (j: nat):
                                      IF x!1 > j THEN 0 ELSE g(j) * C(j, x!1) * x ^ x!1 ENDIF" "factorial(x!1)" "n" "x!1") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 3) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (replace -1) (("1" (expand "^") (("1" (expand "expt" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (lemma "Bern_subdiv_r_id") (("2" (inst - "b") (("2" (decompose-equality) (("2" (inst - "x!1+1") (("2" (expand "o") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (lemma "Bern_poly_inverse_def") (("2" (inst-cp - "Bern_subdiv_l(b)") (("2" (inst - "Bern_subdiv_r(b)") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (case "Bern_subdiv_l(b)`index = b`index") (("1" (replace -1) (("1" (case "Bern_subdiv_r(b)`index = b`index") (("1" (replace -1) (("1" (inst - "Bern_poly_inverse(Bern_subdiv_l(b))" "Bern_poly_inverse(Bern_subdiv_r(b))" "b`index" "x!1") (("1" (assert) (("1" (hide 1) (("1" (skosimp*) (("1" (expand "Bern_poly_inverse" 1 1) (("1" (replace -2) (("1" (expand "Bern_subdiv_l" +) (("1" (lemma "Bern_sweep_expand") (("1" (case "NOT (LAMBDA (i: nat):
                              IF i > m!1 THEN 0
                              ELSE Bern_sweep(b)(b`index - i)`bern_seq(b`index) *
                                    C(b`index, m!1)
                                    * C(m!1, i)
                                    * (-1) ^ (m!1 - i)
                              ENDIF) = (LAMBDA (i: nat):
                              IF i > m!1 THEN 0
                              ELSE ((1 / (2 ^ (b`index-i))) *
                                         sigma(0, (b`index-i),
                                               LAMBDA (j: nat):
                                                 IF j > (b`index-i) THEN 0
                                                 ELSE b`bern_seq(j + i) * C((b`index-i), j)
                                                 ENDIF)) *
                                    C(b`index, m!1)
                                    * C(m!1, i)
                                    * (-1) ^ (m!1 - i)
                              ENDIF)") (("1" (hide 2) (("1" (assert) (("1" (decompose-equality) (("1" (lift-if) (("1" (ground) (("1" (inst - "b" "b`index - x!2") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (assert :flush? T) (("1" (lift-if) (("1" (ground) (("1" (case "NOT x!2 = 0") (("1" (assert) nil nil) ("2" (hide -2) (("2" (replace -1) (("2" (hide -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil) ("7" (skosimp*) (("7" (assert) nil nil)) nil) ("8" (skosimp*) (("8" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -1) (("2" (assert :flush? T) (("2" (expand "Bern_subdiv_r" +) (("2" (inst - "b" "b`index") (("2" (assert) (("2" (expand "Bern_poly_inverse") (("2" (replace -1) (("2" (assert :flush? T) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil) ("9" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil) (Bern_subdiv_l_id-1 nil 3480781016 ("" (skeep) (("" (decompose-equality) (("" (lemma "Bern_subdiv_r_id") (("" (inst - "b") (("" (decompose-equality) (("" (inst - "x!1+1") (("" (expand "o") (("" (replace -1 :dir rl) (("" (hide -1) (("" (name "xx" "1+x!1") (("" (case "Bern_poly(Bern_subdiv_l(b))(xx-1) =
                                   Bern_poly(Bern_subdiv_r(b))(xx)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide -1) (("2" (expand "Bern_poly") (("2" (name "AA" "LAMBDA (i: nat):
                                                  IF i > Bern_subdiv_l(b)`index THEN 0
                                                  ELSE Bern_subdiv_l(b)`bern_seq(i) *
                                                        Bern(i, Bern_subdiv_l(b)`index)(xx - 1)
                                                  ENDIF") (("1" (replace -1) (("1" (name "BB" "LAMBDA (i: nat):
                                                           IF i > Bern_subdiv_r(b)`index THEN 0
                                                           ELSE Bern_subdiv_r(b)`bern_seq(i) *
                                                                 Bern(i, Bern_subdiv_r(b)`index)(xx)
                                                           ENDIF") (("1" (replace -1) (("1" (expand "Bern_subdiv_l" +) (("1" (expand "Bern_subdiv_r" +) (("1" (expand "Bern_sweep" 1) (("1" (name "mm" "b`index") (("1" (replace -1) (("1" (case "FORALL (ij:upto(mm)): AA(ij) = BB(mm-ij)") (("1" (case "NOT (FORALL (av,bv:[nat->real],mv:nat): ((FORALL (iv: upto(mv)): av(iv) = bv(mv-iv)) IMPLIES sigma(0,mv,av) = sigma(0,mv,bv)))") (("1" (hide-all-but 1) (("1" (induct "mv") (("1" (skeep) (("1" (inst - "0") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "sigma" 1 1) (("2" (lemma "sigma_split") (("2" (inst - "bv!1" "1+j!1" "0" "0") (("2" (assert) (("2" (replace -1 1) (("2" (hide -1) (("2" (copy -2) (("2" (expand "sigma" 1 2) (("2" (expand "sigma" 1 2) (("2" (inst - "1+j!1") (("2" (assert) (("2" (replace -1 1) (("2" (hide -1) (("2" (both-sides "-" "bv!1(0)" 1) (("2" (assert) (("2" (lemma "sigma_shift_T2") (("2" (inst - "bv!1" "j!1" "0" "1") (("2" (assert) (("2" (replace -1 1) (("2" (hide -1) (("2" (inst - "av!1" "LAMBDA (i: nat): bv!1(1 + i)") (("2" (assert) (("2" (hide 2) (("2" (skosimp*) (("2" (inst - "iv!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "AA" "BB" "mm") (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "AA" +) (("2" (expand "BB" +) (("2" (hide -2) (("2" (hide -2) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (expand "Bern_subdiv_r" -1) (("1" (expand "Bern_sweep" -1) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "Bern_subdiv_l" -1) (("2" (assert) nil nil)) nil) ("3" (hide 1) (("3" (hide 2) (("3" (case "Bern_subdiv_l(b)`index = mm") (("1" (replace -1) (("1" (case "Bern_subdiv_r(b)`index = mm") (("1" (replace -1) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (Bern_subdiv_r_id 0 (Bern_subdiv_r_id-1 nil 3480422881 ("" (skeep) (("" (lemma "Bern_subdiv_right_id") (("" (inst - "b") (("" (case "Bern_subdiv_r(b) = Bern_subdiv_right(b)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "Bern_subdiv_r") (("2" (decompose-equality 1) (("1" (decompose-equality 1) (("1" (rewrite "Bern_sweep_expand") (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (case "x!1 = 0") (("1" (replace -1) (("1" (expand "Bern_subdiv_right") (("1" (lemma "sigma_reverse") (("1" (inst - "LAMBDA (j: nat):
                IF j > b`index THEN 0
                ELSE C(b`index, j) * b`bern_seq(b`index - j)
                ENDIF" "b`index" "0") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "C") (("1" (assert) (("1" (div-by 1 "1/2^b`index") (("1" (skosimp*) (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (expand "Bern_subdiv_right") (("2" (div-by 2 "1/2^(b`index-x!1)") (("1" (lemma "sigma_reverse") (("1" (inst - "LAMBDA (j: nat):
                IF j > b`index - x!1 THEN 0
                ELSE C(b`index - x!1, j) * b`bern_seq(b`index - j)
                ENDIF" "b`index - x!1" "0") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_restrict_eq") (("1" (inst?) (("1" (assert) (("1" (hide 3) (("1" (decompose-equality 1) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil) ("7" (skosimp*) (("7" (assert) nil nil)) nil) ("8" (skosimp*) (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (expand "Bern_subdiv_right") (("2" (propax) nil nil)) nil) ("3" (skosimp*) (("3" (assert) (("3" (expand "Bern_subdiv_right") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_subdiv_right_id formula-decl nil bernstein_polynomials nil) (Bern_subdiv_right const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bern_subdiv_r const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (sigma_reverse formula-decl nil sigma_nat nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (times_div_cancel1 formula-decl nil extra_real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (factorial def-decl "posnat" factorial ints) (sigma def-decl "real" sigma nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (^ const-decl "real" exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (both_sides_div1 formula-decl nil real_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (C const-decl "posnat" binomial nil) (> const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (x!1 skolem-const-decl "upto(b`index)" bernstein_polynomials nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (sigma_restrict_eq formula-decl nil sigma nil) (restrict const-decl "[T -> real]" sigma nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Bern_sweep_expand formula-decl nil bernstein_polynomials nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bern_sweep def-decl "{bp: Bernstein_Polynomial | bp`index = b`index}" bernstein_polynomials nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real nonempty-type-from-decl nil reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (Bern_coeff_TCC1 0 (Bern_coeff_TCC1-1 nil 3479550050 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (Bern_coeff subtype "bernstein_polynomials.i" "{i: naturalnumbers.nat | reals.<=(i, bernstein_polynomials.s)}"))) (Bern_coeff_TCC2 0 (Bern_coeff_TCC2-1 nil 3479550050 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (Bern_coeff subtype "bernstein_polynomials.i" "{i: naturalnumbers.nat | reals.<=(i, bernstein_polynomials.m)}"))) (Bernstein_le 0 (Bernstein_le-1 nil 3479565645 ("" (skeep) (("" (lemma "Bernstein_equivalence") (("" (inst - "a" "m" "p") (("" (assert) (("" (replace -1) (("" (hide -1) (("" (expand "Bern_poly") (("" (name "AA" "LAMBDA (i: nat):
                                   IF i > Bernstein_polynomial(a, p, m)`index THEN 0
                                   ELSE Bernstein_polynomial(a, p, m)`bern_seq(i) *
                                         Bern(i, Bernstein_polynomial(a, p, m)`index)(x)
                                   ENDIF") (("1" (replace -1) (("1" (lemma "sigma_le") (("1" (inst - "AA" "LAMBDA (i:nat): IF i>m THEN 0 ELSE Ma*Bern(i,m)(x) ENDIF" "m" "0") (("1" (split -) (("1" (expand "Bernstein_polynomial") (("1" (lemma "sigma_scal") (("1" (inst - "LAMBDA (i:nat): IF i>m THEN 0 ELSE Bern(i,m)(x) ENDIF" "Ma" "m" "0") (("1" (lemma "Bernstein_partition_of_unity") (("1" (inst - "m" "x") (("1" (mult-by -1 "Ma") (("1" (replace -1) (("1" (hide -1) (("1" (case "(LAMBDA (i_1: nat):
                                                                 Ma * IF i_1 > m THEN 0 ELSE Bern(i_1, m)(x) ENDIF) = (LAMBDA (i: nat): IF i > m THEN 0 ELSE Ma * Bern(i, m)(x) ENDIF)") (("1" (assert) nil nil) ("2" (decompose-equality) (("1" (lift-if) (("1" (ground) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (nn: subrange(0, m)):
        AA(nn) <= IF nn > m THEN 0 ELSE Ma * Bern(nn, m)(x) ENDIF") (("1" (propax) nil nil) ("2" (hide 2) (("2" (skeep) (("2" (lift-if) (("2" (ground) (("2" (replace -1 2 :dir rl) (("2" (assert) (("2" (lift-if) (("2" (ground) (("1" (expand "Bernstein_polynomial") (("1" (propax) nil nil)) nil) ("2" (expand "Bernstein_polynomial") (("2" (inst - "nn") (("2" (case "sigma(0, nn,
                                          LAMBDA (i: nat):
                                            IF i > nn OR i > p THEN 0
                                            ELSE a(i) * (C(nn, i) / C(m, i))
                                            ENDIF) = Bern_coeff(a,p,m)(nn)") (("1" (replace -1 :dir rl) (("1" (mult-by -3 "Bern(nn,m)(x)") (("1" (skosimp*) (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (lemma "Bern_nonnegative") (("3" (inst - "x") (("3" (assert) (("3" (inst - "nn" "m") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Bern_coeff" 1) (("2" (hide 3) (("2" (hide -1) (("2" (expand "min") (("2" (lift-if) (("2" (ground) (("1" (lemma "sigma_split") (("1" (inst - "LAMBDA (i: nat):
                                          IF i > nn OR i > p THEN 0
                                          ELSE a(i) * (C(nn, i) / C(m, i))
                                          ENDIF" "nn" "0" "p") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (i: nat):
                                               IF i > nn OR i > p THEN 0
                                               ELSE a(i) * (C(nn, i) / C(m, i))
                                               ENDIF" "LAMBDA (i: nat):
                                               0" "nn" "1+p") (("1" (split -1) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_zero") (("1" (inst - "nn" "1+p") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (i: nat):
                                                      IF i > nn OR i > p THEN 0
                                                      ELSE a(i) * (C(nn, i) / C(m, i))
                                                      ENDIF" "LAMBDA (i: nat):
                                                       IF i > p THEN 0 ELSE a(i) * (C(nn, i) / C(m, i)) ENDIF" "p" "0") (("1" (assert) (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (i: nat):
                                          IF i > nn OR i > p THEN 0
                                          ELSE a(i) * (C(nn, i) / C(m, i))
                                          ENDIF" "LAMBDA (i: nat):
                                           IF i > nn THEN 0 ELSE a(i) * (C(nn, i) / C(m, i)) ENDIF" "nn" "0") (("1" (assert) (("1" (hide 3) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Bernstein_polynomial") (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "Bernstein_polynomial") (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bernstein_equivalence formula-decl nil bernstein_polynomials nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Bern const-decl "real" bernstein_polynomials nil) (above nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (Bernstein_polynomial const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_times_real_is_real application-judgement "real" reals nil) (<= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (sigma_le formula-decl nil sigma nil) (sigma_scal formula-decl nil sigma nil) (Bernstein_partition_of_unity formula-decl nil bernstein_polynomials nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (sigma def-decl "real" sigma nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (C const-decl "posnat" binomial nil) (Bern_coeff const-decl "real" bernstein_polynomials nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (p skolem-const-decl "nat" bernstein_polynomials nil) (x skolem-const-decl "real" bernstein_polynomials nil) (nn skolem-const-decl "subrange(0, m)" bernstein_polynomials nil) (Bern_nonnegative formula-decl nil bernstein_polynomials nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (sigma_restrict_eq formula-decl nil sigma nil) (restrict const-decl "[T -> real]" sigma nil) (real_plus_real_is_real application-judgement "real" reals nil) (sigma_nat application-judgement "nat" sigma_nat nil) (sigma_zero formula-decl nil sigma nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_split formula-decl nil sigma nil) (subrange type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (m skolem-const-decl "nat" bernstein_polynomials nil) (Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (sequence type-eq-decl nil sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (Bernstein_lt 0 (Bernstein_lt-1 nil 3479565700 ("" (skeep) (("" (case "FORALL (msn: upto(m)): EXISTS (Mc: real): Mc < Ma AND (FORALL (s:upto(msn)): Bern_coeff(a,p,m)(s) <= Mc)") (("1" (inst - "m") (("1" (skosimp*) (("1" (lemma "Bernstein_le") (("1" (inst - "Mc!1" "a" "m" "p" "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "msn") (("1" (inst + "Bern_coeff(a,p,m)(0)") (("1" (inst - "0") (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (skosimp*) (("2" (inst + "max(Bern_coeff(a,p,m)(1+jt),Mc!1)") (("1" (expand "max" +) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (flatten) (("1" (skosimp*) (("1" (inst - "s!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -4 "1+jt") (("2" (assert) (("2" (skosimp*) (("2" (inst - "s!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_coeff const-decl "real" bernstein_polynomials nil) (sequence type-eq-decl nil sequences nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Bernstein_le formula-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (pred type-eq-decl nil defined_types nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (s!1 skolem-const-decl "upto(1 + jt)" bernstein_polynomials nil) (s!1 skolem-const-decl "upto(1 + jt)" bernstein_polynomials nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (jt skolem-const-decl "upto(m)" bernstein_polynomials nil) (m skolem-const-decl "nat" bernstein_polynomials nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil)) (Bernstein_ge 0 (Bernstein_ge-1 nil 3479566938 ("" (skeep) (("" (lemma "Bernstein_equivalence") (("" (inst - "a" "m" "p") (("" (assert) (("" (replace -1) (("" (hide -1) (("" (expand "Bern_poly") (("" (name "AA" "LAMBDA (i: nat):
                                                 IF i > Bernstein_polynomial(a, p, m)`index THEN 0
                                                 ELSE Bernstein_polynomial(a, p, m)`bern_seq(i) *
                                                       Bern(i, Bernstein_polynomial(a, p, m)`index)(x)
                                                 ENDIF") (("1" (replace -1) (("1" (lemma "sigma_le") (("1" (inst - "LAMBDA (i:nat): IF i>m THEN 0 ELSE Ma*Bern(i,m)(x) ENDIF" "AA" "m" "0") (("1" (split -) (("1" (expand "Bernstein_polynomial") (("1" (lemma "sigma_scal") (("1" (inst - "LAMBDA (i:nat): IF i>m THEN 0 ELSE Bern(i,m)(x) ENDIF" "Ma" "m" "0") (("1" (lemma "Bernstein_partition_of_unity") (("1" (inst - "m" "x") (("1" (mult-by -1 "Ma") (("1" (replace -1) (("1" (hide -1) (("1" (case "(LAMBDA (i_1: nat):
                                                                                                   Ma * IF i_1 > m THEN 0 ELSE Bern(i_1, m)(x) ENDIF) = (LAMBDA (i: nat): IF i > m THEN 0 ELSE Ma * Bern(i, m)(x) ENDIF)") (("1" (assert) nil nil) ("2" (decompose-equality) (("1" (lift-if) (("1" (ground) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (nn: subrange(0, m)):
        IF nn > m THEN 0 ELSE Ma * Bern(nn, m)(x) ENDIF <= AA(nn)") (("1" (propax) nil nil) ("2" (hide 2) (("2" (skeep) (("2" (lift-if) (("2" (ground) (("2" (replace -1 2 :dir rl) (("2" (assert) (("2" (lift-if) (("2" (ground) (("1" (expand "Bernstein_polynomial") (("1" (propax) nil nil)) nil) ("2" (expand "Bernstein_polynomial") (("2" (inst - "nn") (("2" (case "sigma(0, nn,
                                                                        LAMBDA (i: nat):
                                                                          IF i > nn OR i > p THEN 0
                                                                          ELSE a(i) * (C(nn, i) / C(m, i))
                                                                          ENDIF) = Bern_coeff(a,p,m)(nn)") (("1" (replace -1 :dir rl) (("1" (mult-by -3 "Bern(nn,m)(x)") (("1" (assert) nil nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (lemma "Bern_nonnegative") (("3" (inst - "x") (("3" (assert) (("3" (inst - "nn" "m") (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "Bern_nonnegative") (("4" (inst - "x") (("4" (assert) (("4" (inst - "nn" "m") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Bern_coeff" 1) (("2" (hide 3) (("2" (hide -1) (("2" (expand "min") (("2" (lift-if) (("2" (ground) (("1" (lemma "sigma_split") (("1" (inst - "LAMBDA (i: nat):
                                                                      IF i > nn OR i > p THEN 0
                                                                      ELSE a(i) * (C(nn, i) / C(m, i))
                                                                      ENDIF" "nn" "0" "p") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (i: nat):
                                                                               IF i > nn OR i > p THEN 0
                                                                               ELSE a(i) * (C(nn, i) / C(m, i))
                                                                               ENDIF" "LAMBDA (i: nat):
                                                                               0" "nn" "1+p") (("1" (split -1) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_zero") (("1" (inst - "nn" "1+p") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (i: nat):
                                                                                              IF i > nn OR i > p THEN 0
                                                                                              ELSE a(i) * (C(nn, i) / C(m, i))
                                                                                              ENDIF" "LAMBDA (i: nat):
                                                                                               IF i > p THEN 0 ELSE a(i) * (C(nn, i) / C(m, i)) ENDIF" "p" "0") (("1" (assert) (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (i: nat):
                                                                      IF i > nn OR i > p THEN 0
                                                                      ELSE a(i) * (C(nn, i) / C(m, i))
                                                                      ENDIF" "LAMBDA (i: nat):
                                                                       IF i > nn THEN 0 ELSE a(i) * (C(nn, i) / C(m, i)) ENDIF" "nn" "0") (("1" (assert) (("1" (hide 3) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Bernstein_polynomial") (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "Bernstein_polynomial") (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bernstein_equivalence formula-decl nil bernstein_polynomials nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Bern const-decl "real" bernstein_polynomials nil) (above nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (Bernstein_polynomial const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_times_real_is_real application-judgement "real" reals nil) (<= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (sigma_le formula-decl nil sigma nil) (sigma_scal formula-decl nil sigma nil) (Bernstein_partition_of_unity formula-decl nil bernstein_polynomials nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (sigma def-decl "real" sigma nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (C const-decl "posnat" binomial nil) (Bern_coeff const-decl "real" bernstein_polynomials nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (p skolem-const-decl "nat" bernstein_polynomials nil) (x skolem-const-decl "real" bernstein_polynomials nil) (nn skolem-const-decl "subrange(0, m)" bernstein_polynomials nil) (Bern_nonnegative formula-decl nil bernstein_polynomials nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (sigma_restrict_eq formula-decl nil sigma nil) (restrict const-decl "[T -> real]" sigma nil) (real_plus_real_is_real application-judgement "real" reals nil) (sigma_nat application-judgement "nat" sigma_nat nil) (sigma_zero formula-decl nil sigma nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (sigma_split formula-decl nil sigma nil) (subrange type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (m skolem-const-decl "nat" bernstein_polynomials nil) (Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (sequence type-eq-decl nil sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (Bernstein_gt 0 (Bernstein_gt-1 nil 3479567287 ("" (skeep) (("" (case "FORALL (msn: upto(m)): EXISTS (Mc: real): Mc>Ma AND (FORALL (s:upto(msn)): Bern_coeff(a,p,m)(s) >= Mc)") (("1" (inst - "m") (("1" (skosimp*) (("1" (lemma "Bernstein_ge") (("1" (inst - "Mc!1" "a" "m" "p" "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "msn") (("1" (inst + "Bern_coeff(a,p,m)(0)") (("1" (inst - "0") (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (skosimp*) (("2" (inst + "min(Bern_coeff(a,p,m)(1+jt),Mc!1)") (("1" (expand "min" +) (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (flatten) (("1" (skosimp*) (("1" (inst - "s!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -4 "1+jt") (("2" (assert) (("2" (skosimp*) (("2" (inst - "s!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_coeff const-decl "real" bernstein_polynomials nil) (sequence type-eq-decl nil sequences nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Bernstein_ge formula-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (pred type-eq-decl nil defined_types nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (s!1 skolem-const-decl "upto(1 + jt)" bernstein_polynomials nil) (s!1 skolem-const-decl "upto(1 + jt)" bernstein_polynomials nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (jt skolem-const-decl "upto(m)" bernstein_polynomials nil) (m skolem-const-decl "nat" bernstein_polynomials nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil)) (Bern_poly_le 0 (Bern_poly_le-2 nil 3495454459 ("" (skeep) (("" (expand "Bern_poly") (("" (lemma "sigma_le") (("" (inst - "LAMBDA (i: nat):
                IF i > b`index THEN 0
                ELSE b`bern_seq(i) * Bern(i, b`index)(x)
                ENDIF" "LAMBDA (i: nat):
                IF i > b`index THEN 0
                ELSE Ma * Bern(i, b`index)(x)
                ENDIF" "b`index" "0") (("1" (assert) (("1" (split -) (("1" (lemma "Bernstein_partition_of_unity") (("1" (inst - "b`index" "x") (("1" (mult-by -1 "Ma") (("1" (lemma "sigma_scal") (("1" (inst - "LAMBDA (i: nat):
                      IF i > b`index THEN 0 ELSE Bern(i, b`index)(x) ENDIF" "Ma" "b`index" "0") (("1" (case "(LAMBDA (i_1: nat):
                             Ma *
                              IF i_1 > b`index THEN 0 ELSE Bern(i_1, b`index)(x) ENDIF) = (LAMBDA (i: nat):
                              IF i > b`index THEN 0 ELSE Ma * Bern(i, b`index)(x) ENDIF)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality +) (("1" (lift-if) (("1" (ground) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "n!1") (("2" (mult-by -1 "Bern(n!1,b`index)(x)") (("2" (lemma "Bern_nonnegative") (("2" (inst?) (("2" (assert) (("2" (inst - "n!1" "b`index") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (real_times_real_is_real application-judgement "real" reals nil) (<= const-decl "bool" reals nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (sigma_scal formula-decl nil sigma nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (sigma def-decl "real" sigma nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (Bernstein_partition_of_unity formula-decl nil bernstein_polynomials nil) (subrange type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Bern_nonnegative formula-decl nil bernstein_polynomials nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (n!1 skolem-const-decl "subrange(0, b`index)" bernstein_polynomials nil) (x skolem-const-decl "real" bernstein_polynomials nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_le formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil) (Bern_poly_le-1 nil 3495454414 (";;; Proof Bernstein_le-1 for formula bernstein_polynomials.Bernstein_le" (skeep) ((";;; Proof Bernstein_le-1 for formula bernstein_polynomials.Bernstein_le" (lemma "Bernstein_equivalence") ((";;; Proof Bernstein_le-1 for formula bernstein_polynomials.Bernstein_le" (inst - "a" "m" "p") ((";;; Proof Bernstein_le-1 for formula bernstein_polynomials.Bernstein_le" (assert) ((";;; Proof Bernstein_le-1 for formula bernstein_polynomials.Bernstein_le" (replace -1) ((";;; Proof Bernstein_le-1 for formula bernstein_polynomials.Bernstein_le" (hide -1) ((";;; Proof Bernstein_le-1 for formula bernstein_polynomials.Bernstein_le" (expand "Bern_poly") ((";;; Proof Bernstein_le-1 for formula bernstein_polynomials.Bernstein_le" (name "AA" "LAMBDA (i: nat):
                                          IF i > Bernstein_polynomial(a, p, m)`index THEN 0
                                          ELSE Bernstein_polynomial(a, p, m)`bern_seq(i) *
                                                Bern(i, Bernstein_polynomial(a, p, m)`index)(x)
                                          ENDIF") (("1" (replace -1) (("1" (lemma "sigma_le") (("1" (inst - "AA" "LAMBDA (i:nat): IF i>m THEN 0 ELSE Ma*Bern(i,m)(x) ENDIF" "m" "0") (("1" (split -) (("1" (expand "Bernstein_polynomial") (("1" (lemma "sigma_scal") (("1" (inst - "LAMBDA (i:nat): IF i>m THEN 0 ELSE Bern(i,m)(x) ENDIF" "Ma" "m" "0") (("1" (lemma "Bernstein_partition_of_unity") (("1" (inst - "m" "x") (("1" (mult-by -1 "Ma") (("1" (replace -1) (("1" (hide -1) (("1" (case "(LAMBDA (i_1: nat):
                                                                                  Ma * IF i_1 > m THEN 0 ELSE Bern(i_1, m)(x) ENDIF) = (LAMBDA (i: nat): IF i > m THEN 0 ELSE Ma * Bern(i, m)(x) ENDIF)") (("1" (assert) nil) ("2" (decompose-equality) (("1" (lift-if) (("1" (ground) nil))) ("2" (skosimp*) (("2" (assert) nil))))) ("3" (skosimp*) (("3" (assert) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))))))))) ("2" (case "FORALL (nn: subrange(0, m)):
                     AA(nn) <= IF nn > m THEN 0 ELSE Ma * Bern(nn, m)(x) ENDIF") (("1" (propax) nil) ("2" (hide 2) (("2" (skeep) (("2" (lift-if) (("2" (ground) (("2" (replace -1 2 :dir rl) (("2" (assert) (("2" (lift-if) (("2" (ground) (("1" (expand "Bernstein_polynomial") (("1" (propax) nil))) ("2" (expand "Bernstein_polynomial") (("2" (inst - "nn") (("2" (case "sigma(0, nn,
                                                           LAMBDA (i: nat):
                                                             IF i > nn OR i > p THEN 0
                                                             ELSE a(i) * (C(nn, i) / C(m, i))
                                                             ENDIF) = Bern_coeff(a,p,m)(nn)") (("1" (replace -1 :dir rl) (("1" (mult-by -3 "Bern(nn,m)(x)") (("1" (skosimp*) (("1" (assert) nil))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (lemma "Bern_nonnegative") (("3" (inst - "x") (("3" (assert) (("3" (inst - "nn" "m") nil))))))))))) ("2" (expand "Bern_coeff" 1) (("2" (hide 3) (("2" (hide -1) (("2" (expand "min") (("2" (lift-if) (("2" (ground) (("1" (lemma "sigma_split") (("1" (inst - "LAMBDA (i: nat):
                                                          IF i > nn OR i > p THEN 0
                                                          ELSE a(i) * (C(nn, i) / C(m, i))
                                                          ENDIF" "nn" "0" "p") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (i: nat):
                                                                 IF i > nn OR i > p THEN 0
                                                                 ELSE a(i) * (C(nn, i) / C(m, i))
                                                                 ENDIF" "LAMBDA (i: nat):
                                                                 0" "nn" "1+p") (("1" (split -1) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_zero") (("1" (inst - "nn" "1+p") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_restrict_eq") (("1" (inst - "LAMBDA (i: nat):
                                                                            IF i > nn OR i > p THEN 0
                                                                            ELSE a(i) * (C(nn, i) / C(m, i))
                                                                            ENDIF" "LAMBDA (i: nat):
                                                                             IF i > p THEN 0 ELSE a(i) * (C(nn, i) / C(m, i)) ENDIF" "p" "0") (("1" (assert) (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (propax) nil))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))) ("5" (skosimp*) (("5" (assert) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))) ("5" (skosimp*) (("5" (assert) nil))))))))))))))))))) ("2" (hide 2) (("2" (decompose-equality) (("1" (expand "restrict") (("1" (propax) nil))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))))))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))))))) ("2" (lemma "sigma_restrict_eq") (("2" (inst - "LAMBDA (i: nat):
                                                          IF i > nn OR i > p THEN 0
                                                          ELSE a(i) * (C(nn, i) / C(m, i))
                                                          ENDIF" "LAMBDA (i: nat):
                                                           IF i > nn THEN 0 ELSE a(i) * (C(nn, i) / C(m, i)) ENDIF" "nn" "0") (("1" (assert) (("1" (hide 3) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (propax) nil))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))) ("5" (skosimp*) (("5" (assert) nil))))))))) ("2" (skosimp*) (("2" (assert) nil))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))) ("5" (skosimp*) (("5" (assert) nil))))))))))))))))))) ("3" (skosimp*) (("3" (assert) nil))) ("4" (skosimp*) (("4" (assert) nil))))))))))))))))))))))))))))) ("2" (skosimp*) (("2" (assert) nil))))))))) ("2" (expand "Bernstein_polynomial") (("2" (skosimp*) (("2" (assert) nil))))) ("3" (expand "Bernstein_polynomial") (("3" (skosimp*) (("3" (assert) nil)))))))))))))))))))) ";;; developed with shostak decision procedures") nil nil)) (Bern_poly_lt 0 (Bern_poly_lt-1 nil 3495456636 ("" (skeep) (("" (case "EXISTS (MM:real): MM<Ma AND FORALL (s:upto(b`index)): b`bern_seq(s) <= MM") (("1" (skosimp*) (("1" (lemma "Bern_poly_le") (("1" (inst - "MM!1" "b" "x") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (j:upto(b`index)): EXISTS (MM: real):
                 MM < Ma AND (FORALL (s: upto(j)): b`bern_seq(s) <= MM)") (("1" (inst - "b`index") nil nil) ("2" (hide 2) (("2" (induct "j") (("1" (inst + "b`bern_seq(0)/2 + Ma/2") (("1" (assert) (("1" (inst - "0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (skolem 1 "jj") (("2" (flatten) (("2" (skosimp*) (("2" (case "b`bern_seq(1+jj) <= MM!1") (("1" (inst + "MM!1") (("1" (assert) (("1" (skosimp*) (("1" (case "s!1 = 1+jj") (("1" (assert) nil nil) ("2" (inst - "s!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst + "b`bern_seq(1+jj)") (("2" (split) (("1" (inst -4 "1+jj") nil nil) ("2" (skosimp*) (("2" (case "s!1 = 1+jj") (("1" (assert) nil nil) ("2" (inst - "s!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Bern_poly_le formula-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (s!1 skolem-const-decl "upto(1 + jj)" bernstein_polynomials nil) (jj skolem-const-decl "upto(b`index)" bernstein_polynomials nil) (s!1 skolem-const-decl "upto(1 + jj)" bernstein_polynomials nil) (= const-decl "[T, T -> boolean]" equalities nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)) nil)) (Bern_poly_ge 0 (Bern_poly_ge-1 nil 3495457278 ("" (skeep) (("" (expand "Bern_poly") (("" (lemma "sigma_ge") (("" (inst - "LAMBDA (i: nat):
                    IF i > b`index THEN 0
                    ELSE b`bern_seq(i) * Bern(i, b`index)(x)
                    ENDIF" "LAMBDA (i: nat):
                    IF i > b`index THEN 0
                    ELSE Ma * Bern(i, b`index)(x)
                    ENDIF" "b`index" "0") (("1" (assert) (("1" (split -) (("1" (lemma "Bernstein_partition_of_unity") (("1" (inst - "b`index" "x") (("1" (mult-by -1 "Ma") (("1" (lemma "sigma_scal") (("1" (inst - "LAMBDA (i: nat):
                                      IF i > b`index THEN 0 ELSE Bern(i, b`index)(x) ENDIF" "Ma" "b`index" "0") (("1" (case "(LAMBDA (i_1: nat):
                                                           Ma *
                                                            IF i_1 > b`index THEN 0 ELSE Bern(i_1, b`index)(x) ENDIF) = (LAMBDA (i: nat):
                                                            IF i > b`index THEN 0 ELSE Ma * Bern(i, b`index)(x) ENDIF)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality +) (("1" (lift-if) (("1" (ground) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "n!1") (("2" (mult-by -1 "Bern(n!1,b`index)(x)") (("2" (lemma "Bern_nonnegative") (("2" (inst?) (("2" (assert) (("2" (inst - "n!1" "b`index") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (real_times_real_is_real application-judgement "real" reals nil) (<= const-decl "bool" reals nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (sigma_scal formula-decl nil sigma nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (sigma def-decl "real" sigma nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (Bernstein_partition_of_unity formula-decl nil bernstein_polynomials nil) (subrange type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Bern_nonnegative formula-decl nil bernstein_polynomials nil) (n!1 skolem-const-decl "subrange(0, b`index)" bernstein_polynomials nil) (x skolem-const-decl "real" bernstein_polynomials nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_ge formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil)) (Bern_poly_gt 0 (Bern_poly_gt-1 nil 3495457342 ("" (skeep) (("" (case "EXISTS (MM:real): MM>Ma AND FORALL (s:upto(b`index)): b`bern_seq(s) >= MM") (("1" (skosimp*) (("1" (lemma "Bern_poly_ge") (("1" (inst - "MM!1" "b" "x") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (j:upto(b`index)): EXISTS (MM: real):
                                   MM > Ma AND (FORALL (s: upto(j)): b`bern_seq(s) >= MM)") (("1" (inst - "b`index") nil nil) ("2" (hide 2) (("2" (induct "j") (("1" (inst + "b`bern_seq(0)/2 + Ma/2") (("1" (assert) (("1" (inst - "0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (skolem 1 "jj") (("2" (flatten) (("2" (skosimp*) (("2" (case "b`bern_seq(1+jj) >= MM!1") (("1" (inst + "MM!1") (("1" (assert) (("1" (skosimp*) (("1" (case "s!1 = 1+jj") (("1" (assert) nil nil) ("2" (inst - "s!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst + "b`bern_seq(1+jj)") (("2" (split) (("1" (inst -4 "1+jj") nil nil) ("2" (skosimp*) (("2" (case "s!1 = 1+jj") (("1" (assert) nil nil) ("2" (inst - "s!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Bern_poly_ge formula-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (s!1 skolem-const-decl "upto(1 + jj)" bernstein_polynomials nil) (jj skolem-const-decl "upto(b`index)" bernstein_polynomials nil) (s!1 skolem-const-decl "upto(1 + jj)" bernstein_polynomials nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (pred type-eq-decl nil defined_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)) nil)) (Bern_poly_quotient_le_TCC1 0 (Bern_poly_quotient_le_TCC1-1 nil 3563530782 ("" (subtype-tcc) nil nil) ((Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (Bern_poly_quotient_le subtype "bernstein_polynomials.s" "naturalnumbers.upto(bernstein_polynomials.b2`index)"))) (Bern_poly_quotient_le_TCC2 0 (Bern_poly_quotient_le_TCC2-1 nil 3563530782 ("" (subtype-tcc) nil nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (/= const-decl "boolean" notequal nil)) nil (Bern_poly_quotient_le subtype "bernstein_polynomials.b2`bern_seq(bernstein_polynomials.s)" "nznum"))) (Bern_poly_quotient_le_TCC3 0 (Bern_poly_quotient_le_TCC3-1 nil 3563530782 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (C const-decl "posnat" binomial nil) (^ const-decl "real" exponentiation nil) (Bern const-decl "real" bernstein_polynomials nil) (Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (posint_times_posint_is_posint application-judgement "posint" integers nil)) nil (Bern_poly_quotient_le subtype "bernstein_polynomials.Bern_poly(bernstein_polynomials.b2)(bernstein_polynomials.x)" "nznum"))) (Bern_poly_quotient_le 0 (Bern_poly_quotient_le-1 nil 3563530782 ("" (skeep) (("" (case "NOT Bern_poly(b2)(x) > 0") (("1" (hide 2) (("1" (lemma "Bern_poly_gt") (("1" (inst - "0" "b2" "x") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "Bern_poly_le") (("2" (inst - "0" "(# index := b1`index, bern_seq:= (LAMBDA (ii:upto(b1`index)): b1`bern_seq(ii) - Ma*b2`bern_seq(ii)) #)" "x") (("1" (assert) (("1" (split -) (("1" (expand "Bern_poly") (("1" (invoke (case "%1 > 0") (! 1 1 2)) (("1" (cross-mult 1) (("1" (assert) (("1" (rewrite "sigma_scal" :dir rl) (("1" (invoke (case "%1 - %2 <=0") (! 1 1) (! 1 2)) (("1" (assert) nil nil) ("2" (hide 2) (("2" (replace -4 :dir rl) (("2" (rewrite "sigma_minus") (("1" (case "(LAMBDA (i: nat):
                                                            IF i > b1`index THEN 0
                                                            ELSE b1`bern_seq(i) * Bern(i, b1`index)(x) -
                                                                  b2`bern_seq(i) * Bern(i, b1`index)(x) * Ma
                                                            ENDIF) = (LAMBDA (i_1: nat):
                                                            IF i_1 > b1`index THEN 0
                                                            ELSE b1`bern_seq(i_1) * Bern(i_1, b1`index)(x)
                                                            ENDIF
                                                             -
                                                             Ma *
                                                              IF i_1 > b1`index THEN 0
                                                              ELSE b2`bern_seq(i_1) * Bern(i_1, b1`index)(x)
                                                              ENDIF)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (lift-if) (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil) ("6" (skosimp*) (("6" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "s") (("2" (cross-mult -4) (("2" (ground) (("2" (inst - "s") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Bern_poly_gt formula-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (b2 skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (b1 skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Bern const-decl "real" bernstein_polynomials nil) (above nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (sigma def-decl "real" sigma nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (int_minus_int_is_int application-judgement "int" integers nil) (sigma_minus formula-decl nil sigma nil) (sigma_scal formula-decl nil sigma nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (div_mult_pos_neg_le1 formula-decl nil extra_real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (Bern_poly_le formula-decl nil bernstein_polynomials nil)) shostak)) (Bern_poly_split_le 0 (Bern_poly_split_le-1 nil 3495465019 ("" (skeep) (("" (assert) (("" (flatten) (("" (skeep) (("" (inst - "2*(x-1/2)") (("" (inst - "2*x") (("" (assert) (("" (lemma "Bern_subdiv_r_id") (("" (inst?) (("" (replace -1) (("" (hide -1) (("" (lemma "Bern_subdiv_l_id") (("" (inst?) (("" (replace -1) (("" (hide -1) (("" (assert) (("" (grind :exclude "Bern_poly") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_subdiv_r_id formula-decl nil bernstein_polynomials nil) (Bern_subdiv_l_id formula-decl nil bernstein_polynomials nil) (real_plus_real_is_real application-judgement "real" reals nil) (O const-decl "T3" function_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (Bern_poly_split_lt 0 (Bern_poly_split_lt-3 nil 3495466717 ("" (skeep) (("" (assert) (("" (flatten) (("" (skeep) (("" (inst - "2*(x-1/2)") (("" (inst - "2*x") (("" (assert) (("" (lemma "Bern_subdiv_r_id") (("" (inst?) (("" (replace -1) (("" (hide -1) (("" (lemma "Bern_subdiv_l_id") (("" (inst?) (("" (replace -1) (("" (hide -1) (("" (assert) (("" (grind :exclude "Bern_poly") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_subdiv_r_id formula-decl nil bernstein_polynomials nil) (Bern_subdiv_l_id formula-decl nil bernstein_polynomials nil) (real_plus_real_is_real application-judgement "real" reals nil) (O const-decl "T3" function_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_times_real_is_real application-judgement "real" reals nil)) nil) (Bern_poly_split_lt-2 nil 3495465957 ("" (skeep) (("" (assert) (("" (flatten) (("" (label "bslineq" -1) (("" (label "bsrineq" -2) (("" (lemma "Bern_subdiv_l_id") (("" (inst?) (("" (label "bslid" -1) (("" (lemma "Bern_subdiv_r_id") (("" (inst?) (("" (label "bsrid" -1) (("" (lemma "Bern_poly_lt") (("" (label "bplem" -1) (("" (case "x<=1/2") (("1" (inst - "Ma" "Bern_subdiv_l(b)" "2*x") (("1" (assert) (("1" (replace "bslineq") (("1" (replace "bslid" "bplem") (("1" (expand "o") (("1" (assert) nil))))))))))) ("2" (inst - "Ma" "Bern_subdiv_r(b)" "2*(x-1/2)") (("2" (replace "bsrineq") (("2" (assert) (("2" (replace "bsrid") (("2" (expand "o") (("2" (assert) nil)))))))))))))))))))))))))))))))))))))) nil) nil nil) (Bern_poly_split_lt-1 nil 3495465923 ("" (skeep) (("" (assert) (("" (flatten) (("" (label "bslineq" -1) (("" (label "bsrineq" -2) (("" (lemma "Bern_subdiv_l_id") (("" (inst?) (("" (label "bslid" -1) (("" (lemma "Bern_subdiv_r_id") (("" (inst?) (("" (label "bsrid" -1) (("" (lemma "Bern_poly_le") (("" (label "bplem" -1) (("" (case "x<=1/2") (("1" (inst - "Ma" "Bern_subdiv_l(b)" "2*x") (("1" (assert) (("1" (replace "bslineq") (("1" (replace "bslid" "bplem") (("1" (expand "o") (("1" (assert) nil))))))))))) ("2" (inst - "Ma" "Bern_subdiv_r(b)" "2*(x-1/2)") (("2" (replace "bsrineq") (("2" (assert) (("2" (replace "bsrid") (("2" (expand "o") (("2" (assert) nil)))))))))))))))))))))))))))))))))))))) nil) nil nil)) (Bern_poly_split_ge 0 (Bern_poly_split_ge-3 nil 3495466791 ("" (skeep) (("" (assert) (("" (flatten) (("" (skeep) (("" (inst - "2*(x-1/2)") (("" (inst - "2*x") (("" (assert) (("" (lemma "Bern_subdiv_r_id") (("" (inst?) (("" (replace -1) (("" (hide -1) (("" (lemma "Bern_subdiv_l_id") (("" (inst?) (("" (replace -1) (("" (hide -1) (("" (assert) (("" (grind :exclude "Bern_poly") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_subdiv_r_id formula-decl nil bernstein_polynomials nil) (Bern_subdiv_l_id formula-decl nil bernstein_polynomials nil) (real_plus_real_is_real application-judgement "real" reals nil) (O const-decl "T3" function_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_times_real_is_real application-judgement "real" reals nil)) nil) (Bern_poly_split_ge-2 nil 3495465972 ("" (skeep) (("" (assert) (("" (flatten) (("" (label "bslineq" -1) (("" (label "bsrineq" -2) (("" (lemma "Bern_subdiv_l_id") (("" (inst?) (("" (label "bslid" -1) (("" (lemma "Bern_subdiv_r_id") (("" (inst?) (("" (label "bsrid" -1) (("" (lemma "Bern_poly_ge") (("" (label "bplem" -1) (("" (case "x<=1/2") (("1" (inst - "Ma" "Bern_subdiv_l(b)" "2*x") (("1" (assert) (("1" (replace "bslineq") (("1" (replace "bslid" "bplem") (("1" (expand "o") (("1" (assert) nil))))))))))) ("2" (inst - "Ma" "Bern_subdiv_r(b)" "2*(x-1/2)") (("2" (replace "bsrineq") (("2" (assert) (("2" (replace "bsrid") (("2" (expand "o") (("2" (assert) nil)))))))))))))))))))))))))))))))))))))) nil) nil nil) (Bern_poly_split_ge-1 nil 3495465928 ("" (skeep) (("" (assert) (("" (flatten) (("" (label "bslineq" -1) (("" (label "bsrineq" -2) (("" (lemma "Bern_subdiv_l_id") (("" (inst?) (("" (label "bslid" -1) (("" (lemma "Bern_subdiv_r_id") (("" (inst?) (("" (label "bsrid" -1) (("" (lemma "Bern_poly_le") (("" (label "bplem" -1) (("" (case "x<=1/2") (("1" (inst - "Ma" "Bern_subdiv_l(b)" "2*x") (("1" (assert) (("1" (replace "bslineq") (("1" (replace "bslid" "bplem") (("1" (expand "o") (("1" (assert) nil))))))))))) ("2" (inst - "Ma" "Bern_subdiv_r(b)" "2*(x-1/2)") (("2" (replace "bsrineq") (("2" (assert) (("2" (replace "bsrid") (("2" (expand "o") (("2" (assert) nil)))))))))))))))))))))))))))))))))))))) nil) nil nil)) (Bern_poly_split_gt 0 (Bern_poly_split_gt-3 nil 3495466796 ("" (skeep) (("" (assert) (("" (flatten) (("" (skeep) (("" (inst - "2*(x-1/2)") (("" (inst - "2*x") (("" (assert) (("" (lemma "Bern_subdiv_r_id") (("" (inst?) (("" (replace -1) (("" (hide -1) (("" (lemma "Bern_subdiv_l_id") (("" (inst?) (("" (replace -1) (("" (hide -1) (("" (assert) (("" (grind :exclude "Bern_poly") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_subdiv_r_id formula-decl nil bernstein_polynomials nil) (Bern_subdiv_l_id formula-decl nil bernstein_polynomials nil) (real_plus_real_is_real application-judgement "real" reals nil) (O const-decl "T3" function_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_times_real_is_real application-judgement "real" reals nil)) nil) (Bern_poly_split_gt-2 nil 3495465979 ("" (skeep) (("" (assert) (("" (flatten) (("" (label "bslineq" -1) (("" (label "bsrineq" -2) (("" (lemma "Bern_subdiv_l_id") (("" (inst?) (("" (label "bslid" -1) (("" (lemma "Bern_subdiv_r_id") (("" (inst?) (("" (label "bsrid" -1) (("" (lemma "Bern_poly_gt") (("" (label "bplem" -1) (("" (case "x<=1/2") (("1" (inst - "Ma" "Bern_subdiv_l(b)" "2*x") (("1" (assert) (("1" (replace "bslineq") (("1" (replace "bslid" "bplem") (("1" (expand "o") (("1" (assert) nil))))))))))) ("2" (inst - "Ma" "Bern_subdiv_r(b)" "2*(x-1/2)") (("2" (replace "bsrineq") (("2" (assert) (("2" (replace "bsrid") (("2" (expand "o") (("2" (assert) nil)))))))))))))))))))))))))))))))))))))) nil) nil nil) (Bern_poly_split_gt-1 nil 3495465932 ("" (skeep) (("" (assert) (("" (flatten) (("" (label "bslineq" -1) (("" (label "bsrineq" -2) (("" (lemma "Bern_subdiv_l_id") (("" (inst?) (("" (label "bslid" -1) (("" (lemma "Bern_subdiv_r_id") (("" (inst?) (("" (label "bsrid" -1) (("" (lemma "Bern_poly_le") (("" (label "bplem" -1) (("" (case "x<=1/2") (("1" (inst - "Ma" "Bern_subdiv_l(b)" "2*x") (("1" (assert) (("1" (replace "bslineq") (("1" (replace "bslid" "bplem") (("1" (expand "o") (("1" (assert) nil))))))))))) ("2" (inst - "Ma" "Bern_subdiv_r(b)" "2*(x-1/2)") (("2" (replace "bsrineq") (("2" (assert) (("2" (replace "bsrid") (("2" (expand "o") (("2" (assert) nil)))))))))))))))))))))))))))))))))))))) nil) nil nil)) (Bern_min_rec_TCC1 0 (Bern_min_rec_TCC1-1 nil 3486218646 ("" (subtype-tcc) nil nil) nil nil (Bern_min_rec subtype "bernstein_polynomials.iq" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (Bern_min_rec_TCC2 0 (Bern_min_rec_TCC2-1 nil 3486218646 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (Bern_min_rec subtype "(number_fields.-)(bernstein_polynomials.q, 1)" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (Bern_min_rec_TCC3 0 (Bern_min_rec_TCC3-1 nil 3486218646 ("" (termination-tcc) nil nil) nil nil (Bern_min_rec termination "bernstein_polynomials.Bern_min_rec(bernstein_polynomials.b)((number_fields.-)(bernstein_polynomials.q, 1))" "nil"))) (Bern_min_rec_TCC4 0 (Bern_min_rec_TCC4-2 "" 3803790197 ("" (skeep) (("" (typepred "v(b)(q-1)") (("1" (skeep) (("1" (split +) (("1" (expand "min" +) (("1" (lift-if) (("1" (case "y>x") (("1" (assert) (("1" (inst + "iq") (("1" (assert) nil nil)) nil)) nil) ("2" (inst + "q") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "min" +) (("2" (case "y>x") (("1" (assert) (("1" (skosimp*) (("1" (inst - "iq!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "iq!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "q = 0") (("1" (replace -1) (("1" (assert) (("1" (split +) (("1" (inst + "0") (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (skosimp*) (("2" (case "iq!1 = 0") (("1" (replace -1) (("1" (expand "min") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) nil shostak (Bern_min_rec subtype "real_defs.min(bernstein_polynomials.y, bernstein_polynomials.x)" "{r: reals.real | booleans.AND(EXISTS (iq: naturalnumbers.upto(bernstein_polynomials.q)): r = bernstein_polynomials.b`bern_seq(iq), FORALL (iq: naturalnumbers.upto(bernstein_polynomials.q)): reals.<=(r, bernstein_polynomials.b`bern_seq(iq)))}")) (Bern_min_rec_TCC4-1 nil 3486218646 ("" (skeep) (("" (typepred "v(b)(q-1)") (("1" (skeep) (("1" (split +) (("1" (expand "min" +) (("1" (lift-if) (("1" (case "y>x") (("1" (assert) (("1" (skosimp*) (("1" (inst + "iq!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst + "q") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "min" +) (("2" (case "y>x") (("1" (assert) (("1" (skosimp*) (("1" (inst - "iq!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "iq!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "q = 0") (("1" (replace -1) (("1" (assert) (("1" (skosimp*) (("1" (split +) (("1" (inst + "0") (("1" (expand "min") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (case "iq!1 = 0") (("1" (replace -1) (("1" (expand "min") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (iq!1 skolem-const-decl "upto(q)" bernstein_polynomials nil) (q skolem-const-decl "upto(b`index)" bernstein_polynomials nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (iq!1 skolem-const-decl "upto(q)" bernstein_polynomials nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil)) nil (Bern_min_rec subtype "real_defs.min(bernstein_polynomials.y, bernstein_polynomials.x)" "{r: reals.real | booleans.AND(EXISTS (iq: naturalnumbers.upto(bernstein_polynomials.q)): r = bernstein_polynomials.b`bern_seq(iq), FORALL (iq: naturalnumbers.upto(bernstein_polynomials.q)): reals.<=(r, bernstein_polynomials.b`bern_seq(iq)))}"))) (Bern_max_rec_TCC1 0 (Bern_max_rec_TCC1-1 nil 3486219614 ("" (skeep) (("" (skeep) (("" (expand "max") (("" (case "y<x") (("1" (assert) (("1" (ground) (("1" (typepred "v(b)(q-1)") (("1" (skosimp*) (("1" (inst + "iq!1") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "v(b)(q-1)") (("1" (skosimp*) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (typepred "v(b)(q-1)") (("1" (inst - "iq!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split) (("1" (inst + "q") nil nil) ("2" (assert) (("2" (skosimp*) (("2" (lift-if) (("2" (ground) (("2" (typepred "v(b)(q-1)") (("2" (inst - "iq!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (q skolem-const-decl "upto(b`index)" bernstein_polynomials nil) (iq!1 skolem-const-decl "upto(q)" bernstein_polynomials nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil)) nil (Bern_max_rec subtype "real_defs.max(bernstein_polynomials.y, bernstein_polynomials.x)" "{r: reals.real | booleans.AND(EXISTS (iq: naturalnumbers.upto(bernstein_polynomials.q)): r = bernstein_polynomials.b`bern_seq(iq), FORALL (iq: naturalnumbers.upto(bernstein_polynomials.q)): reals.>=(r, bernstein_polynomials.b`bern_seq(iq)))}"))) (Bern_min_bound 0 (Bern_min_bound-1 nil 3486720097 ("" (skeep) (("" (expand "Bern_poly") (("" (lemma "sigma_le") (("" (inst - "(LAMBDA (i: nat):
              IF i > b`index THEN 0
              ELSE Bern_min(b) * Bern(i, b`index)(x)
              ENDIF)" "(LAMBDA (i: nat):
              IF i > b`index THEN 0
              ELSE b`bern_seq(i) * Bern(i, b`index)(x)
              ENDIF)" "b`index" "0") (("1" (assert) (("1" (split -) (("1" (lemma "sigma_scal") (("1" (inst - "(LAMBDA (i: nat):
               IF i > b`index THEN 0
               ELSE Bern(i, b`index)(x)
               ENDIF)" "Bern_min(b)" "b`index" "0") (("1" (case "(LAMBDA (i_1: nat):
              Bern_min(b) *
               IF i_1 > b`index THEN 0 ELSE Bern(i_1, b`index)(x) ENDIF) = (LAMBDA (i: nat):
               IF i > b`index THEN 0
               ELSE Bern_min(b) * Bern(i, b`index)(x)
               ENDIF)") (("1" (lemma "Bernstein_partition_of_unity") (("1" (inst - "b`index" "x") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality 1) (("1" (lift-if) (("1" (ground) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (typepred "Bern_min(b)") (("2" (inst -2 "n!1") (("2" (lemma "Bern_nonnegative") (("2" (inst - "x") (("2" (assert) (("2" (inst - "n!1" "b`index") (("2" (mult-by -3 "Bern(n!1,b`index)(x)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (real_times_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Bern_min const-decl "{r: real |
   (EXISTS (ib: upto(b`index)): r = b`bern_seq(ib)) AND
    (FORALL (ib: upto(b`index)): r <= b`bern_seq(ib))}" bernstein_polynomials nil) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Bernstein_partition_of_unity formula-decl nil bernstein_polynomials nil) (sigma_scal formula-decl nil sigma nil) (subrange type-eq-decl nil integers nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (x skolem-const-decl "real" bernstein_polynomials nil) (n!1 skolem-const-decl "subrange(0, b`index)" bernstein_polynomials nil) (Bern_nonnegative formula-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_le formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (Bern_max_bound 0 (Bern_max_bound-2 nil 3486721681 ("" (skeep) (("" (expand "Bern_poly") (("" (lemma "sigma_le") (("" (inst - "(LAMBDA (i: nat):
                  IF i > b`index THEN 0
                  ELSE b`bern_seq(i) * Bern(i, b`index)(x)
                  ENDIF)" "(LAMBDA (i: nat):
                  IF i > b`index THEN 0
                  ELSE Bern_max(b) * Bern(i, b`index)(x)
                  ENDIF)" "b`index" "0") (("1" (assert) (("1" (split -) (("1" (lemma "sigma_scal") (("1" (inst - "(LAMBDA (i: nat):
                           IF i > b`index THEN 0
                           ELSE Bern(i, b`index)(x)
                           ENDIF)" "Bern_max(b)" "b`index" "0") (("1" (case "(LAMBDA (i_1: nat):
                                        Bern_max(b) *
                                         IF i_1 > b`index THEN 0 ELSE Bern(i_1, b`index)(x) ENDIF) = (LAMBDA (i: nat):
                                         IF i > b`index THEN 0
                                         ELSE Bern_max(b) * Bern(i, b`index)(x)
                                         ENDIF)") (("1" (lemma "Bernstein_partition_of_unity") (("1" (inst - "b`index" "x") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality 1) (("1" (lift-if) (("1" (ground) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (typepred "Bern_max(b)") (("2" (inst -2 "n!1") (("2" (lemma "Bern_nonnegative") (("2" (inst - "x") (("2" (assert) (("2" (inst - "n!1" "b`index") (("2" (mult-by -3 "Bern(n!1,b`index)(x)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Bern_poly const-decl "[real -> real]" bernstein_polynomials nil) (real_times_real_is_real application-judgement "real" reals nil) (<= const-decl "bool" reals nil) (b skolem-const-decl "Bernstein_Polynomial" bernstein_polynomials nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Bern_max const-decl "{r: real |
   (EXISTS (ib: upto(b`index)): r = b`bern_seq(ib)) AND
    (FORALL (ib: upto(b`index)): r >= b`bern_seq(ib))}" bernstein_polynomials nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_high type-eq-decl nil sigma nil) (T_low type-eq-decl nil sigma nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Bernstein_partition_of_unity formula-decl nil bernstein_polynomials nil) (sigma_scal formula-decl nil sigma nil) (subrange type-eq-decl nil integers nil) (n!1 skolem-const-decl "subrange(0, b`index)" bernstein_polynomials nil) (x skolem-const-decl "real" bernstein_polynomials nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Bern_nonnegative formula-decl nil bernstein_polynomials nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_le formula-decl nil sigma nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil) (Bern_max_bound-1 nil 3486721663 ("" (postpone) nil nil) nil shostak)) (Bern_min_est_TCC1 0 (Bern_min_est_TCC1-1 nil 3486719404 ("" (subtype-tcc) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bern_min_est subtype "0" "naturalnumbers.upto(bernstein_polynomials.b`index)"))) (Bern_concat_TCC1 0 (Bern_concat_TCC1-1 nil 3486719404 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posint nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (Bern_concat subtype "bernstein_polynomials.i" "naturalnumbers.below(bernstein_polynomials.BC1`number_polys)"))) (Bern_concat_TCC2 0 (Bern_concat_TCC2-1 nil 3486719404 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posint nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (Bern_concat subtype "(number_fields.-)(bernstein_polynomials.i, bernstein_polynomials.BC1`number_polys)" "naturalnumbers.below(bernstein_polynomials.BC2`number_polys)"))) (Bern_collection_min_est_rec_TCC1 0 (Bern_collection_min_est_rec_TCC1-1 nil 3486719404 ("" (subtype-tcc) nil nil) nil nil (Bern_collection_min_est_rec subtype "0" "naturalnumbers.below(bernstein_polynomials.BC`number_polys)"))) (Bern_collection_min_est_rec_TCC2 0 (Bern_collection_min_est_rec_TCC2-1 nil 3486719404 ("" (subtype-tcc) nil nil) nil nil (Bern_collection_min_est_rec subtype "0" "naturalnumbers.below(bernstein_polynomials.BC`number_polys)"))) (Bern_collection_min_est_rec_TCC3 0 (Bern_collection_min_est_rec_TCC3-1 nil 3486719404 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil naturalnumbers nil) (Bernstein_MinMax type-eq-decl nil bernstein_polynomials nil) (Bernstein_MinMax_Collection type-eq-decl nil bernstein_polynomials nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (Bern_collection_min_est_rec subtype "(number_fields.-)(bernstein_polynomials.np, 1)" "naturalnumbers.below(bernstein_polynomials.BC`number_polys)"))) (Bern_collection_min_est_rec_TCC4 0 (Bern_collection_min_est_rec_TCC4-1 nil 3486719404 ("" (termination-tcc) nil nil) nil nil (Bern_collection_min_est_rec termination "bernstein_polynomials.Bern_collection_min_est_rec(bernstein_polynomials.BC)((number_fields.-)(bernstein_polynomials.np, 1))" "nil"))) (Bern_collection_min_est_TCC1 0 (Bern_collection_min_est_TCC1-1 nil 3486719404 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil (Bern_collection_min_est subtype "(number_fields.-)(bernstein_polynomials.BC`number_polys, 1)" "naturalnumbers.below(bernstein_polynomials.BC`number_polys)"))) (Bern_collection_reduce_min_TCC1 0 (Bern_collection_reduce_min_TCC1-1 nil 3486719404 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (Bern_collection_reduce_min subtype "(number_fields.-)(bernstein_polynomials.BC`number_polys, 1)" "naturalnumbers.below(bernstein_polynomials.BC`number_polys)"))))
