(sqrt_approx (sq_sq_aux 0 (sq_sq_aux-1 nil 3320768920 ("" (grind) nil nil) ((nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (sq const-decl "nonneg_real" sq nil)) SHOSTAK)) (sqrt_newton_step_TCC1 0 (sqrt_newton_step_TCC1-1 nil 3626000882 ("" (skosimp* :preds? t) (("" (move-terms 1 l 1) (("" (rewrite "sq_sq_aux") (("" (ground) nil nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (sq_nz_pos application-judgement "posreal" sq nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (sq_sq_aux formula-decl nil sqrt_approx nil) (nnreal type-eq-decl nil real_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (sq const-decl "nonneg_real" sq nil)) nil (sqrt_newton_step subtype "number_fields./(((number_fields.+)(sqrt_approx.Y, number_fields./(sqrt_approx.X, sqrt_approx.Y))), 2)" "{z | reals.<=(sqrt_approx.X, sq.sq(sqrt_approx.z))}"))) (sqrt_newton_step_increasing 0 (sqrt_newton_step_increasing-2 "" 3882374350 ("" (skeep) (("" (case "x1<=sq(y2)") (("1" (case "sqrt_newton_step(x1, y1)<=sqrt_newton_step(x1, y2) AND 
sqrt_newton_step(x1, y2)<= sqrt_newton_step(x2, y2)") (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (hide 2) (("2" (split 1) (("1" (case "x1<=y1*y2") (("1" (div-by -1 "y1*y2") (("1" (move-terms -1 l 1) (("1" (move-terms -4 l 1) (("1" (mult-ineq -1 -4) (("1" (simplify -1) (("1" (expand "sqrt_newton_step") (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred ("y1")) (("2" (hide 2) (("2" (grind-reals) (("2" (both-sides-f -3 "sqrt") (("1" (both-sides-f -4 "sqrt") (("1" (mult-ineq -1 -2) (("1" (rewrite "sqrt_sq") (("1" (rewrite "sqrt_sq") (("1" (lemma "sq_sqrt") (("1" (inst -1 "x1") (("1" (expand "sq") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sqrt_le") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sqrt_newton_step") (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("3" (flatten) nil nil) ("4" (propax) nil nil)) nil) ("2" (typepred ("y2")) (("2" (ground) nil nil)) nil)) nil)) nil) ((sq const-decl "nonneg_real" sq nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_plus_le1 formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_times_le_any1 formula-decl nil extra_real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (div_simp formula-decl nil real_props nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnreal type-eq-decl nil real_types nil) (sq_sqrt formula-decl nil sqrt nil) (sqrt_pos application-judgement "posreal" sqrt nil) (sqrt_sq formula-decl nil sqrt nil) (sqrt_le formula-decl nil sqrt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (sq_nz_pos application-judgement "posreal" sq nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (sqrt_newton_step const-decl "{z | X <= sq(z)}" sqrt_approx nil)) SHOSTAK) (sqrt_newton_step_increasing-1 nil 3626006724 ("" (skeep) (("" (case "x1<=sq(y2)") (("1" (case "sqrt_newton_step(x1, y1)<=sqrt_newton_step(x1, y2) AND 
sqrt_newton_step(x1, y2)<= sqrt_newton_step(x2, y2)") (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (hide 2) (("2" (split 1) (("1" (case "x1<=y1*y2") (("1" (div-by -1 "y1*y2") (("1" (move-terms -1 l 1) (("1" (move-terms -4 l 1) (("1" (mult-ineq -1 -4) (("1" (simplify -1) (("1" (expand "sqrt_newton_step") (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred (y1)) (("2" (hide 2) (("2" (grind-reals) (("2" (both-sides-f -3 "sqrt") (("1" (both-sides-f -4 "sqrt") (("1" (mult-ineq -1 -2) (("1" (rewrite "sqrt_sq") (("1" (rewrite "sqrt_sq") (("1" (lemma "sq_sqrt") (("1" (inst -1 "x1") (("1" (expand "sq") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sqrt_le") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sqrt_newton_step") (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("3" (flatten) nil nil) ("4" (propax) nil nil)) nil) ("2" (typepred (y2)) (("2" (ground) nil nil)) nil)) nil)) nil) ((sq const-decl "nonneg_real" sq nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt nil) (sq_sqrt formula-decl nil sqrt nil) (sqrt_sq formula-decl nil sqrt nil) (sqrt_pos application-judgement "posreal" sqrt nil) (sqrt_le formula-decl nil sqrt nil) (sq_nz_pos application-judgement "posreal" sq nil)) SHOSTAK)) (sqrt_newton_interv_TCC1 0 (sqrt_newton_interv_TCC1-1 nil 3626606845 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (sq const-decl "nonneg_real" sq nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (sq_nz_pos application-judgement "posreal" sq nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (sqrt_newton_interv subtype "(number_fields.-)(sqrt_approx.n, 1)" "nat"))) (sqrt_newton_interv_TCC2 0 (sqrt_newton_interv_TCC2-1 nil 3626606845 ("" (termination-tcc) nil nil) nil nil (sqrt_newton_interv termination "sqrt_approx.sqrt_newton_interv(sqrt_approx.X, sqrt_approx.sqrt_newton_step(sqrt_approx.X, sqrt_approx.Y), (number_fields.-)(sqrt_approx.n, 1))" "nil"))) (sqrt_newton_interv_increasing 0 (sqrt_newton_interv_increasing-1 nil 3626607143 ("" (induct "n") (("1" (skeep) (("1" (expand "sqrt_newton_interv") (("1" (propax) nil nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "sqrt_newton_interv" 1) (("2" (inst -1 "x1" "x2" "sqrt_newton_step(x1, y1)" "sqrt_newton_step(x2, y2)") (("2" (ground) (("2" (hide 2) (("2" (rewrite "sqrt_newton_step_increasing") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sqrt_newton_step_increasing formula-decl nil sqrt_approx nil) (sqrt_newton_step const-decl "{z | X <= sq(z)}" sqrt_approx nil) (nat_induction formula-decl nil naturalnumbers nil) (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (sq const-decl "nonneg_real" sq nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) SHOSTAK)) (sqrt_newton_interv_dec 0 (sqrt_newton_interv_dec-2 nil 3629033752 ("" (induct "n") (("1" (skeep) (("1" (expand "sqrt_newton_interv") (("1" (expand "sqrt_newton_interv") (("1" (typepred "sqrt_newton_step(X,Y)") (("1" (typepred "Y") (("1" (expand "sqrt_newton_step" 1) (("1" (cross-mult 1) (("1" (move-terms 1 l 2) (("1" (simplify) (("1" (cross-mult) (("1" (expand "sq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "sqrt_newton_interv" 1) (("2" (inst -1 "X" "sqrt_newton_step(X, Y)") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (div_mult_pos_le1 formula-decl nil real_props nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sq_nz_pos application-judgement "posreal" sq nil) (real_minus_real_is_real application-judgement "real" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt_newton_step const-decl "{z | X <= sq(z)}" sqrt_approx nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil) (sq const-decl "nonneg_real" sq nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil) (sqrt_newton_interv_dec-1 nil 3629033726 ("" (postpone) nil nil) nil SHOSTAK)) (sqrt_newton_interv_dec2 0 (sqrt_newton_interv_dec2-1 nil 3629033822 ("" (case "FORALL ((X: posreal | X >= 1 AND X <= 4), (Y: posreal | X <= sq(Y)),
                     n, m, N:nat):  (N = m-n AND m >= n) IMPLIES
                sqrt_newton_interv(X, Y, m) <= sqrt_newton_interv(X, Y, n)") (("1" (skeep) (("1" (inst -1 " X" "Y" "n" "m" "m-n") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "N") (("1" (skeep) (("1" (ground) nil nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (lemma "sqrt_newton_interv_dec") (("2" (inst -1 "X" "Y" "m-1") (("1" (inst -2 "X" "Y" "n" "m-1") (("1" (ground) nil nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sqrt_newton_interv_dec formula-decl nil sqrt_approx nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (m skolem-const-decl "nat" sqrt_approx nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (n skolem-const-decl "nat" sqrt_approx nil) (m skolem-const-decl "nat" sqrt_approx nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (sq const-decl "nonneg_real" sq nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil)) nil)) (sqrt_int_TCC1 0 (sqrt_int_TCC1-1 nil 3626609815 ("" (subtype-tcc) nil nil) ((sq const-decl "nonneg_real" sq nil) (posrat_exp application-judgement "posrat" exponentiation nil)) nil (sqrt_int subtype "2" "{Y | reals.<=(sqrt_approx.X, sq.sq(sqrt_approx.Y))}"))) (sqrt_int_TCC2 0 (sqrt_int_TCC2-2 "" 3882375072 ("" (skeep) (("" (ground) (("1" (typepred "sqrt_newton_interv(X, 2, n)") (("1" (expand "sq " 1) (("1" (rewrite "expt_plus" :dir rl) (("1" (rewrite "expt_times") (("1" (case-replace "2^2 = 4") (("1" (expand "sq") (("1" (typepred ("x")) (("1" (replaces -3 :dir rl) (("1" (cancel-by 1 "4^M") nil nil)) nil)) nil)) nil) ("2" (eval-formula 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (nn:nat): sqrt_newton_interv(4,2,nn)=2") (("1" (inst -1 "n") (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (cancel-by 1 "2^M") (("1" (lemma "sqrt_newton_interv_increasing") (("1" (inst -1 "X" "4" "2" "2" "n") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (induct "nn") (("1" (expand "sqrt_newton_interv") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (expand "sqrt_newton_interv" 1) (("2" (case-replace "sqrt_newton_step(4,2) = 2") (("2" (expand "sqrt_newton_step") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "sq") (("3" (ground) nil nil)) nil)) nil)) nil) ("3" (expand "sq") (("3" (ground) nil nil)) nil)) nil) ("3" (case "FORALL (nn:nat): sqrt_newton_interv(1,1,nn)=1") (("1" (inst -1 "n") (("1" (lemma "sqrt_newton_interv_increasing") (("1" (inst -1 "1" "X" "1" "2" "n") (("1" (ground) (("1" (cancel-by 1 "2^M") nil nil)) nil)) nil)) nil)) nil) ("2" (induct "nn") (("1" (expand "sqrt_newton_interv") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "sqrt_newton_interv" 1) (("2" (case "sqrt_newton_step(1,1)=1") (("1" (replaces -1) nil nil) ("2" (expand "sqrt_newton_step") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sq_nz_pos application-judgement "posreal" sq nil) (expt_times formula-decl nil exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (TRUE const-decl "bool" booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (posrat nonempty-type-eq-decl nil rationals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (expt_plus formula-decl nil exponentiation nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (sq const-decl "nonneg_real" sq nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil) (sqrt_newton_step const-decl "{z | X <= sq(z)}" sqrt_approx nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (expt_x1 formula-decl nil exponentiation nil) (sqrt_newton_interv_increasing formula-decl nil sqrt_approx nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (sq_1 formula-decl nil sq nil) (posrat_exp application-judgement "posrat" exponentiation nil)) SHOSTAK (sqrt_int subtype "number_fields.*(exponentiation.^(2, sqrt_approx.M), sqrt_approx.sqrt_newton_interv(sqrt_approx.X, 2, sqrt_approx.n))" "{z | booleans.AND(reals.>=(sq.sq(sqrt_approx.z), sqrt_approx.x), booleans.AND(reals.<=(sqrt_approx.z, exponentiation.^(2, (number_fields.+)(1, sqrt_approx.M))), reals.>=(sqrt_approx.z, exponentiation.^(2, sqrt_approx.M))))}")) (sqrt_int_TCC2-1 nil 3626609815 ("" (skeep) (("" (ground) (("1" (typepred "sqrt_newton_interv(X, 2, n)") (("1" (expand "sq " 1) (("1" (rewrite "expt_plus" :dir rl) (("1" (rewrite "expt_times") (("1" (case-replace "2^2 = 4") (("1" (expand "sq") (("1" (typepred (x)) (("1" (replaces -3 :dir rl) (("1" (cancel-by 1 "4^M") nil nil)) nil)) nil)) nil) ("2" (eval-formula 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (nn:nat): sqrt_newton_interv(4,2,nn)=2") (("1" (inst -1 "n") (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (cancel-by 1 "2^M") (("1" (lemma "sqrt_newton_interv_increasing") (("1" (inst -1 "X" "4" "2" "2" "n") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (induct "nn") (("1" (expand "sqrt_newton_interv") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (expand "sqrt_newton_interv" 1) (("2" (case-replace "sqrt_newton_step(4,2) = 2") (("2" (expand "sqrt_newton_step") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "sq") (("3" (ground) nil nil)) nil)) nil)) nil) ("3" (expand "sq") (("3" (ground) nil nil)) nil)) nil) ("3" (case "FORALL (nn:nat): sqrt_newton_interv(1,1,nn)=1") (("1" (inst -1 "n") (("1" (lemma "sqrt_newton_interv_increasing") (("1" (inst -1 "1" "X" "1" "2" "n") (("1" (ground) (("1" (cancel-by 1 "2^M") nil nil)) nil)) nil)) nil)) nil) ("2" (induct "nn") (("1" (expand "sqrt_newton_interv") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "sqrt_newton_interv" 1) (("2" (case "sqrt_newton_step(1,1)=1") (("1" (replaces -1) nil nil) ("2" (expand "sqrt_newton_step") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sq_nz_pos application-judgement "posreal" sq nil) (sq const-decl "nonneg_real" sq nil) (sq_1 formula-decl nil sq nil)) nil (sqrt_int subtype "number_fields.*(exponentiation.^(2, sqrt_approx.M), sqrt_approx.sqrt_newton_interv(sqrt_approx.X, 2, sqrt_approx.n))" "{z | booleans.AND(reals.>=(sq.sq(sqrt_approx.z), sqrt_approx.x), booleans.AND(reals.<=(sqrt_approx.z, exponentiation.^(2, (number_fields.+)(1, sqrt_approx.M))), reals.>=(sqrt_approx.z, exponentiation.^(2, sqrt_approx.M))))}"))) (sqrt_int_ub_TCC1 0 (sqrt_int_ub_TCC1-1 nil 3626616415 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq const-decl "nonneg_real" sq nil)) nil (sqrt_int_ub subtype "0" "{zz | reals.<=(sqrt_approx.x, sq.sq(sqrt_approx.zz))}"))) (sqrt_int_ub_TCC2 0 (sqrt_int_ub_TCC2-1 nil 3626616415 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (sqrt_int_ub subtype "sqrt_approx.x" "posreal"))) (sqrt_int_ub_TCC3 0 (sqrt_int_ub_TCC3-1 nil 3626616415 ("" (subtype-tcc) nil nil) ((posrat_exp application-judgement "posrat" exponentiation nil)) nil (sqrt_int_ub subtype "sqrt_approx.Y" "{zz: real_types.posreal | booleans.AND(reals.>=(zz, 1), reals.<=(zz, 4))}"))) (sqrt_int_ub_TCC4 0 (sqrt_int_ub_TCC4-2 "" 3803800152 ("" (skeep*) (("" (decompose-equality -1) (("" (replace -1) (("" (replace -2) (("" (typepred "x") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (posrat_exp application-judgement "posrat" exponentiation nil)) SHOSTAK (sqrt_int_ub subtype "sqrt_approx.x" "{xx: real_types.posreal | number_fields.*(exponentiation.^(4, sqrt_approx.M), sqrt_approx.Y) = xx}")) (sqrt_int_ub_TCC4-1 nil 3626616415 ("" (subtype-tcc) nil nil) nil nil (sqrt_int_ub subtype "sqrt_approx.x" "{xx: real_types.posreal | number_fields.*(exponentiation.^(4, sqrt_approx.M), sqrt_approx.Y) = xx}"))) (sqrt_int_ub_TCC5 0 (sqrt_int_ub_TCC5-1 nil 3626616415 ("" (skeep) (("" (skeep) (("" (typepred "sqrt_int(M, Y, x, 3 + log_nat(max(1, 10 / 3 * M + n), 2)`1)") (("" (name-replace "srt" "sqrt_int(M, Y, x, 3 + log_nat(max(1, 10 / 3 * M + n), 2)`1)") (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq_nz_pos application-judgement "posreal" sq nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sq const-decl "nonneg_real" sq nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt_int const-decl "{z | sq(z) >= x AND z <= 2 ^ (M + 1) AND z >= 2 ^ M}" sqrt_approx nil) (< const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (above nonempty-type-eq-decl nil integers nil) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil)) nil (sqrt_int_ub subtype "sqrt_approx.sqrt_int(sqrt_approx.M, sqrt_approx.Y, sqrt_approx.x, (number_fields.+)(3, log_nat.log_nat(real_defs.max(1, (number_fields.+)(number_fields.*(number_fields./(10, 3), sqrt_approx.M), sqrt_approx.n)), 2)`1))" "{zz | reals.<=(sqrt_approx.x, sq.sq(sqrt_approx.zz))}"))) (sqrt_int_ub_dec 0 (sqrt_int_ub_dec-2 "" 3790089432 ("" (skeep) (("" (expand "sqrt_int_ub") (("" (case "x=0") (("1" (assert) nil nil) ("2" (assert) (("2" (expand "sqrt_int") (("2" (cancel-by 2 " 2 ^ log_int(x, 4)`1") (("2" (lemma "log_int_le") (("2" (inst -1 "2" "max(1, 10/3 * log_int(x, 4)`1 + n)" "max(1, 10/3 * log_int(x, 4)`1 + m)") (("2" (ground) (("1" (case "max(1, 10/3 * log_int(x, 4)`1 + m)>=1 AND max(1, 10/3 * log_int(x, 4)`1 + n)>=1") (("1" (flatten) (("1" (expand "log_int" -3 1) (("1" (expand "log_int" -3 2) (("1" (lemma "sqrt_newton_interv_dec2") (("1" (rewrite "sqrt_newton_interv_dec2") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (hide (-1 2 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sqrt_int_ub const-decl "{zz | x <= sq(zz)}" sqrt_approx nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (log_int const-decl "[z: int, {y: real | y < p AND y >= 1 AND x = p ^ z * y}]" log_int nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (above nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (posrat nonempty-type-eq-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sq const-decl "nonneg_real" sq nil) (<= const-decl "bool" reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sqrt_newton_interv_dec2 formula-decl nil sqrt_approx nil) (log_int_le formula-decl nil log_int nil) (sqrt_int const-decl "{z | sq(z) >= x AND z <= 2 ^ (M + 1) AND z >= 2 ^ M}" sqrt_approx nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)) SHOSTAK) (sqrt_int_ub_dec-1 nil 3629033898 ("" (skeep) (("" (expand "sqrt_int_ub") (("" (case "x=0") (("1" (assert) nil nil) ("2" (assert) (("2" (expand "sqrt_int") (("2" (cancel-by 2 " 2 ^ log_int(x, 4)`1") (("2" (lemma "log_int_le") (("2" (inst -1 "2" "max(1, 10/3 * log_int(x, 4)`1 + n)" "max(1, 10/3 * log_int(x, 4)`1 + m)") (("2" (ground) (("1" (case "max(1, 10/3 * log_int(x, 4)`1 + m)>=1 AND max(1, 10/3 * log_int(x, 4)`1 + n)>=1") (("1" (flatten) (("1" (expand "log_int" -3 1) (("1" (expand "log_int" -3 2) (("1" (lemma "sqrt_newton_interv_dec2") (("1" (rewrite "sqrt_newton_interv_dec2") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (hide (-1 2 4)) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (sqrt_ub_TCC1 0 (sqrt_ub_TCC1-1 nil 3626617109 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (sq const-decl "nonneg_real" sq nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)) nil (sqrt_ub subtype "floor_ceil.floor(sqrt_approx.ub)" "{zz | reals.<=(sqrt_approx.x, sq.sq(sqrt_approx.zz))}"))) (sqrt_ub_increasing 0 (sqrt_ub_increasing-1 nil 3626617036 ("" (skeep) (("" (case "sqrt_int_ub(x,n)<=sqrt_int_ub(y,n)") (("1" (expand "sqrt_ub") (("1" (ground) (("1" (lift-if 1) (("1" (split) (("1" (flatten) (("1" (ground) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (ground) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (ground) (("1" (flip-ineq 1) (("1" (flip-ineq 1) (("1" (typepred "sqrt_int_ub(x, n)") (("1" (typepred "sqrt_int_ub(y, n)") (("1" (name-replace "rtx" "sqrt_int_ub(x, n)") (("1" (name-replace "rty" "sqrt_int_ub(y, n)") (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "sqrt_int_ub") (("2" (lift-if 1) (("2" (ground) (("1" (lift-if 1) (("1" (ground) nil nil)) nil) ("2" (name-replace "Lx" "log_int(x,4)") (("2" (name-replace "Ly" "log_int(y,4)") (("2" (case "Lx`1<Ly`1") (("1" (typepred "sqrt_int(Lx`1, Lx`2, x, 3 + log_nat(max(1, 10/3 * Lx`1 + n), 2)`1)") (("1" (typepred " sqrt_int(Ly`1, Ly`2, y, 3 + log_nat(max(1, 10/3 * Ly`1 + n), 2)`1)") (("1" (ground) (("1" (case "Lx`1+1<=Ly`1") (("1" (lemma "both_sides_expt_gt1_le") (("1" (inst -1 "2" "Lx`1+1" "Ly`1") (("1" (flatten) (("1" (hide -1) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (expand "Ly") (("2" (ground) nil nil)) nil)) nil) ("2" (expand "Lx") (("2" (ground) nil nil)) nil)) nil) ("2" (case "Lx`1 = Ly`1") (("1" (expand "sqrt_int") (("1" (replace -1 3) (("1" (cancel-by 3 "2^Ly`1") (("1" (lemma "sqrt_newton_interv_increasing") (("1" (inst -1 "Lx`2" "Ly`2" "2" "2" "3 + log_nat(max(1, 10/3 * Ly`1 + n), 2)`1") (("1" (ground) (("1" (typepred "Lx`2") (("1" (typepred "Ly`2") (("1" (replace -3) (("1" (replace -6) (("1" (replace -8) (("1" (cancel-by -9 "4^Ly`1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "log_int_le") (("2" (inst -1 "4" "x" "y") (("2" (ground) (("2" (expand "Lx") (("2" (expand "Ly") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sqrt_int_ub const-decl "{zz | x <= sq(zz)}" sqrt_approx nil) (sq const-decl "nonneg_real" sq nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (> const-decl "bool" reals nil) (sqrt_ub const-decl "{zz | x <= sq(zz)}" sqrt_approx nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (sqrt_newton_interv_increasing formula-decl nil sqrt_approx nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil) (y skolem-const-decl "nnreal" sqrt_approx nil) (x skolem-const-decl "nnreal" sqrt_approx nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (posrat nonempty-type-eq-decl nil rationals nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (log_int_le formula-decl nil log_int nil) (sqrt_int const-decl "{z | sq(z) >= x AND z <= 2 ^ (M + 1) AND z >= 2 ^ M}" sqrt_approx nil) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (Ly skolem-const-decl "[z: int, {y_1: real | y_1 < 4 AND y_1 >= 1 AND y = 4 ^ z * y_1}]" sqrt_approx nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (sq_nz_pos application-judgement "posreal" sq nil) (int_plus_int_is_int application-judgement "int" integers nil) (both_sides_expt_gt1_le formula-decl nil exponentiation nil) (Lx skolem-const-decl "[z: int, {y: real | y < 4 AND y >= 1 AND x = 4 ^ z * y}]" sqrt_approx nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (posreal nonempty-type-eq-decl nil real_types nil) (above nonempty-type-eq-decl nil integers nil) (log_int const-decl "[z: int, {y: real | y < p AND y >= 1 AND x = p ^ z * y}]" log_int nil)) SHOSTAK)) (sqrt_ub_dec 0 (sqrt_ub_dec-1 nil 3629033926 ("" (skeep) (("" (lemma "sqrt_int_ub_dec") (("" (inst -1 "m" "n" "x") (("" (ground) (("" (expand "sqrt_ub") (("" (ground) (("" (case "floor(sqrt_int_ub(x, m)) <= floor(sqrt_int_ub(x, n))") (("1" (ground) (("1" (lift-if 1) (("1" (lift-if 1) (("1" (lift-if 1) (("1" (ground) (("1" (flip-ineq 2) (("1" (name-replace "mx" "sqrt_int_ub(x,m)") (("1" (name-replace "nx" "sqrt_int_ub(x,n)") (("1" (flip-ineq 1) (("1" (case "floor(mx)<floor(nx)") (("1" (case "floor(mx)+1 <= floor(nx)") (("1" (case "floor(mx)+1 < mx") (("1" (lemma "floor_def") (("1" (inst -1 "mx") (("1" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil) ("2" (flip-ineq 1) (("2" (mult-ineq -1 -1) (("2" (expand "sq") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sqrt_int_ub_dec formula-decl nil sqrt_approx nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ge_times_ge_any1 formula-decl nil extra_real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (floor_def formula-decl nil floor_ceil nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (sq const-decl "nonneg_real" sq nil) (sqrt_int_ub const-decl "{zz | x <= sq(zz)}" sqrt_approx nil) (sqrt_ub const-decl "{zz | x <= sq(zz)}" sqrt_approx nil) (nnreal type-eq-decl nil real_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) SHOSTAK)) (sqrt_newton_interv_lower_TCC1 0 (sqrt_newton_interv_lower_TCC1-2 "" 3882378530 ("" (skeep) (("" (typepred ("X")) (("" (split) (("1" (cross-mult) nil nil) ("2" (cross-mult) nil nil)) nil)) nil)) nil) nil shostak (sqrt_newton_interv_lower subtype "number_fields./(4, sqrt_approx.X)" "{X | booleans.AND(reals.>=(sqrt_approx.X, 1), reals.<=(sqrt_approx.X, 4))}")) (sqrt_newton_interv_lower_TCC1-1 nil 3626713257 ("" (skeep) (("" (typepred (x)) (("" (split) (("1" (cross-mult) nil nil) ("2" (cross-mult) nil nil)) nil)) nil)) nil) ((<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (div_mult_pos_le1 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil)) nil (sqrt_newton_interv_lower subtype "number_fields./(4, sqrt_approx.X)" "{X | booleans.AND(reals.>=(sqrt_approx.X, 1), reals.<=(sqrt_approx.X, 4))}"))) (sqrt_newton_interv_lower_TCC2 0 (sqrt_newton_interv_lower_TCC2-1 nil 3626713257 ("" (skeep :preds? t) (("" (rewrite "sq_div") (("" (grind-reals) (("" (expand "sq") (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((sq_div formula-decl nil sq nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (sq const-decl "nonneg_real" sq nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sq_nz_pos application-judgement "posreal" sq nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (le_times_le_pos formula-decl nil real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (times_div2 formula-decl nil real_props nil) (div_mult_pos_le1 formula-decl nil real_props nil) (div_mult_pos_le2 formula-decl nil real_props nil) (TRUE const-decl "bool" booleans nil)) nil (sqrt_newton_interv_lower subtype "number_fields./(2, sqrt_approx.Y)" "{Y | reals.<=(number_fields./(4, sqrt_approx.X), sq.sq(sqrt_approx.Y))}"))) (sqrt_newton_interv_lower_TCC3 0 (sqrt_newton_interv_lower_TCC3-1 nil 3626713257 ("" (skeep :preds? t) (("" (rewrite "sq_div") (("" (typepred " sqrt_newton_interv(4 / X, 2 / Y, n)") (("" (expand "sq") (("" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ((posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (sq_div formula-decl nil sq nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (sq const-decl "nonneg_real" sq nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sq_nz_pos application-judgement "posreal" sq nil) (div_mult_pos_le1 formula-decl nil real_props nil) (div_mult_pos_ge2 formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil (sqrt_newton_interv_lower subtype "number_fields./(2, sqrt_approx.sqrt_newton_interv(number_fields./(4, sqrt_approx.X), number_fields./(2, sqrt_approx.Y), sqrt_approx.n))" "{z | reals.>=(sqrt_approx.X, sq.sq(sqrt_approx.z))}"))) (sqrt_newton_interv_lower_increasing 0 (sqrt_newton_interv_lower_increasing-1 nil 3626713806 ("" (skeep) (("" (expand "sqrt_newton_interv_lower") (("" (cross-mult) (("" (lemma "sqrt_newton_interv_increasing") (("" (inst -1 "4/x2" "4/x1" "2/y2" "2/y1" "n") (("" (ground) (("1" (cross-mult) nil nil) ("2" (cross-mult) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (sqrt_newton_interv_lower const-decl "{z | X >= sq(z)}" sqrt_approx nil) (sqrt_newton_interv_increasing formula-decl nil sqrt_approx nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (div_mult_pos_le2 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div2 formula-decl nil real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (sq const-decl "nonneg_real" sq nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (div_mult_pos_le1 formula-decl nil real_props nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil)) SHOSTAK)) (sqrt_newton_interv_lower_inc 0 (sqrt_newton_interv_lower_inc-1 nil 3629192674 ("" (skeep) (("" (expand "sqrt_newton_interv_lower") (("" (cross-mult) (("" (cancel-by 1 "2") (("" (rewrite "sqrt_newton_interv_dec2") nil nil)) nil)) nil)) nil)) nil) ((sqrt_newton_interv_lower const-decl "{z | X >= sq(z)}" sqrt_approx nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (uint8 type-eq-decl nil integertypes nil) (exp2 def-decl "posnat" exp2 nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (sqrt_newton_interv_dec2 formula-decl nil sqrt_approx nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (div_mult_pos_le2 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div2 formula-decl nil real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (sq const-decl "nonneg_real" sq nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (div_mult_pos_le1 formula-decl nil real_props nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil)) SHOSTAK)) (sqrt_int_lower_TCC1 0 (sqrt_int_lower_TCC1-1 nil 3626715471 ("" (subtype-tcc) nil nil) ((sq const-decl "nonneg_real" sq nil) (posrat_exp application-judgement "posrat" exponentiation nil)) nil (sqrt_int_lower subtype "1" "{Y | reals.>=(sqrt_approx.X, sq.sq(sqrt_approx.Y))}"))) (sqrt_int_lower_TCC2 0 (sqrt_int_lower_TCC2-2 "" 3882375476 ("" (skeep) (("" (ground) (("1" (typepred "sqrt_newton_interv_lower(X, 1, n)") (("1" (expand "sq " 1) (("1" (rewrite "expt_plus" :dir rl) (("1" (rewrite "expt_times") (("1" (case-replace "2^2 = 4") (("1" (expand "sq") (("1" (typepred ("x")) (("1" (replaces -3 :dir rl) (("1" (cancel-by 1 "4^M") nil nil)) nil)) nil)) nil) ("2" (eval-formula 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "sqrt_newton_interv_lower(4,2,n) = 2") (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (cancel-by 1 "2^M") (("1" (lemma "sqrt_newton_interv_lower_increasing") (("1" (inst -1 "X" "4" "1" "2" "n") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "sqrt_newton_interv_lower") (("2" (case "FORALL (nn:nat): sqrt_newton_interv(1,1,nn)=1") (("1" (inst -1 "n") (("1" (ground) nil nil)) nil) ("2" (induct "nn") (("1" (expand "sqrt_newton_interv") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "sqrt_newton_interv" 1) (("2" (case "sqrt_newton_step(1,1)=1") (("1" (replaces -1) nil nil) ("2" (expand "sqrt_newton_step") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "sq") (("3" (ground) nil nil)) nil)) nil) ("3" (case "sqrt_newton_interv_lower(1,1,n) = 1") (("1" (lemma "sqrt_newton_interv_lower_increasing") (("1" (inst -1 "1" "X" "1" "1" "n") (("1" (ground) (("1" (cancel-by 1 "2^M") nil nil)) nil)) nil)) nil) ("2" (expand "sqrt_newton_interv_lower") (("2" (case "FORALL (nn:nat): sqrt_newton_interv(4,2,nn)=2") (("1" (inst -1 "n") (("1" (ground) nil nil)) nil) ("2" (hide-all-but 1) (("2" (induct "nn") (("1" (expand "sqrt_newton_interv") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (expand "sqrt_newton_interv" 1) (("2" (case-replace "sqrt_newton_step(4,2) = 2") (("2" (expand "sqrt_newton_step") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "sq") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (sq_nz_pos application-judgement "posreal" sq nil) (expt_times formula-decl nil exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (TRUE const-decl "bool" booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (posrat nonempty-type-eq-decl nil rationals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (expt_plus formula-decl nil exponentiation nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (sq const-decl "nonneg_real" sq nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sqrt_newton_interv_lower const-decl "{z | X >= sq(z)}" sqrt_approx nil) (sqrt_newton_interv def-decl "{z | X <= sq(z)}" sqrt_approx nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (sqrt_newton_step const-decl "{z | X <= sq(z)}" sqrt_approx nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (int_minus_int_is_int application-judgement "int" integers nil) (sqrt_newton_interv_lower_increasing formula-decl nil sqrt_approx nil) (expt_x1 formula-decl nil exponentiation nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil)) SHOSTAK (sqrt_int_lower subtype "number_fields.*(exponentiation.^(2, sqrt_approx.M), sqrt_approx.sqrt_newton_interv_lower(sqrt_approx.X, 1, sqrt_approx.n))" "{z | booleans.AND(reals.<=(sq.sq(sqrt_approx.z), sqrt_approx.x), booleans.AND(reals.<=(sqrt_approx.z, exponentiation.^(2, (number_fields.+)(1, sqrt_approx.M))), reals.>=(sqrt_approx.z, exponentiation.^(2, sqrt_approx.M))))}")) (sqrt_int_lower_TCC2-1 nil 3626715471 ("" (skeep) (("" (ground) (("1" (typepred "sqrt_newton_interv_lower(X, 1, n)") (("1" (expand "sq " 1) (("1" (rewrite "expt_plus" :dir rl) (("1" (rewrite "expt_times") (("1" (case-replace "2^2 = 4") (("1" (expand "sq") (("1" (typepred (x)) (("1" (replaces -3 :dir rl) (("1" (cancel-by 1 "4^M") nil nil)) nil)) nil)) nil) ("2" (eval-formula 1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "sqrt_newton_interv_lower(4,2,n) = 2") (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (cancel-by 1 "2^M") (("1" (lemma "sqrt_newton_interv_lower_increasing") (("1" (inst -1 "X" "4" "1" "2" "n") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "sqrt_newton_interv_lower") (("2" (case "FORALL (nn:nat): sqrt_newton_interv(1,1,nn)=1") (("1" (inst -1 "n") (("1" (ground) nil nil)) nil) ("2" (induct "nn") (("1" (expand "sqrt_newton_interv") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand "sqrt_newton_interv" 1) (("2" (case "sqrt_newton_step(1,1)=1") (("1" (replaces -1) nil nil) ("2" (expand "sqrt_newton_step") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "sq") (("3" (ground) nil nil)) nil)) nil) ("3" (case "sqrt_newton_interv_lower(1,1,n) = 1") (("1" (lemma "sqrt_newton_interv_lower_increasing") (("1" (inst -1 "1" "X" "1" "1" "n") (("1" (ground) (("1" (cancel-by 1 "2^M") nil nil)) nil)) nil)) nil) ("2" (expand "sqrt_newton_interv_lower") (("2" (case "FORALL (nn:nat): sqrt_newton_interv(4,2,nn)=2") (("1" (inst -1 "n") (("1" (ground) nil nil)) nil) ("2" (hide-all-but 1) (("2" (induct "nn") (("1" (expand "sqrt_newton_interv") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (expand "sqrt_newton_interv" 1) (("2" (case-replace "sqrt_newton_step(4,2) = 2") (("2" (expand "sqrt_newton_step") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "sq") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sq_nz_pos application-judgement "posreal" sq nil) (sq const-decl "nonneg_real" sq nil)) nil (sqrt_int_lower subtype "number_fields.*(exponentiation.^(2, sqrt_approx.M), sqrt_approx.sqrt_newton_interv_lower(sqrt_approx.X, 1, sqrt_approx.n))" "{z | booleans.AND(reals.<=(sq.sq(sqrt_approx.z), sqrt_approx.x), booleans.AND(reals.<=(sqrt_approx.z, exponentiation.^(2, (number_fields.+)(1, sqrt_approx.M))), reals.>=(sqrt_approx.z, exponentiation.^(2, sqrt_approx.M))))}"))) (sqrt_int_lb_TCC1 0 (sqrt_int_lb_TCC1-1 nil 3626717160 ("" (subtype-tcc) nil nil) ((sq const-decl "nonneg_real" sq nil)) nil (sqrt_int_lb subtype "0" "{zz | reals.>=(sqrt_approx.x, sq.sq(sqrt_approx.zz))}"))) (sqrt_int_lb_TCC2 0 (sqrt_int_lb_TCC2-1 nil 3626717160 ("" (skeep) (("" (skeep) (("" (typepred " sqrt_int_lower(M, Y, x, 3 + log_nat(max(1, 10 / 3 * M + n), 2)`1)") (("" (ground) nil nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq_nz_pos application-judgement "posreal" sq nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sq const-decl "nonneg_real" sq nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt_int_lower const-decl "{z | sq(z) <= x AND z <= 2 ^ (M + 1) AND z >= 2 ^ M}" sqrt_approx nil) (< const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (above nonempty-type-eq-decl nil integers nil) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil)) nil (sqrt_int_lb subtype "sqrt_approx.sqrt_int_lower(sqrt_approx.M, sqrt_approx.Y, sqrt_approx.x, (number_fields.+)(3, log_nat.log_nat(real_defs.max(1, (number_fields.+)(number_fields.*(number_fields./(10, 3), sqrt_approx.M), sqrt_approx.n)), 2)`1))" "{zz | reals.>=(sqrt_approx.x, sq.sq(sqrt_approx.zz))}"))) (sqrt_int_lb_inc 0 (sqrt_int_lb_inc-2 "" 3790089442 ("" (skeep) (("" (expand "sqrt_int_lb") (("" (case "x=0") (("1" (assert) nil nil) ("2" (assert) (("2" (expand "sqrt_int_lower") (("2" (cancel-by 2 " 2 ^ log_int(x, 4)`1") (("2" (lemma "log_int_le") (("2" (inst -1 "2" "max(1, 10/3 * log_int(x, 4)`1 + n)" "max(1, 10/3 * log_int(x, 4)`1 + m)") (("2" (ground) (("1" (case "max(1, 10/3 * log_int(x, 4)`1 + m)>=1 AND max(1, 10/3 * log_int(x, 4)`1 + n)>=1") (("1" (flatten) (("1" (expand "log_int" -3 1) (("1" (expand "log_int" -3 2) (("1" (rewrite "sqrt_newton_interv_lower_inc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil) ("2" (hide (-1 2 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sqrt_int_lb const-decl "{zz | x >= sq(zz)}" sqrt_approx nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (log_int const-decl "[z: int, {y: real | y < p AND y >= 1 AND x = p ^ z * y}]" log_int nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (above nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (posrat nonempty-type-eq-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt_newton_interv_lower const-decl "{z | X >= sq(z)}" sqrt_approx nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sq const-decl "nonneg_real" sq nil) (<= const-decl "bool" reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sqrt_newton_interv_lower_inc formula-decl nil sqrt_approx nil) (log_int_le formula-decl nil log_int nil) (sqrt_int_lower const-decl "{z | sq(z) <= x AND z <= 2 ^ (M + 1) AND z >= 2 ^ M}" sqrt_approx nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)) SHOSTAK) (sqrt_int_lb_inc-1 nil 3629192868 ("" (skeep) (("" (expand "sqrt_int_lb") (("" (case "x=0") (("1" (assert) nil nil) ("2" (assert) (("2" (expand "sqrt_int_lower") (("2" (cancel-by 2 " 2 ^ log_int(x, 4)`1") (("2" (lemma "log_int_le") (("2" (inst -1 "2" "max(1, 10/3 * log_int(x, 4)`1 + n)" "max(1, 10/3 * log_int(x, 4)`1 + m)") (("2" (ground) (("1" (case "max(1, 10/3 * log_int(x, 4)`1 + m)>=1 AND max(1, 10/3 * log_int(x, 4)`1 + n)>=1") (("1" (flatten) (("1" (expand "log_int" -3 1) (("1" (expand "log_int" -3 2) (("1" (rewrite "sqrt_newton_interv_lower_inc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (ground) nil nil)) nil)) nil) ("2" (hide (-1 2 4)) (("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil SHOSTAK)) (sqrt_lb_TCC1 0 (sqrt_lb_TCC1-1 nil 3626438073 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (sq const-decl "nonneg_real" sq nil) (nonneg_ceiling_is_nat application-judgement "nat" floor_ceil nil)) nil (sqrt_lb subtype "floor_ceil.ceiling(sqrt_approx.lb)" "{zz | reals.>=(sqrt_approx.x, sq.sq(sqrt_approx.zz))}"))) (sqrt_lb_increasing 0 (sqrt_lb_increasing-1 nil 3626717544 ("" (skeep) (("" (case "sqrt_int_lb(x,n)<=sqrt_int_lb(y,n)") (("1" (expand "sqrt_lb") (("1" (ground) (("1" (lift-if 1) (("1" (split) (("1" (flatten) (("1" (ground) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (ground) (("2" (flip-ineq 1) (("2" (flip-ineq 1) (("2" (typepred "sqrt_int_lb(x, n)") (("2" (typepred "sqrt_int_lb(y, n)") (("2" (name-replace "rtx" "sqrt_int_lb(x, n)") (("2" (name-replace "rty" "sqrt_int_lb(y, n)") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (ground) (("2" (lift-if 2) (("2" (split 2) (("1" (flatten) (("1" (ground) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "sqrt_int_lb") (("2" (lift-if 1) (("2" (ground) (("1" (lift-if 1) (("1" (ground) nil nil)) nil) ("2" (name-replace "Lx" "log_int(x,4)") (("2" (name-replace "Ly" "log_int(y,4)") (("2" (case "Lx`1<Ly`1") (("1" (typepred "sqrt_int_lower(Lx`1, Lx`2, x, 3 + log_nat(max(1, 10/3 * Lx`1 + n), 2)`1)") (("1" (typepred " sqrt_int_lower(Ly`1, Ly`2, y, 3 + log_nat(max(1, 10/3 * Ly`1 + n), 2)`1)") (("1" (ground) (("1" (case "Lx`1+1<=Ly`1") (("1" (lemma "both_sides_expt_gt1_le") (("1" (inst -1 "2" "Lx`1+1" "Ly`1") (("1" (flatten) (("1" (hide -1) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil) ("2" (expand "Ly") (("2" (ground) nil nil)) nil)) nil) ("2" (expand "Lx") (("2" (ground) nil nil)) nil)) nil) ("2" (case "Lx`1 = Ly`1") (("1" (expand "sqrt_int_lower") (("1" (replace -1 3) (("1" (cancel-by 3 "2^Ly`1") (("1" (lemma "sqrt_newton_interv_lower_increasing") (("1" (inst -1 "Lx`2" "Ly`2" "1" "1" "3 + log_nat(max(1, 10/3 * Ly`1 + n), 2)`1") (("1" (ground) (("1" (typepred "Lx`2") (("1" (typepred "Ly`2") (("1" (replace -3) (("1" (replace -6) (("1" (replace -8) (("1" (cancel-by -9 "4^Ly`1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "log_int_le") (("2" (inst -1 "4" "x" "y") (("2" (ground) (("2" (expand "Lx") (("2" (expand "Ly") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sqrt_int_lb const-decl "{zz | x >= sq(zz)}" sqrt_approx nil) (sq const-decl "nonneg_real" sq nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_ceiling_is_nat application-judgement "nat" floor_ceil nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ceiling const-decl "{i | x <= i & i < x + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (> const-decl "bool" reals nil) (sqrt_lb const-decl "{zz | x >= sq(zz)}" sqrt_approx nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (sqrt_newton_interv_lower_increasing formula-decl nil sqrt_approx nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (sqrt_newton_interv_lower const-decl "{z | X >= sq(z)}" sqrt_approx nil) (y skolem-const-decl "nnreal" sqrt_approx nil) (x skolem-const-decl "nnreal" sqrt_approx nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (posrat nonempty-type-eq-decl nil rationals nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (log_int_le formula-decl nil log_int nil) (sqrt_int_lower const-decl "{z | sq(z) <= x AND z <= 2 ^ (M + 1) AND z >= 2 ^ M}" sqrt_approx nil) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (Ly skolem-const-decl "[z: int, {y_1: real | y_1 < 4 AND y_1 >= 1 AND y = 4 ^ z * y_1}]" sqrt_approx nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (sq_nz_pos application-judgement "posreal" sq nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_expt_gt1_le formula-decl nil exponentiation nil) (Lx skolem-const-decl "[z: int, {y: real | y < 4 AND y >= 1 AND x = 4 ^ z * y}]" sqrt_approx nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (posreal nonempty-type-eq-decl nil real_types nil) (above nonempty-type-eq-decl nil integers nil) (log_int const-decl "[z: int, {y: real | y < p AND y >= 1 AND x = p ^ z * y}]" log_int nil)) SHOSTAK)) (sqrt_lb_inc 0 (sqrt_lb_inc-1 nil 3629193726 ("" (skeep) (("" (lemma "sqrt_int_lb_inc") (("" (inst -1 "m" "n" "x") (("" (ground) (("" (expand "sqrt_lb") (("" (ground) (("" (case "ceiling(sqrt_int_lb(x, n)) <= ceiling(sqrt_int_lb(x, m))") (("1" (ground) (("1" (lift-if 1) (("1" (lift-if 1) (("1" (lift-if 1) (("1" (ground) (("1" (flip-ineq 2) (("1" (flip-ineq 1) (("1" (ground) (("1" (name-replace "mx" "sqrt_int_lb(x,m)") (("1" (name-replace "nx" "sqrt_int_lb(x,n)") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sqrt_int_lb_inc formula-decl nil sqrt_approx nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_ceiling_is_nat application-judgement "nat" floor_ceil nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (ceiling const-decl "{i | x <= i & i < x + 1}" floor_ceil nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (sq const-decl "nonneg_real" sq nil) (sqrt_int_lb const-decl "{zz | x >= sq(zz)}" sqrt_approx nil) (sqrt_lb const-decl "{zz | x >= sq(zz)}" sqrt_approx nil) (nnreal type-eq-decl nil real_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) SHOSTAK)) (sqrt_bounds 0 (sqrt_bounds-1 nil 3626438092 ("" (skeep) (("" (ground) (("1" (typepred "sqrt_lb(x,n)") (("1" (flip-ineq 1) (("1" (mult-ineq -1 -1) (("1" (lemma "sq_sqrt") (("1" (inst -1 "x") (("1" (split -1) (("1" (expand "sq") (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "sqrt_ub(x,n)") (("2" (flip-ineq 1) (("2" (mult-ineq -1 -1) (("2" (lemma "sq_sqrt") (("2" (inst -1 "x") (("2" (split) (("1" (expand "sq") (("1" (ground) nil nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sq_sqrt formula-decl nil sqrt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (gt_times_gt_any1 formula-decl nil extra_real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (sq const-decl "nonneg_real" sq nil) (sqrt_lb const-decl "{zz | x >= sq(zz)}" sqrt_approx nil) (<= const-decl "bool" reals nil) (sqrt_ub const-decl "{zz | x <= sq(zz)}" sqrt_approx nil)) SHOSTAK)))
