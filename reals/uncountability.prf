(uncountability
 (closed_interval_uncountable 0
  (closed_interval_uncountable-1 nil 3831470896
   ("" (skeep)
    (("" (case "bounded_interval?({x| a<=x AND x<=b})")
      (("1" (use "countable_is_null")
        (("1" (expand "null_set?")
          (("1" (flatten)
            (("1" (expand "mu")
              (("1" (expand "lambda_")
                (("1" (use "lebesgue_outer_measure_bounded_interval")
                  (("1" (decompose-equality -)
                    (("1" (assert)
                      (("1" (use "length_closed_rew")
                        (("1" (assert)
                          (("1" (replace -1 * LR)
                            (("1" (expand "lebesgue_measure")
                              (("1"
                                (expand "induced_measure")
                                (("1"
                                  (expand "restrict")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "bounded_interval?")
        (("2" (split)
          (("1" (expand "interval?") (("1" (grind) nil nil)) nil)
           ("2" (expand "bounded?")
            (("2" (flatten)
              (("2" (expand "nonempty?")
                (("2" (assert)
                  (("2" (split)
                    (("1" (expand "above_bounded")
                      (("1" (inst 1 "b") (("1" (grind) nil nil)) nil))
                      nil)
                     ("2" (expand "below_bounded")
                      (("2" (inst 1 "a") (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bounded_interval? const-decl "bool" real_topology metric_space)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (null_set? const-decl "bool" measure_theory measure_integration)
    (mu const-decl "nnreal" measure_props measure_integration)
    (lebesgue_outer_measure_bounded_interval formula-decl nil
     real_lebesgue_scaf lebesgue)
    (bounded_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (lebesgue_measure const-decl
     "complete_sigma_finite[real, lebesgue_measurable]"
     real_lebesgue_scaf lebesgue)
    (restrict const-decl "R" restrict nil)
    (induced_measure const-decl "complete_measure" outer_measure_props
     measure_integration)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length_closed_rew formula-decl nil real_intervals_aux lebesgue)
    (length const-decl "nnreal" real_intervals_aux lebesgue)
    (TRUE const-decl "bool" booleans nil)
    (lebesgue_outer_measure const-decl "outer_measure"
     real_lebesgue_scaf lebesgue)
    (outer_measure nonempty-type-eq-decl nil outer_measure_def
     measure_integration)
    (outer_measure? const-decl "bool" outer_measure_def
     measure_integration)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def lebesgue)
    nil nil (is_countable const-decl "bool" countability sets_aux)
    (countable_set nonempty-type-eq-decl nil countability sets_aux)
    (countable_is_null judgement-tcc nil lebesgue_def lebesgue)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (interval? const-decl "bool" real_topology metric_space)
    (below_bounded const-decl "bool" bounded_reals nil)
    (lower_bound const-decl "bool" bound_defs nil)
    (above_bounded const-decl "bool" bounded_reals nil)
    (upper_bound const-decl "bool" bound_defs nil)
    (nonempty? const-decl "bool" sets nil)
    (bounded? const-decl "bool" real_topology metric_space))
   shostak))
 (open_interval_uncountable 0
  (open_interval_uncountable-1 nil 3831471243
   ("" (skeep)
    (("" (case "bounded_interval?({x| a<x AND x<b})")
      (("1" (use "countable_is_null")
        (("1" (expand "null_set?")
          (("1" (flatten)
            (("1" (expand "mu")
              (("1" (expand "lambda_")
                (("1" (use "lebesgue_outer_measure_bounded_interval")
                  (("1" (decompose-equality -)
                    (("1" (assert)
                      (("1" (use "length_open_rew")
                        (("1" (assert)
                          (("1" (replace -1 * LR)
                            (("1" (expand "lebesgue_measure")
                              (("1"
                                (expand "induced_measure")
                                (("1"
                                  (expand "restrict")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "bounded_interval?")
        (("2" (split)
          (("1" (expand "interval?") (("1" (grind) nil nil)) nil)
           ("2" (expand "bounded?")
            (("2" (flatten)
              (("2" (expand "nonempty?")
                (("2" (assert)
                  (("2" (split)
                    (("1" (expand "above_bounded")
                      (("1" (inst 1 "b") (("1" (grind) nil nil)) nil))
                      nil)
                     ("2" (expand "below_bounded")
                      (("2" (inst 1 "a") (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bounded_interval? const-decl "bool" real_topology metric_space)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (null_set? const-decl "bool" measure_theory measure_integration)
    (mu const-decl "nnreal" measure_props measure_integration)
    (lebesgue_outer_measure_bounded_interval formula-decl nil
     real_lebesgue_scaf lebesgue)
    (bounded_interval nonempty-type-eq-decl nil real_topology
     metric_space)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (lebesgue_measure const-decl
     "complete_sigma_finite[real, lebesgue_measurable]"
     real_lebesgue_scaf lebesgue)
    (restrict const-decl "R" restrict nil)
    (induced_measure const-decl "complete_measure" outer_measure_props
     measure_integration)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<= const-decl "bool" reals nil)
    (length_open_rew formula-decl nil real_intervals_aux lebesgue)
    (length const-decl "nnreal" real_intervals_aux lebesgue)
    (TRUE const-decl "bool" booleans nil)
    (lebesgue_outer_measure const-decl "outer_measure"
     real_lebesgue_scaf lebesgue)
    (outer_measure nonempty-type-eq-decl nil outer_measure_def
     measure_integration)
    (outer_measure? const-decl "bool" outer_measure_def
     measure_integration)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (lambda_ const-decl "complete_sigma_finite[real, cal_M]"
     lebesgue_def lebesgue)
    nil nil (is_countable const-decl "bool" countability sets_aux)
    (countable_set nonempty-type-eq-decl nil countability sets_aux)
    (countable_is_null judgement-tcc nil lebesgue_def lebesgue)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (interval? const-decl "bool" real_topology metric_space)
    (below_bounded const-decl "bool" bounded_reals nil)
    (lower_bound const-decl "bool" bound_defs nil)
    (above_bounded const-decl "bool" bounded_reals nil)
    (upper_bound const-decl "bool" bound_defs nil)
    (nonempty? const-decl "bool" sets nil)
    (bounded? const-decl "bool" real_topology metric_space))
   shostak))
 (reals_uncountable 0
  (reals_uncountable-1 nil 3831454519
   ("" (expand "reals")
    (("" (expand "fullset")
      (("" (lemma "uncountable_subset[real]")
        (("" (inst -1 "{x|0<=x and x<=1}" "{x|True}")
          (("1" (assert) (("1" (grind) nil nil)) nil)
           ("2" (use "closed_interval_uncountable")
            (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((fullset const-decl "set" sets nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (is_countable const-decl "bool" countability sets_aux)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (uncountable_set type-eq-decl nil countability sets_aux)
    (TRUE const-decl "bool" booleans nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (closed_interval_uncountable formula-decl nil uncountability nil)
    (uncountable_subset formula-decl nil countable_props sets_aux)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (reals const-decl "open" real_topology metric_space))
   shostak)))

