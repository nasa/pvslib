(losr_iterative (incr_trk_vect_TCC1 0 (incr_trk_vect_TCC1-1 nil 3535802573 ("" (skeep) (("" (expand "trk_only?") (("" (lemma "norms_eq_sqv") (("" (inst?) (("" (assert) (("" (hide 2) (("" (rewrite "sqv_add") (("" (case-replace "nvo*perpR(nvo) = 0") (("1" (assert) (("1" (rewrite "sqv_scal") (("1" (rewrite "sqv_scal") (("1" (rewrite "sqv_perpR") (("1" (lemma "sin2_cos2") (("1" (inst - "dir*step") (("1" (mult-by -1 "sqv(nvo)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((trk_only? const-decl "bool" definitions nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real nonempty-type-from-decl nil reals nil) (Vector type-eq-decl nil vectors_2D vectors) (+ const-decl "Vector" vectors_2D vectors) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (* const-decl "Vector" vectors_2D vectors) (cos const-decl "real" sincos_def trig) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nzint nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign type-eq-decl nil sign reals) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (sin const-decl "real" sincos_def trig) (perpR const-decl "Vect2" perpendicular_2D vectors) (* const-decl "real" vectors_2D vectors) (sqv_scal formula-decl nil vectors_2D vectors) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sqv_perpR formula-decl nil perpendicular_2D vectors) (sq const-decl "nonneg_real" sq reals) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqv const-decl "nnreal" vectors_2D vectors) (nnreal type-eq-decl nil real_types nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (sin2_cos2 formula-decl nil sincos_def trig) (minus_real_is_real application-judgement "real" reals nil) (dot_scal_canon formula-decl nil vectors_2D vectors) (scal_assoc formula-decl nil vectors_2D vectors) (real_plus_real_is_real application-judgement "real" reals nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (sqv_add formula-decl nil vectors_2D vectors) (cos_range application-judgement "real_abs_le1" sincos trig) (sin_range application-judgement "real_abs_le1" sincos trig) (norms_eq_sqv formula-decl nil vectors_2D vectors)) nil (incr_trk_vect subtype "(vectors_2D.+)(vectors_2D.*(sincos_def.cos(number_fields.*(losr_iterative.dir, losr_iterative.step)), losr_iterative.nvo), vectors_2D.*(sincos_def.sin(number_fields.*(losr_iterative.dir, losr_iterative.step)), perpendicular_2D.perpR(losr_iterative.nvo)))" "{nvo2: vectors_2D_def.Vect2 | definitions.trk_only?(losr_iterative.nvo)(nvo2)}"))) (losr_trk_iter_i_TCC1 0 (losr_trk_iter_i_TCC1-1 nil 3535288278 ("" (skosimp*) (("" (assert) nil nil)) nil) ((posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)) nil (losr_trk_iter_i subtype "real_defs.max(0, (number_fields.+)((number_fields.-)(floor_ceil.floor(number_fields./(losr_iterative.maxtrk, losr_iterative.step)), losr_iterative.i), 1))" "naturalnumber"))) (losr_trk_iter_i_TCC2 0 (losr_trk_iter_i_TCC2-1 nil 3535288278 ("" (skosimp*) (("" (assert) nil nil)) nil) ((posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (losr_trk_iter_i subtype "losr_iterative.nvo" "{nvo2 | booleans.=>(losr_iterative.nvo2 /= vectors_2D.zero, booleans.AND(definitions.trk_only?(losr_iterative.vo)(losr_iterative.nvo2), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo2, losr_iterative.vi))))}"))) (losr_trk_iter_i_TCC3 0 (losr_trk_iter_i_TCC3-2 "" 3804520716 ("" (skosimp*) (("" (typepred "nvo!1") (("" (split +) (("1" (hide-all-but (-1 -3 1)) (("1" (typepred "incr_trk_vect(nvo!1, step!1, dir!1)") (("1" (replaces -3 :dir rl) (("1" (expand "trk_only?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "repulsive_criteria_transitive") (("2" (inst - "eps!1" "nvo!1-vi!1" "nvop!1-vi!1" "s!1" "vo!1-vi!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak (losr_trk_iter_i subtype "losr_iterative.nvop" "{nvo2 | booleans.=>(losr_iterative.nvo2 /= vectors_2D.zero, booleans.AND(definitions.trk_only?(losr_iterative.vo)(losr_iterative.nvo2), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo2, losr_iterative.vi))))}")) (losr_trk_iter_i_TCC3-1 nil 3535288278 ("" (skosimp*) (("" (typepred "nvo!1") (("" (split +) (("1" (hide-all-but (-1 -6 1)) (("1" (typepred "incr_trk_vect(nvo!1, step!1, dir!1)") (("1" (replaces -3 :dir rl) (("1" (expand "trk_only?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "repulsive_criteria_transitive") (("2" (inst - "eps!1" "nvo!1-vi!1" "nvop!1-vi!1" "s!1" "vo!1-vi!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((- const-decl "Vector" vectors_2D vectors) (repulsive_criteria const-decl "bool" repulsive nil) (Sign type-eq-decl nil sign reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nzint nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (/= const-decl "boolean" notequal nil) (Vector type-eq-decl nil vectors_2D vectors) (trk_only? const-decl "bool" definitions nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (repulsive_criteria_transitive formula-decl nil repulsive nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (incr_trk_vect const-decl "{nvo2: Vect2 | trk_only?(nvo)(nvo2)}" losr_iterative nil)) nil (losr_trk_iter_i subtype "losr_iterative.nvop" "{nvo2 | booleans.=>(losr_iterative.nvo2 /= vectors_2D.zero, booleans.AND(definitions.trk_only?(losr_iterative.vo)(losr_iterative.nvo2), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo2, losr_iterative.vi))))}"))) (losr_trk_iter_i_TCC4 0 (losr_trk_iter_i_TCC4-3 "" 3804521178 ("" (skosimp*) (("" (typepred "nvo!1") (("" (hide 1) (("" (hide 1) (("" (split +) (("1" (hide-all-but (-1 -3 1)) (("1" (typepred "incr_trk_vect(nvo!1, step!1, dir!1)") (("1" (replaces -3 :dir rl) (("1" (expand "trk_only?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "repulsive_criteria_transitive") (("2" (inst - "eps!1" "nvo!1-vi!1" "nvop!1-vi!1" "s!1" "vo!1-vi!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (losr_trk_iter_i subtype "losr_iterative.nvop" "{nvo | booleans.AND(definitions.trk_only?(losr_iterative.vo)(losr_iterative.nvo), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi)))}")) (losr_trk_iter_i_TCC4-2 nil 3535884573 ("" (skosimp*) (("" (typepred "nvo!1") (("" (hide 1) (("" (split +) (("1" (hide-all-but (-1 -4 1)) (("1" (typepred "incr_trk_vect(nvo!1, step!1, dir!1)") (("1" (replaces -3 :dir rl) (("1" (expand "trk_only?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "repulsive_criteria_transitive") (("2" (inst - "eps!1" "nvo!1-vi!1" "nvop!1-vi!1" "s!1" "vo!1-vi!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((- const-decl "Vector" vectors_2D vectors) (repulsive_criteria const-decl "bool" repulsive nil) (Sign type-eq-decl nil sign reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nzint nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (/= const-decl "boolean" notequal nil) (Vector type-eq-decl nil vectors_2D vectors) (trk_only? const-decl "bool" definitions nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (repulsive_criteria_transitive formula-decl nil repulsive nil) (TRUE const-decl "bool" booleans nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (incr_trk_vect const-decl "{nvo2: Vect2 | trk_only?(nvo)(nvo2)}" losr_iterative nil)) nil (losr_trk_iter_i subtype "losr_iterative.nvop" "{nvo | booleans.AND(definitions.trk_only?(losr_iterative.vo)(losr_iterative.nvo), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi)))}")) (losr_trk_iter_i_TCC4-1 nil 3535288278 ("" (skosimp*) (("" (hide -) (("" (assert) (("" (case "floor(maxtrk!1 / step!1) - i!1 + 1 > 0") (("1" (grind) nil nil) ("2" (hide 3) (("2" (typepred "floor(maxtrk!1 / step!1)") (("2" (name-replace "FF" "floor(maxtrk!1 / step!1)") (("2" (case "i!1 < maxtrk!1/step!1") (("1" (assert) nil nil) ("2" (hide-all-but (1 3)) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (losr_trk_iter_i subtype "losr_iterative.nvop" "{nvo | booleans.AND(definitions.trk_only?(losr_iterative.vo)(losr_iterative.nvo), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi)))}"))) (losr_trk_iter_i_TCC5 0 (losr_trk_iter_i_TCC5-3 "" 3804522956 ("" (skosimp*) (("" (hide -) (("" (hide 2) (("" (assert) (("" (case "floor(maxtrk!1 / step!1) - i!1 >= 0") (("1" (grind) nil nil) ("2" (hide 3) (("2" (typepred "floor(maxtrk!1 / step!1)") (("2" (name-replace "FF" "floor(maxtrk!1 / step!1)") (("2" (case "i!1 < maxtrk!1/step!1") (("1" (assert) nil nil) ("2" (hide-all-but (1 3)) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (losr_trk_iter_i termination "losr_iterative.losr_trk_iter_i(losr_iterative.s, losr_iterative.vo, losr_iterative.vi, losr_iterative.minrelgs, losr_iterative.maxtrk, losr_iterative.step, (number_fields.+)(losr_iterative.i, 1), losr_iterative.dir, losr_iterative.eps, losr_iterative.nvop)" "nil")) (losr_trk_iter_i_TCC5-2 nil 3535884446 ("" (skosimp*) (("" (hide -) (("" (hide 1) (("" (assert) (("" (case "floor(maxtrk!1 / step!1) - i!1 >= 0") (("1" (grind) nil nil) ("2" (hide 3) (("2" (typepred "floor(maxtrk!1 / step!1)") (("2" (name-replace "FF" "floor(maxtrk!1 / step!1)") (("2" (case "i!1 < maxtrk!1/step!1") (("1" (assert) nil nil) ("2" (hide-all-but (1 3)) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (int nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)) nil (losr_trk_iter_i termination "losr_iterative.losr_trk_iter_i(losr_iterative.s, losr_iterative.vo, losr_iterative.vi, losr_iterative.minrelgs, losr_iterative.maxtrk, losr_iterative.step, (number_fields.+)(losr_iterative.i, 1), losr_iterative.dir, losr_iterative.eps, losr_iterative.nvop)" "nil")) (losr_trk_iter_i_TCC5-1 nil 3535884239 ("" (termination-tcc) nil nil) nil nil (losr_trk_iter_i termination "losr_iterative.losr_trk_iter_i(losr_iterative.s, losr_iterative.vo, losr_iterative.vi, losr_iterative.minrelgs, losr_iterative.maxtrk, losr_iterative.step, (number_fields.+)(losr_iterative.i, 1), losr_iterative.dir, losr_iterative.eps, losr_iterative.nvop)" "nil"))) (losr_trk_iter_TCC1 0 (losr_trk_iter_TCC1-1 nil 3535288278 ("" (skosimp*) nil nil) nil nil (losr_trk_iter subtype "vectors_2D.zero" "{nvo | booleans.=>(losr_iterative.nvo /= vectors_2D.zero, booleans.AND(definitions.trk_only?(losr_iterative.vo)(losr_iterative.nvo), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), (number_fields.-)(sign.sign(det_2D.det(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi)))))((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi))))}"))) (losr_trk_iter_TCC2 0 (losr_trk_iter_TCC2-1 nil 3535288278 ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil) ((sign_neg_clos application-judgement "Sign" sign reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Vector type-eq-decl nil vectors_2D vectors) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign type-eq-decl nil sign reals) (Sign3 type-eq-decl nil sign3 reals)) nil (losr_trk_iter subtype "losr_iterative.dir3" "Sign"))) (losr_trk_iter_TCC3 0 (losr_trk_iter_TCC3-1 nil 3535288278 ("" (skosimp*) (("" (assert) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sign_neg_clos application-judgement "Sign" sign reals)) nil (losr_trk_iter subtype "losr_iterative.nvo" "{nvo | booleans.AND(definitions.trk_only?(losr_iterative.vo)(losr_iterative.nvo), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi)))}"))) (losr_trk_iter_TCC4 0 (losr_trk_iter_TCC4-1 nil 3535473716 ("" (skosimp*) (("" (typepred "losr_trk_iter_i(s!1, vo!1, vi!1, minrelgs!1, maxtrk!1,
                                    step!1, 1, dir3!1, eps!1, nvo!1)") (("" (name-replace "vv" "losr_trk_iter_i(s!1, vo!1, vi!1, minrelgs!1, maxtrk!1, step!1, 1,
                          dir3!1, eps!1, nvo!1)") (("" (assert) (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Sign3 type-eq-decl nil sign3 reals) (losr_trk_iter_i def-decl "{nvo2 |
   nvo2 /= zero =>
    trk_only?(vo)(nvo2) AND repulsive_criteria(s, vo - vi, eps)(nvo2 - vi)}" losr_iterative nil) (- const-decl "Vector" vectors_2D vectors) (repulsive_criteria const-decl "bool" repulsive nil) (zero const-decl "Vector" vectors_2D vectors) (trk_only? const-decl "bool" definitions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (Sign type-eq-decl nil sign reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nzint nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (/= const-decl "boolean" notequal nil) (Vector type-eq-decl nil vectors_2D vectors) (real nonempty-type-from-decl nil reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sign_neg_clos application-judgement "Sign" sign reals)) nil (losr_trk_iter subtype "losr_iterative.losr_trk_iter_i(losr_iterative.s, losr_iterative.vo, losr_iterative.vi, losr_iterative.minrelgs, losr_iterative.maxtrk, losr_iterative.step, 1, losr_iterative.dir3, losr_iterative.eps, losr_iterative.nvo)" "{nvo | booleans.=>(losr_iterative.nvo /= vectors_2D.zero, booleans.AND(definitions.trk_only?(losr_iterative.vo)(losr_iterative.nvo), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), (number_fields.-)(sign.sign(det_2D.det(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi)))))((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi))))}"))) (losr_trk_iter_TCC5 0 (losr_trk_iter_TCC5-1 nil 3535802573 ("" (skosimp*) nil nil) nil nil (losr_trk_iter subtype "vectors_2D.zero" "{nvo | booleans.=>(losr_iterative.nvo /= vectors_2D.zero, booleans.AND(definitions.trk_only?(losr_iterative.vo)(losr_iterative.nvo), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), (number_fields.-)(sign.sign(det_2D.det(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi)))))((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi))))}"))) (incr_gs_vect_TCC1 0 (incr_gs_vect_TCC1-1 nil 3560175723 ("" (skeep) (("" (lemma "gs_only_normalize") (("" (inst?) (("" (assert) (("" (inst? 1) nil nil)) nil)) nil)) nil)) nil) ((gs_only_normalize formula-decl nil definitions nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (^ const-decl "Normalized" vectors_2D vectors) (Normalized type-eq-decl nil vectors_2D vectors) (Nz_vector type-eq-decl nil vectors_2D vectors) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (Sign type-eq-decl nil sign reals) (- const-decl "[numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nzint nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (norm const-decl "nnreal" vectors_2D vectors) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "Vector" vectors_2D vectors) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (/= const-decl "boolean" notequal nil) (boolean nonempty-type-decl nil booleans nil) (Vector type-eq-decl nil vectors_2D vectors) (real nonempty-type-from-decl nil reals nil) (real_plus_real_is_real application-judgement "real" reals nil)) nil (incr_gs_vect subtype "vectors_2D.*(((number_fields.+)(vectors_2D.norm(losr_iterative.vo), number_fields.*(losr_iterative.dir, losr_iterative.step))), vectors_2D.^(losr_iterative.vo))" "{nvo: vectors_2D_def.Vect2 | booleans.IMPLIES(reals.>((number_fields.+)(vectors_2D.norm(losr_iterative.vo), number_fields.*(losr_iterative.dir, losr_iterative.step)), 0), definitions.gs_only?(losr_iterative.vo)(nvo))}"))) (losr_gs_iter_i_TCC1 0 (losr_gs_iter_i_TCC1-1 nil 3560262748 ("" (skosimp*) (("" (rewrite "max_ge") nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (max_ge formula-decl nil real_defs nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nzint nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign type-eq-decl nil sign reals) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (Vector type-eq-decl nil vectors_2D vectors) (nnreal type-eq-decl nil real_types nil) (norm const-decl "nnreal" vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)) nil (losr_gs_iter_i subtype "real_defs.max(0, (number_fields.+)((number_fields.-)(floor_ceil.floor(IF reals.>=(losr_iterative.dir, 0) THEN number_fields./(((number_fields.-)(losr_iterative.maxgs, vectors_2D.norm(losr_iterative.vo))), losr_iterative.step) ELSE number_fields./(((number_fields.-)(vectors_2D.norm(losr_iterative.vo), losr_iterative.mings)), losr_iterative.step) ENDIF), losr_iterative.i), 1))" "naturalnumber"))) (losr_gs_iter_i_TCC2 0 (losr_gs_iter_i_TCC2-1 nil 3560262748 ("" (skosimp*) (("" (assert) (("" (typepred "nvo!1") (("" (lemma "gs_only_normalize") (("" (inst? -) (("" (assert) (("" (inst? 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (gs_only_normalize formula-decl nil definitions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Vector type-eq-decl nil vectors_2D vectors) (* const-decl "Vector" vectors_2D vectors) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (norm const-decl "nnreal" vectors_2D vectors) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign type-eq-decl nil sign reals) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (Nz_vector type-eq-decl nil vectors_2D vectors) (Normalized type-eq-decl nil vectors_2D vectors) (^ const-decl "Normalized" vectors_2D vectors) (repulsive_criteria const-decl "bool" repulsive nil) (- const-decl "Vector" vectors_2D vectors) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)) nil (losr_gs_iter_i subtype "losr_iterative.nvo" "{nvo2 | booleans.=>(losr_iterative.nvo2 /= vectors_2D.zero, booleans.AND(definitions.gs_only?(losr_iterative.vo)(losr_iterative.nvo2), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo2, losr_iterative.vi))))}"))) (losr_gs_iter_i_TCC3 0 (losr_gs_iter_i_TCC3-2 nil 3560263323 ("" (skosimp*) (("" (lemma "repulsive_criteria_transitive") (("" (inst - "eps!1" "nvo!1-vi!1" "nvop!1-vi!1" "s!1" "vo!1-vi!1") (("" (assert) (("" (typepred "incr_gs_vect(nvo!1, step!1, dir!1)") (("" (assert) (("" (replaces -3 :dir rl) (("" (typepred "nvo!1") (("" (lemma "gs_only_normalize") (("" (inst -1 "vo!1" "nvo!1") (("" (flatten) (("" (hide -1) (("" (split -) (("1" (lemma "gs_only_trans") (("1" (inst -1 "vo!1" "nvo!1" "nvop!1") (("1" (assert) nil nil)) nil)) nil) ("2" (inst? 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((repulsive_criteria_transitive formula-decl nil repulsive nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (gs_only_trans formula-decl nil definitions nil) (gs_only_normalize formula-decl nil definitions nil) (TRUE const-decl "bool" booleans nil) (incr_gs_vect const-decl "{nvo: Vect2 | norm(vo) + dir * step > 0 IMPLIES gs_only?(vo)(nvo)}" losr_iterative nil) (NOT const-decl "[bool -> bool]" booleans nil) (gs_only? const-decl "bool" definitions nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (repulsive_criteria const-decl "bool" repulsive nil) (^ const-decl "Normalized" vectors_2D vectors) (Normalized type-eq-decl nil vectors_2D vectors) (Nz_vector type-eq-decl nil vectors_2D vectors) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (norm const-decl "nnreal" vectors_2D vectors) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "Vector" vectors_2D vectors) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "Vector" vectors_2D vectors) (Vector type-eq-decl nil vectors_2D vectors) (Vect2 type-eq-decl nil vectors_2D_def vectors) (Sign type-eq-decl nil sign reals) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (nzint nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)) nil (losr_gs_iter_i subtype "losr_iterative.nvop" "{nvo2 | booleans.=>(losr_iterative.nvo2 /= vectors_2D.zero, booleans.AND(definitions.gs_only?(losr_iterative.vo)(losr_iterative.nvo2), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo2, losr_iterative.vi))))}")) (losr_gs_iter_i_TCC3-1 nil 3560262748 ("" (subtype-tcc) nil nil) nil nil (losr_gs_iter_i subtype "losr_iterative.nvop" "{nvo2 | booleans.=>(losr_iterative.nvo2 /= vectors_2D.zero, booleans.AND(definitions.gs_only?(losr_iterative.vo)(losr_iterative.nvo2), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo2, losr_iterative.vi))))}"))) (losr_gs_iter_i_TCC4 0 (losr_gs_iter_i_TCC4-4 "" 3804523174 ("" (skosimp*) (("" (typepred "nvo!1") (("" (lemma "repulsive_criteria_transitive") (("" (inst - "eps!1" "nvo!1-vi!1" "nvop!1-vi!1" "s!1" "vo!1-vi!1") (("" (assert) (("" (hide (-1 -4 -7)) (("" (expand "incr_gs_vect") (("" (case "norm(nvo!1) = norm((norm(vo!1) + dir!1 * i!1 * step!1) * ^(vo!1))") (("1" (rewrite "norm_scal") (("1" (replaces -1) (("1" (replaces -1) (("1" (rewrite "normalize_scal") (("1" (rewrite "normalize_normalize") (("1" (rewrite "scal_assoc") (("1" (rewrite "sign_times_abs") (("1" (expand "sign") (("1" (assert) (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (losr_gs_iter_i subtype "losr_iterative.nvop" "{nvo | booleans.AND(losr_iterative.nvo = vectors_2D.*((number_fields.+)((number_fields.+)(vectors_2D.norm(losr_iterative.vo), number_fields.*(losr_iterative.step, losr_iterative.dir)), number_fields.*(number_fields.*(losr_iterative.dir, losr_iterative.i), losr_iterative.step)), vectors_2D.^(losr_iterative.vo)), booleans.AND(reals.>((number_fields.+)((number_fields.+)(vectors_2D.norm(losr_iterative.vo), number_fields.*(losr_iterative.step, losr_iterative.dir)), number_fields.*(number_fields.*(losr_iterative.dir, losr_iterative.i), losr_iterative.step)), 0), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi))))}")) (losr_gs_iter_i_TCC4-3 nil 3560267127 ("" (skosimp*) (("" (typepred "nvo!1") (("" (hide 1) (("" (lemma "repulsive_criteria_transitive") (("" (inst - "eps!1" "nvo!1-vi!1" "nvop!1-vi!1" "s!1" "vo!1-vi!1") (("" (assert) (("" (hide (-1 -4 -6)) (("" (expand "incr_gs_vect") (("" (case "norm(nvo!1) = norm((norm(vo!1) + dir!1 * i!1 * step!1) * ^(vo!1))") (("1" (rewrite "norm_scal") (("1" (replaces -1) (("1" (replaces -1) (("1" (rewrite "normalize_scal") (("1" (rewrite "normalize_normalize") (("1" (rewrite "scal_assoc") (("1" (rewrite "sign_times_abs") (("1" (expand "sign") (("1" (assert) (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((- const-decl "Vector" vectors_2D vectors) (repulsive_criteria const-decl "bool" repulsive nil) (^ const-decl "Normalized" vectors_2D vectors) (Normalized type-eq-decl nil vectors_2D vectors) (Nz_vector type-eq-decl nil vectors_2D vectors) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Sign type-eq-decl nil sign reals) (- const-decl "[numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nzint nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (/= const-decl "boolean" notequal nil) (norm const-decl "nnreal" vectors_2D vectors) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "Vector" vectors_2D vectors) (Vector type-eq-decl nil vectors_2D vectors) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (real nonempty-type-from-decl nil reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (gs_only? const-decl "bool" definitions nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (nzreal nonempty-type-eq-decl nil reals nil) (normalize_scal formula-decl nil vectors_2D vectors) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nz_nzv application-judgement "Nz_vector" vectors_2D vectors) (sign const-decl "Sign" sign reals) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (scal_assoc formula-decl nil vectors_2D vectors) (sign_mult_clos application-judgement "Sign" sign reals) (real_times_real_is_real application-judgement "real" reals nil) (sign_times_abs formula-decl nil sign reals) (normalize_normalize formula-decl nil vectors_2D vectors) (norm_normalize formula-decl nil vectors_2D vectors) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (norm_scal formula-decl nil vectors_2D vectors) (incr_gs_vect const-decl "{nvo: Vect2 | norm(vo) + dir * step > 0 IMPLIES gs_only?(vo)(nvo)}" losr_iterative nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (repulsive_criteria_transitive formula-decl nil repulsive nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)) nil (losr_gs_iter_i subtype "losr_iterative.nvop" "{nvo | booleans.AND(losr_iterative.nvo = vectors_2D.*((number_fields.+)((number_fields.+)(vectors_2D.norm(losr_iterative.vo), number_fields.*(losr_iterative.step, losr_iterative.dir)), number_fields.*(number_fields.*(losr_iterative.dir, losr_iterative.i), losr_iterative.step)), vectors_2D.^(losr_iterative.vo)), booleans.AND(reals.>((number_fields.+)((number_fields.+)(vectors_2D.norm(losr_iterative.vo), number_fields.*(losr_iterative.step, losr_iterative.dir)), number_fields.*(number_fields.*(losr_iterative.dir, losr_iterative.i), losr_iterative.step)), 0), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi))))}")) (losr_gs_iter_i_TCC4-2 nil 3560264980 ("" (skosimp*) (("" (typepred "nvo!1") (("" (hide 1) (("" (split +) (("1" (typepred "incr_gs_vect(nvo!1, step!1, dir!1)") (("1" (assert) (("1" (replaces -4 :dir rl) (("1" (hide-all-but (-1 -2 1)) (("1" (expand "gs_only?" -) (("1" (skosimp*) (("1" (replaces -) (("1" (lemma "gs_only_scal") (("1" (inst -1 "vo!1" "l!1*l!2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "repulsive_criteria_transitive") (("2" (inst - "eps!1" "nvo!1-vi!1" "nvop!1-vi!1" "s!1" "vo!1-vi!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((repulsive_criteria const-decl "bool" repulsive nil) (Sign type-eq-decl nil sign reals) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (Vector type-eq-decl nil vectors_2D vectors) (gs_only? const-decl "bool" definitions nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (gs_only_scal formula-decl nil definitions nil) (scal_assoc formula-decl nil vectors_2D vectors) (nz_nzv application-judgement "Nz_vector" vectors_2D vectors) (norm const-decl "nnreal" vectors_2D vectors) (repulsive_criteria_transitive formula-decl nil repulsive nil)) nil (losr_gs_iter_i subtype "losr_iterative.nvop" "{nvo | booleans.AND(losr_iterative.nvo = vectors_2D.*((number_fields.+)((number_fields.+)(vectors_2D.norm(losr_iterative.vo), number_fields.*(losr_iterative.step, losr_iterative.dir)), number_fields.*(number_fields.*(losr_iterative.dir, losr_iterative.i), losr_iterative.step)), vectors_2D.^(losr_iterative.vo)), booleans.AND(reals.>((number_fields.+)((number_fields.+)(vectors_2D.norm(losr_iterative.vo), number_fields.*(losr_iterative.step, losr_iterative.dir)), number_fields.*(number_fields.*(losr_iterative.dir, losr_iterative.i), losr_iterative.step)), 0), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi))))}")) (losr_gs_iter_i_TCC4-1 nil 3560262748 ("" (subtype-tcc) nil nil) nil nil (losr_gs_iter_i subtype "losr_iterative.nvop" "{nvo | booleans.AND(losr_iterative.nvo = vectors_2D.*((number_fields.+)((number_fields.+)(vectors_2D.norm(losr_iterative.vo), number_fields.*(losr_iterative.step, losr_iterative.dir)), number_fields.*(number_fields.*(losr_iterative.dir, losr_iterative.i), losr_iterative.step)), vectors_2D.^(losr_iterative.vo)), booleans.AND(reals.>((number_fields.+)((number_fields.+)(vectors_2D.norm(losr_iterative.vo), number_fields.*(losr_iterative.step, losr_iterative.dir)), number_fields.*(number_fields.*(losr_iterative.dir, losr_iterative.i), losr_iterative.step)), 0), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi))))}"))) (losr_gs_iter_i_TCC5 0 (losr_gs_iter_i_TCC5-5 "" 3804525466 ("" (skosimp*) (("" (hide -1 -3 3) (("" (typepred "nvo!1") (("" (hide -3) (("" (case "norm(nvo!1) = norm((norm(vo!1) + dir!1 * i!1 * step!1) * ^(vo!1))") (("1" (hide -2) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (replaces -1) (("1" (assert) (("1" (typepred "dir!1") (("1" (hide -1) (("1" (split -) (("1" (replaces -1) (("1" (assert) (("1" (case "floor((maxgs!1 - norm(vo!1)) / step!1) - i!1 >= 0") (("1" (grind) nil nil) ("2" (hide 4) (("2" (typepred "floor((maxgs!1 - norm(vo!1)) / step!1)") (("2" (name-replace "FF" "floor((maxgs!1 - norm(vo!1)) / step!1)") (("2" (case "i!1 < (maxgs!1-norm(vo!1))/step!1") (("1" (assert) nil nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (case "floor((norm(vo!1) - mings!1) / step!1) - i!1 >= 0") (("1" (grind) nil nil) ("2" (hide 4) (("2" (typepred "floor((norm(vo!1)-mings!1) / step!1)") (("2" (case "i!1 < (norm(vo!1)-mings!1)/step!1") (("1" (assert) nil nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak (losr_gs_iter_i termination "losr_iterative.losr_gs_iter_i(losr_iterative.s, losr_iterative.vo, losr_iterative.vi, losr_iterative.minrelgs, losr_iterative.mings, losr_iterative.maxgs, losr_iterative.step, (number_fields.+)(losr_iterative.i, 1), losr_iterative.dir, losr_iterative.eps, losr_iterative.nvop)" "nil")) (losr_gs_iter_i_TCC5-4 nil 3560267142 ("" (skosimp*) (("" (hide -1 -2 1) (("" (typepred "nvo!1") (("" (hide -3) (("" (case "norm(nvo!1) = norm((norm(vo!1) + dir!1 * i!1 * step!1) * ^(vo!1))") (("1" (hide -2) (("1" (rewrite "norm_scal") (("1" (expand "abs") (("1" (replaces -1) (("1" (assert) (("1" (typepred "dir!1") (("1" (hide -1) (("1" (split -) (("1" (replaces -1) (("1" (assert) (("1" (case "floor((maxgs!1 - norm(vo!1)) / step!1) - i!1 >= 0") (("1" (grind) nil nil) ("2" (hide 4) (("2" (typepred "floor((maxgs!1 - norm(vo!1)) / step!1)") (("2" (name-replace "FF" "floor((maxgs!1 - norm(vo!1)) / step!1)") (("2" (case "i!1 < (maxgs!1-norm(vo!1))/step!1") (("1" (assert) nil nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (assert) (("2" (case "floor((norm(vo!1) - mings!1) / step!1) - i!1 >= 0") (("1" (grind) nil nil) ("2" (hide 4) (("2" (typepred "floor((norm(vo!1)-mings!1) / step!1)") (("2" (case "i!1 < (norm(vo!1)-mings!1)/step!1") (("1" (assert) nil nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (integer nonempty-type-from-decl nil integers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (sqv const-decl "nnreal" vectors_2D vectors) (* const-decl "real" vectors_2D vectors) (sqrt_pos application-judgement "posreal" sqrt reals) (nz_sqv_gt_0 application-judgement "posreal" vectors_2D vectors) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (TRUE const-decl "bool" booleans nil) (norm_normalize formula-decl nil vectors_2D vectors) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (norm_scal formula-decl nil vectors_2D vectors) (real_plus_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Vector type-eq-decl nil vectors_2D vectors) (* const-decl "Vector" vectors_2D vectors) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (norm const-decl "nnreal" vectors_2D vectors) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign type-eq-decl nil sign reals) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (Nz_vector type-eq-decl nil vectors_2D vectors) (Normalized type-eq-decl nil vectors_2D vectors) (^ const-decl "Normalized" vectors_2D vectors) (repulsive_criteria const-decl "bool" repulsive nil) (- const-decl "Vector" vectors_2D vectors) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)) nil (losr_gs_iter_i termination "losr_iterative.losr_gs_iter_i(losr_iterative.s, losr_iterative.vo, losr_iterative.vi, losr_iterative.minrelgs, losr_iterative.mings, losr_iterative.maxgs, losr_iterative.step, (number_fields.+)(losr_iterative.i, 1), losr_iterative.dir, losr_iterative.eps, losr_iterative.nvop)" "nil")) (losr_gs_iter_i_TCC5-3 nil 3560266338 ("" (skosimp*) (("" (typepred "nvo!1") (("" (hide 1) (("" (split +) (("1" (typepred "incr_gs_vect(nvo!1, step!1, dir!1)") (("1" (assert) (("1" (replaces -4 :dir rl) (("1" (hide-all-but (-1 -2 1)) (("1" (expand "gs_only?" -) (("1" (skosimp*) (("1" (replaces -) (("1" (lemma "gs_only_scal") (("1" (inst -1 "vo!1" "l!1*l!2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "repulsive_criteria_transitive") (("2" (inst - "eps!1" "nvo!1-vi!1" "nvop!1-vi!1" "s!1" "vo!1-vi!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((repulsive_criteria_transitive formula-decl nil repulsive nil) (norm const-decl "nnreal" vectors_2D vectors) (nz_nzv application-judgement "Nz_vector" vectors_2D vectors) (scal_assoc formula-decl nil vectors_2D vectors) (gs_only_scal formula-decl nil definitions nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (gs_only? const-decl "bool" definitions nil) (Vector type-eq-decl nil vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (Sign type-eq-decl nil sign reals) (repulsive_criteria const-decl "bool" repulsive nil)) nil (losr_gs_iter_i termination "losr_iterative.losr_gs_iter_i(losr_iterative.s, losr_iterative.vo, losr_iterative.vi, losr_iterative.minrelgs, losr_iterative.mings, losr_iterative.maxgs, losr_iterative.step, (number_fields.+)(losr_iterative.i, 1), losr_iterative.dir, losr_iterative.eps, losr_iterative.nvop)" "nil")) (losr_gs_iter_i_TCC5-2 nil 3560265196 ("" (skosimp*) (("" (hide -) (("" (hide 1) (("" (case "floor((maxgs!1-mings!1) / step!1) - i!1 + 1 > 0") (("1" (grind) nil nil) ("2" (hide 4) (("2" (typepred "floor((maxgs!1 - mings!1) / step!1)") (("2" (name-replace "FF" "floor((maxgs!1 - mings!1) / step!1)") (("2" (case "i!1 < (maxgs!1 - mings!1) / step!1") (("1" (assert) nil nil) ("2" (typepred "maxgs!1") (("2" (typepred "mings!1") (("2" (grind-reals) (("2" (case "maxgs!1 > mings!1") (("1" (grind-reals) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (losr_gs_iter_i termination "losr_iterative.losr_gs_iter_i(losr_iterative.s, losr_iterative.vo, losr_iterative.vi, losr_iterative.minrelgs, losr_iterative.mings, losr_iterative.maxgs, losr_iterative.step, (number_fields.+)(losr_iterative.i, 1), losr_iterative.dir, losr_iterative.eps, losr_iterative.nvop)" "nil")) (losr_gs_iter_i_TCC5-1 nil 3560262748 ("" (termination-tcc) nil nil) nil nil (losr_gs_iter_i termination "losr_iterative.losr_gs_iter_i(losr_iterative.s, losr_iterative.vo, losr_iterative.vi, losr_iterative.minrelgs, losr_iterative.mings, losr_iterative.maxgs, losr_iterative.step, (number_fields.+)(losr_iterative.i, 1), losr_iterative.dir, losr_iterative.eps, losr_iterative.nvop)" "nil"))) (losr_gs_iter_i_TCC6 0 (losr_gs_iter_i_TCC6-3 nil 3560267166 ("" (skosimp* :preds? t) (("" (case "gs_only?(vo!1)(nvo!1)") (("1" (replaces -10) (("1" (rewrite "gs_only_zero_right") nil nil)) nil) ("2" (lemma "gs_only_normalize") (("2" (inst?) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ((gs_only? const-decl "bool" definitions nil) (gs_only_zero_right formula-decl nil definitions nil) (TRUE const-decl "bool" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (gs_only_normalize formula-decl nil definitions nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Vector type-eq-decl nil vectors_2D vectors) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign type-eq-decl nil sign reals) (Vect2 type-eq-decl nil vectors_2D_def vectors) (AND const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "Vector" vectors_2D vectors) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnreal type-eq-decl nil real_types nil) (norm const-decl "nnreal" vectors_2D vectors) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (Nz_vector type-eq-decl nil vectors_2D vectors) (Normalized type-eq-decl nil vectors_2D vectors) (^ const-decl "Normalized" vectors_2D vectors) (repulsive_criteria const-decl "bool" repulsive nil) (- const-decl "Vector" vectors_2D vectors)) nil (losr_gs_iter_i subtype "losr_iterative.nvo" "Nz_vect2")) (losr_gs_iter_i_TCC6-2 nil 3560266318 ("" (skosimp*) (("" (hide -) (("" (hide 1) (("" (case "floor((maxgs!1-mings!1) / step!1) - i!1 + 1 > 0") (("1" (grind) nil) ("2" (hide 4) (("2" (typepred "floor((maxgs!1 - mings!1) / step!1)") (("2" (name-replace "FF" "floor((maxgs!1 - mings!1) / step!1)") (("2" (case "i!1 < (maxgs!1 - mings!1) / step!1") (("1" (assert) nil) ("2" (typepred "maxgs!1") (("2" (typepred "mings!1") (("2" (grind-reals) (("2" (case "maxgs!1 > mings!1") (("1" (grind-reals) (("1" (postpone) nil))) ("2" (postpone) nil)))))))))))))))))))))))) nil) nil nil (losr_gs_iter_i subtype "losr_iterative.nvo" "Nz_vect2")) (losr_gs_iter_i_TCC6-1 nil 3560262748 ("" (skosimp* :preds? t) (("" (replaces -5) (("" (rewrite "gs_only_zero_right") nil nil)) nil)) nil) ((gs_only_zero_right formula-decl nil definitions nil) (Vector type-eq-decl nil vectors_2D vectors) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (Sign type-eq-decl nil sign reals) (Vect2 type-eq-decl nil vectors_2D_def vectors) (gs_only? const-decl "bool" definitions nil) (repulsive_criteria const-decl "bool" repulsive nil)) nil (losr_gs_iter_i subtype "losr_iterative.nvo" "Nz_vect2"))) (losr_gs_iter_TCC1 0 (losr_gs_iter_TCC1-1 nil 3560452362 ("" (skosimp*) nil nil) nil nil (losr_gs_iter subtype "vectors_2D.zero" "{nvo | booleans.=>(losr_iterative.nvo /= vectors_2D.zero, booleans.AND(definitions.gs_only?(losr_iterative.vo)(losr_iterative.nvo), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), (number_fields.-)(sign.sign(det_2D.det(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi)))))((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi))))}"))) (losr_gs_iter_TCC2 0 (losr_gs_iter_TCC2-1 nil 3560452362 ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil) ((sign_neg_clos application-judgement "Sign" sign reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (Vector type-eq-decl nil vectors_2D vectors) (/= const-decl "boolean" notequal nil) (zero const-decl "Vector" vectors_2D vectors) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Sign type-eq-decl nil sign reals) (Sign3 type-eq-decl nil sign3 reals)) nil (losr_gs_iter subtype "losr_iterative.dir3" "Sign"))) (losr_gs_iter_TCC3 0 (losr_gs_iter_TCC3-1 nil 3560452362 ("" (skosimp*) (("" (assert) (("" (expand "incr_gs_vect") (("" (assert) (("" (expand "losr_gs_iter_dir") (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_plus_real_is_real application-judgement "real" reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sign_neg_clos application-judgement "Sign" sign reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (losr_gs_iter_dir const-decl "Sign3" losr_iterative nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (incr_gs_vect const-decl "{nvo: Vect2 | norm(vo) + dir * step > 0 IMPLIES gs_only?(vo)(nvo)}" losr_iterative nil) (real_times_real_is_real application-judgement "real" reals nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors)) nil (losr_gs_iter subtype "losr_iterative.nvo" "{nvo | booleans.AND(losr_iterative.nvo = vectors_2D.*(((number_fields.+)(vectors_2D.norm(losr_iterative.vo), number_fields.*(losr_iterative.step, losr_iterative.dir3))), vectors_2D.^(losr_iterative.vo)), booleans.AND(reals.>((number_fields.+)(vectors_2D.norm(losr_iterative.vo), number_fields.*(losr_iterative.step, losr_iterative.dir3)), 0), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), losr_iterative.eps)((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi))))}"))) (losr_gs_iter_TCC4 0 (losr_gs_iter_TCC4-1 nil 3560452362 ("" (skosimp*) (("" (typepred "losr_gs_iter_i(s!1, vo!1, vi!1, minrelgs!1, mings!1,
                              maxgs!1, step!1, 1, dir3!1, eps!1, nvo!1)") (("" (name-replace "LGS" "losr_gs_iter_i(s!1,
                                         vo!1,
                                         vi!1,
                                         minrelgs!1,
                                         mings!1,
                                         maxgs!1,
                                         step!1,
                                         1,
                                         dir3!1,
                                         eps!1,
                                         nvo!1)") (("" (assert) (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Sign3 type-eq-decl nil sign3 reals) (losr_gs_iter_i def-decl "{nvo2 |
   nvo2 /= zero =>
    gs_only?(vo)(nvo2) AND repulsive_criteria(s, vo - vi, eps)(nvo2 - vi)}" losr_iterative nil) (gs_only? const-decl "bool" definitions nil) (- const-decl "Vector" vectors_2D vectors) (repulsive_criteria const-decl "bool" repulsive nil) (^ const-decl "Normalized" vectors_2D vectors) (Normalized type-eq-decl nil vectors_2D vectors) (Nz_vector type-eq-decl nil vectors_2D vectors) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nzint nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (zero const-decl "Vector" vectors_2D vectors) (norm const-decl "nnreal" vectors_2D vectors) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "Vector" vectors_2D vectors) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Vect2 type-eq-decl nil vectors_2D_def vectors) (Sign type-eq-decl nil sign reals) (posnat nonempty-type-eq-decl nil integers nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Nz_vect2 type-eq-decl nil vectors_2D vectors) (/= const-decl "boolean" notequal nil) (Vector type-eq-decl nil vectors_2D vectors) (real nonempty-type-from-decl nil reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sign_neg_clos application-judgement "Sign" sign reals) (real_times_real_is_real application-judgement "real" reals nil) (nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors)) nil (losr_gs_iter subtype "losr_iterative.losr_gs_iter_i(losr_iterative.s, losr_iterative.vo, losr_iterative.vi, losr_iterative.minrelgs, losr_iterative.mings, losr_iterative.maxgs, losr_iterative.step, 1, losr_iterative.dir3, losr_iterative.eps, losr_iterative.nvo)" "{nvo | booleans.=>(losr_iterative.nvo /= vectors_2D.zero, booleans.AND(definitions.gs_only?(losr_iterative.vo)(losr_iterative.nvo), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), (number_fields.-)(sign.sign(det_2D.det(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi)))))((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi))))}"))) (losr_gs_iter_TCC5 0 (losr_gs_iter_TCC5-1 nil 3560452362 ("" (skosimp*) nil nil) ((nz_norm_gt_0 application-judgement "posreal" vectors_2D vectors) (real_times_real_is_real application-judgement "real" reals nil)) nil (losr_gs_iter subtype "vectors_2D.zero" "{nvo | booleans.=>(losr_iterative.nvo /= vectors_2D.zero, booleans.AND(definitions.gs_only?(losr_iterative.vo)(losr_iterative.nvo), repulsive.repulsive_criteria(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi), (number_fields.-)(sign.sign(det_2D.det(losr_iterative.s, (vectors_2D.-)(losr_iterative.vo, losr_iterative.vi)))))((vectors_2D.-)(losr_iterative.nvo, losr_iterative.vi))))}"))))
