(orthogonality_basis (IMP_critical_pairs_TCC1 0 (IMP_critical_pairs_TCC1-1 nil 3673972992 ("" (rewrite "var_countable") nil nil) ((var_countable formula-decl nil orthogonality_basis nil)) nil (IMP_critical_pairs assuming "critical_pairs[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].critical_pairs" "var_countable: ASSUMPTION countability[term_adt[critical_pairs.variable, critical_pairs.symbol, critical_pairs.arity].term].is_countably_infinite(variables_term[critical_pairs.variable, critical_pairs.symbol, critical_pairs.arity].V)"))) (complement_pos_TCC1 0 (complement_pos_TCC1-1 nil 3668595362 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (complement_pos subtype "0" "below[fsp`length]"))) (complement_pos_TCC2 0 (complement_pos_TCC2-1 nil 3668595362 ("" (termination-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (O const-decl "finseq" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (<= const-decl "bool" positions nil) (/= const-decl "boolean" notequal nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (complement_pos_set const-decl "set[T]" predicate_fseq2set nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (empty_seq const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (rest const-decl "finseq" seq_extras structures) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[position[variable, symbol, arity]]" orthogonality_basis nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (complement_pos termination "orthogonality_basis.complement_pos(orthogonality_basis.p, seq_extras[position[variable, symbol, arity]].rest(orthogonality_basis.fsp))" "nil"))) (complement_pos_TCC3 0 (complement_pos_TCC3-1 nil 3668595362 ("" (termination-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (O const-decl "finseq" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (<= const-decl "bool" positions nil) (/= const-decl "boolean" notequal nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (complement_pos_set const-decl "set[T]" predicate_fseq2set nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (empty_seq const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (rest const-decl "finseq" seq_extras structures) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[position[variable, symbol, arity]]" orthogonality_basis nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (complement_pos termination "orthogonality_basis.complement_pos(orthogonality_basis.p, seq_extras[position[variable, symbol, arity]].rest(orthogonality_basis.fsp))" "nil"))) (D_TCC1 0 (D_TCC1-1 nil 3578321423 ("" (skosimp) (("" (skosimp) (("" (typepred fsp!1) (("" (expand* SPP? SP? finseq_appl) (("" (flatten) (("" (inst -2 i!1) (("" (inst -4 i!1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SP? const-decl "bool" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (< const-decl "bool" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (term type-decl nil term_adt nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (SPP? const-decl "bool" positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil)) nil (D subtype "orthogonality_basis.fsp`seq(orthogonality_basis.i)" "{p | booleans.AND(positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positionsOF(orthogonality_basis.s)(orthogonality_basis.p), positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positionsOF(orthogonality_basis.t)(orthogonality_basis.p))}"))) (G_TCC1 0 (G_TCC1-1 nil 3578323310 ("" (skosimp) (("" (typepred fsp!1) (("" (expand* SPP? SP? finseq_appl) (("" (flatten) (("" (inst -2 i!1) (("" (inst -4 i!1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((AND const-decl "[bool, bool -> bool]" booleans nil) (SPP? const-decl "bool" positions nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (< const-decl "bool" reals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (SP? const-decl "bool" positions nil)) nil (G subtype "orthogonality_basis.fsp`seq(orthogonality_basis.i)" "{p | booleans.AND(positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positionsOF(orthogonality_basis.s)(orthogonality_basis.p), positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positionsOF(orthogonality_basis.t)(orthogonality_basis.p))}"))) (ntCP?_TCC1 0 (ntCP?_TCC1-1 nil 3581173294 ("" (skosimp*) (("" (hide-all-but 3) (("" (typepred "p!1") (("" (rewrite "ext_preserv_pos") nil nil)) nil)) nil)) nil) ((ext_preserv_pos formula-decl nil substitution nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (term type-decl nil term_adt nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (positions? type-eq-decl nil positions nil)) nil (ntCP? subtype "orthogonality_basis.p" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(substitution[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].ext(orthogonality_basis.sigma)(rewrite_rules[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].lhs(orthogonality_basis.e1)))"))) (linear?_TCC1 0 (linear?_TCC1-1 nil 3434983472 ("" (skosimp) (("" (lemma Pos_var_is_finite) (("" (inst -1 t!1 x!1) (("" (assert) nil nil)) nil)) nil)) nil) ((arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (Pos_var_is_finite formula-decl nil subterm nil) (Vars const-decl "set[(V)]" subterm nil) (member const-decl "bool" sets nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil)) nil (linear? subtype "subterm[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].Pos_var(orthogonality_basis.t, orthogonality_basis.x)" "finite_set[position[variable, symbol, arity]]"))) (replace_par_pos_TCC1 0 (replace_par_pos_TCC1-1 nil 3481989126 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (term type-decl nil term_adt nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (SPP? const-decl "bool" positions nil) (SPP type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (SP? const-decl "bool" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (replace_par_pos subtype "0" "below[length(fst)]"))) (replace_par_pos_TCC2 0 (replace_par_pos_TCC2-1 nil 3481989126 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (term type-decl nil term_adt nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (SPP? const-decl "bool" positions nil) (SPP type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (SP? const-decl "bool" positions nil) (< const-decl "bool" reals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (replace_par_pos subtype "finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_basis.fsp)(0)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(orthogonality_basis.s)"))) (replace_par_pos_TCC3 0 (replace_par_pos_TCC3-1 nil 3481989126 ("" (skosimp) (("" (typepred ("fsp!1" "fst!1")) (("" (expand SPP?) (("" (flatten) (("" (rewrite rest_of_PP_is_PP) (("" (rewrite rest_of_SP_is_SP) (("" (hide 3) (("" (expand* SP? finseq_appl) (("" (skeep) (("" (inst -2 i) (("" (case "i=0") (("1" (replace -1) (("1" (rewrite replace_preserv_pos) nil nil)) nil) ("2" (expand* PP? finseq_appl) (("2" (assert) (("2" (inst -1 "0" "i") (("2" (assert) (("2" (rewrite replace_preserv_parallel_pos) (("2" (reveal -2) (("2" (inst -1 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (SPP type-eq-decl nil positions nil) (SPP? const-decl "bool" positions nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (rest_of_SP_is_SP formula-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (< const-decl "bool" reals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (SP? const-decl "bool" positions nil) (SP type-eq-decl nil positions nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (replace_preserv_pos formula-decl nil replacement nil) (PP type-eq-decl nil positions nil) (PP? const-decl "bool" positions nil) (rest_of_PP_is_PP formula-decl nil positions nil)) nil (replace_par_pos subtype "seq_extras[position[variable, symbol, arity]].rest(orthogonality_basis.fsp)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(replacement[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].replaceTerm(orthogonality_basis.s, finite_sequences[term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].term].finseq_appl(orthogonality_basis.fst)(0), finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_basis.fsp)(0)))"))) (replace_par_pos_TCC4 0 (replace_par_pos_TCC4-1 nil 3481989126 ("" (skosimp*) (("" (typepred "fst!1") (("" (grind) nil nil)) nil)) nil) ((SPP type-eq-decl nil positions nil) (SPP? const-decl "bool" positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (finseq type-eq-decl nil finite_sequences nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (rest const-decl "finseq" seq_extras structures) (^ const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (replace_par_pos subtype "seq_extras[term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].term].rest(orthogonality_basis.fst)" "{fst_1 | fst_1`length = seq_extras[position[variable, symbol, arity]].rest(orthogonality_basis.fsp)`length}"))) (replace_par_pos_TCC5 0 (replace_par_pos_TCC5-1 nil 3481989126 ("" (skosimp*) (("" (typepred fst!1) (("" (grind) nil nil)) nil)) nil) ((SPP type-eq-decl nil positions nil) (SPP? const-decl "bool" positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (finseq type-eq-decl nil finite_sequences nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (rest const-decl "finseq" seq_extras structures) (^ const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (replace_par_pos termination "orthogonality_basis.replace_par_pos(replacement[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].replaceTerm(orthogonality_basis.s, finite_sequences[term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].term].finseq_appl(orthogonality_basis.fst)(0), finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_basis.fsp)(0)), seq_extras[position[variable, symbol, arity]].rest(orthogonality_basis.fsp), seq_extras[term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].term].rest(orthogonality_basis.fst))" "nil"))) (sigma_rhs_TCC1 0 (sigma_rhs_TCC1-1 nil 3567344809 ("" (subtype-tcc) nil nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (sigma_rhs subtype "orthogonality_basis.i" "below[length(fse)]"))) (subtermsOF_TCC1 0 (subtermsOF_TCC1-1 nil 3568476666 ("" (expand finseq_appl) (("" (skosimp) (("" (typepred fsp!1) (("" (expand* SP? finseq_appl) (("" (inst -1 i!1) nil nil)) nil)) nil)) nil)) nil) ((< const-decl "bool" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (term type-decl nil term_adt nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (SP? const-decl "bool" positions nil) (SP type-eq-decl nil positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (subtermsOF subtype "finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_basis.fsp)(orthogonality_basis.i)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(orthogonality_basis.t)"))) (parallel_reduction_fix?_TCC1 0 (parallel_reduction_fix?_TCC1-1 nil 3567754876 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (SPP? const-decl "bool" positions nil) (SPP type-eq-decl nil positions nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" predicate_fseq2set nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (< const-decl "bool" reals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (parallel_reduction_fix? subtype "orthogonality_basis.fsp" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SP(orthogonality_basis.s)"))) (parallel_reduction_fix?_TCC2 0 (parallel_reduction_fix?_TCC2-1 nil 3567754876 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (term type-decl nil term_adt nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (SPP? const-decl "bool" positions nil) (SPP type-eq-decl nil positions nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" predicate_fseq2set nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (parallel_reduction_fix? subtype "orthogonality_basis.fse" "{fse | orthogonality_basis.fse`length = orthogonality_basis.fss`length}"))) (parallel_reduction_fix?_TCC3 0 (parallel_reduction_fix?_TCC3-1 nil 3567754876 ("" (skosimp) (("" (expand sigma_rhs) (("" (expand empty_seq) (("" (lift-if) (("" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (empty_seq const-decl "finseq" finite_sequences nil)) nil (parallel_reduction_fix? subtype "orthogonality_basis.sigma_rhs(orthogonality_basis.fss, orthogonality_basis.fse)" "{fst | orthogonality_basis.fst`length = orthogonality_basis.fsp`length}"))) (complement_pos_character 0 (complement_pos_character-1 nil 3673527612 ("" (measure-induct "fsp`length" fsp) (("" (skeep) (("" (skeep) (("" (case "x`length=0") (("1" (hide -2) (("1" (expand "seq2set") (("1" (expand finseq_appl) (("1" (skosimp) (("1" (typepred "kk!1") (("1" (hide -3) (("1" (expand complement_pos) (("1" (assert) (("1" (expand empty_seq) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x)") (("2" (rewrite length_rest) (("2" (expand "seq2set") (("2" (expand finseq_appl) (("2" (skosimp) (("2" (expand complement_pos -2) (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (case "kk!1=0") (("1" (replaces -1) (("1" (expand* add_first insert?) (("1" (inst 2 0) (("1" (expand complement_pos_set -2) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (expand* nonempty? empty?) (("2" (skosimp 2) (("2" (expand emptyset) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand emptyset) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* add_first insert? finseq_appl) (("2" (lift-if) (("2" (assert) (("2" (inst -3 p p1) (("2" (prop) (("1" (skosimp) (("1" (typepred i!1) (("1" (expand rest (-1 -2)) (("1" (expand* ^ min) (("1" (expand empty_seq -1) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (inst 7 "1+i!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "kk!1-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 p p1) (("2" (prop) (("1" (skosimp) (("1" (typepred i!1) (("1" (expand rest (-1 -2)) (("1" (expand* ^ min) (("1" (expand empty_seq -1) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (inst 7 "1+i!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 kk!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty_seq const-decl "finseq" finite_sequences nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (length_rest formula-decl nil seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (complement_pos_set const-decl "set[T]" predicate_fseq2set nil) (emptyset const-decl "set" sets nil) (nonempty? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (TRUE const-decl "bool" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (int_minus_int_is_int application-judgement "int" integers nil) (rest const-decl "finseq" seq_extras structures) (O const-decl "finseq" finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (complement_pos def-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (seq2set const-decl "finite_set[T]" seq2set structures) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (complement_pos_is_PP 0 (complement_pos_is_PP-1 nil 3668373375 ("" (measure-induct "fsp`length" fsp) (("" (skeep) (("" (skeep) (("" (case "x`length=0") (("1" (expand complement_pos 1) (("1" (expand PP? 1 1) (("1" (expand empty_seq 1 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x)") (("2" (rewrite length_rest) (("2" (inst -1 p) (("2" (rewrite rest_of_PP_is_PP) (("2" (expand complement_pos 2) (("2" (assert) (("2" (prop) (("2" (rewrite add_first_parallel_pos_to_PP_is_PP) (("2" (expand finseq_appl) (("2" (skeep) (("2" (typepred "choose(complement_pos_set(<=, o)(p, x`seq(0)))") (("2" (lemma complement_pos_character) (("2" (inst -1 "rest(x)" p "complement_pos(p, rest(x))`seq(i)") (("2" (prop) (("1" (skolem -1 k) (("1" (expand complement_pos_set -2 1) (("1" (expand emptyset) (("1" (prop) (("1" (typepred k) (("1" (expand rest -1) (("1" (expand rest -4 1) (("1" (expand* ^ min) (("1" (expand empty_seq -1) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (expand PP? -7) (("1" (expand finseq_appl) (("1" (assert) (("1" (inst -7 1+k 0) (("1" (assert) (("1" (lemma parallel_pos_same_prefix) (("1" (inst -1 p "x`seq(1+k)" "x`seq(0)" "complement_pos(p, rest(x))`seq(i)" "choose(complement_pos_set(<=, o)(p, x`seq(0)))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "seq2set" 1) (("2" (expand finseq_appl) (("2" (inst 1 i) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (empty_seq const-decl "finseq" finite_sequences nil) (length_rest formula-decl nil seq_extras structures) (PP type-eq-decl nil positions nil) (rest_of_PP_is_PP formula-decl nil positions nil) (O const-decl "finseq" finite_sequences nil) (<= const-decl "bool" positions nil) (complement_pos_set const-decl "set[T]" predicate_fseq2set nil) (PRED type-eq-decl nil defined_types nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (add_first_parallel_pos_to_PP_is_PP formula-decl nil positions nil) (complement_pos_character formula-decl nil orthogonality_basis nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (^ const-decl "finseq" finite_sequences nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (parallel_pos_same_prefix formula-decl nil positions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (emptyset const-decl "set" sets nil) (below type-eq-decl nil naturalnumbers nil) (seq2set const-decl "finite_set[T]" seq2set structures) (NOT const-decl "[bool -> bool]" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (rest const-decl "finseq" seq_extras structures) (complement_pos def-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (PP? const-decl "bool" positions nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (complement_pos_empty 0 (complement_pos_empty-1 nil 3668419010 ("" (measure-induct "fsp`length" fsp) (("" (skeep) (("" (skeep) (("" (case "x`length=0") (("1" (expand complement_pos 1) (("1" (expand empty_seq) (("1" (assert) nil nil)) nil)) nil) ("2" (inst -1 "rest(x)") (("2" (rewrite length_rest) (("2" (expand complement_pos 2) (("2" (assert) (("2" (lift-if) (("2" (expand add_first 2) (("2" (expand insert?) (("2" (inst -1 p) (("2" (prop) (("1" (expand* add_first insert? PP? nonempty? empty? member complement_pos_set emptyset finseq_appl) (("1" (skosimp) (("1" (prop) (("1" (inst -4 0 1) (("1" (expand parallel) (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand rest 2) (("2" (expand* ^ min empty_seq add_first insert? PP? finseq_appl) (("2" (assert) (("2" (prop) (("2" (lift-if) (("2" (assert) (("2" (prop) (("2" (skosimp) (("2" (lift-if) (("2" (prop) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (inst -3 0 j!1+1) (("1" (assert) nil nil) ("2" (typepred j!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (inst -3 i!1+1 0) (("1" (assert) nil nil) ("2" (typepred i!1) (("2" (assert) nil nil)) nil)) nil) ("2" (inst -2 i!1+1 j!1+1) (("1" (assert) nil nil) ("2" (typepred j!1) (("2" (assert) nil nil)) nil) ("3" (typepred i!1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 1 2) (("3" (expand* rest ^ min empty_seq add_first insert? PP? finseq_appl) (("3" (prop) (("3" (lift-if) (("3" (assert) (("3" (prop) (("3" (skosimp) (("3" (lift-if) (("3" (prop) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (typepred j!1) (("2" (inst -3 0 j!1+1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (typepred i!1) (("1" (assert) (("1" (inst -3 i!1+1 0) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred (i!1 j!1)) (("2" (assert) (("2" (inst -3 i!1+1 j!1+1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((empty_seq const-decl "finseq" finite_sequences nil) (length_rest formula-decl nil seq_extras structures) (j!1 skolem-const-decl "below[IF 1 > x`length - 1 OR 1 >= x`length THEN 0 ELSE x`length - 1 ENDIF +
       1]" orthogonality_basis nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (i!1 skolem-const-decl "below[IF 1 > x`length - 1 OR 1 >= x`length THEN 0 ELSE x`length - 1 ENDIF +
       1]" orthogonality_basis nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (x skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (j!1 skolem-const-decl "below[IF 1 > x`length - 1 OR 1 >= x`length THEN 0 ELSE x`length - 1 ENDIF +
       1]" orthogonality_basis nil) (NOT const-decl "[bool -> bool]" booleans nil) (^ const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (complement_pos_set const-decl "set[T]" predicate_fseq2set nil) (empty? const-decl "bool" sets nil) (parallel const-decl "bool" positions nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (insert? const-decl "finseq" seq_extras structures) (rest const-decl "finseq" seq_extras structures) (complement_pos def-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (= const-decl "[T, T -> boolean]" equalities nil) (add_first const-decl "finseq" seq_extras structures) (PP? const-decl "bool" positions nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (comp_pos_rest 0 (comp_pos_rest-1 nil 3569857244 ("" (skeep) (("" (decompose-equality) (("1" (expand comp_pos 1 1) (("1" (grind) nil nil)) nil) ("2" (decompose-equality) (("2" (typepred x!1) (("2" (expand comp_pos) (("2" (expand* rest ^ min finseq_appl) (("2" (expand empty_seq -1) (("2" (lift-if) (("2" (assert) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((comp_pos const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (rest const-decl "finseq" seq_extras structures) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (O const-decl "finseq" finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (^ const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil)) shostak)) (comp_pos_preservs_length 0 (comp_pos_preservs_length-1 nil 3541888278 ("" (measure-induct "fsp`length" fsp) (("" (skeep) (("" (skeep) (("" (case "x`length=0") (("1" (expand comp_pos 1) (("1" (propax) nil nil)) nil) ("2" (expand comp_pos 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((comp_pos const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (comp_pos_character_TCC1 0 (comp_pos_character_TCC1-1 nil 3541888277 ("" (skeep) (("" (rewrite comp_pos_preservs_length) (("" (typepred i) (("" (propax) nil nil)) nil)) nil)) nil) ((comp_pos_preservs_length formula-decl nil orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil)) nil (comp_pos_character subtype "orthogonality_basis.i" "below[comp_pos(p, fsp)`length]"))) (comp_pos_character 0 (comp_pos_character-1 nil 3541888478 ("" (skeep) (("" (expand comp_pos) (("" (expand finseq_appl) (("" (propax) nil nil)) nil)) nil)) nil) ((comp_pos const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak)) (comp_pos_is_PP 0 (comp_pos_is_PP-1 nil 3541887603 ("" (skeep) (("" (expand* comp_pos PP? finseq_appl) (("" (prop) (("" (skosimp) (("" (inst -1 i!1 j!1) (("" (assert) (("" (rewrite comp_preservs_parallel_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PP? const-decl "bool" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (comp_pos const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (comp_preservs_parallel_pos formula-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (comp_pos_in_PP_preservs_PP_TCC1 0 (comp_pos_in_PP_preservs_PP_TCC1-1 nil 3568364731 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (comp_pos_in_PP_preservs_PP subtype "0" "below[fsp`length]"))) (comp_pos_in_PP_preservs_PP 0 (comp_pos_in_PP_preservs_PP-1 nil 3568365552 ("" (skeep) (("" (expand* rest ^ min) (("" (expand empty_seq) (("" (expand* o comp_pos finseq_appl) (("" (expand* PP? finseq_appl) (("" (lift-if) (("" (assert) (("" (prop) (("1" (skeep 2) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep 2) (("2" (typepred (i j)) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (inst -4 i j) (("2" (assert) (("2" (rewrite comp_preservs_parallel_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep 2) (("3" (typepred (i j)) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (assert) (("3" (inst -4 i j) (("3" (assert) (("3" (rewrite comp_preservs_parallel_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep 2) (("4" (typepred (i j)) (("4" (lift-if) (("4" (lift-if) (("4" (lift-if) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep 2) (("5" (typepred (i j)) (("5" (lift-if) (("5" (lift-if) (("5" (lift-if) (("5" (assert) (("5" (prop) (("1" (assert) (("1" (inst -5 0 "1 - fsp1`length + j") (("1" (assert) (("1" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil)) nil) ("2" (rewrite parallel_comm) (("2" (inst -5 0 "1 - fsp1`length + i") (("2" (assert) (("2" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil)) nil) ("3" (inst -4 "1 - fsp1`length + i" "1 - fsp1`length + j") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep 2) (("6" (lift-if) (("6" (lift-if) (("6" (lift-if) (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (skeep 2) (("7" (lift-if) (("7" (lift-if) (("7" (lift-if) (("7" (assert) nil nil)) nil)) nil)) nil)) nil) ("8" (skeep 2) (("8" (typepred (i j)) (("8" (lift-if) (("8" (lift-if) (("8" (lift-if) (("8" (assert) (("8" (prop) (("1" (inst -5 i j) (("1" (assert) (("1" (rewrite comp_preservs_parallel_pos) nil nil)) nil)) nil) ("2" (inst -5 0 "1 - fsp1`length + j") (("1" (rewrite comp_preservs_parallel_pos2) nil nil) ("2" (assert) nil nil)) nil) ("3" (rewrite parallel_comm) (("3" (inst -5 0 "1 - fsp1`length + i") (("3" (assert) (("3" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil)) nil) ("4" (inst -4 "1 - fsp1`length + i" "1 - fsp1`length + j") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (rest const-decl "finseq" seq_extras structures) (comp_pos const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (comp_preservs_parallel_pos formula-decl nil positions nil) (int_plus_int_is_int application-judgement "int" integers nil) (parallel_comm formula-decl nil positions nil) (comp_preservs_parallel_pos2 formula-decl nil positions nil) (i skolem-const-decl "below[fsp1`length +
       IF fsp`length = 0 THEN fsp`length
       ELSE IF 1 > fsp`length - 1 OR 1 >= fsp`length THEN 0
            ELSE fsp`length - 1
            ENDIF
       ENDIF]" orthogonality_basis nil) (fsp1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (fsp skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (j skolem-const-decl "below[fsp1`length +
       IF fsp`length = 0 THEN fsp`length
       ELSE IF 1 > fsp`length - 1 OR 1 >= fsp`length THEN 0
            ELSE fsp`length - 1
            ENDIF
       ENDIF]" orthogonality_basis nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (PP? const-decl "bool" positions nil) (empty_seq const-decl "finseq" finite_sequences nil)) shostak)) (sigma_rhs_rest_TCC1 0 (sigma_rhs_rest_TCC1-1 nil 3568042173 ("" (skosimp) (("" (grind) nil nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (rest const-decl "finseq" seq_extras structures) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (^ const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil)) nil (sigma_rhs_rest subtype "seq_extras[rewrite_rule[variable, symbol, arity]].rest(orthogonality_basis.fse)" "{fse | orthogonality_basis.fse`length = seq_extras[Sub[variable, symbol, arity]].rest(orthogonality_basis.fss)`length}"))) (sigma_rhs_rest 0 (sigma_rhs_rest-1 nil 3573806063 ("" (skosimp*) (("" (expand "rest" 1 1) (("" (lift-if) (("" (prop) (("1" (grind) nil nil) ("2" (decompose-equality 2) (("1" (grind) nil nil) ("2" (decompose-equality 1) (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (expand "sigma_rhs" -1) (("1" (lift-if) (("1" (prop) (("1" (hide (-2 2)) (("1" (grind) nil nil)) nil) ("2" (lemma "seq_extras[Sub].length_rest_0") (("2" (inst?) (("2" (assert) (("2" (expand "sigma_rhs" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rest const-decl "finseq" seq_extras structures) (empty_seq const-decl "finseq" finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (rhs const-decl "term" rewrite_rules nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (< const-decl "bool" reals nil) (length_rest_0 formula-decl nil seq_extras structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (fss!1 skolem-const-decl "finseq[Sub[variable, symbol, arity]]" orthogonality_basis nil) (fse!1 skolem-const-decl "finseq[rewrite_rule[variable, symbol, arity]]" orthogonality_basis nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (sigma_rhs_o_TCC1 0 (sigma_rhs_o_TCC1-1 nil 3567783730 ("" (subtype-tcc) nil nil) ((O const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (sigma_rhs_o subtype "finite_sequences[rewrite_rule[variable, symbol, arity]].o(orthogonality_basis.fse1, orthogonality_basis.fse2)" "{fse | orthogonality_basis.fse`length = (finite_sequences[Sub[variable, symbol, arity]].o(orthogonality_basis.fss1, orthogonality_basis.fss2))`length}"))) (sigma_rhs_o 0 (sigma_rhs_o-1 nil 3567783731 ("" (skosimp) (("" (case "fss1!1`length = 0") (("1" (replace -1 -2) (("1" (expand "sigma_rhs" 1 2) (("1" (lift-if) (("1" (assert) (("1" (rewrite "empty_0") (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (replaces -1) (("1" (rewrite "empty_o_seq") (("1" (rewrite "empty_o_seq") (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "fss2!1`length = 0") (("1" (replace -1 -3) (("1" (expand "sigma_rhs" 2 3) (("1" (lift-if) (("1" (assert) (("1" (rewrite "empty_0") (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (replaces -2) (("1" (rewrite "seq_o_empty") (("1" (rewrite "seq_o_empty") (("1" (rewrite "seq_o_empty") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 3) (("1" (grind) nil nil) ("2" (decompose-equality 1) (("2" (expand "sigma_rhs") (("2" (lift-if) (("2" (expand "finseq_appl") (("2" (prop) (("1" (hide 1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq type-eq-decl nil finite_sequences nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (empty_o_seq formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (empty_0 formula-decl nil seq_extras structures) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (O const-decl "finseq" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (rhs const-decl "term" rewrite_rules nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (seq_o_empty formula-decl nil seq_extras structures)) shostak)) (subtermsOF_rest_TCC1 0 (subtermsOF_rest_TCC1-1 nil 3573401562 ("" (skosimp) (("" (rewrite rest_of_SP_is_SP) nil nil)) nil) ((rest_of_SP_is_SP formula-decl nil positions nil) (term type-decl nil term_adt nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (SP? const-decl "bool" positions nil) (SP type-eq-decl nil positions nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil)) nil (subtermsOF_rest subtype "seq_extras[position[variable, symbol, arity]].rest(orthogonality_basis.fsp)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SP(orthogonality_basis.t)"))) (subtermsOF_rest 0 (subtermsOF_rest-1 nil 3573401567 ("" (skeep) (("" (decompose-equality 1) (("1" (expand rest 1 2) (("1" (expand subtermsOF 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand* rest ^ min empty_seq) (("1" (expand subtermsOF) (("1" (assert) nil nil)) nil)) nil) ("2" (expand* ^ min empty_seq finseq_appl) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (expand* rest ^ min empty_seq subtermsOF) (("1" (assert) nil nil)) nil) ("2" (expand* rest ^ min empty_seq subtermsOF) (("2" (assert) nil nil)) nil) ("3" (expand* rest ^ min empty_seq subtermsOF) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (expand* rest ^ min subtermsOF finseq_appl) (("2" (lift-if) (("2" (prop) (("1" (typepred x!1) (("1" (expand* rest ^ min subtermsOF finseq_appl) (("1" (expand empty_seq -1) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred x!1) (("2" (expand* rest ^ min subtermsOF finseq_appl) (("2" (expand empty_seq -1) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rest const-decl "finseq" seq_extras structures) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (SP? const-decl "bool" positions nil) (SP type-eq-decl nil positions nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (finseq type-eq-decl nil finite_sequences nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (^ const-decl "finseq" finite_sequences nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil)) shostak)) (ntCP_lemma_aux1_TCC1 0 (ntCP_lemma_aux1_TCC1-1 nil 3581173294 ("" (skosimp*) (("" (hide-all-but (-1 3)) (("" (rewrite "ext_preserv_pos") nil nil)) nil)) nil) ((arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (lhs const-decl "term" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (ext_preserv_pos formula-decl nil substitution nil)) nil (ntCP_lemma_aux1 subtype "orthogonality_basis.p" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(substitution[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].ext(orthogonality_basis.sg1)(rewrite_rules[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].lhs(orthogonality_basis.e1)))"))) (ntCP_lemma_aux1 0 (ntCP_lemma_aux1-1 nil 3581173357 ("" (skosimp*) (("" (lemma "CP_lemma_aux1a") (("" (inst?) (("" (assert) (("" (skosimp*) (("" (case "ext(union_subs((restriction(sg1!1)(Vars(lhs(e1!1))), restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))))(subtermOF(lhs(e1!1), p!1)) = ext(union_subs((restriction(sg1!1)(Vars(lhs(e1!1))), restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))))(ext(rho!1)(lhs(e2!1)))") (("1" (lemma "unification") (("1" (inst -1 "subtermOF(lhs(e1!1), p!1)" "ext(rho!1)(lhs(e2!1))") (("1" (hide 2) (("1" (prop) (("1" (skosimp*) (("1" (copy -1) (("1" (expand "mgu" -1) (("1" (flatten) (("1" (hide -1) (("1" (inst -1 "union_subs(restriction(sg1!1)(Vars(lhs(e1!1))), restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))") (("1" (expand "member" -1) (("1" (expand "U" -1) (("1" (expand "unifier" -1) (("1" (assert) (("1" (expand "<=") (("1" (skosimp*) (("1" (inst 2 "ext(theta!1)(rhs(e1!1))" "replaceTerm(ext(theta!1)(lhs(e1!1)), ext(theta!1)(ext(rho!1)(rhs(e2!1))),p!1)" "tau!1") (("1" (lemma "ext_o") (("1" (inst -1 "tau!1" "theta!1") (("1" (decompose-equality -1) (("1" (split) (("1" (hide -1) (("1" (expand "ntCP?") (("1" (inst 1 "theta!1" "rho!1" "e1!1" "e2!1" "p!1") (("1" (assert) (("1" (reveal 3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rhs(e1!1)") (("2" (expand "o") (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (lemma "restriction_union") (("2" (inst -1 "restriction(sg1!1)(Vars(lhs(e1!1)))" "restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1))))" "rhs(e1!1)") (("1" (lemma "dom_restriction") (("1" (copy -1) (("1" (inst -1 "Vars(lhs(e1!1))" "sg1!1") (("1" (inst -2 "Vars(ext(rho!1)(lhs(e2!1)))" "alpha!1") (("1" (lemma "IUnion_extra[(V)].disjoint_subset") (("1" (inst -1 "Dom(restriction(sg1!1)(Vars(lhs(e1!1))))" "Vars(lhs(e1!1))" "Dom(restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))" "Vars(ext(rho!1)(lhs(e2!1)))") (("1" (assert) (("1" (prop) (("1" (replace -1 1) (("1" (lemma "restriction_term") (("1" (inst?) (("1" (prop) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "e1!1") (("2" (expand "rewrite_rule?") (("2" (expand* "lhs" "rhs") (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -6 1)) (("2" (lemma "IUnion_extra[(V)].disjoint_subset") (("2" (inst -1 "Vars(rhs(e1!1))" "Vars(rhs(e1!1))" "Dom(restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))" "Vars(ext(rho!1)(lhs(e2!1)))") (("2" (prop) (("1" (hide-all-but 1) (("1" (expand* "subset?" "member") (("1" (skeep) nil nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (lemma "IUnion_extra[(V)].disjoint_subset") (("2" (inst -1 "Vars(rhs(e1!1))" "Vars(lhs(e1!1))" "Vars(ext(rho!1)(lhs(e2!1)))" "Vars(ext(rho!1)(lhs(e2!1)))") (("2" (prop) (("1" (hide (-1 2)) (("1" (typepred "e1!1") (("1" (expand* "rewrite_rule?" "lhs" "rhs") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (expand* "subset?" "member") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "restriction_Subs") nil nil) ("3" (rewrite "restriction_Subs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "ext_replace_ext") (("3" (inst?) (("3" (prop) (("1" (replaces -1) (("1" (copy -1) (("1" (inst -1 "ext(rho!1)(rhs(e2!1))") (("1" (inst -2 "lhs(e1!1)") (("1" (expand "o") (("1" (replace -1 1 rl) (("1" (replace -2 1 rl) (("1" (replace -3 1 rl) (("1" (hide (-1 -2 -3)) (("1" (lemma "restriction_union") (("1" (copy -1) (("1" (inst -1 "restriction(sg1!1)(Vars(lhs(e1!1)))" "restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1))))" "lhs(e1!1)") (("1" (inst -2 "restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1))))" "restriction(sg1!1)(Vars(lhs(e1!1)))" "ext(rho!1)(rhs(e2!1))") (("1" (lemma "dom_restriction") (("1" (copy -1) (("1" (inst -1 "Vars(lhs(e1!1))" "sg1!1") (("1" (inst -2 "Vars(ext(rho!1)(lhs(e2!1)))" "alpha!1") (("1" (lemma "IUnion_extra[(V)].disjoint_subset") (("1" (inst -1 "Dom(restriction(sg1!1)(Vars(lhs(e1!1))))" "Vars(lhs(e1!1))" "Dom(restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))" "Vars(ext(rho!1)(lhs(e2!1)))") (("1" (assert) (("1" (lemma "IUnion_extra[(V)].disjoint_commute") (("1" (inst -1 "Dom(restriction(sg1!1)(Vars(lhs(e1!1))))" "Dom(restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))") (("1" (assert) (("1" (prop) (("1" (rewrite "union_commute") (("1" (replaces -1) (("1" (replaces -1) (("1" (lemma "restriction_term") (("1" (copy -1) (("1" (inst -1 "Vars(ext(rho!1)(lhs(e2!1)))" "alpha!1" "ext(rho!1)(rhs(e2!1))") (("1" (inst -2 "Vars(lhs(e1!1))" "sg1!1" "lhs(e1!1)") (("1" (prop) (("1" (replace -1 1 rl) (("1" (replace -2 1 rl) (("1" (rewrite "ext_o") (("1" (expand "o") (("1" (case-replace "ext(alpha!1)(ext(rho!1)(rhs(e2!1))) = ext(sg2!1)(rhs(e2!1))") (("1" (hide-all-but (-10 -12 1)) (("1" (replaces -1) (("1" (lemma "ext_o") (("1" (inst -1 "alpha!1" "rho!1") (("1" (copy -1) (("1" (decompose-equality -1) (("1" (decompose-equality -2) (("1" (inst -1 "lhs(e2!1)") (("1" (inst -2 "rhs(e2!1)") (("1" (expand "o") (("1" (replace -1 * rl) (("1" (replace -2 * rl) (("1" (hide (-1 -2)) (("1" (lemma "same_substitution") (("1" (inst -1 "comp(alpha!1, rho!1)" "sg2!1" "lhs(e2!1)") (("1" (assert) (("1" (lemma "same_term") (("1" (inst -1 "comp(alpha!1, rho!1)" "sg2!1" "rhs(e2!1)") (("1" (prop) (("1" (skosimp*) (("1" (hide (-3 2)) (("1" (inst -2 "x!1") (("1" (assert) (("1" (hide 1) (("1" (typepred "e2!1") (("1" (hide -2) (("1" (expand "rewrite_rule?") (("1" (flatten) (("1" (expand* "subset?" "rhs" "lhs") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "subset?" "member") (("2" (skeep) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "e2!1") (("3" (expand "rewrite_rule?") (("3" (flatten) (("3" (lemma "rename_preserv_inclusion") (("3" (expand* "rhs" "lhs") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (expand* "subset?" "member") (("4" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -8 1)) (("2" (lemma "IUnion_extra[(V)].disjoint_subset") (("2" (case "disjoint?(Vars(lhs(e1!1)), Vars(ext(rho!1)(rhs(e2!1))))") (("1" (inst -2 "Dom(restriction(sg1!1)(Vars(lhs(e1!1))))" "Vars(lhs(e1!1))" "Vars(ext(rho!1)(rhs(e2!1)))" "Vars(ext(rho!1)(rhs(e2!1)))") (("1" (prop) (("1" (lemma "IUnion_extra[(V)].disjoint_commute") (("1" (inst -1 "Dom(restriction(sg1!1)(Vars(lhs(e1!1))))" "Vars(ext(rho!1)(rhs(e2!1)))") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "subset?" "member") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 1)) (("2" (typepred "e2!1") (("2" (expand "rewrite_rule?") (("2" (flatten) (("2" (expand* "lhs" "rhs") (("2" (lemma "rename_preserv_inclusion") (("2" (inst -1 "rho!1" "e2!1`1" "e2!1`2") (("2" (assert) (("2" (inst -4 "Vars(e1!1`1)" "Vars(e1!1`1)" "Vars(ext(rho!1)(e2!1`2))" "Vars(ext(rho!1)(e2!1`1))") (("2" (prop) (("2" (hide-all-but 1) (("2" (expand* "subset?" "member") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-5 -8 1)) (("3" (lemma "IUnion_extra[(V)].disjoint_subset") (("3" (inst -1 "Vars(lhs(e1!1))" "Vars(lhs(e1!1))" "Dom(restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))" "Vars(ext(rho!1)(lhs(e2!1)))") (("3" (prop) (("3" (hide-all-but 1) (("3" (expand* "subset?" "member") (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-3 -7 1)) (("4" (lemma "IUnion_extra[(V)].disjoint_subset") (("4" (case "disjoint?(Vars(ext(rho!1)(rhs(e2!1))), Vars(lhs(e1!1)))") (("1" (inst -2 "Vars(ext(rho!1)(rhs(e2!1)))" "Vars(ext(rho!1)(rhs(e2!1)))" "Dom(restriction(sg1!1)(Vars(lhs(e1!1))))" "Vars(lhs(e1!1))") (("1" (prop) (("1" (hide-all-but 1) (("1" (expand* "subset?" "member") (("1" (skeep) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 2)) (("2" (typepred "e2!1") (("2" (expand "rewrite_rule?") (("2" (flatten) (("2" (lemma "rename_preserv_inclusion") (("2" (inst -1 "rho!1" "e2!1`1" "e2!1`2") (("2" (assert) (("2" (inst -4 "Vars(e1!1`1)" "Vars(e1!1`1)" "Vars(ext(rho!1)(e2!1`2))" "Vars(ext(rho!1)(e2!1`1))") (("2" (prop) (("1" (expand* "rhs" "lhs") (("1" (hide-all-but (-1 2)) (("1" (lemma "IUnion_extra[(V)].disjoint_commute") (("1" (inst -1 "Vars(e1!1`1)" "Vars(ext(rho!1)(e2!1`2))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "subset?" "member") (("2" (skeep) nil nil)) nil)) nil) ("3" (expand* "rhs" "lhs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "restriction_Subs") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "restriction_Subs") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "restriction_Subs") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "restriction_Subs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-7 1)) (("2" (rewrite "ext_preserv_pos") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (rewrite "ext_preserv_pos") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "restriction_Subs") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "restriction_Subs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "unifiable") (("2" (inst 1 "union_subs((restriction(sg1!1)(Vars(lhs(e1!1))), restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1))))))") (("1" (expand "unifier") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "restriction_Subs") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "restriction_Subs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3 4) (("2" (lemma "restriction_union") (("2" (inst -1 "restriction(sg1!1)(Vars(lhs(e1!1)))" "restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1))))" "subtermOF(lhs(e1!1), p!1)") (("1" (lemma "dom_restriction") (("1" (inst -1 "Vars(lhs(e1!1))" "sg1!1") (("1" (lemma "IUnion_extra[(V)].disjoint_subset") (("1" (inst -1 "Dom(restriction(sg1!1)(Vars(lhs(e1!1))))" "Vars(lhs(e1!1))" "Dom(restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))" "Vars(ext(rho!1)(lhs(e2!1)))") (("1" (lemma "dom_restriction") (("1" (inst -1 "Vars(ext(rho!1)(lhs(e2!1)))" "alpha!1") (("1" (assert) (("1" (lemma "IUnion_extra[(V)].disjoint_subset") (("1" (inst -1 "Vars(lhs(e1!1))" "Vars(lhs(e1!1))" "Dom(restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))" "Vars(ext(rho!1)(lhs(e2!1)))") (("1" (prop) (("1" (replaces -1) (("1" (lemma "restriction_union") (("1" (inst -1 "restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1))))" "restriction(sg1!1)(Vars(lhs(e1!1)))" "ext(rho!1)(lhs(e2!1))") (("1" (lemma "IUnion_extra[(V)].disjoint_commute") (("1" (inst -1 "Dom(restriction(sg1!1)(Vars(lhs(e1!1))))" "Dom(restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))") (("1" (assert) (("1" (lemma "IUnion_extra[(V)].disjoint_subset") (("1" (inst -1 "Dom(restriction(sg1!1)(Vars(lhs(e1!1))))" "Vars(lhs(e1!1))" "Vars(ext(rho!1)(lhs(e2!1)))" "Vars(ext(rho!1)(lhs(e2!1)))") (("1" (assert) (("1" (prop) (("1" (rewrite "union_commute") (("1" (replaces -1) (("1" (lemma "restriction_term") (("1" (inst?) (("1" (prop) (("1" (replace -1 1 rl) (("1" (lemma "restriction_term") (("1" (inst -1 "Vars(ext(rho!1)(lhs(e2!1)))" "alpha!1" "ext(rho!1)(lhs(e2!1))") (("1" (prop) (("1" (replace -1 1 rl) (("1" (rewrite "ext_o") (("1" (expand "o") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "subset?" "member") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "vars_subterm") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (rewrite "IUnion_extra[(V)].disjoint_commute") nil nil)) nil) ("3" (hide-all-but 1) (("3" (expand* "subset?" "member") (("3" (skeep) nil nil)) nil)) nil) ("4" (hide-all-but (-5 -6 1)) (("4" (lemma "IUnion_extra[(V)].disjoint_subset") (("4" (inst -1 "Dom(restriction(sg1!1)(Vars(lhs(e1!1))))" "Vars(lhs(e1!1))" "Vars(ext(rho!1)(lhs(e2!1)))" "Vars(ext(rho!1)(lhs(e2!1)))") (("4" (assert) (("4" (prop) (("1" (hide (-2 -3)) (("1" (lemma "IUnion_extra[(V)].disjoint_commute") (("1" (inst -1 "Dom(restriction(sg1!1)(Vars(lhs(e1!1))))" "Vars(ext(rho!1)(lhs(e2!1)))") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (-1 -2 2)) (("2" (expand* "subset?" "member") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "restriction_Subs") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (lemma "vars_subterm") (("2" (inst?) (("2" (assert) (("2" (lemma "IUnion_extra[(V)].disjoint_subset") (("2" (inst -1 "Vars(subtermOF(lhs(e1!1), p!1))" "Vars(lhs(e1!1))" "Dom(restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))" "Dom(restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))") (("2" (prop) (("2" (hide-all-but 1) (("2" (expand* "subset?" "member") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand* "subset?" "member") (("3" (skeep) nil nil)) nil)) nil) ("4" (hide-all-but (-1 -4 1)) (("4" (lemma "IUnion_extra[(V)].disjoint_subset") (("4" (inst -1 "Dom(restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))" "Vars(ext(rho!1)(lhs(e2!1)))" "Vars(lhs(e1!1))" "Vars(lhs(e1!1))") (("4" (lemma "IUnion_extra[(V)].disjoint_commute") (("4" (inst?) (("4" (assert) (("4" (prop) (("1" (hide (-2 -3 -4)) (("1" (lemma "vars_subterm") (("1" (inst?) (("1" (assert) (("1" (lemma "IUnion_extra[(V)].disjoint_subset") (("1" (inst -1 "Vars(subtermOF(lhs(e1!1), p!1))" "Vars(lhs(e1!1))" "Dom(restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))" "Dom(restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))") (("1" (prop) (("1" (hide-all-but 1) (("1" (expand* "subset?" "member") (("1" (skeep) nil nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (lemma "IUnion_extra[(V)].disjoint_commute") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "subset?" "member") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "restriction_Subs") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "restriction_Subs") nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "union_is_sub") (("1" (hide 2) (("1" (rewrite "restriction_Subs") nil nil)) nil) ("2" (hide 2) (("2" (rewrite "restriction_Subs") nil nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (expand "disjoint_D?") (("4" (lemma "dom_restriction") (("4" (copy -1) (("4" (inst -1 "Vars(lhs(e1!1))" "sg1!1") (("4" (inst -2 "Vars(ext(rho!1)(lhs(e2!1)))" "alpha!1") (("4" (lemma "IUnion_extra[(V)].disjoint_subset") (("4" (inst -1 "Dom(restriction(sg1!1)(Vars(lhs(e1!1))))" "Vars(lhs(e1!1))" "Dom(restriction(alpha!1)(Vars(ext(rho!1)(lhs(e2!1)))))" "Vars(ext(rho!1)(lhs(e2!1)))") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (rewrite "restriction_Subs") nil nil)) nil) ("6" (hide-all-but 1) (("6" (rewrite "restriction_Subs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (CP_lemma_aux1a formula-decl nil critical_pairs nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (Ren type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (lhs const-decl "term" rewrite_rules nil) (Vars const-decl "set[(V)]" subterm nil) (restriction const-decl "term" substitution nil) (union_subs const-decl "term" substitution nil) (disjoint_D type-eq-decl nil substitution nil) (disjoint_D? const-decl "bool" substitution nil) (ext def-decl "term" substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (sg1!1 skolem-const-decl "Sub[variable, symbol, arity]" orthogonality_basis nil) (E!1 skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" orthogonality_basis nil) (e1!1 skolem-const-decl "{e1 | member(e1, E!1)}" orthogonality_basis nil) (alpha!1 skolem-const-decl "Sub[variable, symbol, arity]" orthogonality_basis nil) (rho!1 skolem-const-decl "Ren[variable, symbol, arity]" orthogonality_basis nil) (e2!1 skolem-const-decl "{e2 | member(e2, E!1)}" orthogonality_basis nil) (U const-decl "set[Sub[variable, symbol, arity]]" unification nil) (ext_o formula-decl nil substitution nil) (O const-decl "T3" function_props nil) (comp const-decl "term" substitution nil) (ext_replace_ext formula-decl nil substitution nil) (same_term formula-decl nil substitution nil) (same_substitution formula-decl nil substitution nil) (rename_preserv_inclusion formula-decl nil substitution nil) (union_commute formula-decl nil substitution nil) (disjoint? const-decl "bool" sets nil) (disjoint_commute formula-decl nil IUnion_extra nil) (TRUE const-decl "bool" booleans nil) (ext_preserv_pos formula-decl nil substitution nil) (restriction_union formula-decl nil substitution nil) (restriction_Subs formula-decl nil substitution nil) (dom_restriction formula-decl nil substitution nil) (disjoint_subset formula-decl nil IUnion_extra nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subset? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (restriction_term formula-decl nil substitution nil) (Dom const-decl "set[(V)]" substitution nil) (ntCP? const-decl "bool" orthogonality_basis nil) (rhs const-decl "term" rewrite_rules nil) (replaceTerm def-decl "term" replacement nil) (p!1 skolem-const-decl "position[variable, symbol, arity]" orthogonality_basis nil) (theta!1 skolem-const-decl "Sub[variable, symbol, arity]" orthogonality_basis nil) (<= const-decl "bool" unification nil) (unifier const-decl "bool" unification nil) (mgu const-decl "bool" unification nil) (unifiable const-decl "bool" unification nil) (unification formula-decl nil unification nil) (vars_subterm formula-decl nil subterm nil) (union_is_sub formula-decl nil substitution nil) (member const-decl "bool" sets nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil)) shostak)) (Orth_lemma_aux 0 (Orth_lemma_aux-1 nil 3448728252 ("" (skeep) (("" (assert) (("" (flatten) (("" (lemma "replace_distributivity") (("" (inst -1 p1 p2 t "ext(sg2)(ext(rho2)(rhs(e2p)))") (("" (assert) (("" (lemma "pos_subterm") (("" (inst -1 p1 p2 t) (("" (assert) (("" (lemma "positions_of_ext") (("" (inst -1 "comp(sg1, rho1)" "lhs(e1p)") (("1" (decompose-equality -1) (("1" (inst -1 "p2") (("1" (iff) (("1" (flatten) (("1" (hide -2) (("1" (expand* "union" "member") (("1" (prop) (("1" (lemma "ntCP_lemma_aux1") (("1" (inst -1 "comp(sg1, rho1)" "comp(sg2, rho2)" "E" "p2" "e1p" "e2p") (("1" (expand Ambiguous?) (("1" (prop) (("1" (skosimp) (("1" (inst 2 "t1!1" "t2!1") nil nil)) nil) ("2" (lemma "subterm_ext_commute") (("2" (inst -1 "p2" "lhs(e1p)" "comp(sg1, rho1)") (("2" (assert) (("2" (hide-all-but (-1 -3 -9 -11 -13 1)) (("2" (rewrite ext_o) (("2" (rewrite ext_o) (("2" (expand o (-1 1)) (("2" (replaces -3) (("2" (replace -1 1 rl) (("2" (replace -4 1 rl) (("2" (replace -3 1 rl) (("2" (replace -2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -1) (("3" (replace -2) (("3" (expand lhs) (("3" (expand rhs) (("3" (decompose-equality -1) (("3" (rewrite seq_o_empty) (("3" (replace -11) (("3" (hide 1 2) (("3" (inst 1 t1) (("3" (replace -14 1) (("3" (replace -16 1) (("3" (replace -13 -15) (("3" (hide-all-but (-15 1)) (("3" (lemma ext_o) (("3" (inst-cp -1 sg1 rho1) (("3" (inst -1 sg2 rho2) (("3" (expand o) (("3" (decompose-equality -1) (("3" (decompose-equality -2) (("3" (inst-cp -2 "e2p`2") (("3" (inst -2 "e2p`1") (("3" (inst-cp -1 "e2p`2") (("3" (inst - "e2p`1") (("3" (replace -1 -5 rl) (("3" (replace -3 -5 rl) (("3" (replace -2 1 rl) (("3" (replace -4 1 rl) (("3" (hide -1 -2 -3 -4) (("3" (lemma same_substitution) (("3" (inst -1 "comp(sg1, rho1)" "comp(sg2, rho2)" "e2p`1") (("3" (typepred "e2p") (("3" (expand rewrite_rule?) (("3" (flatten) (("3" (expand subset?) (("3" (lemma same_term) (("3" (inst -1 "comp(sg1, rho1)" "comp(sg2, rho2)" "e2p`2") (("3" (expand RC) (("3" (expand* union member) (("3" (flatten) (("3" (hide 2) (("3" (assert) (("3" (skeep) (("3" (inst -2 x) (("3" (inst -3 x) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite subs_o) nil nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (skolem -1 ("p1p" "p2p")) (("2" (expand Linear?) (("2" (flatten) (("2" (expand Left_Linear?) (("2" (expand Right_Linear?) (("2" (inst -12 e1p) (("2" (inst -13 e1p) (("2" (expand linear?) (("2" (inst -12 "subtermOF(lhs(e1p), p1p)") (("1" (inst -13 "subtermOF(lhs(e1p), p1p)") (("1" (lemma Var_occurs_only_once) (("1" (inst -1 "rhs(e1p)" "subtermOF(lhs(e1p), p1p)") (("1" (assert) (("1" (skolem -1 pr) (("1" (flatten) (("1" (inst 1 "replaceTerm( t1, ext(SigmaP(comp(sg1, rho1), ext(sg2)(ext(rho2)(rhs(e2p))),
                                                                                                                                       	    subtermOF(lhs(e1p), p1p), p2p))(rhs(e1p)), p1)") (("1" (prop) (("1" (expand RC) (("1" (expand* union member) (("1" (flatten) (("1" (hide 2) (("1" (expand reduction? 1) (("1" (inst 1 e2p "comp(sg2, rho2)" "p1 o (pr o p2p)") (("1" (split) (("1" (lemma ext_preserv_pos) (("1" (inst -1 pr "rhs(e1p)" "comp(sg1, rho1)") (("1" (assert) (("1" (rewrite ext_o) (("1" (expand o -1) (("1" (rewrite ext_o) (("1" (expand o 1 3) (("1" (replace -19 1 rl) (("1" (replace -14 1) (("1" (replaces -8) (("1" (expand o -7) (("1" (replace -3 -7 rl) (("1" (lemma replace_preserv_pos) (("1" (inst -1 p1 t "ext(sg1)(ext(rho1)(rhs(e1p)))") (("1" (assert) (("1" (lemma subterm_of_replace) (("1" (inst -1 p1 t "ext(sg1)(ext(rho1)(rhs(e1p)))") (("1" (assert) (("1" (replace -19 -1 rl) (("1" (replace -19 -2 rl) (("1" (lemma pos_subterm) (("1" (inst -1 "p1 o pr" p2p t1) (("1" (prop) (("1" (case "p1 o pr o p2p = p1 o (pr o p2p)") (("1" (replace -1 1 rl) (("1" (replace -2 1) (("1" (lemma pos_o_term) (("1" (inst -1 p1 pr t1) (("1" (prop) (("1" (lemma pos_subterm) (("1" (inst -1 p1 pr t1) (("1" (assert) (("1" (replaces -1) (("1" (replace -4 1) (("1" (replace -9 1) (("1" (lemma subterm_ext_commute) (("1" (inst -1 pr "rhs(e1p)" "comp(sg1, rho1)") (("1" (assert) (("1" (rewrite ext_o) (("1" (expand o -1) (("1" (replace -1 1) (("1" (replace -9 1) (("1" (replace -22 1) (("1" (lemma pos_subterm) (("1" (inst -1 p1p p2p "ext(sg1)(ext(rho1)(lhs(e1p)))") (("1" (prop) (("1" (replace -1 1) (("1" (lemma subterm_ext_commute) (("1" (inst -1 p1p "lhs(e1p)" "comp(sg1, rho1)") (("1" (assert) (("1" (rewrite ext_o) (("1" (expand o -1) (("1" (replace -1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma pos_o_term) (("2" (inst -1 p1p p2p "ext(sg1)(ext(rho1)(lhs(e1p)))") (("2" (prop) (("1" (lemma ext_preserv_pos) (("1" (inst -1 p1p "lhs(e1p)" "comp(sg1, rho1)") (("1" (assert) (("1" (rewrite ext_o) (("1" (expand o -1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil)) nil)) nil) ("2" (replace -9 -13) (("2" (lemma subterm_ext_commute) (("2" (inst -1 p1p "lhs(e1p)" "comp(sg1, rho1)") (("1" (assert) (("1" (rewrite ext_o) (("1" (expand o -1) (("1" (replace -1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma o_assoc[posnat]) (("2" (inst -1 p1 pr p2p) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1 -3 rl) (("2" (lemma pos_o_term) (("2" (inst -1 "p1 o pr" p2p t1) (("2" (prop) (("1" (lemma pos_o_term) (("1" (inst -1 p1 pr t1) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma pos_o_term) (("2" (inst -1 p1 pr t1) (("2" (assert) (("2" (lemma pos_subterm) (("2" (inst -1 p1 pr t1) (("2" (assert) (("2" (replace -1 1) (("2" (replace -3 1) (("2" (lemma subterm_ext_commute) (("2" (inst -1 pr "rhs(e1p)" "comp(sg1, rho1)") (("1" (assert) (("1" (rewrite ext_o) (("1" (expand o -1) (("1" (replace -1 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma SigmaP_vs_replaceTerm_linearR) (("2" (inst -1 pr p2p "rhs(e1p)" "comp(sg1, rho1)" "ext(sg2)(ext(rho2)(rhs(e2p)))" "subtermOF(rhs(e1p), pr)") (("1" (assert) (("1" (replace -3 1 rl) (("1" (replace -1 1) (("1" (rewrite ext_o) (("1" (expand o -7) (("1" (rewrite ext_o) (("1" (expand o 1 (1 3)) (("1" (hide -1) (("1" (lemma replace_preserv_pos) (("1" (inst -1 p1 t "ext(sg1)(ext(rho1)(rhs(e1p)))") (("1" (assert) (("1" (lemma subterm_of_replace) (("1" (inst -1 p1 t "ext(sg1)(ext(rho1)(rhs(e1p)))") (("1" (assert) (("1" (replace -19 (-1 -2) rl) (("1" (replace -1 1 rl) (("1" (lemma replace_associativity) (("1" (inst -1 p1 "pr o p2p" "ext(sg2)(ext(rho2)(rhs(e2p)))" t1 "subtermOF(t1, p1)") (("1" (prop) (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (lemma replace_subterm_of_term) (("1" (inst -1 p1 t1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma ext_preserv_pos) (("2" (inst -1 pr "rhs(e1p)" "comp(sg1, rho1)") (("1" (assert) (("1" (rewrite ext_o) (("1" (expand o -1) (("1" (replace -5 -9 rl) (("1" (lemma subterm_ext_commute) (("1" (inst -1 pr "rhs(e1p)" "comp(sg1, rho1)") (("1" (assert) (("1" (rewrite ext_o) (("1" (expand o -1) (("1" (replace -1 -10 rl) (("1" (hide -1) (("1" (replace -2 (-1 -9) rl) (("1" (lemma pos_o_term) (("1" (inst -1 pr p2p "subtermOF(t1, p1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -5 1)) (("2" (replaces -1) (("2" (expand V) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite ext_o) (("2" (expand o -6) (("2" (lemma replace_preserv_pos) (("2" (inst -1 p1 t "ext(sg1)(ext(rho1)(rhs(e1p)))") (("2" (assert) (("2" (replace -18 -1 rl) (("2" (lemma subterm_of_replace) (("2" (inst -1 p1 t "ext(sg1)(ext(rho1)(rhs(e1p)))") (("2" (assert) (("2" (replace -19 -1 rl) (("2" (lemma ext_preserv_pos) (("2" (inst -1 pr "rhs(e1p)" "comp(sg1, rho1)") (("1" (assert) (("1" (rewrite ext_o) (("1" (expand o -1) (("1" (replace -5 -9 rl) (("1" (replace -2 -1 rl) (("1" (lemma subterm_ext_commute) (("1" (inst -1 pr "rhs(e1p)" "comp(sg1, rho1)") (("1" (assert) (("1" (rewrite ext_o) (("1" (expand o -1) (("1" (replace -1 -10 rl) (("1" (replace -3 -10 rl) (("1" (lemma pos_o_term) (("1" (inst -1 pr p2p "subtermOF(t1, p1)") (("1" (assert) (("1" (lemma pos_o_term) (("1" (inst -1 p1 "pr o p2p" t1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite subs_o) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* RC union member) (("2" (flatten) (("2" (hide 2) (("2" (expand reduction?) (("2" (inst 1 e1p "SigmaP(comp(sg1, rho1),
                                                                                                                                  ext(sg2)(ext(rho2)(rhs(e2p))),
                                                                                                                                  subtermOF(lhs(e1p), p1p), p2p)" p1) (("1" (split) (("1" (lemma replace_preserv_pos) (("1" (inst -1 p3 t "ext(sg2)(ext(rho2)(rhs(e2p)))") (("1" (assert) (("1" (replace -20 -1 rl) (("1" (replace -14 -1) (("1" (lemma pos_ax) (("1" (inst -1 p1 p2 t2) (("1" (assert) (("1" (replace -15 (-14 -20)) (("1" (replace -21 1) (("1" (replace -15 1) (("1" (replace -10 1) (("1" (lemma SigmaP_vs_replaceTerm_linearR) (("1" (replace -6 1) (("1" (inst -1 p1p p2p "lhs(e1p)" "comp(sg1, rho1)" "ext(sg2)(ext(rho2)(rhs(e2p)))" "subtermOF(lhs(e1p), p1p)") (("1" (assert) (("1" (rewrite ext_o -1) (("1" (expand o -1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_dominance) (("2" (copy -1) (("2" (inst -1 p1 empty_seq "ext(SigmaP(comp(sg1, rho1),
                                                                                                                                                           ext(sg2)(ext(rho2)(rhs(e2p))),
                                                                                                                                                           subtermOF(lhs(e1p), p1p), p2p))
                                                                                                                                                           (rhs(e1p))" t "ext(sg1)(ext(rho1)(rhs(e1p)))") (("2" (rewrite seq_o_empty -1) (("2" (assert) (("2" (replace -19 -1 rl) (("2" (inst -2 p1 p2 "ext(SigmaP(comp(sg1, rho1),
                                                                                                                                                           ext(sg2)(ext(rho2)(rhs(e2p))),
                                                                                                                                                           subtermOF(lhs(e1p), p1p), p2p))
                                                                                                                                                           (rhs(e1p))" t "ext(sg2)(ext(rho2)(rhs(e2p)))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_preserv_pos) (("2" (inst -1 p3 t "ext(sg2)(ext(rho2)(rhs(e2p)))") (("2" (assert) (("2" (replace -20 -1 rl) (("2" (lemma pos_ax) (("2" (inst -1 p1 p2 t2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite SigmaP_Subs) (("3" (expand comp 1) (("3" (rewrite ext_o) (("3" (expand o -6) (("3" (expand ext -6 2) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand ext -6) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_preserv_pos) (("2" (inst -1 p1 t "ext(sg1)(ext(rho1)(rhs(e1p)))") (("2" (assert) nil nil)) nil)) nil) ("3" (rewrite SigmaP_Subs) (("3" (expand ext -6) (("3" (propax) nil nil)) nil)) nil) ("4" (expand ext -6) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand member) (("2" (inst 2 t1) (("2" (prop) (("1" (expand* RC union member) nil nil) ("2" (expand* RC union member) (("2" (flatten) (("2" (hide 2) (("2" (expand reduction?) (("2" (inst 1 e1p "SigmaP(comp(sg1, rho1), ext(sg2)(ext(rho2)(rhs(e2p))),
                                                                                                       subtermOF(lhs(e1p), p1p), p2p)" p1) (("1" (split) (("1" (replace -11 -6 rl) (("1" (replace -16 -6 rl) (("1" (replace -6 1) (("1" (lemma SigmaP_vs_replaceTerm_linearR) (("1" (inst -1 p1p p2p "lhs(e1p)" "comp(sg1, rho1)" "ext(sg2)(ext(rho2)(rhs(e2p)))" "subtermOF(lhs(e1p), p1p)") (("1" (assert) (("1" (replace -2 -1 rl) (("1" (rewrite ext_o -1) (("1" (expand o -1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_dominance) (("2" (inst -1 p1 p2 "ext(SigmaP(comp(sg1, rho1),
                                                                                                                                              ext(sg2)(ext(rho2)(rhs(e2p))),
                                                                                                                                              subtermOF(lhs(e1p), p1p), p2p))
                                                                                                                                              (rhs(e1p))" t "ext(sg2)(ext(rho2)(rhs(e2p)))") (("2" (assert) (("2" (replace -12 -1 rl) (("2" (replace -17 1) (("2" (replace -1 1) (("2" (hide -1) (("2" (replace -14 1) (("2" (lemma equality_replaceTerm) (("2" (inst -1 p1 t "ext(sg1)(ext(rho1)(rhs(e1p)))" "ext(SigmaP(comp(sg1, rho1),
                                                                                                                                                                         ext(sg2)(ext(rho2)(rhs(e2p))),
                                                                                                                                                                         subtermOF(lhs(e1p), p1p), p2p))
                                                                                                                                                                         (rhs(e1p))") (("2" (prop) (("2" (hide 1 3) (("2" (lemma SigmaP_equivalence) (("2" (inst -1 p2p "rhs(e1p)" "comp(sg1, rho1)" "ext(sg2)(ext(rho2)(rhs(e2p)))" "subtermOF(lhs(e1p), p1p)") (("2" (prop) (("1" (rewrite ext_o -1) (("1" (expand o -1) (("1" (assert) nil nil)) nil)) nil) ("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_preserv_pos) (("2" (inst -1 p3 t "ext(sg2)(ext(rho2)(rhs(e2p)))") (("2" (assert) (("2" (replace -17 -1 rl) (("2" (replace -12 -1) (("2" (lemma pos_ax) (("2" (inst -1 p1 p2 t2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite SigmaP_Subs) (("3" (expand ext -4) (("3" (propax) nil nil)) nil)) nil) ("4" (expand ext -4) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* V member) (("2" (split) (("1" (propax) nil nil) ("2" (expand Vars 1) (("2" (inst 1 p1p) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite ext_o 1) (("3" (expand o 1) (("3" (lemma pos_subterm_ax) (("3" (inst -1 p1 p2 t) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (replace_distributivity formula-decl nil replacement nil) (positions_of_ext formula-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (union const-decl "set" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (finseq type-eq-decl nil finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (sg2 skolem-const-decl "Sub[variable, symbol, arity]" orthogonality_basis nil) (rho2 skolem-const-decl "Ren[variable, symbol, arity]" orthogonality_basis nil) (TRUE const-decl "bool" booleans nil) (O const-decl "T3" function_props nil) (ext_o formula-decl nil substitution nil) (subterm_ext_commute formula-decl nil substitution nil) (seq_o_empty formula-decl nil seq_extras structures) (subset? const-decl "bool" sets nil) (RC const-decl "reflexive" relations_closure nil) (same_term formula-decl nil substitution nil) (same_substitution formula-decl nil substitution nil) (Ambiguous? const-decl "bool" orthogonality_basis nil) (subs_o formula-decl nil substitution nil) (ntCP_lemma_aux1 formula-decl nil orthogonality_basis nil) (Right_Linear? const-decl "bool" orthogonality_basis nil) (e1p skolem-const-decl "rewrite_rule[variable, symbol, arity]" orthogonality_basis nil) (p1p skolem-const-decl "position[variable, symbol, arity]" orthogonality_basis nil) (Vars const-decl "set[(V)]" subterm nil) (SigmaP_equivalence formula-decl nil substitution nil) (equality_replaceTerm formula-decl nil replacement nil) (Var_occurs_only_once formula-decl nil subterm nil) (pr skolem-const-decl "position[variable, symbol, arity]" orthogonality_basis nil) (SigmaP_vs_replaceTerm_linearR formula-decl nil substitution nil) (replace_associativity formula-decl nil replacement nil) (replace_subterm_of_term formula-decl nil replacement nil) (ext_preserv_pos formula-decl nil substitution nil) (replace_preserv_pos formula-decl nil replacement nil) (o_assoc formula-decl nil finite_sequences nil) (pos_o_term formula-decl nil subterm nil) (subterm_of_replace formula-decl nil replacement nil) (reduction? const-decl "bool" reduction nil) (SigmaP_Subs formula-decl nil substitution nil) (pos_ax formula-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (replace_dominance formula-decl nil replacement nil) (t2 skolem-const-decl "term" orthogonality_basis nil) (replaceTerm def-decl "term" replacement nil) (p1 skolem-const-decl "position[variable, symbol, arity]" orthogonality_basis nil) (t1 skolem-const-decl "term" orthogonality_basis nil) (e2p skolem-const-decl "rewrite_rule[variable, symbol, arity]" orthogonality_basis nil) (SigmaP const-decl "term" substitution nil) (p2p skolem-const-decl "position[variable, symbol, arity]" orthogonality_basis nil) (linear? const-decl "bool" orthogonality_basis nil) (Left_Linear? const-decl "bool" orthogonality_basis nil) (Linear? const-decl "bool" orthogonality_basis nil) (pos_subterm_ax formula-decl nil subterm nil) (member const-decl "bool" sets nil) (lhs const-decl "term" rewrite_rules nil) (rho1 skolem-const-decl "Ren[variable, symbol, arity]" orthogonality_basis nil) (sg1 skolem-const-decl "Sub[variable, symbol, arity]" orthogonality_basis nil) (comp const-decl "term" substitution nil) (pos_subterm formula-decl nil subterm nil) (rhs const-decl "term" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (Ren type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (ext def-decl "term" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil)) shostak)) (Linear_and_Non_ambiguous_implies_sub_comm 0 (Linear_and_Non_ambiguous_implies_sub_comm-2 "" 3790334001 ("" (skeep) (("" (expand sub_commutative?) (("" (skolem * ("t" "t1" "t2")) (("" (flatten) (("" (expand "reduction?" (-2 -3)) (("" (skosimp*) (("" (case "parallel(p!1, p!2)") (("1" (hide 1) (("1" (inst 1 "replaceTerm(t1, ext(sigma!2)(rhs(e!2)), p!2)") (("1" (lemma "replace_persistence") (("1" (inst -1 "p!1" "p!2" "t" "ext(sigma!1)(rhs(e!1))") (("1" (assert) (("1" (lemma "replace_preserv_parallel_pos") (("1" (inst?) (("1" (inst -1 "p!2") (("1" (assert) (("1" (expand RC) (("1" (expand union) (("1" (expand member) (("1" (split) (("1" (flatten) (("1" (hide 2) (("1" (expand reduction?) (("1" (inst 1 "e!2" "sigma!2" "p!2") (("1" (replace -6 1) (("1" (replace -2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 2) (("2" (expand reduction?) (("2" (inst 1 "e!1" "sigma!1" "p!1") (("1" (lemma "replace_persistence") (("1" (inst -1 "p!2" "p!1" "t" "ext(sigma!2)(rhs(e!2))") (("1" (assert) (("1" (rewrite parallel_comm) (("1" (replace -9 1) (("1" (replace -1 1) (("1" (assert) (("1" (replace -7 1) (("1" (lemma "replace_commutativity") (("1" (inst -1 "p!1" "p!2" "ext(sigma!2)(rhs(e!2))" "t" "ext(sigma!1)(rhs(e!1))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "replace_preserv_parallel_pos") (("2" (inst -1 "p!2" "p!1" "t" "ext(sigma!2)(rhs(e!2))") (("2" (replace -9 1) (("2" (rewrite parallel_comm) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "replace_preserv_parallel_pos") (("2" (inst?) (("2" (inst -1 "p!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "parallel") (("2" (expand "<=") (("2" (prop) (("1" (skosimp*) (("1" (lemma Orth_lemma_aux) (("1" (inst -1 "E" "e!1" "e!2" "p!1" "p1!1" "p!2" "_" "_" "_" "_" t t1 t2) (("1" (assert) (("1" (lemma exists_renaming) (("1" (copy -1) (("1" (inst -1 "Vars(lhs(e!1))" "Vars(t)") (("1" (skeep -1) (("1" (assert) (("1" (inst -3 "Vars(lhs(e!2))" "Vars(t)") (("1" (skolem -3 rho2) (("1" (flatten) (("1" (lemma inverse_renaming) (("1" (copy -1) (("1" (inst -1 rho) (("1" (inst -2 rho2) (("1" (skolem -1 rhoi) (("1" (skolem -2 rho2i) (("1" (inst -7 rho rho2 "comp(sigma!1,rhoi)" "comp(sigma!2,rho2i)") (("1" (prop) (("1" (hide 2 3) (("1" (replace -9 1) (("1" (hide-all-but (-1 -3 1)) (("1" (rewrite ext_o) (("1" (expand o) (("1" (lemma ext_o) (("1" (inst -1 rhoi rho) (("1" (expand o) (("1" (decompose-equality) (("1" (inst -1 "lhs(e!1)") (("1" (replace -1 1 rl) (("1" (rewrite inverse_rename_identity) (("1" (expand subset?) (("1" (skeep) (("1" (expand member) (("1" (replace -4 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -10 1)) (("2" (replaces -3 1) (("2" (rewrite ext_o) (("2" (lemma ext_o) (("2" (inst -1 rhoi rho) (("2" (expand o) (("2" (decompose-equality) (("2" (inst -1 "rhs(e!1)") (("2" (replace -1 1 rl) (("2" (rewrite inverse_rename_identity) (("2" (replace -3 1) (("2" (hide-all-but 1) (("2" (typepred e!1) (("2" (expand rewrite_rule?) (("2" (flatten) (("2" (expand rhs) (("2" (expand lhs) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-5 -6 -11 1)) (("3" (replaces -3 1) (("3" (rewrite ext_o) (("3" (lemma ext_o) (("3" (inst -1 rho2i rho2) (("3" (expand o) (("3" (decompose-equality) (("3" (inst -1 "lhs(e!2)") (("3" (replace -1 1 rl) (("3" (reveal -5) (("3" (rewrite inverse_rename_identity) (("3" (replace -3 1) (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-2 -5 -6 -12 1)) (("4" (replaces -4 1) (("4" (rewrite ext_o) (("4" (lemma ext_o) (("4" (inst -1 rho2i rho2) (("4" (expand o) (("4" (decompose-equality) (("4" (inst -1 "rhs(e!2)") (("4" (replace -1 1 rl) (("4" (rewrite inverse_rename_identity) (("4" (hide 2) (("4" (replaces -3 1) (("4" (hide-all-but 1) (("4" (typepred e!2) (("4" (expand rewrite_rule?) (("4" (flatten) (("4" (expand rhs) (("4" (expand lhs) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-3 -4 1)) (("5" (expand disjoint?) (("5" (expand empty?) (("5" (skeep) (("5" (expand member) (("5" (expand intersection) (("5" (expand member) (("5" (flatten) (("5" (inst -4 x) (("5" (prop) (("5" (expand restrict) (("5" (expand Ran) (("5" (expand member) (("5" (expand Vars -1) (("5" (skolem -1 pi) (("5" (rewrite subterm_ext_commute) (("1" (inst 1 "subtermOF(lhs(e!1), pi)") (("1" (split) (("1" (replace -3 1) (("1" (lemma term_is_a_var) (("1" (inst -1 rho "subtermOF(lhs(e!1), pi)" x) (("1" (assert) (("1" (expand Vars 1) (("1" (inst 1 pi) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma term_is_a_var) (("2" (inst -1 rho "subtermOF(lhs(e!1), pi)" x) (("2" (assert) (("2" (expand ext -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand V 1) (("2" (lemma term_is_a_var) (("2" (inst -1 rho "subtermOF(lhs(e!1), pi)" x) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred pi) (("2" (rewrite rename_preserv_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-5 -6 1)) (("6" (expand disjoint?) (("6" (expand empty?) (("6" (skeep) (("6" (inst -3 x) (("6" (expand intersection) (("6" (expand member) (("6" (expand restrict) (("6" (flatten) (("6" (prop) (("6" (expand Ran) (("6" (expand Vars -1) (("6" (skolem -1 pi) (("6" (rewrite subterm_ext_commute) (("1" (inst 1 "subtermOF(lhs(e!2), pi)") (("1" (expand member) (("1" (split) (("1" (replace -3 1) (("1" (expand Vars 1) (("1" (inst 1 pi) nil nil)) nil)) nil) ("2" (lemma term_is_a_var) (("2" (inst -1 rho2 "subtermOF(lhs(e!2), pi)" x) (("2" (assert) (("2" (expand ext -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand V 1) (("2" (lemma term_is_a_var) (("2" (inst -1 rho2 "subtermOF(lhs(e!2), pi)" x) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred pi) (("2" (lemma rename_preserv_pos) (("2" (inst -1 rho2 "lhs(e!2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite subs_o) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite vars_of_term_finite) nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite vars_of_term_finite) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite vars_of_term_finite) nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite vars_of_term_finite) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (lemma Orth_lemma_aux) (("2" (inst -1 E e!2 e!1 p!2 p1!1 p!1 "_" "_" "_" "_" t t2 t1) (("2" (assert) (("2" (lemma exists_renaming) (("2" (copy -1) (("2" (inst -1 "Vars(lhs(e!1))" "Vars(t)") (("1" (skeep -1) (("1" (inst -3 "Vars(lhs(e!2))" "Vars(t)") (("1" (skolem -3 rho2) (("1" (flatten) (("1" (lemma inverse_renaming) (("1" (copy -1) (("1" (inst -1 rho) (("1" (skolem -1 rhoi) (("1" (inst -2 rho2) (("1" (skolem -2 rho2i) (("1" (inst -7 "rho2" "rho" "comp(sigma!2,rho2i)" "comp(sigma!1,rhoi)") (("1" (prop) (("1" (hide-all-but (-1 2)) (("1" (skosimp) (("1" (inst 1 s!1) (("1" (prop) nil nil)) nil)) nil)) nil) ("2" (replace -11 1) (("2" (hide-all-but (-2 1)) (("2" (rewrite ext_o) (("2" (lemma ext_o) (("2" (inst -1 rho2i rho2) (("2" (expand o) (("2" (decompose-equality) (("2" (inst -1 "lhs(e!2)") (("2" (replace -1 1 rl) (("2" (rewrite inverse_rename_identity) (("2" (expand subset?) (("2" (skeep) (("2" (reveal -6) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -12 1) (("3" (hide-all-but (-2 -5 1)) (("3" (rewrite ext_o) (("3" (lemma ext_o) (("3" (inst -1 rho2i rho2) (("3" (expand o) (("3" (decompose-equality) (("3" (inst -1 "rhs(e!2)") (("3" (replace -1 1 rl) (("3" (rewrite inverse_rename_identity) (("3" (expand subset?) (("3" (skeep) (("3" (expand member) (("3" (replace -4) (("3" (hide-all-but (-1 1)) (("3" (typepred e!2) (("3" (expand rewrite_rule?) (("3" (flatten) (("3" (expand subset?) (("3" (inst -1 x) (("3" (expand member) (("3" (expand rhs) (("3" (expand lhs) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -9 1) (("4" (hide-all-but (-1 -3 1)) (("4" (rewrite ext_o) (("4" (lemma ext_o) (("4" (inst -1 rhoi rho) (("4" (expand o) (("4" (decompose-equality) (("4" (inst -1 "lhs(e!1)") (("4" (replace -1 1 rl) (("4" (rewrite inverse_rename_identity) (("4" (expand subset?) (("4" (skeep) (("4" (expand member) (("4" (replace -4) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (replace -10 1) (("5" (hide-all-but (-1 -3 1)) (("5" (rewrite ext_o) (("5" (lemma ext_o) (("5" (inst -1 rhoi rho) (("5" (expand o) (("5" (decompose-equality) (("5" (inst -1 "rhs(e!1)") (("5" (replace -1 1 rl) (("5" (rewrite inverse_rename_identity) (("5" (replace -3) (("5" (hide-all-but 1) (("5" (typepred e!1) (("5" (expand rewrite_rule?) (("5" (flatten) (("5" (expand rhs) (("5" (expand lhs) (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-5 -6 1)) (("6" (expand disjoint?) (("6" (expand empty?) (("6" (skeep) (("6" (inst -3 x) (("6" (expand member) (("6" (expand intersection) (("6" (expand member) (("6" (flatten) (("6" (prop) (("6" (expand restrict) (("6" (expand Ran) (("6" (expand Vars -1) (("6" (skolem -1 pi) (("6" (rewrite subterm_ext_commute) (("1" (inst 1 "subtermOF(lhs(e!2), pi)") (("1" (expand member) (("1" (split) (("1" (replace -3) (("1" (expand Vars 1) (("1" (inst 1 pi) nil nil)) nil)) nil) ("2" (lemma term_is_a_var) (("2" (inst -1 rho2 "subtermOF(lhs(e!2), pi)" x) (("2" (assert) (("2" (expand ext -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand V) (("2" (lemma term_is_a_var) (("2" (inst -1 rho2 "subtermOF(lhs(e!2), pi)" x) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred pi) (("2" (rewrite rename_preserv_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide-all-but (-3 -4 1)) (("7" (expand disjoint?) (("7" (expand empty?) (("7" (skeep) (("7" (inst -3 x) (("7" (expand intersection) (("7" (expand member) (("7" (flatten) (("7" (split) (("1" (propax) nil nil) ("2" (expand restrict) (("2" (expand Ran) (("2" (expand Vars -1) (("2" (skolem -1 pi) (("2" (rewrite subterm_ext_commute) (("1" (lemma term_is_a_var) (("1" (inst -1 rho "subtermOF(lhs(e!1), pi)" x) (("1" (assert) (("1" (inst 1 "subtermOF(lhs(e!1), pi)") (("1" (expand member) (("1" (split) (("1" (replace -4) (("1" (expand Vars 1) (("1" (inst 1 pi) nil nil)) nil)) nil) ("2" (expand ext -2) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand V) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred pi) (("2" (rewrite rename_preserv_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite subs_o) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite vars_of_term_finite) nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite vars_of_term_finite) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite vars_of_term_finite) nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite vars_of_term_finite) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sub_commutative? const-decl "bool" confluence_commute nil) (Orth_lemma_aux formula-decl nil orthogonality_basis nil) (e!2 skolem-const-decl "{e | member(e, E)}" orthogonality_basis nil) (subs_o formula-decl nil substitution nil) (ext_o formula-decl nil substitution nil) (inverse_rename_identity formula-decl nil substitution nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subset? const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (O const-decl "T3" function_props nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (disjoint? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (Ran const-decl "set[term[variable, symbol, arity]]" substitution nil) (subterm_ext_commute formula-decl nil substitution nil) (term_is_a_var formula-decl nil substitution nil) (pi skolem-const-decl "positions?[variable, symbol, arity](ext(rho)(lhs(e!1)))" orthogonality_basis nil) (rho skolem-const-decl "Ren[variable, symbol, arity]" orthogonality_basis nil) (subtermOF def-decl "term" subterm nil) (rename_preserv_pos formula-decl nil substitution nil) (restrict const-decl "R" restrict nil) (empty? const-decl "bool" sets nil) (pi skolem-const-decl "positions?[variable, symbol, arity](ext(rho2)(lhs(e!2)))" orthogonality_basis nil) (rho2 skolem-const-decl "Ren[variable, symbol, arity]" orthogonality_basis nil) (rho2i skolem-const-decl "Ren[variable, symbol, arity]" orthogonality_basis nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" orthogonality_basis nil) (rhoi skolem-const-decl "Ren[variable, symbol, arity]" orthogonality_basis nil) (sigma!1 skolem-const-decl "Sub[variable, symbol, arity]" orthogonality_basis nil) (comp const-decl "term" substitution nil) (Ren? const-decl "bool" substitution nil) (Ren type-eq-decl nil substitution nil) (inverse_renaming formula-decl nil substitution nil) (vars_of_term_finite formula-decl nil subterm nil) (finite_set type-eq-decl nil finite_sets nil) (e!1 skolem-const-decl "{e | member(e, E)}" orthogonality_basis nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" orthogonality_basis nil) (lhs const-decl "term" rewrite_rules nil) (Vars const-decl "set[(V)]" subterm nil) (is_finite const-decl "bool" finite_sets nil) (exists_renaming formula-decl nil substitution nil) (rho2i skolem-const-decl "Ren[variable, symbol, arity]" orthogonality_basis nil) (rhoi skolem-const-decl "Ren[variable, symbol, arity]" orthogonality_basis nil) (pi skolem-const-decl "positions?[variable, symbol, arity](ext(rho)(lhs(e!1)))" orthogonality_basis nil) (rho skolem-const-decl "Ren[variable, symbol, arity]" orthogonality_basis nil) (pi skolem-const-decl "positions?[variable, symbol, arity](ext(rho2)(lhs(e!2)))" orthogonality_basis nil) (rho2 skolem-const-decl "Ren[variable, symbol, arity]" orthogonality_basis nil) (<= const-decl "bool" positions nil) (replace_persistence formula-decl nil replacement nil) (union const-decl "set" sets nil) (t2 skolem-const-decl "term[variable, symbol, arity]" orthogonality_basis nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](t)" orthogonality_basis nil) (parallel_comm formula-decl nil positions nil) (replace_commutativity formula-decl nil replacement nil) (RC const-decl "reflexive" relations_closure nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (member const-decl "bool" sets nil) (rhs const-decl "term" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (ext def-decl "term" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (replaceTerm def-decl "term" replacement nil) (t1 skolem-const-decl "term[variable, symbol, arity]" orthogonality_basis nil) (t skolem-const-decl "term[variable, symbol, arity]" orthogonality_basis nil) (p!2 skolem-const-decl "positions?[variable, symbol, arity](t)" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (parallel const-decl "bool" positions nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (reduction? const-decl "bool" reduction nil)) shostak) (Linear_and_Non_ambiguous_implies_sub_comm-1 nil 3435409696 ("" (skeep) (("" (expand sub_commutative?) (("" (expand "sub_commutative?") (("" (skolem * ("t" "t1" "t2")) (("" (flatten) (("" (expand "reduction?" (-2 -3)) (("" (skosimp*) (("" (case "parallel(p!1, p!2)") (("1" (hide 1) (("1" (inst 1 "replaceTerm(t1, ext(sigma!2)(rhs(e!2)), p!2)") (("1" (lemma "replace_persistence") (("1" (inst -1 "p!1" "p!2" "t" "ext(sigma!1)(rhs(e!1))") (("1" (assert) (("1" (lemma "replace_preserv_parallel_pos") (("1" (inst?) (("1" (inst -1 "p!2") (("1" (assert) (("1" (expand RC) (("1" (expand union) (("1" (expand member) (("1" (split) (("1" (flatten) (("1" (hide 2) (("1" (expand reduction?) (("1" (inst 1 "e!2" "sigma!2" "p!2") (("1" (replace -6 1) (("1" (replace -2 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 2) (("2" (expand reduction?) (("2" (inst 1 "e!1" "sigma!1" "p!1") (("1" (lemma "replace_persistence") (("1" (inst -1 "p!2" "p!1" "t" "ext(sigma!2)(rhs(e!2))") (("1" (assert) (("1" (rewrite parallel_comm) (("1" (replace -9 1) (("1" (replace -1 1) (("1" (assert) (("1" (replace -7 1) (("1" (lemma "replace_commutativity") (("1" (inst -1 "p!1" "p!2" "ext(sigma!2)(rhs(e!2))" "t" "ext(sigma!1)(rhs(e!1))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "replace_preserv_parallel_pos") (("2" (inst -1 "p!2" "p!1" "t" "ext(sigma!2)(rhs(e!2))") (("2" (replace -9 1) (("2" (rewrite parallel_comm) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "replace_preserv_parallel_pos") (("2" (inst?) (("2" (inst -1 "p!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "parallel") (("2" (expand "<=") (("2" (prop) (("1" (skosimp*) (("1" (lemma Orth_lemma_aux) (("1" (inst -1 "E" "e!1" "e!2" "p!1" "p1!1" "p!2" "_" "_" "_" "_" t t1 t2) (("1" (assert) (("1" (lemma exists_renaming) (("1" (copy -1) (("1" (inst -1 "Vars(lhs(e!1))" "Vars(t)") (("1" (skeep -1) (("1" (assert) (("1" (inst -3 "Vars(lhs(e!2))" "Vars(t)") (("1" (skolem -3 rho2) (("1" (flatten) (("1" (lemma inverse_renaming) (("1" (copy -1) (("1" (inst -1 rho) (("1" (inst -2 rho2) (("1" (skolem -1 rhoi) (("1" (skolem -2 rho2i) (("1" (inst -7 rho rho2 "comp(sigma!1,rhoi)" "comp(sigma!2,rho2i)") (("1" (prop) (("1" (hide 2 3) (("1" (replace -9 1) (("1" (hide-all-but (-1 -3 1)) (("1" (rewrite ext_o) (("1" (expand o) (("1" (lemma ext_o) (("1" (inst -1 rhoi rho) (("1" (expand o) (("1" (decompose-equality) (("1" (inst -1 "lhs(e!1)") (("1" (replace -1 1 rl) (("1" (rewrite inverse_rename_identity) (("1" (expand subset?) (("1" (skeep) (("1" (expand member) (("1" (replace -4 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -10 1)) (("2" (replaces -3 1) (("2" (rewrite ext_o) (("2" (lemma ext_o) (("2" (inst -1 rhoi rho) (("2" (expand o) (("2" (decompose-equality) (("2" (inst -1 "rhs(e!1)") (("2" (replace -1 1 rl) (("2" (rewrite inverse_rename_identity) (("2" (replace -3 1) (("2" (hide-all-but 1) (("2" (typepred e!1) (("2" (expand rewrite_rule?) (("2" (flatten) (("2" (expand rhs) (("2" (expand lhs) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-5 -6 -11 1)) (("3" (replaces -3 1) (("3" (rewrite ext_o) (("3" (lemma ext_o) (("3" (inst -1 rho2i rho2) (("3" (expand o) (("3" (decompose-equality) (("3" (inst -1 "lhs(e!2)") (("3" (replace -1 1 rl) (("3" (reveal -5) (("3" (rewrite inverse_rename_identity) (("3" (replace -3 1) (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-2 -5 -6 -12 1)) (("4" (replaces -4 1) (("4" (rewrite ext_o) (("4" (lemma ext_o) (("4" (inst -1 rho2i rho2) (("4" (expand o) (("4" (decompose-equality) (("4" (inst -1 "rhs(e!2)") (("4" (replace -1 1 rl) (("4" (rewrite inverse_rename_identity) (("4" (hide 2) (("4" (replaces -3 1) (("4" (hide-all-but 1) (("4" (typepred e!2) (("4" (expand rewrite_rule?) (("4" (flatten) (("4" (expand rhs) (("4" (expand lhs) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-3 -4 1)) (("5" (expand disjoint?) (("5" (expand empty?) (("5" (skeep) (("5" (expand member) (("5" (expand intersection) (("5" (expand member) (("5" (flatten) (("5" (inst -4 x) (("5" (prop) (("5" (expand restrict) (("5" (expand Ran) (("5" (expand member) (("5" (expand Vars -1) (("5" (skolem -1 pi) (("5" (rewrite subterm_ext_commute) (("1" (inst 1 "subtermOF(lhs(e!1), pi)") (("1" (split) (("1" (replace -3 1) (("1" (lemma term_is_a_var) (("1" (inst -1 rho "subtermOF(lhs(e!1), pi)" x) (("1" (assert) (("1" (expand Vars 1) (("1" (inst 1 pi) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma term_is_a_var) (("2" (inst -1 rho "subtermOF(lhs(e!1), pi)" x) (("2" (assert) (("2" (expand ext -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand V 1) (("2" (lemma term_is_a_var) (("2" (inst -1 rho "subtermOF(lhs(e!1), pi)" x) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred pi) (("2" (rewrite rename_preserv_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-5 -6 1)) (("6" (expand disjoint?) (("6" (expand empty?) (("6" (skeep) (("6" (inst -3 x) (("6" (expand intersection) (("6" (expand member) (("6" (expand restrict) (("6" (flatten) (("6" (prop) (("6" (expand Ran) (("6" (expand Vars -1) (("6" (skolem -1 pi) (("6" (rewrite subterm_ext_commute) (("1" (inst 1 "subtermOF(lhs(e!2), pi)") (("1" (expand member) (("1" (split) (("1" (replace -3 1) (("1" (expand Vars 1) (("1" (inst 1 pi) nil nil)) nil)) nil) ("2" (lemma term_is_a_var) (("2" (inst -1 rho2 "subtermOF(lhs(e!2), pi)" x) (("2" (assert) (("2" (expand ext -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand V 1) (("2" (lemma term_is_a_var) (("2" (inst -1 rho2 "subtermOF(lhs(e!2), pi)" x) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred pi) (("2" (lemma rename_preserv_pos) (("2" (inst -1 rho2 "lhs(e!2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite subs_o) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite vars_of_term_finite) nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite vars_of_term_finite) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite vars_of_term_finite) nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite vars_of_term_finite) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (lemma Orth_lemma_aux) (("2" (inst -1 E e!2 e!1 p!2 p1!1 p!1 "_" "_" "_" "_" t t2 t1) (("2" (assert) (("2" (lemma exists_renaming) (("2" (copy -1) (("2" (inst -1 "Vars(lhs(e!1))" "Vars(t)") (("1" (skeep -1) (("1" (inst -3 "Vars(lhs(e!2))" "Vars(t)") (("1" (skolem -3 rho2) (("1" (flatten) (("1" (lemma inverse_renaming) (("1" (copy -1) (("1" (inst -1 rho) (("1" (skolem -1 rhoi) (("1" (inst -2 rho2) (("1" (skolem -2 rho2i) (("1" (inst -7 "rho2" "rho" "comp(sigma!2,rho2i)" "comp(sigma!1,rhoi)") (("1" (prop) (("1" (hide-all-but (-1 2)) (("1" (skosimp) (("1" (inst 1 s!1) (("1" (prop) nil nil)) nil)) nil)) nil) ("2" (replace -11 1) (("2" (hide-all-but (-2 1)) (("2" (rewrite ext_o) (("2" (lemma ext_o) (("2" (inst -1 rho2i rho2) (("2" (expand o) (("2" (decompose-equality) (("2" (inst -1 "lhs(e!2)") (("2" (replace -1 1 rl) (("2" (rewrite inverse_rename_identity) (("2" (expand subset?) (("2" (skeep) (("2" (reveal -6) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -12 1) (("3" (hide-all-but (-2 -5 1)) (("3" (rewrite ext_o) (("3" (lemma ext_o) (("3" (inst -1 rho2i rho2) (("3" (expand o) (("3" (decompose-equality) (("3" (inst -1 "rhs(e!2)") (("3" (replace -1 1 rl) (("3" (rewrite inverse_rename_identity) (("3" (expand subset?) (("3" (skeep) (("3" (expand member) (("3" (replace -4) (("3" (hide-all-but (-1 1)) (("3" (typepred e!2) (("3" (expand rewrite_rule?) (("3" (flatten) (("3" (expand subset?) (("3" (inst -1 x) (("3" (expand member) (("3" (expand rhs) (("3" (expand lhs) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -9 1) (("4" (hide-all-but (-1 -3 1)) (("4" (rewrite ext_o) (("4" (lemma ext_o) (("4" (inst -1 rhoi rho) (("4" (expand o) (("4" (decompose-equality) (("4" (inst -1 "lhs(e!1)") (("4" (replace -1 1 rl) (("4" (rewrite inverse_rename_identity) (("4" (expand subset?) (("4" (skeep) (("4" (expand member) (("4" (replace -4) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (replace -10 1) (("5" (hide-all-but (-1 -3 1)) (("5" (rewrite ext_o) (("5" (lemma ext_o) (("5" (inst -1 rhoi rho) (("5" (expand o) (("5" (decompose-equality) (("5" (inst -1 "rhs(e!1)") (("5" (replace -1 1 rl) (("5" (rewrite inverse_rename_identity) (("5" (replace -3) (("5" (hide-all-but 1) (("5" (typepred e!1) (("5" (expand rewrite_rule?) (("5" (flatten) (("5" (expand rhs) (("5" (expand lhs) (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (-5 -6 1)) (("6" (expand disjoint?) (("6" (expand empty?) (("6" (skeep) (("6" (inst -3 x) (("6" (expand member) (("6" (expand intersection) (("6" (expand member) (("6" (flatten) (("6" (prop) (("6" (expand restrict) (("6" (expand Ran) (("6" (expand Vars -1) (("6" (skolem -1 pi) (("6" (rewrite subterm_ext_commute) (("1" (inst 1 "subtermOF(lhs(e!2), pi)") (("1" (expand member) (("1" (split) (("1" (replace -3) (("1" (expand Vars 1) (("1" (inst 1 pi) nil nil)) nil)) nil) ("2" (lemma term_is_a_var) (("2" (inst -1 rho2 "subtermOF(lhs(e!2), pi)" x) (("2" (assert) (("2" (expand ext -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand V) (("2" (lemma term_is_a_var) (("2" (inst -1 rho2 "subtermOF(lhs(e!2), pi)" x) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred pi) (("2" (rewrite rename_preserv_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide-all-but (-3 -4 1)) (("7" (expand disjoint?) (("7" (expand empty?) (("7" (skeep) (("7" (inst -3 x) (("7" (expand intersection) (("7" (expand member) (("7" (flatten) (("7" (split) (("1" (propax) nil nil) ("2" (expand restrict) (("2" (expand Ran) (("2" (expand Vars -1) (("2" (skolem -1 pi) (("2" (rewrite subterm_ext_commute) (("1" (lemma term_is_a_var) (("1" (inst -1 rho "subtermOF(lhs(e!1), pi)" x) (("1" (assert) (("1" (inst 1 "subtermOF(lhs(e!1), pi)") (("1" (expand member) (("1" (split) (("1" (replace -4) (("1" (expand Vars 1) (("1" (inst 1 pi) nil nil)) nil)) nil) ("2" (expand ext -2) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand V) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred pi) (("2" (rewrite rename_preserv_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subs_o) nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite subs_o) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite vars_of_term_finite) nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite vars_of_term_finite) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite vars_of_term_finite) nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite vars_of_term_finite) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sub_commutative? const-decl "bool" confluence_commute nil) (Orth_lemma_aux formula-decl nil orthogonality_basis nil) nil (subs_o formula-decl nil substitution nil) (ext_o formula-decl nil substitution nil) (inverse_rename_identity formula-decl nil substitution nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subset? const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (O const-decl "T3" function_props nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (disjoint? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (Ran const-decl "set[term[variable, symbol, arity]]" substitution nil) (subterm_ext_commute formula-decl nil substitution nil) (term_is_a_var formula-decl nil substitution nil) nil nil (subtermOF def-decl "term" subterm nil) (rename_preserv_pos formula-decl nil substitution nil) (restrict const-decl "R" restrict nil) (empty? const-decl "bool" sets nil) nil nil nil nil nil nil (comp const-decl "term" substitution nil) (Ren? const-decl "bool" substitution nil) (Ren type-eq-decl nil substitution nil) (inverse_renaming formula-decl nil substitution nil) (vars_of_term_finite formula-decl nil subterm nil) (finite_set type-eq-decl nil finite_sets nil) nil nil (lhs const-decl "term" rewrite_rules nil) (Vars const-decl "set[(V)]" subterm nil) (is_finite const-decl "bool" finite_sets nil) (exists_renaming formula-decl nil substitution nil) nil nil nil nil nil nil (<= const-decl "bool" positions nil) (replace_persistence formula-decl nil replacement nil) (union const-decl "set" sets nil) nil nil (parallel_comm formula-decl nil positions nil) (replace_commutativity formula-decl nil replacement nil) (RC const-decl "reflexive" relations_closure nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (member const-decl "bool" sets nil) (rhs const-decl "term" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (ext def-decl "term" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (replaceTerm def-decl "term" replacement nil) nil nil nil (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (parallel const-decl "bool" positions nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (reduction? const-decl "bool" reduction nil)) shostak)) (Linear_and_Non_ambiguous_implies_confluent 0 (Linear_and_Non_ambiguous_implies_confluent-1 nil 3434983522 ("" (skeep) (("" (name-replace RRE "reduction?(E)") (("" (lemma Linear_and_Non_ambiguous_implies_sub_comm) (("" (inst -1 E) (("" (assert) (("" (reveal -2) (("" (replace -1 -2 lr) (("" (hide -1 1 -3) (("" (lemma sub_comm_implies_conf) (("" (inst -1 RRE) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (term type-decl nil term_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (reduction? const-decl "bool" reduction nil) (PRED type-eq-decl nil defined_types nil) (sub_comm_implies_conf formula-decl nil confluence_commute nil) (Linear_and_Non_ambiguous_implies_sub_comm formula-decl nil orthogonality_basis nil)) shostak)) (parallel_reduction_inclusion 0 (parallel_reduction_inclusion-1 nil 3481989126 ("" (skeep) (("" (expand* subset? member) (("" (split) (("1" (skeep) (("1" (expand* reduction? parallel_reduction?) (("1" (skosimp -1) (("1" (inst 1 "(# length := 1, seq := (LAMBDA (n: below[1]): p!1) #)") (("1" (expand parallel_reduction_fix?) (("1" (inst 1 "(# length := 1, seq := (LAMBDA (n: below[1]): e!1) #) " "(# length := 1, seq := (LAMBDA (n: below[1]): sigma!1) #)") (("1" (prop) (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (hide -1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide -) (("2" (typepred e!1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (case "FORALL (t1,t2,(fsp: SPP(t1)), (fse: finseq[rewrite_rule] | subset?(fse, E)), fss): (fsp`length = fse`length & fsp`length = fss`length & subtermsOF(t1, fsp) = sigma_lhs(fss, fse) & t2 = replace_par_pos(t1, fsp, sigma_rhs(fss, fse))) => RTC(reduction?(E))(t1, t2)") (("1" (expand* parallel_reduction? finseq_appl) (("1" (skosimp -2) (("1" (expand parallel_reduction_fix?) (("1" (skosimp) (("1" (inst -1 "x`1" "x`2" fsp!1 fse!1 fss!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (measure-induct "fss`length" fss) (("1" (skeep) (("1" (skosimp) (("1" (case "x!1`length=0") (("1" (hide -2) (("1" (expand replace_par_pos) (("1" (assert) (("1" (expand* RTC IUnion) (("1" (inst 1 0) (("1" (expand iterate) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x!1)") (("2" (rewrite length_rest) (("2" (expand replace_par_pos -5) (("2" (assert) (("2" (expand finseq_appl) (("2" (rewrite sigma_rhs_rest) (("2" (expand sigma_rhs -5 1) (("2" (expand finseq_appl) (("2" (inst -1 "replaceTerm(t1!1,ext(x!1`seq(0))(rhs(fse!1`seq(0))),fsp!1`seq(0))" t2!1 "rest(fsp!1)" "rest(fse!1)") (("1" (assert) (("1" (prop) (("1" (case "reduction?(E)(t1!1, replaceTerm(t1!1, ext(x!1`seq(0))(rhs(fse!1`seq(0))),fsp!1`seq(0)))") (("1" (typepred "RTC(reduction?(E))") (("1" (expand reflexive_transitive?) (("1" (flatten) (("1" (expand transitive?) (("1" (lemma R_subset_RTC) (("1" (inst -1 "reduction?(E)") (("1" (expand* subset? member) (("1" (inst -1 "(t1!1, replaceTerm(t1!1, ext(x!1`seq(0))(rhs(fse!1`seq(0))), fsp!1`seq(0)))") (("1" (assert) (("1" (inst -3 t1!1 "replaceTerm(t1!1, ext(x!1`seq(0))(rhs(fse!1`seq(0))),fsp!1`seq(0))" t2!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand reduction? 1) (("2" (inst 1 "fse!1`seq(0)" "x!1`seq(0)" "fsp!1`seq(0)") (("1" (expand* subtermsOF finseq_appl) (("1" (expand* sigma_lhs finseq_appl) (("1" (decompose-equality -4) (("1" (inst -1 0) nil nil) ("2" (typepred fsp!1) (("2" (hide-all-but (-1 1)) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 x!2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred fse!1) (("2" (hide-all-but (-1 1)) (("2" (expand* subset? subset? member) (("2" (inst?) (("2" (assert) (("2" (expand* seq2set finseq_appl) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3 -4 3) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 -2 1)) (("3" (grind) nil nil)) nil) ("4" (expand* subtermsOF sigma_lhs finseq_appl) (("4" (lift-if) (("4" (prop) (("1" (expand empty_seq) (("1" (split) (("1" (hide-all-but (-1 -3 1)) (("1" (grind) nil nil)) nil) ("2" (decompose-equality) (("1" (typepred x!2) (("1" (hide-all-but (-1 -2 -4)) (("1" (grind) nil nil)) nil)) nil) ("2" (skosimp) (("2" (hide-all-but (-1 -2 -4)) (("2" (grind) nil nil)) nil)) nil) ("3" (skeep) (("3" (typepred i) (("3" (hide-all-but (-1 -2 -4)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 2) (("1" (hide-all-but (-2 1)) (("1" (grind) nil nil)) nil) ("2" (decompose-equality) (("1" (decompose-equality -3) (("1" (expand rest (1 2)) (("1" (expand* ^ min) (("1" (expand empty_seq 2) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (inst -1 1+x!2) (("3" (typepred fsp!1) (("3" (expand* SPP? SP? PP? finseq_appl) (("3" (flatten) (("3" (assert) (("3" (rewrite replace_persistence) (("1" (inst -2 0) nil nil) ("2" (inst -2 1+x!2) nil nil) ("3" (inst -1 0 1+x!2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred fsp!1) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 x!3) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil) ("3" (skeep) (("3" (hide-all-but (-2 1)) (("3" (typepred i) (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (skeep) (("4" (typepred i) (("4" (expand rest (-1 1)) (("4" (expand* ^ min) (("4" (expand empty_seq -1) (("4" (lift-if) (("4" (assert) (("4" (prop) (("4" (typepred fsp!1) (("4" (expand* SPP? SP? PP? finseq_appl) (("4" (flatten) (("4" (assert) (("4" (rewrite replace_preserv_parallel_pos) (("1" (inst -2 1+i) nil nil) ("2" (inst -2 0) nil nil) ("3" (inst -1 0 1+i) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (skosimp) (("3" (grind) nil nil)) nil)) nil) ("4" (hide-all-but (-1 -2 1)) (("4" (skeep) (("4" (typepred i) (("4" (grind) nil nil)) nil)) nil)) nil) ("5" (hide-all-but (-1 -2 1 2)) (("5" (skeep) (("5" (typepred i) (("5" (expand* rest ^ min) (("5" (expand empty_seq (-1 2)) (("5" (lift-if) (("5" (assert) (("5" (prop) (("5" (typepred fsp!1) (("5" (expand* SPP? SP? PP? finseq_appl) (("5" (assert) (("5" (flatten) (("5" (rewrite replace_preserv_parallel_pos) (("1" (inst -2 1+i) nil nil) ("2" (inst -2 0) nil nil) ("3" (inst -1 0 1+i) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred fse!1) (("2" (expand subset?) (("2" (lemma "predicate_fseq2set[rewrite_rule].rest_subset") (("2" (inst?) (("2" (lemma "sets_lemmas[rewrite_rule].subset_transitive") (("2" (inst -1 "seq2set(rest(fse!1))" "seq2set(fse!1)" "E") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand sigma_rhs 1) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (skeep) (("5" (typepred fsp) (("5" (expand SPP?) (("5" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (expand* sigma_rhs empty_seq) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (skeep) (("5" (assert) nil nil)) nil) ("6" (skeep) (("6" (typepred fsp) (("6" (expand SPP?) (("6" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (iterate def-decl "pred[[T, T]]" relation_iterate orders) (length_rest formula-decl nil seq_extras structures) (sigma_rhs_rest formula-decl nil orthogonality_basis nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (subset_transitive formula-decl nil sets_lemmas nil) (rest_subset formula-decl nil predicate_fseq2set nil) (FALSE const-decl "bool" booleans nil) (epsilon const-decl "T" epsilons nil) (TRUE const-decl "bool" booleans nil) (x!1 skolem-const-decl "finseq[Sub[variable, symbol, arity]]" orthogonality_basis nil) (fsp!1 skolem-const-decl "SPP[variable, symbol, arity](t1!1)" orthogonality_basis nil) (t1!1 skolem-const-decl "term" orthogonality_basis nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (replace_persistence formula-decl nil replacement nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (int_minus_int_is_int application-judgement "int" integers nil) (transitive? const-decl "bool" relations nil) (R_subset_RTC formula-decl nil relations_closure nil) (subtermOF def-decl "term" subterm nil) (replaceTerm def-decl "term" replacement nil) (ext def-decl "term" substitution nil) (fse!1 skolem-const-decl "{fse: finseq[rewrite_rule[variable, symbol, arity]] | subset?(fse, E)}" orthogonality_basis nil) (wf_nat formula-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (well_founded? const-decl "bool" orders nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (SP type-eq-decl nil positions nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (SP? const-decl "bool" positions nil) (PP? const-decl "bool" positions nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (nil application-judgement "(nonempty?[rewrite_rule[variable, symbol, arity]])" orthogonality_basis nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (Vars const-decl "set[(V)]" subterm nil) (seq2set const-decl "finite_set[T]" seq2set structures) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (lhs const-decl "term" rewrite_rules nil) (sigma_lhs const-decl "finseq[term]" orthogonality_basis nil) (rhs const-decl "term" rewrite_rules nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (empty_seq const-decl "finseq" finite_sequences nil) (^ const-decl "finseq" finite_sequences nil) (rest const-decl "finseq" seq_extras structures) (replace_par_pos def-decl "term" orthogonality_basis nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (e!1 skolem-const-decl "{e | member(e, E)}" orthogonality_basis nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" orthogonality_basis nil) (subset? const-decl "bool" predicate_fseq2set nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (SPP type-eq-decl nil positions nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (term type-decl nil term_adt nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (SPP? const-decl "bool" positions nil) (x skolem-const-decl "[term[variable, symbol, arity], term[variable, symbol, arity]]" orthogonality_basis nil) (< const-decl "bool" reals nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](x`1)" orthogonality_basis nil) (reduction? const-decl "bool" reduction nil) (parallel_reduction? const-decl "bool" orthogonality_basis nil)) shostak)) (parallel_reduction_RTC 0 (parallel_reduction_RTC-1 nil 3491728922 ("" (skosimp) (("" (decompose-equality) (("" (iff) (("" (lemma parallel_reduction_inclusion) (("" (inst -1 E!1) (("" (split) (("1" (flatten) (("1" (hide -3) (("1" (expand RTC -1) (("1" (expand* IUnion member) (("1" (case "FORALL (t1, t2: term, i: nat): iterate(reduction?(E!1), i)(t1, t2) => RTC(parallel_reduction?(E!1))(t1, t2)") (("1" (skosimp) (("1" (inst -1 x!1 x!2 i!1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -1 2) (("2" (induct i) (("1" (skeep) (("1" (expand* RTC IUnion member) (("1" (inst 1 0) (("1" (expand iterate) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (lemma iterate_add_one) (("2" (inst -1 "reduction?(E!1)" j) (("2" (replaces -1) (("2" (expand o) (("2" (skosimp) (("2" (inst -1 y!1 t2) (("2" (assert) (("2" (expand* subset? member) (("2" (inst -4 "(t1, y!1)") (("2" (lemma RC_o_RTC_is_RTC) (("2" (inst -1 "parallel_reduction?(E!1)" t1 y!1 t2) (("2" (expand* RC union member) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide -2) (("2" (expand RTC -1) (("2" (expand* IUnion member) (("2" (case "FORALL (t1, t2: term, i: nat): iterate(parallel_reduction?(E!1), i)(t1, t2) => RTC(reduction?(E!1))(t1, t2)") (("1" (skosimp) (("1" (inst -1 x!1 x!2 i!1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -1 2) (("2" (induct i) (("1" (skeep) (("1" (expand* RTC IUnion member) (("1" (inst 1 0) (("1" (expand iterate) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (lemma iterate_add_one) (("2" (inst -1 "parallel_reduction?(E!1)" j) (("2" (replaces -1) (("2" (expand o) (("2" (skosimp) (("2" (inst -1 y!1 t2) (("2" (assert) (("2" (expand* subset? member) (("2" (inst -4 "(t1, y!1)") (("2" (assert) (("2" (lemma RTC_o_RTC_is_RTC) (("2" (inst -1 "reduction?(E!1)" t1 y!1 t2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (reduction? const-decl "bool" reduction nil) (parallel_reduction? const-decl "bool" orthogonality_basis nil) (pred type-eq-decl nil defined_types nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (parallel_reduction_inclusion formula-decl nil orthogonality_basis nil) (IUnion const-decl "set[T]" indexed_sets nil) (iterate_add_one formula-decl nil relation_iterate orders) (int_minus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (PRED type-eq-decl nil defined_types nil) (RC const-decl "reflexive" relations_closure nil) (union const-decl "set" sets nil) (RC_o_RTC_is_RTC formula-decl nil confluence_commute nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (O const-decl "bool" relation_props nil) (nat_induction formula-decl nil naturalnumbers nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (iterate def-decl "pred[[T, T]]" relation_iterate orders) (RTC_o_RTC_is_RTC formula-decl nil confluence_commute nil)) shostak)) (replace_par_pos_preservs_pos_TCC1 0 (replace_par_pos_preservs_pos_TCC1-1 nil 3503045178 ("" (skosimp*) (("" (expand "SPP?") (("" (flatten) (("" (lemma "rest_of_PP_is_PP") (("" (inst -1 "add_first(p!1, fsp!1)") (("" (rewrite "rest_add_first") (("" (lemma "rest_of_SP_is_SP") (("" (inst -1 "t!1" "add_first(p!1, fsp!1)") (("" (rewrite "rest_add_first") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SPP? const-decl "bool" positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (rest_of_PP_is_PP formula-decl nil positions nil) (rest_add_first formula-decl nil seq_extras structures) (term type-decl nil term_adt nil) (SP? const-decl "bool" positions nil) (t!1 skolem-const-decl "term" orthogonality_basis nil) (SP type-eq-decl nil positions nil) (rest_of_SP_is_SP formula-decl nil positions nil) (PP type-eq-decl nil positions nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (PP? const-decl "bool" positions nil) (add_first const-decl "finseq" seq_extras structures) (p!1 skolem-const-decl "position[variable, symbol, arity]" orthogonality_basis nil) (fsp!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil)) nil (replace_par_pos_preservs_pos subtype "orthogonality_basis.fsp" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(orthogonality_basis.t)"))) (replace_par_pos_preservs_pos 0 (replace_par_pos_preservs_pos-1 nil 3491736008 ("" (measure-induct "fsp`length" "fsp") (("1" (skeep) (("1" (skeep) (("1" (case "x`length = 0") (("1" (hide -2) (("1" (expand replace_par_pos 1) (("1" (assert) (("1" (expand* SPP? SP?) (("1" (flatten) (("1" (inst -3 0) (("1" (expand finseq_appl) (("1" (expand add_first -3) (("1" (expand insert?) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x)") (("2" (rewrite length_rest) (("2" (inst -1 "rest(fst)" "p" "replaceTerm(t, fst`seq(0), x`seq(0))") (("1" (prop) (("1" (expand replace_par_pos 2) (("1" (expand finseq_appl) (("1" (prop) nil nil)) nil)) nil) ("2" (expand SPP?) (("2" (flatten) (("2" (rewrite add_first_parallel_pos_to_PP_is_PP) (("1" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (rewrite replace_preserv_parallel_pos) (("1" (expand SP? -2) (("1" (inst -2 0) (("1" (hide-all-but (-2 1)) (("1" (expand* finseq_appl add_first insert?) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 4)) (("2" (expand* SP? add_first insert? finseq_appl) (("2" (inst -1 1) (("1" (assert) nil nil) ("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -3 -4 2 3 5) (("3" (expand PP? -1) (("3" (prop) (("1" (hide -2) (("1" (expand* add_first insert?) (("1" (assert) nil nil)) nil)) nil) ("2" (inst -1 1 0) (("1" (assert) (("1" (hide -2) (("1" (expand* add_first insert? finseq_appl) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand* add_first insert?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 2 4) (("2" (expand* SP? finseq_appl) (("2" (case "rest(x)`length=0") (("1" (hide -2 -3 2) (("1" (grind) nil nil)) nil) ("2" (skeep 2) (("2" (rewrite replace_preserv_parallel_pos) (("1" (hide -1 3) (("1" (inst -1 "i+2") (("1" (expand* add_first insert? finseq_appl rest ^ min) (("1" (lift-if) (("1" (prop) (("1" (expand empty_seq 1) (("1" (propax) nil nil)) nil) ("2" (expand empty_seq 1) (("2" (propax) nil nil)) nil) ("3" (expand empty_seq 1) (("3" (propax) nil nil)) nil) ("4" (expand empty_seq 1) (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred i) (("2" (expand* add_first insert?) (("2" (lemma length_rest[position]) (("2" (inst -1 x) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (inst -1 1) (("1" (expand* add_first insert? finseq_appl) nil nil) ("2" (hide-all-but 1) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -2 3) (("3" (expand* PP? finseq_appl) (("3" (prop) (("1" (expand* add_first insert?) (("1" (assert) nil nil)) nil) ("2" (inst -1 1 "i+2") (("1" (assert) (("1" (expand* add_first insert? finseq_appl rest ^ min) (("1" (expand empty_seq 3) (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand* add_first insert?) (("2" (typepred i) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand* add_first insert?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 2 4) (("2" (case "rest(x)`length=0") (("1" (hide -2 2) (("1" (grind) nil nil)) nil) ("2" (skeep 2) (("2" (expand* PP? finseq_appl) (("2" (prop) (("1" (expand* add_first insert?) (("1" (assert) nil nil)) nil) ("2" (inst -1 "i+2" 0) (("1" (assert) (("1" (hide 1) (("1" (expand* add_first insert? finseq_appl rest ^ min) (("1" (expand empty_seq 1) (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2 4) (("3" (typepred i) (("3" (expand* add_first insert? rest ^ min empty_seq) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite rest_of_PP_is_PP) (("3" (case "rest(add_first(p,x))=x") (("1" (replace -1 1 rl) (("1" (rewrite rest_of_PP_is_PP) nil nil)) nil) ("2" (rewrite rest_add_first) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (expand* rest ^ min empty_seq) (("3" (lift-if) (("3" (lift-if) (("3" (assert) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand SPP? -1) (("2" (flatten) (("2" (hide-all-but (-2 1 2)) (("2" (expand* SP? finseq_appl) (("2" (inst -1 1) (("1" (expand* add_first insert? finseq_appl) nil nil) ("2" (hide 2) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide 2) (("2" (case "fsp=rest(add_first(p,fsp))") (("1" (replace -1 1) (("1" (expand SPP?) (("1" (rewrite rest_of_PP_is_PP) (("1" (rewrite rest_of_SP_is_SP) nil nil)) nil)) nil)) nil) ("2" (rewrite rest_add_first) nil nil)) nil)) nil)) nil)) nil) ((rest_of_SP_is_SP formula-decl nil positions nil) (SP? const-decl "bool" positions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (p skolem-const-decl "position[variable, symbol, arity]" orthogonality_basis nil) (x skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (insert? const-decl "finseq" seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length_rest formula-decl nil seq_extras structures) (rest_of_PP_is_PP formula-decl nil positions nil) (rest_add_first formula-decl nil seq_extras structures) (i skolem-const-decl "below[length(rest(x))]" orthogonality_basis nil) (parallel const-decl "bool" positions nil) (<= const-decl "bool" positions nil) (O const-decl "finseq" finite_sequences nil) (SP type-eq-decl nil positions nil) (add_first_parallel_pos_to_SP_is_SP formula-decl nil positions nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (i skolem-const-decl "below[length(rest[position[variable, symbol, arity]](x))]" orthogonality_basis nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (^ const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (add_first_parallel_pos_to_PP_is_PP formula-decl nil positions nil) (PP? const-decl "bool" positions nil) (PP type-eq-decl nil positions nil) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (t skolem-const-decl "term" orthogonality_basis nil) (fst skolem-const-decl "finseq[term]" orthogonality_basis nil) (rest const-decl "finseq" seq_extras structures) (replace_par_pos def-decl "term" orthogonality_basis nil) (SPP type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (SPP? const-decl "bool" positions nil) (add_first const-decl "finseq" seq_extras structures) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (replace_par_pos_preservs_PP 0 (replace_par_pos_preservs_PP-1 nil 3522709547 ("" (measure-induct "fsp`length" "fsp") (("" (skeep) (("" (skeep) (("" (skeep) (("" (expand finseq_appl) (("" (case "x`length = 0") (("1" (hide -2) (("1" (expand replace_par_pos 1) (("1" (assert) nil nil)) nil)) nil) ("2" (case "x`length = 1") (("1" (lemma "length_rest_0[position]") (("1" (inst?) (("1" (assert) (("1" (expand replace_par_pos 2) (("1" (expand replace_par_pos 2) (("1" (expand finseq_appl) (("1" (hide -3) (("1" (typepred "i") (("1" (replace -3 -1) (("1" (case-replace "i=0") (("1" (expand "SPP?") (("1" (flatten) (("1" (expand "SP?") (("1" (inst -6 "0") (("1" (expand finseq_appl) (("1" (rewrite "replace_preserv_pos") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand replace_par_pos 3) (("2" (assert) (("2" (expand finseq_appl) (("2" (case-replace "i=0") (("1" (lemma "replace_par_pos_preservs_pos") (("1" (inst -1 "rest(x)" "rest(fst)" "x`seq(0)" "replaceTerm(t, fst`seq(0), x`seq(0))") (("1" (assert) (("1" (hide (-2 4)) (("1" (lemma "seq_first_rest[position]") (("1" (inst?) (("1" (assert) (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (expand "SPP?") (("1" (prop) (("1" (expand "SP?") (("1" (skosimp*) (("1" (expand "finseq_appl") (("1" (case-replace "i!1 = 0") (("1" (inst -4 "i!1") (("1" (rewrite "replace_preserv_pos") nil nil)) nil) ("2" (copy -3) (("2" (inst -1 "0") (("2" (inst -4 "i!1") (("2" (expand "PP?") (("2" (inst -3 "0" "i!1") (("2" (assert) (("2" (expand "finseq_appl") (("2" (rewrite "replace_preserv_parallel_pos") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "rest(x)`length = 0") (("1" (hide-all-but (-1 2 3)) (("1" (lemma "length_rest_0[position]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x)") (("2" (prop) (("1" (inst -1 "rest(fst)" "replaceTerm(t, fst`seq(0), x`seq(0))") (("1" (prop) (("1" (inst -1 "i - 1") (("1" (lemma "rest_pos[position]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "i-1") (("1" (expand finseq_appl) (("1" (replaces -1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 6) (("2" (expand "SPP?") (("2" (prop) (("1" (rewrite "rest_of_PP_is_PP") nil nil) ("2" (expand "SP?") (("2" (expand* "SP?" "finseq_appl") (("2" (skosimp*) (("2" (copy -2) (("2" (inst -1 "0") (("2" (inst -3 "i!1 + 1") (("1" (expand* "PP?" "finseq_appl") (("1" (inst -2 "0" "i!1 + 1") (("1" (assert) (("1" (lemma "rest_pos[position]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "i!1") (("1" (expand "finseq_appl") (("1" (replaces -1) (("1" (rewrite "replace_preserv_parallel_pos") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 -3 1)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rest_pos formula-decl nil seq_extras structures) (i skolem-const-decl "below[x`length]" orthogonality_basis nil) (x skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (TRUE const-decl "bool" booleans nil) (i!1 skolem-const-decl "below[length(rest(x))]" orthogonality_basis nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (PP type-eq-decl nil positions nil) (rest_of_PP_is_PP formula-decl nil positions nil) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (seq_first_rest formula-decl nil seq_extras structures) (PP? const-decl "bool" positions nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (int_minus_int_is_int application-judgement "int" integers nil) (first const-decl "T" seq_extras structures) (rest const-decl "finseq" seq_extras structures) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (length_rest_0 formula-decl nil seq_extras structures) (SP? const-decl "bool" positions nil) (replace_preserv_pos formula-decl nil replacement nil) (NOT const-decl "[bool -> bool]" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (SPP type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (SPP? const-decl "bool" positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (replace_par_pos_preservs_PP_o_PP_TCC1 0 (replace_par_pos_preservs_PP_o_PP_TCC1-1 nil 3522718320 ("" (skosimp) (("" (skosimp) (("" (expand* o SPP? SP? PP? finseq_appl) (("" (assert) (("" (lift-if) (("" (assert) (("" (prop) (("1" (skeep) (("1" (typepred i) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (typepred i) (("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (typepred i) (("3" (assert) nil nil)) nil)) nil) ("4" (skeep) (("4" (inst -3 i) (("4" (assert) nil nil)) nil)) nil) ("5" (skeep) (("5" (inst -1 i j) (("5" (assert) nil nil)) nil)) nil) ("6" (skeep) (("6" (inst -2 i) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (SP? const-decl "bool" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (PP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (replace_par_pos_preservs_PP_o_PP subtype "orthogonality_basis.fsp" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(orthogonality_basis.t)"))) (replace_par_pos_preservs_PP_o_PP 0 (replace_par_pos_preservs_PP_o_PP-1 nil 3522718729 ("" (measure-induct "fsp`length" "fsp") (("1" (skeep) (("1" (skeep) (("1" (skeep) (("1" (expand "finseq_appl") (("1" (case "length(x) = 0") (("1" (hide -2) (("1" (expand "replace_par_pos") (("1" (assert) (("1" (expand* "SPP?" "SP?" "finseq_appl") (("1" (flatten) (("1" (inst -3 "x`length + i") (("1" (expand "o") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "replace_par_pos" 2) (("2" (assert) (("2" (expand "finseq_appl") (("2" (case "x`length = 1") (("1" (lemma "length_rest_0[position]") (("1" (inst?) (("1" (assert) (("1" (hide -3) (("1" (expand replace_par_pos 2) (("1" (expand* "SPP?" "PP?" "SP?" "finseq_appl") (("1" (prop) (("1" (grind) nil nil) ("2" (inst -1 "0" "i + x`length") (("1" (assert) (("1" (copy -4) (("1" (inst -1 "0") (("1" (inst -5 "i + x`length") (("1" (hide 1) (("1" (expand "o") (("1" (rewrite "replace_preserv_parallel_pos") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x)") (("2" (prop) (("1" (inst -1 "fsq" "rest(fst)" "replaceTerm(t, fst`seq(0), x`seq(0))") (("1" (prop) (("1" (inst -1 "i") nil nil) ("2" (hide 4) (("2" (expand "SPP?") (("2" (flatten) (("2" (lemma "rest_of_PP_is_PP") (("2" (inst -1 "x o fsq") (("2" (lemma "rest_of_SP_is_SP") (("2" (inst -1 "t" "x o fsq") (("2" (prop) (("1" (hide (-1 -3 -4)) (("1" (lemma "rest_compo[position]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand* "PP?" "SP?" "finseq_appl") (("2" (prop) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (case "i!1 < x`length") (("1" (case "fsq`length = 0") (("1" (rewrite "empty_0") (("1" (lemma "seq_o_empty[position]") (("1" (inst -1 "rest(x)") (("1" (replace -2) (("1" (lemma "rest_compo[position]") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (replaces -1) (("1" (lemma "seq_o_empty[position]") (("1" (inst -1 "x") (("1" (replaces -1) (("1" (inst -3 "0" "i!1 + 1") (("1" (assert) (("1" (inst -5 "i!1") (("1" (inst -6 "0") (("1" (case "i!1 = x`length -1") (("1" (grind) nil nil) ("2" (lemma "rest_pos[position]") (("2" (inst -1 "x") (("2" (assert) (("2" (inst -1 "i!1") (("2" (expand "finseq_appl") (("2" (replaces -1) (("2" (rewrite "replace_preserv_parallel_pos") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "i!1") (("1" (lemma "rest_compo[position]") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (inst -2 "0" "i!1 + 1") (("1" (assert) (("1" (lemma "rest_pos[position]") (("1" (inst -1 "x o fsq") (("1" (assert) (("1" (inst -1 "i!1") (("1" (expand "finseq_appl") (("1" (replaces -1) (("1" (lemma "rest_compo[position]") (("1" (inst?) (("1" (reveal -5) (("1" (replaces -1) (("1" (expand "o" -2 1) (("1" (inst -5 "0") (("1" (expand "o" -5) (("1" (rewrite "replace_preserv_parallel_pos") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 2 5 6)) (("2" (expand "o") (("2" (expand "rest") (("2" (expand "^") (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "0" "i!1 + 1") (("1" (assert) (("1" (expand "o" -1 1) (("1" (lemma "rest_pos[position]") (("1" (inst -1 "x o fsq") (("1" (prop) (("1" (inst -1 "i!1") (("1" (expand "finseq_appl") (("1" (lemma "rest_compo[position]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (skosimp*) (("4" (inst -1 "0" "i!1 + 1") (("1" (assert) (("1" (inst -3 "i!1") (("1" (inst -4 "0") (("1" (hide -2) (("1" (expand "o" -1 1) (("1" (expand "o" -3) (("1" (lemma "rest_pos[position]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "i!1") (("1" (expand "finseq_appl") (("1" (lemma "rest_compo[position]") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (replaces -1) (("1" (rewrite "replace_preserv_parallel_pos") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 4)) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide (-1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (expand* "SPP?" "SP?" "PP?" "finseq_appl") (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (skosimp*) (("2" (inst -2 "i!1 + fsp`length") (("1" (expand "o") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (inst -1 "i!1" "j!1") (("1" (assert) (("1" (expand "o") (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (inst -2 "i!1") (("1" (expand "o" -2) (("1" (propax) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((fsp skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (i!1 skolem-const-decl "below[length(fsp)]" orthogonality_basis nil) (fsq skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (i!1 skolem-const-decl "below[fsp`length]" orthogonality_basis nil) (j!1 skolem-const-decl "below[fsp`length]" orthogonality_basis nil) (i!1 skolem-const-decl "below[length(fsp)]" orthogonality_basis nil) (SP? const-decl "bool" positions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (x skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (fsq skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (i skolem-const-decl "below[fsq`length]" orthogonality_basis nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (PP? const-decl "bool" positions nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (length_rest_0 formula-decl nil seq_extras structures) (rest_of_PP_is_PP formula-decl nil positions nil) (rest_of_SP_is_SP formula-decl nil positions nil) (rest_compo formula-decl nil seq_extras structures) (i!1 skolem-const-decl "below[length(rest(x) o fsq)]" orthogonality_basis nil) (^ const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_0 formula-decl nil seq_extras structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (rest_pos formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (empty_seq const-decl "finseq" finite_sequences nil) (seq_o_empty formula-decl nil seq_extras structures) (<= const-decl "bool" positions nil) (parallel const-decl "bool" positions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (i!1 skolem-const-decl "below[length(rest(x) o fsq)]" orthogonality_basis nil) (SP type-eq-decl nil positions nil) (t skolem-const-decl "term" orthogonality_basis nil) (PP type-eq-decl nil positions nil) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (rest const-decl "finseq" seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (SPP type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (SPP? const-decl "bool" positions nil) (O const-decl "finseq" finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (replace_par_pos_equivalence_TCC1 0 (replace_par_pos_equivalence_TCC1-1 nil 3491905313 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (replace_par_pos_equivalence subtype "0" "below[length(fst)]"))) (replace_par_pos_equivalence_TCC2 0 (replace_par_pos_equivalence_TCC2-1 nil 3491905313 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (/= const-decl "boolean" notequal nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (replace_par_pos_equivalence subtype "finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_basis.fsp)(0)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(orthogonality_basis.s)"))) (replace_par_pos_equivalence_TCC3 0 (replace_par_pos_equivalence_TCC3-2 "" 3803915768 ("" (skosimp) (("" (expand finseq_appl) (("" (expand SPP?) (("" (flatten) (("" (rewrite rest_of_PP_is_PP) (("" (rewrite rest_of_SP_is_SP) (("" (hide 3) (("" (expand* SP? finseq_appl) (("" (skosimp) (("" (case "i!1=0") (("1" (replaces -1) (("1" (rewrite replace_preserv_pos) (("1" (inst - 0) nil nil)) nil)) nil) ("2" (expand* PP? finseq_appl) (("2" (assert) (("2" (inst -2 0 i!1) (("2" (assert) (("2" (rewrite replace_preserv_parallel_pos) (("1" (inst - i!1) nil nil) ("2" (inst - 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (replace_par_pos_equivalence subtype "seq_extras[position[variable, symbol, arity]].rest(orthogonality_basis.fsp)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(replacement[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].replaceTerm(orthogonality_basis.s, finite_sequences[term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].term].finseq_appl(orthogonality_basis.fst)(0), finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_basis.fsp)(0)))")) (replace_par_pos_equivalence_TCC3-1 nil 3491905313 ("" (skosimp) (("" (expand finseq_appl) (("" (expand SPP?) (("" (flatten) (("" (rewrite rest_of_PP_is_PP) (("" (rewrite rest_of_SP_is_SP) (("" (hide 3) (("" (expand* SP? finseq_appl) (("" (skosimp) (("" (case "i!1=0") (("1" (replaces -1) (("1" (rewrite replace_preserv_pos) (("1" (inst -2 0) nil nil)) nil)) nil) ("2" (expand* PP? finseq_appl) (("2" (assert) (("2" (inst -1 0 i!1) (("2" (assert) (("2" (rewrite replace_preserv_parallel_pos) (("1" (inst -2 i!1) nil nil) ("2" (inst -2 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (rest_of_SP_is_SP formula-decl nil positions nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (SP? const-decl "bool" positions nil) (SP type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (replace_preserv_pos formula-decl nil replacement nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (PP type-eq-decl nil positions nil) (PP? const-decl "bool" positions nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (rest_of_PP_is_PP formula-decl nil positions nil) (SPP? const-decl "bool" positions nil)) nil (replace_par_pos_equivalence subtype "seq_extras[position[variable, symbol, arity]].rest(orthogonality_basis.fsp)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(replacement[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].replaceTerm(orthogonality_basis.s, finite_sequences[term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].term].finseq_appl(orthogonality_basis.fst)(0), finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_basis.fsp)(0)))"))) (replace_par_pos_equivalence_TCC4 0 (replace_par_pos_equivalence_TCC4-1 nil 3491905313 ("" (skosimp) (("" (grind) nil nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (rest const-decl "finseq" seq_extras structures) (term type-decl nil term_adt nil) (^ const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (SPP? const-decl "bool" positions nil) (SP? const-decl "bool" positions nil) (PP? const-decl "bool" positions nil) (parallel const-decl "bool" positions nil) (<= const-decl "bool" positions nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (O const-decl "finseq" finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (/= const-decl "boolean" notequal nil)) nil (replace_par_pos_equivalence subtype "seq_extras[term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].term].rest(orthogonality_basis.fst)" "{fst_1 | fst_1`length = seq_extras[position[variable, symbol, arity]].rest(orthogonality_basis.fsp)`length}"))) (replace_par_pos_equivalence_TCC5 0 (replace_par_pos_equivalence_TCC5-1 nil 3491905313 ("" (skosimp*) (("" (grind) nil nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rest const-decl "finseq" seq_extras structures) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (^ const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (SPP? const-decl "bool" positions nil) (SP? const-decl "bool" positions nil) (PP? const-decl "bool" positions nil) (parallel const-decl "bool" positions nil) (<= const-decl "bool" positions nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (O const-decl "finseq" finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (/= const-decl "boolean" notequal nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (finseq type-eq-decl nil finite_sequences nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil (replace_par_pos_equivalence subtype "seq_extras[position[variable, symbol, arity]].rest(orthogonality_basis.fsp)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(orthogonality_basis.s)"))) (replace_par_pos_equivalence_TCC6 0 (replace_par_pos_equivalence_TCC6-1 nil 3491905313 ("" (skosimp) (("" (expand finseq_appl) (("" (rewrite replace_par_pos_preservs_pos) (("1" (case "first(fsp!1) = fsp!1`seq(0)") (("1" (replace -1 1 rl) (("1" (lemma seq_first_rest[position]) (("1" (inst -1 fsp!1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide -2 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (^ const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (/= const-decl "boolean" notequal nil) (= const-decl "[T, T -> boolean]" equalities nil) (seq_first_rest formula-decl nil seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (term type-decl nil term_adt nil) (rest const-decl "finseq" seq_extras structures) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil)) nil (replace_par_pos_equivalence subtype "finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_basis.fsp)(0)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(orthogonality_basis.replace_par_pos(orthogonality_basis.s, seq_extras[position[variable, symbol, arity]].rest(orthogonality_basis.fsp), seq_extras[term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].term].rest(orthogonality_basis.fst)))"))) (replace_par_pos_equivalence 0 (replace_par_pos_equivalence-1 nil 3491905313 ("" (expand finseq_appl) (("" (measure-induct "fsp`length" "fsp") (("1" (skeep) (("1" (skeep) (("1" (inst -1 "rest(x)") (("1" (rewrite length_rest) (("1" (inst -1 "rest(fst)" "replaceTerm(s,fst`seq(0),x`seq(0))") (("1" (case "rest(x)`length=0") (("1" (expand replace_par_pos 2) (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil) ("2" (prop) (("1" (expand replace_par_pos 3 1) (("1" (lift-if) (("1" (prop) (("1" (expand replace_par_pos 2 2) (("1" (expand finseq_appl) (("1" (lift-if) (("1" (prop) (("1" (replaces -1) (("1" (reveal (-2 -3)) (("1" (inst -1 "rest(fst)" "replaceTerm(s, fst`seq(0), x`seq(0))") (("1" (inst -2 "delete(x, 1)") (("1" (prop) (("1" (inst -1 "delete(fst,1)" "replaceTerm(s,rest(fst)`seq(0),rest(x)`seq(0))") (("1" (prop) (("1" (replace -2 2 rl) (("1" (hide -2 1 4) (("1" (name-replace "REPL_REST" "replaceTerm(s,rest(fst)`seq(0),rest(x)`seq(0))") (("1" (lemma delete_rest[position]) (("1" (copy -1) (("1" (inst -2 x 1) (("1" (assert) (("1" (replace -2 -3 rl) (("1" (inst -1 "rest(x)" 0) (("1" (replaces -1) (("1" (hide -1) (("1" (lemma delete_rest[term]) (("1" (copy -1) (("1" (inst -2 fst 1) (("1" (assert) (("1" (replace -2 -3 rl) (("1" (inst -1 "rest(fst)" 0) (("1" (replaces -1) (("1" (hide -1) (("1" (expand delete -1) (("1" (expand finseq_appl) (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (expand REPL_REST) (("1" (expand SPP?) (("1" (flatten) (("1" (rewrite replace_commutativity) (("1" (hide-all-but (-2 1)) (("1" (expand SP?) (("1" (inst -1 0) (("1" (expand finseq_appl) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 3 4)) (("2" (lemma rest_pos[position]) (("2" (inst -1 x) (("2" (assert) (("2" (inst -1 0) (("1" (expand finseq_appl) (("1" (replace -1 1 rl) (("1" (expand SP? -2) (("1" (inst -2 1) (("1" (expand finseq_appl) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand rest 3) (("2" (expand* ^ min empty_seq) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2 -3 -4 2) (("3" (lemma rest_pos[position]) (("3" (inst -1 x) (("3" (assert) (("3" (inst -1 0) (("1" (expand PP?) (("1" (prop) (("1" (hide-all-but (-1 2)) (("1" (expand* rest ^ min empty_seq) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 0 1) (("1" (assert) (("1" (expand finseq_appl) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 2 6)) (("2" (expand SPP?) (("2" (flatten) (("2" (split) (("1" (hide -2) (("1" (rewrite delete_of_PP_is_PP) nil nil)) nil) ("2" (rewrite delete_of_SP_is_SP) (("2" (hide -1 2) (("2" (expand SP?) (("2" (expand finseq_appl) (("2" (skeep) (("2" (inst -1 i) (("2" (rewrite replace_preserv_parallel_pos) (("1" (hide -1 2) (("1" (lemma rest_pos[position]) (("1" (inst -1 x) (("1" (assert) (("1" (inst -1 0) (("1" (reveal -4) (("1" (inst -1 1) (("1" (expand finseq_appl) (("1" (assert) nil nil)) nil) ("2" (hide -1 2 4) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 4) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (lemma rest_pos[position]) (("2" (inst -1 x) (("2" (assert) (("2" (inst -1 0) (("1" (reveal -5) (("1" (expand PP?) (("1" (prop) (("1" (hide -2 1 3) (("1" (expand* rest ^ min empty_seq) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand finseq_appl) (("2" (inst -1 1 i) (("2" (prop) (("1" (assert) nil nil) ("2" (typepred i) (("2" (reveal 1) (("2" (replace -2 1 rl) (("2" (replace -3) (("2" (rewrite replace_preserv_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 4) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (expand* delete rest ^ min empty_seq) (("3" (lift-if) (("3" (prop) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (-3 1)) (("4" (expand delete) (("4" (lift-if) (("4" (lift-if) (("4" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 2)) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 5)) (("2" (expand delete) (("2" (lift-if) (("2" (prop) (("1" (hide 1) (("1" (expand* rest ^ min empty_seq) (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil)) nil) ("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -3 3 4) (("3" (expand SPP?) (("3" (flatten) (("3" (rewrite rest_of_PP_is_PP) (("3" (expand SP?) (("3" (skeep) (("3" (inst -2 "i+1") (("1" (lemma rest_pos[position]) (("1" (inst -1 x) (("1" (assert) (("1" (inst -1 i) (("1" (expand finseq_appl) (("1" (rewrite replace_preserv_parallel_pos) (("1" (reveal -3) (("1" (inst -1 0) (("1" (expand finseq_appl) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand PP?) (("2" (prop) (("1" (hide-all-but (-1 3)) (("1" (expand* rest ^ min empty_seq) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand finseq_appl) (("2" (inst -1 0 "i+1") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred i) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred i) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred i) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (1 6)) (("4" (expand delete) (("4" (lift-if) (("4" (prop) (("1" (expand* rest ^ min empty_seq) (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-3 1)) (("5" (expand* rest ^ min empty_seq) (("5" (lift-if) (("5" (lift-if) (("5" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but (1 6)) (("6" (expand delete) (("6" (lift-if) (("6" (prop) (("1" (expand* rest ^ min empty_seq) (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand SPP?) (("2" (flatten) (("2" (rewrite rest_of_PP_is_PP) (("2" (expand SP?) (("2" (skeep) (("2" (rewrite replace_preserv_parallel_pos) (("1" (lemma rest_pos[position]) (("1" (inst -1 x) (("1" (assert) (("1" (inst -1 i) (("1" (inst -3 "i+1") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred i) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred i) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 0) (("2" (expand finseq_appl) (("2" (propax) nil nil)) nil)) nil) ("3" (lemma rest_pos[position]) (("3" (inst -1 x) (("3" (assert) (("3" (inst -1 i) (("1" (expand PP?) (("1" (prop) (("1" (hide-all-but (-1 3)) (("1" (expand* rest ^ min empty_seq) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 0 "i+1") (("1" (assert) (("1" (expand finseq_appl) (("1" (replace -2 2 rl) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred i) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred i) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (expand* rest ^ min empty_seq) (("3" (lift-if) (("3" (lift-if) (("3" (assert) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (rewrite replace_par_pos_preservs_pos) (("1" (hide -2 -3 3) (("1" (lemma seq_first_rest[position]) (("1" (inst -1 fsp) (("1" (assert) (("1" (expand* first finseq_appl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand SPP?) (("3" (rewrite rest_of_PP_is_PP) (("3" (rewrite rest_of_SP_is_SP) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (hide-all-but (-2 2)) (("4" (expand* rest ^ min empty_seq) (("4" (lift-if) (("4" (lift-if) (("4" (assert) (("4" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (case "rest(fsp)`length=0") (("1" (hide-all-but (-1 2)) (("1" (expand* SPP? PP? SP? finseq_appl) (("1" (split) (("1" (propax) nil nil) ("2" (assert) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (rewrite rest_of_PP_is_PP) (("2" (skeep 3) (("2" (rewrite replace_preserv_parallel_pos) (("1" (hide -1 4) (("1" (inst -1 "i+1") (("1" (expand* rest ^ min) (("1" (expand empty_seq 2) (("1" (lift-if) (("1" (assert) (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (typepred i) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 0) nil nil) ("3" (hide -2 4) (("3" (expand* PP? finseq_appl) (("3" (prop) (("1" (hide 1 3) (("1" (expand* rest ^ min empty_seq) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -1 0 "i+1") (("1" (assert) (("1" (expand* rest ^ min) nil nil)) nil) ("2" (hide 2 3 4) (("2" (typepred i) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (expand* SPP? SP?) (("6" (expand finseq_appl) (("6" (flatten) (("6" (inst -2 0) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (assert) nil nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (assert) nil nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (/= const-decl "boolean" notequal nil) (SPP? const-decl "bool" positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (rest const-decl "finseq" seq_extras structures) (replaceTerm def-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (SPP type-eq-decl nil positions nil) (length_rest formula-decl nil seq_extras structures) (i skolem-const-decl "below[length(rest(x))]" orthogonality_basis nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (x skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (delete const-decl "finseq" seq_extras structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "below[length(rest(x))]" orthogonality_basis nil) (rest_of_PP_is_PP formula-decl nil positions nil) (fst skolem-const-decl "finseq[term]" orthogonality_basis nil) (SP type-eq-decl nil positions nil) (delete_of_SP_is_SP formula-decl nil positions nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (NOT const-decl "[bool -> bool]" booleans nil) (replace_preserv_pos formula-decl nil replacement nil) (delete_of_PP_is_PP formula-decl nil positions nil) (PP type-eq-decl nil positions nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (replace_commutativity formula-decl nil replacement nil) (SP? const-decl "bool" positions nil) (rest_pos formula-decl nil seq_extras structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (empty_seq const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (PP? const-decl "bool" positions nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (REPL_REST skolem-const-decl "term[variable, symbol, arity]" orthogonality_basis nil) (delete_rest formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (first const-decl "T" seq_extras structures) (seq_first_rest formula-decl nil seq_extras structures) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (rest_of_SP_is_SP formula-decl nil positions nil) (i skolem-const-decl "below[length(rest[position[variable, symbol, arity]](fsp))]" orthogonality_basis nil) (fsp skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak)) (replace_par_pos_equivalence1_TCC1 0 (replace_par_pos_equivalence1_TCC1-1 nil 3549809212 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (replace_par_pos_equivalence1 subtype "orthogonality_basis.n" "below[length(fst)]"))) (replace_par_pos_equivalence1_TCC2 0 (replace_par_pos_equivalence1_TCC2-1 nil 3549809212 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (/= const-decl "boolean" notequal nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (replace_par_pos_equivalence1 subtype "finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_basis.fsp)(orthogonality_basis.n)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(orthogonality_basis.s)"))) (replace_par_pos_equivalence1_TCC3 0 (replace_par_pos_equivalence1_TCC3-2 "" 3803915912 ("" (skosimp) (("" (expand finseq_appl) (("" (expand SPP?) (("" (flatten) (("" (rewrite delete_of_PP_is_PP) (("" (expand* delete finseq_appl) (("" (assert) (("" (expand* SP? finseq_appl) (("" (skosimp) (("" (prop) (("1" (inst-cp - i!1) (("1" (inst - n!1) (("1" (rewrite replace_preserv_parallel_pos) (("1" (expand* PP? finseq_appl) (("1" (inst - n!1 i!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst-cp - 1+i!1) (("2" (inst - n!1) (("2" (rewrite replace_preserv_parallel_pos) (("2" (expand* PP? finseq_appl) (("2" (inst - n!1 1+i!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (replace_par_pos_equivalence1 subtype "seq_extras[position[variable, symbol, arity]].delete(orthogonality_basis.fsp, orthogonality_basis.n)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(replacement[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].replaceTerm(orthogonality_basis.s, finite_sequences[term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].term].finseq_appl(orthogonality_basis.fst)(orthogonality_basis.n), finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_basis.fsp)(orthogonality_basis.n)))")) (replace_par_pos_equivalence1_TCC3-1 nil 3549809212 ("" (skosimp) (("" (expand finseq_appl) (("" (expand SPP?) (("" (flatten) (("" (rewrite delete_of_PP_is_PP) (("" (expand* delete finseq_appl) (("" (assert) (("" (expand* SP? finseq_appl) (("" (skosimp) (("" (prop) (("1" (inst-cp -3 i!1) (("1" (inst -3 n!1) (("1" (rewrite replace_preserv_parallel_pos) (("1" (expand* PP? finseq_appl) (("1" (inst -2 n!1 i!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst-cp -2 1+i!1) (("2" (inst -2 n!1) (("2" (rewrite replace_preserv_parallel_pos) (("2" (expand* PP? finseq_appl) (("2" (inst -1 n!1 1+i!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (delete const-decl "finseq" seq_extras structures) (SP? const-decl "bool" positions nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (term type-decl nil term_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (< const-decl "bool" reals nil) (PP type-eq-decl nil positions nil) (PP? const-decl "bool" positions nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (delete_of_PP_is_PP formula-decl nil positions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (SPP? const-decl "bool" positions nil)) nil (replace_par_pos_equivalence1 subtype "seq_extras[position[variable, symbol, arity]].delete(orthogonality_basis.fsp, orthogonality_basis.n)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(replacement[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].replaceTerm(orthogonality_basis.s, finite_sequences[term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].term].finseq_appl(orthogonality_basis.fst)(orthogonality_basis.n), finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_basis.fsp)(orthogonality_basis.n)))"))) (replace_par_pos_equivalence1_TCC4 0 (replace_par_pos_equivalence1_TCC4-1 nil 3549809212 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (delete const-decl "finseq" seq_extras structures) (term type-decl nil term_adt nil) (/= const-decl "boolean" notequal nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (replace_par_pos_equivalence1 subtype "seq_extras[term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].term].delete(orthogonality_basis.fst, orthogonality_basis.n)" "{fst_1 | fst_1`length = seq_extras[position[variable, symbol, arity]].delete(orthogonality_basis.fsp, orthogonality_basis.n)`length}"))) (replace_par_pos_equivalence1 0 (replace_par_pos_equivalence1-1 nil 3549809212 ("" (auto-rewrite finseq_appl) (("" (measure-induct "fsp`length" fsp) (("1" (skeep) (("1" (skeep) (("1" (assert) (("1" (expand replace_par_pos 2 2) (("1" (assert) (("1" (case n=0) (("1" (case "delete(x, n)=rest(x) & delete(fst, n)=rest(fst)") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (expand rest 1) (("2" (expand delete 1) (("2" (expand* ^ min empty_seq) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (decompose-equality) nil nil) ("3" (lift-if) (("3" (assert) (("3" (decompose-equality) (("3" (skosimp) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 1 2)) (("4" (assert) nil nil)) nil) ("5" (decompose-equality) nil nil) ("6" (lift-if) (("6" (assert) (("6" (decompose-equality) (("6" (skosimp) nil nil)) nil)) nil)) nil) ("7" (decompose-equality) (("1" (skeep) (("1" (expand min) (("1" (propax) nil nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (typepred x_1) (("2" (expand min) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand min) (("3" (assert) nil nil)) nil)) nil) ("8" (decompose-equality) (("1" (skosimp) (("1" (expand min) (("1" (propax) nil nil)) nil)) nil) ("2" (skosimp) (("2" (typepred x!1) (("2" (expand min) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand min) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x)") (("2" (rewrite length_rest) (("2" (inst -1 "rest(fst)" "n-1" "replaceTerm(s, fst`seq(0), x`seq(0))") (("1" (prop) (("1" (expand replace_par_pos 3 1) (("1" (expand delete 3 1) (("1" (assert) (("1" (rewrite replace_commutativity 3) (("1" (case "rest(x)`seq(n - 1)=x`seq(n) & rest(fst)`seq(n - 1)=fst`seq(n)") (("1" (case "fst`seq(0)=delete(fst, n)`seq(0) & x`seq(0)=delete(x, n)`seq(0)") (("1" (case "delete(rest(x), n - 1)=rest(delete(x, n)) & delete(rest(fst), n - 1)=rest(delete(fst, n))") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide (-1 -2 -3 -4 4)) (("2" (expand delete 1) (("2" (expand rest 1) (("2" (expand* ^ min) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (decompose-equality) (("1" (expand empty_seq) (("1" (assert) nil nil)) nil) ("2" (decompose-equality) (("1" (typepred x!1) (("1" (expand rest -1) (("1" (expand* ^ min empty_seq) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred i) (("2" (expand rest -1) (("2" (expand* ^ min empty_seq) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand rest 1) (("3" (expand* ^ min empty_seq) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (expand empty_seq) (("3" (skeep) (("3" (expand rest -1) (("3" (expand* ^ min empty_seq) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (typepred i) (("4" (expand rest -1) (("4" (expand* ^ min empty_seq) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (expand rest 1) (("5" (expand* ^ min empty_seq) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (decompose-equality) (("1" (expand empty_seq) (("1" (assert) nil nil)) nil) ("2" (decompose-equality) (("1" (typepred x!1) (("1" (expand rest -1) (("1" (expand* ^ min empty_seq) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred i) (("2" (expand rest -1) (("2" (expand* ^ min empty_seq) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand rest 1) (("3" (expand* ^ min empty_seq) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (expand empty_seq) (("3" (skosimp) (("3" (expand rest -1) (("3" (expand* ^ min empty_seq) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (typepred i) (("4" (expand rest -1) (("4" (expand* ^ min empty_seq) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (expand rest 1) (("5" (expand* ^ min empty_seq) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (decompose-equality) (("1" (expand empty_seq) (("1" (assert) nil nil)) nil) ("2" (decompose-equality) (("1" (typepred x!1) (("1" (expand rest -1) (("1" (expand* ^ min empty_seq) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred i) (("2" (expand rest -1) (("2" (expand* ^ min empty_seq) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand rest 1) (("3" (expand* ^ min empty_seq) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (expand empty_seq) (("3" (skosimp) (("3" (expand rest -1) (("3" (expand* ^ min empty_seq) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (typepred i) (("4" (expand rest -1) (("4" (expand* ^ min empty_seq) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (expand rest 1) (("5" (expand* ^ min empty_seq) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (assert) (("4" (decompose-equality) (("1" (expand empty_seq) (("1" (assert) nil nil)) nil) ("2" (decompose-equality) (("1" (typepred x!1) (("1" (expand rest -1) (("1" (expand* ^ min empty_seq) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred i) (("2" (expand rest -1) (("2" (expand* ^ min empty_seq) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand rest 1) (("3" (expand* ^ min empty_seq) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (expand empty_seq) (("3" (skosimp) (("3" (expand rest -1) (("3" (expand* ^ min empty_seq) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (typepred i) (("4" (expand rest -1) (("4" (expand* ^ min empty_seq) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (expand rest 1) (("5" (expand* ^ min empty_seq) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (assert) (("5" (decompose-equality) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand min) (("2" (skeep) (("2" (expand rest 1) (("2" (expand* ^ min empty_seq) nil nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (typepred x!1) (("3" (expand min) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil) ("5" (expand min) (("5" (assert) nil nil)) nil) ("6" (skeep) (("6" (typepred i) (("6" (expand rest -1) (("6" (expand* ^ min empty_seq) (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (skeep) (("7" (typepred i) (("7" (expand rest -1) (("7" (expand* ^ min empty_seq) (("7" (assert) nil nil)) nil)) nil)) nil)) nil) ("8" (expand rest 1) (("8" (expand* ^ min empty_seq) (("8" (assert) nil nil)) nil)) nil)) nil)) nil) ("6" (assert) (("6" (decompose-equality) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand min) (("2" (skosimp) (("2" (expand rest 1) (("2" (expand* ^ min empty_seq) nil nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (typepred x!1) (("3" (expand min) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (skosimp) (("4" (assert) nil nil)) nil) ("5" (expand min) (("5" (assert) nil nil)) nil) ("6" (skeep) (("6" (typepred i) (("6" (expand rest -1) (("6" (expand* ^ min empty_seq) (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (skeep) (("7" (assert) nil nil)) nil) ("8" (expand rest 1) (("8" (expand* ^ min empty_seq) (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 -3 4)) (("2" (expand "delete") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand rest 1) (("2" (expand ^) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand* SPP? SP?) (("2" (flatten) (("2" (inst -3 n) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand delete 1) (("3" (expand* SPP? SP?) (("3" (flatten) (("3" (inst -3 0) nil nil)) nil)) nil)) nil) ("4" (expand delete 1) (("4" (expand* SPP? PP?) (("4" (flatten) (("4" (inst -2 n 0) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand SPP?) (("2" (flatten) (("2" (rewrite rest_of_PP_is_PP) (("2" (lemma rest_of_SP_is_SP) (("2" (inst -1 s x) (("2" (expand SP? (-1 1)) (("2" (assert) (("2" (skeep) (("2" (inst -1 i) (("2" (rewrite replace_preserv_parallel_pos) (("1" (expand SP?) (("1" (inst -3 0) (("1" (assert) nil nil)) nil)) nil) ("2" (expand PP?) (("2" (inst -2 0 1+i) (("1" (assert) (("1" (expand rest 1) (("1" (expand ^) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred i) (("2" (expand rest -1) (("2" (expand* ^ min empty_seq) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand rest -1) (("3" (expand* ^ min empty_seq) (("3" (assert) nil nil)) nil)) nil) ("4" (expand rest 1) (("4" (expand* ^ min empty_seq) (("4" (lift-if) (("4" (lift-if) (("4" (lift-if) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand rest 1) (("5" (expand* ^ min empty_seq) (("5" (lift-if) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (skeep) (("2" (expand delete) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand SPP?) (("3" (flatten) (("3" (rewrite delete_of_PP_is_PP) (("3" (lemma delete_of_SP_is_SP) (("3" (inst -1 s fsp n) (("3" (expand SP?) (("3" (assert) (("3" (skeep 2) (("3" (rewrite replace_preserv_parallel_pos) (("1" (inst -1 i) nil nil) ("2" (inst -3 n) nil nil) ("3" (expand PP?) (("3" (typepred i) (("3" (expand delete -1) (("3" (assert) (("3" (expand delete 1) (("3" (lift-if) (("3" (assert) (("3" (prop) (("1" (inst -4 n i) (("1" (assert) nil nil)) nil) ("2" (inst -3 n 1+i) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (expand* SPP? SP?) (("4" (flatten) (("4" (inst -2 n) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (/= const-decl "boolean" notequal nil) (SPP? const-decl "bool" positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (delete const-decl "finseq" seq_extras structures) (replaceTerm def-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (SPP type-eq-decl nil positions nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (^ const-decl "finseq" finite_sequences nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (<= const-decl "bool" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (fst skolem-const-decl "finseq[term]" orthogonality_basis nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (FALSE const-decl "bool" booleans nil) (epsilon const-decl "T" epsilons nil) (TRUE const-decl "bool" booleans nil) (x skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (NOT const-decl "[bool -> bool]" booleans nil) (rest const-decl "finseq" seq_extras structures) (length_rest formula-decl nil seq_extras structures) (replace_commutativity formula-decl nil replacement nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (SP? const-decl "bool" positions nil) (PP? const-decl "bool" positions nil) (rest_of_SP_is_SP formula-decl nil positions nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (i skolem-const-decl "below[length(rest(x))]" orthogonality_basis nil) (SP type-eq-decl nil positions nil) (s skolem-const-decl "term" orthogonality_basis nil) (rest_of_PP_is_PP formula-decl nil positions nil) (PP type-eq-decl nil positions nil) (n skolem-const-decl "nat" orthogonality_basis nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (delete_of_SP_is_SP formula-decl nil positions nil) (fsp skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (s skolem-const-decl "term" orthogonality_basis nil) (delete_of_PP_is_PP formula-decl nil positions nil)) shostak)) (replace_par_pos_preservs_subterm_TCC1 0 (replace_par_pos_preservs_subterm_TCC1-1 nil 3491736007 ("" (skosimp*) (("" (rewrite "replace_par_pos_preservs_pos") nil nil)) nil) ((replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (term type-decl nil term_adt nil)) nil (replace_par_pos_preservs_subterm subtype "orthogonality_basis.p" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(orthogonality_basis.replace_par_pos(orthogonality_basis.t, orthogonality_basis.fsp, orthogonality_basis.fst))"))) (replace_par_pos_preservs_subterm_TCC2 0 (replace_par_pos_preservs_subterm_TCC2-2 "" 3803915938 ("" (skosimp) (("" (expand* add_first insert? SPP? SP? finseq_appl) (("" (flatten) (("" (inst - 0) (("" (assert) nil nil)) nil)) nil)) nil)) nil) nil shostak (replace_par_pos_preservs_subterm subtype "orthogonality_basis.p" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(orthogonality_basis.t)")) (replace_par_pos_preservs_subterm_TCC2-1 nil 3491736007 ("" (skosimp) (("" (expand* add_first insert? SPP? SP? finseq_appl) (("" (flatten) (("" (inst -2 0) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((insert? const-decl "finseq" seq_extras structures) (SP? const-decl "bool" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (SPP? const-decl "bool" positions nil) (add_first const-decl "finseq" seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (fsp!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil)) nil (replace_par_pos_preservs_subterm subtype "orthogonality_basis.p" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(orthogonality_basis.t)"))) (replace_par_pos_preservs_subterm 0 (replace_par_pos_preservs_subterm-1 nil 3520355037 ("" (measure-induct "fsp`length" "fsp") (("1" (skeep) (("1" (skeep) (("1" (case "x`length=0") (("1" (hide -2) (("1" (expand* replace_par_pos finseq_appl) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x)") (("2" (rewrite length_rest) (("2" (expand replace_par_pos 2) (("2" (lift-if) (("2" (assert) (("2" (lemma replace_par_pos_equivalence) (("2" (expand finseq_appl) (("2" (inst -1 x fst t) (("2" (assert) (("2" (prop) (("1" (replaces -1) (("1" (rewrite replace_persistence) (("1" (inst -1 "rest(fst)" "p" "t") (("1" (prop) (("1" (expand SPP?) (("1" (flatten) (("1" (case "rest(x)`length=0") (("1" (split) (("1" (hide-all-but (-1 1)) (("1" (expand* PP? finseq_appl) (("1" (prop) (("1" (hide 2) (("1" (expand* add_first insert? rest ^ min empty_seq) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -4 -5 3) (("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (inst -2 0) (("1" (expand* add_first insert? finseq_appl) nil nil) ("2" (hide-all-but 1) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (typepred i) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (rewrite add_first_parallel_pos_to_PP_is_PP) (("1" (skeep) (("1" (expand finseq_appl) (("1" (hide -2 -3 -4 2 5) (("1" (expand* PP? finseq_appl) (("1" (prop) (("1" (expand* add_first insert?) (("1" (assert) nil nil)) nil) ("2" (inst -1 "i+2" 0) (("1" (assert) (("1" (hide 1) (("1" (expand* add_first insert? finseq_appl rest ^ min) (("1" (expand empty_seq 2) (("1" (lift-if) (("1" (assert) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2 3) (("3" (typepred i) (("3" (expand* add_first insert? rest ^ min empty_seq) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "x=rest(add_first(p,x))") (("1" (rewrite rest_of_PP_is_PP) (("1" (replace -1 1) (("1" (rewrite rest_of_PP_is_PP) nil nil)) nil)) nil) ("2" (rewrite rest_add_first) nil nil)) nil)) nil) ("2" (rewrite add_first_parallel_pos_to_SP_is_SP) (("2" (case "x=rest(add_first(p,x))") (("1" (rewrite rest_of_SP_is_SP) (("1" (replace -1 1) (("1" (rewrite rest_of_SP_is_SP) nil nil)) nil)) nil) ("2" (rewrite rest_add_first) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (rewrite replace_par_pos_preservs_pos) (("1" (expand SPP?) (("1" (flatten) (("1" (split) (("1" (rewrite add_first_parallel_pos_to_PP_is_PP) (("1" (skeep) (("1" (case "rest(x)`length=0") (("1" (expand PP? 2) (("1" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand* add_first insert?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 3 4) (("2" (expand* PP? finseq_appl) (("2" (prop) (("1" (hide 1 2) (("1" (expand* add_first insert?) (("1" (assert) nil nil)) nil)) nil) ("2" (inst -1 "i+2" 1) (("1" (assert) (("1" (hide 1) (("1" (expand* add_first insert? finseq_appl rest ^ min) (("1" (expand empty_seq 1) (("1" (lift-if) (("1" (assert) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 5)) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2 4) (("3" (typepred i) (("3" (expand* add_first insert? rest ^ min empty_seq) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite rest_of_PP_is_PP) (("2" (case "x=rest(add_first(p,x))") (("1" (replace -1 1) (("1" (rewrite rest_of_PP_is_PP) nil nil)) nil) ("2" (rewrite rest_add_first) nil nil)) nil)) nil)) nil) ("2" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (hide-all-but (-2 1 4)) (("1" (expand* SP? finseq_appl) (("1" (inst -1 1) (("1" (expand* add_first insert? finseq_appl) nil nil) ("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite rest_of_SP_is_SP) (("2" (case "x=rest(add_first(p,x))") (("1" (replace -1 1) (("1" (rewrite rest_of_SP_is_SP) nil nil)) nil) ("2" (rewrite rest_add_first) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 3) (("3" (rewrite replace_par_pos_preservs_pos) (("1" (hide -2 -3 2) (("1" (expand SPP?) (("1" (flatten) (("1" (case "rest(x)`length=0") (("1" (split) (("1" (hide -2 -3 2) (("1" (expand* PP? finseq_appl) (("1" (grind) nil nil)) nil)) nil) ("2" (hide -2 2) (("2" (rewrite empty_0) (("2" (replaces -1) (("2" (rewrite add_first_empty_seq) (("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (case "i=0") (("1" (inst -2 0) (("1" (expand* add_first insert? finseq_appl) (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred i) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (rewrite add_first_parallel_pos_to_PP_is_PP) (("1" (skeep) (("1" (hide -2 2) (("1" (expand* PP? finseq_appl) (("1" (prop) (("1" (hide 1) (("1" (expand* add_first insert? rest ^ min empty_seq) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -1 "i+2" 0) (("1" (assert) (("1" (hide 1) (("1" (expand* add_first insert? finseq_appl rest ^ min) (("1" (expand empty_seq 2) (("1" (lift-if) (("1" (assert) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2 3 5) (("3" (typepred i) (("3" (expand* add_first insert? rest ^ min empty_seq) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite rest_of_PP_is_PP) (("2" (case "x=rest(add_first(p,x))") (("1" (replace -1 1) (("1" (rewrite rest_of_PP_is_PP) nil nil)) nil) ("2" (rewrite rest_add_first) nil nil)) nil)) nil)) nil) ("2" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (hide-all-but (-2 1)) (("1" (expand* SP? finseq_appl) (("1" (inst -1 0) (("1" (expand* add_first insert? finseq_appl) nil nil) ("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite rest_of_SP_is_SP) (("2" (case "x=rest(add_first(p,x))") (("1" (replace -1 1) (("1" (rewrite rest_of_SP_is_SP) nil nil)) nil) ("2" (rewrite rest_add_first) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand SPP? -2) (("4" (flatten) (("4" (hide-all-but (-2 1 2)) (("4" (expand* PP? add_first insert? finseq_appl) (("4" (inst -1 1 0) (("1" (assert) nil nil) ("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil) ("3" (expand* add_first insert?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand SPP?) (("2" (flatten) (("2" (hide-all-but (-2 -3 1)) (("2" (case "x=rest(add_first(p,x))") (("1" (replace -1 1) (("1" (rewrite rest_of_PP_is_PP) (("1" (rewrite rest_of_SP_is_SP) nil nil)) nil)) nil) ("2" (rewrite rest_add_first) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (hide -1 -3 -4) (("2" (inst -1 0) (("1" (expand* add_first insert? finseq_appl) nil nil) ("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (rewrite replace_par_pos_preservs_pos) nil nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (case "fsp=rest(add_first(p,fsp))") (("1" (replace -1 1) (("1" (expand SPP?) (("1" (rewrite rest_of_PP_is_PP) (("1" (rewrite rest_of_SP_is_SP) nil nil)) nil)) nil)) nil) ("2" (rewrite rest_add_first) nil nil)) nil)) nil)) nil)) nil) ((fsp skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (p skolem-const-decl "position[variable, symbol, arity]" orthogonality_basis nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (length_rest formula-decl nil seq_extras structures) (replace_par_pos_equivalence formula-decl nil orthogonality_basis nil) (replace_persistence formula-decl nil replacement nil) (rest_of_PP_is_PP formula-decl nil positions nil) (rest_add_first formula-decl nil seq_extras structures) (i skolem-const-decl "below[length(rest(x))]" orthogonality_basis nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (add_first_parallel_pos_to_PP_is_PP formula-decl nil positions nil) (PP type-eq-decl nil positions nil) (rest_of_SP_is_SP formula-decl nil positions nil) (add_first_parallel_pos_to_SP_is_SP formula-decl nil positions nil) (SP type-eq-decl nil positions nil) (PP? const-decl "bool" positions nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (^ const-decl "finseq" finite_sequences nil) (insert? const-decl "finseq" seq_extras structures) (SP? const-decl "bool" positions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (p skolem-const-decl "position[variable, symbol, arity]" orthogonality_basis nil) (x skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (NOT const-decl "[bool -> bool]" booleans nil) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (i skolem-const-decl "below[length(rest(x))]" orthogonality_basis nil) (finite_sequence type-eq-decl nil finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (add_first_empty_seq formula-decl nil seq_extras structures) (empty_0 formula-decl nil seq_extras structures) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (parallel const-decl "bool" positions nil) (<= const-decl "bool" positions nil) (O const-decl "finseq" finite_sequences nil) (/= const-decl "boolean" notequal nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (i skolem-const-decl "below[length(rest(x))]" orthogonality_basis nil) (TRUE const-decl "bool" booleans nil) (rest const-decl "finseq" seq_extras structures) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (SPP type-eq-decl nil positions nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (SPP? const-decl "bool" positions nil) (add_first const-decl "finseq" seq_extras structures) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (replace_par_pos_subterm_TCC1 0 (replace_par_pos_subterm_TCC1-1 nil 3568372801 ("" (skosimp) (("" (rewrite replace_par_pos_preservs_PP) nil nil)) nil) ((replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (term type-decl nil term_adt nil)) nil (replace_par_pos_subterm subtype "finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_basis.fsp)(orthogonality_basis.i)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(orthogonality_basis.replace_par_pos(orthogonality_basis.t, orthogonality_basis.fsp, orthogonality_basis.fst))"))) (replace_par_pos_subterm_TCC2 0 (replace_par_pos_subterm_TCC2-1 nil 3568372801 ("" (subtype-tcc) nil nil) ((finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (replace_par_pos_subterm subtype "orthogonality_basis.i" "below[length(fst)]"))) (replace_par_pos_subterm 0 (replace_par_pos_subterm-2 "" 3803918558 ("" (expand "finseq_appl") (("" (measure-induct+ "length(fsp)" "fsp") (("1" (skosimp*) (("1" (case "x!1`length = 0") (("1" (hide-all-but -1) (("1" (typepred "i!1") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "replace_par_pos" 2) (("2" (expand "finseq_appl") (("2" (inst -1 "rest(x!1)" "rest(fst!1)" "t!1") (("2" (rewrite "length_rest") (("2" (prop) (("1" (lemma "replace_par_pos_equivalence") (("1" (expand "finseq_appl") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (lemma "replace_par_pos_preservs_pos") (("1" (inst -1 "rest(x!1)" "rest(fst!1)" "x!1`seq(0)" "t!1") (("1" (lemma "seq_first_rest[position]") (("1" (inst?) (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (replace -1 -2 rl) (("1" (prop) (("1" (case-replace "i!1 = 0" :hide? T) (("1" (hide-all-but (-1 2)) (("1" (lemma "subterm_of_replace") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "replace_par_pos_preservs_PP") (("2" (expand "finseq_appl") (("2" (inst?) (("2" (prop) (("1" (inst -1 "i!1 - 1") (("1" (inst -4 "i!1 - 1") (("1" (lemma "rest_pos[position]") (("1" (expand "finseq_appl") (("1" (inst?) (("1" (prop) (("1" (inst -1 "i!1 - 1") (("1" (lemma "rest_pos[term]") (("1" (expand "finseq_appl") (("1" (inst?) (("1" (prop) (("1" (inst -1 "i!1 - 1") (("1" (assert) (("1" (replace -1 -6 rl) (("1" (replace -2 -6 rl) (("1" (hide (-1 -2 -5)) (("1" (expand "SPP?") (("1" (flatten) (("1" (hide -5) (("1" (expand "PP?") (("1" (expand "finseq_appl") (("1" (inst -4 "0" "i!1") (("1" (assert) (("1" (lemma "replace_persistence") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 -8 1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 -7 1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (assert) nil nil)) nil)) nil) ("2" (prop) (("1" (hide-all-but (1 2)) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 2)) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1 3)) (("2" (expand "SPP?") (("2" (rewrite "rest_of_PP_is_PP") (("2" (rewrite "rest_of_SP_is_SP") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-5 1 3)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 3)) (("2" (expand "SPP?") (("2" (rewrite "rest_of_PP_is_PP") (("2" (rewrite "rest_of_SP_is_SP") nil nil)) nil)) nil)) nil) ("3" (hide (-1 3)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (skosimp) (("2" (grind) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp) (("3" (lemma "replace_par_pos_preservs_PP") (("3" (expand "finseq_appl") (("3" (inst?) (("3" (assert) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide (-1 2)) (("4" (skosimp) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (lemma "replace_par_pos_preservs_PP") (("5" (expand "finseq_appl") (("5" (inst?) (("5" (assert) (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (replace_par_pos_subterm-1 nil 3568372802 ("" (expand "finseq_appl") (("" (measure-induct+ "length(fsp)" "fsp") (("1" (skosimp*) (("1" (case "x!1`length = 0") (("1" (hide-all-but -1) (("1" (typepred "i!1") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "replace_par_pos" 2) (("2" (expand "finseq_appl") (("2" (inst -1 "rest(x!1)" "rest(fst!1)" "t!1") (("2" (rewrite "length_rest") (("2" (prop) (("1" (lemma "replace_par_pos_equivalence") (("1" (expand "finseq_appl") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (lemma "replace_par_pos_preservs_pos") (("1" (inst -1 "rest(x!1)" "rest(fst!1)" "x!1`seq(0)" "t!1") (("1" (lemma "seq_first_rest[position]") (("1" (inst?) (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (replace -1 -2 rl) (("1" (prop) (("1" (case-replace "i!1 = 0" :hide? T) (("1" (hide-all-but (-1 2)) (("1" (lemma "subterm_of_replace") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "replace_par_pos_preservs_PP") (("2" (expand "finseq_appl") (("2" (inst?) (("2" (prop) (("1" (inst -1 "i!1 - 1") (("1" (inst -4 "i!1 - 1") (("1" (lemma "rest_pos[position]") (("1" (expand "finseq_appl") (("1" (inst?) (("1" (prop) (("1" (inst -1 "i!1 - 1") (("1" (lemma "rest_pos[term]") (("1" (expand "finseq_appl") (("1" (inst?) (("1" (prop) (("1" (inst -1 "i!1 - 1") (("1" (assert) (("1" (replace -1 -6 rl) (("1" (replace -2 -6 rl) (("1" (hide (-1 -2 -5)) (("1" (expand "SPP?") (("1" (flatten) (("1" (hide -5) (("1" (expand "PP?") (("1" (expand "finseq_appl") (("1" (inst -4 "0" "i!1") (("1" (assert) (("1" (lemma "replace_persistence") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 -8 1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 -7 1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (assert) nil nil)) nil)) nil) ("2" (prop) (("1" (hide-all-but (1 2)) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 2)) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1 3)) (("2" (expand "SPP?") (("2" (rewrite "rest_of_PP_is_PP") (("2" (rewrite "rest_of_SP_is_SP") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-5 1 3)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 3)) (("2" (expand "SPP?") (("2" (rewrite "rest_of_PP_is_PP") (("2" (rewrite "rest_of_SP_is_SP") nil nil)) nil)) nil)) nil) ("3" (hide (-1 3)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (skosimp) (("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but (-1 -2 1)) (("3" (skosimp) (("3" (lemma "replace_par_pos_preservs_PP") (("3" (expand "finseq_appl") (("3" (inst?) (("3" (assert) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide (-1 2)) (("4" (skosimp) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skosimp) (("5" (lemma "replace_par_pos_preservs_PP") (("5" (expand "finseq_appl") (("5" (inst?) (("5" (assert) (("5" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rest_of_SP_is_SP formula-decl nil positions nil) (SP? const-decl "bool" positions nil) (SP type-eq-decl nil positions nil) (rest_of_PP_is_PP formula-decl nil positions nil) (PP type-eq-decl nil positions nil) (^ const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (replace_persistence formula-decl nil replacement nil) (PP? const-decl "bool" positions nil) (int_plus_int_is_int application-judgement "int" integers nil) (rest_pos formula-decl nil seq_extras structures) (i!1 skolem-const-decl "below[x!1`length]" orthogonality_basis nil) (x!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (subterm_of_replace formula-decl nil replacement nil) (first const-decl "T" seq_extras structures) (seq_first_rest formula-decl nil seq_extras structures) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (TRUE const-decl "bool" booleans nil) (replace_par_pos_equivalence formula-decl nil orthogonality_basis nil) (length_rest formula-decl nil seq_extras structures) (rest const-decl "finseq" seq_extras structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (SPP? const-decl "bool" positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (SPP type-eq-decl nil positions nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak)) (replace_par_pos_comp_TCC1 0 (replace_par_pos_comp_TCC1-1 nil 3491736007 ("" (subtype-tcc) nil nil) ((O const-decl "finseq" finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (replace_par_pos_comp subtype "finite_sequences[term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].term].o(orthogonality_basis.fst1, orthogonality_basis.fst2)" "{fst | orthogonality_basis.fst`length = (finite_sequences[position[variable, symbol, arity]].o(orthogonality_basis.fsp1, orthogonality_basis.fsp2))`length}"))) (replace_par_pos_comp_TCC2 0 (replace_par_pos_comp_TCC2-2 "" 3803918763 ("" (skosimp) (("" (expand* o SPP? SP? PP? finseq_appl) (("" (flatten) (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (split 1) (("1" (propax) nil nil) ("2" (assert) (("2" (prop) (("1" (skeep) (("1" (inst - i) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep 2) (("2" (inst - i) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (skeep) (("1" (prop) (("1" (assert) nil nil) ("2" (inst -1 i j) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst - i) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (replace_par_pos_comp subtype "orthogonality_basis.fsp1" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(orthogonality_basis.t)")) (replace_par_pos_comp_TCC2-1 nil 3491736007 ("" (skosimp) (("" (expand* o SPP? SP? PP? finseq_appl) (("" (flatten) (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (split 1) (("1" (propax) nil nil) ("2" (assert) (("2" (prop) (("1" (skeep) (("1" (inst -3 i) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep 2) (("2" (inst -3 i) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split) (("1" (skeep) (("1" (prop) (("1" (assert) nil nil) ("2" (inst -1 i j) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -2 i) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SPP? const-decl "bool" positions nil) (PP? const-decl "bool" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (SP? const-decl "bool" positions nil) (O const-decl "finseq" finite_sequences nil) (i skolem-const-decl "below[length(fsp1!1)]" orthogonality_basis nil) (fsp2!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (i skolem-const-decl "below[fsp1!1`length]" orthogonality_basis nil) (fsp1!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (j skolem-const-decl "below[fsp1!1`length]" orthogonality_basis nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (replace_par_pos_comp subtype "orthogonality_basis.fsp1" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(orthogonality_basis.t)"))) (replace_par_pos_comp_TCC3 0 (replace_par_pos_comp_TCC3-1 nil 3491736007 ("" (skosimp*) (("" (expand "SPP?") (("" (flatten) (("" (prop) (("1" (hide -4) (("1" (expand "PP?") (("1" (prop) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (skosimp*) (("2" (inst -1 "fsp1!1`length + i!1" "fsp1!1`length + j!1") (("1" (assert) (("1" (expand o) (("1" (propax) nil nil)) nil)) nil) ("2" (expand o) (("2" (assert) nil nil)) nil) ("3" (expand o) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_par_pos_preservs_PP_o_PP) (("2" (inst -1 fsp1!1 fsp2!1 fst1!1 t!1) (("2" (expand SPP?) (("2" (assert) (("2" (expand SP? 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SPP? const-decl "bool" positions nil) (PP? const-decl "bool" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (i!1 skolem-const-decl "below[fsp2!1`length]" orthogonality_basis nil) (fsp2!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (fsp1!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (j!1 skolem-const-decl "below[fsp2!1`length]" orthogonality_basis nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (O const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (term type-decl nil term_adt nil) (SP? const-decl "bool" positions nil) (replace_par_pos_preservs_PP_o_PP formula-decl nil orthogonality_basis nil)) nil (replace_par_pos_comp subtype "orthogonality_basis.fsp2" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(orthogonality_basis.replace_par_pos(orthogonality_basis.t, orthogonality_basis.fsp1, orthogonality_basis.fst1))"))) (replace_par_pos_comp 0 (replace_par_pos_comp-2 "" 3790334069 ("" (measure-induct "fsp1`length" "fsp1") (("1" (skeep) (("1" (skeep) (("1" (case "x`length=0") (("1" (hide -2) (("1" (expand replace_par_pos 1 3) (("1" (lift-if) (("1" (prop) (("1" (replace -1) (("1" (rewrite empty_0) (("1" (rewrite empty_0) (("1" (replaces -1) (("1" (replaces -2) (("1" (rewrite empty_o_seq) (("1" (rewrite empty_o_seq) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x)") (("2" (rewrite length_rest) (("2" (expand replace_par_pos 2 (1 3)) (("2" (lift-if) (("2" (lift-if) (("2" (expand finseq_appl) (("2" (prop) (("1" (hide-all-but (-1 3)) (("1" (rewrite "empty_0") (("1" (lemma "seq_empty[position]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "fsp2" "rest(fst1)" "fst2" "t") (("2" (assert) (("2" (prop) (("1" (lemma replace_par_pos_equivalence) (("1" (expand finseq_appl) (("1" (copy -1) (("1" (inst -1 "x o fsp2" "fst1 o fst2" "t") (("1" (prop) (("1" (replaces -1) (("1" (copy -1) (("1" (inst -1 "x" "fst1" "t") (("1" (prop) (("1" (replaces -1) (("1" (inst -1 "add_first(x`seq(0),fsp2)" "add_first(fst1`seq(0),fst2)" "replace_par_pos(t,rest(x),rest(fst1))") (("1" (prop) (("1" (rewrite rest_add_first) (("1" (rewrite rest_add_first) (("1" (expand add_first -1) (("1" (expand* insert? finseq_appl) (("1" (replaces -1) (("1" (rewrite rest_compo) (("1" (rewrite rest_compo) (("1" (replaces -1) (("1" (expand o 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 4)) (("2" (expand SPP?) (("2" (flatten) (("2" (prop) (("1" (expand* PP? finseq_appl) (("1" (prop) (("1" (hide 2) (("1" (expand* add_first insert?) (("1" (expand o -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep 3) (("2" (case "i=0") (("1" (case "j=0") (("1" (assert) nil nil) ("2" (replaces -1) (("2" (inst -1 0 "x`length + j -1") (("1" (assert) (("1" (expand o -1) (("1" (expand add_first 5) (("1" (expand* insert? finseq_appl) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred j) (("2" (expand* add_first insert? o) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "j=0") (("1" (replaces -1) (("1" (inst -1 "x`length + i -1" 0) (("1" (assert) (("1" (hide-all-but (-1 5 6)) (("1" (expand* add_first insert? finseq_appl o) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred i) (("2" (expand* add_first insert? o) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "x`length + i -1" "x`length + j -1") (("1" (assert) (("1" (hide-all-but (-1 6 7)) (("1" (expand* o add_first insert? finseq_appl) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred j) (("2" (expand* add_first insert? o) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred i) (("3" (expand* add_first insert? o) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand* add_first insert?) (("1" (inst -2 0) (("1" (expand o -2) (("1" (rewrite replace_par_pos_preservs_pos) (("1" (lemma seq_first_rest[position]) (("1" (inst -1 x) (("1" (assert) (("1" (expand* first finseq_appl) (("1" (replace -1 1 rl) (("1" (expand SPP?) (("1" (hide -1) (("1" (split) (("1" (expand* PP? finseq_appl) (("1" (prop) (("1" (expand o -1) (("1" (assert) nil nil)) nil) ("2" (skosimp) (("2" (inst -1 i!1 j!1) (("1" (assert) (("1" (typepred (i!1 j!1)) (("1" (expand o -3) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred j!1) (("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil) ("3" (typepred i!1) (("3" (expand o 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* SP? finseq_appl) (("2" (skosimp) (("2" (reveal -3) (("2" (typepred i!1) (("2" (inst -2 i!1) (("1" (expand o -2) (("1" (propax) nil nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -4) (("2" (hide-all-but (-1 1)) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "x`length + i -1") (("1" (expand* add_first insert? finseq_appl) (("1" (expand o -2) (("1" (assert) (("1" (rewrite replace_par_pos_preservs_pos) (("1" (expand* SPP? PP? finseq_appl) (("1" (split) (("1" (propax) nil nil) ("2" (prop) (("1" (hide -2 2 4) (("1" (expand* o add_first insert? rest ^ min empty_seq) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (case "i!1=0") (("1" (replaces -1) (("1" (case "j!1=0") (("1" (assert) nil nil) ("2" (typepred i j!1) (("2" (inst -3 "x`length + i-1" j!1) (("1" (prop) (("1" (hide -4 2 3 4 7) (("1" (expand* add_first insert? finseq_appl o rest ^ min) (("1" (expand empty_seq -3) (("1" (lift-if) (("1" (assert) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3)) (("2" (expand* add_first insert? rest ^ min empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand* add_first insert? rest ^ min empty_seq o) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (expand* add_first insert? o) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "j!1 = 0") (("1" (replaces -1) (("1" (hide -2 2 3 4 7) (("1" (typepred i!1 i) (("1" (inst -3 i!1 "x`length+i-1") (("1" (prop) (("1" (expand* o add_first insert? finseq_appl rest ^ min) (("1" (expand empty_seq -2) (("1" (lift-if) (("1" (assert) (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2)) (("2" (expand* add_first insert? rest ^ min empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand* add_first insert? o) (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (expand* add_first insert? o rest ^ min empty_seq) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 3 4 7 8) (("2" (typepred i!1 j!1) (("2" (inst -3 i!1 j!1) (("1" (assert) (("1" (expand* o add_first insert? finseq_appl rest ^ min) (("1" (expand empty_seq (-1 -2)) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand* o add_first insert? rest ^ min empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (expand* o add_first insert? rest ^ min empty_seq) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 3) (("3" (expand* SP? finseq_appl) (("3" (skosimp) (("3" (reveal -2) (("3" (case "i!1 = 0") (("1" (replaces -1) (("1" (inst -1 "x`length+i-1") (("1" (expand* o add_first insert? finseq_appl) nil nil) ("2" (hide-all-but 1) (("2" (typepred i) (("2" (expand* o add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred i!1) (("2" (inst -2 i!1) (("1" (expand* o add_first insert? finseq_appl rest ^ min) (("1" (expand empty_seq -1) (("1" (lift-if) (("1" (assert) (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand* o add_first insert? rest ^ min empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -5) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred i) (("2" (expand* o add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but -1) (("3" (expand* add_first insert?) (("3" (assert) nil nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand* add_first insert?) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 4)) (("2" (expand* SPP? PP? SP? finseq_appl) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (skeep) (("1" (typepred i) (("1" (inst -3 i) (("1" (expand o -3) (("1" (propax) nil nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep 2) (("2" (typepred i) (("2" (inst -3 i) (("1" (expand o -3) (("1" (propax) nil nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (typepred i j) (("3" (expand o -3) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (skeep 2) (("4" (typepred i j) (("4" (inst -3 i j) (("1" (assert) (("1" (expand o -3) (("1" (propax) nil nil)) nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil) ("3" (expand o 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (expand o -1) (("5" (assert) nil nil)) nil) ("6" (skeep 2) (("6" (typepred i) (("6" (inst -3 i) (("1" (expand o -3) (("1" (propax) nil nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -6 1)) (("2" (expand o) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 4)) (("2" (expand SPP?) (("2" (flatten) (("2" (split) (("1" (lemma rest_of_PP_is_PP) (("1" (inst -1 "x o fsp2") (("1" (rewrite rest_compo) nil nil)) nil)) nil) ("2" (lemma rest_of_SP_is_SP) (("2" (inst -1 t "x o fsp2") (("2" (rewrite rest_compo) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (expand* rest ^ min empty_seq) (("3" (lift-if) (("3" (lift-if) (("3" (assert) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand SPP?) (("2" (flatten) (("2" (split) (("1" (expand* PP? finseq_appl) (("1" (prop) (("1" (expand o -1) (("1" (assert) nil nil)) nil) ("2" (skeep 3) (("2" (inst -1 "fsp1`length+i" "fsp1`length+j") (("1" (assert) (("1" (expand o -1) (("1" (propax) nil nil)) nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil) ("3" (expand o 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand SP? 1) (("2" (skeep) (("2" (expand finseq_appl) (("2" (rewrite replace_par_pos_preservs_pos) (("2" (expand* SPP? SP? PP? finseq_appl) (("2" (split) (("1" (propax) nil nil) ("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand* o add_first insert?) (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp) (("2" (case "i!1=0 & j!1=0") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (prop) (("1" (case "j!1 = 0") (("1" (replaces -1) (("1" (typepred i!1 i) (("1" (inst -3 "i!1-1" "fsp1`length+i") (("1" (prop) (("1" (hide-all-but (-1 -2 1 5)) (("1" (expand* o add_first insert? finseq_appl) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2)) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil) ("3" (expand o 1) (("3" (assert) (("3" (hide-all-but (-1 1)) (("3" (expand* add_first insert?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred i!1 j!1) (("2" (inst -3 "i!1-1" "j!1-1") (("1" (assert) (("1" (hide-all-but (-1 -2 -3 1 2 6)) (("1" (expand* o add_first insert? finseq_appl) (("1" (lift-if) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand o 1) (("2" (assert) (("2" (hide-all-but (-2 1)) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 1 3)) (("3" (expand* o add_first insert?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i!1=0") (("1" (replaces -1) (("1" (typepred j!1 i) (("1" (inst -3 "fsp1`length+i" "j!1-1") (("1" (prop) (("1" (hide-all-but (-1 -2 1 5)) (("1" (expand* add_first insert? finseq_appl o) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2)) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand* add_first insert? o) (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (expand o) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred i!1 j!1) (("2" (inst -3 "i!1-1" "j!1-1") (("1" (assert) (("1" (hide-all-but (-1 -2 -3 1 2 6)) (("1" (expand* add_first insert? finseq_appl o) (("1" (lift-if) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 3)) (("2" (expand* add_first insert? o) (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but (-1 1 2)) (("3" (expand* add_first insert? o) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (hide-all-but (-2 1)) (("3" (case "i!1=0") (("1" (replaces -1) (("1" (inst -1 "fsp1`length+i") (("1" (expand* add_first insert? o) nil nil) ("2" (typepred i) (("2" (expand o) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i!1-1") (("1" (expand* add_first insert? finseq_appl o) (("1" (assert) (("1" (prop) (("1" (hide-all-but 1) (("1" (typepred i!1) (("1" (expand* add_first insert?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (typepred i!1) (("2" (expand* add_first insert? o) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand* SPP? PP? SP? finseq_appl) (("3" (flatten) (("3" (split) (("1" (prop) (("1" (expand o -1) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (typepred i) (("2" (inst -3 i) (("1" (expand o -3) (("1" (propax) nil nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (prop) (("1" (skeep 2) (("1" (typepred i j) (("1" (inst -3 i j) (("1" (assert) (("1" (expand o -3) (("1" (propax) nil nil)) nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil) ("3" (expand o 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred i) (("2" (inst -3 i) (("1" (expand o -3) (("1" (propax) nil nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (hide -1) (("4" (expand o) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((fsp1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (i skolem-const-decl "below[length(fsp1)]" orthogonality_basis nil) (fsp2 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (i skolem-const-decl "below[length(fsp1)]" orthogonality_basis nil) (i skolem-const-decl "below[fsp1`length]" orthogonality_basis nil) (j skolem-const-decl "below[fsp1`length]" orthogonality_basis nil) (fsp1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (fsp2 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (i skolem-const-decl "below[fsp2`length]" orthogonality_basis nil) (j skolem-const-decl "below[fsp2`length]" orthogonality_basis nil) (j!1 skolem-const-decl "below[add_first(fsp2`seq(i), fsp1)`length]" orthogonality_basis nil) (i skolem-const-decl "below[length(fsp2)]" orthogonality_basis nil) (i!1 skolem-const-decl "below[add_first(fsp2`seq(i), fsp1)`length]" orthogonality_basis nil) (i!1 skolem-const-decl "below[length(add_first(fsp2`seq(i), fsp1))]" orthogonality_basis nil) (empty_0 formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (empty_o_seq formula-decl nil seq_extras structures) (length_rest formula-decl nil seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (i skolem-const-decl "below[length(x)]" orthogonality_basis nil) (i skolem-const-decl "below[length(x)]" orthogonality_basis nil) (j skolem-const-decl "below[x`length]" orthogonality_basis nil) (i skolem-const-decl "below[x`length]" orthogonality_basis nil) (i skolem-const-decl "below[length(x)]" orthogonality_basis nil) (insert? const-decl "finseq" seq_extras structures) (rest_compo formula-decl nil seq_extras structures) (rest_add_first formula-decl nil seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (j skolem-const-decl "below[add_first(x`seq(0), fsp2)`length]" orthogonality_basis nil) (fsp2 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (x skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (i skolem-const-decl "below[add_first(x`seq(0), fsp2)`length]" orthogonality_basis nil) (PP? const-decl "bool" positions nil) (i skolem-const-decl "below[length(add_first(x`seq(0), fsp2))]" orthogonality_basis nil) (i!1 skolem-const-decl "below[add_first(fsp2`seq(i - 1), rest(x))`length]" orthogonality_basis nil) (j!1 skolem-const-decl "below[add_first(fsp2`seq(i - 1), rest(x))`length]" orthogonality_basis nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (i!1 skolem-const-decl "below[length(add_first(fsp2`seq(i - 1), rest(x)))]" orthogonality_basis nil) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (first const-decl "T" seq_extras structures) (i!1 skolem-const-decl "below[x`length]" orthogonality_basis nil) (j!1 skolem-const-decl "below[x`length]" orthogonality_basis nil) (i!1 skolem-const-decl "below[length(x)]" orthogonality_basis nil) (seq_first_rest formula-decl nil seq_extras structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (^ const-decl "finseq" finite_sequences nil) (SP? const-decl "bool" positions nil) (add_first const-decl "finseq" seq_extras structures) (replace_par_pos_equivalence formula-decl nil orthogonality_basis nil) (PP type-eq-decl nil positions nil) (rest_of_PP_is_PP formula-decl nil positions nil) (t skolem-const-decl "term" orthogonality_basis nil) (SP type-eq-decl nil positions nil) (rest_of_SP_is_SP formula-decl nil positions nil) (seq_empty formula-decl nil seq_extras structures) (rest const-decl "finseq" seq_extras structures) (SPP type-eq-decl nil positions nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (SPP? const-decl "bool" positions nil) (O const-decl "finseq" finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak) (replace_par_pos_comp-1 nil 3520362037 ("" (measure-induct "fsp1`length" "fsp1") (("1" (skeep) (("1" (skeep) (("1" (case "x`length=0") (("1" (hide -2) (("1" (expand replace_par_pos 1 3) (("1" (lift-if) (("1" (prop) (("1" (replace -1) (("1" (rewrite empty_0) (("1" (rewrite empty_0) (("1" (replaces -1) (("1" (replaces -2) (("1" (replaces -2) (("1" (rewrite empty_o_seq) (("1" (rewrite empty_o_seq) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x)") (("2" (rewrite length_rest) (("2" (expand replace_par_pos 2 (1 3)) (("2" (lift-if) (("2" (lift-if) (("2" (expand finseq_appl) (("2" (prop) (("1" (hide-all-but (-1 3)) (("1" (rewrite "empty_0") (("1" (lemma "seq_empty[position]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "fsp2" "rest(fst1)" "fst2" "t") (("2" (assert) (("2" (prop) (("1" (lemma replace_par_pos_equivalence) (("1" (expand finseq_appl) (("1" (copy -1) (("1" (inst -1 "x o fsp2" "fst1 o fst2" "t") (("1" (prop) (("1" (replaces -1) (("1" (copy -1) (("1" (inst -1 "x" "fst1" "t") (("1" (prop) (("1" (replaces -1) (("1" (inst -1 "add_first(x`seq(0),fsp2)" "add_first(fst1`seq(0),fst2)" "replace_par_pos(t,rest(x),rest(fst1))") (("1" (prop) (("1" (rewrite rest_add_first) (("1" (rewrite rest_add_first) (("1" (expand add_first -1) (("1" (expand* insert? finseq_appl) (("1" (replaces -1) (("1" (rewrite rest_compo) (("1" (rewrite rest_compo) (("1" (replaces -1) (("1" (expand o 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 4)) (("2" (expand SPP?) (("2" (flatten) (("2" (prop) (("1" (expand* PP? finseq_appl) (("1" (prop) (("1" (hide 2) (("1" (expand* add_first insert?) (("1" (expand o -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep 3) (("2" (case "i=0") (("1" (case "j=0") (("1" (assert) nil nil) ("2" (replaces -1) (("2" (inst -1 0 "x`length + j -1") (("1" (assert) (("1" (expand o -1) (("1" (expand add_first 5) (("1" (expand* insert? finseq_appl) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred j) (("2" (expand* add_first insert? o) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "j=0") (("1" (replaces -1) (("1" (inst -1 "x`length + i -1" 0) (("1" (assert) (("1" (hide-all-but (-1 5 6)) (("1" (expand* add_first insert? finseq_appl o) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred i) (("2" (expand* add_first insert? o) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "x`length + i -1" "x`length + j -1") (("1" (assert) (("1" (hide-all-but (-1 6 7)) (("1" (expand* o add_first insert? finseq_appl) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred j) (("2" (expand* add_first insert? o) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred i) (("3" (expand* add_first insert? o) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (case "i=0") (("1" (replaces -1) (("1" (expand* add_first insert?) (("1" (inst -2 0) (("1" (expand o -2) (("1" (rewrite replace_par_pos_preservs_pos) (("1" (lemma seq_first_rest[position]) (("1" (inst -1 x) (("1" (assert) (("1" (expand* first finseq_appl) (("1" (replace -1 1 rl) (("1" (expand SPP?) (("1" (hide -1) (("1" (split) (("1" (expand* PP? finseq_appl) (("1" (prop) (("1" (expand o -1) (("1" (assert) nil nil)) nil) ("2" (skosimp) (("2" (inst -1 i!1 j!1) (("1" (assert) (("1" (typepred (i!1 j!1)) (("1" (expand o -3) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred j!1) (("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil) ("3" (typepred i!1) (("3" (expand o 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* SP? finseq_appl) (("2" (skosimp) (("2" (reveal -3) (("2" (typepred i!1) (("2" (inst -2 i!1) (("1" (expand o -2) (("1" (propax) nil nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -4) (("2" (hide-all-but (-1 1)) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "x`length + i -1") (("1" (expand* add_first insert? finseq_appl) (("1" (expand o -2) (("1" (assert) (("1" (rewrite replace_par_pos_preservs_pos) (("1" (expand* SPP? PP? finseq_appl) (("1" (split) (("1" (propax) nil nil) ("2" (prop) (("1" (hide -2 2 4) (("1" (expand* o add_first insert? rest ^ min empty_seq) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (case "i!1=0") (("1" (replaces -1) (("1" (case "j!1=0") (("1" (assert) nil nil) ("2" (typepred i j!1) (("2" (inst -3 "x`length + i-1" j!1) (("1" (prop) (("1" (hide -4 2 3 4 7) (("1" (expand* add_first insert? finseq_appl o rest ^ min) (("1" (expand empty_seq -3) (("1" (lift-if) (("1" (assert) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3)) (("2" (expand* add_first insert? rest ^ min empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand* add_first insert? rest ^ min empty_seq o) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (expand* add_first insert? o) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "j!1 = 0") (("1" (replaces -1) (("1" (hide -2 2 3 4 7) (("1" (typepred i!1 i) (("1" (inst -3 i!1 "x`length+i-1") (("1" (prop) (("1" (expand* o add_first insert? finseq_appl rest ^ min) (("1" (expand empty_seq -2) (("1" (lift-if) (("1" (assert) (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2)) (("2" (expand* add_first insert? rest ^ min empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand* add_first insert? o) (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (expand* add_first insert? o rest ^ min empty_seq) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 3 4 7 8) (("2" (typepred i!1 j!1) (("2" (inst -3 i!1 j!1) (("1" (assert) (("1" (expand* o add_first insert? finseq_appl rest ^ min) (("1" (expand empty_seq (-1 -2)) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand* o add_first insert? rest ^ min empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (expand* o add_first insert? rest ^ min empty_seq) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 3) (("3" (expand* SP? finseq_appl) (("3" (skosimp) (("3" (reveal -2) (("3" (case "i!1 = 0") (("1" (replaces -1) (("1" (inst -1 "x`length+i-1") (("1" (expand* o add_first insert? finseq_appl) nil nil) ("2" (hide-all-but 1) (("2" (typepred i) (("2" (expand* o add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred i!1) (("2" (inst -2 i!1) (("1" (expand* o add_first insert? finseq_appl rest ^ min) (("1" (expand empty_seq -1) (("1" (lift-if) (("1" (assert) (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand* o add_first insert? rest ^ min empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -5) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred i) (("2" (expand* o add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but -1) (("3" (expand* add_first insert?) (("3" (assert) nil nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand* add_first insert?) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 4)) (("2" (expand* SPP? PP? SP? finseq_appl) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (skeep) (("1" (typepred i) (("1" (inst -3 i) (("1" (expand o -3) (("1" (propax) nil nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep 2) (("2" (typepred i) (("2" (inst -3 i) (("1" (expand o -3) (("1" (propax) nil nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (typepred i j) (("3" (expand o -3) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (skeep 2) (("4" (typepred i j) (("4" (inst -3 i j) (("1" (assert) (("1" (expand o -3) (("1" (propax) nil nil)) nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil) ("3" (expand o 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (expand o -1) (("5" (assert) nil nil)) nil) ("6" (skeep 2) (("6" (typepred i) (("6" (inst -3 i) (("1" (expand o -3) (("1" (propax) nil nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -6 1)) (("2" (expand o) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 4)) (("2" (expand SPP?) (("2" (flatten) (("2" (split) (("1" (lemma rest_of_PP_is_PP) (("1" (inst -1 "x o fsp2") (("1" (rewrite rest_compo) nil nil)) nil)) nil) ("2" (lemma rest_of_SP_is_SP) (("2" (inst -1 t "x o fsp2") (("2" (rewrite rest_compo) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (expand* rest ^ min empty_seq) (("3" (lift-if) (("3" (lift-if) (("3" (assert) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand SPP?) (("2" (flatten) (("2" (split) (("1" (expand* PP? finseq_appl) (("1" (prop) (("1" (expand o -1) (("1" (assert) nil nil)) nil) ("2" (skeep 3) (("2" (inst -1 "fsp1`length+i" "fsp1`length+j") (("1" (assert) (("1" (expand o -1) (("1" (propax) nil nil)) nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil) ("3" (expand o 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand SP? 1) (("2" (skeep) (("2" (expand finseq_appl) (("2" (rewrite replace_par_pos_preservs_pos) (("2" (expand* SPP? SP? PP? finseq_appl) (("2" (split) (("1" (propax) nil nil) ("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand* o add_first insert?) (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp) (("2" (case "i!1=0 & j!1=0") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (prop) (("1" (case "j!1 = 0") (("1" (replaces -1) (("1" (typepred i!1 i) (("1" (inst -3 "i!1-1" "fsp1`length+i") (("1" (prop) (("1" (hide-all-but (-1 -2 1 5)) (("1" (expand* o add_first insert? finseq_appl) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2)) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil) ("3" (expand o 1) (("3" (assert) (("3" (hide-all-but (-1 1)) (("3" (expand* add_first insert?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred i!1 j!1) (("2" (inst -3 "i!1-1" "j!1-1") (("1" (assert) (("1" (hide-all-but (-1 -2 -3 1 2 6)) (("1" (expand* o add_first insert? finseq_appl) (("1" (lift-if) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand o 1) (("2" (assert) (("2" (hide-all-but (-2 1)) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 1 3)) (("3" (expand* o add_first insert?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i!1=0") (("1" (replaces -1) (("1" (typepred j!1 i) (("1" (inst -3 "fsp1`length+i" "j!1-1") (("1" (prop) (("1" (hide-all-but (-1 -2 1 5)) (("1" (expand* add_first insert? finseq_appl o) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2)) (("2" (expand* add_first insert?) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand* add_first insert? o) (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (expand o) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred i!1 j!1) (("2" (inst -3 "i!1-1" "j!1-1") (("1" (assert) (("1" (hide-all-but (-1 -2 -3 1 2 6)) (("1" (expand* add_first insert? finseq_appl o) (("1" (lift-if) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 3)) (("2" (expand* add_first insert? o) (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but (-1 1 2)) (("3" (expand* add_first insert? o) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (hide-all-but (-2 1)) (("3" (case "i!1=0") (("1" (replaces -1) (("1" (inst -1 "fsp1`length+i") (("1" (expand* add_first insert? o) nil nil) ("2" (typepred i) (("2" (expand o) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i!1-1") (("1" (expand* add_first insert? finseq_appl o) (("1" (assert) (("1" (prop) (("1" (hide-all-but 1) (("1" (typepred i!1) (("1" (expand* add_first insert?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (typepred i!1) (("2" (expand* add_first insert? o) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand* SPP? PP? SP? finseq_appl) (("3" (flatten) (("3" (split) (("1" (prop) (("1" (expand o -1) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (typepred i) (("2" (inst -3 i) (("1" (expand o -3) (("1" (propax) nil nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (prop) (("1" (skeep 2) (("1" (typepred i j) (("1" (inst -3 i j) (("1" (assert) (("1" (expand o -3) (("1" (propax) nil nil)) nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil) ("3" (expand o 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred i) (("2" (inst -3 i) (("1" (expand o -3) (("1" (propax) nil nil)) nil) ("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (hide -1) (("4" (expand o) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) (nil nil nil nil nil nil nil nil nil nil nil nil nil nil (empty_0 formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (empty_o_seq formula-decl nil seq_extras structures) (length_rest formula-decl nil seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) nil nil nil nil nil (insert? const-decl "finseq" seq_extras structures) (rest_compo formula-decl nil seq_extras structures) (rest_add_first formula-decl nil seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) nil nil nil (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) nil (PP? const-decl "bool" positions nil) nil nil nil (odd_plus_even_is_odd application-judgement "odd_int" integers nil) nil (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (first const-decl "T" seq_extras structures) nil nil nil (seq_first_rest formula-decl nil seq_extras structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (^ const-decl "finseq" finite_sequences nil) (SP? const-decl "bool" positions nil) (add_first const-decl "finseq" seq_extras structures) (replace_par_pos_equivalence formula-decl nil orthogonality_basis nil) (PP type-eq-decl nil positions nil) (rest_of_PP_is_PP formula-decl nil positions nil) nil (SP type-eq-decl nil positions nil) (rest_of_SP_is_SP formula-decl nil positions nil) (seq_empty formula-decl nil seq_extras structures) (rest const-decl "finseq" seq_extras structures) (SPP type-eq-decl nil positions nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (SPP? const-decl "bool" positions nil) (O const-decl "finseq" finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (replace_par_pos_comp_commute_TCC1 0 (replace_par_pos_comp_commute_TCC1-1 nil 3568042173 ("" (skosimp) (("" (expand SPP?) (("" (flatten) (("" (prop) (("1" (lemma predicate_fseq2set[position].pred_bin_comp) (("1" (inst -1 "parallel" "fsp1!1" "fsp2!1") (("1" (prop) (("1" (expand* "PSeq?" "PP?" "finseq_appl") nil nil) ("2" (expand* "PSeq?" "PP?" "finseq_appl") nil nil)) nil)) nil)) nil) ("2" (lemma predicate_fseq2set[position].subset_comp) (("2" (inst -1 "positionsOF(t!1)" "fsp1!1" "fsp2!1") (("2" (prop) (("1" (expand* SP? finseq_appl) (("1" (skosimp) (("1" (expand subset?) (("1" (expand* subset? member seq2set finseq_appl) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* SP? finseq_appl) (("2" (expand subset?) (("2" (expand* subset? member seq2set finseq_appl) (("2" (skosimp*) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SPP? const-decl "bool" positions nil) (PRED type-eq-decl nil defined_types nil) (parallel const-decl "bool" positions nil) (finseq type-eq-decl nil finite_sequences nil) (PSeq? const-decl "bool" predicate_fseq2set nil) (PP? const-decl "bool" positions nil) (pred_bin_comp formula-decl nil predicate_fseq2set nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (SP? const-decl "bool" positions nil) (subset? const-decl "bool" predicate_fseq2set nil) (< const-decl "bool" reals nil) (O const-decl "finseq" finite_sequences nil) (below type-eq-decl nil naturalnumbers nil) (subset? const-decl "bool" sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (member const-decl "bool" sets nil) (subset_comp formula-decl nil predicate_fseq2set nil)) nil (replace_par_pos_comp_commute subtype "finite_sequences[position[variable, symbol, arity]].o(orthogonality_basis.fsp2, orthogonality_basis.fsp1)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(orthogonality_basis.t)"))) (replace_par_pos_comp_commute_TCC2 0 (replace_par_pos_comp_commute_TCC2-1 nil 3568042173 ("" (subtype-tcc) nil nil) ((O const-decl "finseq" finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (replace_par_pos_comp_commute subtype "finite_sequences[term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].term].o(orthogonality_basis.fst2, orthogonality_basis.fst1)" "{fst | orthogonality_basis.fst`length = (finite_sequences[position[variable, symbol, arity]].o(orthogonality_basis.fsp2, orthogonality_basis.fsp1))`length}"))) (replace_par_pos_comp_commute 0 (replace_par_pos_comp_commute-2 "" 3803924525 ("" (measure-induct+ "length(fsp1)" "fsp1") (("1" (case "x!1`length = 0") (("1" (skosimp) (("1" (hide (-2 -3)) (("1" (replace -1 -2) (("1" (rewrite "empty_0") (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (replaces -1) (("1" (rewrite "empty_o_seq") (("1" (rewrite "empty_o_seq") (("1" (rewrite "seq_o_empty") (("1" (rewrite "seq_o_empty") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "replace_par_pos" 2 1) (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "replace_par_pos") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (hide 2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x!1)" "fsp2!1" "rest(fst1!1)" "fst2!1" "replaceTerm(t!1, (fst1!1 o fst2!1)`seq(0), (x!1 o fsp2!1)`seq(0))") (("2" (rewrite "length_rest") (("2" (prop) (("1" (lemma "rest_compo[position]") (("1" (inst -1 "x!1" "fsp2!1") (("1" (assert) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (lemma "rest_compo[term]") (("1" (inst -1 "fst1!1" "fst2!1") (("1" (assert) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (replaces -1) (("1" (expand "o" 2 (1 2)) (("1" (lemma "replace_par_pos_equivalence1") (("1" (expand "finseq_appl") (("1" (inst -1 "fsp2!1 o x!1" "fst2!1 o fst1!1" "fst2!1`length" "t!1") (("1" (prop) (("1" (case-replace "(fst2!1 o fst1!1)`seq(fst2!1`length) = fst1!1`seq(0)" :hide? T) (("1" (case-replace "(fsp2!1 o x!1)`seq(fst2!1`length) = x!1`seq(0)" :hide? T) (("1" (case-replace "delete(fsp2!1 o x!1, fst2!1`length) = fsp2!1 o rest(x!1)" :hide? T) (("1" (case-replace "delete(fst2!1 o fst1!1, fst2!1`length) = fst2!1 o rest(fst1!1)" :hide? T) (("1" (hide (-1 -2 3)) (("1" (decompose-equality 1) (("1" (grind) nil nil) ("2" (decompose-equality 1) (("2" (expand "delete") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (hide 1) (("1" (grind) nil nil)) nil) ("2" (expand "o" 1) (("2" (assert) nil nil)) nil) ("3" (expand "o" 2) (("3" (assert) (("3" (lemma "rest_pos[term]") (("3" (expand "finseq_appl") (("3" (inst -1 "fst1!1") (("3" (prop) (("1" (inst -1 "x!2 - fst2!1`length") (("1" (assert) nil nil) ("2" (hide 3) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 3)) (("2" (decompose-equality 1) (("1" (grind) nil nil) ("2" (decompose-equality 1) (("2" (expand "delete") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (hide 1) (("1" (grind) nil nil)) nil) ("2" (expand "o" 1) (("2" (assert) nil nil)) nil) ("3" (expand "o" 2) (("3" (assert) (("3" (lemma "rest_pos[position]") (("3" (expand "finseq_appl") (("3" (inst -1 "x!1") (("3" (prop) (("1" (inst -1 "x!2 - fst2!1`length") (("1" (assert) nil nil) ("2" (hide 3) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 3)) (("2" (expand "o" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (-1 -2 3)) (("2" (expand "o" 1) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand SPP?) (("2" (flatten) (("2" (prop) (("1" (hide -2) (("1" (lemma predicate_fseq2set[position].pred_bin_comp) (("1" (inst -1 "parallel" "x!1" "fsp2!1") (("1" (prop) (("1" (hide -2) (("1" (expand* "PSeq?" "PP?" "finseq_appl") nil nil)) nil) ("2" (hide 2) (("2" (expand* "PSeq?" "PP?" "finseq_appl") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma predicate_fseq2set[position].subset_comp) (("2" (inst -1 "positionsOF(t!1)" "x!1" "fsp2!1") (("2" (prop) (("1" (hide -2) (("1" (expand* SP? finseq_appl) (("1" (skosimp) (("1" (expand subset?) (("1" (expand* subset? member seq2set finseq_appl) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* SP? finseq_appl) (("2" (expand subset?) (("2" (expand* subset? member seq2set finseq_appl) (("2" (skosimp*) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (expand o) (("3" (propax) nil nil)) nil)) nil) ("4" (hide-all-but (-2 -3 1)) (("4" (expand o) (("4" (assert) nil nil)) nil)) nil) ("5" (hide-all-but (-3 1 4)) (("5" (expand o) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "o" 1 (1 2)) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (lemma "rest_compo[position]") (("2" (inst -1 "x!1" "fsp2!1") (("2" (assert) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (expand "SPP?") (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (rewrite "rest_of_PP_is_PP") nil nil)) nil) ("2" (rewrite "rest_of_SP_is_SP") (("2" (hide 2) (("2" (expand "SP?") (("2" (expand "finseq_appl") (("2" (skosimp) (("2" (expand "o" 1) (("2" (prop) (("1" (case-replace "i!1 = 0" :hide? T) (("1" (hide-all-but (-3 1)) (("1" (inst -1 "0") (("1" (expand "o") (("1" (lemma "replace_preserv_pos") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "PP?") (("2" (expand "finseq_appl") (("2" (prop) (("1" (grind) nil nil) ("2" (inst -1 "0" "i!1") (("2" (assert) (("2" (inst-cp -3 "0") (("2" (inst -3 "i!1") (("2" (expand "o" (-1 -3 -4)) (("2" (lemma "replace_preserv_parallel_pos") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "PP?") (("2" (expand "finseq_appl") (("2" (assert) (("2" (inst -1 "0" "i!1") (("2" (assert) (("2" (inst-cp -2 "0") (("2" (inst -2 "i!1") (("2" (expand "o" (-1 -2 -3)) (("2" (lemma "replace_preserv_parallel_pos") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 3)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -5 2)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (expand SPP?) (("3" (flatten) (("3" (prop) (("1" (hide -2) (("1" (lemma predicate_fseq2set[position].pred_bin_comp) (("1" (inst -1 "parallel" "y!1" "fsp2!1") (("1" (prop) (("1" (hide -2) (("1" (expand* "PSeq?" "PP?" "finseq_appl") nil nil)) nil) ("2" (hide 2) (("2" (expand* "PSeq?" "PP?" "finseq_appl") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma predicate_fseq2set[position].subset_comp) (("2" (inst -1 "positionsOF(t!1)" "y!1" "fsp2!1") (("2" (prop) (("1" (hide -2) (("1" (expand* SP? finseq_appl) (("1" (skosimp) (("1" (expand subset?) (("1" (expand* subset? member seq2set finseq_appl) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* SP? finseq_appl) (("2" (expand subset?) (("2" (expand* subset? member seq2set finseq_appl) (("2" (skosimp*) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide (-1 -5 2)) (("4" (grind) nil nil)) nil) ("5" (hide (-1 2)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-1 1)) (("6" (expand SPP?) (("6" (flatten) (("6" (prop) (("1" (hide -2) (("1" (lemma predicate_fseq2set[position].pred_bin_comp) (("1" (inst -1 "parallel" "fsp1!1" "fsp2!1") (("1" (prop) (("1" (hide -2) (("1" (expand* "PSeq?" "PP?" "finseq_appl") nil nil)) nil) ("2" (hide 2) (("2" (expand* "PSeq?" "PP?" "finseq_appl") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma predicate_fseq2set[position].subset_comp) (("2" (inst -1 "positionsOF(t!1)" "fsp1!1" "fsp2!1") (("2" (prop) (("1" (hide -2) (("1" (expand* SP? finseq_appl) (("1" (skosimp) (("1" (expand subset?) (("1" (expand* subset? member seq2set finseq_appl) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* SP? finseq_appl) (("2" (expand subset?) (("2" (expand* subset? member seq2set finseq_appl) (("2" (skosimp*) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide (-1 2)) (("7" (grind) nil nil)) nil)) nil) nil shostak) (replace_par_pos_comp_commute-1 nil 3569838973 ("" (measure-induct+ "length(fsp1)" "fsp1") (("1" (case "x!1`length = 0") (("1" (skosimp) (("1" (hide (-2 -3)) (("1" (replace -1 -2) (("1" (rewrite "empty_0") (("1" (rewrite "empty_0") (("1" (replaces -1) (("1" (replaces -1) (("1" (rewrite "empty_o_seq") (("1" (rewrite "empty_o_seq") (("1" (rewrite "seq_o_empty") (("1" (rewrite "seq_o_empty") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand "replace_par_pos" 2 1) (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "replace_par_pos") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (hide 2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x!1)" "fsp2!1" "rest(fst1!1)" "fst2!1" "replaceTerm(t!1, (fst1!1 o fst2!1)`seq(0), (x!1 o fsp2!1)`seq(0))") (("2" (rewrite "length_rest") (("2" (prop) (("1" (lemma "rest_compo[position]") (("1" (inst -1 "x!1" "fsp2!1") (("1" (assert) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (lemma "rest_compo[term]") (("1" (inst -1 "fst1!1" "fst2!1") (("1" (assert) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (replaces -1) (("1" (expand "o" 2 (1 2)) (("1" (lemma "replace_par_pos_equivalence1") (("1" (expand "finseq_appl") (("1" (inst -1 "fsp2!1 o x!1" "fst2!1 o fst1!1" "fst2!1`length" "t!1") (("1" (prop) (("1" (case-replace "(fst2!1 o fst1!1)`seq(fst2!1`length) = fst1!1`seq(0)" :hide? T) (("1" (case-replace "(fsp2!1 o x!1)`seq(fst2!1`length) = x!1`seq(0)" :hide? T) (("1" (case-replace "delete(fsp2!1 o x!1, fst2!1`length) = fsp2!1 o rest(x!1)" :hide? T) (("1" (case-replace "delete(fst2!1 o fst1!1, fst2!1`length) = fst2!1 o rest(fst1!1)" :hide? T) (("1" (hide (-1 -2 3)) (("1" (decompose-equality 1) (("1" (grind) nil nil) ("2" (decompose-equality 1) (("2" (expand "delete") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (hide 1) (("1" (grind) nil nil)) nil) ("2" (expand "o" 1) (("2" (assert) nil nil)) nil) ("3" (expand "o" 2) (("3" (assert) (("3" (lemma "rest_pos[term]") (("3" (expand "finseq_appl") (("3" (inst -1 "fst1!1") (("3" (prop) (("1" (inst -1 "x!2 - fst2!1`length") (("1" (assert) nil nil) ("2" (hide 3) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 3)) (("2" (decompose-equality 1) (("1" (grind) nil nil) ("2" (decompose-equality 1) (("2" (expand "delete") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (hide 1) (("1" (grind) nil nil)) nil) ("2" (expand "o" 1) (("2" (assert) nil nil)) nil) ("3" (expand "o" 2) (("3" (assert) (("3" (lemma "rest_pos[position]") (("3" (expand "finseq_appl") (("3" (inst -1 "x!1") (("3" (prop) (("1" (inst -1 "x!2 - fst2!1`length") (("1" (assert) nil nil) ("2" (hide 3) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 3)) (("2" (expand "o" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide (-1 -2 3)) (("2" (expand "o" 1) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand SPP?) (("2" (flatten) (("2" (prop) (("1" (hide -2) (("1" (lemma predicate_fseq2set[position].pred_bin_comp) (("1" (inst -1 "parallel" "x!1" "fsp2!1") (("1" (prop) (("1" (hide -2) (("1" (expand* "PSeq?" "PP?" "finseq_appl") nil nil)) nil) ("2" (hide 2) (("2" (expand* "PSeq?" "PP?" "finseq_appl") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma predicate_fseq2set[position].subset_comp) (("2" (inst -1 "positionsOF(t!1)" "x!1" "fsp2!1") (("2" (prop) (("1" (hide -2) (("1" (expand* SP? finseq_appl) (("1" (skosimp) (("1" (expand subset?) (("1" (expand* subset? member seq2set finseq_appl) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* SP? finseq_appl) (("2" (expand subset?) (("2" (expand* subset? member seq2set finseq_appl) (("2" (skosimp*) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (expand o) (("3" (propax) nil nil)) nil)) nil) ("4" (hide-all-but (-2 -3 1)) (("4" (expand o) (("4" (assert) nil nil)) nil)) nil) ("5" (hide-all-but (-3 1 4)) (("5" (expand o) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "o" 1 (1 2)) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (lemma "rest_compo[position]") (("2" (inst -1 "x!1" "fsp2!1") (("2" (assert) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (expand "SPP?") (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (rewrite "rest_of_PP_is_PP") nil nil)) nil) ("2" (rewrite "rest_of_SP_is_SP") (("2" (hide 2) (("2" (expand "SP?") (("2" (expand "finseq_appl") (("2" (skosimp) (("2" (expand "o" 1) (("2" (prop) (("1" (case-replace "i!1 = 0" :hide? T) (("1" (hide-all-but (-3 1)) (("1" (inst -1 "0") (("1" (expand "o") (("1" (lemma "replace_preserv_pos") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "PP?") (("2" (expand "finseq_appl") (("2" (prop) (("1" (grind) nil nil) ("2" (inst -1 "0" "i!1") (("2" (assert) (("2" (inst-cp -3 "0") (("2" (inst -3 "i!1") (("2" (expand "o" (-1 -3 -4)) (("2" (lemma "replace_preserv_parallel_pos") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "PP?") (("2" (expand "finseq_appl") (("2" (assert) (("2" (inst -1 "0" "i!1") (("2" (assert) (("2" (inst-cp -2 "0") (("2" (inst -2 "i!1") (("2" (expand "o" (-1 -2 -3)) (("2" (lemma "replace_preserv_parallel_pos") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-1 3)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -5 2)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (expand SPP?) (("3" (flatten) (("3" (prop) (("1" (hide -2) (("1" (lemma predicate_fseq2set[position].pred_bin_comp) (("1" (inst -1 "parallel" "y!1" "fsp2!1") (("1" (prop) (("1" (hide -2) (("1" (expand* "PSeq?" "PP?" "finseq_appl") nil nil)) nil) ("2" (hide 2) (("2" (expand* "PSeq?" "PP?" "finseq_appl") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma predicate_fseq2set[position].subset_comp) (("2" (inst -1 "positionsOF(t!1)" "y!1" "fsp2!1") (("2" (prop) (("1" (hide -2) (("1" (expand* SP? finseq_appl) (("1" (skosimp) (("1" (expand subset?) (("1" (expand* subset? member seq2set finseq_appl) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* SP? finseq_appl) (("2" (expand subset?) (("2" (expand* subset? member seq2set finseq_appl) (("2" (skosimp*) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide (-1 -5 2)) (("4" (grind) nil nil)) nil) ("5" (hide (-1 2)) (("5" (grind) nil nil)) nil) ("6" (hide-all-but (-1 1)) (("6" (expand SPP?) (("6" (flatten) (("6" (prop) (("1" (hide -2) (("1" (lemma predicate_fseq2set[position].pred_bin_comp) (("1" (inst -1 "parallel" "fsp1!1" "fsp2!1") (("1" (prop) (("1" (hide -2) (("1" (expand* "PSeq?" "PP?" "finseq_appl") nil nil)) nil) ("2" (hide 2) (("2" (expand* "PSeq?" "PP?" "finseq_appl") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma predicate_fseq2set[position].subset_comp) (("2" (inst -1 "positionsOF(t!1)" "fsp1!1" "fsp2!1") (("2" (prop) (("1" (hide -2) (("1" (expand* SP? finseq_appl) (("1" (skosimp) (("1" (expand subset?) (("1" (expand* subset? member seq2set finseq_appl) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* SP? finseq_appl) (("2" (expand subset?) (("2" (expand* subset? member seq2set finseq_appl) (("2" (skosimp*) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide (-1 2)) (("7" (grind) nil nil)) nil)) nil) ((<= const-decl "bool" positions nil) (/= const-decl "boolean" notequal nil) (empty_0 formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (empty_o_seq formula-decl nil seq_extras structures) (seq_o_empty formula-decl nil seq_extras structures) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (rest const-decl "finseq" seq_extras structures) (x!2 skolem-const-decl "below[delete(fsp2!1 o x!1, fst2!1`length)`length]" orthogonality_basis nil) (x!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (fsp2!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (^ const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (rest_pos formula-decl nil seq_extras structures) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (fst2!1 skolem-const-decl "finseq[term]" orthogonality_basis nil) (fst1!1 skolem-const-decl "finseq[term]" orthogonality_basis nil) (x!2 skolem-const-decl "below[delete(fst2!1 o fst1!1, fst2!1`length)`length]" orthogonality_basis nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (delete const-decl "finseq" seq_extras structures) (pred_bin_comp formula-decl nil predicate_fseq2set nil) (PSeq? const-decl "bool" predicate_fseq2set nil) (PP? const-decl "bool" positions nil) (PRED type-eq-decl nil defined_types nil) (parallel const-decl "bool" positions nil) (subset_comp formula-decl nil predicate_fseq2set nil) (SP? const-decl "bool" positions nil) (subset? const-decl "bool" predicate_fseq2set nil) (below type-eq-decl nil naturalnumbers nil) (subset? const-decl "bool" sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (replace_par_pos_equivalence1 formula-decl nil orthogonality_basis nil) (rest_compo formula-decl nil seq_extras structures) (SP type-eq-decl nil positions nil) (rest_of_SP_is_SP formula-decl nil positions nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (replace_preserv_pos formula-decl nil replacement nil) (rest_of_PP_is_PP formula-decl nil positions nil) (PP type-eq-decl nil positions nil) (length_rest formula-decl nil seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (SPP type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (SPP? const-decl "bool" positions nil) (O const-decl "finseq" finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (replace_replace_par_pos_TCC1 0 (replace_replace_par_pos_TCC1-1 nil 3567786697 ("" (skosimp) (("" (expand SPP?) (("" (flatten) (("" (rewrite comp_pos_is_PP) (("" (expand* SP? finseq_appl) (("" (skeep) (("" (expand comp_pos) (("" (expand finseq_appl) (("" (inst -3 i) (("" (rewrite replace_compose_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SPP? const-decl "bool" positions nil) (comp_pos_is_PP formula-decl nil orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (term type-decl nil term_adt nil) (replace_compose_pos formula-decl nil replacement nil) (< const-decl "bool" reals nil) (comp_pos const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (SP? const-decl "bool" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (replace_replace_par_pos subtype "orthogonality_basis.comp_pos(orthogonality_basis.q, orthogonality_basis.fsp)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(replacement[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].replaceTerm(orthogonality_basis.t, orthogonality_basis.s, orthogonality_basis.q))"))) (replace_replace_par_pos_TCC2 0 (replace_replace_par_pos_TCC2-1 nil 3567786697 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil) (O const-decl "finseq" finite_sequences nil) (comp_pos const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil)) nil (replace_replace_par_pos subtype "orthogonality_basis.fst" "{fst | orthogonality_basis.fst`length = orthogonality_basis.comp_pos(orthogonality_basis.q, orthogonality_basis.fsp)`length}"))) (replace_replace_par_pos 0 (replace_replace_par_pos-2 "" 3803938539 ("" (measure-induct+ "length(fsp)" "fsp") (("1" (skosimp) (("1" (expand "replace_par_pos" 1) (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "comp_pos") (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (-1 2)) (("2" (expand "comp_pos") (("2" (propax) nil nil)) nil)) nil) ("3" (inst -1 "rest(x!1)" "rest(fst!1)" "q!1" "replaceTerm(s!1, fst!1`seq(0), x!1`seq(0))" "t!1") (("3" (rewrite "length_rest") (("3" (prop) (("1" (replaces -1) (("1" (lemma "replace_associativity") (("1" (inst?) (("1" (prop) (("1" (replace -1 2 rl) (("1" (expand "comp_pos" 2 2) (("1" (expand "finseq_appl") (("1" (rewrite "comp_pos_rest") nil nil)) nil)) nil)) nil) ("2" (expand "SPP?") (("2" (flatten) (("2" (hide-all-but (-3 1 4)) (("2" (expand "SP?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 4)) (("2" (expand "SPP?") (("2" (prop) (("1" (hide (-2 2)) (("1" (expand "PP?") (("1" (prop) (("1" (hide 2) (("1" (grind) nil nil)) nil) ("2" (skosimp) (("2" (expand "finseq_appl") (("2" (inst -1 "i!1 + 1" "j!1 + 1") (("1" (assert) (("1" (lemma "rest_pos[position]") (("1" (inst?) (("1" (assert) (("1" (expand "finseq_appl") (("1" (inst-cp -1 "i!1") (("1" (inst -1 "j!1") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "j!1") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "j!1") (("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "i!1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "PP?" "SP?") (("2" (expand "finseq_appl") (("2" (prop) (("1" (skosimp) (("1" (typepred "i!1") (("1" (hide (-3 1)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -1 "0" "i!1 + 1") (("1" (assert) (("1" (lemma "rest_pos[position]") (("1" (inst?) (("1" (assert) (("1" (expand "finseq_appl") (("1" (inst -1 "i!1") (("1" (replace -1 2 rl) (("1" (inst-cp -3 "0") (("1" (inst -3 "i!1 + 1") (("1" (lemma "replace_preserv_parallel_pos") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (expand "comp_pos") (("2" (propax) nil nil)) nil)) nil) ("3" (hide-all-but (-2 -3 1)) (("3" (expand "SPP?") (("3" (prop) (("1" (hide -3) (("1" (expand "PP?") (("1" (prop) (("1" (hide (-2 2)) (("1" (expand "comp_pos") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (skosimp) (("2" (inst -1 "i!1" "j!1") (("1" (assert) (("1" (hide (-2 1 2 3)) (("1" (expand* "parallel" "comp_pos") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide 2) (("1" (expand "<=") (("1" (skosimp) (("1" (inst 1 "p1!1") (("1" (lemma "o_assoc[posnat]") (("1" (inst?) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (lemma "equal_prefix[posnat]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (expand "<=") (("2" (skosimp) (("2" (inst 1 "p1!1") (("2" (lemma "o_assoc[posnat]") (("2" (inst?) (("2" (replace -1 -2 rl) (("2" (hide -1) (("2" (lemma "equal_prefix[posnat]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "j!1") (("2" (expand "comp_pos") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "i!1") (("3" (expand "comp_pos") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "SP?") (("2" (skosimp) (("2" (expand "comp_pos") (("2" (expand "finseq_appl") (("2" (inst?) (("2" (lemma "replace_compose_pos") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-3 1)) (("4" (expand "comp_pos") (("4" (propax) nil nil)) nil)) nil) ("5" (hide (-3 2)) (("5" (expand "SPP?") (("5" (prop) (("1" (hide -3) (("1" (expand "PP?") (("1" (prop) (("1" (hide (-2 2)) (("1" (expand "comp_pos") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (skosimp) (("2" (inst -1 "i!1" "j!1") (("1" (assert) (("1" (hide (-2 1 2 3)) (("1" (expand* "parallel" "comp_pos") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide 2) (("1" (expand "<=") (("1" (skosimp) (("1" (inst 1 "p1!1") (("1" (lemma "o_assoc[posnat]") (("1" (inst?) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (lemma "equal_prefix[posnat]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (expand "<=") (("2" (skosimp) (("2" (inst 1 "p1!1") (("2" (lemma "o_assoc[posnat]") (("2" (inst?) (("2" (replace -1 -2 rl) (("2" (hide -1) (("2" (lemma "equal_prefix[posnat]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "j!1") (("2" (expand "comp_pos") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "i!1") (("3" (expand "comp_pos") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "SP?") (("2" (skosimp) (("2" (expand "comp_pos") (("2" (expand "finseq_appl") (("2" (inst?) (("2" (lemma "replace_compose_pos") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (replace_replace_par_pos-1 nil 3569855862 ("" (measure-induct+ "length(fsp)" "fsp") (("1" (skosimp) (("1" (expand "replace_par_pos" 1) (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "comp_pos") (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (-1 2)) (("2" (expand "comp_pos") (("2" (propax) nil nil)) nil)) nil) ("3" (inst -1 "rest(x!1)" "rest(fst!1)" "q!1" "replaceTerm(s!1, fst!1`seq(0), x!1`seq(0))" "t!1") (("3" (rewrite "length_rest") (("3" (prop) (("1" (replaces -1) (("1" (lemma "replace_associativity") (("1" (inst?) (("1" (prop) (("1" (replace -1 2 rl) (("1" (expand "comp_pos" 2 2) (("1" (expand "finseq_appl") (("1" (rewrite "comp_pos_rest") nil nil)) nil)) nil)) nil) ("2" (expand "SPP?") (("2" (flatten) (("2" (hide-all-but (-3 1 4)) (("2" (expand "SP?") (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 4)) (("2" (expand "SPP?") (("2" (prop) (("1" (hide (-2 2)) (("1" (expand "PP?") (("1" (prop) (("1" (hide 2) (("1" (grind) nil nil)) nil) ("2" (skosimp) (("2" (expand "finseq_appl") (("2" (inst -1 "i!1 + 1" "j!1 + 1") (("1" (assert) (("1" (lemma "rest_pos[position]") (("1" (inst?) (("1" (assert) (("1" (expand "finseq_appl") (("1" (inst-cp -1 "i!1") (("1" (inst -1 "j!1") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "j!1") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "j!1") (("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "i!1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "PP?" "SP?") (("2" (expand "finseq_appl") (("2" (prop) (("1" (skosimp) (("1" (typepred "i!1") (("1" (hide (-3 1)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -1 "0" "i!1 + 1") (("1" (assert) (("1" (lemma "rest_pos[position]") (("1" (inst?) (("1" (assert) (("1" (expand "finseq_appl") (("1" (inst -1 "i!1") (("1" (replace -1 2 rl) (("1" (inst-cp -3 "0") (("1" (inst -3 "i!1 + 1") (("1" (lemma "replace_preserv_parallel_pos") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "comp_pos") (("2" (propax) nil nil)) nil)) nil) ("3" (hide-all-but (-1 -2 1)) (("3" (expand "SPP?") (("3" (prop) (("1" (hide -3) (("1" (expand "PP?") (("1" (prop) (("1" (hide (-2 2)) (("1" (expand "comp_pos") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (skosimp) (("2" (inst -1 "i!1" "j!1") (("1" (assert) (("1" (hide (-2 1 2 3)) (("1" (expand* "parallel" "comp_pos") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide 2) (("1" (expand "<=") (("1" (skosimp) (("1" (inst 1 "p1!1") (("1" (lemma "o_assoc[posnat]") (("1" (inst?) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (lemma "equal_prefix[posnat]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (expand "<=") (("2" (skosimp) (("2" (inst 1 "p1!1") (("2" (lemma "o_assoc[posnat]") (("2" (inst?) (("2" (replace -1 -2 rl) (("2" (hide -1) (("2" (lemma "equal_prefix[posnat]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "j!1") (("2" (expand "comp_pos") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "i!1") (("3" (expand "comp_pos") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "SP?") (("2" (skosimp) (("2" (expand "comp_pos") (("2" (expand "finseq_appl") (("2" (inst?) (("2" (lemma "replace_compose_pos") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-3 1)) (("4" (expand "comp_pos") (("4" (propax) nil nil)) nil)) nil) ("5" (hide (-3 2)) (("5" (expand "SPP?") (("5" (prop) (("1" (hide -3) (("1" (expand "PP?") (("1" (prop) (("1" (hide (-2 2)) (("1" (expand "comp_pos") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (skosimp) (("2" (inst -1 "i!1" "j!1") (("1" (assert) (("1" (hide (-2 1 2 3)) (("1" (expand* "parallel" "comp_pos") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide 2) (("1" (expand "<=") (("1" (skosimp) (("1" (inst 1 "p1!1") (("1" (lemma "o_assoc[posnat]") (("1" (inst?) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (lemma "equal_prefix[posnat]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (expand "<=") (("2" (skosimp) (("2" (inst 1 "p1!1") (("2" (lemma "o_assoc[posnat]") (("2" (inst?) (("2" (replace -1 -2 rl) (("2" (hide -1) (("2" (lemma "equal_prefix[posnat]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "j!1") (("2" (expand "comp_pos") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "i!1") (("3" (expand "comp_pos") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "SP?") (("2" (skosimp) (("2" (expand "comp_pos") (("2" (expand "finseq_appl") (("2" (inst?) (("2" (lemma "replace_compose_pos") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((j!1 skolem-const-decl "below[comp_pos(q!1, fsp!1)`length]" orthogonality_basis nil) (i!1 skolem-const-decl "below[comp_pos(q!1, fsp!1)`length]" orthogonality_basis nil) (fsp!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (q!1 skolem-const-decl "position[variable, symbol, arity]" orthogonality_basis nil) (i!1 skolem-const-decl "below[comp_pos(q!1, y!1)`length]" orthogonality_basis nil) (y!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (q!1 skolem-const-decl "position[variable, symbol, arity]" orthogonality_basis nil) (j!1 skolem-const-decl "below[comp_pos(q!1, y!1)`length]" orthogonality_basis nil) (o_assoc formula-decl nil finite_sequences nil) (equal_prefix formula-decl nil seq_extras structures) (O const-decl "finseq" finite_sequences nil) (<= const-decl "bool" positions nil) (parallel const-decl "bool" positions nil) (replace_compose_pos formula-decl nil replacement nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (i!1 skolem-const-decl "below[length(rest(x!1))]" orthogonality_basis nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (rest_pos formula-decl nil seq_extras structures) (j!1 skolem-const-decl "below[rest(x!1)`length]" orthogonality_basis nil) (i!1 skolem-const-decl "below[rest(x!1)`length]" orthogonality_basis nil) (x!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (^ const-decl "finseq" finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (PP? const-decl "bool" positions nil) (SP? const-decl "bool" positions nil) (comp_pos_rest formula-decl nil orthogonality_basis nil) (replace_associativity formula-decl nil replacement nil) (TRUE const-decl "bool" booleans nil) (length_rest formula-decl nil seq_extras structures) (rest const-decl "finseq" seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (SPP type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (SPP? const-decl "bool" positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (comp_pos const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (comp_pos_in_SP_preservs_SP_in_replace_TCC1 0 (comp_pos_in_SP_preservs_SP_in_replace_TCC1-1 nil 3568363668 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (comp_pos_in_SP_preservs_SP_in_replace subtype "0" "below[fsp`length]"))) (comp_pos_in_SP_preservs_SP_in_replace_TCC2 0 (comp_pos_in_SP_preservs_SP_in_replace_TCC2-1 nil 3568363668 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (fsp!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (fsp1!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (comp_pos_in_SP_preservs_SP_in_replace subtype "orthogonality_basis.fsp`seq(0)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(orthogonality_basis.t)"))) (comp_pos_in_SP_preservs_SP_in_replace 0 (comp_pos_in_SP_preservs_SP_in_replace-1 nil 3568364600 ("" (skeep) (("" (expand* SPP? SP? finseq_appl) (("" (flatten) (("" (skeep) (("" (expand o 1) (("" (expand* comp_pos finseq_appl) (("" (prop) (("1" (inst -3 0) (("1" (inst -4 i) (("1" (rewrite replace_compose_pos) nil nil)) nil)) nil) ("2" (typepred i) (("2" (expand* o comp_pos finseq_appl rest ^ min) (("2" (expand empty_seq -1) (("2" (lift-if) (("2" (assert) (("2" (prop) (("2" (inst-cp -3 "1 - fsp1`length + i") (("2" (inst -3 0) (("2" (rewrite replace_preserv_parallel_pos) (("2" (expand* PP? finseq_appl) (("2" (inst -2 0 "1 - fsp1`length + i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SP? const-decl "bool" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (SPP? const-decl "bool" positions nil) (comp_pos const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty_seq const-decl "finseq" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (PP? const-decl "bool" positions nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (term type-decl nil term_adt nil) (replace_compose_pos formula-decl nil replacement nil) (rest const-decl "finseq" seq_extras structures) (O const-decl "finseq" finite_sequences nil)) shostak)) (comp_pos_in_SPP_preservs_SPP_in_replace_TCC1 0 (comp_pos_in_SPP_preservs_SPP_in_replace_TCC1-1 nil 3568364731 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (comp_pos_in_SPP_preservs_SPP_in_replace subtype "0" "below[fsp`length]"))) (comp_pos_in_SPP_preservs_SPP_in_replace_TCC2 0 (comp_pos_in_SPP_preservs_SPP_in_replace_TCC2-1 nil 3568364731 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (fsp!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (fsp1!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (comp_pos_in_SPP_preservs_SPP_in_replace subtype "orthogonality_basis.fsp`seq(0)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(orthogonality_basis.t)"))) (comp_pos_in_SPP_preservs_SPP_in_replace 0 (comp_pos_in_SPP_preservs_SPP_in_replace-1 nil 3568367426 ("" (skeep) (("" (expand SPP?) (("" (flatten) (("" (rewrite comp_pos_in_PP_preservs_PP) (("" (rewrite comp_pos_in_SP_preservs_SP_in_replace) (("" (expand SPP?) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SPP? const-decl "bool" positions nil) (comp_pos_in_PP_preservs_PP formula-decl nil orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (term type-decl nil term_adt nil) (comp_pos_in_SP_preservs_SP_in_replace formula-decl nil orthogonality_basis nil)) shostak)) (comp_pos_in_SPP_preservs_SPP_in_replace_par_pos_TCC1 0 (comp_pos_in_SPP_preservs_SPP_in_replace_par_pos_TCC1-1 nil 3568369310 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (comp_pos_in_SPP_preservs_SPP_in_replace_par_pos subtype "0" "below[fst`length]"))) (comp_pos_in_SPP_preservs_SPP_in_replace_par_pos_TCC2 0 (comp_pos_in_SPP_preservs_SPP_in_replace_par_pos_TCC2-1 nil 3568369310 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil) (/= const-decl "boolean" notequal nil)) nil (comp_pos_in_SPP_preservs_SPP_in_replace_par_pos subtype "orthogonality_basis.fst" "{fst | orthogonality_basis.fst`length = orthogonality_basis.fsp`length}"))) (comp_pos_in_SPP_preservs_SPP_in_replace_par_pos 0 (comp_pos_in_SPP_preservs_SPP_in_replace_par_pos-1 nil 3568369310 ("" (skeep) (("" (expand SPP?) (("" (flatten) (("" (split) (("1" (hide -1 -2 -5 -7) (("1" (expand* add_first insert? o comp_pos finseq_appl) (("1" (expand* PP? finseq_appl) (("1" (assert) (("1" (prop) (("1" (skeep 2) (("1" (typepred (i j)) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep 3) (("2" (typepred (i j)) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (inst -4 0 "j - fsp1`length + 1") (("1" (assert) (("1" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil) ("2" (rewrite parallel_comm) (("2" (inst -3 0 "i - fsp1`length + 1") (("2" (assert) (("2" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (skeep 4) (("4" (typepred (i j)) (("4" (lift-if) (("4" (lift-if) (("4" (lift-if) (("4" (assert) (("4" (prop) (("1" (inst -4 0 "j - fsp1`length + 1") (("1" (assert) (("1" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil) ("2" (rewrite parallel_comm) (("2" (inst -4 0 "i - fsp1`length + 1") (("2" (assert) (("2" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil)) nil) ("3" (inst -4 "i - fsp1`length" "j - fsp1`length") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep 3) (("5" (typepred (i j)) (("5" (lift-if) (("5" (lift-if) (("5" (lift-if) (("5" (assert) (("5" (inst -5 i j) (("5" (assert) (("5" (rewrite comp_preservs_parallel_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep 4) (("6" (typepred (i j)) (("6" (lift-if) (("6" (lift-if) (("6" (lift-if) (("6" (assert) (("6" (prop) (("1" (inst -7 i j) (("1" (rewrite comp_preservs_parallel_pos) nil nil)) nil) ("2" (inst -4 0 "j - fsp1`length + 1") (("1" (assert) (("1" (rewrite comp_preservs_parallel_pos2) nil nil)) nil) ("2" (assert) nil nil)) nil) ("3" (rewrite parallel_comm) (("3" (inst -3 0 "i - fsp1`length + 1") (("3" (assert) (("3" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (assert) nil nil) ("8" (skeep 5) (("8" (typepred (i j)) (("8" (lift-if) (("8" (lift-if) (("8" (lift-if) (("8" (assert) (("8" (prop) (("1" (inst -7 i j) (("1" (assert) (("1" (rewrite comp_preservs_parallel_pos) nil nil)) nil)) nil) ("2" (inst -4 0 "j - fsp1`length + 1") (("1" (assert) (("1" (rewrite comp_preservs_parallel_pos2) nil nil)) nil) ("2" (assert) nil nil)) nil) ("3" (rewrite parallel_comm) (("3" (inst -4 0 "i - fsp1`length + 1") (("3" (assert) (("3" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil)) nil) ("4" (inst -4 "i - fsp1`length" "j - fsp1`length") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4 -6) (("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (typepred i) (("2" (expand* o comp_pos finseq_appl) (("2" (prop) (("1" (lemma replace_par_pos_preservs_PP) (("1" (inst -1 fsp fst t) (("1" (expand* SPP? SP? finseq_appl) (("1" (assert) (("1" (prop) (("1" (inst -1 0) (("1" (lemma replace_par_pos_subterm) (("1" (inst -1 fsp fst t) (("1" (expand* SPP? SP? finseq_appl) (("1" (prop) (("1" (inst -1 0) (("1" (inst -8 i) (("1" (rewrite pos_o_term) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -6 "i - fsp1`length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SPP? const-decl "bool" positions nil) (insert? const-decl "finseq" seq_extras structures) (comp_pos const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (add_first const-decl "finseq" seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (j skolem-const-decl "below[fsp1`length + fsp2`length]" orthogonality_basis nil) (i skolem-const-decl "below[fsp1`length + fsp2`length]" orthogonality_basis nil) (j skolem-const-decl "below[fsp1`length + fsp2`length]" orthogonality_basis nil) (comp_preservs_parallel_pos formula-decl nil positions nil) (j skolem-const-decl "below[fsp1`length + fsp2`length]" orthogonality_basis nil) (i skolem-const-decl "below[fsp1`length + fsp2`length]" orthogonality_basis nil) (fsp2 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (fsp1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (comp_preservs_parallel_pos2 formula-decl nil positions nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (parallel_comm formula-decl nil positions nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (PP? const-decl "bool" positions nil) (SP? const-decl "bool" positions nil) (term type-decl nil term_adt nil) (pos_o_term formula-decl nil subterm nil) (SPP type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (replace_par_pos_subterm formula-decl nil orthogonality_basis nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (fsp skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (i skolem-const-decl "below[length(comp_pos(fsp`seq(0), fsp1) o fsp2)]" orthogonality_basis nil)) shostak)) (parallel_reduction_reflexive 0 (parallel_reduction_reflexive-1 nil 3569858198 ("" (skeep) (("" (expand reflexive?) (("" (skeep) (("" (expand* parallel_reduction? parallel_reduction_fix?) (("" (inst 1 "empty_seq" "empty_seq" "empty_seq") (("1" (expand empty_seq) (("1" (split) (("1" (expand* subtermsOF sigma_lhs) (("1" (expand empty_seq) (("1" (decompose-equality) (("1" (skeep) nil nil)) nil)) nil)) nil) ("2" (expand replace_par_pos) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma predicate_fseq2set[rewrite_rule].subset_empty_seq) (("2" (inst?) nil nil)) nil) ("3" (expand empty_seq) (("3" (expand* SPP? SP? PP?) (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((reflexive? const-decl "bool" relations nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (parallel_reduction? const-decl "bool" orthogonality_basis nil) (PP? const-decl "bool" positions nil) (SP? const-decl "bool" positions nil) (subset_empty_seq formula-decl nil predicate_fseq2set nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (sigma_lhs const-decl "finseq[term]" orthogonality_basis nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (< const-decl "bool" reals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (pred type-eq-decl nil defined_types nil) (epsilon const-decl "T" epsilons nil) (TRUE const-decl "bool" booleans nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (FALSE const-decl "bool" booleans nil) (SPP type-eq-decl nil positions nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" predicate_fseq2set nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" orthogonality_basis nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (term type-decl nil term_adt nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (SPP? const-decl "bool" positions nil) (x skolem-const-decl "term[variable, symbol, arity]" orthogonality_basis nil) (empty_seq const-decl "finseq" finite_sequences nil)) shostak)) (non_ambiguous_implies_same_term 0 (non_ambiguous_implies_same_term-1 nil 3567344810 ("" (skeep) (("" (expand reduction_fix?) (("" (skosimp*) (("" (lemma ntCP_lemma_aux1) (("" (inst -1 sigma!1 sigma!2 E empty_seq e!1 e!2) (("" (expand empty_seq -1) (("" (expand subtermOF -1) (("" (expand replaceTerm -1) (("" (prop) (("1" (skosimp) (("1" (expand Ambiguous?) (("1" (inst 1 t1!1 t2!1) nil nil)) nil)) nil) ("2" (expand positionsOF 1) (("2" (expand only_empty_seq) (("2" (lift-if) (("2" (assert) (("2" (expand empty_seq 1) (("2" (expand union) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred e!1) (("3" (expand rewrite_rule?) (("3" (expand lhs -3) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) (("5" (lemma same_substitution) (("5" (inst -1 sigma!1 sigma!2 "lhs(e!2)") (("5" (assert) (("5" (replaces -2) (("5" (lemma same_term) (("5" (inst -1 sigma!1 sigma!2 "rhs(e!2)") (("5" (prop) (("1" (assert) nil nil) ("2" (typepred e!2) (("2" (expand rewrite_rule?) (("2" (flatten) (("2" (expand subset?) (("2" (expand* rhs lhs) (("2" (skeep) (("2" (inst -1 x) (("2" (inst -4 x) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((reduction_fix? const-decl "bool" reduction nil) (ntCP_lemma_aux1 formula-decl nil orthogonality_basis nil) (replaceTerm def-decl "term" replacement nil) (TRUE const-decl "bool" booleans nil) (rhs const-decl "term" rewrite_rules nil) (subset? const-decl "bool" sets nil) (same_term formula-decl nil substitution nil) (same_substitution formula-decl nil substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (lhs const-decl "term" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (union const-decl "set" sets nil) (only_empty_seq const-decl "positions" positions nil) (Ambiguous? const-decl "bool" orthogonality_basis nil) (subtermOF def-decl "term" subterm nil) (member const-decl "bool" sets nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil)) shostak)) (parallel_reduction_context_aux_TCC1 0 (parallel_reduction_context_aux_TCC1-1 nil 3567754876 ("" (subtype-tcc) nil nil) ((finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil)) nil (parallel_reduction_context_aux subtype "orthogonality_basis.i" "below[length(fst2)]"))) (parallel_reduction_context_aux 0 (parallel_reduction_context_aux-1 nil 3567754877 ("" (measure-induct "fsp`length" fsp) (("1" (skeep) (("1" (skeep) (("1" (case "x`length=0") (("1" (expand finseq_appl) (("1" (inst 1 empty_seq) (("1" (split) (("1" (expand replace_par_pos 1) (("1" (assert) (("1" (expand parallel_reduction_fix? 1) (("1" (inst 1 empty_seq empty_seq) (("1" (expand empty_seq) (("1" (split) (("1" (expand* subtermsOF sigma_lhs) (("1" (expand empty_seq) (("1" (decompose-equality) (("1" (skeep) nil nil)) nil)) nil)) nil) ("2" (expand replace_par_pos 1) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite subset_empty_seq) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but 1) (("2" (expand empty_seq 1) (("2" (expand add_first 1) (("2" (expand insert?) (("2" (expand PP? 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand empty_seq 1) (("2" (expand SPP? 1) (("2" (expand PP? 1) (("2" (expand* SP? finseq_appl) (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x)") (("2" (rewrite length_rest) (("2" (expand replace_par_pos 2) (("2" (assert) (("2" (expand finseq_appl) (("2" (inst -1 E "rest(fst1)" "rest(fst2)" "replaceTerm(t, fst1`seq(0), x`seq(0))") (("1" (prop) (("1" (skosimp) (("1" (inst -6 0) (("1" (expand parallel_reduction? -6) (("1" (skosimp) (("1" (inst 2 "comp_pos(x`seq(0),fsp!1) o fsq!1") (("1" (split) (("1" (expand parallel_reduction_fix?) (("1" (skosimp*) (("1" (inst 1 "fse!2 o fse!1" "fss!2 o fss!1") (("1" (expand o 1 (1 2 3 4)) (("1" (rewrite comp_pos_preservs_length) (("1" (assert) (("1" (prop) (("1" (decompose-equality 1) (("1" (expand subtermsOF 1) (("1" (expand sigma_lhs 1) (("1" (expand o 1) (("1" (expand empty_seq) (("1" (expand comp_pos 1) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand subtermsOF 1) (("2" (expand sigma_lhs 1) (("2" (expand finseq_appl) (("2" (lift-if) (("2" (expand empty_seq) (("2" (typepred x!1) (("2" (expand subtermsOF -1) (("2" (expand o -1) (("2" (expand comp_pos -1) (("2" (expand o 1 1) (("2" (assert) (("2" (expand o 1) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (expand comp_pos 1) (("2" (expand finseq_appl) (("2" (prop) (("1" (expand subtermsOF -13) (("1" (expand sigma_lhs -13) (("1" (expand empty_seq) (("1" (assert) (("1" (decompose-equality -13) (("1" (inst -1 x!1) (("1" (expand finseq_appl) (("1" (rewrite replace_par_pos_preservs_subterm) (("1" (rewrite replace_embedding) (("1" (hide-all-but (-9 1)) (("1" (expand* SPP? SP? finseq_appl) (("1" (flatten) (("1" (inst -2 0) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred fsp!1) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 x!1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand SPP? 1) (("2" (split) (("1" (rewrite add_first_parallel_pos_to_PP_is_PP 1) (("1" (expand finseq_appl) (("1" (skosimp) (("1" (typepred i!1) (("1" (expand rest (-1 1)) (("1" (expand* ^ min) (("1" (expand empty_seq -1) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (hide -7 -8) (("1" (expand SPP? -8) (("1" (expand PP? -8) (("1" (expand finseq_appl) (("1" (assert) (("1" (flatten) (("1" (inst -8 0 1+i!1) (("1" (assert) (("1" (rewrite parallel_comm 3) (("1" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite rest_of_PP_is_PP) (("2" (expand SPP? -9) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide -6 -7) (("2" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (typepred fsp!1) (("1" (expand SPP? (-1 -8)) (("1" (flatten) (("1" (hide 2) (("1" (expand* SP? finseq_appl) (("1" (inst -2 x!1) (("1" (inst -10 0) (("1" (rewrite replace_compose_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand SPP? -7) (("2" (flatten) (("2" (expand* SP? finseq_appl) (("2" (skosimp) (("2" (typepred i!1) (("2" (expand rest (-1 1)) (("2" (expand* ^ min) (("2" (expand empty_seq -1) (("2" (lift-if) (("2" (assert) (("2" (prop) (("2" (inst-cp -9 1+i!1) (("2" (inst -9 0) (("2" (expand PP? -8) (("2" (expand finseq_appl) (("2" (assert) (("2" (rewrite replace_preserv_parallel_pos 3) (("2" (inst -8 0 1+i!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-10 1 3)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred fsp!1) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 x!2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5) (("2" (expand subtermsOF -4) (("2" (expand sigma_lhs -4) (("2" (expand empty_seq) (("2" (expand finseq_appl) (("2" (lift-if) (("2" (assert) (("2" (decompose-equality -4) (("1" (inst -1 "x!1 - fss!2`length") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred fsq!1) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 x1!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite sigma_rhs_o 1) (("2" (rewrite replace_par_pos_comp_commute 1) (("1" (replaces -12) (("1" (rewrite replace_replace_par_pos 1) (("1" (rewrite replace_par_pos_comp 1) (("1" (lemma replace_par_pos_comp) (("1" (inst -1 "comp_pos(x`seq(0), fsp!1)" "rest(x)" "sigma_rhs(fss!2, fse!2)" "rest(fst2)" "replaceTerm(t, fst1`seq(0), x`seq(0))") (("1" (prop) (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (rewrite replace_par_pos_comp_commute 1) (("1" (rewrite replace_par_pos_comp 1) (("1" (assert) nil nil) ("2" (hide (-4 2)) (("2" (lemma "comp_pos_in_PP_preservs_PP") (("2" (inst?) (("2" (typepred "fsp!1") (("2" (expand SPP? (-1 -7)) (("2" (prop) (("1" (expand "SPP?") (("1" (split) (("1" (hide-all-but (-1 1)) (("1" (lemma predicate_fseq2set[position].pred_bin_comp) (("1" (inst -1 "parallel" "comp_pos(x`seq(0), fsp!1)" "rest(x)") (("1" (prop) (("1" (hide -2) (("1" (expand* PP? PSeq?) nil nil)) nil) ("2" (hide 2) (("2" (expand* PP? PSeq?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma predicate_fseq2set[position].subset_comp) (("2" (inst -1 "positionsOF(replaceTerm(t, fst1`seq(0), x`seq(0)))" "comp_pos(x`seq(0), fsp!1)" "rest(x)") (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand* subset? SP? finseq_appl) (("1" (skosimp) (("1" (expand* subset? member seq2set finseq_appl) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand subset?) (("2" (expand* subset? member seq2set finseq_appl) (("2" (skosimp*) (("2" (replace -1 1 rl) (("2" (lemma "comp_pos_in_SPP_preservs_SPP_in_replace") (("2" (inst -1 "x" "fsp!1" "fst1`seq(0)" "t") (("2" (expand "SPP?") (("2" (prop) (("2" (expand "SP?" -2) (("2" (expand "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-8 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-9 -10 1)) (("4" (expand sigma_rhs) (("4" (expand comp_pos) (("4" (lift-if) (("4" (expand empty_seq) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite comp_pos_in_SPP_preservs_SPP_in_replace) nil nil) ("3" (hide-all-but (-9 -10 1)) (("3" (expand* sigma_rhs empty_seq comp_pos) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (-8 1)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite comp_pos_in_SPP_preservs_SPP_in_replace) nil nil) ("3" (hide-all-but (-9 -10 1)) (("3" (expand* sigma_rhs empty_seq comp_pos) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (-8 1)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 2) (("2" (lemma comp_pos_in_SPP_preservs_SPP_in_replace_par_pos) (("2" (inst -1 x fsp!1 fsq!1 fst1 t) (("2" (assert) (("2" (inst -4 "x`seq(0)") (("1" (expand replace_par_pos -1) (("1" (expand finseq_appl) (("1" (lemma seq_first_rest[position]) (("1" (inst -1 x) (("1" (assert) (("1" (expand* first finseq_appl) (("1" (expand SPP? -6) (("1" (flatten) (("1" (replace -1 -5 rl) (("1" (assert) (("1" (prop) (("1" (expand "SPP?") (("1" (hide-all-but (-1 1)) (("1" (flatten) (("1" (split) (("1" (hide -2) (("1" (lemma predicate_fseq2set[position].pred_bin_comp) (("1" (inst -1 "parallel" "comp_pos(x`seq(0), fsp!1)" "fsq!1") (("1" (split) (("1" (hide -2) (("1" (expand* PP? PSeq?) nil nil)) nil) ("2" (hide 2) (("2" (expand* PP? PSeq?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma predicate_fseq2set[position].subset_comp) (("2" (inst -1 "positionsOF(replace_par_pos(replaceTerm(t, fst1`seq(0), x`seq(0)), rest(x),rest(fst1)))" "comp_pos(x`seq(0), fsp!1)" "fsq!1") (("2" (split) (("1" (hide -2) (("1" (expand* subset? SP? finseq_appl) (("1" (skosimp) (("1" (expand* subset? member seq2set finseq_appl) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* subset? SP? finseq_appl) (("2" (expand* subset? member seq2set finseq_appl) (("2" (skosimp*) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1 3)) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 0) (("2" (rewrite replace_preserv_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2 1)) (("3" (expand* sigma_rhs empty_seq) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (-9 -10 1)) (("4" (expand* sigma_rhs empty_seq comp_pos) (("4" (lift-if) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 0) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-9 -10 1)) (("3" (expand* sigma_rhs empty_seq) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 -11 2) (("2" (lemma comp_pos_in_SPP_preservs_SPP_in_replace_par_pos) (("2" (inst -1 x fsp!1 fsq!1 fst1 t) (("2" (expand replace_par_pos -1) (("2" (expand finseq_appl) (("2" (inst -3 "x`seq(0)") (("1" (prop) (("1" (lemma seq_first_rest[position]) (("1" (inst -1 x) (("1" (assert) (("1" (expand* first finseq_appl) (("1" (expand SPP? -4) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (rewrite replace_preserv_pos) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-9 -10 1)) (("3" (expand* sigma_rhs empty_seq comp_pos) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 -2 1)) (("4" (expand* sigma_rhs empty_seq) (("4" (lift-if) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred (fse!1 fse!2)) (("2" (expand subset?) (("2" (lemma sets_lemmas[rewrite_rule].union_upper_bound) (("2" (inst -1 "seq2set(fse!2)" "seq2set(fse!1)" "E") (("2" (assert) (("2" (hide (-2 -3)) (("2" (lemma predicate_fseq2set[rewrite_rule].comp_subset) (("2" (inst?) (("2" (lemma sets_lemmas[rewrite_rule].subset_transitive) (("2" (inst -1 "seq2set(fse!2 o fse!1)" "union(seq2set(fse!2), seq2set(fse!1))" "E") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (lemma comp_pos_in_SPP_preservs_SPP_in_replace_par_pos) (("2" (inst -1 x fsp!1 fsq!1 fst1 t) (("2" (assert) (("2" (expand replace_par_pos -1 1) (("2" (expand finseq_appl) (("2" (prop) (("1" (expand SPP? -1) (("1" (flatten) (("1" (hide -2 -4 -7 -8 -9) (("1" (expand* add_first comp_pos rest ^ min empty_seq finseq_appl) (("1" (expand o -1 2) (("1" (expand o 1 2) (("1" (expand* insert? finseq_appl) (("1" (expand* PP? finseq_appl) (("1" (assert) (("1" (prop) (("1" (skosimp) (("1" (typepred (i!1 j!1)) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (hide -7) (("1" (rewrite parallel_comm) (("1" (inst -6 1 0) (("1" (assert) (("1" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -6 p!1) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (inst -2 0 "j!1-fsp!1`length") (("1" (assert) nil nil)) nil) ("2" (inst -2 0 "j!1-fsp!1`length") (("2" (assert) nil nil)) nil) ("3" (inst -1 0 "j!1-fsp!1`length") (("3" (assert) nil nil)) nil) ("4" (skosimp) (("4" (lift-if) (("4" (assert) (("4" (prop) (("1" (inst -6 0 j!2+1) (("1" (assert) nil nil) ("2" (typepred j!2) (("2" (assert) nil nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (inst -6 1+i!2 0) (("1" (assert) nil nil) ("2" (typepred i!2) (("2" (assert) nil nil)) nil)) nil) ("2" (inst -5 1+i!2 1+j!2) (("1" (assert) nil nil) ("2" (typepred j!2) (("2" (assert) nil nil)) nil) ("3" (typepred i!2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred p!1) (("2" (inst -6 1 0) (("2" (assert) (("2" (rewrite replace_preserv_parallel_pos 1) (("2" (hide-all-but (-7 1)) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -7) (("3" (inst -6 1 0) (("3" (assert) (("3" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil)) nil) ("4" (hide -6 -7) (("4" (assert) nil nil)) nil) ("5" (assert) nil nil) ("6" (inst -6 p!1) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (inst -2 "i!1-fsp!1`length" 0) (("1" (assert) nil nil)) nil) ("2" (inst -2 "i!1-fsp!1`length" 0) (("2" (assert) nil nil)) nil) ("3" (inst -1 "i!1-fsp!1`length" 0) (("3" (assert) nil nil)) nil) ("4" (skosimp) (("4" (typepred (i!2 j!2)) (("4" (lift-if) (("4" (lift-if) (("4" (lift-if) (("4" (assert) (("4" (prop) (("1" (inst -8 0 1+j!2) (("1" (assert) nil nil)) nil) ("2" (inst -8 1+i!2 0) (("2" (assert) nil nil)) nil) ("3" (inst -7 1+i!2 1+j!2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -5 1 0) (("2" (assert) (("2" (typepred p!1) (("2" (rewrite replace_preserv_parallel_pos) (("2" (hide-all-but (-7 1)) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (assert) nil nil) ("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (rewrite parallel_comm) (("1" (inst -4 1 0) (("1" (assert) (("1" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil)) nil) ("2" (inst -4 p!1) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (inst -2 0 "j!1-fsp!1`length") (("1" (assert) nil nil)) nil) ("2" (inst -2 0 "j!1-fsp!1`length") (("2" (assert) nil nil)) nil) ("3" (inst -1 0 "j!1-fsp!1`length") (("3" (assert) nil nil)) nil) ("4" (skosimp) (("4" (typepred (i!2 j!2)) (("4" (lift-if) (("4" (assert) (("4" (prop) (("1" (inst -6 0 j!2+1) (("1" (assert) nil nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (inst -6 1+i!2 0) (("1" (assert) nil nil)) nil) ("2" (inst -5 1+i!2 1+j!2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred p!1) (("2" (inst -4 1 0) (("2" (assert) (("2" (rewrite replace_preserv_parallel_pos 1) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -6 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -5) (("3" (inst -4 1 0) (("3" (assert) (("3" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil)) nil) ("4" (hide -3 -4 -5) (("4" (typepred fsp!1) (("4" (expand* SPP? PP? finseq_appl) (("4" (assert) (("4" (flatten) (("4" (inst -1 i!1-1 j!1-1) (("4" (assert) (("4" (rewrite comp_preservs_parallel_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide -3 -4) (("5" (typepred (i!1 j!1)) (("5" (inst -4 i!1-1 "j!1-1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("6" (inst -4 p!1) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (inst -2 "i!1-fsp!1`length" 0) (("1" (assert) nil nil)) nil) ("2" (inst -2 "i!1-fsp!1`length" 0) (("2" (assert) nil nil)) nil) ("3" (inst -1 "i!1-fsp!1`length" 0) (("3" (assert) nil nil)) nil) ("4" (skosimp) (("4" (typepred (i!2 j!2)) (("4" (lift-if) (("4" (lift-if) (("4" (lift-if) (("4" (assert) (("4" (prop) (("1" (inst -6 0 1+j!2) (("1" (assert) nil nil)) nil) ("2" (inst -6 1+i!2 0) (("2" (assert) nil nil)) nil) ("3" (inst -5 1+i!2 1+j!2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -3 1 0) (("2" (assert) (("2" (typepred p!1) (("2" (rewrite replace_preserv_parallel_pos) (("2" (hide-all-but (-5 1)) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide -3 -4) (("7" (inst -2 i!1-1 j!1-1) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("8" (hide -1 -2 -3) (("8" (typepred fsq!1) (("8" (expand SPP? -1) (("8" (flatten) (("8" (expand* PP? finseq_appl) (("8" (assert) (("8" (typepred (i!1 j!1)) (("8" (inst -3 "i!1-1-fsp!1`length" "j!1-1-fsp!1`length") (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "x`seq(0)") (("1" (prop) (("1" (lemma seq_first_rest[position]) (("1" (inst -1 x) (("1" (expand* first finseq_appl) (("1" (expand SPP?) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite replace_preserv_pos) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -4 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma comp_pos_in_SPP_preservs_SPP_in_replace_par_pos) (("2" (inst -1 x fsp!1 fsq!1 fst1 t) (("2" (assert) (("2" (expand replace_par_pos 1) (("2" (expand finseq_appl) (("2" (inst -2 "x`seq(0)") (("1" (prop) (("1" (lemma seq_first_rest[position]) (("1" (inst -1 x) (("1" (expand* first finseq_appl) (("1" (expand SPP? -3) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite replace_preserv_pos) (("2" (expand SPP? -2) (("2" (flatten) (("2" (expand* SP? finseq_appl) (("2" (inst -3 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand SPP?) (("2" (hide 3) (("2" (flatten) (("2" (rewrite rest_of_PP_is_PP) (("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (typepred i) (("2" (expand rest (-1 1)) (("2" (expand* ^ min) (("2" (expand empty_seq -1) (("2" (lift-if) (("2" (assert) (("2" (prop) (("2" (expand* PP? finseq_appl) (("2" (rewrite replace_preserv_parallel_pos) (("1" (inst -3 1+i) nil nil) ("2" (inst -3 0) nil nil) ("3" (inst -2 0 1+i) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1 2)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-3 1 2)) (("4" (grind) nil nil)) nil) ("5" (hide 3) (("5" (skeep) (("5" (typepred i) (("5" (expand rest (-1 1)) (("5" (expand* ^ min) (("5" (expand empty_seq -1) (("5" (lift-if) (("5" (lift-if) (("5" (lift-if) (("5" (assert) (("5" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil) ("7" (inst -5 1+i) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil) ((t skolem-const-decl "term" orthogonality_basis nil) (x skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (fst1 skolem-const-decl "finseq[term]" orthogonality_basis nil) (empty_seq const-decl "finseq" finite_sequences nil) (insert? const-decl "finseq" seq_extras structures) (subset_empty_seq formula-decl nil predicate_fseq2set nil) (sigma_lhs const-decl "finseq[term]" orthogonality_basis nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (epsilon const-decl "T" epsilons nil) (TRUE const-decl "bool" booleans nil) (subtermOF def-decl "term" subterm nil) (FALSE const-decl "bool" booleans nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" orthogonality_basis nil) (subset? const-decl "bool" predicate_fseq2set nil) (SP? const-decl "bool" positions nil) (length_rest formula-decl nil seq_extras structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (replaceTerm def-decl "term" replacement nil) (i skolem-const-decl "below[rest(x)`length]" orthogonality_basis nil) (O const-decl "finseq" finite_sequences nil) (comp_pos const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (fsp!1 skolem-const-decl "SPP[variable, symbol, arity](fst1`seq(0))" orthogonality_basis nil) (fsq!1 skolem-const-decl "SPP[variable, symbol, arity](replace_par_pos(replaceTerm
                                             (t, fst1`seq(0), x`seq(0)),
                                             rest(x),
                                             rest(fst1)))" orthogonality_basis nil) (j!2 skolem-const-decl "below[IF 1 > x`length - 1 OR 1 >= x`length THEN 0 ELSE x`length - 1 ENDIF +
       1]" orthogonality_basis nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (i!2 skolem-const-decl "below[IF 1 > x`length - 1 OR 1 >= x`length THEN 0 ELSE x`length - 1 ENDIF +
       1]" orthogonality_basis nil) (int_plus_int_is_int application-judgement "int" integers nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](t)" orthogonality_basis nil) (i!1 skolem-const-decl "below[1 + fsp!1`length + fsq!1`length]" orthogonality_basis nil) (j!1 skolem-const-decl "below[1 + fsp!1`length + fsq!1`length]" orthogonality_basis nil) (comp_preservs_parallel_pos formula-decl nil positions nil) (fse!2 skolem-const-decl "{fse | subset?(fse, E)}" orthogonality_basis nil) (fse!1 skolem-const-decl "{fse | subset?(fse, E)}" orthogonality_basis nil) (comp_pos_preservs_length formula-decl nil orthogonality_basis nil) (NOT const-decl "[bool -> bool]" booleans nil) (replace_par_pos_preservs_subterm formula-decl nil orthogonality_basis nil) (replace_embedding formula-decl nil replacement nil) (rest_of_PP_is_PP formula-decl nil positions nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (^ const-decl "finseq" finite_sequences nil) (comp_preservs_parallel_pos2 formula-decl nil positions nil) (parallel_comm formula-decl nil positions nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (add_first_parallel_pos_to_PP_is_PP formula-decl nil positions nil) (PP type-eq-decl nil positions nil) (add_first_parallel_pos_to_SP_is_SP formula-decl nil positions nil) (replace_compose_pos formula-decl nil replacement nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (ext def-decl "term" substitution nil) (lhs const-decl "term" rewrite_rules nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (SP type-eq-decl nil positions nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (replace_par_pos_comp_commute formula-decl nil orthogonality_basis nil) (replace_replace_par_pos formula-decl nil orthogonality_basis nil) (first const-decl "T" seq_extras structures) (seq_first_rest formula-decl nil seq_extras structures) (replace_preserv_pos formula-decl nil replacement nil) (comp_pos_in_SPP_preservs_SPP_in_replace_par_pos formula-decl nil orthogonality_basis nil) (comp_pos_in_PP_preservs_PP formula-decl nil orthogonality_basis nil) (pred_bin_comp formula-decl nil predicate_fseq2set nil) (PSeq? const-decl "bool" predicate_fseq2set nil) (PRED type-eq-decl nil defined_types nil) (parallel const-decl "bool" positions nil) (comp_pos_in_SPP_preservs_SPP_in_replace formula-decl nil orthogonality_basis nil) (below type-eq-decl nil naturalnumbers nil) (subset? const-decl "bool" sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (member const-decl "bool" sets nil) (subset_comp formula-decl nil predicate_fseq2set nil) (replace_par_pos_comp formula-decl nil orthogonality_basis nil) (sigma_rhs_o formula-decl nil orthogonality_basis nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (union_upper_bound formula-decl nil sets_lemmas nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (comp_subset formula-decl nil predicate_fseq2set nil) (subset_transitive formula-decl nil sets_lemmas nil) (finite_union application-judgement "finite_set[rewrite_rule[variable, symbol, arity]]" orthogonality_basis nil) (union const-decl "set" sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (rest const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (PP? const-decl "bool" positions nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (SPP type-eq-decl nil positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (parallel_reduction? const-decl "bool" orthogonality_basis nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (SPP? const-decl "bool" positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (parallel_reduction_context 0 (parallel_reduction_context-1 nil 3567763121 ("" (skeep) (("" (lemma parallel_reduction_context_aux) (("" (expand finseq_appl) (("" (inst -1 E fsp fst1 fst2 t) (("" (assert) (("" (prop) (("" (skolem -1 fsq) (("" (flatten) (("" (expand parallel_reduction? 1) (("" (inst 1 fsq) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((parallel_reduction_context_aux formula-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (= const-decl "[T, T -> boolean]" equalities nil) (SPP type-eq-decl nil positions nil) (SPP? const-decl "bool" positions nil) (parallel_reduction? const-decl "bool" orthogonality_basis nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak)) (replace_par_pos_of_app_is_app 0 (replace_par_pos_of_app_is_app-1 nil 3575200221 ("" (measure-induct "fsp`length" fsp) (("" (skeep) (("" (skeep) (("" (case "x`length=0") (("1" (hide -2) (("1" (expand replace_par_pos) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "#" 2) (("2" (expand replace_par_pos 3) (("2" (assert) (("2" (expand finseq_appl) (("2" (inst -1 "rest(x)") (("2" (rewrite length_rest) (("2" (inst -1 "rest(fst)" "replaceTerm(t, fst`seq(0), x`seq(0))") (("2" (prop) (("1" (expand "#" -1) (("1" (decompose-equality -1) (("1" (decompose-equality -2) (("1" (hide 2 3) (("1" (inst -1 0) (("1" (expand rest (-1 -2)) (("1" (expand* ^ min) (("1" (expand empty_seq -2) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (expand* SPP? PP? finseq_appl) (("1" (flatten) (("1" (assert) (("1" (inst -4 0 1) (("1" (assert) (("1" (expand parallel) (("1" (flatten) (("1" (expand <= 7) (("1" (inst 7 "x`seq(0)") (("1" (replaces -2) (("1" (rewrite empty_o_seq) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (assert) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (decompose-equality 3) (("1" (expand* SPP? PP? finseq_appl) (("1" (flatten) (("1" (inst -2 0 1) (("1" (assert) (("1" (case "x`seq(0)=empty_seq") (("1" (replaces -1) (("1" (expand parallel) (("1" (flatten) (("1" (expand <= 4) (("1" (inst 4 "x`seq(1)") (("1" (rewrite empty_o_seq) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand replaceTerm 3) (("2" (expand empty_seq 1) (("2" (lift-if) (("2" (assert) (("2" (decompose-equality 1) (("2" (decompose-equality 1) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand replaceTerm 2) (("2" (expand finseq_appl) (("2" (lift-if) (("2" (prop) (("1" (case "x`length=1") (("1" (decompose-equality 2) (("1" (typepred x!1) (("1" (rewrite empty_0 -3) nil nil)) nil) ("2" (skeep) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand* SPP? PP? finseq_appl) (("2" (flatten) (("2" (assert) (("2" (inst -3 0 1) (("2" (expand parallel) (("2" (flatten) (("2" (rewrite empty_0 -1) (("2" (replaces -1) (("2" (expand <= 5) (("2" (inst 5 "x`seq(1)") (("2" (rewrite empty_o_seq) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand SPP?) (("3" (rewrite rest_of_PP_is_PP) (("3" (hide 3 4) (("3" (flatten) (("3" (expand* rest ^ min empty_seq SP? finseq_appl) (("3" (assert) (("3" (prop) (("1" (skeep) nil nil) ("2" (skeep) nil nil) ("3" (skeep) (("3" (expand* PP? finseq_appl) (("3" (inst -2 0 1+i) (("3" (rewrite replace_preserv_parallel_pos) (("1" (inst -3 1+i) nil nil) ("2" (inst -3 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-3 1)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (length_rest formula-decl nil seq_extras structures) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (PP? const-decl "bool" positions nil) (empty_o_seq formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (<= const-decl "bool" positions nil) (parallel const-decl "bool" positions nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (x skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (epsilon const-decl "T" epsilons nil) (FALSE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty_0 formula-decl nil seq_extras structures) (PP type-eq-decl nil positions nil) (rest_of_PP_is_PP formula-decl nil positions nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (SP? const-decl "bool" positions nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (rest const-decl "finseq" seq_extras structures) (replace_par_pos def-decl "term" orthogonality_basis nil) (SPP type-eq-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (SPP? const-decl "bool" positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (replace_par_pos_preservs_f_TCC1 0 (replace_par_pos_preservs_f_TCC1-1 nil 3575293899 ("" (skosimp) (("" (lemma replace_par_pos_of_app_is_app) (("" (inst -1 fsp!1 fst!1 t!1) (("" (assert) nil nil)) nil)) nil)) nil) ((replace_par_pos_of_app_is_app formula-decl nil orthogonality_basis nil) (term type-decl nil term_adt nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (replace_par_pos_preservs_f subtype "orthogonality_basis.replace_par_pos(orthogonality_basis.t, orthogonality_basis.fsp, orthogonality_basis.fst)" "(term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].app?)"))) (replace_par_pos_preservs_f 0 (replace_par_pos_preservs_f-1 nil 3575293900 ("" (measure-induct "fsp`length" fsp) (("1" (skeep) (("1" (skeep) (("1" (case "x`length=0") (("1" (hide -2) (("1" (expand replace_par_pos) (("1" (assert) nil nil)) nil)) nil) ("2" (expand replace_par_pos 3) (("2" (expand finseq_appl) (("2" (assert) (("2" (inst -1 "rest(x)") (("2" (rewrite length_rest) (("2" (inst -1 "rest(fst)" "replaceTerm(t, fst`seq(0), x`seq(0))") (("2" (prop) (("1" (hide 2 3) (("1" (expand* "#" rest ^ min) (("1" (lift-if) (("1" (expand empty_seq -1 1) (("1" (prop) (("1" (decompose-equality -2) (("1" (inst -1 0) (("1" (assert) (("1" (expand* SPP? PP? finseq_appl parallel <=) (("1" (flatten) (("1" (inst -4 0 1) (("1" (assert) (("1" (flatten) (("1" (replaces -1) (("1" (inst 5 "x`seq(0)") (("1" (rewrite empty_o_seq) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand min) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 3 rl) (("2" (hide -1) (("2" (expand replaceTerm) (("2" (lift-if) (("2" (prop) (("2" (case "x`length=1") (("1" (expand "#") (("1" (decompose-equality 3) (("1" (rewrite empty_0 -2) (("1" (decompose-equality 1) (("1" (skeep) (("1" (replaces -1) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* SPP? PP? finseq_appl parallel) (("2" (assert) (("2" (flatten) (("2" (inst -3 0 1) (("2" (assert) (("2" (flatten) (("2" (rewrite empty_0 -1) (("2" (expand <= 4) (("2" (inst 4 "x`seq(1)") (("2" (replaces -1) (("2" (rewrite empty_o_seq) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 4) (("3" (expand replaceTerm 1) (("3" (lift-if) (("3" (prop) (("1" (rewrite empty_0 -1) (("1" (case "x`length=1") (("1" (expand "#") (("1" (decompose-equality 3) (("1" (decompose-equality 1) (("1" (skeep) (("1" (replace -1) (("1" (prop) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* SPP? PP? finseq_appl parallel) (("2" (assert) (("2" (flatten) (("2" (inst -3 0 1) (("2" (assert) (("2" (flatten) (("2" (replaces -1) (("2" (expand <= 4) (("2" (inst 4 "x`seq(1)") (("2" (rewrite empty_o_seq) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide -1 -3 3 4) (("4" (expand SPP?) (("4" (rewrite rest_of_PP_is_PP) (("4" (expand* rest ^ min empty_seq) (("4" (expand* SP? finseq_appl) (("4" (assert) (("4" (prop) (("1" (skeep) nil nil) ("2" (skeep) nil nil) ("3" (skeep) (("3" (inst -2 1+i) (("3" (expand* PP? finseq_appl) (("3" (inst -1 0 1+i) (("3" (assert) (("3" (rewrite replace_preserv_parallel_pos) (("3" (reveal -2) (("3" (inst -1 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-3 1)) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (lemma replace_par_pos_of_app_is_app) (("2" (inst -1 fsp fst t) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((replace_par_pos_of_app_is_app formula-decl nil orthogonality_basis nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (rest const-decl "finseq" seq_extras structures) (replaceTerm def-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (PP type-eq-decl nil positions nil) (rest_of_PP_is_PP formula-decl nil positions nil) (SP? const-decl "bool" positions nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (empty_0 formula-decl nil seq_extras structures) (IFF const-decl "[bool, bool -> bool]" booleans nil) (x skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (PP? const-decl "bool" positions nil) (parallel const-decl "bool" positions nil) (<= const-decl "bool" positions nil) (empty_o_seq formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_min application-judgement "{k: posint | k <= i AND k <= j}" real_defs nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (length_rest formula-decl nil seq_extras structures) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (SPP? const-decl "bool" positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_sequence type-eq-decl nil finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (empty_seq const-decl "finseq" finite_sequences nil) (SPP type-eq-decl nil positions nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (parallel_reduction_variables_context 0 (parallel_reduction_variables_context-1 nil 3575186558 ("" (induct t) (("1" (skosimp) (("1" (skeep) (("1" (inst -1 "vars(vars1_var!1)") (("1" (expand V) (("1" (inst 1 empty_seq) (("1" (expand empty_seq) (("1" (expand subtermOF) (("1" (propax) nil nil)) nil)) nil) ("2" (expand positionsOF) (("2" (expand* only_empty_seq empty_seq) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (case "app2_var`length=0") (("1" (expand parallel_reduction? 1) (("1" (inst 1 empty_seq) (("1" (expand parallel_reduction_fix?) (("1" (inst 1 empty_seq empty_seq) (("1" (expand empty_seq) (("1" (assert) (("1" (expand* subtermsOF sigma_lhs empty_seq) (("1" (expand replace_par_pos) (("1" (split) (("1" (decompose-equality 1) (("1" (skeep) nil nil)) nil) ("2" (expand ext 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite predicate_fseq2set[rewrite_rule].subset_empty_seq) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand empty_seq) (("2" (expand* SPP? SP? PP? finseq_appl) (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma parallel_reduction_context) (("2" (expand finseq_appl) (("2" (inst -1 E "(# length := app2_var`length, seq := (LAMBDA (i:below[app2_var`length]): #(i + 1)) #)" "(# length := app2_var`length,  seq := (LAMBDA (i:below[app2_var`length]): ext(sigma)(app2_var`seq(i))) #)" "(# length := app2_var`length, seq := (LAMBDA (i:below[app2_var`length]): ext(theta)(app2_var`seq(i))) #)" "ext(sigma)(app(app1_var, app2_var))") (("2" (assert) (("2" (prop) (("1" (case "ext(sigma)(app(app1_var, app2_var)) = replace_par_pos(ext(sigma)(app(app1_var, app2_var)), (# length := app2_var`length, seq := (LAMBDA(i:below[app2_var`length]): #(1 + i)) #), (# length := app2_var`length, seq:= (LAMBDA                          (i:below[app2_var`length]):                                                          ext
                                                                                        (sigma)
                                                                                        (app2_var`seq(i))) #))
                                                 AND ext(theta)(app(app1_var, app2_var)) =
                                                     replace_par_pos(ext
                                                                                 (sigma)(app(app1_var, app2_var)),
                                                                                 (# length := app2_var`length,
                                                                                    seq
                                                                                    := (LAMBDA
                                                                                        (i:
                                                                                         below[app2_var`length]):
                                                                                         #(1 + i)) #),
                                                                                 (# length := app2_var`length,
                                                                                    seq
                                                                                    := (LAMBDA
                                                                                        (i:
                                                                                         below[app2_var`length]):
                                                                                        ext
                                                                                        (theta)
                                                                                        (app2_var`seq(i))) #))") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 2)) (("2" (split) (("1" (expand ext 1 (1 2)) (("1" (expand finseq_appl) (("1" (case "SPP?(app(app1_var, (# length := app2_var`length,
                                               seq
                                                 := LAMBDA (n: below[app2_var`length]):
                                                      ext(sigma)(app2_var`seq(n)) #)))
                                                             ((# length := app2_var`length,
                                                                 seq := (LAMBDA (i: below[app2_var`length]):  #(1 + i)) #))") (("1" (lemma replace_par_pos_preservs_f) (("1" (inst -1 "(# length := app2_var`length,
                                                     seq := (LAMBDA (i: below[app2_var`length]):  #(1 + i)) #)" "(# length := app2_var`length,
                                                     seq := (LAMBDA (i: below[app2_var`length]):
                                                            ext(sigma)(app2_var`seq(i))) #)" "app(app1_var, (# length := app2_var`length,
                                                     seq := (LAMBDA (i: below[app2_var`length]):
                                                            ext(sigma)(app2_var`seq(i))) #))") (("1" (assert) (("1" (split) (("1" (hide -2 1) (("1" (expand "#" -1 2) (("1" (flatten) (("1" (decompose-equality -2) (("1" (inst -1 0) (("1" (expand* "#" empty_seq) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (decompose-equality 1) (("1" (decompose-equality 1) (("1" (case "args(replace_par_pos(app(app1_var,
                                                                                                     (# length := app2_var`length,
                                                                                                        seq
                                                                                                          := LAMBDA
                                                                                                             (n: below[app2_var`length]):
                                                                                                             ext(sigma)(app2_var`seq(n)) #)),
                                                                                                 (# length := app2_var`length,
                                                                                                    seq
                                                                                                      := (LAMBDA
                                                                                                          (i: below[app2_var`length]):
                                                                                                           #(1 + i)) #),
                                                                                                 (# length := app2_var`length,
                                                                                                    seq
                                                                                                      := (LAMBDA
                                                                                                          (i: below[app2_var`length]):
                                                                                                          ext(sigma)(app2_var`seq(i))) #)))`seq(x!1) =
                                                                                  subtermOF(replace_par_pos(app(app1_var,
                                                                                                     (# length := app2_var`length,
                                                                                                        seq
                                                                                                          := LAMBDA
                                                                                                             (n: below[app2_var`length]):
                                                                                                             ext(sigma)(app2_var`seq(n)) #)),
                                                                                                 (# length := app2_var`length,
                                                                                                    seq
                                                                                                      := (LAMBDA
                                                                                                          (i: below[app2_var`length]):
                                                                                                           #(1 + i)) #),
                                                                                                 (# length := app2_var`length,
                                                                                                    seq
                                                                                                      := (LAMBDA
                                                                                                          (i: below[app2_var`length]):
                                                                                                          ext(sigma)(app2_var`seq(i))) #)), #(1 + x!1))") (("1" (replaces -1) (("1" (hide -1) (("1" (lemma replace_par_pos_subterm) (("1" (inst -1 "(# length := app2_var`length,
                                                                                    seq := (LAMBDA (i: below[app2_var`length]): #(1 + i)) #)" "(# length := app2_var`length,
                                                                                      seq
                                                                                        := (LAMBDA (i: below[app2_var`length]):
                                                                                              ext(sigma)(app2_var`seq(i))) #)" "app(app1_var, (# length := app2_var`length,
                                                                                       seq := LAMBDA (n: below[app2_var`length]): ext(sigma)(app2_var`seq(n)) #))") (("1" (expand finseq_appl) (("1" (inst -1 x!1) (("1" (replaces -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (expand* subtermOF finseq_appl) (("2" (expand "#" 1 2) (("2" (expand subtermOF) (("2" (expand "#" 1 (2 4)) (("2" (expand rest 1 1) (("2" (expand* ^ min empty_seq first finseq_appl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 2) (("3" (lemma replace_par_pos_preservs_PP) (("3" (inst -1 "(# length := app2_var`length,
                                                                                    seq := (LAMBDA (i: below[app2_var`length]): #(1 + i)) #)" "(# length := app2_var`length,
                                                                                      seq
                                                                                        := (LAMBDA (i: below[app2_var`length]):
                                                                                              ext(sigma)(app2_var`seq(i))) #)" "app(app1_var, (# length := app2_var`length,
                                                                                       seq := LAMBDA (n: below[app2_var`length]): ext(sigma)(app2_var`seq(n)) #))") (("3" (assert) (("3" (inst -1 x!1) (("3" (expand finseq_appl) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* SPP? PP? SP? finseq_appl) (("2" (split) (("1" (propax) nil nil) ("2" (prop) (("2" (skeep) (("2" (expand parallel) (("2" (expand <=) (("2" (split) (("1" (skosimp) (("1" (expand* "#" o) (("1" (flatten) (("1" (decompose-equality) (("1" (inst -1 0) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand* "#" o) (("2" (flatten) (("2" (decompose-equality) (("2" (inst -1 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (rewrite subterm_if_le_arity) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand ext 1 (1 2)) (("2" (expand finseq_appl) (("2" (case "SPP?(app(app1_var,
                                                                         (# length := app2_var`length,
                                                                               seq := LAMBDA (n: below[app2_var`length]): ext(sigma)(app2_var`seq(n)) #)))
                                                                    ((# length := app2_var`length,
                                                                           seq := (LAMBDA (i: below[app2_var`length]): #(1 + i)) #))") (("1" (lemma replace_par_pos_preservs_f) (("1" (inst -1 "(# length := app2_var`length,
                                                                  seq := (LAMBDA (i: below[app2_var`length]): #(1 + i)) #)" "(# length := app2_var`length,
                                                                    seq
                                                                      := (LAMBDA (i: below[app2_var`length]):
                                                                            ext(theta)(app2_var`seq(i))) #)" "app(app1_var, (# length := app2_var`length,
                                                                     seq := LAMBDA (n: below[app2_var`length]): ext(sigma)(app2_var`seq(n)) #))") (("1" (assert) (("1" (split) (("1" (hide -2 1) (("1" (expand "#" -1 2) (("1" (flatten) (("1" (decompose-equality -2) (("1" (inst -1 0) (("1" (expand* "#" empty_seq) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (decompose-equality 1) (("1" (decompose-equality 1) (("1" (case "args(replace_par_pos(app(app1_var,
                                                                                                     (# length := app2_var`length,
                                                                                                        seq
                                                                                                          := LAMBDA
                                                                                                             (n: below[app2_var`length]):
                                                                                                             ext(sigma)(app2_var`seq(n)) #)),
                                                                                                 (# length := app2_var`length,
                                                                                                    seq
                                                                                                      := (LAMBDA
                                                                                                          (i: below[app2_var`length]):
                                                                                                           #(1 + i)) #),
                                                                                                 (# length := app2_var`length,
                                                                                                    seq
                                                                                                      := (LAMBDA
                                                                                                          (i: below[app2_var`length]):
                                                                                                          ext(theta)(app2_var`seq(i))) #)))`seq(x!1) =
                                                                                  subtermOF(replace_par_pos(app(app1_var,
                                                                                                     (# length := app2_var`length,
                                                                                                        seq
                                                                                                          := LAMBDA
                                                                                                             (n: below[app2_var`length]):
                                                                                                             ext(sigma)(app2_var`seq(n)) #)),
                                                                                                 (# length := app2_var`length,
                                                                                                    seq
                                                                                                      := (LAMBDA
                                                                                                          (i: below[app2_var`length]):
                                                                                                           #(1 + i)) #),
                                                                                                 (# length := app2_var`length,
                                                                                                    seq
                                                                                                      := (LAMBDA
                                                                                                          (i: below[app2_var`length]):
                                                                                                          ext(theta)(app2_var`seq(i))) #)), #(1 + x!1))") (("1" (replaces -1) (("1" (hide -1) (("1" (lemma replace_par_pos_subterm) (("1" (inst -1 "(# length := app2_var`length,
                                                                                    seq := (LAMBDA (i: below[app2_var`length]): #(1 + i)) #)" "(# length := app2_var`length,
                                                                                      seq
                                                                                        := (LAMBDA (i: below[app2_var`length]):
                                                                                              ext(theta)(app2_var`seq(i))) #)" "app(app1_var, (# length := app2_var`length,
                                                                                       seq := LAMBDA (n: below[app2_var`length]): ext(sigma)(app2_var`seq(n)) #))") (("1" (expand finseq_appl) (("1" (inst -1 x!1) (("1" (replaces -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (expand* subtermOF finseq_appl) (("2" (expand "#" 1 2) (("2" (expand subtermOF) (("2" (expand "#" 1 (2 4)) (("2" (expand rest 1 1) (("2" (expand* ^ min empty_seq first finseq_appl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 2) (("3" (lemma replace_par_pos_preservs_PP) (("3" (inst -1 "(# length := app2_var`length,
                                                                                    seq := (LAMBDA (i: below[app2_var`length]): #(1 + i)) #)" "(# length := app2_var`length,
                                                                                      seq
                                                                                        := (LAMBDA (i: below[app2_var`length]):
                                                                                              ext(theta)(app2_var`seq(i))) #)" "app(app1_var, (# length := app2_var`length,
                                                                                       seq := LAMBDA (n: below[app2_var`length]): ext(sigma)(app2_var`seq(n)) #))") (("3" (assert) (("3" (inst -1 x!1) (("3" (expand finseq_appl) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* SPP? PP? SP? finseq_appl) (("2" (split) (("1" (propax) nil nil) ("2" (prop) (("2" (skeep) (("2" (expand parallel) (("2" (expand <=) (("2" (split) (("1" (skosimp) (("1" (expand* "#" o) (("1" (flatten) (("1" (decompose-equality) (("1" (inst -1 0) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (expand* "#" o) (("2" (flatten) (("2" (decompose-equality) (("2" (inst -1 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (rewrite subterm_if_le_arity) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand* ext finseq_appl) (("2" (expand* SPP? SP? PP? finseq_appl) (("2" (split) (("1" (propax) nil nil) ("2" (prop) (("2" (skosimp 2) (("2" (expand parallel) (("2" (split) (("1" (expand "#") (("1" (expand <= -1) (("1" (skosimp) (("1" (expand o -1) (("1" (flatten) (("1" (decompose-equality) (("1" (inst -1 0) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "#") (("2" (expand <=) (("2" (skosimp) (("2" (expand o -1) (("2" (flatten) (("2" (decompose-equality -2) (("2" (inst -1 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (lemma subterm_if_le_arity) (("3" (typepred i!1) (("3" (inst -2 "1+i!1" "app(app1_var,
                                                    (# length := app2_var`length,
                                                       seq
                                                         := LAMBDA (n: below[app2_var`length]):
                                                              ext(sigma)(app2_var`seq(n)) #))") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp) (("3" (inst -1 i!1) (("3" (inst -1 E sigma theta) (("3" (assert) (("3" (skosimp) (("3" (inst -1 x!1) (("3" (typepred x!1) (("3" (skosimp) (("3" (inst 1 "add_first(1 + i!1, p!1)") (("1" (expand subtermOF 1) (("1" (rewrite rest_add_first) (("1" (expand* add_first insert? first finseq_appl) (("1" (lift-if) (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand positionsOF 1) (("2" (expand* only_empty_seq union IUnion member) (("2" (flatten) (("2" (hide 1) (("2" (inst 1 "1+i!1") (("2" (expand finseq_appl) (("2" (expand catenate) (("2" (inst 1 p!1) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_sequence type-eq-decl nil finite_sequences nil) (SPP? const-decl "bool" positions nil) (sigma skolem-const-decl "Sub[variable, symbol, arity]" orthogonality_basis nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (app1_var skolem-const-decl "symbol" orthogonality_basis nil) (app2_var skolem-const-decl "{args: finite_sequence[term] | args`length = arity(app1_var)}" orthogonality_basis nil) (SPP type-eq-decl nil positions nil) (subset? const-decl "bool" predicate_fseq2set nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" orthogonality_basis nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (< const-decl "bool" reals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (pred type-eq-decl nil defined_types nil) (epsilon const-decl "T" epsilons nil) (TRUE const-decl "bool" booleans nil) (FALSE const-decl "bool" booleans nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (sigma_lhs const-decl "finseq[term]" orthogonality_basis nil) (subset_empty_seq formula-decl nil predicate_fseq2set nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (PP? const-decl "bool" positions nil) (SP? const-decl "bool" positions nil) (add_first const-decl "finseq" seq_extras structures) (p!1 skolem-const-decl "positions?[variable, symbol, arity](app2_var`seq(i!1))" orthogonality_basis nil) (rest_add_first formula-decl nil seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (union const-decl "set" sets nil) (member const-decl "bool" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (<= const-decl "bool" reals nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (x!1 skolem-const-decl "Vars?[variable, symbol, arity](app2_var`seq(i!1))" orthogonality_basis nil) (i!1 skolem-const-decl "below[app2_var`length]" orthogonality_basis nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (<= const-decl "bool" positions nil) (int_minus_int_is_int application-judgement "int" integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (O const-decl "finseq" finite_sequences nil) (parallel const-decl "bool" positions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (subterm_if_le_arity formula-decl nil positions nil) (replace_par_pos_preservs_f formula-decl nil orthogonality_basis nil) (term_app_extensionality formula-decl nil term_adt nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (^ const-decl "finseq" finite_sequences nil) (first const-decl "T" seq_extras structures) (rest const-decl "finseq" seq_extras structures) (replace_par_pos_subterm formula-decl nil orthogonality_basis nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (theta skolem-const-decl "Sub[variable, symbol, arity]" orthogonality_basis nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (parallel_reduction_context formula-decl nil orthogonality_basis nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (vars1_var!1 skolem-const-decl "variable" orthogonality_basis nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (only_empty_seq const-decl "positions" positions nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (ext def-decl "term" substitution nil) (parallel_reduction? const-decl "bool" orthogonality_basis nil) (Vars? type-eq-decl nil subterm nil) (subtermOF def-decl "term" subterm nil) (= const-decl "[T, T -> boolean]" equalities nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil)) shostak)) (parallel_reduction_result 0 (parallel_reduction_result-1 nil 3577718885 ("" (measure-induct "fsp`length" fsp) (("" (skosimp) (("" (skeep) (("" (case " x!1`length=0") (("1" (hide -2) (("1" (expand parallel_reduction_fix?) (("1" (skosimp) (("1" (expand replace_par_pos -8) (("1" (assert) (("1" (inst 2 sigma) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x!1)") (("2" (rewrite length_rest) (("2" (expand parallel_reduction_fix? -5) (("2" (skosimp) (("2" (expand replace_par_pos -8) (("2" (expand finseq_appl) (("2" (assert) (("2" (lemma replace_par_pos_equivalence) (("2" (expand finseq_appl) (("2" (inst -1 x!1 "sigma_rhs(fss!1, fse!1)" "ext(sigma)(lhs(e))") (("2" (assert) (("2" (expand sigma_rhs -1 1) (("2" (replaces -1) (("2" (expand sigma_rhs -8 2) (("2" (expand finseq_appl) (("2" (rewrite sigma_rhs_rest) (("2" (lemma positions_of_ext) (("2" (inst -1 sigma "lhs(e)") (("2" (decompose-equality -1) (("2" (inst -1 "x!1`seq(0)") (("2" (expand* union member) (("2" (iff) (("2" (flatten) (("2" (hide -2) (("2" (expand SPP? -5) (("2" (expand* SP? finseq_appl) (("2" (flatten) (("2" (inst-cp -6 0) (("2" (assert) (("2" (expand subtermsOF -10) (("2" (expand sigma_lhs -10) (("2" (expand finseq_appl) (("2" (decompose-equality -10) (("1" (prop) (("1" (expand* Orthogonal? Ambiguous?) (("1" (flatten) (("1" (lemma ntCP_lemma_aux1) (("1" (inst -1 sigma "fss!1`seq(0)" E "x!1`seq(0)" e "fse!1`seq(0)") (("1" (inst -3 0) (("1" (assert) (("1" (rewrite subterm_ext_commute -3) (("1" (assert) (("1" (prop) (("1" (skosimp) (("1" (inst 3 t1!1 t2!1) nil nil)) nil) ("2" (hide-all-but (-2 -8 2 4)) (("2" (expand* PP? finseq_appl) (("2" (case "x!1`length=1") (("1" (assert) (("1" (prop) (("1" (expand "#") (("1" (decompose-equality) (("1" (decompose-equality 2) (("1" (decompose-equality 1) (("1" (skeep) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -2 0 1) (("2" (expand parallel) (("2" (flatten) (("2" (expand <= 3) (("2" (inst 3 "x!1`seq(1)") (("2" (replaces -1) (("2" (rewrite empty_o_seq) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred fse!1) (("2" (expand* subset? member) (("2" (expand* subset? member seq2set finseq_appl) (("2" (inst?) (("2" (assert) (("2" (inst? 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand member 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -6 E e sigma "replace_par_pos(ext(sigma)(lhs(e)), rest(x!1),
                                                                       sigma_rhs(rest(fss!1), rest(fse!1)))") (("2" (assert) (("2" (prop) (("1" (hide-all-but (-1 -9 1 2)) (("1" (expand* rest ^ min) (("1" (expand empty_seq -1 1) (("1" (expand "#") (("1" (decompose-equality -1) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (decompose-equality -1) (("1" (hide 6) (("1" (inst -1 0) (("1" (expand* PP? finseq_appl) (("1" (assert) (("1" (inst -3 0 1) (("1" (expand* parallel <=) (("1" (flatten) (("1" (replaces -1) (("1" (inst 7 "x!1`seq(0)") (("1" (rewrite empty_o_seq) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand min) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst 3 "SigmaP(theta!1, ext(fss!1`seq(0))(rhs(fse!1`seq(0))), subtermOF(lhs(e), p1!1), p2!1)") (("1" (lemma SigmaP_vs_replaceTerm_linearR) (("1" (inst -1 p1!1 p2!1 "lhs(e)" theta!1 "ext(fss!1`seq(0))(rhs(fse!1`seq(0)))" "subtermOF(lhs(e), p1!1)") (("1" (assert) (("1" (split) (("1" (lemma seq_first_rest[position]) (("1" (inst -1 x!1) (("1" (assert) (("1" (lemma replace_par_pos_preservs_pos) (("1" (inst -1 "rest(x!1)" "sigma_rhs(rest(fss!1), rest(fse!1))" "x!1`seq(0)" "ext(sigma)(lhs(e))") (("1" (assert) (("1" (prop) (("1" (replaces -3) (("1" (replaces -3) (("1" (lemma pos_subterm_ax) (("1" (inst -1 p1!1 p2!1 "ext(theta!1)(lhs(e))") (("1" (assert) (("1" (rewrite subterm_ext_commute -1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -10 -11 1 3)) (("2" (expand* SPP? SP? finseq_appl) (("2" (expand* first finseq_appl) (("2" (assert) (("2" (skeep) (("2" (inst -3 i) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-13 -14 1 3)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -7 -8 1)) (("2" (expand* Orthogonal? Left_Linear? linear?) (("2" (flatten) (("2" (inst -3 e) (("1" (inst -3 "subtermOF(lhs(e), p1!1)") (("1" (expand* member Vars) (("1" (inst 1 p1!1) nil nil)) nil)) nil) ("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite SigmaP_Subs) (("2" (hide 2) (("2" (lemma replace_par_pos_preservs_pos) (("2" (inst -1 "rest(x!1)" "sigma_rhs(rest(fss!1), rest(fse!1))" "x!1`seq(0)" "ext(sigma)(lhs(e))") (("2" (prop) (("1" (replaces -2) (("1" (replaces -2) (("1" (lemma pos_subterm_ax) (("1" (inst -1 p1!1 p2!1 "ext(theta!1)(lhs(e))") (("1" (assert) (("1" (rewrite subterm_ext_commute -1) (("1" (expand ext -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-9 -10 1 3)) (("2" (lemma seq_first_rest[position]) (("2" (inst -1 x!1) (("2" (assert) (("2" (expand* first finseq_appl) (("2" (replace -1 1 rl) (("2" (expand* SPP? SP? finseq_appl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-12 -13 1 3)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -14) (("3" (lemma replace_par_pos_preservs_pos) (("3" (inst -1 "rest(x!1)" "sigma_rhs(rest(fss!1), rest(fse!1))" "x!1`seq(0)" "ext(sigma)(lhs(e))") (("3" (prop) (("1" (replaces -2) (("1" (lemma pos_subterm_ax) (("1" (inst -1 p1!1 p2!1 "ext(theta!1)(lhs(e))") (("1" (assert) (("1" (rewrite subterm_ext_commute -1) (("1" (expand ext -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-9 -10 1 3)) (("2" (lemma seq_first_rest[position]) (("2" (inst -1 x!1) (("2" (expand* first finseq_appl) (("2" (replace -1 1 rl) (("2" (expand* SPP? SP? finseq_appl) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-12 -13 1 3)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand V) (("4" (propax) nil nil)) nil)) nil)) nil) ("3" (expand SPP?) (("3" (rewrite rest_of_PP_is_PP) (("3" (lemma rest_of_SP_is_SP) (("3" (inst -1 "ext(sigma)(lhs(e))" x!1) (("3" (expand SP? 1) (("3" (expand finseq_appl) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -13 4) (("4" (expand* parallel_reduction_fix?) (("4" (inst 1 "rest(fse!1)" "rest(fss!1)") (("1" (prop) (("1" (hide-all-but (-11 1 2)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-12 1 2)) (("2" (grind) nil nil)) nil) ("3" (hide 3) (("3" (expand* rest ^ min empty_seq) (("3" (lift-if) (("3" (assert) (("3" (lift-if) (("3" (assert) (("3" (lift-if) (("3" (expand* subtermsOF sigma_lhs empty_seq finseq_appl) (("3" (prop) (("1" (decompose-equality 1) (("1" (skeep) nil nil)) nil) ("2" (decompose-equality 1) (("2" (skeep) nil nil)) nil) ("3" (assert) nil nil) ("4" (decompose-equality 1) (("4" (skeep) nil nil)) nil) ("5" (decompose-equality 1) (("5" (skeep) nil nil)) nil) ("6" (assert) nil nil) ("7" (decompose-equality 3) (("1" (inst -5 1+x!2) nil nil) ("2" (skeep) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (inst -9 1+i) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred fse!1) (("2" (expand subset?) (("2" (lemma predicate_fseq2set[rewrite_rule].rest_subset) (("2" (inst?) (("2" (lemma sets_lemmas[rewrite_rule].subset_transitive) (("2" (inst -1 "seq2set(rest(fse!1))" "seq2set(fse!1)" "E") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -11 x!2) nil nil) ("3" (inst -8 x!2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((replace_par_pos def-decl "term" orthogonality_basis nil) (length_rest formula-decl nil seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (replace_par_pos_equivalence formula-decl nil orthogonality_basis nil) (subset? const-decl "bool" predicate_fseq2set nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (sigma_rhs_rest formula-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (e skolem-const-decl "rewrite_rule[variable, symbol, arity]" orthogonality_basis nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" orthogonality_basis nil) (fse!1 skolem-const-decl "{fse | subset?(fse, E)}" orthogonality_basis nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (x!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (empty_o_seq formula-decl nil seq_extras structures) (<= const-decl "bool" positions nil) (parallel const-decl "bool" positions nil) (PP? const-decl "bool" positions nil) (subterm_ext_commute formula-decl nil substitution nil) (seq2set const-decl "finite_set[T]" seq2set structures) (subset? const-decl "bool" sets nil) (below type-eq-decl nil naturalnumbers nil) (ntCP_lemma_aux1 formula-decl nil orthogonality_basis nil) (Ambiguous? const-decl "bool" orthogonality_basis nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (posint_min application-judgement "{k: posint | k <= i AND k <= j}" real_defs nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (FALSE const-decl "bool" booleans nil) (epsilon const-decl "T" epsilons nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (p1!1 skolem-const-decl "position[variable, symbol, arity]" orthogonality_basis nil) (theta!1 skolem-const-decl "Sub[variable, symbol, arity]" orthogonality_basis nil) (p2!1 skolem-const-decl "position[variable, symbol, arity]" orthogonality_basis nil) (SigmaP const-decl "term" substitution nil) (fss!1 skolem-const-decl "finseq[Sub[variable, symbol, arity]]" orthogonality_basis nil) (rhs const-decl "term" rewrite_rules nil) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (first const-decl "T" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (pos_subterm_ax formula-decl nil subterm nil) (seq_first_rest formula-decl nil seq_extras structures) (Left_Linear? const-decl "bool" orthogonality_basis nil) (linear? const-decl "bool" orthogonality_basis nil) (Vars const-decl "set[(V)]" subterm nil) (SigmaP_vs_replaceTerm_linearR formula-decl nil substitution nil) (SigmaP_Subs formula-decl nil substitution nil) (PP type-eq-decl nil positions nil) (rest_of_PP_is_PP formula-decl nil positions nil) (SP type-eq-decl nil positions nil) (sigma skolem-const-decl "Sub[variable, symbol, arity]" orthogonality_basis nil) (rest_of_SP_is_SP formula-decl nil positions nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subset_transitive formula-decl nil sets_lemmas nil) (rest_subset formula-decl nil predicate_fseq2set nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sigma_lhs const-decl "finseq[term]" orthogonality_basis nil) (member const-decl "bool" sets nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (union const-decl "set" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (O const-decl "finseq" finite_sequences nil) (positions_of_ext formula-decl nil substitution nil) (TRUE const-decl "bool" booleans nil) (rest const-decl "finseq" seq_extras structures) (empty_seq const-decl "finseq" finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (SPP type-eq-decl nil positions nil) (lhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (SPP? const-decl "bool" positions nil) (Orthogonal? const-decl "bool" orthogonality_basis nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (replace_par_pos_subterm2_TCC1 0 (replace_par_pos_subterm2_TCC1-1 nil 3668531013 ("" (skosimp*) (("" (lemma replace_par_pos_preservs_PP) (("" (inst -1 fsp!1 fst!1 s!1) (("" (assert) nil nil)) nil)) nil)) nil) ((replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (term type-decl nil term_adt nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (replace_par_pos_subterm2 subtype "orthogonality_basis.fst" "{fst | orthogonality_basis.fst`length = orthogonality_basis.fsp`length}"))) (replace_par_pos_subterm2_TCC2 0 (replace_par_pos_subterm2_TCC2-1 nil 3668531013 ("" (skosimp) (("" (skosimp) (("" (lemma replace_par_pos_preservs_PP) (("" (inst -1 fsp!1 fst!1 s!1) (("" (assert) (("" (expand* seq2set finseq_appl) (("" (skosimp) (("" (inst -1 kk!1) (("" (lemma closed_positions) (("" (inst -1 p!1 p1!1 "replace_par_pos(s!1, fsp!1, fst!1)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (term type-decl nil term_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (seq2set const-decl "finite_set[T]" seq2set structures) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (SPP? const-decl "bool" positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (SPP type-eq-decl nil positions nil) (closed_positions formula-decl nil positions nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil)) nil (replace_par_pos_subterm2 subtype "orthogonality_basis.p" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(orthogonality_basis.replace_par_pos(orthogonality_basis.s, orthogonality_basis.fsp, orthogonality_basis.fst))"))) (replace_par_pos_subterm2_TCC3 0 (replace_par_pos_subterm2_TCC3-2 "" 3803938665 ("" (skosimp*) (("" (expand* SPP? SP? seq2set finseq_appl) (("" (flatten) (("" (skosimp*) (("" (inst - "kk!1") (("" (lemma closed_positions) (("" (inst -1 p!1 p1!1 s!1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (replace_par_pos_subterm2 subtype "orthogonality_basis.p" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(orthogonality_basis.s)")) (replace_par_pos_subterm2_TCC3-1 nil 3668531013 ("" (skosimp*) (("" (expand* SPP? SP? seq2set finseq_appl) (("" (flatten) (("" (skosimp*) (("" (inst -2 "kk!1") (("" (lemma closed_positions) (("" (inst -1 p!1 p1!1 s!1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SP? const-decl "bool" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (seq2set const-decl "finite_set[T]" seq2set structures) (SPP? const-decl "bool" positions nil) (closed_positions formula-decl nil positions nil) (term type-decl nil term_adt nil) (below type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (replace_par_pos_subterm2 subtype "orthogonality_basis.p" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].positions?(orthogonality_basis.s)"))) (replace_par_pos_subterm2_TCC4 0 (replace_par_pos_subterm2_TCC4-2 "" 3803938707 ("" (skosimp*) (("" (expand* SPP? SP? seq2set finseq_appl) (("" (skosimp*) (("" (rewrite complement_pos_is_PP) (("" (skosimp) (("" (lemma complement_pos_character) (("" (inst -1 fsp!1 p!1 "complement_pos(p!1, fsp!1)`seq(i!1)") (("" (prop) (("1" (skosimp) (("1" (inst - i!2) (("1" (lemma pos_subterm_ax) (("1" (inst -1 p!1 "complement_pos(p!1, fsp!1)`seq(i!1)" s!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* seq2set finseq_appl) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (replace_par_pos_subterm2 subtype "orthogonality_basis.complement_pos(orthogonality_basis.p, orthogonality_basis.fsp)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(subterm[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].subtermOF(orthogonality_basis.s, orthogonality_basis.p))")) (replace_par_pos_subterm2_TCC4-1 nil 3668531013 ("" (skosimp*) (("" (expand* SPP? SP? seq2set finseq_appl) (("" (skosimp*) (("" (rewrite complement_pos_is_PP) (("" (skosimp) (("" (lemma complement_pos_character) (("" (inst -1 fsp!1 p!1 "complement_pos(p!1, fsp!1)`seq(i!1)") (("" (prop) (("1" (skosimp) (("1" (inst -3 i!2) (("1" (lemma pos_subterm_ax) (("1" (inst -1 p!1 "complement_pos(p!1, fsp!1)`seq(i!1)" s!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* seq2set finseq_appl) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SP? const-decl "bool" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (seq2set const-decl "finite_set[T]" seq2set structures) (SPP? const-decl "bool" positions nil) (complement_pos_is_PP formula-decl nil orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (complement_pos_character formula-decl nil orthogonality_basis nil) (term type-decl nil term_adt nil) (pos_subterm_ax formula-decl nil subterm nil) (below type-eq-decl nil naturalnumbers nil) (complement_pos def-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (< const-decl "bool" reals nil)) nil (replace_par_pos_subterm2 subtype "orthogonality_basis.complement_pos(orthogonality_basis.p, orthogonality_basis.fsp)" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SPP(subterm[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].subtermOF(orthogonality_basis.s, orthogonality_basis.p))"))) (replace_par_pos_subterm2_TCC5 0 (replace_par_pos_subterm2_TCC5-1 nil 3668531013 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (O const-decl "finseq" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (<= const-decl "bool" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (seq2set const-decl "finite_set[T]" seq2set structures) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (replace_par_pos_subterm2 subtype "orthogonality_basis.fst1" "{fst | orthogonality_basis.fst`length = orthogonality_basis.complement_pos(orthogonality_basis.p, orthogonality_basis.fsp)`length}"))) (replace_par_pos_subterm2 0 (replace_par_pos_subterm2-1 nil 3668531026 ("" (measure-induct "fsp`length" fsp) (("1" (skeep) (("1" (skeep) (("1" (case "x`length=0") (("1" (hide -2) (("1" (expand "seq2set") (("1" (expand finseq_appl) (("1" (skosimp) (("1" (typepred kk!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand seq2set -3) (("2" (expand finseq_appl) (("2" (skolem -3 i) (("2" (case "x`length=1") (("1" (hide -2) (("1" (inst 3 fst) (("1" (split) (("1" (expand complement_pos) (("1" (lift-if) (("1" (prop) (("1" (expand* add_first insert?) (("1" (expand* rest ^ min empty_seq) (("1" (lift-if) (("1" (assert) (("1" (expand complement_pos) (("1" (expand empty_seq) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* nonempty? empty? member) (("2" (copy -5) (("2" (expand <= -1) (("2" (skosimp) (("2" (inst -2 p1!1) (("2" (expand* complement_pos_set emptyset) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand complement_pos) (("2" (expand* replace_par_pos finseq_appl) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (expand add_first 1 (1 2)) (("2" (expand insert?) (("2" (copy -4) (("2" (expand <= -1) (("2" (skosimp) (("2" (case "choose(complement_pos_set(<=, o)(p, x`seq(0))) = p1!1") (("1" (replaces -1) (("1" (prop) (("1" (assert) nil nil) ("2" (hide 1) (("2" (rewrite rest_add_first) (("2" (expand rest 1 (1 3)) (("2" (expand* ^ min empty_seq) (("2" (lift-if) (("2" (assert) (("2" (expand complement_pos) (("2" (expand empty_seq) (("2" (expand replace_par_pos) (("2" (case "i=0") (("1" (replace -1) (("1" (replace -6 1) (("1" (replace -3 1) (("1" (rewrite replace_distributivity) (("1" (expand* SPP? SP? finseq_appl) (("1" (flatten) (("1" (inst -6 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 1) (("3" (expand* nonempty? empty? member) (("3" (inst -1 p1!1) (("3" (expand* complement_pos_set emptyset) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 1 2) (("4" (expand* nonempty? empty? member) (("4" (inst -1 p1!1) (("4" (expand* complement_pos_set emptyset) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "choose(complement_pos_set(<=, o)(p, x`seq(0)))") (("2" (expand complement_pos_set -1 1) (("2" (expand emptyset) (("2" (assert) (("2" (case i=0) (("1" (replace -1) (("1" (replace -6 -3 rl) (("1" (lemma equal_prefix[posnat]) (("1" (inst -1 p "choose(complement_pos_set(<=, o)(p, x`seq(0)))" p1!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand* nonempty? empty? member) (("3" (inst -1 p1!1) (("3" (expand* complement_pos_set emptyset) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i=0") (("1" (replace -1) (("1" (inst -2 "delete(x, 1)") (("1" (expand delete -2 1) (("1" (inst -2 "delete(fst, 1)" p p1 s) (("1" (expand delete -2 (3 4)) (("1" (assert) (("1" (prop) (("1" (skosimp) (("1" (expand complement_pos) (("1" (expand delete -1 1) (("1" (expand delete -2 3) (("1" (expand delete -1 (1 2)) (("1" (expand delete -2 (3 4)) (("1" (expand finseq_appl) (("1" (copy -6) (("1" (expand <= -1) (("1" (skosimp) (("1" (case "nonempty?(complement_pos_set(<=, o)(p, x`seq(0)))") (("1" (assert) (("1" (expand add_first -3) (("1" (expand insert?) (("1" (expand complement_pos 4) (("1" (expand rest 4 (1 2 3 8 9 10)) (("1" (expand* ^ min empty_seq) (("1" (case "rest(delete(x, 1)) = rest(rest(x))") (("1" (replace -1) (("1" (case "choose(complement_pos_set(<=, o)(p, x`seq(0))) = p1!1") (("1" (replaces -1) (("1" (case "nonempty?(complement_pos_set(<=, o)(p, x`seq(1)))") (("1" (assert) (("1" (inst 4 "add_first(fst1!1`seq(0), add_first(fst`seq(1), rest(fst1!1)))") (("1" (expand add_first 4 (1 2 3 4)) (("1" (expand insert?) (("1" (expand rest 4 3) (("1" (expand* ^ min empty_seq) (("1" (lift-if) (("1" (case "fst1!1`length = 1") (("1" (assert) (("1" (expand replace_par_pos 4) (("1" (expand finseq_appl) (("1" (rewrite rest_add_first) (("1" (rewrite rest_add_first) (("1" (expand add_first 4 (1 2 3 5)) (("1" (expand insert?) (("1" (expand replace_par_pos 4) (("1" (expand finseq_appl) (("1" (lift-if) (("1" (rewrite rest_add_first) (("1" (rewrite rest_add_first) (("1" (expand add_first 4) (("1" (expand insert?) (("1" (expand rest 4 1) (("1" (expand* ^ min empty_seq) (("1" (expand replace_par_pos -7) (("1" (expand finseq_appl) (("1" (lift-if) (("1" (expand delete -7 (1 2 3)) (("1" (lift-if) (("1" (rewrite rest_add_first) (("1" (expand finseq_appl) (("1" (expand add_first -7) (("1" (expand insert?) (("1" (case "rest(delete(fst, 1)) = rest(rest(fst))") (("1" (replace -1) (("1" (replace -4) (("1" (typepred "choose(complement_pos_set(<=, o)(p, x`seq(1)))") (("1" (expand complement_pos_set -1 1) (("1" (expand emptyset) (("1" (prop) (("1" (expand replace_par_pos -10 2) (("1" (expand replace_par_pos 5 2) (("1" (lemma replace_par_pos_equivalence) (("1" (expand finseq_appl) (("1" (inst -1 "rest(x)" "rest(fst)" "replaceTerm
                                                                                                                                                                                            (s, fst`seq(0), x`seq(0))") (("1" (prop) (("1" (replaces -1) (("1" (lemma replace_distributivity) (("1" (inst -1 p "choose(complement_pos_set(<=, o)(p, x`seq(1)))" "replace_par_pos(replaceTerm(s, fst`seq(0), x`seq(0)),
                                                                                                                                                                                                      rest(rest(x)),
                                                                                                                                                                                                      rest(rest(fst)))" "fst`seq(1)") (("1" (prop) (("1" (replace -11 -1) (("1" (expand rest 5 (5 6)) (("1" (expand ^) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -2 1 rl) (("2" (lemma replace_par_pos_preservs_pos) (("2" (inst -1 "add_first(x`seq(0),rest(rest(x)))" "add_first(fst`seq(0),rest(rest(fst)))" "x`seq(1)" s) (("2" (hide-all-but (-1 -13 -16 1 3 4)) (("2" (prop) (("1" (expand replace_par_pos -1) (("1" (expand finseq_appl) (("1" (rewrite rest_add_first) (("1" (rewrite rest_add_first) (("1" (expand add_first) (("1" (expand insert?) (("1" (assert) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand SPP?) (("2" (flatten) (("2" (expand* rest ^ min empty_seq) (("2" (lift-if) (("2" (expand* add_first insert? finseq_appl) (("2" (assert) (("2" (case "x`length<3") (("1" (assert) (("1" (split) (("1" (expand* PP? finseq_appl) (("1" (skeep) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (inst -3 1 0) (("1" (assert) nil nil)) nil) ("2" (inst -3 0 1) (("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (prop) (("1" (inst -4 1) nil nil) ("2" (inst -3 0) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split) (("1" (expand* PP? finseq_appl) (("1" (skeep) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (inst -3 1 0) (("1" (assert) nil nil)) nil) ("2" (inst -2 1 j) (("2" (assert) nil nil)) nil) ("3" (inst -3 0 1) (("3" (assert) nil nil)) nil) ("4" (inst -2 0 j) (("4" (assert) nil nil)) nil) ("5" (inst -2 i!1 1) (("5" (assert) nil nil)) nil) ("6" (inst -2 i!1 0) (("6" (assert) nil nil)) nil) ("7" (inst -1 i!1 j) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (prop) (("1" (inst -3 1) nil nil) ("2" (inst -3 0) nil nil) ("3" (inst -2 i!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-12 1 3 4)) (("2" (expand SPP?) (("2" (rewrite rest_of_PP_is_PP) (("2" (flatten) (("2" (expand* SP? PP? finseq_appl) (("2" (skeep) (("2" (typepred i!1) (("2" (expand rest (-1 1)) (("2" (expand* ^ min empty_seq) (("2" (rewrite replace_preserv_parallel_pos) (("1" (inst -3 1+i!1) nil nil) ("2" (inst -3 0) nil nil) ("3" (inst -2 0 1+i!1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 2 3)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-15 1 3 4)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-12 1 2 3)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand replace_par_pos 5) (("2" (expand finseq_appl) (("2" (expand add_first 5 (1 2 3 5)) (("2" (expand insert?) (("2" (rewrite rest_add_first) (("2" (rewrite rest_add_first) (("2" (expand replace_par_pos 5) (("2" (expand finseq_appl) (("2" (expand rest 5 (1 2 3)) (("2" (expand* ^ min empty_seq) (("2" (expand add_first 5 (1 2 3)) (("2" (expand insert?) (("2" (rewrite rest_add_first) (("2" (rewrite rest_add_first) (("2" (expand replace_par_pos -6) (("2" (expand finseq_appl) (("2" (expand delete -6 (1 2 3)) (("2" (expand finseq_appl) (("2" (expand add_first -6 (1 2)) (("2" (expand insert?) (("2" (rewrite rest_add_first) (("2" (case "rest(delete(fst, 1)) = rest(rest(fst))") (("1" (replace -1) (("1" (replace -3) (("1" (lemma replace_par_pos_equivalence) (("1" (inst -1 "add_first(choose(complement_pos_set(<=, o)(p, x`seq(1))) ,complement_pos(p, rest(rest(x))))" "add_first(fst`seq(1), rest(fst1!1))" "replaceTerm(subtermOF(s, p),fst1!1`seq(0),p1!1)") (("1" (expand finseq_appl) (("1" (expand add_first -1 (2 3 4 5 6 11 12)) (("1" (expand insert?) (("1" (rewrite rest_add_first) (("1" (rewrite rest_add_first) (("1" (prop) (("1" (replaces -1) (("1" (replace -7 5 rl) (("1" (lemma replace_distributivity) (("1" (typepred "choose(complement_pos_set(<=, o)(p, x`seq(1)))") (("1" (expand complement_pos_set -1 1) (("1" (expand emptyset) (("1" (prop) (("1" (inst -3 p "choose(complement_pos_set(<=, o)(p, x`seq(1)))" "replace_par_pos(replaceTerm
                                                                                                                                                                       (s, fst`seq(0), x`seq(0)), rest(rest(x)),
                                                                                                                                                                       rest(rest(fst)))" "fst`seq(1)") (("1" (prop) (("1" (replace -1 6 rl) (("1" (replace -3 6 rl) (("1" (hide -1) (("1" (lemma replace_par_pos_equivalence) (("1" (expand finseq_appl) (("1" (inst -1 "add_first(x`seq(1), delete(x, 1))" "add_first(fst`seq(1), delete(fst,1))" s) (("1" (rewrite rest_add_first) (("1" (rewrite rest_add_first) (("1" (expand add_first -1 (2 3 4 5 6 7 8)) (("1" (expand insert?) (("1" (expand delete -1 (2 3 4)) (("1" (prop) (("1" (expand replace_par_pos -1) (("1" (expand finseq_appl) (("1" (lift-if) (("1" (expand delete -1 (1 2 3 6 7)) (("1" (expand finseq_appl) (("1" (replace -4) (("1" (replace -6) (("1" (lemma replace_commutativity) (("1" (inst -1 "x`seq(0)" "x`seq(1)" "fst`seq(1)" s "fst`seq(0)") (("1" (expand* SPP? SP? PP? finseq_appl) (("1" (assert) (("1" (hide-all-but (-12 1)) (("1" (flatten) (("1" (prop) (("1" (inst -2 0) nil nil) ("2" (inst -2 1) nil nil) ("3" (inst -1 0 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-11 1 4 5)) (("2" (expand SPP?) (("2" (flatten) (("2" (split) (("1" (rewrite add_first_parallel_pos_to_PP_is_PP) (("1" (expand finseq_appl) (("1" (hide 2) (("1" (skeep) (("1" (typepred i!1) (("1" (expand delete) (("1" (expand finseq_appl) (("1" (lift-if) (("1" (expand* PP? finseq_appl) (("1" (prop) (("1" (inst -3 i!1 1) (("1" (assert) nil nil)) nil) ("2" (inst -2 1+i!1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite delete_of_PP_is_PP) nil nil)) nil) ("2" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (hide 2) (("1" (expand* SP? finseq_appl) (("1" (inst -2 1) nil nil)) nil)) nil) ("2" (rewrite delete_of_SP_is_SP) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -2 1 rl) (("2" (hide-all-but (-3 -5 -10 -11 1 4 5)) (("2" (lemma replace_par_pos_preservs_pos) (("2" (inst -1 "delete(x, 1)" "delete(fst, 1)" "x`seq(1)" s) (("2" (expand delete -1 (2 3)) (("2" (expand replace_par_pos -1) (("2" (expand finseq_appl) (("2" (expand delete -1 (2 3 4)) (("2" (expand finseq_appl) (("2" (assert) (("2" (hide -1 -2 2) (("2" (expand SPP?) (("2" (flatten) (("2" (split) (("1" (rewrite add_first_parallel_pos_to_PP_is_PP) (("1" (expand finseq_appl) (("1" (hide 2) (("1" (skeep) (("1" (typepred i!1) (("1" (expand delete) (("1" (expand* PP? finseq_appl) (("1" (lift-if) (("1" (prop) (("1" (inst -4 i!1 1) (("1" (assert) nil nil)) nil) ("2" (inst -3 1+i!1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite delete_of_PP_is_PP) nil nil)) nil) ("2" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (hide 2) (("1" (expand* SP? finseq_appl) (("1" (inst -3 1) nil nil)) nil)) nil) ("2" (rewrite delete_of_SP_is_SP) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -7 6) (("2" (expand SPP?) (("2" (flatten) (("2" (lemma rest_of_PP_is_PP) (("2" (inst -1 x) (("2" (lemma complement_pos_is_PP) (("2" (inst -1 "rest(x)" p) (("2" (assert) (("2" (expand complement_pos -1) (("2" (expand rest -1 (1 2 3)) (("2" (expand* ^ min empty_seq) (("2" (assert) (("2" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (hide 2) (("1" (rewrite replace_preserv_parallel_pos 1) (("1" (hide 2) (("1" (typepred "choose(complement_pos_set(<=, o)(p, x`seq(1)))") (("1" (expand complement_pos_set -1 1) (("1" (expand emptyset) (("1" (prop) (("1" (lemma pos_subterm_ax) (("1" (inst -1 p "choose(complement_pos_set(<=, o)(p, x`seq(1)))" s) (("1" (assert) (("1" (expand* SP? finseq_appl) (("1" (inst -13 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* SP? finseq_appl) (("2" (lemma pos_subterm_ax) (("2" (inst -1 p p1!1 s) (("2" (inst -12 0) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "choose(complement_pos_set(<=, o)(p, x`seq(1)))") (("3" (expand complement_pos_set -1 1) (("3" (expand emptyset) (("3" (prop) (("3" (expand PP? -12) (("3" (expand finseq_appl) (("3" (inst -12 0 1) (("3" (lemma parallel_pos_same_prefix) (("3" (inst -1 p "x`seq(0)" "x`seq(1)" p1!1 "choose(complement_pos_set(<=, o)(p, x`seq(1)))") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (lemma complement_pos_character) (("2" (inst -1 "rest(rest(x))" p "complement_pos(p,
                                                                                                                                                                                                     rest[position[variable, symbol, arity]]
                                                                                                                                                                                                         (rest
                                                                                                                                                                                                          [position[variable, symbol, arity]]
                                                                                                                                                                                                          (x)))`seq
                                                                                                                                                                                          (i!1)") (("2" (rewrite rest_of_PP_is_PP) (("2" (prop) (("1" (skosimp) (("1" (expand rest -1 (1 2)) (("1" (typepred i!2) (("1" (expand rest -1) (("1" (expand* ^ min empty_seq) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (rewrite replace_preserv_parallel_pos 5) (("1" (hide 6) (("1" (inst -12 2+i!2) (("1" (lemma pos_subterm_ax) (("1" (inst -1 p "complement_pos(p,
                                                                                                                                                                                                               rest[position[variable, symbol, arity]]
                                                                                                                                                                                                                   (rest[position[variable, symbol, arity]](x)))`seq
                                                                                                                                                                                                    (i!1)" s) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 6) (("2" (lemma pos_subterm_ax) (("2" (inst -13 0) (("2" (inst -1 p p1!1 s) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand PP? -11) (("3" (expand finseq_appl) (("3" (hide 6) (("3" (inst -11 0 2+i!2) (("3" (assert) (("3" (lemma parallel_pos_same_prefix) (("3" (inst -1 p "x`seq(0)" "x`seq(2+i!2)" p1!1 "complement_pos(p,
                                                                                                                                                                                                               rest[position[variable, symbol, arity]]
                                                                                                                                                                                                                   (rest[position[variable, symbol, arity]](x)))`seq
                                                                                                                                                                                                    (i!1)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* "seq2set" "finseq_appl") (("2" (inst 1 i!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-6 1 3 4 5)) (("3" (expand rest 1 1) (("3" (expand* ^ min empty_seq) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-11 1 3 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst 5 fst1!1) (("2" (expand add_first 5 1) (("2" (expand insert?) (("2" (expand replace_par_pos 5) (("2" (expand finseq_appl) (("2" (rewrite rest_add_first) (("2" (expand add_first 5) (("2" (expand insert?) (("2" (expand replace_par_pos -5) (("2" (expand delete -5 (1 2 3)) (("2" (expand finseq_appl) (("2" (rewrite rest_add_first -5) (("2" (expand* add_first insert?) (("2" (replace -5 5 rl) (("2" (hide -5) (("2" (expand replace_par_pos 5 1) (("2" (expand finseq_appl) (("2" (expand rest 5 (1 2 3)) (("2" (expand* ^ min empty_seq) (("2" (lemma replace_par_pos_equivalence) (("2" (inst -1 "rest(x)" "rest(fst)" "replaceTerm
                                                                                                                                              (s, fst`seq(0), x`seq(0))") (("2" (expand finseq_appl) (("2" (expand rest -1 (2 3 4 5 6 15 16)) (("2" (expand* ^ min) (("2" (prop) (("1" (case "rest(delete(fst, 1)) = rest(rest(fst))") (("1" (replaces -2 5) (("1" (rewrite replace_persistence 5) (("1" (assert) nil nil) ("2" (hide 6) (("2" (lemma replace_par_pos_preservs_pos) (("2" (inst -1 "rest(rest(x))" "rest(rest(fst))" "x`seq(1)" "replaceTerm(s, fst`seq(0), x`seq(0))") (("2" (expand rest -1 (3 4 5 6)) (("2" (expand* ^ min empty_seq) (("2" (prop) (("1" (hide 2) (("1" (lemma seq_first_rest[position]) (("1" (inst -1 "rest(x)") (("1" (expand* first finseq_appl) (("1" (expand rest -1 (1 3)) (("1" (expand* ^ min) (("1" (replace -1 1 rl) (("1" (expand SPP?) (("1" (flatten) (("1" (rewrite rest_of_PP_is_PP) (("1" (hide -1) (("1" (expand rest 1) (("1" (expand* ^ min empty_seq) (("1" (expand* SP? PP? finseq_appl) (("1" (skeep) (("1" (rewrite replace_preserv_parallel_pos 1) (("1" (inst -8 1+i!1) nil nil) ("2" (inst -8 0) nil nil) ("3" (inst -7 0 1+i!1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 6) (("3" (lemma replace_par_pos_preservs_pos) (("3" (inst -1 "rest(rest(x))" "rest(rest(fst))" "x`seq(0)" "replaceTerm(s, fst`seq(0), x`seq(0))") (("3" (prop) (("1" (lemma closed_positions) (("1" (inst -1 p p1 "replace_par_pos(replaceTerm(s, fst`seq(0), x`seq(0)),
                                                                                                                                                                    rest(rest(x)), rest(rest(fst)))") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand SPP?) (("2" (flatten) (("2" (split) (("1" (rewrite add_first_parallel_pos_to_PP_is_PP) (("1" (hide 2) (("1" (skeep) (("1" (typepred i!1) (("1" (expand rest (-1 1)) (("1" (expand* ^ min empty_seq finseq_appl) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (expand* PP? finseq_appl) (("1" (inst -8 2+i!1 0) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-7 1)) (("2" (rewrite "rest_of_PP_is_PP") (("2" (hide 2) (("2" (rewrite "rest_of_PP_is_PP") nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (hide 2) (("1" (lemma replace_preserv_pos) (("1" (inst -1 "x`seq(0)" s "fst`seq(0)") (("1" (assert) (("1" (expand* SP? finseq_appl) (("1" (inst -8 0) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand rest 1) (("2" (expand* ^ min empty_seq) (("2" (assert) (("2" (expand* SP? PP? finseq_appl) (("2" (prop) (("1" (skeep) nil nil) ("2" (skeep) nil nil) ("3" (skeep) (("3" (rewrite replace_preserv_parallel_pos) (("1" (inst -8 2+i!1) nil nil) ("2" (inst -8 0) nil nil) ("3" (inst -7 0 2+i!1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-10 1 4 5)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 6) (("4" (expand parallel) (("4" (split) (("1" (expand* SPP? PP? finseq_appl) (("1" (flatten) (("1" (inst -8 0 1) (("1" (expand parallel) (("1" (flatten) (("1" (expand <= (-1 5)) (("1" (skosimp) (("1" (replace -1 -5) (("1" (inst 5 "p1!2 o p1!1") (("1" (rewrite o_assoc) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* SPP? PP? finseq_appl) (("2" (flatten) (("2" (hide -4) (("2" (expand* nonempty? empty? member complement_pos_set emptyset) (("2" (copy -1) (("2" (expand <= -1) (("2" (skosimp) (("2" (inst -4 p1!2) (("2" (prop) (("2" (inst -9 0 1) (("2" (assert) (("2" (expand parallel) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-10 1 3 4)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 6) (("2" (expand SPP?) (("2" (flatten) (("2" (rewrite rest_of_PP_is_PP) (("2" (expand rest 1) (("2" (expand* ^ min empty_seq) (("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (expand* PP? finseq_appl) (("2" (rewrite replace_preserv_parallel_pos) (("1" (inst -7 1+i!1) nil nil) ("2" (inst -7 0) nil nil) ("3" (inst -6 0 1+i!1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -8 -9 1 2 3)) (("2" (typepred "choose(complement_pos_set(<=, o)(p, x`seq(0)))") (("2" (expand complement_pos_set -1 1) (("2" (lemma equal_prefix[posnat]) (("2" (inst -1 p "choose(complement_pos_set(<=, o)(p, x`seq(0)))" p1!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2 3)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -6 -7 1 3 4)) (("2" (expand* nonempty? empty? member complement_pos_set emptyset) (("2" (inst -1 p1!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 2 3)) (("2" (expand SPP?) (("2" (flatten) (("2" (rewrite delete_of_PP_is_PP) (("2" (rewrite delete_of_SP_is_SP) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1 2 3)) (("3" (expand* delete seq2set finseq_appl) (("3" (inst 1 0) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (inst -1 "rest(x)") (("2" (rewrite length_rest) (("2" (inst -1 "rest(fst)" p p1 "replaceTerm(s, fst`seq(0), x`seq(0))") (("1" (assert) (("1" (prop) (("1" (skosimp) (("1" (expand complement_pos 5) (("1" (case "nonempty?(complement_pos_set(<=, o)(p, x`seq(0)))") (("1" (assert) (("1" (inst 5 "add_first(fst`seq(0), fst1!1)") (("1" (expand add_first 5 (1 2)) (("1" (expand insert?) (("1" (expand replace_par_pos 5) (("1" (expand finseq_appl) (("1" (expand add_first 5 (1 2 3)) (("1" (expand insert?) (("1" (rewrite rest_add_first) (("1" (rewrite rest_add_first) (("1" (replaces -3) (("1" (typepred "choose(complement_pos_set(<=, o)(p, x`seq(0)))") (("1" (expand complement_pos_set -1 1) (("1" (expand emptyset) (("1" (prop) (("1" (name-replace "B" "choose(complement_pos_set(<=, o)(p, x`seq(0)))") (("1" (replace -2 6) (("1" (rewrite replace_distributivity 6) (("1" (expand* SPP? SP? finseq_appl) (("1" (flatten) (("1" (inst -6 0) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst 6 fst1!1) (("2" (assert) (("2" (expand replace_par_pos 6 1) (("2" (expand finseq_appl) (("2" (replaces -2) (("2" (expand* SPP? SP? PP? finseq_appl) (("2" (flatten) (("2" (rewrite replace_persistence 6) (("1" (inst -3 0) nil nil) ("2" (inst -3 i) (("2" (lemma closed_positions) (("2" (inst -1 p p1 s) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide -1 7) (("3" (expand parallel) (("3" (split) (("1" (inst -2 0 i) (("1" (assert) (("1" (flatten) (("1" (expand <= (-1 -4 5)) (("1" (skosimp*) (("1" (inst 5 "p1!1 o p1!2") (("1" (rewrite o_assoc) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* nonempty? empty? member complement_pos_set emptyset) (("2" (copy -1) (("2" (expand <= -1) (("2" (skosimp) (("2" (inst -3 p1!1) (("2" (prop) (("2" (inst -4 0 i) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 6) (("2" (expand SPP?) (("2" (flatten) (("2" (rewrite rest_of_PP_is_PP) (("2" (expand* rest ^ min empty_seq) (("2" (expand* SP? PP? finseq_appl) (("2" (skeep) (("2" (rewrite replace_preserv_parallel_pos) (("1" (inst -2 1+i!1) nil nil) ("2" (inst -2 0) nil nil) ("3" (inst -1 0 1+i!1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 6) (("3" (expand* rest ^ min empty_seq seq2set finseq_appl) (("3" (inst 1 i-1) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide -1 6) (("4" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 6) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 0) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (expand SPP?) (("3" (rewrite complement_pos_is_PP) (("3" (expand* SP? finseq_appl) (("3" (flatten) (("3" (skeep) (("3" (lemma complement_pos_character) (("3" (inst -1 fsp p "complement_pos(p, fsp)`seq(i)") (("3" (assert) (("3" (prop) (("1" (skosimp) (("1" (inst -3 i!1) (("1" (lemma pos_subterm_ax) (("1" (inst -1 p "complement_pos(p, fsp)`seq(i)" s) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand* seq2set finseq_appl) (("2" (inst 1 i) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (expand* seq2set finseq_appl) (("4" (skosimp) (("4" (expand* SPP? SP? finseq_appl) (("4" (flatten) (("4" (inst -2 kk!1) (("4" (lemma closed_positions) (("4" (inst -1 p p1 s) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (lemma replace_par_pos_preservs_PP) (("5" (inst -1 fsp fst s) (("5" (assert) (("5" (expand* seq2set finseq_appl) (("5" (skosimp) (("5" (inst -1 kk!1) (("5" (lemma closed_positions) (("5" (inst -1 p p1 "replace_par_pos(s, fsp, fst)") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ((replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (choose const-decl "(p)" sets nil) (PRED type-eq-decl nil defined_types nil) (O const-decl "finseq" finite_sequences nil) (rest_add_first formula-decl nil seq_extras structures) (replace_distributivity formula-decl nil replacement nil) (SP? const-decl "bool" positions nil) (TRUE const-decl "bool" booleans nil) (equal_prefix formula-decl nil seq_extras structures) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (empty_seq const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (rest const-decl "finseq" seq_extras structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (add_first const-decl "finseq" seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (complement_pos_set const-decl "set[T]" predicate_fseq2set nil) (emptyset const-decl "set" sets nil) (s skolem-const-decl "term" orthogonality_basis nil) (length_rest formula-decl nil seq_extras structures) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (PP? const-decl "bool" positions nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (rest_of_PP_is_PP formula-decl nil positions nil) (PP type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (replace_par_pos_equivalence formula-decl nil orthogonality_basis nil) (pos_subterm_ax formula-decl nil subterm nil) (parallel_pos_same_prefix formula-decl nil positions nil) (complement_pos_character formula-decl nil orthogonality_basis nil) (complement_pos_is_PP formula-decl nil orthogonality_basis nil) (replace_commutativity formula-decl nil replacement nil) (delete_of_PP_is_PP formula-decl nil positions nil) (add_first_parallel_pos_to_PP_is_PP formula-decl nil positions nil) (delete_of_SP_is_SP formula-decl nil positions nil) (add_first_parallel_pos_to_SP_is_SP formula-decl nil positions nil) (SP type-eq-decl nil positions nil) (o_assoc formula-decl nil finite_sequences nil) (parallel const-decl "bool" positions nil) (replace_preserv_pos formula-decl nil replacement nil) (closed_positions formula-decl nil positions nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (first const-decl "T" seq_extras structures) (seq_first_rest formula-decl nil seq_extras structures) (replace_persistence formula-decl nil replacement nil) (fst skolem-const-decl "finseq[term]" orthogonality_basis nil) (delete const-decl "finseq" seq_extras structures) (x skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (SPP type-eq-decl nil positions nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (SPP? const-decl "bool" positions nil) (finite_sequence type-eq-decl nil finite_sequences nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (<= const-decl "bool" positions nil) (/= const-decl "boolean" notequal nil) (= const-decl "[T, T -> boolean]" equalities nil) (complement_pos def-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (parallel_reduction_variables 0 (parallel_reduction_variables-1 nil 3578314930 ("" (skeep) (("" (skeep) (("" (expand parallel_reduction_fix?) (("" (skosimp) (("" (typepred x) (("" (skosimp) (("" (expand V) (("" (typepred p!1) (("" (hide -5 2) (("" (case "PP?(add_first(p!1, fsp))") (("1" (lemma replace_par_pos_preservs_subterm) (("1" (lemma replace_par_pos_preservs_pos) (("1" (inst -1 fsp "sigma_rhs(fss!1, fse!1)" p!1 "ext(sigma)(lhs(e))") (("1" (inst -2 fsp "sigma_rhs(fss!1, fse!1)" p!1 "ext(sigma)(lhs(e))") (("1" (expand SPP?) (("1" (assert) (("1" (case "SP?(ext(sigma)(lhs(e)))(add_first(p!1, fsp))") (("1" (case "sigma_rhs(fss!1, fse!1)`length = fsp`length") (("1" (assert) (("1" (replace -13 -3 rl) (("1" (replace -13 -4 rl) (("1" (expand* parallel_reduction? parallel_reduction_fix?) (("1" (inst 2 empty_seq) (("1" (inst 2 empty_seq empty_seq) (("1" (expand empty_seq 2) (("1" (expand replace_par_pos 2) (("1" (expand subtermsOF 2) (("1" (expand sigma_lhs 2) (("1" (expand empty_seq) (("1" (split) (("1" (decompose-equality 1) (("1" (skeep) nil nil)) nil) ("2" (rewrite subterm_ext_commute -4) (("2" (rewrite subterm_ext_commute -4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite predicate_fseq2set[rewrite_rule].subset_empty_seq) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* empty_seq SPP? PP? SP? finseq_appl) (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-10 1)) (("2" (expand sigma_rhs 1) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (reveal -13) (("2" (expand SPP?) (("2" (flatten) (("2" (rewrite add_first_parallel_pos_to_SP_is_SP) (("2" (hide 2) (("2" (rewrite ext_preserv_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite add_first_parallel_pos_to_PP_is_PP) (("1" (hide 2) (("1" (expand finseq_appl) (("1" (skeep) (("1" (case "fsp`seq(i) = p!1") (("1" (lemma replace_par_pos_preservs_PP) (("1" (lemma replace_par_pos_subterm) (("1" (expand finseq_appl) (("1" (inst -1 fsp "sigma_rhs(fss!1, fse!1)" "ext(sigma)(lhs(e))") (("1" (assert) (("1" (inst -2 fsp "sigma_rhs(fss!1, fse!1)" "ext(sigma)(lhs(e))") (("1" (expand sigma_rhs -1 (1 3)) (("1" (expand sigma_rhs -2 1) (("1" (expand finseq_appl) (("1" (expand* parallel_reduction? parallel_reduction_fix?) (("1" (inst 3 "#(empty_seq)") (("1" (inst 3 "#(fse!1`seq(i))" "#(fss!1`seq(i))") (("1" (expand "#" 3 (1 2 3 4)) (("1" (prop) (("1" (expand "#") (("1" (expand* subtermsOF sigma_lhs empty_seq finseq_appl) (("1" (decompose-equality 1) (("1" (decompose-equality -10) (("1" (inst -1 i) (("1" (expand subtermOF 1) (("1" (rewrite subterm_ext_commute -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -17) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 x!2) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (expand* positionsOF only_empty_seq catenate union IUnion member empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "#") (("2" (expand replace_par_pos 1) (("2" (expand finseq_appl) (("2" (expand rest 1 1) (("2" (expand* ^ min) (("2" (expand empty_seq) (("2" (expand replace_par_pos 1) (("2" (expand replaceTerm 1) (("2" (expand sigma_rhs 1) (("2" (expand finseq_appl) (("2" (replace -11 -1 rl) (("2" (replace -11 -2 rl) (("2" (inst -1 i) (("2" (inst -2 i) (("2" (rewrite subterm_ext_commute -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (reveal -3) (("3" (propax) nil nil)) nil) ("4" (reveal -3) (("4" (propax) nil nil)) nil) ("5" (reveal -3) (("5" (propax) nil nil)) nil) ("6" (reveal -3) (("6" (propax) nil nil)) nil) ("7" (reveal -3) (("7" (propax) nil nil)) nil) ("8" (reveal -3) (("8" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred fse!1) (("2" (expand subset?) (("2" (expand* "subset?" "member" "seq2set" "finseq_appl") (("2" (skosimp*) (("2" (inst?) (("2" (assert) (("2" (inst?) (("2" (expand "#") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "#" SPP? PP? SP? finseq_appl) (("2" (skeep) (("2" (expand* positionsOF only_empty_seq catenate union IUnion member empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand parallel) (("2" (split) (("1" (copy -1) (("1" (expand <= -1) (("1" (skosimp) (("1" (lemma ntCP_lemma_aux1) (("1" (inst -1 sigma "fss!1`seq(i)" E "fsp`seq(i)" e "fse!1`seq(i)") (("1" (prop) (("1" (skosimp) (("1" (expand Ambiguous?) (("1" (inst 2 t1!1 t2!1) nil nil)) nil)) nil) ("2" (lemma pos_ax) (("2" (inst -1 "fsp`seq(i)" p1!1 "lhs(e)") (("2" (assert) nil nil)) nil)) nil) ("3" (lemma variable_positions_parallel) (("3" (inst -1 "lhs(e)" "subtermOF(lhs(e), fsp`seq(i))" x "fsp`seq(i)" p!1) (("1" (expand parallel) (("1" (assert) (("1" (prop) (("1" (lemma variable_positions) (("1" (inst -1 "lhs(e)" x "fsp`seq(i)" p!1) (("1" (assert) (("1" (expand* member Pos_var extend parallel) (("1" (prop) (("1" (lemma pos_ax) (("1" (inst -1 "fsp`seq(i)" p1!1 "lhs(e)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand V) (("2" (propax) nil nil)) nil)) nil)) nil) ("4" (expand* subtermsOF sigma_lhs empty_seq finseq_appl) (("4" (decompose-equality -9) (("1" (inst -1 i) (("1" (rewrite subterm_ext_commute -1) (("1" (lemma pos_ax) (("1" (inst -1 "fsp`seq(i)" p1!1 "lhs(e)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (reveal -14) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 x!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal (-2 2)) (("5" (expand "#" 1) (("5" (case "fsp`length=1") (("1" (decompose-equality 1) (("1" (decompose-equality 1) (("1" (skeep) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand* SPP? PP? finseq_appl) (("2" (flatten) (("2" (assert) (("2" (case "i=0") (("1" (replaces -1) (("1" (inst -1 0 1) (("1" (expand parallel) (("1" (flatten) (("1" (expand <= 2) (("1" (inst 2 "fsp`seq(1)") (("1" (replaces -3) (("1" (rewrite empty_o_seq) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 0 i) (("2" (expand parallel) (("2" (assert) (("2" (flatten) (("2" (expand <= 4) (("2" (inst 4 "fsp`seq(0)") (("2" (replaces -3) (("2" (rewrite empty_o_seq) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred fse!1) (("2" (expand* subset? member) (("2" (expand* "subset?" "member" "seq2set" "finseq_appl") (("2" (inst?) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand member) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand parallel_reduction?) (("2" (reveal -1) (("2" (case "SPP?(ext(sigma)(x))(complement_pos(p!1, fsp))") (("1" (inst 3 "complement_pos(p!1, fsp)") (("1" (lemma replace_par_pos_subterm) (("1" (lemma replace_par_pos_preservs_PP) (("1" (expand finseq_appl) (("1" (inst -1 fsp "sigma_rhs(fss!1, fse!1)" "ext(sigma)(lhs(e))") (("1" (inst -2 fsp "sigma_rhs(fss!1, fse!1)" "ext(sigma)(lhs(e))") (("1" (assert) (("1" (expand sigma_rhs -1 1) (("1" (expand sigma_rhs -2 (1 3)) (("1" (expand finseq_appl) (("1" (case "SPP?(ext(theta)(x))(complement_pos(p!1, fsp))") (("1" (case "FORALL(i:below[complement_pos(p!1, fsp)`length]):
                                                                                            EXISTS((e1|member(e1, E)), sg1): C(e1, sg1, ext(sigma)(x), ext(theta)(x), complement_pos(p!1, fsp)`seq(i))") (("1" (lemma seq_construct2[rewrite_rule]) (("1" (inst -1 "D(ext(sigma)(x), ext(theta)(x), complement_pos(p!1, fsp), E)" "complement_pos(p!1, fsp)`length") (("1" (prop) (("1" (lemma seq_construct2[Sub]) (("1" (inst -1 "G(ext(sigma)(x), ext(theta)(x), complement_pos(p!1, fsp), E)" "complement_pos(p!1, fsp)`length") (("1" (prop) (("1" (skosimp*) (("1" (expand parallel_reduction_fix?) (("1" (inst 3 fseq!2 fseq!1) (("1" (assert) (("1" (split) (("1" (expand subtermsOF 1) (("1" (expand sigma_lhs 1) (("1" (lift-if) (("1" (prop) (("1" (expand empty_seq) (("1" (assert) (("1" (decompose-equality 1) (("1" (expand finseq_appl) (("1" (skeep) nil nil)) nil)) nil)) nil)) nil) ("2" (expand finseq_appl) (("2" (decompose-equality 2) (("1" (inst -2 x!1) (("1" (inst -4 x!1) (("1" (expand extend) (("1" (expand* G D) (("1" (flatten) (("1" (skosimp*) (("1" (hide -6) (("1" (expand C) (("1" (flatten) (("1" (replace -2 -6) (("1" (case "e!1 = fseq!2`seq(x!1)") (("1" (assert) nil nil) ("2" (hide-all-but (-5 -6 1 5)) (("2" (lemma ntCP_lemma_aux1) (("2" (inst -1 "fseq!1`seq(x!1)" sigma!1 E empty_seq e!1 "fseq!2`seq(x!1)") (("2" (assert) (("2" (prop) (("1" (skosimp) (("1" (expand Ambiguous?) (("1" (inst 2 t1!1 t2!1) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* positionsOF only_empty_seq catenate union IUnion member empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but -1) (("3" (expand* empty_seq subtermOF) (("3" (typepred e!1) (("3" (expand rewrite_rule?) (("3" (flatten) (("3" (expand lhs) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand* empty_seq subtermOF) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (skeep) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-9 1)) (("3" (skeep) (("3" (expand* SPP? SP? finseq_appl) (("3" (flatten) (("3" (inst -2 i!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_par_pos_subterm2) (("2" (inst -1 fsp "sigma_rhs(fss!1, fse!1)" p!1 "fsp`seq(i)" "ext(sigma)(lhs(e))") (("2" (assert) (("2" (expand sigma_rhs -1 1) (("2" (prop) (("1" (skosimp) (("1" (expand extend) (("1" (hide -7) (("1" (replace -20 -2 rl) (("1" (rewrite subterm_ext_commute -2) (("1" (rewrite subterm_ext_commute -2) (("1" (replace -15 -2) (("1" (replace -2 1) (("1" (case "fst1!1= sigma_rhs(fseq!1, fseq!2)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand sigma_rhs 1) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (decompose-equality 1) (("1" (decompose-equality 1) nil nil)) nil) ("2" (expand finseq_appl) (("2" (decompose-equality 2) (("2" (decompose-equality 1) (("1" (inst -4 x!1) (("1" (inst -6 x!1) (("1" (expand* G D) (("1" (flatten) (("1" (skosimp*) (("1" (expand C) (("1" (flatten) (("1" (case "e!1 = fseq!2`seq(x!1)") (("1" (replaces -1) (("1" (lemma complement_pos_character) (("1" (inst -1 fsp p!1 "complement_pos(p!1, fsp)`seq(x!1)") (("1" (prop) (("1" (skosimp) (("1" (inst -13 i!1) (("1" (inst -12 i!1) (("1" (replace -24 -13 rl) (("1" (replace -1 -13) (("1" (rewrite pos_subterm -13) (("1" (rewrite subterm_ext_commute -13) (("1" (replace -19 -13) (("1" (replace -13 -6) (("1" (replace -13 -10) (("1" (replace -6 -10) (("1" (lemma replace_par_pos_subterm) (("1" (inst -1 "complement_pos(p!1, fsp)" fst1!1 "ext(sigma)(x)") (("1" (expand finseq_appl) (("1" (inst -1 x!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* seq2set finseq_appl) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -7 -8 1 5)) (("2" (replaces -3) (("2" (lemma ntCP_lemma_aux1) (("2" (inst -1 sigma!1 "fseq!1`seq(x!1)" E empty_seq "fseq!2`seq(x!1)" e!1) (("2" (prop) (("1" (skosimp) (("1" (expand Ambiguous?) (("1" (inst 2 t1!1 t2!1) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* positionsOF only_empty_seq catenate union IUnion member empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but -1) (("3" (expand* empty_seq subtermOF) (("3" (typepred "fseq!2`seq(x!1)") (("3" (expand rewrite_rule?) (("3" (flatten) (("3" (expand lhs) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand* empty_seq subtermOF) nil nil) ("5" (hide-all-but (-1 -3 1)) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 1)) (("2" (skeep) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* seq2set finseq_appl) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 1)) (("2" (expand subset?) (("2" (expand* subset? member seq2set finseq_appl) (("2" (skeep) (("2" (skeep) (("2" (inst -3 kk) (("1" (expand* extend D) (("1" (assert) (("1" (expand member) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand extend) (("2" (hide-all-but (-2 1)) (("2" (skeep) (("2" (inst -1 i!1) (("2" (skosimp) (("2" (inst 1 sg1!1) (("2" (expand G) (("2" (inst 1 e1!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand extend) (("2" (skeep) (("2" (inst -1 i!1) (("2" (skosimp) (("2" (inst 1 e1!1) (("2" (expand D) (("2" (inst 1 sg1!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (skeep) (("2" (lemma complement_pos_character) (("2" (inst -1 fsp p!1 "complement_pos(p!1, fsp)`seq(i!1)") (("2" (prop) (("1" (skosimp) (("1" (expand* subtermsOF sigma_lhs empty_seq finseq_appl) (("1" (decompose-equality -14) (("1" (inst -1 i!2) (("1" (replace -2 -1) (("1" (rewrite pos_subterm -1) (("1" (rewrite subterm_ext_commute -1) (("1" (inst 1 "fse!1`seq(i!2)" "fss!1`seq(i!2)") (("1" (expand C 1) (("1" (assert) (("1" (inst -5 i!2) (("1" (replace -15 -5 rl) (("1" (replace -2 -5) (("1" (rewrite pos_subterm -5) (("1" (rewrite subterm_ext_commute -5) (("1" (assert) nil nil)) nil) ("2" (lemma complement_pos_character) (("2" (inst -1 fsp p!1 "complement_pos(p!1, fsp)`seq(i!1)") (("2" (prop) (("1" (skosimp) (("1" (replace -1 1 rl) (("1" (inst -5 i!3) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* seq2set finseq_appl) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand member) (("2" (typepred fse!1) (("2" (expand subset?) (("2" (expand* subset? member seq2set finseq_appl) (("2" (inst?) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma complement_pos_character) (("2" (inst -1 fsp p!1 "complement_pos(p!1, fsp)`seq(i!1)") (("2" (prop) (("1" (skosimp) (("1" (replace -1 1 rl) (("1" (hide-all-but (-8 1)) (("1" (expand* SPP? SP? finseq_appl) (("1" (flatten) (("1" (inst -2 i!3) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* seq2set finseq_appl) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 x!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* seq2set finseq_appl) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide-all-but (-1 -4 1)) (("3" (expand* SPP? SP? finseq_appl) (("3" (flatten) (("3" (inst -2 i!1) (("3" (inst -4 i!1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand SPP? (-4 1)) (("2" (flatten) (("2" (rewrite complement_pos_is_PP) (("2" (expand SP? 1) (("2" (expand finseq_appl) (("2" (skeep) (("2" (lemma complement_pos_character) (("2" (inst -1 fsp p!1 "complement_pos(p!1, fsp)`seq(i!1)") (("2" (assert) (("2" (prop) (("1" (skosimp) (("1" (replace -15 -2 rl) (("1" (inst -2 i!2) (("1" (replace -1 -2) (("1" (lemma pos_subterm_ax) (("1" (inst -1 p!1 "complement_pos(p!1, fsp)`seq(i!1)" "ext(theta)(lhs(e))") (("1" (assert) (("1" (rewrite subterm_ext_commute -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* seq2set finseq_appl) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand SPP?) (("2" (flatten) (("2" (rewrite complement_pos_is_PP) (("2" (expand* SP? finseq_appl) (("2" (lemma complement_pos_character) (("2" (skeep) (("2" (inst -1 fsp p!1 "complement_pos(p!1, fsp)`seq(i!1)") (("2" (prop) (("1" (skosimp) (("1" (inst -3 i!2) (("1" (lemma pos_subterm_ax) (("1" (inst -1 p!1 "complement_pos(p!1, fsp)`seq(i!1)" "ext(sigma)(lhs(e))") (("1" (assert) (("1" (rewrite subterm_ext_commute -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* seq2set finseq_appl) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (expand SPP?) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq type-eq-decl nil finite_sequences nil) (PP? const-decl "bool" positions nil) (add_first const-decl "finseq" seq_extras structures) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (SP type-eq-decl nil positions nil) (add_first_parallel_pos_to_SP_is_SP formula-decl nil positions nil) (ext_preserv_pos formula-decl nil substitution nil) (parallel_reduction? const-decl "bool" orthogonality_basis nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" orthogonality_basis nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (sigma_lhs const-decl "finseq[term]" orthogonality_basis nil) (FALSE const-decl "bool" booleans nil) (TRUE const-decl "bool" booleans nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (< const-decl "bool" reals nil) (subterm_ext_commute formula-decl nil substitution nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (subset_empty_seq formula-decl nil predicate_fseq2set nil) (SPP type-eq-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (x skolem-const-decl "Vars?[variable, symbol, arity](lhs(e))" orthogonality_basis nil) (e skolem-const-decl "rewrite_rule[variable, symbol, arity]" orthogonality_basis nil) (sigma skolem-const-decl "Sub[variable, symbol, arity]" orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (subset? const-decl "bool" predicate_fseq2set nil) (ext def-decl "term" substitution nil) (replace_par_pos_preservs_subterm formula-decl nil orthogonality_basis nil) (parallel const-decl "bool" positions nil) (complement_pos def-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (complement_pos_is_PP formula-decl nil orthogonality_basis nil) (pos_subterm_ax formula-decl nil subterm nil) (C const-decl "bool" orthogonality_basis nil) (theta skolem-const-decl "Sub[variable, symbol, arity]" orthogonality_basis nil) (D const-decl "bool" orthogonality_basis nil) (PRED type-eq-decl nil defined_types nil) (kk skolem-const-decl "below(length(fseq!2))" orthogonality_basis nil) (replace_par_pos_subterm2 formula-decl nil orthogonality_basis nil) (fst1!1 skolem-const-decl "finseq[term]" orthogonality_basis nil) (complement_pos_character formula-decl nil orthogonality_basis nil) (pos_subterm formula-decl nil subterm nil) (x!1 skolem-const-decl "below[fst1!1`length]" orthogonality_basis nil) (rhs const-decl "term" rewrite_rules nil) (x!1 skolem-const-decl "below[complement_pos(p!1, fsp)`length]" orthogonality_basis nil) (fseq!1 skolem-const-decl "finseq[Sub[variable, symbol, arity]]" orthogonality_basis nil) (fseq!2 skolem-const-decl "finseq[rewrite_rule[variable, symbol, arity]]" orthogonality_basis nil) (G const-decl "bool" orthogonality_basis nil) (seq_construct2 formula-decl nil predicate_fseq2set nil) (i!2 skolem-const-decl "below[fsp`length]" orthogonality_basis nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](lhs(e))" orthogonality_basis nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (empty_o_seq formula-decl nil seq_extras structures) (variable_positions_parallel formula-decl nil subterm nil) (Pos_var const-decl "positions" subterm nil) (extend const-decl "R" extend nil) (variable_positions formula-decl nil subterm nil) (pos_ax formula-decl nil positions nil) (Ambiguous? const-decl "bool" orthogonality_basis nil) (ntCP_lemma_aux1 formula-decl nil orthogonality_basis nil) (<= const-decl "bool" positions nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (finite_sequence type-eq-decl nil finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (below type-eq-decl nil naturalnumbers nil) (subset? const-decl "bool" sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (^ const-decl "finseq" finite_sequences nil) (replaceTerm def-decl "term" replacement nil) (rest const-decl "finseq" seq_extras structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (only_empty_seq const-decl "positions" positions nil) (i skolem-const-decl "below[length(fsp)]" orthogonality_basis nil) (fsp skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (fse!1 skolem-const-decl "{fse | subset?(fse, E)}" orthogonality_basis nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (replace_par_pos_subterm formula-decl nil orthogonality_basis nil) (add_first_parallel_pos_to_PP_is_PP formula-decl nil positions nil) (PP type-eq-decl nil positions nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (positions? type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (subtermOF def-decl "term" subterm nil) (Vars? type-eq-decl nil subterm nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil)) shostak)) (replace_par_pos_dominance_TCC1 0 (replace_par_pos_dominance_TCC1-2 "" 3803941472 ("" (skosimp*) (("" (expand dominates?) (("" (expand SPP? -4) (("" (flatten) (("" (expand* SP? finseq_appl) (("" (skosimp) (("" (expand parallel_reduction_fix? -) (("" (skosimp) (("" (lemma replace_par_pos_preservs_pos) (("" (inst -1 fsp1!1 "sigma_rhs(fss!1, fse!1)" "fsp!1`seq(i!1)" t!1) (("" (assert) (("" (split) (("1" (expand SPP? 1) (("1" (split) (("1" (rewrite add_first_parallel_pos_to_PP_is_PP) (("1" (expand finseq_appl) (("1" (hide 2) (("1" (skosimp) (("1" (expand parallel) (("1" (split) (("1" (inst - "fsp1!1`seq(i!2)") (("1" (prop) (("1" (skosimp) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (case "kk!1 = i!1") (("1" (replaces -1) (("1" (case "fsp!1`seq(i!1) = fsp1!1`seq(i!2)") (("1" (replaces -1) (("1" (lemma replace_par_pos_preservs_PP) (("1" (inst -1 fsp1!1 "sigma_rhs(fss!1, fse!1)" t!1) (("1" (assert) (("1" (prop) (("1" (inst -1 i!2) (("1" (expand finseq_appl) (("1" (assert) nil nil)) nil)) nil) ("2" (expand sigma_rhs 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand <=) (("2" (skosimp*) (("2" (replaces -1) (("2" (case "p1!1`length=0") (("1" (rewrite empty_0 -1) (("1" (replace -1) (("1" (rewrite seq_o_empty 1) nil nil)) nil)) nil) ("2" (expand o -1) (("2" (decompose-equality -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* PP? finseq_appl) (("2" (assert) (("2" (inst -8 i!1 kk!1) (("2" (assert) (("2" (expand parallel -8) (("2" (flatten) (("2" (expand <=) (("2" (skosimp*) (("2" (replace -1 -2) (("2" (inst 3 "p1!1 o p1!2") (("2" (rewrite o_assoc) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "seq2set" "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_par_pos_preservs_PP) (("2" (inst -1 fsp1!1 "sigma_rhs(fss!1, fse!1)" t!1) (("2" (assert) (("2" (prop) (("1" (expand finseq_appl) (("1" (inst -1 i!2) (("1" (replace -7 -1 rl) (("1" (expand <= -2) (("1" (skosimp) (("1" (replace -2 -1) (("1" (lemma pos_ax) (("1" (inst -1 "fsp!1`seq(i!1)" p1!1 s!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand sigma_rhs 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand SPP?) (("2" (propax) nil nil)) nil)) nil) ("2" (expand* add_first insert? SP? finseq_appl) (("2" (skeep) (("2" (prop) (("1" (inst -9 i!1) nil nil) ("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -7 "i_1 -1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand sigma_rhs 1) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (replace_par_pos_dominance subtype "orthogonality_basis.fsp" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SP(orthogonality_basis.s)")) (replace_par_pos_dominance_TCC1-1 nil 3668595362 ("" (skosimp*) (("" (expand dominates?) (("" (expand SPP? -1) (("" (flatten) (("" (expand* SP? finseq_appl) (("" (skosimp) (("" (expand parallel_reduction_fix? -4) (("" (skosimp) (("" (lemma replace_par_pos_preservs_pos) (("" (inst -1 fsp1!1 "sigma_rhs(fss!1, fse!1)" "fsp!1`seq(i!1)" t!1) (("" (assert) (("" (split) (("1" (expand SPP? 1) (("1" (split) (("1" (rewrite add_first_parallel_pos_to_PP_is_PP) (("1" (expand finseq_appl) (("1" (hide 2) (("1" (skosimp) (("1" (expand parallel) (("1" (split) (("1" (inst -9 "fsp1!1`seq(i!2)") (("1" (prop) (("1" (skosimp) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (case "kk!1 = i!1") (("1" (replaces -1) (("1" (case "fsp!1`seq(i!1) = fsp1!1`seq(i!2)") (("1" (replaces -1) (("1" (lemma replace_par_pos_preservs_PP) (("1" (inst -1 fsp1!1 "sigma_rhs(fss!1, fse!1)" t!1) (("1" (assert) (("1" (prop) (("1" (inst -1 i!2) (("1" (expand finseq_appl) (("1" (assert) nil nil)) nil)) nil) ("2" (expand sigma_rhs 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand <=) (("2" (skosimp*) (("2" (replaces -1) (("2" (case "p1!1`length=0") (("1" (rewrite empty_0 -1) (("1" (replace -1) (("1" (rewrite seq_o_empty 1) nil nil)) nil)) nil) ("2" (expand o -1) (("2" (decompose-equality -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* PP? finseq_appl) (("2" (assert) (("2" (inst -3 i!1 kk!1) (("2" (assert) (("2" (expand parallel -3) (("2" (flatten) (("2" (expand <=) (("2" (skosimp*) (("2" (replace -1 -2) (("2" (inst 3 "p1!1 o p1!2") (("2" (rewrite o_assoc) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "seq2set" "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_par_pos_preservs_PP) (("2" (inst -1 fsp1!1 "sigma_rhs(fss!1, fse!1)" t!1) (("2" (assert) (("2" (prop) (("1" (expand finseq_appl) (("1" (inst -1 i!2) (("1" (replace -9 -1 rl) (("1" (expand <= -2) (("1" (skosimp) (("1" (replace -2 -1) (("1" (lemma pos_ax) (("1" (inst -1 "fsp!1`seq(i!1)" p1!1 s!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand sigma_rhs 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand SPP?) (("2" (propax) nil nil)) nil)) nil) ("2" (expand* add_first insert? SP? finseq_appl) (("2" (skeep) (("2" (prop) (("1" (inst -3 i!1) nil nil) ("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -4 "i_1 -1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand sigma_rhs 1) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dominates? const-decl "bool" predicate_fseq2set nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (= const-decl "[T, T -> boolean]" equalities nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (subset? const-decl "bool" predicate_fseq2set nil) (< const-decl "bool" reals nil) (seq2set const-decl "finite_set[T]" seq2set structures) (below type-eq-decl nil naturalnumbers nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (seq_o_empty formula-decl nil seq_extras structures) (empty_0 formula-decl nil seq_extras structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (O const-decl "finseq" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (<= const-decl "bool" positions nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (o_assoc formula-decl nil finite_sequences nil) (pos_ax formula-decl nil positions nil) (parallel const-decl "bool" positions nil) (add_first_parallel_pos_to_PP_is_PP formula-decl nil positions nil) (PP? const-decl "bool" positions nil) (PP type-eq-decl nil positions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (fsp1!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (i_1 skolem-const-decl "below[1 + fsp1!1`length]" orthogonality_basis nil) (add_first const-decl "finseq" seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (empty_seq const-decl "finseq" finite_sequences nil) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (SP? const-decl "bool" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (SPP? const-decl "bool" positions nil)) nil (replace_par_pos_dominance subtype "orthogonality_basis.fsp" "positions[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].SP(orthogonality_basis.s)"))) (replace_par_pos_dominance_TCC2 0 (replace_par_pos_dominance_TCC2-1 nil 3668595362 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (seq2set const-decl "finite_set[T]" seq2set structures) (O const-decl "finseq" finite_sequences nil) (<= const-decl "bool" positions nil) (dominates? const-decl "bool" predicate_fseq2set nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (replace_par_pos_dominance subtype "orthogonality_basis.subtermsOF(orthogonality_basis.s, orthogonality_basis.fsp)" "{fst | orthogonality_basis.fst`length = orthogonality_basis.fsp`length}"))) (replace_par_pos_dominance 0 (replace_par_pos_dominance-1 nil 3668619759 ("" (expand "dominates?") (("" (measure-induct "fsp1`length" fsp1) (("1" (skeep) (("1" (case "x_1`length=0") (("1" (measure-induct "fsp`length" fsp) (("1" (hide -2) (("1" (skosimp) (("1" (skeep) (("1" (case "x!1`length=0") (("1" (hide -2) (("1" (expand parallel_reduction_fix?) (("1" (skosimp) (("1" (expand replace_par_pos) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand parallel_reduction_fix?) (("2" (assert) (("2" (skosimp) (("2" (expand replace_par_pos -1 1) (("2" (expand replace_par_pos (-7 2)) (("2" (expand finseq_appl) (("2" (inst -1 "rest(x!1)") (("2" (rewrite length_rest) (("2" (inst -1 E s "replaceTerm(t, subtermsOF(s, x!1)`seq(0),
                                                                 x!1`seq(0))") (("2" (assert) (("2" (prop) (("1" (rewrite subtermsOF_rest 2) (("1" (expand SPP? -2) (("1" (propax) nil nil)) nil)) nil) ("2" (expand SPP? (-1 1)) (("2" (flatten) (("2" (rewrite rest_of_PP_is_PP) (("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (typepred i) (("2" (expand rest (-1 1)) (("2" (expand* ^ min) (("2" (expand empty_seq -1) (("2" (lift-if) (("2" (assert) (("2" (prop) (("2" (inst-cp -3 1+i) (("2" (inst -3 0) (("2" (expand* PP? finseq_appl) (("2" (assert) (("2" (inst -2 0 1+i) (("2" (rewrite replace_preserv_parallel_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand SPP? (-2 1)) (("3" (flatten) (("3" (assert) (("3" (expand* SP? PP? finseq_appl) (("3" (skeep) nil nil)) nil)) nil)) nil)) nil) ("4" (replaces -6) (("4" (expand subtermsOF 1 (2 3)) (("4" (expand finseq_appl) (("4" (rewrite replace_subterm_of_term) (("1" (inst 1 fse!1 fss!1) (("1" (assert) nil nil)) nil) ("2" (expand SPP? -1) (("2" (flatten) (("2" (expand* SP? finseq_appl) (("2" (inst -2 0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (hide-all-but (-1 -9)) (("5" (expand* "seq2set" "finseq_appl") (("5" (skosimp) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but 1) (("2" (expand subtermsOF) (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide-all-but (-1 -3 -5 1)) (("3" (expand SPP?) (("3" (flatten) (("3" (expand* parallel_reduction_fix? replace_par_pos finseq_appl) (("3" (skosimp) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep 2) (("2" (inst -1 "rest(x_1)") (("2" (rewrite length_rest) (("2" (expand parallel_reduction_fix? -4) (("2" (skosimp) (("2" (expand replace_par_pos -7) (("2" (expand finseq_appl) (("2" (assert) (("2" (expand sigma_rhs -7 1) (("2" (expand finseq_appl) (("2" (rewrite sigma_rhs_rest -7) (("2" (inst -1 E fsp s "replaceTerm(t, ext(fss!1`seq(0))(rhs(fse!1`seq(0))),
                                                     x_1`seq(0))") (("2" (assert) (("2" (prop) (("1" (inst -8 "x_1`seq(0)") (("1" (split) (("1" (skosimp) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (lemma replace_par_pos_equivalence1) (("1" (inst -1 fsp "subtermsOF(s, fsp)" kk!1 t) (("1" (assert) (("1" (expand finseq_appl) (("1" (expand subtermsOF -1 1) (("1" (replace -1 2 rl) (("1" (lemma replace_par_pos_equivalence1) (("1" (inst -1 fsp "subtermsOF(s, fsp)" kk!1 "replaceTerm(t, ext(fss!1`seq(0))(rhs(fse!1`seq(0))),
                                                           x_1`seq(0))") (("1" (assert) (("1" (expand subtermsOF -1 1) (("1" (prop) (("1" (expand finseq_appl) (("1" (replace -1 -5 rl) (("1" (hide -1 -2) (("1" (case "replaceTerm(replaceTerm(t,ext(fss!1`seq(0))(rhs(fse!1`seq(0))),x_1`seq(0)),
                                                                                subtermsOF(s, fsp)`seq(kk!1),
                                                                                fsp`seq(kk!1)) =
                                                          replaceTerm(t, subtermsOF(s, fsp)`seq(kk!1),fsp`seq(kk!1))") (("1" (assert) nil nil) ("2" (hide -3 -9 3) (("2" (expand subtermsOF 1) (("2" (expand finseq_appl) (("2" (expand <=) (("2" (skosimp) (("2" (replace -1) (("2" (replace -2) (("2" (rewrite replace_dominance) (("2" (expand SPP? -4) (("2" (flatten) (("2" (expand* SP? finseq_appl) (("2" (assert) (("2" (inst -5 0) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -4 -10 3) (("2" (expand SPP?) (("2" (flatten) (("2" (assert) (("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (case i=kk!1) (("1" (replaces -1) (("1" (lemma replace_preserv_pos) (("1" (inst -1 "x_1`seq(0)" t "ext(fss!1`seq(0))(rhs(fse!1`seq(0)))") (("1" (inst -7 0) (("1" (assert) (("1" (inst -5 kk!1) (("1" (lemma closed_positions) (("1" (inst -1 "fsp`seq(kk!1)" "x_1`seq(0)" "replaceTerm(t, ext(fss!1`seq(0))(rhs(fse!1`seq(0))),
                                                                  x_1`seq(0))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_preserv_parallel_pos) (("2" (inst -1 "x_1`seq(0)" "fsp`seq(i)" t "ext(fss!1`seq(0))(rhs(fse!1`seq(0)))") (("2" (inst -5 i) (("2" (inst -7 0) (("2" (assert) (("2" (expand PP? -3) (("2" (inst -3 kk!1 i) (("2" (expand finseq_appl) (("2" (expand <=) (("2" (skosimp) (("2" (replace -1) (("2" (replace -2) (("2" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "seq2set" "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (expand SPP?) (("2" (flatten) (("2" (assert) (("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (inst -9 "x_1`seq(0)") (("2" (split) (("1" (skosimp) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (case kk!1=i) (("1" (replaces -1) (("1" (lemma replace_preserv_pos) (("1" (inst -1 "x_1`seq(0)" t "ext(fss!1`seq(0))(rhs(fse!1`seq(0)))") (("1" (inst -7 0) (("1" (assert) (("1" (lemma closed_positions) (("1" (inst -1 "fsp`seq(i)" "x_1`seq(0)" "replaceTerm(t, ext(fss!1`seq(0))(rhs(fse!1`seq(0))),
                                                            x_1`seq(0))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite replace_preserv_parallel_pos) (("1" (inst -4 i) nil nil) ("2" (inst -6 0) nil nil) ("3" (expand PP? -3) (("3" (inst -3 kk!1 i) (("3" (expand finseq_appl) (("3" (expand <=) (("3" (skosimp) (("3" (replace -1) (("3" (replace -2) (("3" (rewrite comp_preservs_parallel_pos2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "seq2set" "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand SPP? (-2 1)) (("3" (flatten) (("3" (rewrite rest_of_PP_is_PP) (("3" (expand rest 1) (("3" (expand* ^ min) (("3" (expand empty_seq) (("3" (expand SP?) (("3" (prop) (("1" (skeep) nil nil) ("2" (skeep) nil nil) ("3" (skeep 3) (("3" (expand finseq_appl) (("3" (inst-cp -3 1+i) (("3" (inst -3 0) (("3" (expand* PP? finseq_appl) (("3" (inst -2 0 1+i) (("3" (assert) (("3" (rewrite replace_preserv_parallel_pos) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand parallel_reduction_fix?) (("4" (inst 1 "rest(fse!1)" "rest(fss!1)") (("1" (prop) (("1" (hide-all-but (-3 1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (-3 -4 -5 1)) (("3" (expand* rest ^ min empty_seq) (("3" (lift-if) (("3" (prop) (("1" (expand subtermsOF 1) (("1" (expand sigma_lhs 1) (("1" (expand finseq_appl) (("1" (expand empty_seq) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (decompose-equality 1) (("1" (skeep) nil nil) ("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand subtermsOF 1) (("2" (expand sigma_lhs 1) (("2" (expand finseq_appl) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) (("2" (decompose-equality 1) (("1" (skeep) nil nil) ("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand subtermsOF 3) (("3" (expand sigma_lhs 3) (("3" (expand finseq_appl) (("3" (expand empty_seq) (("3" (lift-if) (("3" (assert) (("3" (decompose-equality 3) (("1" (expand subtermsOF -3) (("1" (expand sigma_lhs -3) (("1" (expand finseq_appl) (("1" (decompose-equality -3) (("1" (inst -1 1+x!1) (("1" (replace -1 1 rl) (("1" (rewrite replace_persistence) (("1" (reveal -4) (("1" (expand* SPP? SP? finseq_appl) (("1" (flatten) (("1" (inst -2 0) nil nil)) nil)) nil)) nil) ("2" (reveal -4) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 1+x!1) nil nil)) nil)) nil)) nil) ("3" (reveal -4) (("3" (expand* SPP? PP? finseq_appl) (("3" (flatten) (("3" (inst -1 0 1+x!1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -3) (("2" (expand* SPP? SP? finseq_appl) (("2" (flatten) (("2" (inst -2 x!2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide -3) (("2" (grind) nil nil)) nil)) nil) ("3" (skeep) (("3" (hide -3) (("3" (typepred i) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (typepred i) (("4" (lift-if) (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (skeep) (("5" (reveal -3) (("5" (expand* SPP? SP? PP? finseq_appl) (("5" (flatten) (("5" (rewrite replace_preserv_parallel_pos) (("1" (inst -2 1+i) nil nil) ("2" (inst -2 0) nil nil) ("3" (inst -1 0 1+i) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (reveal -3) (("6" (expand* SPP? SP? finseq_appl) (("6" (flatten) (("6" (inst -2 0) (("6" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred fse!1) (("2" (expand subset?) (("2" (lemma predicate_fseq2set[rewrite_rule].rest_subset) (("2" (inst?) (("2" (lemma sets_lemmas[rewrite_rule].subset_transitive) (("2" (inst -1 "seq2set(rest(fse!1))" "seq2set(fse!1)" "E") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but (-7 1 2)) (("5" (skeep) (("5" (expand* "seq2set" "finseq_appl") (("5" (skeep) (("5" (typepred kk) (("5" (expand* rest ^ min empty_seq) (("5" (lift-if) (("5" (assert) (("5" (prop) (("5" (inst -3 "x") (("5" (split) (("1" (propax) nil nil) ("2" (hide-all-but (-1 1)) (("2" (inst 1 1+kk) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand subtermsOF 1) (("2" (propax) nil nil)) nil)) nil) ("3" (skeep) (("3" (hide 2) (("3" (expand* SPP? finseq_appl) (("3" (flatten) (("3" (expand SP? 1) (("3" (expand finseq_appl) (("3" (skeep) (("3" (expand parallel_reduction_fix?) (("3" (skosimp) (("3" (case "PP?(add_first(fsp`seq(i),fsp1))") (("1" (lemma replace_par_pos_preservs_pos) (("1" (inst -1 fsp1 "sigma_rhs(fss!1, fse!1)" "fsp`seq(i)" t) (("1" (expand SPP?) (("1" (expand sigma_rhs -1 1) (("1" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (assert) (("1" (lift-if) (("1" (expand empty_seq) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand SP? -3) (("2" (expand finseq_appl) (("2" (inst -3 i) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite add_first_parallel_pos_to_PP_is_PP) (("2" (expand finseq_appl) (("2" (hide 2) (("2" (skosimp) (("2" (expand parallel) (("2" (split) (("1" (inst -10 "fsp1`seq(i!1)") (("1" (split) (("1" (skosimp) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (expand PP? -4) (("1" (expand finseq_appl) (("1" (case kk!1=i) (("1" (replaces -1) (("1" (lemma replace_par_pos_preservs_PP) (("1" (inst -1 fsp1 "sigma_rhs(fss!1, fse!1)" t) (("1" (expand SPP?) (("1" (expand sigma_rhs -1 1) (("1" (expand finseq_appl) (("1" (inst -1 i!1) (("1" (replace -12 -1 rl) (("1" (expand <=) (("1" (skosimp*) (("1" (replaces -3) (("1" (case "p1!1`length=0") (("1" (rewrite empty_0 -1) (("1" (replaces -1) (("1" (replaces -2) (("1" (rewrite seq_o_empty) nil nil)) nil)) nil)) nil) ("2" (expand o -3) (("2" (decompose-equality -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst -4 kk!1 i) (("2" (expand parallel) (("2" (flatten) (("2" (expand <=) (("2" (skosimp*) (("2" (replaces -1) (("2" (replaces -1) (("2" (inst 2 "p1!1 o p1!2") (("2" (rewrite o_assoc) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "seq2set" "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_par_pos_preservs_PP) (("2" (inst -1 fsp1 "sigma_rhs(fss!1, fse!1)" t) (("2" (expand* SPP? finseq_appl) (("2" (expand sigma_rhs -1 1) (("2" (inst -1 i!1) (("2" (replace -10 -1 rl) (("2" (lemma closed_positions) (("2" (inst -1 "fsp`seq(i)" "fsp1`seq(i!1)" s) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (SP? const-decl "bool" positions nil) (<= const-decl "bool" positions nil) (seq2set const-decl "finite_set[T]" seq2set structures) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (SPP type-eq-decl nil positions nil) (SPP? const-decl "bool" positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (SP type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (rest const-decl "finseq" seq_extras structures) (replaceTerm def-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (subtermsOF_rest formula-decl nil orthogonality_basis nil) (NOT const-decl "[bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (^ const-decl "finseq" finite_sequences nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (empty_seq const-decl "finseq" finite_sequences nil) (rest_of_PP_is_PP formula-decl nil positions nil) (PP? const-decl "bool" positions nil) (PP type-eq-decl nil positions nil) (replace_subterm_of_term formula-decl nil replacement nil) (subset? const-decl "bool" predicate_fseq2set nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (TRUE const-decl "bool" booleans nil) (length_rest formula-decl nil seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (x_1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (rhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (replace_par_pos_equivalence1 formula-decl nil orthogonality_basis nil) (subtermOF def-decl "term" subterm nil) (replace_dominance formula-decl nil replacement nil) (comp_preservs_parallel_pos2 formula-decl nil positions nil) (closed_positions formula-decl nil positions nil) (replace_preserv_pos formula-decl nil replacement nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" orthogonality_basis nil) (fse!1 skolem-const-decl "{fse | subset?(fse, E)}" orthogonality_basis nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (lhs const-decl "term" rewrite_rules nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (replace_persistence formula-decl nil replacement nil) (FALSE const-decl "bool" booleans nil) (epsilon const-decl "T" epsilons nil) (fss!1 skolem-const-decl "finseq[Sub[variable, symbol, arity]]" orthogonality_basis nil) (t skolem-const-decl "term" orthogonality_basis nil) (sigma_lhs const-decl "finseq[term]" orthogonality_basis nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (rest_subset formula-decl nil predicate_fseq2set nil) (subset_transitive formula-decl nil sets_lemmas nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (sigma_rhs_rest formula-decl nil orthogonality_basis nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (add_first const-decl "finseq" seq_extras structures) (add_first_parallel_pos_to_SP_is_SP formula-decl nil positions nil) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (seq_o_empty formula-decl nil seq_extras structures) (empty_0 formula-decl nil seq_extras structures) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (O const-decl "finseq" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (o_assoc formula-decl nil finite_sequences nil) (parallel const-decl "bool" positions nil) (add_first_parallel_pos_to_PP_is_PP formula-decl nil positions nil) (dominates? const-decl "bool" predicate_fseq2set nil)) shostak)) (Parallel_Moves_Lemma 0 (Parallel_Moves_Lemma-1 nil 3575626525 ("" (skeep) (("" (expand parallel_reduction? -3) (("" (skosimp) (("" (lemma parallel_reduction_result) (("" (inst -1 E e fsp!1 sigma t) (("" (expand member) (("" (assert) (("" (case "fsp!1 = #(empty_seq)") (("1" (hide -2) (("1" (inst 1 t) (("1" (expand parallel_reduction_fix? -4) (("1" (skosimp) (("1" (replaces -1) (("1" (expand* "#") (("1" (expand* replace_par_pos finseq_appl) (("1" (expand* rest ^ min empty_seq) (("1" (lift-if) (("1" (assert) (("1" (expand* replace_par_pos finseq_appl) (("1" (expand replaceTerm) (("1" (expand sigma_rhs) (("1" (expand finseq_appl) (("1" (lemma non_ambiguous_implies_same_term) (("1" (inst -1 E empty_seq "ext(sigma)(lhs(e))" "ext(sigma)(rhs(e))" t) (("1" (expand Orthogonal?) (("1" (flatten) (("1" (assert) (("1" (lemma parallel_reduction_reflexive) (("1" (inst -1 E) (("1" (expand reflexive?) (("1" (inst -1 t) (("1" (assert) (("1" (prop) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand* positionsOF only_empty_seq union IUnion member catenate empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand* empty_seq reduction_fix?) (("3" (inst 1 e sigma) (("1" (prop) (("1" (expand subtermOF) (("1" (propax) nil nil)) nil) ("2" (expand replaceTerm) (("2" (propax) nil nil)) nil)) nil) ("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil) ("4" (expand* empty_seq reduction_fix?) (("4" (inst 1 "fse!1`seq(0)" "fss!1`seq(0)") (("1" (split) (("1" (expand* subtermsOF sigma_lhs empty_seq finseq_appl) (("1" (expand* subtermOF) (("1" (decompose-equality -6) (("1" (inst -1 0) nil nil)) nil)) nil)) nil) ("2" (expand replaceTerm) (("2" (propax) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand member) (("2" (typepred fse!1) (("2" (expand subset?) (("2" (expand* subset? member seq2set finseq_appl) (("2" (inst?) (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skosimp) (("2" (lemma parallel_reduction_variables_context) (("2" (inst -1 E sigma "rhs(e)" theta!1) (("2" (inst 2 "ext(theta!1)(rhs(e))") (("2" (split 2) (("1" (assert) (("1" (typepred e) (("1" (expand rewrite_rule?) (("1" (flatten) (("1" (skeep) (("1" (expand* subset? member) (("1" (inst -1 x) (("1" (lemma parallel_reduction_variables) (("1" (expand Orthogonal?) (("1" (inst -1 E e fsp!1 sigma theta!1) (("1" (flatten) (("1" (assert) (("1" (expand parallel_reduction? -1) (("1" (prop) (("1" (inst -2 x) (("1" (skosimp) (("1" (expand parallel_reduction? 3) (("1" (inst 3 fsp!2) nil nil)) nil)) nil) ("2" (expand Vars) (("2" (skosimp) (("2" (inst 1 p!1) (("1" (expand lhs 1) (("1" (propax) nil nil)) nil) ("2" (typepred p!1) (("2" (expand lhs 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred x) (("2" (expand Vars) (("2" (expand rhs -2) (("2" (skosimp) (("2" (inst 1 p!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand parallel_reduction? 1) (("2" (inst 1 "#(empty_seq)") (("1" (expand parallel_reduction_fix? 1) (("1" (inst 1 "#(e)" "#(theta!1)") (("1" (expand "#") (("1" (expand empty_seq) (("1" (split) (("1" (expand* subtermsOF sigma_lhs empty_seq finseq_appl) (("1" (expand subtermOF 1) (("1" (decompose-equality 1) nil nil)) nil)) nil) ("2" (expand* replace_par_pos finseq_appl) (("2" (expand replaceTerm) (("2" (expand rest 1 1) (("2" (expand* ^ min empty_seq) (("2" (expand* replace_par_pos finseq_appl) (("2" (expand sigma_rhs 1) (("2" (expand finseq_appl) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand subset?) (("2" (expand* subset? member seq2set finseq_appl) (("2" (skosimp*) (("2" (expand "#") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "#" SPP? SP? PP? finseq_appl) (("2" (skeep) (("2" (hide-all-but 1) (("2" (expand* positionsOF only_empty_seq union member IUnion catenate empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((parallel_reduction? const-decl "bool" orthogonality_basis nil) (parallel_reduction_result formula-decl nil orthogonality_basis nil) (member const-decl "bool" sets nil) (empty_seq const-decl "finseq" finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (rest const-decl "finseq" seq_extras structures) (replaceTerm def-decl "term" replacement nil) (rhs const-decl "term" rewrite_rules nil) (parallel_reduction_reflexive formula-decl nil orthogonality_basis nil) (reflexive? const-decl "bool" relations nil) (NOT const-decl "[bool -> bool]" booleans nil) (seq2set const-decl "finite_set[T]" seq2set structures) (subset? const-decl "bool" sets nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (sigma_lhs const-decl "finseq[term]" orthogonality_basis nil) (fse!1 skolem-const-decl "{fse | subset?(fse, E)}" orthogonality_basis nil) (subset? const-decl "bool" predicate_fseq2set nil) (reduction_fix? const-decl "bool" reduction nil) (subtermOF def-decl "term" subterm nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" orthogonality_basis nil) (e skolem-const-decl "rewrite_rule[variable, symbol, arity]" orthogonality_basis nil) (positionsOF def-decl "positions" positions nil) (union const-decl "set" sets nil) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (only_empty_seq const-decl "positions" positions nil) (Orthogonal? const-decl "bool" orthogonality_basis nil) (non_ambiguous_implies_same_term formula-decl nil orthogonality_basis nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (TRUE const-decl "bool" booleans nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (parallel_reduction_variables formula-decl nil orthogonality_basis nil) (Vars const-decl "set[(V)]" subterm nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](e`1)" orthogonality_basis nil) (x skolem-const-decl "Vars?[variable, symbol, arity](rhs(e))" orthogonality_basis nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (positions type-eq-decl nil positions nil) (positions? type-eq-decl nil positions nil) (Vars? type-eq-decl nil subterm nil) (PP? const-decl "bool" positions nil) (SP? const-decl "bool" positions nil) (t skolem-const-decl "term" orthogonality_basis nil) (parallel_reduction_variables_context formula-decl nil orthogonality_basis nil) (SPP type-eq-decl nil positions nil) (lhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (SPP? const-decl "bool" positions nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_basis nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_basis nil)) shostak)))
