(inn_dp_termination (IMP_dependency_pairs_TCC1 0 (IMP_dependency_pairs_TCC1-1 nil 3763208403 ("" (rewrite "var_countable") nil nil) ((var_countable formula-decl nil inn_dp_termination nil)) nil (IMP_dependency_pairs assuming "dependency_pairs[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].dependency_pairs" "var_countable: ASSUMPTION countability[term_adt[dependency_pairs.variable, dependency_pairs.symbol, dependency_pairs.arity].term].is_countably_infinite(variables_term[dependency_pairs.variable, dependency_pairs.symbol, dependency_pairs.arity].V)"))) (inn_dp_termination_alt?_TCC1 0 (inn_dp_termination_alt?_TCC1-1 nil 3763208403 ("" (skeep :preds? t) (("" (typepred "dps(i)") (("" (expand "dep_pair_alt?") (("" (flatten) nil nil)) nil)) nil)) nil) ((sequence type-eq-decl nil sequences nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (inn_dp_termination_alt? subtype "inn_dp_termination.dps(inn_dp_termination.i)`2" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dps(inn_dp_termination.i)`1))"))) (inn_dp_termination_alt?_TCC2 0 (inn_dp_termination_alt?_TCC2-1 nil 3763208403 ("" (skeep* :preds? t) (("" (assert) (("" (replaces -2) (("" (assert) (("" (typepred "dps(x1)") (("" (expand "dep_pair_alt?") (("" (flatten) (("" (expand "dep_pair?") (("" (assert) (("" (inst?) (("" (assert) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (dep_pair? const-decl "bool" dependency_pairs nil) (positions? type-eq-decl nil positions nil) (rhs const-decl "term" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (sequence type-eq-decl nil sequences nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (inn_dp_termination_alt? subtype "inn_dp_termination.seq" "sequence[dep_pair[variable, symbol, arity](E)]"))) (inn_dp_termination_and_inn_alt_eq 0 (inn_dp_termination_and_inn_alt_eq-1 nil 3761501293 ("" (skeep*) (("" (prop) (("1" (expand "inn_dp_termination_alt?") (("1" (expand "inn_dp_termination?") (("1" (skeep*) (("1" (inst -1 "(LAMBDA(i:nat): rule_and_pos_from_dp(E)(seq(i)))" "sigmas") (("1" (expand "inn_infinite_dep_chain?") (("1" (skeep) (("1" (expand "rule_and_pos_from_dp") (("1" (inst?) (("1" (assert) (("1" (expand "inn_chained_dp?") (("1" (typepred "choose({(e: rewrite_rule), (p: position) |
                                                                                               member(e, E) AND
                                                                                                lhs(e) = seq(1 + i)`1 AND
                                                                                                 positionsOF(rhs(e))(p) AND
                                                                                                  subtermOF(rhs(e), p)
                                                                                                  =
                                                                                                  seq(1 + i)`2})") (("1" (typepred "choose({(e: rewrite_rule), (p: position)
                                                                                                                                |
                                                                                                                                member(e, E)
                                                                                                                                AND
                                                                                                                                lhs(e) = seq(i)`1
                                                                                                                                AND
                                                                                                                                positionsOF(rhs(e))(p)
                                                                                                                                AND
                                                                                                                                subtermOF(rhs(e), p) = seq(i)`2})") (("1" (assert) (("1" (name-replace "choose1" "choose({(e: rewrite_rule), (p: position)
                                                                                                                                                      |
                                                                                                                                                      member(e, E)
                                                                                                                                                      AND
                                                                                                                                                      lhs(e) = seq(i)`1
                                                                                                                                                      AND
                                                                                                                                                      positionsOF(rhs(e))(p)
                                                                                                                                                      AND
                                                                                                                                                      subtermOF(rhs(e), p) = seq(i)`2})") (("1" (typepred "choose({(e: rewrite_rule), (p: position) |
                                                                                                                                              member(e, E) AND
                                                                                                                                               lhs(e) = seq(1 + i)`1 AND
                                                                                                                                                positionsOF(rhs(e))(p) AND
                                                                                                                                                 subtermOF(rhs(e), p) = seq(1 + i)`2})") (("1" (name-replace "choose2" "choose({(e: rewrite_rule), (p: position) |
                                                                                                                                                              member(e, E) AND
                                                                                                                                                               lhs(e) = seq(1 + i)`1 AND
                                                                                                                                                                positionsOF(rhs(e))(p) AND
                                                                                                                                                                 subtermOF(rhs(e), p) = seq(1 + i)`2})") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (typepred "seq(i)") (("2" (expand "dep_pair?") (("2" (flatten) (("2" (skeep*) (("2" (inst -6 "(e,p)") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (flatten) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (typepred "seq(i + 1)") (("2" (expand "dep_pair?") (("2" (flatten) (("2" (skeep*) (("2" (inst -6 "(e,p)") (("2" (assert) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (typepred "seq(i)") (("2" (hide -2) (("2" (expand "dep_pair?") (("2" (expand "dep_pair_alt?") (("2" (flatten) (("2" (assert) (("2" (skeep*) (("2" (expand "rule_and_pos_from_dp") (("2" (typepred "choose({(e: rewrite_rule), (p: position) |
                                                                                                 member(e, E) AND
                                                                                                  lhs(e) = seq(i)`1 AND
                                                                                                   positionsOF(rhs(e))(p) AND
                                                                                                    subtermOF(rhs(e), p) = seq(i)`2})") (("1" (assert) (("1" (name-replace "ee" "choose({(e: rewrite_rule), (p: position) |
                                         member(e, E) AND
                                          lhs(e) = seq(i)`1 AND
                                           positionsOF(rhs(e))(p) AND
                                            subtermOF(rhs(e), p) = seq(i)`2})") (("1" (hide-all-but (-1 1)) (("1" (expand "member") (("1" (expand "lhs") (("1" (typepred "ee`1") (("1" (expand "rewrite_rule?") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "(e,p)") (("2" (typepred "p") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "inn_dp_termination?") (("2" (expand "inn_dp_termination_alt?") (("2" (skeep) (("2" (inst -1 "(LAMBDA(i:nat): (lhs(dps(i)`1), subtermOF(rhs(dps(i)`1),dps(i)`2)))" "sigmas") (("1" (skeep) (("1" (hide -) (("1" (typepred "dps(i)") (("1" (expand "dep_pair_alt?") (("1" (expand "dep_pair?") (("1" (flatten) (("1" (assert) (("1" (expand "defined?") (("1" (assert) (("1" (inst 1 "dps(i)`1") (("1" (assert) (("1" (inst 1 "dps(i)`2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "dps(i)") (("2" (expand "dep_pair_alt?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inn_dp_termination? const-decl "bool" inn_dp_termination nil) (seq skolem-const-decl "sequence[dep_pair[variable, symbol, arity](E)]" inn_dp_termination nil) (sequence type-eq-decl nil sequences nil) (rule_and_pos_from_dp const-decl "[rewrite_rule, position]" dependency_pairs nil) (dep_pair type-eq-decl nil dependency_pairs nil) (dep_pair? const-decl "bool" dependency_pairs nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (inn_chained_dp? const-decl "bool" inn_dp_termination nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (empty? const-decl "bool" sets nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (rhs const-decl "term" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (lhs const-decl "term" rewrite_rules nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (inn_infinite_dep_chain? const-decl "bool" inn_dp_termination nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (inn_dp_termination_alt? const-decl "bool" inn_dp_termination nil) (dps skolem-const-decl "sequence[dep_pair_alt[variable, symbol, arity](E)]" inn_dp_termination nil) (defined? const-decl "bool" rewrite_rules nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil)) (inn_noetherian_implies_inn_dp_termination 0 (inn_noetherian_implies_inn_dp_termination-1 nil 3761501384 ("" (skeep) (("" (lemma "inn_dp_termination_and_inn_alt_eq") (("" (inst?) (("" (assert) (("" (hide 2) (("" (rewrite "R_is_Noet_iff_TC_is") (("" (assert) (("" (expand "noetherian?") (("" (expand "inn_dp_termination_alt?") (("" (rewrite "no_infinite_descending_sequence") (("" (expand "empty?") (("" (skeep :preds? t) (("" (expand "member") (("" (expand "descending?") (("" (expand "converse") (("" (assert) (("" (inst -2 "(LAMBDA(i:nat): term_pos_dps_alt(E)(dps,sigmas,i)`1)") (("" (induct "n") (("1" (assert) (("1" (expand "term_pos_dps_alt") (("1" (expand "term_pos_dps_alt") (("1" (typepred "dps(0)" "dps(1)") (("1" (expand "dep_pair_alt?") (("1" (flatten) (("1" (expand "inn_infinite_dep_chain?") (("1" (inst -11 0 1) (("1" (assert) (("1" (expand "inn_chained_dp?") (("1" (flatten) (("1" (lemma "non_root_inn_subset_inn_reduction") (("1" (inst?) (("1" (assert) (("1" (lemma "Closure_monotony") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (hide -1 -2 -3 -5 -6) (("1" (expand "subset?") (("1" (expand "member") (("1" (inst?) (("1" (assert) (("1" (case "innermost_reduction?(E)(ext(sigmas(0))(lhs(dps(0)`1)), ext(sigmas(0))(rhs(dps(0)`1)))") (("1" (case "innermost_reduction?(E)(ext(sigmas(1))(lhs(dps(1)`1)), ext(sigmas(1))(rhs(dps(1)`1)))") (("1" (lemma "inn_reduction_is_comp_op") (("1" (inst?) (("1" (lemma "closure_comp_cont") (("1" (inst?) (("1" (rewrite "comp_op_iff_comp_cont") (("1" (assert) (("1" (flatten) (("1" (hide -1 -3) (("1" (expand "comp_cont?" -1) (("1" (inst -1 "dps(0)`2" "ext(sigmas(0))(rhs(dps(0)`1))") (("1" (rewrite "ext_preserv_pos") (("1" (inst -1 "ext(sigmas(0))(subtermOF(rhs(dps(0)`1), dps(0)`2))" "ext(sigmas(1))(lhs(dps(1)`1))") (("1" (assert) (("1" (expand "TC" 1) (("1" (expand "RTC" -1) (("1" (expand "IUnion") (("1" (skeep*) (("1" (inst 1 "i+1") (("1" (lemma "iterate_add_applied") (("1" (inst -1 "innermost_reduction?(E)" "i" "1" "replaceTerm(ext(sigmas(0))(rhs(dps(0)`1)),ext(sigmas(0))(subtermOF(rhs(dps(0)`1), dps(0)`2)),dps(0)`2)" "replaceTerm(ext(sigmas(0))(rhs(dps(0)`1)),
                                                                                                                                                                  ext(sigmas(1))(lhs(dps(1)`1)),
                                                                                                                                                                  dps(0)`2)" "replaceTerm(ext(sigmas(0))(rhs(dps(0)`1)),
                                                                                                                                                                  ext(sigmas(1))(rhs(dps(1)`1)),
                                                                                                                                                                  dps(0)`2)") (("1" (assert) (("1" (rewrite "iterate_1") (("1" (prop) (("1" (lemma "replace_subterm_of_term") (("1" (inst -1 "dps(0)`2" "ext(sigmas(0))(rhs(dps(0)`1))") (("1" (rewrite "ext_preserv_pos") (("1" (lemma "subterm_of_ext") (("1" (inst -1 "dps(0)`2" "empty_seq" "sigmas(0)" "rhs(dps(0)`1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -5 2) (("2" (expand "comp_cont?") (("2" (inst -1 "dps(0)`2" "ext(sigmas(0))(rhs(dps(0)`1))") (("2" (rewrite "ext_preserv_pos") (("2" (inst -1 "ext(sigmas(1))(lhs(dps(1)`1))" "ext(sigmas(1))(rhs(dps(1)`1))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-14 1)) (("2" (expand "innermost_reduction?") (("2" (inst 1 "empty_seq") (("1" (expand "innermost_reduction_fix?") (("1" (rewrite "subterm_empty_seq") (("1" (assert) (("1" (hide -) (("1" (expand "reduction_fix?") (("1" (inst 1 "dps(1)`1" "sigmas(1)") (("1" (rewrite "subterm_empty_seq") (("1" (assert) (("1" (expand "replaceTerm") (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-12 1)) (("2" (expand "innermost_reduction?") (("2" (inst 1 "empty_seq") (("1" (expand "innermost_reduction_fix?") (("1" (rewrite "subterm_empty_seq") (("1" (assert) (("1" (hide -) (("1" (expand "reduction_fix?") (("1" (inst 1 "dps(0)`1" "sigmas(0)") (("1" (rewrite "subterm_empty_seq") (("1" (assert) (("1" (expand "replaceTerm") (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (expand "positionsOF") (("2" (expand "only_empty_seq") (("2" (expand "union") (("2" (expand "member") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "term_pos_dps_alt" 1) (("2" (expand "term_pos_dps_alt" 1 (3 4)) (("2" (expand "term_pos_dps_alt" -1 2) (("2" (expand "inn_infinite_dep_chain?") (("2" (inst -2 "1+j" "2+j") (("2" (assert) (("2" (expand "inn_chained_dp?") (("2" (flatten) (("2" (lemma "non_root_inn_subset_inn_reduction") (("2" (inst?) (("2" (assert) (("2" (lemma "Closure_monotony") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (hide -1 -2 -3 -5 -6) (("2" (expand "subset?") (("2" (expand "member") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (assert) (("2" (typepred "dps(1+j)" "dps(2+j)") (("2" (expand "dep_pair_alt?") (("2" (flatten) (("2" (lemma "ext_preserv_pos") (("2" (inst-cp -1 "dps(1 + j)`2" "rhs(dps(1 + j)`1)" "sigmas(1 + j)") (("2" (assert) (("2" (inst -1 "dps(2 + j)`2" "rhs(dps(2 + j)`1)" "sigmas(2 + j)") (("2" (assert) (("2" (rewrite "replace_associativity") (("2" (lemma "inn_reduction_is_comp_op") (("2" (inst?) (("2" (case "innermost_reduction?(E)(ext(sigmas(1 + j))(lhs(dps(1 + j)`1)), ext(sigmas(1 + j))(rhs(dps(1 + j)`1)))") (("1" (case "innermost_reduction?(E)(ext(sigmas(2 + j))(lhs(dps(2 + j)`1)), ext(sigmas(2 + j))(rhs(dps(2 + j)`1)))") (("1" (hide -6 -7 -8 -9 -10 -11 -12 -13 -14 -15 -18 -19 -20) (("1" (rewrite "comp_op_iff_comp_cont") (("1" (lemma "closure_comp_cont") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (hide -3) (("1" (expand "comp_cont?" -5) (("1" (inst-cp -5 "dps(1 + j)`2" "ext(sigmas(1 + j))
                                                                                                                                   (rhs(dps(1 + j)`1))") (("1" (assert) (("1" (inst -6 "ext(sigmas(2 + j))(lhs(dps(2 + j)`1))" "ext(sigmas(2 + j))(rhs(dps(2 + j)`1))") (("1" (assert) (("1" (hide -3) (("1" (expand "comp_cont?" -2) (("1" (inst-cp -2 "dps(1 + j)`2" "ext(sigmas(1 + j))(rhs(dps(1 + j)`1))") (("1" (assert) (("1" (inst -3 "ext(sigmas(1 + j))
                                                                                                     (subtermOF(rhs(dps(1 + j)`1), dps(1 + j)`2))" "ext(sigmas(2 + j))(lhs(dps(2 + j)`1))") (("1" (assert) (("1" (lemma "replace_subterm_of_term") (("1" (inst -1 "dps(1 + j)`2" "ext(sigmas(1 + j))(rhs(dps(1 + j)`1))") (("1" (assert) (("1" (lemma "subterm_of_ext") (("1" (inst -1 "dps(1 + j)`2" "empty_seq" "sigmas(1 + j)" "rhs(dps(1 + j)`1)") (("1" (assert) (("1" (replace -1 -5 rl) (("1" (replace -2 -5) (("1" (hide -1 -2) (("1" (typepred "term_pos_dps_alt(E)(dps, sigmas, j)") (("1" (inst -3 "term_pos_dps_alt(E)(dps, sigmas, j)`2" "term_pos_dps_alt(E)(dps, sigmas, j)`1") (("1" (assert) (("1" (inst -3 "ext(sigmas(1 + j))(rhs(dps(1 + j)`1))" "          replaceTerm(ext(sigmas(1 + j))(rhs(dps(1 + j)`1)), ext(sigmas(2 + j))
                                                                                                                   (lhs(dps(2 + j)`1)),
                                                                                                                dps(1 + j)`2)") (("1" (assert) (("1" (hide -4) (("1" (hide -9) (("1" (expand "RTC") (("1" (expand "TC" 1) (("1" (expand "IUnion") (("1" (skeep) (("1" (inst 1 "i + 1") (("1" (lemma "iterate_add_applied") (("1" (inst -1 "innermost_reduction?(E)" "i" "1" "replaceTerm(term_pos_dps_alt(E)(dps, sigmas, j)`1,
                                                                                                                    ext(sigmas(1 + j))
                                                                                                                       (rhs(dps(1 + j)`1)),
                                                                                                                    term_pos_dps_alt(E)(dps, sigmas, j)`2)" "replaceTerm(term_pos_dps_alt(E)(dps, sigmas, j)`1,
                                                                                                                    replaceTerm(ext
                                                                                                                                (sigmas(1 + j))
                                                                                                                                (rhs(dps(1 + j)`1)),
                                                                                                                                ext
                                                                                                                                (sigmas(2 + j))
                                                                                                                                (lhs(dps(2 + j)`1)),
                                                                                                                                dps(1 + j)`2),
                                                                                                                    term_pos_dps_alt(E)(dps, sigmas, j)`2)" "replaceTerm(term_pos_dps_alt(E)(dps, sigmas, j)`1,
                                                                                                                    replaceTerm(ext
                                                                                                                                (sigmas(1 + j))
                                                                                                                                (rhs(dps(1 + j)`1)),
                                                                                                                                ext
                                                                                                                                (sigmas(2 + j))
                                                                                                                                (rhs(dps(2 + j)`1)),
                                                                                                                                dps(1 + j)`2),
                                                                                                                    term_pos_dps_alt(E)(dps, sigmas, j)`2)") (("1" (assert) (("1" (hide-all-but (-1 -5 -6 1)) (("1" (inst - "term_pos_dps_alt(E)(dps, sigmas, j)`2" "term_pos_dps_alt(E)(dps, sigmas, j)`1") (("1" (assert) (("1" (inst -2 "replaceTerm(ext(sigmas(1 + j))
                                                                                                                          (rhs(dps(1 + j)`1)),
                                                                                                                       ext(sigmas(2 + j))
                                                                                                                          (lhs(dps(2 + j)`1)),
                                                                                                                       dps(1 + j)`2)" "replaceTerm(ext(sigmas(1 + j))
                                                                                                                          (rhs(dps(1 + j)`1)),
                                                                                                                       ext(sigmas(2 + j))
                                                                                                                          (rhs(dps(2 + j)`1)),
                                                                                                                       dps(1 + j)`2)") (("1" (assert) (("1" (rewrite "iterate_1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-18 1)) (("2" (expand "innermost_reduction?") (("2" (inst 1 "empty_seq") (("1" (expand "innermost_reduction_fix?") (("1" (rewrite "subterm_empty_seq") (("1" (assert) (("1" (hide -) (("1" (expand "reduction_fix?") (("1" (inst 1 "dps(2 + j)`1" "sigmas(2 + j)") (("1" (rewrite "subterm_empty_seq") (("1" (assert) (("1" (expand "replaceTerm") (("1" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-17 1)) (("2" (expand "innermost_reduction?") (("2" (inst 1 "empty_seq") (("1" (expand "innermost_reduction_fix?") (("1" (rewrite "subterm_empty_seq") (("1" (assert) (("1" (hide -) (("1" (expand "reduction_fix?") (("1" (inst 1 "dps(1 + j)`1" "sigmas(1 + j)") (("1" (rewrite "subterm_empty_seq") (("1" (assert) (("1" (expand "replaceTerm") (("1" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inn_dp_termination_and_inn_alt_eq formula-decl nil inn_dp_termination nil) (R_is_Noet_iff_TC_is formula-decl nil noetherian nil) (PRED type-eq-decl nil defined_types nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (noetherian? const-decl "bool" noetherian nil) (no_infinite_descending_sequence formula-decl nil well_foundedness orders) (pred type-eq-decl nil defined_types nil) (converse const-decl "pred[[T2, T1]]" relation_defs nil) (transitive? const-decl "bool" relations nil) (transitive type-eq-decl nil relations_closure nil) (TC const-decl "transitive" relations_closure nil) (transitive_converse application-judgement "(transitive?[T])" relation_converse_props nil) (descending? const-decl "bool" monotone_sequences orders) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat_induction formula-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (inn_chained_dp? const-decl "bool" inn_dp_termination nil) (non_root_inn_subset_inn_reduction formula-decl nil innermost_reduction nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (subset? const-decl "bool" sets nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (ext def-decl "term" substitution nil) (sigmas skolem-const-decl "sequence[Sub[variable, symbol, arity]]" inn_dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (dps skolem-const-decl "sequence[dep_pair_alt[variable, symbol, arity](E)]" inn_dp_termination nil) (subterm_empty_seq formula-decl nil subterm nil) (reduction_fix? const-decl "bool" reduction nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (empty_seq_is_position formula-decl nil positions nil) (inn_reduction_is_comp_op formula-decl nil innermost_reduction nil) (closure_comp_cont formula-decl nil compatibility nil) (comp_op_iff_comp_cont formula-decl nil compatibility nil) (comp_cont? const-decl "bool" compatibility nil) (ext_preserv_pos formula-decl nil substitution nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (TRUE const-decl "bool" booleans nil) (iterate_add_applied formula-decl nil relation_iterate orders) (subterm_of_ext formula-decl nil substitution nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (replace_subterm_of_term formula-decl nil replacement nil) (iterate_1 formula-decl nil relation_iterate orders) (replaceTerm def-decl "term" replacement nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IUnion const-decl "set[T]" indexed_sets nil) (only_empty_seq const-decl "positions" positions nil) (catenate const-decl "positions" positions nil) (add_first const-decl "finseq" seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (union const-decl "set" sets nil) (Closure_monotony formula-decl nil relations_closure nil) (inn_infinite_dep_chain? const-decl "bool" inn_dp_termination nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (j skolem-const-decl "nat" inn_dp_termination nil) (empty_0 formula-decl nil seq_extras structures) (int_minus_int_is_int application-judgement "int" integers nil) (replace_associativity formula-decl nil replacement nil) (sequence type-eq-decl nil sequences nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (term_pos_dps_alt def-decl "{(t, p) | positionsOF(t)(p)}" dependency_pairs nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (inn_dp_termination_alt? const-decl "bool" inn_dp_termination nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil)) nil)) (mint_is_app 0 (mint_is_app-1 nil 3761501440 ("" (skeep) (("" (expand "minimal_innermost_non_terminating?") (("" (flatten) (("" (hide -1) (("" (expand "innermost_reduction?") (("" (expand "innermost_reduction_fix?") (("" (expand "reduction_fix?") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (/= const-decl "boolean" notequal nil) (Dom const-decl "set[(V)]" substitution nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (terminating? const-decl "bool" noetherian nil) (is_normal_form? const-decl "bool" ars_terminology nil) (reducible? const-decl "bool" ars_terminology nil) (term type-decl nil term_adt nil) (non_root_reduction? const-decl "bool" reduction nil) (rhs const-decl "term" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (positions? type-eq-decl nil positions nil) (sequence type-eq-decl nil sequences nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (Vars const-decl "set[(V)]" subterm nil) (subset? const-decl "bool" sets nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (empty_seq const-decl "finseq" finite_sequences nil) (only_empty_seq const-decl "positions" positions nil) (subtermOF def-decl "term" subterm nil) (replaceTerm def-decl "term" replacement nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (e!1 skolem-const-decl "{e | member[rewrite_rule[variable, symbol, arity]](e, E)}" inn_dp_termination nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (union const-decl "set" sets nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (finseq type-eq-decl nil finite_sequences nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (seq!1 skolem-const-decl "sequence[term[variable, symbol, arity]]" inn_dp_termination nil) (sigma!1 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (= const-decl "[T, T -> boolean]" equalities nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](seq!1(0))" inn_dp_termination nil) (ext def-decl "term" substitution nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (reduction_fix? const-decl "bool" reduction nil) (innermost_reduction? const-decl "bool" innermost_reduction nil)) nil)) (args_innermost_minimal 0 (args_innermost_minimal-1 nil 3761501529 ("" (skeep :preds? t) (("" (expand "minimal_innermost_non_terminating?") (("" (prop) (("1" (expand "finseq_appl") (("1" (skeep) (("1" (inst -1 "#(i+1)") (("1" (expand "subtermOF") (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (expand "#") (("1" (expand "rest") (("1" (expand "^") (("1" (rewrite "subterm_empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (prop) (("1" (hide 2 3) (("1" (grind) (("1" (inst 1 "1+i") (("1" (inst 1 "empty_seq") (("1" (prop) (("1" (expand "positionsOF") (("1" (expand "only_empty_seq") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "empty_seq") (("2" (propax) nil nil)) nil) ("3" (decompose-equality 1) (("3" (skeep :preds? t) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (skolem 1 "ps") (("2" (typepred "ps") (("2" (case "length(ps)=1") (("1" (inst -3 "first(ps) - 1") (("1" (expand "subtermOF") (("1" (expand "empty_seq") (("1" (decompose-equality 1) (("1" (expand "finseq_appl") (("1" (expand "rest") (("1" (expand "^") (("1" (rewrite "subterm_empty_seq") nil nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "first(ps)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil) ("2" (inst -2 "#(first(ps))`seq(0) - 1") (("1" (expand "#") (("1" (lemma "innermost_terminating_all_subterms") (("1" (inst -1 "E" "subtermOF(t, #(ps`seq(0)))") (("1" (assert) (("1" (lemma "pos_subterm") (("1" (inst -1 "#(ps`seq(0))" "rest(ps)" "t") (("1" (prop) (("1" (inst -2 "rest(ps)") (("1" (assert) (("1" (replace -3 -2 rl) (("1" (hide -3) (("1" (case "#(ps`seq(0)) o rest(ps) = ps") (("1" (assert) nil nil) ("2" (hide-all-but (1 2 3)) (("2" (grind) (("1" (decompose-equality 3) (("1" (decompose-equality) nil nil)) nil) ("2" (decompose-equality 2) (("1" (decompose-equality) (("1" (typepred "x!1") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "n") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 1) (("2" (hide 4) (("2" (expand "subtermOF") (("2" (expand "finseq_appl") (("2" (expand "first") (("2" (expand "finseq_appl") (("2" (expand "#") (("2" (expand "rest") (("2" (expand "^") (("2" (rewrite "subterm_empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1 2 3)) (("3" (case "#(ps`seq(0)) o rest(ps) = ps") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (grind) (("1" (decompose-equality 3) (("1" (decompose-equality) nil nil)) nil) ("2" (decompose-equality 2) (("1" (decompose-equality) (("1" (typepred "x!1") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "n") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 1 3 6 7) (("4" (expand "subtermOF") (("4" (expand "finseq_appl") (("4" (expand "first") (("4" (expand "rest") (("4" (expand "#") (("4" (expand "^") (("4" (expand "finseq_appl") (("4" (rewrite "subterm_empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "#") (("2" (expand "positionsOF") (("2" (expand "only_empty_seq") (("2" (expand "union") (("2" (expand "member") (("2" (assert) (("2" (prop) (("2" (expand "IUnion") (("2" (skeep) (("2" (expand "catenate") (("2" (expand "finseq_appl") (("2" (skeep) (("2" (inst 2 "i_1") (("2" (inst 2 "empty_seq") (("2" (prop) (("1" (expand "member") (("1" (hide -1) (("1" (expand "positionsOF") (("1" (expand "only_empty_seq") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (expand "union") (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 3)) (("3" (expand "empty_seq") (("3" (decompose-equality 2) (("3" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "first(ps)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("3" (expand "empty_seq") (("3" (decompose-equality 3) (("3" (decompose-equality) nil nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (innermost_terminating_all_subterms formula-decl nil innermost_reduction nil) (O const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (pos_subterm formula-decl nil subterm nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (ps skolem-const-decl "{p: positions?(t) | NOT p = empty_seq}" inn_dp_termination nil) (not_empty_seq type-eq-decl nil seq_extras structures) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (is_normal_form? const-decl "bool" ars_terminology nil) (reducible? const-decl "bool" ars_terminology nil) (non_root_reduction? const-decl "bool" reduction nil) (reduction_fix? const-decl "bool" reduction nil) (rhs const-decl "term" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (TRUE const-decl "bool" booleans nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (FALSE const-decl "bool" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (i skolem-const-decl "below[length(args(t))]" inn_dp_termination nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (t skolem-const-decl "{t: term |
   app?(t) AND
    length(args(t)) > 0 AND NOT terminating?(innermost_reduction?(E))(t)}" inn_dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (terminating? const-decl "bool" noetherian nil) (PRED type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (positions? type-eq-decl nil positions nil) (int_minus_int_is_int application-judgement "int" integers nil) (first const-decl "T" seq_extras structures) (^ const-decl "finseq" finite_sequences nil) (subterm_empty_seq formula-decl nil subterm nil) (rest const-decl "finseq" seq_extras structures) (subtermOF def-decl "term" subterm nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (<= const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (only_empty_seq const-decl "positions" positions nil) (member const-decl "bool" sets nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (union const-decl "set" sets nil)) nil)) (inn_non_terminating_has_mint 0 (inn_non_terminating_has_mint-1 nil 3761501579 ("" (skeep) (("" (induct "t") (("1" (typepred "t!1") (("1" (propax) nil nil)) nil) ("2" (skeep :preds? t) (("2" (hide 2) (("2" (expand "terminating?") (("2" (skeep) (("2" (inst -2 0) (("2" (assert) (("2" (use "reducible_is_app") (("2" (assert) (("2" (expand "reducible?") (("2" (inst 1 "seq(1)") (("2" (use "innermost_subset_reduction") (("2" (expand "subset?") (("2" (expand "member") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (case "arity(app1_var) =0") (("1" (hide -3) (("1" (inst 2 "empty_seq") (("1" (rewrite "subterm_empty_seq") (("1" (expand "minimal_innermost_non_terminating?") (("1" (prop) (("1" (skeep :preds? t) (("1" (expand "positionsOF") (("1" (assert) (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "empty_seq_is_position") nil nil)) nil)) nil) ("2" (expand "terminating?" 2) (("2" (skeep*) (("2" (case "minimal_innermost_non_terminating?(E)(app(app1_var, app2_var))") (("1" (inst 2 "empty_seq") (("1" (rewrite "subterm_empty_seq") nil nil) ("2" (use "empty_seq_is_position") nil nil)) nil) ("2" (lemma "args_innermost_minimal") (("2" (inst -1 "E" "app(app1_var, app2_var)") (("1" (assert) (("1" (skeep) (("1" (inst -2 "i") (("1" (expand "finseq_appl") (("1" (prop) (("1" (skeep) (("1" (inst 4 "add_first(i+1,p)") (("1" (expand "subtermOF" 4) (("1" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (expand "first") (("2" (expand "finseq_appl") (("2" (expand "add_first") (("2" (case "insert?(1 + i, p, 0)`seq(0) - 1 = i AND rest(insert?(1 + i, p, 0)) = p") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("1" (expand "insert?") (("1" (propax) nil nil)) nil) ("2" (expand "insert?") (("2" (expand "rest") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (expand "^") (("2" (grind) (("1" (decompose-equality 2) (("1" (decompose-equality) nil nil)) nil) ("2" (decompose-equality 2) (("2" (decompose-equality) nil nil)) nil) ("3" (decompose-equality 4) (("1" (decompose-equality) (("1" (skeep :preds? t) (("1" (grind) nil nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "p") (("2" (hide -2 -5 2 3) (("2" (expand "positionsOF" 1) (("2" (expand "union") (("2" (expand "member") (("2" (expand "only_empty_seq") (("2" (prop) (("2" (expand "IUnion") (("2" (inst 2 "i+1") (("2" (expand "catenate") (("2" (inst 2 "p") (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -3 3) (("2" (expand "minimal_innermost_non_terminating?") (("2" (prop) (("1" (expand "terminating?") (("1" (inst 1 "seq") (("1" (prop) nil nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (lemma "innermost_terminating_all_subterms") (("2" (inst -1 "E" "app(app1_var, app2_var)") (("2" (assert) (("2" (inst -1 "p") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (terminating? const-decl "bool" noetherian nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (subtermOF def-decl "term" subterm nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (term_induction formula-decl nil term_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (innermost_subset_reduction formula-decl nil innermost_reduction nil) (reducible? const-decl "bool" ars_terminology nil) (sequence type-eq-decl nil sequences nil) (reducible_is_app formula-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (app1_var skolem-const-decl "symbol" inn_dp_termination nil) (app2_var skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var)}" inn_dp_termination nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (only_empty_seq const-decl "positions" positions nil) (subterm_empty_seq formula-decl nil subterm nil) (empty_seq_is_position formula-decl nil positions nil) (TRUE const-decl "bool" booleans nil) (args_innermost_minimal formula-decl nil inn_dp_termination nil) (innermost_terminating_all_subterms formula-decl nil innermost_reduction nil) (< const-decl "bool" reals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (add_first const-decl "finseq" seq_extras structures) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "below[length(app2_var)]" inn_dp_termination nil) (p skolem-const-decl "positions?[variable, symbol, arity](app2_var`seq(i))" inn_dp_termination nil) (insert? const-decl "finseq" seq_extras structures) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil nat_types nil) (rest const-decl "finseq" seq_extras structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (even? const-decl "bool" integers nil) (FALSE const-decl "bool" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (first const-decl "T" seq_extras structures) (union const-decl "set" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (positions_of_inf_nr_reduction 0 (positions_of_inf_nr_reduction-1 nil 3761501611 ("" (skeep* :preds? t) (("" (inst 1 "LAMBDA(i:nat): choose({p: positions?(seqt(i)) | NOT p = empty_seq AND innermost_reduction_fix?(E)(seqt(i), seqt(i + 1), p)})") (("1" (skeep) (("1" (typepred "choose({p: positions?(seqt(j)) | NOT p = empty_seq AND
                                    innermost_reduction_fix?(E)
                                                            (seqt(j),
                                                             seqt(j + 1),
                                                             p)})") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -2 "j") (("2" (expand "non_root_innermost_reduction?") (("2" (skeep) (("2" (inst?) (("2" (expand "innermost_reduction_fix?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "non_root_innermost_reduction?") (("2" (inst -2 "i") (("2" (skeep) (("2" (inst?) (("2" (expand "innermost_reduction_fix?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (seqt skolem-const-decl "sequence[term[variable, symbol, arity]]" inn_dp_termination nil) (sequence type-eq-decl nil sequences nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (choose const-decl "(p)" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (member const-decl "bool" sets nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (empty? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil)) (exists_inf_red_arg_in_inf_nr_im_red_TCC1 0 (exists_inf_red_arg_in_inf_nr_im_red_TCC1-1 nil 3761499258 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (term type-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (sequence type-eq-decl nil sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (finseq type-eq-decl nil finite_sequences nil) (positions? type-eq-decl nil positions nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (member const-decl "bool" sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (is_normal_form? const-decl "bool" ars_terminology nil) (reducible? const-decl "bool" ars_terminology nil) (non_root_reduction? const-decl "bool" reduction nil) (reduction_fix? const-decl "bool" reduction nil) (rhs const-decl "term" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (IUnion const-decl "set[T]" indexed_sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (empty_seq const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (exists_inf_red_arg_in_inf_nr_im_red subtype "inn_dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (i: naturalnumbers.nat): (booleans.NOT)(seqp(i) = finite_sequences[posnat].empty_seq)}"))) (exists_inf_red_arg_in_inf_nr_im_red 0 (exists_inf_red_arg_in_inf_nr_im_red-2 "" 3790334374 ("" (skeep* :preds? t) (("" (use "positions_of_inf_nr_reduction") (("" (prop) (("1" (skeep) (("1" (lemma "infinite_pigeonhole[nat, {l: posnat | l<= length(args(s))}]") (("1" (inst -1 "args_of_pos_seq(seqp)") (("1" (skolem -1 "l") (("1" (typepred "l") (("1" (inst 2 "l") (("1" (expand "inf_red_arg_in_inf_nr_im_red") (("1" (expand "singleton") (("1" (hide-all-but (-1 -2 -7 1)) (("1" (expand "inverse_image") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (skeep) (("2" (inst -1 "x1") (("2" (inst -2 "x1") (("2" (flatten) (("2" (expand "args_of_pos_seq") (("2" (use "non_root_ir_preserves_root_symbol") (("2" (assert) (("2" (flatten) (("2" (hide -4 -5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -3 -4 2) (("3" (skeep) (("3" (inst?) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_finite_type") (("2" (inst 1 "length(args(s)) + 1" "LAMBDA(l: posnat | l <= length(args(s))): l") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil) ("3" (hide-all-but -1) (("3" (expand "is_finite_type") (("3" (lemma "infinite_def[nat]") (("3" (inst -1 "{x:nat | x >=0}") (("3" (prop) (("1" (expand "is_finite") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (skeep) (("2" (inst?) (("2" (flatten) (("2" (expand "non_root_innermost_reduction?") (("2" (inst?) (("1" (expand "innermost_reduction_fix?") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((positions_of_inf_nr_reduction formula-decl nil inn_dp_termination nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (pred type-eq-decl nil defined_types nil) (sequence type-eq-decl nil sequences nil) (i skolem-const-decl "nat" inn_dp_termination nil) (infinite_def formula-decl nil infinite_nat_def sets_aux) (is_finite const-decl "bool" finite_sets nil) (g skolem-const-decl "[nat -> below[N]]" inn_dp_termination nil) (N skolem-const-decl "nat" inn_dp_termination nil) (injective? const-decl "bool" functions nil) (< const-decl "bool" reals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (seqp skolem-const-decl "{seqp: sequence[position[variable, symbol, arity]] |
   FORALL (n: nat):
     positionsOF(seqt(n))(seqp(n)) AND
      NOT empty_seq = seqp(n) AND
       innermost_reduction_fix?(E)(seqt(n), seqt(1 + n), seqp(n))}" inn_dp_termination nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (positions? type-eq-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (seqt skolem-const-decl "{seqt: sequence[term[variable, symbol, arity]] |
   FORALL (n: nat): RTC(non_root_innermost_reduction?(E))(s, seqt(n))}" inn_dp_termination nil) (s skolem-const-decl "{s: term | app?(s)}" inn_dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (position type-eq-decl nil positions nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (member const-decl "bool" sets nil) (inverse_image const-decl "set[D]" function_image nil) (singleton const-decl "(singleton?)" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (union const-decl "set" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (add_first const-decl "finseq" seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (first const-decl "T" seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (non_root_ir_preserves_root_symbol formula-decl nil innermost_reduction nil) (is_finite_type const-decl "bool" finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (<= const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (infinite_pigeonhole formula-decl nil infinite_pigeonhole orders) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak) (exists_inf_red_arg_in_inf_nr_im_red-1 nil 3761501657 ("" (skeep* :preds? t) (("" (use "positions_of_inf_nr_reduction") (("" (prop) (("1" (skeep) (("1" (lemma "infinite_pigeonhole[nat, {l: posnat | l<= length(args(s))}]") (("1" (inst -1 "args_of_pos_seq(seqp)") (("1" (skolem -1 "l") (("1" (typepred "l") (("1" (inst 2 "l") (("1" (expand "inf_red_arg_in_inf_nr_im_red") (("1" (expand "singleton") (("1" (hide-all-but (-1 -2 -7 1)) (("1" (expand "inverse_image") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (skeep) (("2" (inst -1 "x1") (("2" (inst -2 "x1") (("2" (flatten) (("2" (expand "args_of_pos_seq") (("2" (use "non_root_ir_preserves_root_symbol") (("2" (assert) (("2" (flatten) (("2" (hide -4 -5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -3 -4 2) (("3" (skeep) (("3" (inst?) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_finite_type") (("2" (inst 1 "length(args(s)) + 1" "LAMBDA(l: posnat | l <= length(args(s))): l") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil) ("3" (hide-all-but -1) (("3" (expand "is_finite_type") (("3" (lemma "infinite_def[nat]") (("3" (inst -1 "{x:nat | x >=0}") (("3" (prop) (("1" (expand "is_finite") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (expand "injective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (skeep) (("2" (inst?) (("2" (flatten) (("2" (expand "non_root_innermost_reduction?") (("2" (inst?) (("1" (expand "innermost_reduction_fix?") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (infinite_def formula-decl nil infinite_nat_def sets_aux) (is_finite const-decl "bool" finite_sets nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (positions? type-eq-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (member const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (union const-decl "set" sets nil) (catenate const-decl "positions" positions nil) (add_first const-decl "finseq" seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (first const-decl "T" seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (non_root_ir_preserves_root_symbol formula-decl nil innermost_reduction nil) (is_finite_type const-decl "bool" finite_sets nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (infinite_pigeonhole formula-decl nil infinite_pigeonhole orders)) nil)) (exists_nth_in_inf_nr_im_red_TCC1 0 (exists_nth_in_inf_nr_im_red_TCC1-1 nil 3761499258 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (term type-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (sequence type-eq-decl nil sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (finseq type-eq-decl nil finite_sequences nil) (positions? type-eq-decl nil positions nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (IUnion const-decl "set[T]" indexed_sets nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (reduction_fix? const-decl "bool" reduction nil) (non_root_reduction? const-decl "bool" reduction nil) (reducible? const-decl "bool" ars_terminology nil) (is_normal_form? const-decl "bool" ars_terminology nil) (int_minus_int_is_int application-judgement "int" integers nil) (member const-decl "bool" sets nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (empty_seq const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (exists_nth_in_inf_nr_im_red subtype "inn_dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (i: naturalnumbers.nat): (booleans.NOT)(seqp(i) = finite_sequences[posnat].empty_seq)}"))) (exists_nth_in_inf_nr_im_red_TCC2 0 (exists_nth_in_inf_nr_im_red_TCC2-2 nil 3761500188 ("" (skolem 1 ("E" "s" "seqt" "seqp" "l1" "m")) (("" (prop) (("" (expand "is_finite") (("" (inst 1 "m" "LAMBDA(k: nat |
                         args_of_pos_seq(seqp)(k) = l1 AND
                          k < m): k") (("" (expand "injective?") (("" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (position type-eq-decl nil positions nil) (sequence type-eq-decl nil sequences nil) (NOT const-decl "[bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positions? type-eq-decl nil positions nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (< const-decl "bool" reals nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil)) nil (exists_nth_in_inf_nr_im_red subtype "{k: naturalnumbers.nat | booleans.AND(dependency_pairs[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].args_of_pos_seq(inn_dp_termination.seqp)(k) = inn_dp_termination.l, reals.<(k, inn_dp_termination.m))}" "finite_set[nat]")) (exists_nth_in_inf_nr_im_red_TCC2-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (exists_nth_in_inf_nr_im_red subtype "{k: naturalnumbers.nat | booleans.AND(dependency_pairs[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].args_of_pos_seq(inn_dp_termination.seqp)(k) = inn_dp_termination.l, reals.<(k, inn_dp_termination.m))}" "finite_set[nat]"))) (exists_nth_in_inf_nr_im_red 0 (exists_nth_in_inf_nr_im_red-1 nil 3761501696 ("" (skeep) (("" (skeep :preds? t) (("" (case "FORALL (i: nat): NOT seqp(i) = empty_seq[posnat]") (("1" (with-tccs (induct "n")) (("1" (expand "inf_red_arg_in_inf_nr_im_red") (("1" (expand "inverse_image") (("1" (expand "member") (("1" (expand "singleton") (("1" (use "infinite_nonempty[nat]") (("1" (inst 1 "min({x: nat | args_of_pos_seq(seqp)(x) = l})") (("1" (with-tccs (typepred "min({x: nat |
                                                                                                                args_of_pos_seq(seqp)(x) = l})")) (("1" (prop) (("1" (hide -1) (("1" (with-tccs (case "nonempty?({k: nat |
                                                         args_of_pos_seq(seqp)(k) = l AND
                                                          k < min({x: nat | args_of_pos_seq(seqp)(x) = l})})")) (("1" (with-tccs (name "nnat" "choose({k: nat |
                                                                                                                                                                                                                            args_of_pos_seq(seqp)(k) = l AND
                                                                                                                                                                                                                             k <
                                                                                                                                                                                                                              min({x: nat | args_of_pos_seq(seqp)(x) = l})})")) (("1" (inst -3 "nnat") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "nonempty_card[nat]") (("2" (hide-all-but (-1 1 2)) (("2" (with-tccs (name-replace "sset" "{k: nat |
                                                args_of_pos_seq(seqp)(k) = l AND
                                                 k < min({x: nat | args_of_pos_seq(seqp)(x) = l})}")) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep* :preds? t) (("2" (case "nonempty?({x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})") (("1" (case "is_finite[nat]({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m})") (("1" (inst 1 " min({x: nat |
                                                                                                                              args_of_pos_seq(seqp)(x) = l AND x > m})") (("1" (prop) (("1" (typepred "min({x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})") (("1" (propax) nil nil) ("2" (propax) nil nil)) nil) ("2" (with-tccs (case "{k: nat |
                                                  args_of_pos_seq(seqp)(k) = l AND
                                                   k < min({x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})} = add(m,{x: nat | args_of_pos_seq(seqp)(x) = l AND x < m})")) (("1" (replaces -1) (("1" (use " card_add[nat]") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "add") (("2" (hide -6 2) (("2" (expand "member") (("2" (decompose-equality) (("2" (iff) (("2" (typepred "min({x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})") (("2" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst?) (("2" (assert) nil nil)) nil) ("3" (inst?) (("3" (assert) nil nil)) nil) ("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -4 1)) (("2" (expand "is_finite") (("2" (inst 1 "m" "LAMBDA(k: nat |
                                                                                                                               args_of_pos_seq(seqp)(k) = l AND k < m): k") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "l") (("2" (expand "inf_red_arg_in_inf_nr_im_red") (("2" (expand "inverse_image") (("2" (expand "singleton") (("2" (expand "member") (("2" (case "{x: nat | args_of_pos_seq(seqp)(x) = l} = union({x: nat | args_of_pos_seq(seqp)(x) = l AND x <= m}, {x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})") (("1" (replace -1 1) (("1" (lemma "infinite_union[nat]") (("1" (inst? -1) (("1" (assert) (("1" (prop) (("1" (hide-all-but (-2 1)) (("1" (expand "is_finite") (("1" (inst 1 "m+1" "LAMBDA (x: nat |
                                                                                                                                               args_of_pos_seq(seqp)(x) = l AND x <= m) : x") (("1" (expand "injective?") (("1" (skeep) nil nil)) nil) ("2" (typepred "seqp") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "infinite_nonempty[nat]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "union") (("2" (expand "member") (("2" (decompose-equality) (("2" (iff) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (skeep*) (("2" (inst?) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (<= const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (is_finite const-decl "bool" finite_sets nil) (< const-decl "bool" reals nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (nat_induction formula-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (l skolem-const-decl "{l: posnat | l <= length(args(s)) AND inf_red_arg_in_inf_nr_im_red(seqp)(l)}" inn_dp_termination nil) (seqp skolem-const-decl "{seqp: sequence[position[variable, symbol, arity]] |
   FORALL (n: nat):
     positionsOF(seqt(n))(seqp(n)) AND
      NOT empty_seq = seqp(n) AND
       innermost_reduction_fix?(E)(seqt(n), seqt(1 + n), seqp(n))}" inn_dp_termination nil) (seqt skolem-const-decl "{seqt: sequence[term[variable, symbol, arity]] |
   FORALL (n: nat): RTC(non_root_innermost_reduction?(E))(s, seqt(n))}" inn_dp_termination nil) (s skolem-const-decl "{s: term | app?(s)}" inn_dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (inverse_image const-decl "set[D]" function_image nil) (singleton const-decl "(singleton?)" sets nil) (nonempty? const-decl "bool" sets nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (choose const-decl "(p)" sets nil) (nonempty_card formula-decl nil finite_sets nil) (infinite_set type-eq-decl nil infinite_sets_def nil) (infinite_nonempty judgement-tcc nil infinite_sets_def nil) (member const-decl "bool" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability sets_aux) (nonempty_singleton_finite application-judgement "non_empty_finite_set[posnat]" positions nil) (union const-decl "set" sets nil) (infinite_union formula-decl nil infinite_sets_def nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (card_add formula-decl nil finite_sets nil) (add const-decl "(nonempty?)" sets nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (m skolem-const-decl "nat" inn_dp_termination nil) (injective? const-decl "bool" functions nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (position type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (sequence type-eq-decl nil sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (positions? type-eq-decl nil positions nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil)) (nth_index_TCC1 0 (nth_index_TCC1-2 nil 3761500228 ("" (skolem 1 ("E" "s" "seqt" "seqp" "l1" "n")) (("" (typepred ("E" "s" "seqt" "seqp" "l1" "n")) (("" (lemma "exists_nth_in_inf_nr_im_red") (("" (inst -1 "E" "s" "seqt" "seqp" "l1" "n") (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (skeep) (("" (inst? -10) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (positions? type-eq-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (sequence type-eq-decl nil sequences nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (pred type-eq-decl nil defined_types nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (empty? const-decl "bool" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (exists_nth_in_inf_nr_im_red formula-decl nil inn_dp_termination nil)) nil (nth_index subtype "{m: naturalnumbers.nat | booleans.AND(dependency_pairs[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].args_of_pos_seq(inn_dp_termination.seqp)(m) = inn_dp_termination.l, finite_sets[nat].card({k: naturalnumbers.nat | booleans.AND(dependency_pairs[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].args_of_pos_seq(inn_dp_termination.seqp)(k) = inn_dp_termination.l, reals.<(k, m))}) = inn_dp_termination.n)}" "(sets[nat].nonempty?)")) (nth_index_TCC1-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (nth_index subtype "{m: naturalnumbers.nat | booleans.AND(dependency_pairs[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].args_of_pos_seq(inn_dp_termination.seqp)(m) = inn_dp_termination.l, finite_sets[nat].card({k: naturalnumbers.nat | booleans.AND(dependency_pairs[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].args_of_pos_seq(inn_dp_termination.seqp)(k) = inn_dp_termination.l, reals.<(k, m))}) = inn_dp_termination.n)}" "(sets[nat].nonempty?)"))) (nth_index_increasing_TCC1 0 (nth_index_increasing_TCC1-1 nil 3761499258 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (sequence type-eq-decl nil sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (finseq type-eq-decl nil finite_sequences nil) (positions? type-eq-decl nil positions nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (< const-decl "bool" reals nil) (subtermOF def-decl "term" subterm nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (member const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (Vars const-decl "set[(V)]" subterm nil) (subset? const-decl "bool" sets nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (E!1 skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (e!1 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (s!1 skolem-const-decl "{s: term | app?(s)}" inn_dp_termination nil) (seqt!1 skolem-const-decl "{seqt: sequence[term[variable, symbol, arity]] |
   FORALL (n: nat): RTC(non_root_innermost_reduction?(E!1))(s!1, seqt(n))}" inn_dp_termination nil) (n!1 skolem-const-decl "nat" inn_dp_termination nil) (seqp!1 skolem-const-decl "{seqp: sequence[position[variable, symbol, arity]] |
   FORALL (n: nat):
     positionsOF(seqt!1(n))(seqp(n)) AND
      NOT empty_seq = seqp(n) AND
       innermost_reduction_fix?(E!1)(seqt!1(n), seqt!1(1 + n), seqp(n))}" inn_dp_termination nil) (p!1 skolem-const-decl "{p:
   positions?
       [variable, symbol, arity](subtermOF(seqt!1(n!1), seqp!1(n!1))) |
   NOT (p = empty_seq)}" inn_dp_termination nil) (sigma!1 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (ext def-decl "term" substitution nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (p!2 skolem-const-decl "positions?[variable, symbol, arity](e!1`1)" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (int_minus_int_is_int application-judgement "int" integers nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (p!2 skolem-const-decl "positions?[variable, symbol, arity](e!1`1)" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (p!2 skolem-const-decl "positions?[variable, symbol, arity](e!1`1)" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (IUnion const-decl "set[T]" indexed_sets nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[posnat]" positions nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability sets_aux) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty_seq const-decl "finseq" finite_sequences nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (reduction_fix? const-decl "bool" reduction nil) (non_root_reduction? const-decl "bool" reduction nil) (term type-decl nil term_adt nil) (reducible? const-decl "bool" ars_terminology nil) (is_normal_form? const-decl "bool" ars_terminology nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Dom const-decl "set[(V)]" substitution nil) (/= const-decl "boolean" notequal nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil)) nil (nth_index_increasing subtype "inn_dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (n: naturalnumbers.nat): booleans.AND(positions[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].positionsOF(inn_dp_termination.seqt(n))(seqp(n)), booleans.AND((booleans.NOT)(finite_sequences[posnat].empty_seq = seqp(n)), innermost_reduction[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].innermost_reduction_fix?(inn_dp_termination.E)(inn_dp_termination.seqt(n), inn_dp_termination.seqt((number_fields.+)(1, n)), seqp(n))))}"))) (nth_index_increasing 0 (nth_index_increasing-1 nil 3761501744 ("" (skeep* :preds? t) (("" (expand "nth_index") (("" (with-tccs (typepred "choose({m: nat |
                               args_of_pos_seq(seqp)(m) = l AND
                                card({k: nat |
                                        args_of_pos_seq(seqp)(k) = l AND k < m})
                                 = i})")) (("" (with-tccs (name-replace "ith_index" "choose({m: nat |
                                           args_of_pos_seq(seqp)(m) = l AND
                                            card({k: nat |
                                                    args_of_pos_seq(seqp)(k) = l AND k < m})
                                             = i})")) (("" (with-tccs (typepred "choose({m: nat |
                                            args_of_pos_seq(seqp)(m) = l AND
                                             card({k: nat |
                                                     args_of_pos_seq(seqp)(k) = l AND k < m})
                                              = j})")) (("" (with-tccs (name-replace "jth_index" "choose({m: nat |
                                                        args_of_pos_seq(seqp)(m) = l AND
                                                         card({k: nat |
                                                                 args_of_pos_seq(seqp)(k) = l AND k < m})
                                                          = j})")) (("" (case "subset?({k_1: nat | args_of_pos_seq(seqp)(k_1) = l AND k_1 < jth_index},
                                                                                         {k_1: nat | args_of_pos_seq(seqp)(k_1) = l AND k_1 < ith_index})") (("1" (with-tccs (use "card_subset[nat]")) (("1" (assert) nil nil)) nil) ("2" (expand "subset?") (("2" (expand "member") (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth_index const-decl "nat" inn_dp_termination nil) (member const-decl "bool" sets nil) (card_subset formula-decl nil finite_sets nil) (ith_index skolem-const-decl "({m: nat |
    args_of_pos_seq(seqp)(m) = l AND
     card({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m}) = i})" inn_dp_termination nil) (jth_index skolem-const-decl "({m: nat |
    args_of_pos_seq(seqp)(m) = l AND
     card({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m}) = j})" inn_dp_termination nil) (j skolem-const-decl "{j: nat | i < j}" inn_dp_termination nil) (i skolem-const-decl "nat" inn_dp_termination nil) (l skolem-const-decl "{l: posnat | l <= length(args(s)) AND inf_red_arg_in_inf_nr_im_red(seqp)(l)}" inn_dp_termination nil) (seqp skolem-const-decl "{seqp: sequence[position[variable, symbol, arity]] |
   FORALL (n: nat):
     positionsOF(seqt(n))(seqp(n)) AND
      NOT empty_seq = seqp(n) AND
       innermost_reduction_fix?(E)(seqt(n), seqt(1 + n), seqp(n))}" inn_dp_termination nil) (seqt skolem-const-decl "{seqt: sequence[term[variable, symbol, arity]] |
   FORALL (n: nat): RTC(non_root_innermost_reduction?(E))(s, seqt(n))}" inn_dp_termination nil) (s skolem-const-decl "{s: term | app?(s)}" inn_dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subset? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (position type-eq-decl nil positions nil) (sequence type-eq-decl nil sequences nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positions? type-eq-decl nil positions nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (< const-decl "bool" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil)) (nth_index_continuous_TCC1 0 (nth_index_continuous_TCC1-1 nil 3761499258 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (sequence type-eq-decl nil sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (finseq type-eq-decl nil finite_sequences nil) (positions? type-eq-decl nil positions nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability sets_aux) (nonempty_singleton_finite application-judgement "non_empty_finite_set[posnat]" positions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (p!2 skolem-const-decl "positions?[variable, symbol, arity](e!1`1)" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (p!2 skolem-const-decl "positions?[variable, symbol, arity](e!1`1)" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (int_minus_int_is_int application-judgement "int" integers nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (p!2 skolem-const-decl "positions?[variable, symbol, arity](e!1`1)" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (ext def-decl "term" substitution nil) (sigma!1 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (p!1 skolem-const-decl "{p:
   positions?
       [variable, symbol, arity](subtermOF(seqt!1(n!1), seqp!1(n!1))) |
   NOT (p = empty_seq)}" inn_dp_termination nil) (seqp!1 skolem-const-decl "{seqp: sequence[position[variable, symbol, arity]] |
   FORALL (n: nat):
     positionsOF(seqt!1(n))(seqp(n)) AND
      NOT empty_seq = seqp(n) AND
       innermost_reduction_fix?(E!1)(seqt!1(n), seqt!1(1 + n), seqp(n))}" inn_dp_termination nil) (n!1 skolem-const-decl "nat" inn_dp_termination nil) (seqt!1 skolem-const-decl "{seqt: sequence[term[variable, symbol, arity]] |
   FORALL (n: nat): RTC(non_root_innermost_reduction?(E!1))(s!1, seqt(n))}" inn_dp_termination nil) (s!1 skolem-const-decl "{s: term | app?(s)}" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (sigma!2 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (e!2 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (e!1 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (E!1 skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (subset? const-decl "bool" sets nil) (Vars const-decl "set[(V)]" subterm nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (subtermOF def-decl "term" subterm nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (first const-decl "T" seq_extras structures) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (empty_seq const-decl "finseq" finite_sequences nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (reduction_fix? const-decl "bool" reduction nil) (non_root_reduction? const-decl "bool" reduction nil) (term type-decl nil term_adt nil) (reducible? const-decl "bool" ars_terminology nil) (is_normal_form? const-decl "bool" ars_terminology nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Dom const-decl "set[(V)]" substitution nil) (/= const-decl "boolean" notequal nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil)) nil (nth_index_continuous subtype "inn_dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (n: naturalnumbers.nat): booleans.AND(positions[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].positionsOF(inn_dp_termination.seqt(n))(seqp(n)), booleans.AND((booleans.NOT)(finite_sequences[posnat].empty_seq = seqp(n)), innermost_reduction[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].innermost_reduction_fix?(inn_dp_termination.E)(inn_dp_termination.seqt(n), inn_dp_termination.seqt((number_fields.+)(1, n)), seqp(n))))}"))) (nth_index_continuous_TCC2 0 (nth_index_continuous_TCC2-2 nil 3761500270 ("" (skeep* :preds? t) (("" (expand "is_finite") (("" (inst 1 "nth_index(E)(s)(seqt)(seqp)(l)(i + 1)" "LAMBDA(k_1: nat |
                           args_of_pos_seq(seqp)(k_1) = l AND
                            k_1 < nth_index(E)(s)(seqt)(seqp)(l)(i + 1)): k_1") (("" (expand "injective?") (("" (skeep) nil nil)) nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (< const-decl "bool" reals nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (nth_index const-decl "nat" inn_dp_termination nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (positions? type-eq-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (pred type-eq-decl nil defined_types nil) (sequence type-eq-decl nil sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (nth_index_continuous subtype "{k_1: naturalnumbers.nat | booleans.AND(dependency_pairs[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].args_of_pos_seq(inn_dp_termination.seqp)(k_1) = inn_dp_termination.l, reals.<(k_1, inn_dp_termination.nth_index(inn_dp_termination.E)(inn_dp_termination.s)(inn_dp_termination.seqt)(inn_dp_termination.seqp)(inn_dp_termination.l)((number_fields.+)(inn_dp_termination.i, 1))))}" "finite_set[nat]")) (nth_index_continuous_TCC2-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (nth_index_continuous subtype "{k_1: naturalnumbers.nat | booleans.AND(dependency_pairs[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].args_of_pos_seq(inn_dp_termination.seqp)(k_1) = inn_dp_termination.l, reals.<(k_1, inn_dp_termination.nth_index(inn_dp_termination.E)(inn_dp_termination.s)(inn_dp_termination.seqt)(inn_dp_termination.seqp)(inn_dp_termination.l)((number_fields.+)(inn_dp_termination.i, 1))))}" "finite_set[nat]"))) (nth_index_continuous_TCC3 0 (nth_index_continuous_TCC3-2 nil 3761500309 ("" (skeep* :preds? t) (("" (expand "is_finite") (("" (inst 1 "nth_index(E)(s)(seqt)(seqp)(l)(i)" "LAMBDA(k_1: nat |
                           args_of_pos_seq(seqp)(k_1) = l AND
                            k_1 < nth_index(E)(s)(seqt)(seqp)(l)(i)): k_1") (("" (expand "injective?") (("" (skeep) nil nil)) nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (< const-decl "bool" reals nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (nth_index const-decl "nat" inn_dp_termination nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (positions? type-eq-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (pred type-eq-decl nil defined_types nil) (sequence type-eq-decl nil sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (nth_index_continuous subtype "{k_1: naturalnumbers.nat | booleans.AND(dependency_pairs[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].args_of_pos_seq(inn_dp_termination.seqp)(k_1) = inn_dp_termination.l, reals.<(k_1, inn_dp_termination.nth_index(inn_dp_termination.E)(inn_dp_termination.s)(inn_dp_termination.seqt)(inn_dp_termination.seqp)(inn_dp_termination.l)(inn_dp_termination.i)))}" "finite_set[nat]")) (nth_index_continuous_TCC3-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (nth_index_continuous subtype "{k_1: naturalnumbers.nat | booleans.AND(dependency_pairs[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].args_of_pos_seq(inn_dp_termination.seqp)(k_1) = inn_dp_termination.l, reals.<(k_1, inn_dp_termination.nth_index(inn_dp_termination.E)(inn_dp_termination.s)(inn_dp_termination.seqt)(inn_dp_termination.seqp)(inn_dp_termination.l)(inn_dp_termination.i)))}" "finite_set[nat]"))) (nth_index_continuous 0 (nth_index_continuous-1 nil 3761501805 ("" (skeep* :preds? t) (("" (expand "nth_index") (("" (with-tccs (typepred "choose({m: nat |
                                       args_of_pos_seq(seqp)(m) = l AND
                                        card({k: nat |
                                                args_of_pos_seq(seqp)(k) = l AND
                                                 k < m})
                                         = 1 + i})") :tcc-step (skip)) (("1" (with-tccs (name-replace "i1nth_index" "choose({m: nat |
                                                 args_of_pos_seq(seqp)(m) = l AND
                                                  card({k: nat |
                                                          args_of_pos_seq(seqp)(k) = l AND
                                                           k < m})
                                                   = 1 + i})")) (("1" (with-tccs (typepred "choose({m: nat |
                                                   args_of_pos_seq(seqp)(m) = l AND
                                                    card({k: nat |
                                                            args_of_pos_seq(seqp)(k) = l
                                                            AND
                                                            k < m})
                                                     = i})") :tcc-step (skip)) (("1" (with-tccs (name-replace "ith_index" "choose({m: nat |
                                                             args_of_pos_seq(seqp)(m) = l AND
                                                              card({k: nat |
                                                                      args_of_pos_seq(seqp)(k) = l
                                                                      AND
                                                                      k < m})
                                                               = i})")) (("1" (hide 2) (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (expand "member") (("1" (lemma "exists_nth_in_inf_nr_im_red") (("1" (inst -1 "E" "s" "seqt" "seqp" "l" "i") (("1" (skeep) (("1" (inst -3 "m") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "is_finite") (("2" (inst 1 "m" "LAMBDA(k: nat |
                                               args_of_pos_seq(seqp)(k) = l AND k < m): k") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_im_red") (("2" (inst -1 "E" "s" "seqt" "seqp" "l" "1 + i") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                         args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth_index const-decl "nat" inn_dp_termination nil) (int_minus_int_is_int application-judgement "int" integers nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability sets_aux) (nonempty_singleton_finite application-judgement "non_empty_finite_set[posnat]" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (first const-decl "T" seq_extras structures) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (reduction_fix? const-decl "bool" reduction nil) (non_root_reduction? const-decl "bool" reduction nil) (reducible? const-decl "bool" ars_terminology nil) (is_normal_form? const-decl "bool" ars_terminology nil) (IUnion const-decl "set[T]" indexed_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (i skolem-const-decl "nat" inn_dp_termination nil) (l skolem-const-decl "{l: posnat | l <= length(args(s)) AND inf_red_arg_in_inf_nr_im_red(seqp)(l)}" inn_dp_termination nil) (seqp skolem-const-decl "{seqp: sequence[position[variable, symbol, arity]] |
   FORALL (n: nat):
     positionsOF(seqt(n))(seqp(n)) AND
      NOT empty_seq = seqp(n) AND
       innermost_reduction_fix?(E)(seqt(n), seqt(1 + n), seqp(n))}" inn_dp_termination nil) (seqt skolem-const-decl "{seqt: sequence[term[variable, symbol, arity]] |
   FORALL (n: nat): RTC(non_root_innermost_reduction?(E))(s, seqt(n))}" inn_dp_termination nil) (s skolem-const-decl "{s: term | app?(s)}" inn_dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (injective? const-decl "bool" functions nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (exists_nth_in_inf_nr_im_red formula-decl nil inn_dp_termination nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (position type-eq-decl nil positions nil) (sequence type-eq-decl nil sequences nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positions? type-eq-decl nil positions nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (< const-decl "bool" reals nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (finite_set type-eq-decl nil finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil)) (argument_protected_in_non_nth_index_TCC1 0 (argument_protected_in_non_nth_index_TCC1-2 nil 3761500360 ("" (skeep* :preds? t) nil nil) nil nil (argument_protected_in_non_nth_index subtype "inn_dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (n: naturalnumbers.nat): booleans.AND(positions[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].positionsOF(inn_dp_termination.seqt(n))(seqp(n)), booleans.AND((booleans.NOT)(finite_sequences[posnat].empty_seq = seqp(n)), innermost_reduction[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].innermost_reduction_fix?(inn_dp_termination.E)(inn_dp_termination.seqt(n), inn_dp_termination.seqt((number_fields.+)(1, n)), seqp(n))))}")) (argument_protected_in_non_nth_index_TCC1-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (argument_protected_in_non_nth_index subtype "inn_dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (n: naturalnumbers.nat): booleans.AND(positions[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].positionsOF(inn_dp_termination.seqt(n))(seqp(n)), booleans.AND((booleans.NOT)(finite_sequences[posnat].empty_seq = seqp(n)), innermost_reduction[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].innermost_reduction_fix?(inn_dp_termination.E)(inn_dp_termination.seqt(n), inn_dp_termination.seqt((number_fields.+)(1, n)), seqp(n))))}"))) (argument_protected_in_non_nth_index_TCC2 0 (argument_protected_in_non_nth_index_TCC2-2 nil 3761500400 ("" (skeep* :preds? t) (("" (inst? -3) (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (argument_protected_in_non_nth_index subtype "inn_dp_termination.seqp(inn_dp_termination.j)" "{p: positions[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].positions?(inn_dp_termination.seqt(inn_dp_termination.j)) | (booleans.NOT)((p = finite_sequences[posnat].empty_seq))}")) (argument_protected_in_non_nth_index_TCC2-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (argument_protected_in_non_nth_index subtype "inn_dp_termination.seqp(inn_dp_termination.j)" "{p: positions[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].positions?(inn_dp_termination.seqt(inn_dp_termination.j)) | (booleans.NOT)((p = finite_sequences[posnat].empty_seq))}"))) (argument_protected_in_non_nth_index 0 (argument_protected_in_non_nth_index-1 nil 3761501847 ("" (skeep* :preds? t) (("" (prop) (("1" (expand "nth_index") (("1" (with-tccs (typepred "choose({m: nat |
                            args_of_pos_seq(seqp)(m) = l AND
                             card({k: nat |
                                     args_of_pos_seq(seqp)(k) = l AND
                                      k < m})
                              = 0})")) (("1" (with-tccs (name-replace "zeroth_index" "choose({m: nat |
                                         args_of_pos_seq(seqp)(m) = l AND
                                          card({k: nat |
                                                  args_of_pos_seq(seqp)(k) =
                                                   l
                                                   AND k < m})
                                           = 0})")) (("1" (lemma "card_empty?[nat]") (("1" (inst?) (("1" (assert) (("1" (iff) (("1" (prop) (("1" (hide -1 -4) (("1" (expand "empty?") (("1" (expand "member") (("1" (inst -1 "j") (("1" (assert) (("1" (expand "args_of_pos_seq") (("1" (expand "arg_rest?") (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_finite") (("2" (inst 1 "zeroth_index" "LAMBDA(k_1: nat |
                                         args_of_pos_seq(seqp)(k_1) = l AND
                                          k_1 < zeroth_index): k_1") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "nth_index_continuous") (("2" (inst?) (("2" (assert) (("2" (expand "nth_index") (("2" (with-tccs (typepred "choose({m: nat |
                                args_of_pos_seq(seqp)(m) = l AND
                                 card({k: nat |
                                         args_of_pos_seq(seqp)(k) = l AND k < m})
                                  = 1 + n})")) (("2" (with-tccs (name-replace "n1_index" "choose({m: nat |
                                        args_of_pos_seq(seqp)(m) = l AND
                                         card({k: nat |
                                                 args_of_pos_seq(seqp)(k) = l AND k < m})
                                          = 1 + n})")) (("2" (with-tccs (typepred "choose({m: nat |
                                            args_of_pos_seq(seqp)(m) = l AND
                                             card({k: nat |
                                                     args_of_pos_seq(seqp)(k) = l AND k < m})
                                              = n})") :tcc-step (skip)) (("1" (with-tccs (name-replace "n_index" "choose({m: nat |
                                                      args_of_pos_seq(seqp)(m) = l AND
                                                       card({k: nat |
                                                               args_of_pos_seq(seqp)(k) = l AND k < m})
                                                        = n})")) (("1" (typepred "min({m : nat | m > n_index AND m <= j AND
                                                       args_of_pos_seq(seqp)(m) = l})") (("1" (name-replace "min_j_index" "min({m: nat |
                                                           m > n_index AND
                                                            m <= j AND args_of_pos_seq(seqp)(m) = l})") (("1" (case "strict_subset?({k: nat | args_of_pos_seq(seqp)(k) = l AND k < n_index}, {k_1: nat |
                                                                                                    args_of_pos_seq(seqp)(k_1) = l AND k_1 < min_j_index})") (("1" (use "card_strict_subset[nat]") (("1" (assert) (("1" (replace -8) (("1" (case "strict_subset?({k_1: nat |
                                                                                                                        args_of_pos_seq(seqp)(k_1) = l AND k_1 < min_j_index}, {k: nat | args_of_pos_seq(seqp)(k) = l AND k < n1_index})") (("1" (hide -3) (("1" (use "card_strict_subset[nat]") (("1" (assert) nil nil) ("2" (expand "is_finite") (("2" (inst 1 "n1_index" "LAMBDA(k_1: nat |
                                                                                                                         args_of_pos_seq(seqp)(k_1) = l AND
                                                                                                                          k_1 < n1_index): k_1") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil) ("3" (expand "is_finite") (("3" (inst 1 "min_j_index" "LAMBDA(k_1: nat |
                                                                                                           args_of_pos_seq(seqp)(k_1) = l AND
                                                                                                            k_1 < min_j_index): k_1") (("3" (expand "injective?") (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "strict_subset?") (("2" (prop) (("1" (expand "subset?") (("1" (expand "member") (("1" (skeep) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (decompose-equality -1) (("2" (inst -1 "min_j_index") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_finite") (("2" (inst 1 "min_j_index" "LAMBDA(k_1: nat |
                                                                                       args_of_pos_seq(seqp)(k_1) = l AND
                                                                                        k_1 < min_j_index): k_1") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil) ("3" (expand "is_finite") (("3" (inst 1 "n_index" "LAMBDA(k_1: nat |
                                                                                       args_of_pos_seq(seqp)(k_1) = l AND
                                                                                        k_1 < n_index): k_1") (("3" (expand "injective?") (("3" (skeep) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "strict_subset?") (("2" (prop) (("1" (expand "subset?") (("1" (expand "member") (("1" (skeep) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (decompose-equality -1) (("2" (inst -1 "n_index") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -1 "j") (("2" (assert) (("2" (hide-all-but (-15 1)) (("2" (expand "args_of_pos_seq") (("2" (expand "arg_rest?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "is_finite") (("2" (inst 1 "m" "LAMBDA(k: nat |
                                                   args_of_pos_seq(seqp)(k) = l AND
                                                    k < m): k") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((< const-decl "bool" reals nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (nonempty? const-decl "bool" sets nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (positions? type-eq-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (NOT const-decl "[bool -> bool]" booleans nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (pred type-eq-decl nil defined_types nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (sequence type-eq-decl nil sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (choose const-decl "(p)" sets nil) (card_empty? formula-decl nil finite_sets nil) (injective? const-decl "bool" functions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty? const-decl "bool" sets nil) (arg_rest? const-decl "bool" innermost_reduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (member const-decl "bool" sets nil) (zeroth_index skolem-const-decl "({m: nat |
    args_of_pos_seq(seqp)(m) = l AND
     card({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m}) = 0})" inn_dp_termination nil) (l skolem-const-decl "{l: posnat | l <= length(args(s)) AND inf_red_arg_in_inf_nr_im_red(seqp)(l)}" inn_dp_termination nil) (seqp skolem-const-decl "{seqp: sequence[position[variable, symbol, arity]] |
   FORALL (n: nat):
     positionsOF(seqt(n))(seqp(n)) AND
      NOT empty_seq = seqp(n) AND
       innermost_reduction_fix?(E)(seqt(n), seqt(1 + n), seqp(n))}" inn_dp_termination nil) (seqt skolem-const-decl "{seqt: sequence[term[variable, symbol, arity]] |
   FORALL (n: nat): RTC(non_root_innermost_reduction?(E))(s, seqt(n))}" inn_dp_termination nil) (s skolem-const-decl "{s: term | app?(s)}" inn_dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (nth_index const-decl "nat" inn_dp_termination nil) (nth_index_continuous formula-decl nil inn_dp_termination nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (strict_subset? const-decl "bool" sets nil) (strict_subset_is_strict_order name-judgement "(strict_order?[set[T]])" sets_lemmas nil) (n1_index skolem-const-decl "({m: nat |
    args_of_pos_seq(seqp)(m) = l AND
     card({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m}) = 1 + n})" inn_dp_termination nil) (subset? const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (n skolem-const-decl "nat" inn_dp_termination nil) (n_index skolem-const-decl "({m: nat |
    args_of_pos_seq(seqp)(m) = l AND
     card({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m}) = n})" inn_dp_termination nil) (j skolem-const-decl "nat" inn_dp_termination nil) (min_j_index skolem-const-decl "{a |
   (a > n_index AND a <= j AND args_of_pos_seq(seqp)(a) = l) AND
    FORALL (x: nat):
      x > n_index AND x <= j AND args_of_pos_seq(seqp)(x) = l IMPLIES
       a <= x}" inn_dp_termination nil) (card_strict_subset formula-decl nil finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil)) (mint_is_nr_inn_terminating 0 (mint_is_nr_inn_terminating-3 nil 3785696120 ("" (skeep) (("" (expand "noetherian?") (("" (expand "converse") (("" (rewrite "no_infinite_descending_sequence") (("" (expand "descending?") (("" (expand "empty?") (("" (expand "member") (("" (skolem 1 "seqt") (("" (use "mint_is_app") (("" (assert) (("" (use "positions_of_inf_nr_reduction") (("" (prop) (("1" (skeep) (("1" (use "exists_inf_red_arg_in_inf_nr_im_red") (("1" (skeep :preds? t) (("1" (expand "minimal_innermost_non_terminating?") (("1" (flatten) (("1" (inst -6 "#(l)") (("1" (expand "terminating?") (("1" (inst-cp -7 "0") (("1" (expand "rest?" -8) (("1" (flatten) (("1" (hide -9 -10) (("1" (lemma "non_root_rtc_reduction_of_argument") (("1" (inst -1 "E" "seqt(0)" "s") (("1" (assert) (("1" (inst -1 "l") (("1" (expand "RTC" -1) (("1" (expand "IUnion") (("1" (skeep) (("1" (use "iterate_to_finseq") (("1" (assert) (("1" (expand "finseq_appl") (("1" (skolem -1 "preseq") (("1" (flatten) (("1" (inst 1 "LAMBDA(i: nat): IF i < length(preseq) THEN preseq(i) ELSE subtermOF(seqt(nth_index(E)(s)(seqt)(seqp)(l)(i - length(preseq)) + 1), #(l)) ENDIF") (("1" (expand "finseq_appl") (("1" (assert) (("1" (skeep) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (inst? -5) (("1" (assert) nil nil)) nil) ("2" (case-replace "n = length(preseq) - 1") (("1" (assert) (("1" (replaces -4) (("1" (hide -1 -2 -3 -4 -5 -8 1) (("1" (case-replace "subtermOF(seqt(0),  #(l)) = subtermOF(seqt(nth_index(E)(s)(seqt)(seqp)(l)(0)), #(l))" :hide? t) (("1" (name-replace "zeroth_index" "nth_index(E)(s)(seqt)(seqp)(l)(0)") (("1" (inst -3 "zeroth_index") (("1" (flatten) (("1" (case "first(seqp(zeroth_index)) = l") (("1" (case " #(l) o rest(seqp(zeroth_index)) = seqp(zeroth_index)") (("1" (expand "innermost_reduction_fix?") (("1" (flatten) (("1" (expand "reduction_fix?") (("1" (skeep) (("1" (expand "innermost_reduction?") (("1" (inst 1 "rest(seqp(zeroth_index))") (("1" (expand "innermost_reduction_fix?") (("1" (expand "reduction_fix?") (("1" (lemma "pos_subterm") (("1" (inst -1 " #(l)" "rest(seqp(zeroth_index))" "seqt(zeroth_index)") (("1" (assert) (("1" (inst? 1) (("1" (assert) (("1" (use "replace_distributivity") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "pos_subterm_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 -7 -8 2) (("2" (use "seq_first_rest_1[posnat]") (("2" (assert) (("2" (hide-all-but (1 3)) (("2" (lemma "empty_0[posnat]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "zeroth_index") (("2" (expand "nth_index") (("2" (expand "args_of_pos_seq") (("2" (with-tccs (typepred "choose({m: nat |
                                                                                                                                                                                                                                                                         first(seqp(m)) = l AND
                                                                                                                                                                                                                                                                          card({k: nat | first(seqp(k)) = l AND k < m})
                                                                                                                                                                                                                                                                           = n})")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 3)) (("3" (use "empty_0[posnat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (name "fseq_t" "(#length := nth_index(E)(s)(seqt)(seqp)(l)(0) + 1, seq := LAMBDA(i:below[nth_index(E)(s)(seqt)(seqp)(l)(0)+1]): seqt(i) #)") (("2" (name "fseq_p" "(#length := nth_index(E)(s)(seqt)(seqp)(l)(0) + 1, seq := LAMBDA(i:below[nth_index(E)(s)(seqt)(seqp)(l)(0)+1]): seqp(i) #)") (("2" (lemma "arg_preservation_in_finite_reduction") (("2" (expand "finseq_appl") (("2" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (prop) (("1" (inst -1 "nth_index(E)(s)(seqt)(seqp)(l)(0)") (("1" (expand "fseq_t") (("1" (propax) nil nil)) nil) ("2" (expand "fseq_p") (("2" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (expand "fseq_t") (("2" (expand "fseq_p") (("2" (hide -1 -2) (("2" (inst -3 "n!1") (("2" (flatten) (("2" (assert) (("2" (typepred "n!1") (("2" (expand "fseq_p") (("2" (hide 1) (("2" (use "argument_protected_in_non_nth_index") (("2" (prop) (("2" (expand "arg_rest?") (("2" (expand "rest?") (("2" (inst -9 "n!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (hide-all-but (-3 -4 -8 1)) (("2" (expand "fseq_t") (("2" (expand "rest?") (("2" (inst?) (("2" (flatten) (("2" (use "non_root_ir_preserves_root_symbol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-5 1)) (("4" (expand "fseq_t") (("4" (expand "finseq_appl") (("4" (expand "empty_seq") (("4" (inst?) (("4" (flatten) (("4" (use "reducible_is_app") (("4" (assert) (("4" (use "innermost_subset_reduction") (("4" (expand "subset?") (("4" (expand "member") (("4" (expand "reducible?") (("4" (inst 1 "seqt(1)") (("4" (inst?) (("4" (assert) (("4" (expand "innermost_reduction?") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -6 "nth_index(E)(s)(seqt)(seqp)(l)(0)") (("3" (expand "rest?") (("3" (flatten) (("3" (hide-all-but (-1 -2 -6 1)) (("3" (use "non_root_ir_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (hide -1 -2 -3 -4 -7) (("3" (case-replace "1 - length(preseq) + n = n - length(preseq) + 1") (("1" (name-replace "nn" "n - length(preseq)") (("1" (hide -1) (("1" (with-tccs (case-replace "subtermOF(seqt(1 + nth_index(E)(s)(seqt)(seqp)(l)(nn)), #(l)) = subtermOF(seqt(nth_index(E)(s)(seqt)(seqp)(l)(nn + 1)), #(l)) " :hide? t) :tcc-step (skip)) (("1" (with-tccs (name-replace "n1th_index" "nth_index
                                                                                                                                                                                                        (E)(s)(seqt)(seqp)(l)(nn + 1)")) (("1" (inst -3 "n1th_index") (("1" (flatten) (("1" (case "first(seqp(n1th_index)) = l") (("1" (case " #(l) o rest(seqp(n1th_index)) = seqp(n1th_index)") (("1" (expand "innermost_reduction_fix?") (("1" (flatten) (("1" (expand "reduction_fix?") (("1" (skeep) (("1" (expand "innermost_reduction?") (("1" (inst 2 "rest(seqp(n1th_index))") (("1" (expand "innermost_reduction_fix?") (("1" (expand "reduction_fix?") (("1" (lemma "pos_subterm") (("1" (inst -1 " #(l)" "rest(seqp(n1th_index))" "seqt(n1th_index)") (("1" (assert) (("1" (inst? 2) (("1" (assert) (("1" (use "replace_distributivity") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "pos_subterm_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 -7 -8 -9 3) (("2" (use "seq_first_rest_1[posnat]") (("2" (assert) (("2" (hide-all-but (1 4)) (("2" (lemma "empty_0[posnat]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n1th_index") (("2" (expand "nth_index") (("2" (expand "args_of_pos_seq") (("2" (with-tccs (typepred "choose({m: nat |
                                                                                                                                                                                                                                 first(seqp(m)) = l AND
                                                                                                                                                                                                                                  card({k: nat | first(seqp(k)) = l AND k < m})
                                                                                                                                                                                                                                   = 1 + nn})")) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 4)) (("3" (use "empty_0[posnat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "nn") (("2" (case-replace "1 - length(preseq) + n = n - length(preseq) + 1") (("1" (case-replace "length(preseq) = n") (("1" (assert) (("1" (name "l_seq" "nth_index(E)(s)(seqt)(seqp)(l)(1) - nth_index(E)(s)(seqt)(seqp)(l)(0)") (("1" (name "fseq_t" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqt(i + 1 + nth_index(E)(s)(seqt)(seqp)(l)(0)) #)") (("1" (name "fseq_p" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqp(i + 1 + nth_index(E)(s)(seqt)(seqp)(l)(0)) #)") (("1" (lemma "arg_preservation_in_finite_reduction") (("1" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (expand "finseq_appl") (("1" (prop) (("1" (expand "fseq_t") (("1" (inst -1 "l_seq - 1") (("1" (expand "l_seq") (("1" (propax) nil nil)) nil) ("2" (expand "l_seq") (("2" (assert) (("2" (lemma "nth_index_increasing") (("2" (inst -1 "E" "s" "seqt" "seqp" "l" "0" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (expand "fseq_p") (("2" (expand "fseq_t") (("2" (skeep :preds? t) (("2" (inst? -7) (("2" (flatten) (("2" (assert) (("2" (expand "fseq_p") (("2" (expand "l_seq") (("2" (hide -3) (("2" (lemma "argument_protected_in_non_nth_index") (("2" (inst -1 "E" "s" "seqt" "seqp" "l" "1 + nth_index(E)(s)(seqt)(seqp)(l)(0) + n!1") (("2" (prop) (("1" (assert) (("1" (expand "arg_rest?") (("1" (inst? -11) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst 2 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "finseq_appl") (("2" (expand "fseq_t") (("2" (inst? -11) (("2" (expand "rest?") (("2" (flatten) (("2" (hide-all-but (-6 -7 -11 1)) (("2" (use "non_root_ir_preserves_root_symbol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2 1)) (("3" (expand "fseq_p") (("3" (expand "l_seq") (("3" (assert) (("3" (hide -) (("3" (lemma "nth_index_increasing") (("3" (inst -1 "E" "s" "seqt" "seqp" "l" "0" "1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 -2 -8 1)) (("4" (expand "fseq_t") (("4" (expand "l_seq") (("4" (lemma "nth_index_increasing") (("4" (inst -1 "E" "s" "seqt" "seqp" "l" "0" "1") (("4" (assert) (("4" (expand "empty_seq") (("4" (expand "finseq_appl") (("4" (name-replace "idx" "1 + nth_index(E)(s)(seqt)(seqp)(l)(0)") (("4" (inst -3 "idx") (("4" (flatten) (("4" (hide-all-but (-4 1)) (("4" (use "reducible_is_app") (("4" (assert) (("4" (expand "reducible?") (("4" (inst 1 "seqt(1 + idx)") (("4" (use "innermost_subset_reduction") (("4" (expand "subset?") (("4" (expand "member") (("4" (inst?) (("4" (assert) (("4" (expand "innermost_reduction?") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "l_seq") (("2" (lemma "nth_index_increasing") (("2" (inst -1 "E" "s" "seqt" "seqp" "l" "0" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-tccs (name "l_seq" "nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq) + 1) - nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq))") :tcc-step (skip)) (("1" (name "fseq_t" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqt(i + 1 + nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq))) #)") (("1" (name "fseq_p" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqp(i + 1 + nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq))) #)") (("1" (lemma "arg_preservation_in_finite_reduction") (("1" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (expand "finseq_appl") (("1" (prop) (("1" (expand "fseq_t") (("1" (inst -1 "l_seq - 1") (("1" (expand "l_seq") (("1" (assert) nil nil)) nil) ("2" (expand "l_seq") (("2" (assert) (("2" (lemma "nth_index_increasing") (("2" (inst -1 "E" "s" "seqt" "seqp" "l" "n - length(preseq)" "n - length(preseq) + 1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (expand "fseq_p") (("2" (expand "fseq_t") (("2" (skeep :preds? t) (("2" (inst? -6) (("1" (flatten) (("1" (assert) (("1" (expand "fseq_p") (("1" (expand "l_seq") (("1" (hide -3) (("1" (lemma "argument_protected_in_non_nth_index") (("1" (inst -1 "E" "s" "seqt" "seqp" "l" "1 + nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq)) + n!1") (("1" (prop) (("1" (assert) (("1" (expand "arg_rest?") (("1" (inst? -10) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst 2 "n - length(preseq)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "finseq_appl") (("2" (expand "fseq_t") (("2" (inst? -10) (("2" (expand "rest?") (("2" (flatten) (("2" (hide-all-but (-5 -6 -10 1)) (("2" (use "non_root_ir_preserves_root_symbol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (hide-all-but 1) (("3" (expand "fseq_p") (("3" (expand "l_seq") (("3" (lemma "nth_index_increasing") (("3" (inst -1 "E" "s" "seqt" "seqp" "l" "n - length(preseq)" "n - length(preseq) + 1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) (("4" (hide-all-but (-4 -7 -10 1)) (("4" (lemma "nth_index_increasing") (("4" (expand "fseq_t") (("4" (expand "l_seq") (("4" (inst -1 "E" "s" "seqt" "seqp" "l" "n - length(preseq)" "n - length(preseq) + 1") (("1" (assert) (("1" (expand "empty_seq") (("1" (expand "finseq_appl") (("1" (name-replace "idx" "1 + nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq))") (("1" (inst -2 "idx") (("1" (flatten) (("1" (hide-all-but (-3 1)) (("1" (use "reducible_is_app") (("1" (assert) (("1" (expand "reducible?") (("1" (inst 1 "seqt(1 + idx)") (("1" (use "innermost_subset_reduction") (("1" (expand "subset?") (("1" (expand "member") (("1" (inst?) (("1" (assert) (("1" (expand "innermost_reduction?") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (inst? -2) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (inst? -3) (("3" (expand "rest?") (("3" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (assert) nil nil)) nil) ("3" (expand "l_seq") (("3" (lemma "nth_index_increasing") (("3" (inst -1 "E" "s" "seqt" "seqp" "l" "n - length(preseq)" "n - length(preseq) + 1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) (("3" (hide 3) (("3" (expand "nn") (("3" (case "1 - length(preseq) + n >= 0") (("1" (inst -7 "nth_index(E)(s)(seqt)(seqp)(l)(1 - length(preseq) + n)") (("1" (expand "rest?") (("1" (flatten) (("1" (hide-all-but (-1 -2 -3 -7 1)) (("1" (use "non_root_ir_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (expand "nn") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (case "i!1 - length(preseq) >= 0") (("1" (inst -12 "1 + nth_index(E)(s)(seqt)(seqp)(l)(i!1 - length(preseq))") (("1" (expand "rest?") (("1" (flatten) (("1" (hide-all-but (-1 -6 -7 -12 2)) (("1" (use "non_root_ir_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (assert) (("3" (hide-all-but (-11 2)) (("3" (expand "rest?") (("3" (skeep) (("3" (inst?) (("3" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-8 1)) (("4" (skeep*) (("4" (inst -1 "n") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "positions_of_arg") (("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst? -1) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (inst? -4) (("3" (expand "rest?") (("3" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst? -3) (("2" (expand "rest?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((noetherian? const-decl "bool" noetherian nil) (no_infinite_descending_sequence formula-decl nil well_foundedness orders) (pred type-eq-decl nil defined_types nil) (rest? const-decl "bool" restricted_reduction nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (term type-decl nil term_adt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (empty? const-decl "bool" sets nil) (exists_inf_red_arg_in_inf_nr_im_red formula-decl nil inn_dp_termination nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (seqt skolem-const-decl "sequence[term[variable, symbol, arity]]" inn_dp_termination nil) (s skolem-const-decl "term[variable, symbol, arity]" inn_dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (positions? type-eq-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (seqp skolem-const-decl "sequence[position[variable, symbol, arity]]" inn_dp_termination nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (finite_sequence type-eq-decl nil finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (<= const-decl "bool" reals nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (l skolem-const-decl "{l: posnat | l <= length(args(s))}" inn_dp_termination nil) (non_root_rtc_reduction_of_argument formula-decl nil innermost_reduction nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (i skolem-const-decl "nat" inn_dp_termination nil) (preseq skolem-const-decl "{seq: finseq[term[variable, symbol, arity]] | length(seq) = 1 + i}" inn_dp_termination nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (nth_index const-decl "nat" inn_dp_termination nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (n1th_index skolem-const-decl "nat" inn_dp_termination nil) (nn skolem-const-decl "int" inn_dp_termination nil) (l_seq skolem-const-decl "int" inn_dp_termination nil) (fseq_t skolem-const-decl "[# length: int, seq: [below[l_seq] -> term[variable, symbol, arity]] #]" inn_dp_termination nil) (fseq_p skolem-const-decl "[# length: int, seq: [below[l_seq] -> position[variable, symbol, arity]] #]" inn_dp_termination nil) (nth_index_increasing formula-decl nil inn_dp_termination nil) (fseq_p skolem-const-decl "[# length: int, seq: [below[l_seq] -> position[variable, symbol, arity]] #]" inn_dp_termination nil) (fseq_t skolem-const-decl "[# length: int, seq: [below[l_seq] -> term[variable, symbol, arity]] #]" inn_dp_termination nil) (l_seq skolem-const-decl "int" inn_dp_termination nil) (TRUE const-decl "bool" booleans nil) (/= const-decl "boolean" notequal nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (empty_0 formula-decl nil seq_extras structures) (seq_first_rest_1 formula-decl nil seq_extras structures) (reduction_fix? const-decl "bool" reduction nil) (pos_subterm_ax formula-decl nil subterm nil) (pos_subterm formula-decl nil subterm nil) (rhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (replace_distributivity formula-decl nil replacement nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (zeroth_index skolem-const-decl "nat" inn_dp_termination nil) (rest const-decl "finseq" seq_extras structures) (O const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (nonempty? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (choose const-decl "(p)" sets nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (posint nonempty-type-eq-decl nil integers nil) (arg_preservation_in_finite_reduction formula-decl nil innermost_reduction nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (fseq_t skolem-const-decl "[# length: posint,
   seq:
     [below[nth_index(E)(s)(seqt)(seqp)(l)(0) + 1] ->
        term[variable, symbol, arity]] #]" inn_dp_termination nil) (fseq_p skolem-const-decl "[# length: posint,
   seq:
     [below[nth_index(E)(s)(seqt)(seqp)(l)(0) + 1] ->
        position[variable, symbol, arity]] #]" inn_dp_termination nil) (argument_protected_in_non_nth_index formula-decl nil inn_dp_termination nil) (arg_rest? const-decl "bool" innermost_reduction nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (non_root_ir_preserves_root_symbol formula-decl nil innermost_reduction nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (subset? const-decl "bool" sets nil) (reducible? const-decl "bool" ars_terminology nil) (innermost_subset_reduction formula-decl nil innermost_reduction nil) (reducible_is_app formula-decl nil reduction nil) (positions_of_arg formula-decl nil positions nil) (non_root_ir_preserves_pos_args formula-decl nil innermost_reduction nil) (n skolem-const-decl "nat" inn_dp_termination nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (i!1 skolem-const-decl "nat" inn_dp_termination nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (subtermOF def-decl "term" subterm nil) (iterate_to_finseq formula-decl nil relations_closure nil) (IUnion const-decl "set[T]" indexed_sets nil) (terminating? const-decl "bool" noetherian nil) (sequence type-eq-decl nil sequences nil) (positions_of_inf_nr_reduction formula-decl nil inn_dp_termination nil) (mint_is_app formula-decl nil inn_dp_termination nil) (member const-decl "bool" sets nil) (descending? const-decl "bool" monotone_sequences orders) (converse const-decl "pred[[T2, T1]]" relation_defs nil)) nil) (mint_is_nr_inn_terminating-2 nil 3785696057 ("" (skeep) (("" (expand "noetherian?") (("" (expand "converse") (("" (rewrite "no_infinite_descending_sequence") (("" (expand "descending?") (("" (expand "empty?") (("" (expand "member") (("" (skolem 1 "seqt") (("" (use "mint_is_app") (("" (assert) (("" (use "positions_of_inf_nr_reduction") (("" (prop) (("1" (skeep) (("1" (use "exists_inf_red_arg_in_inf_nr_im_red") (("1" (skeep :preds? t) (("1" (expand "minimal_innermost_non_terminating?") (("1" (flatten) (("1" (inst -6 "#(l)") (("1" (expand "terminating?") (("1" (inst-cp -7 "0") (("1" (expand "rest?" -8) (("1" (flatten) (("1" (hide -9 -10) (("1" (lemma "non_root_rtc_reduction_of_argument") (("1" (inst -1 "E" "seqt(0)" "s") (("1" (assert) (("1" (inst -1 "l") (("1" (expand "RTC" -1) (("1" (expand "IUnion") (("1" (skeep) (("1" (use "iterate_to_finseq") (("1" (assert) (("1" (expand "finseq_appl") (("1" (skolem -1 "preseq") (("1" (flatten) (("1" (inst 1 "LAMBDA(i: nat): IF i < length(preseq) THEN preseq(i) ELSE subtermOF(seqt(nth_index(E)(s)(seqt)(seqp)(l)(i - length(preseq)) + 1), #(l)) ENDIF") (("1" (expand "finseq_appl") (("1" (assert) (("1" (skeep) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (inst? -5) (("1" (assert) nil))) ("2" (case-replace "n = length(preseq) - 1") (("1" (assert) (("1" (replaces -4) (("1" (hide -1 -2 -3 -4 -5 -8 1) (("1" (case-replace "subtermOF(seqt(0),  #(l)) = subtermOF(seqt(nth_index(E)(s)(seqt)(seqp)(l)(0)), #(l))" :hide? t) (("1" (name-replace "zeroth_index" "nth_index(E)(s)(seqt)(seqp)(l)(0)") (("1" (inst -3 "zeroth_index") (("1" (flatten) (("1" (case "first(seqp(zeroth_index)) = l") (("1" (case " #(l) o rest(seqp(zeroth_index)) = seqp(zeroth_index)") (("1" (expand "innermost_reduction_fix?") (("1" (flatten) (("1" (expand "reduction_fix?") (("1" (skeep) (("1" (expand "innermost_reduction?") (("1" (inst 1 "rest(seqp(zeroth_index))") (("1" (expand "innermost_reduction_fix?") (("1" (expand "reduction_fix?") (("1" (lemma "pos_subterm") (("1" (inst -1 " #(l)" "rest(seqp(zeroth_index))" "seqt(zeroth_index)") (("1" (assert) (("1" (inst? 1) (("1" (assert) (("1" (use "replace_distributivity") (("1" (assert) nil))))))))))))))))) ("2" (use "pos_subterm_ax") (("2" (assert) nil))))))))))))))) ("2" (hide -5 -7 -8 2) (("2" (use "seq_first_rest_1[posnat]") (("2" (assert) (("2" (hide-all-but (1 3)) (("2" (lemma "empty_0[posnat]") (("2" (inst?) (("2" (assert) nil))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "zeroth_index") (("2" (expand "nth_index") (("2" (expand "args_of_pos_seq") (("2" (with-tccs (typepred "choose({m: nat |
                                                                                                                                                                                                                                                                         first(seqp(m)) = l AND
                                                                                                                                                                                                                                                                          card({k: nat | first(seqp(k)) = l AND k < m})
                                                                                                                                                                                                                                                                           = n})")) (("1" (assert) nil) ("2" (assert) nil))))))))))) ("3" (hide-all-but (1 3)) (("3" (use "empty_0[posnat]") (("3" (assert) nil))))))))))))) ("2" (hide 2) (("2" (name "fseq_t" "(#length := nth_index(E)(s)(seqt)(seqp)(l)(0) + 1, seq := LAMBDA(i:below[nth_index(E)(s)(seqt)(seqp)(l)(0)+1]): seqt(i) #)") (("2" (name "fseq_p" "(#length := nth_index(E)(s)(seqt)(seqp)(l)(0) + 1, seq := LAMBDA(i:below[nth_index(E)(s)(seqt)(seqp)(l)(0)+1]): seqp(i) #)") (("2" (lemma "arg_preservation_in_finite_reduction") (("2" (expand "finseq_appl") (("2" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (prop) (("1" (inst -1 "nth_index(E)(s)(seqt)(seqp)(l)(0)") (("1" (expand "fseq_t") (("1" (propax) nil))) ("2" (expand "fseq_p") (("2" (assert) nil))))) ("2" (skeep) (("2" (expand "fseq_t") (("2" (expand "fseq_p") (("2" (hide -1 -2) (("2" (inst -3 "n!1") (("2" (flatten) (("2" (assert) (("2" (typepred "n!1") (("2" (expand "fseq_p") (("2" (hide 1) (("2" (use "argument_protected_in_non_nth_index") (("2" (prop) (("2" (expand "arg_rest?") (("2" (expand "rest?") (("2" (inst -9 "n!1") nil))))))))))))))))))))))))))))))) ("2" (expand "finseq_appl") (("2" (hide-all-but (-3 -4 -8 1)) (("2" (expand "fseq_t") (("2" (expand "rest?") (("2" (inst?) (("2" (flatten) (("2" (use "non_root_ir_preserves_root_symbol") (("2" (assert) nil))))))))))))))) ("3" (hide-all-but (-1 -2 1)) (("3" (grind) nil))) ("4" (hide-all-but (-5 1)) (("4" (expand "fseq_t") (("4" (expand "finseq_appl") (("4" (expand "empty_seq") (("4" (inst?) (("4" (flatten) (("4" (use "reducible_is_app") (("4" (assert) (("4" (use "innermost_subset_reduction") (("4" (expand "subset?") (("4" (expand "member") (("4" (expand "reducible?") (("4" (inst 1 "seqt(1)") (("4" (inst?) (("4" (assert) (("4" (expand "innermost_reduction?") (("4" (inst?) nil))))))))))))))))))))))))))))))))))))))))))))) ("3" (inst -6 "nth_index(E)(s)(seqt)(seqp)(l)(0)") (("3" (expand "rest?") (("3" (flatten) (("3" (hide-all-but (-1 -2 -6 1)) (("3" (use "non_root_ir_preserves_pos_args") (("1" (assert) nil) ("2" (rewrite "positions_of_arg") nil))))))))))))))))))) ("2" (assert) nil))) ("3" (hide -1 -2 -3 -4 -7) (("3" (case-replace "1 - length(preseq) + n = n - length(preseq) + 1") (("1" (name-replace "nn" "n - length(preseq)") (("1" (hide -1) (("1" (with-tccs (case-replace "subtermOF(seqt(1 + nth_index(E)(s)(seqt)(seqp)(l)(nn)), #(l)) = subtermOF(seqt(nth_index(E)(s)(seqt)(seqp)(l)(nn + 1)), #(l)) " :hide? t)) (("1" (with-tccs (name-replace "n1th_index" "nth_index
                                                                                                                                                                                                        (E)(s)(seqt)(seqp)(l)(nn + 1)")) (("1" (inst -3 "n1th_index") (("1" (flatten) (("1" (case "first(seqp(n1th_index)) = l") (("1" (case " #(l) o rest(seqp(n1th_index)) = seqp(n1th_index)") (("1" (expand "innermost_reduction_fix?") (("1" (flatten) (("1" (expand "reduction_fix?") (("1" (skeep) (("1" (expand "innermost_reduction?") (("1" (inst 2 "rest(seqp(n1th_index))") (("1" (expand "innermost_reduction_fix?") (("1" (expand "reduction_fix?") (("1" (lemma "pos_subterm") (("1" (inst -1 " #(l)" "rest(seqp(n1th_index))" "seqt(n1th_index)") (("1" (assert) (("1" (inst? 2) (("1" (assert) (("1" (use "replace_distributivity") (("1" (assert) nil))))))))))))))))) ("2" (use "pos_subterm_ax") (("2" (assert) nil))))))))))))))) ("2" (hide -5 -7 -8 -9 3) (("2" (use "seq_first_rest_1[posnat]") (("2" (assert) (("2" (hide-all-but (1 4)) (("2" (lemma "empty_0[posnat]") (("2" (inst?) (("2" (assert) nil))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "n1th_index") (("2" (expand "nth_index") (("2" (expand "args_of_pos_seq") (("2" (with-tccs (typepred "choose({m: nat |
                                                                                                                                                                                                                                 first(seqp(m)) = l AND
                                                                                                                                                                                                                                  card({k: nat | first(seqp(k)) = l AND k < m})
                                                                                                                                                                                                                                   = 1 + nn})")) nil))))))))) ("3" (hide-all-but (1 4)) (("3" (use "empty_0[posnat]") (("3" (assert) nil))))))))))))) ("2" (hide 3) (("2" (expand "nn") (("2" (case-replace "1 - length(preseq) + n = n - length(preseq) + 1") (("1" (case-replace "length(preseq) = n") (("1" (assert) (("1" (name "l_seq" "nth_index(E)(s)(seqt)(seqp)(l)(1) - nth_index(E)(s)(seqt)(seqp)(l)(0)") (("1" (name "fseq_t" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqt(i + 1 + nth_index(E)(s)(seqt)(seqp)(l)(0)) #)") (("1" (name "fseq_p" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqp(i + 1 + nth_index(E)(s)(seqt)(seqp)(l)(0)) #)") (("1" (lemma "arg_preservation_in_finite_reduction") (("1" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (expand "finseq_appl") (("1" (prop) (("1" (expand "fseq_t") (("1" (inst -1 "l_seq - 1") (("1" (expand "l_seq") (("1" (propax) nil))) ("2" (expand "l_seq") (("2" (assert) (("2" (lemma "nth_index_increasing") (("2" (inst -1 "E" "s" "seqt" "seqp" "l" "0" "1") (("2" (assert) nil))))))))))))) ("2" (hide -1 -2) (("2" (expand "fseq_p") (("2" (expand "fseq_t") (("2" (skeep :preds? t) (("2" (inst? -7) (("2" (flatten) (("2" (assert) (("2" (expand "fseq_p") (("2" (expand "l_seq") (("2" (hide -3) (("2" (lemma "argument_protected_in_non_nth_index") (("2" (inst -1 "E" "s" "seqt" "seqp" "l" "1 + nth_index(E)(s)(seqt)(seqp)(l)(0) + n!1") (("2" (prop) (("1" (assert) (("1" (expand "arg_rest?") (("1" (inst? -11) (("1" (assert) nil))))))) ("2" (inst 2 "0") (("2" (assert) nil))))))))))))))))))))))))))))))))) ("2" (assert) (("2" (expand "finseq_appl") (("2" (expand "fseq_t") (("2" (inst? -11) (("2" (expand "rest?") (("2" (flatten) (("2" (hide-all-but (-6 -7 -11 1)) (("2" (use "non_root_ir_preserves_root_symbol") (("2" (assert) nil))))))))))))))))) ("3" (hide-all-but (-1 -2 1)) (("3" (expand "fseq_p") (("3" (expand "l_seq") (("3" (assert) (("3" (hide -) (("3" (lemma "nth_index_increasing") (("3" (inst -1 "E" "s" "seqt" "seqp" "l" "0" "1") (("3" (assert) nil))))))))))))))) ("4" (hide-all-but (-1 -2 -8 1)) (("4" (expand "fseq_t") (("4" (expand "l_seq") (("4" (lemma "nth_index_increasing") (("4" (inst -1 "E" "s" "seqt" "seqp" "l" "0" "1") (("4" (assert) (("4" (expand "empty_seq") (("4" (expand "finseq_appl") (("4" (name-replace "idx" "1 + nth_index(E)(s)(seqt)(seqp)(l)(0)") (("4" (inst -3 "idx") (("4" (flatten) (("4" (hide-all-but (-4 1)) (("4" (use "reducible_is_app") (("4" (assert) (("4" (expand "reducible?") (("4" (inst 1 "seqt(1 + idx)") (("4" (use "innermost_subset_reduction") (("4" (expand "subset?") (("4" (expand "member") (("4" (inst?) (("4" (assert) (("4" (expand "innermost_reduction?") (("4" (inst?) nil))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (expand "l_seq") (("2" (lemma "nth_index_increasing") (("2" (inst -1 "E" "s" "seqt" "seqp" "l" "0" "1") (("2" (assert) nil))))))))))))) ("2" (with-tccs (name "l_seq" "nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq) + 1) - nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq))") :tcc-step (skip)) (("1" (name "fseq_t" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqt(i + 1 + nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq))) #)") (("1" (name "fseq_p" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqp(i + 1 + nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq))) #)") (("1" (lemma "arg_preservation_in_finite_reduction") (("1" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (expand "finseq_appl") (("1" (prop) (("1" (expand "fseq_t") (("1" (inst -1 "l_seq - 1") (("1" (expand "l_seq") (("1" (assert) nil))) ("2" (expand "l_seq") (("2" (assert) (("2" (lemma "nth_index_increasing") (("2" (inst -1 "E" "s" "seqt" "seqp" "l" "n - length(preseq)" "n - length(preseq) + 1") (("2" (assert) nil))))))))))))) ("2" (hide -1 -2) (("2" (expand "fseq_p") (("2" (expand "fseq_t") (("2" (skeep :preds? t) (("2" (inst? -6) (("1" (flatten) (("1" (assert) (("1" (expand "fseq_p") (("1" (expand "l_seq") (("1" (hide -3) (("1" (lemma "argument_protected_in_non_nth_index") (("1" (inst -1 "E" "s" "seqt" "seqp" "l" "1 + nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq)) + n!1") (("1" (prop) (("1" (assert) (("1" (expand "arg_rest?") (("1" (inst? -10) (("1" (assert) nil))))))) ("2" (inst 2 "n - length(preseq)") (("2" (assert) nil))))))))))))))))))) ("2" (assert) nil))))))))))))))) ("2" (assert) (("2" (expand "finseq_appl") (("2" (expand "fseq_t") (("2" (inst? -10) (("2" (expand "rest?") (("2" (flatten) (("2" (hide-all-but (-5 -6 -10 1)) (("2" (use "non_root_ir_preserves_root_symbol") (("2" (assert) nil))))))))))))))))) ("3" (assert) (("3" (hide-all-but 1) (("3" (expand "fseq_p") (("3" (expand "l_seq") (("3" (lemma "nth_index_increasing") (("3" (inst -1 "E" "s" "seqt" "seqp" "l" "n - length(preseq)" "n - length(preseq) + 1") (("3" (assert) nil))))))))))))) ("4" (assert) (("4" (hide-all-but (-4 -7 -10 1)) (("4" (lemma "nth_index_increasing") (("4" (expand "fseq_t") (("4" (expand "l_seq") (("4" (inst -1 "E" "s" "seqt" "seqp" "l" "n - length(preseq)" "n - length(preseq) + 1") (("1" (assert) (("1" (expand "empty_seq") (("1" (expand "finseq_appl") (("1" (name-replace "idx" "1 + nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq))") (("1" (inst -2 "idx") (("1" (flatten) (("1" (hide-all-but (-3 1)) (("1" (use "reducible_is_app") (("1" (assert) (("1" (expand "reducible?") (("1" (inst 1 "seqt(1 + idx)") (("1" (use "innermost_subset_reduction") (("1" (expand "subset?") (("1" (expand "member") (("1" (inst?) (("1" (assert) (("1" (expand "innermost_reduction?") (("1" (inst?) nil))))))))))))))))))))))))))))))))))) ("2" (hide 2) (("2" (skeep) (("2" (inst? -2) (("2" (flatten) (("2" (assert) nil))))))))) ("3" (hide 2) (("3" (skeep) (("3" (inst? -3) (("3" (expand "rest?") (("3" (flatten) nil))))))))))))))))))))))))))) ("2" (skeep :preds? t) (("2" (assert) nil))) ("3" (expand "l_seq") (("3" (lemma "nth_index_increasing") (("3" (inst -1 "E" "s" "seqt" "seqp" "l" "n - length(preseq)" "n - length(preseq) + 1") (("1" (assert) nil) ("2" (assert) nil) ("3" (assert) nil))))))))) ("2" (assert) nil))))) ("2" (assert) nil))))))) ("3" (assert) (("3" (hide 3) (("3" (expand "nn") (("3" (case "1 - length(preseq) + n >= 0") (("1" (inst -7 "nth_index(E)(s)(seqt)(seqp)(l)(1 - length(preseq) + n)") (("1" (expand "rest?") (("1" (flatten) (("1" (hide-all-but (-1 -2 -3 -7 1)) (("1" (use "non_root_ir_preserves_pos_args") (("1" (assert) nil) ("2" (rewrite "positions_of_arg") nil))))))))))) ("2" (assert) nil))))))))) ("4" (expand "nn") (("4" (assert) nil))))))))) ("2" (assert) nil))))))))))))))))))))))) ("2" (skeep) (("2" (case "i!1 - length(preseq) >= 0") (("1" (inst -12 "1 + nth_index(E)(s)(seqt)(seqp)(l)(i!1 - length(preseq))") (("1" (expand "rest?") (("1" (flatten) (("1" (hide-all-but (-1 -6 -7 -12 2)) (("1" (use "non_root_ir_preserves_pos_args") (("1" (assert) nil) ("2" (rewrite "positions_of_arg") nil))))))))))) ("2" (assert) nil))))) ("3" (skeep) (("3" (assert) (("3" (hide-all-but (-11 2)) (("3" (expand "rest?") (("3" (skeep) (("3" (inst?) (("3" (flatten) nil))))))))))))) ("4" (hide-all-but (-8 1)) (("4" (skeep*) (("4" (inst -1 "n") (("4" (flatten) (("4" (assert) nil))))))))) ("5" (skeep) (("5" (assert) nil))))))))))))))))))))))))))))))))))))))) ("2" (rewrite "positions_of_arg") (("2" (hide-all-but -1) (("2" (grind) nil))))))))))))) ("2" (skeep) (("2" (inst? -1) (("2" (flatten) (("2" (assert) nil))))))) ("3" (skeep) (("3" (inst? -4) (("3" (expand "rest?") (("3" (flatten) nil))))))))))) ("2" (skeep) (("2" (inst? -3) (("2" (expand "rest?") (("2" (flatten) (("2" (assert) nil)))))))))))))))))))))))))))))))) nil) nil nil) (mint_is_nr_inn_terminating-1 nil 3761501941 ("" (skeep) (("" (expand "noetherian?") (("" (expand "converse") (("" (rewrite "no_infinite_descending_sequence") (("" (expand "descending?") (("" (expand "empty?") (("" (expand "member") (("" (skolem 1 "seqt") (("" (use "mint_is_app") (("" (assert) (("" (use "positions_of_inf_nr_reduction") (("" (prop) (("1" (skeep) (("1" (use "exists_inf_red_arg_in_inf_nr_im_red") (("1" (skeep :preds? t) (("1" (expand "minimal_innermost_non_terminating?") (("1" (flatten) (("1" (inst -6 "#(l)") (("1" (expand "terminating?") (("1" (inst-cp -7 "0") (("1" (expand "rest?" -8) (("1" (flatten) (("1" (hide -9 -10) (("1" (lemma "non_root_rtc_reduction_of_argument") (("1" (inst -1 "E" "seqt(0)" "s") (("1" (assert) (("1" (inst -1 "l") (("1" (expand "RTC" -1) (("1" (expand "IUnion") (("1" (skeep) (("1" (use "iterate_to_finseq") (("1" (assert) (("1" (expand "finseq_appl") (("1" (skolem -1 "preseq") (("1" (flatten) (("1" (inst 1 "LAMBDA(i: nat): IF i < length(preseq) THEN preseq(i) ELSE subtermOF(seqt(nth_index(E)(s)(seqt)(seqp)(l)(i - length(preseq)) + 1), #(l)) ENDIF") (("1" (expand "finseq_appl") (("1" (assert) (("1" (skeep) (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (inst? -5) (("1" (assert) nil nil)) nil) ("2" (case-replace "n = length(preseq) - 1") (("1" (assert) (("1" (replaces -4) (("1" (hide -1 -2 -3 -4 -5 -8 1) (("1" (case-replace "subtermOF(seqt(0),  #(l)) = subtermOF(seqt(nth_index(E)(s)(seqt)(seqp)(l)(0)), #(l))" :hide? t) (("1" (name-replace "zeroth_index" "nth_index(E)(s)(seqt)(seqp)(l)(0)") (("1" (inst -3 "zeroth_index") (("1" (flatten) (("1" (case "first(seqp(zeroth_index)) = l") (("1" (case " #(l) o rest(seqp(zeroth_index)) = seqp(zeroth_index)") (("1" (expand "innermost_reduction_fix?") (("1" (flatten) (("1" (expand "reduction_fix?") (("1" (skeep) (("1" (expand "innermost_reduction?") (("1" (inst 1 "rest(seqp(zeroth_index))") (("1" (expand "innermost_reduction_fix?") (("1" (expand "reduction_fix?") (("1" (lemma "pos_subterm") (("1" (inst -1 " #(l)" "rest(seqp(zeroth_index))" "seqt(zeroth_index)") (("1" (assert) (("1" (inst? 1) (("1" (assert) (("1" (use "replace_distributivity") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "pos_subterm_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 -7 -8 2) (("2" (use "seq_first_rest_1[posnat]") (("2" (assert) (("2" (hide-all-but (1 3)) (("2" (lemma "empty_0[posnat]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "zeroth_index") (("2" (expand "nth_index") (("2" (expand "args_of_pos_seq") (("2" (with-tccs (typepred "choose({m: nat |
                                                                                                                                                                                                                                                      first(seqp(m)) = l AND
                                                                                                                                                                                                                                                       card({k: nat | first(seqp(k)) = l AND k < m})
                                                                                                                                                                                                                                                        = n})")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 3)) (("3" (use "empty_0[posnat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (name "fseq_t" "(#length := nth_index(E)(s)(seqt)(seqp)(l)(0) + 1, seq := LAMBDA(i:below[nth_index(E)(s)(seqt)(seqp)(l)(0)+1]): seqt(i) #)") (("2" (name "fseq_p" "(#length := nth_index(E)(s)(seqt)(seqp)(l)(0) + 1, seq := LAMBDA(i:below[nth_index(E)(s)(seqt)(seqp)(l)(0)+1]): seqp(i) #)") (("2" (lemma "arg_preservation_in_finite_reduction") (("2" (expand "finseq_appl") (("2" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (prop) (("1" (inst -1 "nth_index(E)(s)(seqt)(seqp)(l)(0)") (("1" (expand "fseq_t") (("1" (propax) nil nil)) nil) ("2" (expand "fseq_p") (("2" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (expand "fseq_t") (("2" (expand "fseq_p") (("2" (hide -1 -2) (("2" (inst -3 "n!1") (("2" (flatten) (("2" (assert) (("2" (typepred "n!1") (("2" (expand "fseq_p") (("2" (hide 1) (("2" (use "argument_protected_in_non_nth_index") (("2" (prop) (("2" (expand "arg_rest?") (("2" (expand "rest?") (("2" (inst -9 "n!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (hide-all-but (-3 -4 -8 1)) (("2" (expand "fseq_t") (("2" (expand "rest?") (("2" (inst?) (("2" (flatten) (("2" (use "non_root_ir_preserves_root_symbol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2 1)) (("3" (grind) nil nil)) nil) ("4" (hide-all-but (-5 1)) (("4" (expand "fseq_t") (("4" (expand "finseq_appl") (("4" (expand "empty_seq") (("4" (inst?) (("4" (flatten) (("4" (use "reducible_is_app") (("4" (assert) (("4" (use "innermost_subset_reduction") (("4" (expand "subset?") (("4" (expand "member") (("4" (expand "reducible?") (("4" (inst 1 "seqt(1)") (("4" (inst?) (("4" (assert) (("4" (expand "innermost_reduction?") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -6 "nth_index(E)(s)(seqt)(seqp)(l)(0)") (("3" (expand "rest?") (("3" (flatten) (("3" (hide-all-but (-1 -2 -6 1)) (("3" (use "non_root_ir_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (hide -1 -2 -3 -4 -7) (("3" (case-replace "1 - length(preseq) + n = n - length(preseq) + 1") (("1" (name-replace "nn" "n - length(preseq)") (("1" (hide -1) (("1" (with-tccs (case-replace "subtermOF(seqt(1 + nth_index(E)(s)(seqt)(seqp)(l)(nn)), #(l)) = subtermOF(seqt(nth_index(E)(s)(seqt)(seqp)(l)(nn + 1)), #(l)) " :hide? t)) (("1" (with-tccs (name-replace "n1th_index" "nth_index
                                                                                                                                                                                       (E)(s)(seqt)(seqp)(l)(nn + 1)")) (("1" (inst -3 "n1th_index") (("1" (flatten) (("1" (case "first(seqp(n1th_index)) = l") (("1" (case " #(l) o rest(seqp(n1th_index)) = seqp(n1th_index)") (("1" (expand "innermost_reduction_fix?") (("1" (flatten) (("1" (expand "reduction_fix?") (("1" (skeep) (("1" (expand "innermost_reduction?") (("1" (inst 2 "rest(seqp(n1th_index))") (("1" (expand "innermost_reduction_fix?") (("1" (expand "reduction_fix?") (("1" (lemma "pos_subterm") (("1" (inst -1 " #(l)" "rest(seqp(n1th_index))" "seqt(n1th_index)") (("1" (assert) (("1" (inst? 2) (("1" (assert) (("1" (use "replace_distributivity") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "pos_subterm_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -5 -7 -8 -9 3) (("2" (use "seq_first_rest_1[posnat]") (("2" (assert) (("2" (hide-all-but (1 4)) (("2" (lemma "empty_0[posnat]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n1th_index") (("2" (expand "nth_index") (("2" (expand "args_of_pos_seq") (("2" (with-tccs (typepred "choose({m: nat |
                                                                                                                                                                                                              first(seqp(m)) = l AND
                                                                                                                                                                                                               card({k: nat | first(seqp(k)) = l AND k < m})
                                                                                                                                                                                                                = 1 + nn})")) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 4)) (("3" (use "empty_0[posnat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "nn") (("2" (case-replace "1 - length(preseq) + n = n - length(preseq) + 1") (("1" (case-replace "length(preseq) = n") (("1" (assert) (("1" (name "l_seq" "nth_index(E)(s)(seqt)(seqp)(l)(1) - nth_index(E)(s)(seqt)(seqp)(l)(0)") (("1" (name "fseq_t" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqt(i + 1 + nth_index(E)(s)(seqt)(seqp)(l)(0)) #)") (("1" (name "fseq_p" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqp(i + 1 + nth_index(E)(s)(seqt)(seqp)(l)(0)) #)") (("1" (lemma "arg_preservation_in_finite_reduction") (("1" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (expand "finseq_appl") (("1" (prop) (("1" (expand "fseq_t") (("1" (inst -1 "l_seq - 1") (("1" (expand "l_seq") (("1" (propax) nil nil)) nil) ("2" (expand "l_seq") (("2" (assert) (("2" (lemma "nth_index_increasing") (("2" (inst -1 "E" "s" "seqt" "seqp" "l" "0" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (expand "fseq_p") (("2" (expand "fseq_t") (("2" (skeep :preds? t) (("2" (inst? -7) (("2" (flatten) (("2" (assert) (("2" (expand "fseq_p") (("2" (expand "l_seq") (("2" (hide -3) (("2" (lemma "argument_protected_in_non_nth_index") (("2" (inst -1 "E" "s" "seqt" "seqp" "l" "1 + nth_index(E)(s)(seqt)(seqp)(l)(0) + n!1") (("2" (prop) (("1" (assert) (("1" (expand "arg_rest?") (("1" (inst? -11) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst 2 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "finseq_appl") (("2" (expand "fseq_t") (("2" (inst? -11) (("2" (expand "rest?") (("2" (flatten) (("2" (hide-all-but (-6 -7 -11 1)) (("2" (use "non_root_ir_preserves_root_symbol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2 1)) (("3" (expand "fseq_p") (("3" (expand "l_seq") (("3" (assert) (("3" (hide -) (("3" (lemma "nth_index_increasing") (("3" (inst -1 "E" "s" "seqt" "seqp" "l" "0" "1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 -2 -8 1)) (("4" (expand "fseq_t") (("4" (expand "l_seq") (("4" (lemma "nth_index_increasing") (("4" (inst -1 "E" "s" "seqt" "seqp" "l" "0" "1") (("4" (assert) (("4" (expand "empty_seq") (("4" (expand "finseq_appl") (("4" (name-replace "idx" "1 + nth_index(E)(s)(seqt)(seqp)(l)(0)") (("4" (inst -3 "idx") (("4" (flatten) (("4" (hide-all-but (-4 1)) (("4" (use "reducible_is_app") (("4" (assert) (("4" (expand "reducible?") (("4" (inst 1 "seqt(1 + idx)") (("4" (use "innermost_subset_reduction") (("4" (expand "subset?") (("4" (expand "member") (("4" (inst?) (("4" (assert) (("4" (expand "innermost_reduction?") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "l_seq") (("2" (lemma "nth_index_increasing") (("2" (inst -1 "E" "s" "seqt" "seqp" "l" "0" "1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (with-tccs (name "l_seq" "nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq) + 1) - nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq))")) (("1" (name "fseq_t" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqt(i + 1 + nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq))) #)") (("1" (name "fseq_p" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqp(i + 1 + nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq))) #)") (("1" (lemma "arg_preservation_in_finite_reduction") (("1" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (expand "finseq_appl") (("1" (prop) (("1" (expand "fseq_t") (("1" (inst -1 "l_seq - 1") (("1" (expand "l_seq") (("1" (assert) nil nil)) nil) ("2" (expand "l_seq") (("2" (assert) (("2" (lemma "nth_index_increasing") (("2" (inst -1 "E" "s" "seqt" "seqp" "l" "n - length(preseq)" "n - length(preseq) + 1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (expand "fseq_p") (("2" (expand "fseq_t") (("2" (skeep :preds? t) (("2" (inst? -6) (("1" (flatten) (("1" (assert) (("1" (expand "fseq_p") (("1" (expand "l_seq") (("1" (hide -3) (("1" (lemma "argument_protected_in_non_nth_index") (("1" (inst -1 "E" "s" "seqt" "seqp" "l" "1 + nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq)) + n!1") (("1" (prop) (("1" (assert) (("1" (expand "arg_rest?") (("1" (inst? -10) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst 2 "n - length(preseq)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "finseq_appl") (("2" (expand "fseq_t") (("2" (inst? -10) (("2" (expand "rest?") (("2" (flatten) (("2" (hide-all-but (-5 -6 -10 1)) (("2" (use "non_root_ir_preserves_root_symbol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (hide-all-but 1) (("3" (expand "fseq_p") (("3" (expand "l_seq") (("3" (lemma "nth_index_increasing") (("3" (inst -1 "E" "s" "seqt" "seqp" "l" "n - length(preseq)" "n - length(preseq) + 1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) (("4" (hide-all-but (-4 -7 -10 1)) (("4" (lemma "nth_index_increasing") (("4" (expand "fseq_t") (("4" (expand "l_seq") (("4" (inst -1 "E" "s" "seqt" "seqp" "l" "n - length(preseq)" "n - length(preseq) + 1") (("1" (assert) (("1" (expand "empty_seq") (("1" (expand "finseq_appl") (("1" (name-replace "idx" "1 + nth_index(E)(s)(seqt)(seqp)(l)(n - length(preseq))") (("1" (inst -2 "idx") (("1" (flatten) (("1" (hide-all-but (-3 1)) (("1" (use "reducible_is_app") (("1" (assert) (("1" (expand "reducible?") (("1" (inst 1 "seqt(1 + idx)") (("1" (use "innermost_subset_reduction") (("1" (expand "subset?") (("1" (expand "member") (("1" (inst?) (("1" (assert) (("1" (expand "innermost_reduction?") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (inst? -2) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (inst? -3) (("3" (expand "rest?") (("3" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (assert) nil nil)) nil) ("3" (expand "l_seq") (("3" (lemma "nth_index_increasing") (("3" (inst -1 "E" "s" "seqt" "seqp" "l" "n - length(preseq)" "n - length(preseq) + 1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) (("3" (hide 3) (("3" (expand "nn") (("3" (case "1 - length(preseq) + n >= 0") (("1" (inst -7 "nth_index(E)(s)(seqt)(seqp)(l)(1 - length(preseq) + n)") (("1" (expand "rest?") (("1" (flatten) (("1" (hide-all-but (-1 -2 -3 -7 1)) (("1" (use "non_root_ir_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (expand "nn") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (case "i!1 - length(preseq) >= 0") (("1" (inst -12 "1 + nth_index(E)(s)(seqt)(seqp)(l)(i!1 - length(preseq))") (("1" (expand "rest?") (("1" (flatten) (("1" (hide-all-but (-1 -6 -7 -12 2)) (("1" (use "non_root_ir_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (assert) (("3" (hide-all-but (-11 2)) (("3" (expand "rest?") (("3" (skeep) (("3" (inst?) (("3" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-8 1)) (("4" (skeep*) (("4" (inst -1 "n") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "positions_of_arg") (("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst? -1) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (inst? -4) (("3" (expand "rest?") (("3" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst? -3) (("2" (expand "rest?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((noetherian? const-decl "bool" noetherian nil) (no_infinite_descending_sequence formula-decl nil well_foundedness orders) (rest? const-decl "bool" restricted_reduction nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (term type-decl nil term_adt nil) (empty? const-decl "bool" sets nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (positions? type-eq-decl nil positions nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (finite_sequence type-eq-decl nil finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (non_root_rtc_reduction_of_argument formula-decl nil innermost_reduction nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (empty_0 formula-decl nil seq_extras structures) (seq_first_rest_1 formula-decl nil seq_extras structures) (reduction_fix? const-decl "bool" reduction nil) (pos_subterm_ax formula-decl nil subterm nil) (pos_subterm formula-decl nil subterm nil) (rhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (replace_distributivity formula-decl nil replacement nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (rest const-decl "finseq" seq_extras structures) (O const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (choose const-decl "(p)" sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (nonempty? const-decl "bool" sets nil) (arg_preservation_in_finite_reduction formula-decl nil innermost_reduction nil) (non_root_ir_preserves_root_symbol formula-decl nil innermost_reduction nil) (subset? const-decl "bool" sets nil) (reducible? const-decl "bool" ars_terminology nil) (innermost_subset_reduction formula-decl nil innermost_reduction nil) (reducible_is_app formula-decl nil reduction nil) (positions_of_arg formula-decl nil positions nil) (non_root_ir_preserves_pos_args formula-decl nil innermost_reduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (subtermOF def-decl "term" subterm nil) (iterate_to_finseq formula-decl nil relations_closure nil) (terminating? const-decl "bool" noetherian nil) (member const-decl "bool" sets nil) (descending? const-decl "bool" monotone_sequences orders)) nil)) (reductions_below_min_root_are_non_root_TCC1 0 (reductions_below_min_root_are_non_root_TCC1-2 nil 3761500464 ("" (skeep :preds? t) (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (skeep) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ((nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (empty? const-decl "bool" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (reductions_below_min_root_are_non_root subtype "{i: naturalnumbers.nat | (booleans.NOT)(restricted_reduction[term_adt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].term].rest?(innermost_reduction[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].non_root_innermost_reduction?(inn_dp_termination.E), inn_dp_termination.seq(0))(inn_dp_termination.seq(i), inn_dp_termination.seq((number_fields.+)(i, 1))))}" "(sets[nat].nonempty?)")) (reductions_below_min_root_are_non_root_TCC1-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (reductions_below_min_root_are_non_root subtype "{i: naturalnumbers.nat | (booleans.NOT)(restricted_reduction[term_adt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].term].rest?(innermost_reduction[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].non_root_innermost_reduction?(inn_dp_termination.E), inn_dp_termination.seq(0))(inn_dp_termination.seq(i), inn_dp_termination.seq((number_fields.+)(i, 1))))}" "(sets[nat].nonempty?)"))) (reductions_below_min_root_are_non_root 0 (reductions_below_min_root_are_non_root-1 nil 3761501897 ("" (skeep :preds? t) (("" (typepred "min({i: nat |
                NOT rest?(non_root_innermost_reduction?(E), seq(0))
                         (seq(i), seq(1 + i))})") (("1" (replace -3 -1 rl) (("1" (case-replace "j=0") (("1" (skeep :preds? t) (("1" (assert) nil nil)) nil) ("2" (induct "k" 3) (("1" (typepred "k!1") (("1" (propax) nil nil)) nil) ("2" (typepred "k!1") (("2" (propax) nil nil)) nil) ("3" (assert) nil nil) ("4" (skeep) (("4" (lemma "iterate_add") (("4" (inst -1 "non_root_innermost_reduction?(E)" "j_1" "1") (("4" (replaces -1) (("4" (expand "o") (("4" (inst 1 "seq(j_1)") (("4" (assert) (("4" (prop) (("1" (assert) (("1" (inst -4 "j_1") (("1" (prop) (("1" (assert) nil nil) ("2" (expand "rest?" -1) (("2" (prop) (("2" (expand "iterate" 1) (("2" (expand "o") (("2" (inst 1 "seq(j_1)") (("2" (assert) (("2" (expand "iterate") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j_1") (("2" (case-replace "j_1=0") (("1" (expand "iterate" 1) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (assert) (("3" (expand "rest?" -5) (("3" (expand "iterate" 1) (("3" (expand "o") (("3" (inst 1 "seq(j_1)") (("3" (prop) (("1" (expand "iterate" 1) (("1" (propax) nil nil)) nil) ("2" (typepred "j_1") (("2" (case-replace "j_1=0") (("1" (assert) (("1" (inst -5 0) (("1" (assert) (("1" (expand "rest?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (skeep) (("2" (skeep -2) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (sequence type-eq-decl nil sequences nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rest? const-decl "bool" restricted_reduction nil) (pred type-eq-decl nil defined_types nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (O const-decl "bool" relation_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (iterate_add formula-decl nil relation_iterate orders) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat_induction formula-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (iterate def-decl "pred[[T, T]]" relation_iterate orders) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil)) (inf_inn_deriv_of_mint_has_min_root_reduction_index_TCC1 0 (inf_inn_deriv_of_mint_has_min_root_reduction_index_TCC1-2 nil 3761501157 ("" (skeep* :preds? t) (("" (rewrite "empty_seq_is_position") nil nil)) nil) ((empty_seq_is_position formula-decl nil positions nil) (term type-decl nil term_adt nil) (sequence type-eq-decl nil sequences nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (inf_inn_deriv_of_mint_has_min_root_reduction_index subtype "finite_sequences[posnat].empty_seq" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](inn_dp_termination.seq(inn_dp_termination.j))")) (inf_inn_deriv_of_mint_has_min_root_reduction_index_TCC1-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (inf_inn_deriv_of_mint_has_min_root_reduction_index subtype "finite_sequences[posnat].empty_seq" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](inn_dp_termination.seq(inn_dp_termination.j))"))) (inf_inn_deriv_of_mint_has_min_root_reduction_index_TCC2 0 (inf_inn_deriv_of_mint_has_min_root_reduction_index_TCC2-2 nil 3761500518 ("" (skeep* :preds? t) (("" (rewrite "empty_seq_is_position") nil nil)) nil) ((empty_seq_is_position formula-decl nil positions nil) (term type-decl nil term_adt nil) (sequence type-eq-decl nil sequences nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (inf_inn_deriv_of_mint_has_min_root_reduction_index subtype "finite_sequences[posnat].empty_seq" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](inn_dp_termination.seq(inn_dp_termination.k))")) (inf_inn_deriv_of_mint_has_min_root_reduction_index_TCC2-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (inf_inn_deriv_of_mint_has_min_root_reduction_index subtype "finite_sequences[posnat].empty_seq" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](inn_dp_termination.seq(inn_dp_termination.k))"))) (inf_inn_deriv_of_mint_has_min_root_reduction_index 0 (inf_inn_deriv_of_mint_has_min_root_reduction_index-1 nil 3761502005 ("" (skeep) (("" (lemma "non_noetherian_and_noetherian_rest_subset") (("" (inst -1 "innermost_reduction?(E)" "non_root_innermost_reduction?(E)" "seq(0)") (("" (split -1) (("1" (inst -1 "seq") (("1" (prop) (("1" (skeep) (("1" (name "min_i" "min({i:nat | NOT rest?(non_root_innermost_reduction?(E), seq(0))
                                                                                              (seq(i), seq(i + 1))})") (("1" (inst 2 "min_i") (("1" (prop) (("1" (hide 2) (("1" (inst -3 "min_i") (("1" (expand "innermost_reduction?") (("1" (skeep :preds? t) (("1" (typepred "min_i") (("1" (expand "rest?" 1) (("1" (prop) (("1" (expand "RTC" 1) (("1" (expand "IUnion") (("1" (case-replace "min_i = 0") (("1" (inst 1 "0") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil) ("2" (lemma "reductions_below_min_root_are_non_root") (("2" (inst -1 "E" "seq" "min_i" "min_i") (("1" (inst 2 "min_i") nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (hide-all-but (-4 1)) (("4" (use "mint_is_nr_inn_terminating") (("4" (assert) (("4" (expand "noetherian?") (("4" (rewrite "no_infinite_descending_sequence") (("4" (expand "empty?") (("4" (expand "member") (("4" (expand "descending?") (("4" (expand "converse") (("4" (inst -1 "seq") (("4" (skeep) (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "RTC") (("2" (expand "IUnion") (("2" (inst 1 "1 + min_i") (("2" (lemma "iterate_add") (("2" (inst -1 "non_root_innermost_reduction?(E)" "min_i" "1") (("2" (replaces -1) (("2" (expand "o") (("2" (inst 1 "seq(min_i)") (("2" (prop) (("1" (case-replace "min_i = 0") (("1" (hide-all-but 1) (("1" (expand "iterate") (("1" (propax) nil nil)) nil)) nil) ("2" (lemma "reductions_below_min_root_are_non_root") (("2" (inst -1 "E" "seq" "min_i" "min_i") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (hide-all-but (-4 1)) (("3" (use "mint_is_nr_inn_terminating") (("3" (assert) (("3" (expand "noetherian?") (("3" (rewrite "no_infinite_descending_sequence") (("3" (expand "empty?") (("3" (expand "member") (("3" (expand "descending?") (("3" (inst -1 "seq") (("3" (skeep) (("3" (expand "converse") (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "iterate" 1) (("2" (expand "o") (("2" (inst 1 "seq(min_i)") (("2" (expand "iterate" 1) (("2" (expand "non_root_innermost_reduction?" 1) (("2" (inst 1 "p") (("1" (expand "innermost_reduction_fix?") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "non_root_innermost_reduction?" 1) (("3" (inst 1 "p") (("1" (expand "innermost_reduction_fix?" (2 -5)) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "min_i") (("2" (skeep) (("2" (case "k < min_i") (("1" (inst -2 "k") (("1" (prop) (("1" (assert) nil nil) ("2" (expand "rest?" -1) (("2" (flatten) (("2" (expand "non_root_innermost_reduction?" -3) (("2" (skeep :preds? t) (("2" (expand "innermost_reduction_fix?" -7) (("2" (flatten) (("2" (rewrite "subterm_empty_seq") (("2" (hide-all-but (-1 -5 -7 1)) (("2" (rewrite* "nr_normal_form_subterms") (("2" (inst?) (("2" (assert) (("2" (expand "reduction_fix?") (("2" (skeep) (("2" (expand "is_normal_form?") (("2" (expand "reducible?") (("2" (inst 2 "ext(sigma)(rhs(e))") (("2" (replace -2 2) (("2" (expand "reduction?") (("2" (inst 2 "e" "sigma" "empty_seq") (("1" (rewrite "subterm_empty_seq") (("1" (expand "replaceTerm " 2) (("1" (rewrite "empty_0") nil nil)) nil)) nil) ("2" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -1 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "non_root_inn_subset_inn_reduction") nil nil) ("3" (use "mint_is_nr_inn_terminating") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (non_noetherian_and_noetherian_rest_subset formula-decl nil restricted_reduction nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (rest? const-decl "bool" restricted_reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (O const-decl "bool" relation_props nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (p skolem-const-decl "positions?[variable, symbol, arity](seq(min_i))" inn_dp_termination nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (below type-eq-decl nil nat_types nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (TRUE const-decl "bool" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (iterate_add formula-decl nil relation_iterate orders) (RTC const-decl "reflexive_transitive" relations_closure nil) (iterate def-decl "pred[[T, T]]" relation_iterate orders) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (seq skolem-const-decl "sequence[term[variable, symbol, arity]]" inn_dp_termination nil) (min_i skolem-const-decl "{a |
   NOT rest?(non_root_innermost_reduction?(E), seq(0))(seq(a), seq(1 + a))
    AND
    FORALL (x: nat):
      NOT rest?(non_root_innermost_reduction?(E), seq(0))
               (seq(x), seq(1 + x))
       IMPLIES a <= x}" inn_dp_termination nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (mint_is_nr_inn_terminating formula-decl nil inn_dp_termination nil) (noetherian? const-decl "bool" noetherian nil) (empty? const-decl "bool" sets nil) (descending? const-decl "bool" monotone_sequences orders) (member const-decl "bool" sets nil) (no_infinite_descending_sequence formula-decl nil well_foundedness orders) (converse const-decl "pred[[T2, T1]]" relation_defs nil) (reductions_below_min_root_are_non_root formula-decl nil inn_dp_termination nil) (IUnion const-decl "set[T]" indexed_sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (subterm_empty_seq formula-decl nil subterm nil) (nr_normal_form_subterms formula-decl nil innermost_reduction nil) (reducible? const-decl "bool" ars_terminology nil) (sigma skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (lhs const-decl "term" rewrite_rules nil) (e skolem-const-decl "{e | member(e, E)}" inn_dp_termination nil) (replaceTerm def-decl "term" replacement nil) (empty_0 formula-decl nil seq_extras structures) (empty_seq_is_position formula-decl nil positions nil) (reduction? const-decl "bool" reduction nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (ext def-decl "term" substitution nil) (rhs const-decl "term" rewrite_rules nil) (is_normal_form? const-decl "bool" ars_terminology nil) (reduction_fix? const-decl "bool" reduction nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (non_root_inn_subset_inn_reduction formula-decl nil innermost_reduction nil) (sequence type-eq-decl nil sequences nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (pred type-eq-decl nil defined_types nil)) nil)) (mint_reduces_to_int_nrnf_term 0 (mint_reduces_to_int_nrnf_term-1 nil 3761502042 ("" (skeep :preds? t) (("" (copy -1) (("" (expand "minimal_innermost_non_terminating?" -2) (("" (flatten) (("" (expand "terminating?" 1) (("" (skeep) (("" (use "inf_inn_deriv_of_mint_has_min_root_reduction_index") (("" (assert) (("" (prop) (("" (skeep) (("" (inst 1 "seq(j)") (("1" (prop) (("1" (replaces -4 :dir rl) (("1" (lemma "seq_of_relation_RTC[term]") (("1" (inst -1 "seq" "non_root_innermost_reduction?(E)" "0" "j") (("1" (assert) (("1" (hide -1 -3 -4 -5 2) (("1" (skeep) (("1" (inst -1 "k") (("1" (prop) (("1" (typepred "k") (("1" (assert) nil nil)) nil) ("2" (reveal -4) (("2" (inst -1 "k") (("2" (expand "non_root_innermost_reduction?") (("2" (expand "innermost_reduction?") (("2" (skeep) (("2" (case "p=empty_seq") (("1" (assert) nil nil) ("2" (inst 3 "p") (("2" (assert) (("2" (expand "innermost_reduction_fix?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "innermost_reduction_fix?") (("2" (assert) (("2" (rewrite "subterm_empty_seq") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -6)) (("2" (expand "terminating?") (("2" (inst 1 "LAMBDA (i: nat) : seq(j+i)") (("2" (assert) (("2" (skeep) (("2" (inst -1 "n+j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (seq_of_relation_RTC formula-decl nil relations_closure nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (p skolem-const-decl "positions?[variable, symbol, arity](seq(k))" inn_dp_termination nil) (k skolem-const-decl "{k: nat | k < j}" inn_dp_termination nil) (< const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (TRUE const-decl "bool" booleans nil) (subterm_empty_seq formula-decl nil subterm nil) (NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (seq skolem-const-decl "sequence[term[variable, symbol, arity]]" inn_dp_termination nil) (j skolem-const-decl "nat" inn_dp_termination nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (sequence type-eq-decl nil sequences nil) (inf_inn_deriv_of_mint_has_min_root_reduction_index formula-decl nil inn_dp_termination nil) (terminating? const-decl "bool" noetherian nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil)) nil)) (reducible_position_of_normal_inst_is_app_pos_of_term 0 (reducible_position_of_normal_inst_is_app_pos_of_term-1 nil 3761502072 ("" (skeep* :preds? t) (("" (lemma "positions_of_ext") (("" (inst -1 "sigma" "t") (("" (expand "union") (("" (expand "member") (("" (assert) (("" (decompose-equality -1) (("" (inst -1 "p") (("" (assert) (("" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (replaces -1) (("2" (lemma "subterm_of_ext") (("2" (inst -1 "p1" "p2" "sigma" "t") (("2" (assert) (("2" (replaces -1) (("2" (expand "normal_sub?") (("2" (inst -5 "subtermOF(t, p1)") (("1" (expand "is_normal_form?") (("1" (name-replace "st" "subtermOF(t, p1)") (("1" (hide-all-but (-2 -3 -6 1)) (("1" (expand "reducible?") (("1" (expand "reduction?") (("1" (skeep* :preds? t) (("1" (case "positionsOF(sigma(st))(p2 o p!1)") (("1" (inst 1 "replaceTerm(sigma(st), ext(sigma_1)(rhs(e)), p2 o p!1)") (("1" (inst 1 "e" "sigma_1" "p2 o p!1") (("1" (lemma "pos_subterm") (("1" (inst -1 "p2" "p!1" "sigma(st)") (("1" (assert) (("1" (expand "ext" -9 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "ext" -6) (("2" (assert) (("2" (use "pos_o_term") (("2" (assert) (("2" (expand "ext" -4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-5 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (positions_of_ext formula-decl nil substitution nil) (union const-decl "set" sets nil) (t skolem-const-decl "term[variable, symbol, arity]" inn_dp_termination nil) (p1 skolem-const-decl "position[variable, symbol, arity]" inn_dp_termination nil) (Dom const-decl "set[(V)]" substitution nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (sigma skolem-const-decl "(normal_sub?(E))" inn_dp_termination nil) (reducible? const-decl "bool" ars_terminology nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (pos_o_term formula-decl nil subterm nil) (st skolem-const-decl "term[variable, symbol, arity]" inn_dp_termination nil) (p2 skolem-const-decl "position[variable, symbol, arity]" inn_dp_termination nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](subtermOF(ext(sigma)(st), p2))" inn_dp_termination nil) (rhs const-decl "term" rewrite_rules nil) (replaceTerm def-decl "term" replacement nil) (pos_subterm formula-decl nil subterm nil) (reduction? const-decl "bool" reduction nil) (is_normal_form? const-decl "bool" ars_terminology nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (/= const-decl "boolean" notequal nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](sigma(subtermOF(t, p1)))" inn_dp_termination nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (sigma!1 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (< const-decl "bool" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (e!1 skolem-const-decl "{e | member[rewrite_rule[variable, symbol, arity]](e, E)}" inn_dp_termination nil) (subset? const-decl "bool" sets nil) (Vars const-decl "set[(V)]" subterm nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lhs const-decl "term" rewrite_rules nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (only_empty_seq const-decl "positions" positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (subterm_of_ext formula-decl nil substitution nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (ext def-decl "term" substitution nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (finseq type-eq-decl nil finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (member const-decl "bool" sets nil) (normal_sub? const-decl "bool" reduction nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil)) (normal_inst_of_rule_with_mint_on_rhs_gives_dp_alt 0 (normal_inst_of_rule_with_mint_on_rhs_gives_dp_alt-1 nil 3761502110 ("" (skeep* :preds? t) (("" (expand "dep_pair_alt?") (("" (case "reducible?(reduction?(E))(subtermOF(ext(sigma)(rhs(e)), p))") (("1" (use "reducible_position_of_normal_inst_is_app_pos_of_term") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand "rewrite_rule?") (("1" (expand "lhs") (("1" (flatten) (("1" (assert) (("1" (lemma "mint_reduces_to_int_nrnf_term") (("1" (inst -1 "E" "subtermOF(ext(sigma)(rhs(e)), p)") (("1" (skeep :preds? t) (("1" (use "non_root_ir_preserves_root_symbol") (("1" (assert) (("1" (flatten) (("1" (use "ext_preserve_symbol") (("1" (assert) (("1" (replaces -1 :dir rl) (("1" (replaces -2) (("1" (hide-all-but (-1 -3 1 3)) (("1" (expand "terminating?") (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (replaces -2) (("1" (expand "innermost_reduction?") (("1" (expand "innermost_reduction_fix?") (("1" (expand "reduction_fix?") (("1" (skeep :preds? t) (("1" (skeep) (("1" (case-replace "p!1 = empty_seq" :hide? t) (("1" (expand "defined?") (("1" (inst?) (("1" (lemma "ext_preserve_symbol") (("1" (inst -1 "lhs(e!1)" "sigma!1" "empty_seq") (("1" (rewrite* "subterm_empty_seq") (("1" (assert) (("1" (typepred "e!1") (("1" (expand "rewrite_rule?") (("1" (expand "lhs") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (expand "is_normal_form?") (("2" (expand "reducible?") (("2" (inst 2 "seq(1)") (("2" (expand "non_root_reduction?") (("2" (inst?) (("2" (expand "reduction_fix?") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "reducible_is_app") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "minimal_innermost_non_terminating?") (("2" (flatten) (("2" (hide-all-but (1 2)) (("2" (expand "terminating?") (("2" (skeep) (("2" (inst?) (("2" (replaces -1 :dir rl) (("2" (assert) (("2" (expand "reducible?") (("2" (inst 1 "seq(1)") (("2" (use "innermost_subset_reduction") (("2" (expand "subset?") (("2" (expand "member") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dep_pair_alt? const-decl "bool" dependency_pairs nil) (innermost_subset_reduction formula-decl nil innermost_reduction nil) (subset? const-decl "bool" sets nil) (reducible_position_of_normal_inst_is_app_pos_of_term formula-decl nil inn_dp_termination nil) (mint_reduces_to_int_nrnf_term formula-decl nil inn_dp_termination nil) (reducible_is_app formula-decl nil reduction nil) (ext_preserve_symbol formula-decl nil substitution nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (reduction_fix? const-decl "bool" reduction nil) (non_root_reduction? const-decl "bool" reduction nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](t)" inn_dp_termination nil) (t skolem-const-decl "{t: term | NOT terminating?(innermost_reduction?(E))(t)}" inn_dp_termination nil) (sequence type-eq-decl nil sequences nil) (is_normal_form? const-decl "bool" ars_terminology nil) (defined? const-decl "bool" rewrite_rules nil) (empty_seq_is_position formula-decl nil positions nil) (subterm_empty_seq formula-decl nil subterm nil) (e!1 skolem-const-decl "{e | member[rewrite_rule[variable, symbol, arity]](e, E)}" inn_dp_termination nil) (= const-decl "[T, T -> boolean]" equalities nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (sigma skolem-const-decl "(normal_sub?(E))" inn_dp_termination nil) (e skolem-const-decl "{e | member(e, E)}" inn_dp_termination nil) (p skolem-const-decl "positions?[variable, symbol, arity](ext(sigma)(rhs(e)))" inn_dp_termination nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (terminating? const-decl "bool" noetherian nil) (NOT const-decl "[bool -> bool]" booleans nil) (non_root_ir_preserves_root_symbol formula-decl nil innermost_reduction nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (lhs const-decl "term" rewrite_rules nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (term type-decl nil term_adt nil) (PRED type-eq-decl nil defined_types nil) (reducible? const-decl "bool" ars_terminology nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (reduction? const-decl "bool" reduction nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (ext def-decl "term" substitution nil) (normal_sub? const-decl "bool" reduction nil) (rhs const-decl "term" rewrite_rules nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil)) (mint_to_nit_nrnf_TCC1 0 (mint_to_nit_nrnf_TCC1-2 nil 3761500585 ("" (skeep :preds? t) (("" (expand "nonempty?") (("" (expand "empty?") (("" (use "mint_reduces_to_int_nrnf_term") (("" (skeep :preds? t) (("" (inst?) (("" (assert) (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonempty? const-decl "bool" sets nil) (mint_reduces_to_int_nrnf_term formula-decl nil inn_dp_termination nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (terminating? const-decl "bool" noetherian nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)) nil (mint_to_nit_nrnf subtype "{t: term_adt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].term | booleans.AND(relations_closure[term_adt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].term].RTC(innermost_reduction[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].non_root_innermost_reduction?(inn_dp_termination.E))(inn_dp_termination.s, t), booleans.AND(ars_terminology[term_adt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].term].is_normal_form?(reduction[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].non_root_reduction?(inn_dp_termination.E))(t), (booleans.NOT)(noetherian[term_adt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].term].terminating?(innermost_reduction[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].innermost_reduction?(inn_dp_termination.E))(t))))}" "(sets[term_adt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].term].nonempty?)")) (mint_to_nit_nrnf_TCC1-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (mint_to_nit_nrnf subtype "{t: term_adt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].term | booleans.AND(relations_closure[term_adt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].term].RTC(innermost_reduction[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].non_root_innermost_reduction?(inn_dp_termination.E))(inn_dp_termination.s, t), booleans.AND(ars_terminology[term_adt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].term].is_normal_form?(reduction[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].non_root_reduction?(inn_dp_termination.E))(t), (booleans.NOT)(noetherian[term_adt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].term].terminating?(innermost_reduction[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].innermost_reduction?(inn_dp_termination.E))(t))))}" "(sets[term_adt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].term].nonempty?)"))) (reduced_nit_nrnf_has_mint_TCC1 0 (reduced_nit_nrnf_has_mint_TCC1-2 nil 3761500625 ("" (skeep :preds? t) (("" (rewrite "ext_preserv_pos") nil nil)) nil) ((ext_preserv_pos formula-decl nil substitution nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil) (positions? type-eq-decl nil positions nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil)) nil (reduced_nit_nrnf_has_mint subtype "inn_dp_termination.p" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(inn_dp_termination.sigma)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.e)))")) (reduced_nit_nrnf_has_mint_TCC1-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (reduced_nit_nrnf_has_mint subtype "inn_dp_termination.p" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(inn_dp_termination.sigma)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.e)))"))) (reduced_nit_nrnf_has_mint 0 (reduced_nit_nrnf_has_mint-1 nil 3761502141 ("" (skeep* :preds? t) (("" (hide -1) (("" (expand "mint_to_nit_nrnf") (("" (typepred "choose({t: term |
                               RTC(non_root_innermost_reduction?(E))(s, t) AND
                                is_normal_form?(non_root_reduction?(E))(t) AND NOT terminating?(innermost_reduction?(E))(t)})") (("1" (name-replace "nf_term" "choose({t: term |
                                   RTC(non_root_innermost_reduction?(E))(s, t) AND
                                    is_normal_form?(non_root_reduction?(E))(t) AND NOT terminating?(innermost_reduction?(E))(t)})") (("1" (expand "terminating?") (("1" (skeep) (("1" (inst -4 0) (("1" (assert) (("1" (lemma "inn_non_terminating_has_mint") (("1" (inst -1 "E" "seq(1)") (("1" (skeep* :preds? t) (("1" (expand "innermost_reduction?") (("1" (expand "innermost_reduction_fix?") (("1" (expand "reduction_fix?") (("1" (skeep* :preds? t) (("1" (case-replace "ext(restriction(sigma)(Vars(lhs(e))))(lhs(e)) = ext(sigma)(lhs(e)) AND ext(restriction(sigma)(Vars(lhs(e))))(rhs(e)) = ext(sigma)(rhs(e))") (("1" (flatten) (("1" (case-replace "p!1 = empty_seq" :hide? t) (("1" (inst 1 "restriction(sigma)(Vars(lhs(e)))" "e" "p") (("1" (rewrite "subterm_empty_seq") (("1" (expand "member") (("1" (assert) (("1" (expand "replaceTerm") (("1" (expand "empty_seq" -14) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterm_empty_seq") (("2" (expand "replaceTerm") (("2" (expand "empty_seq" -14) (("2" (replaces -14) (("2" (lemma "reducible_position_of_normal_inst_is_app_pos_of_term") (("2" (inst -1 "E" "rhs(e)" "restriction(sigma)(Vars(lhs(e)))" "p") (("1" (assert) (("1" (replaces -2) (("1" (hide-all-but (-7 1)) (("1" (name-replace "t1" "subtermOF(ext(sigma)(rhs(e)), p)") (("1" (expand "minimal_innermost_non_terminating?") (("1" (flatten) (("1" (hide -1) (("1" (expand "terminating?") (("1" (skeep) (("1" (inst -2 0) (("1" (assert) (("1" (expand "innermost_reduction?") (("1" (expand "innermost_reduction_fix?") (("1" (expand "reduction_fix?") (("1" (skeep* :preds? t) (("1" (expand "reducible?") (("1" (replaces -5) (("1" (inst 1 "seq!1(1)") (("1" (expand "reduction?") (("1" (inst 1 "e!1" "sigma!1" "p!2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "ext_preserv_pos") nil nil) ("3" (rewrite "normal_subst") (("3" (expand "rewrite_rule?") (("3" (expand "lhs") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-10 -11 -13 -14 1)) (("2" (replaces -2) (("2" (rewrite* "nr_normal_form_subterms") (("2" (inst -1 "p!1") (("2" (assert) (("2" (expand "is_normal_form?") (("2" (expand "reducible?") (("2" (expand "reduction?") (("2" (inst 2 "subtermOF(replaceTerm(nf_term, ext(sigma)(rhs(e)), p!1), p!1)") (("1" (inst 2 "e" "sigma" "empty_seq") (("1" (rewrite "subterm_empty_seq") (("1" (assert) (("1" (expand "replaceTerm" 2 2) (("1" (expand "empty_seq" 2) (("1" (rewrite "subterm_of_replace") nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "empty_seq_is_position") nil nil)) nil) ("2" (typepred "p!1") (("2" (rewrite "replace_preserv_pos") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "rewrite_rule?") (("2" (expand "lhs") (("2" (expand "rhs") (("2" (prop) (("1" (use "restriction_term") (("1" (assert) (("1" (expand "subset?") (("1" (skeep) nil nil)) nil)) nil)) nil) ("2" (use "restriction_term") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (prop) (("3" (rewrite "restriction_Subs") nil nil)) nil) ("4" (rewrite "restriction_Subs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (expand "terminating?") (("2" (inst 1 "LAMBDA(i: nat): seq(i+1)") (("2" (assert) (("2" (skeep) (("2" (reveal -2) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "mint_reduces_to_int_nrnf_term") (("2" (skeep :preds? t) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst?) (("2" (assert) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((innermost_reduction? const-decl "bool" innermost_reduction nil) (terminating? const-decl "bool" noetherian nil) (non_root_reduction? const-decl "bool" reduction nil) (is_normal_form? const-decl "bool" ars_terminology nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (pred type-eq-decl nil defined_types nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (inn_non_terminating_has_mint formula-decl nil inn_dp_termination nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (restriction_Subs formula-decl nil substitution nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subset? const-decl "bool" sets nil) (restriction_term formula-decl nil substitution nil) (nr_normal_form_subterms formula-decl nil innermost_reduction nil) (s skolem-const-decl "{s: term | minimal_innermost_non_terminating?(E)(s)}" inn_dp_termination nil) (nf_term skolem-const-decl "({t: term |
    RTC(non_root_innermost_reduction?(E))(s, t) AND
     is_normal_form?(non_root_reduction?(E))(t) AND
      NOT terminating?(innermost_reduction?(E))(t)})" inn_dp_termination nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](seq(0))" inn_dp_termination nil) (empty_seq_is_position formula-decl nil positions nil) (subterm_of_replace formula-decl nil replacement nil) (replace_preserv_pos formula-decl nil replacement nil) (e skolem-const-decl "{e | member[rewrite_rule[variable, symbol, arity]](e, E)}" inn_dp_termination nil) (p skolem-const-decl "positions?[variable, symbol, arity](seq(1))" inn_dp_termination nil) (replaceTerm def-decl "term" replacement nil) (subterm_empty_seq formula-decl nil subterm nil) (normal_sub? const-decl "bool" reduction nil) (sigma skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (subtermOF def-decl "term" subterm nil) (reducible? const-decl "bool" ars_terminology nil) (reduction? const-decl "bool" reduction nil) (ext_preserv_pos formula-decl nil substitution nil) (normal_subst formula-decl nil innermost_reduction nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (reducible_position_of_normal_inst_is_app_pos_of_term formula-decl nil inn_dp_termination nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (ext def-decl "term" substitution nil) (restriction const-decl "term" substitution nil) (Vars const-decl "set[(V)]" subterm nil) (lhs const-decl "term" rewrite_rules nil) (member const-decl "bool" sets nil) (rhs const-decl "term" rewrite_rules nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (reduction_fix? const-decl "bool" reduction nil) (seq skolem-const-decl "sequence[term[variable, symbol, arity]]" inn_dp_termination nil) (sequence type-eq-decl nil sequences nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (mint_reduces_to_int_nrnf_term formula-decl nil inn_dp_termination nil) (empty? const-decl "bool" sets nil) (mint_to_nit_nrnf const-decl "term" inn_dp_termination nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil)) (dp_and_sub_from_int_nrnf_TCC1 0 (dp_and_sub_from_int_nrnf_TCC1-2 nil 3761501195 ("" (skeep* :preds? t) (("" (rewrite "ext_preserv_pos") nil nil)) nil) ((ext_preserv_pos formula-decl nil substitution nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (positions? type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (dp_and_sub_from_int_nrnf subtype "inn_dp_termination.p" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(inn_dp_termination.sigma)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.e)))")) (dp_and_sub_from_int_nrnf_TCC1-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (dp_and_sub_from_int_nrnf subtype "inn_dp_termination.p" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(inn_dp_termination.sigma)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.e)))"))) (dp_and_sub_from_int_nrnf_TCC2 0 (dp_and_sub_from_int_nrnf_TCC2-2 nil 3761500665 ("" (skeep* :preds? t) (("" (use "reduced_nit_nrnf_has_mint") (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (skeep) (("" (inst -5 "(sigma, e, p)") (("" (assert) (("" (typepred "e") (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((reduced_nit_nrnf_has_mint formula-decl nil inn_dp_termination nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (empty? const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (positions? type-eq-decl nil positions nil) (rhs const-decl "term" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (dp_and_sub_from_int_nrnf subtype "{(sigma: substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].Sub, e: rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rewrite_rule, p: positions[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].positions?(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(e))) | booleans.AND(sets[rewrite_rule[variable, symbol, arity]].member(e, inn_dp_termination.E), booleans.AND(substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(sigma)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].lhs(e)) = inn_dp_termination.nf_term, inn_dp_termination.minimal_innermost_non_terminating?(inn_dp_termination.E)(subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(sigma)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(e)), p))))}" "(sets[[Sub[variable, symbol, arity], e: rewrite_rule[variable, symbol, arity], positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(e))]].nonempty?)")) (dp_and_sub_from_int_nrnf_TCC2-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (dp_and_sub_from_int_nrnf subtype "{(sigma: substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].Sub, e: rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rewrite_rule, p: positions[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].positions?(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(e))) | booleans.AND(sets[rewrite_rule[variable, symbol, arity]].member(e, inn_dp_termination.E), booleans.AND(substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(sigma)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].lhs(e)) = inn_dp_termination.nf_term, inn_dp_termination.minimal_innermost_non_terminating?(inn_dp_termination.E)(subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(sigma)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(e)), p))))}" "(sets[[Sub[variable, symbol, arity], e: rewrite_rule[variable, symbol, arity], positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(e))]].nonempty?)"))) (dp_and_sub_from_int_nrnf_TCC3 0 (dp_and_sub_from_int_nrnf_TCC3-2 nil 3761500716 ("" (skeep* :preds? t) (("" (name-replace "sig_e_p" "choose({(sigma: Sub), (e: rewrite_rule), (p: positions?(rhs(e))) |
                       member(e, E) AND
                        ext(sigma)(lhs(e)) = nf_term AND
                         minimal_innermost_non_terminating?(E)
                                                           (subtermOF
                                                            (ext(sigma)(rhs(e)),
                                                             p))})") (("1" (typepred "sig_e_p") (("1" (lemma "normal_inst_of_rule_with_mint_on_rhs_gives_dp_alt") (("1" (inst -1 "E" "sub_e_p`2" "restriction(sub_e_p`1)(Vars(lhs(sub_e_p`2)))" "sub_e_p`3") (("1" (assert) (("1" (use "restriction_term") (("1" (assert) (("1" (typepred "sub_e_p`2") (("1" (expand "rewrite_rule?") (("1" (expand "rhs") (("1" (expand "lhs") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "ext_preserv_pos") nil nil) ("3" (rewrite "restriction_Subs") (("3" (expand "mint_to_nit_nrnf") (("3" (typepred "choose({t: term |
                                   RTC(non_root_innermost_reduction?(E))(s, t) AND
                                    is_normal_form?(non_root_reduction?(E))(t) AND NOT terminating?(innermost_reduction?(E))(t)})") (("1" (rewrite "normal_subst") (("1" (typepred "sub_e_p`2") (("1" (expand "rewrite_rule?") (("1" (expand "lhs") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (use "mint_reduces_to_int_nrnf_term") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (hide -7) (("2" (inst -1 "(sub_e_p`1, sub_e_p`2, sub_e_p`3)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep* :preds? t) (("3" (rewrite "ext_preserv_pos") nil nil)) nil)) nil)) nil) ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (positions? type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (ext def-decl "term" substitution nil) (lhs const-decl "term" rewrite_rules nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (subtermOF def-decl "term" subterm nil) (normal_inst_of_rule_with_mint_on_rhs_gives_dp_alt formula-decl nil inn_dp_termination nil) (restriction_Subs formula-decl nil substitution nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (PRED type-eq-decl nil defined_types nil) (is_normal_form? const-decl "bool" ars_terminology nil) (non_root_reduction? const-decl "bool" reduction nil) (terminating? const-decl "bool" noetherian nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (normal_subst formula-decl nil innermost_reduction nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (empty? const-decl "bool" sets nil) (mint_reduces_to_int_nrnf_term formula-decl nil inn_dp_termination nil) (mint_to_nit_nrnf const-decl "term" inn_dp_termination nil) (ext_preserv_pos formula-decl nil substitution nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (restriction_term formula-decl nil substitution nil) (restriction const-decl "term" substitution nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (nf_term skolem-const-decl "term[variable, symbol, arity]" inn_dp_termination nil) (sub_e_p skolem-const-decl "({(sigma: Sub[variable, symbol, arity],
   e: rewrite_rule[variable, symbol, arity],
   p:
     positions?
         [variable, symbol, arity](rhs[variable, symbol, arity](e))) |
    member[rewrite_rule[variable, symbol, arity]](e, E) AND
     ext[variable, symbol, arity](sigma)(lhs[variable, symbol, arity](e)) =
      nf_term
      AND
      minimal_innermost_non_terminating?(E)
                                        (subtermOF[variable, symbol, arity]
                                         (ext[variable, symbol, arity]
                                          (sigma)
                                          (rhs[variable, symbol, arity]
                                           (e)),
                                          p))})" inn_dp_termination nil) (Vars const-decl "set[(V)]" subterm nil) (normal_sub? const-decl "bool" reduction nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (dp_and_sub_from_int_nrnf subtype "(inn_dp_termination.sub_e_p`2, inn_dp_termination.sub_e_p`3)" "dep_pair_alt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](inn_dp_termination.E)")) (dp_and_sub_from_int_nrnf_TCC3-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (dp_and_sub_from_int_nrnf subtype "(inn_dp_termination.sub_e_p`2, inn_dp_termination.sub_e_p`3)" "dep_pair_alt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](inn_dp_termination.E)"))) (next_inst_dp_is_inn_chained_and_mnt_TCC1 0 (next_inst_dp_is_inn_chained_and_mnt_TCC1-2 nil 3761500758 ("" (skeep* :preds? t) (("" (expand "dep_pair_alt?") (("" (flatten) (("" (use "ext_preserv_pos") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((dep_pair_alt? const-decl "bool" dependency_pairs nil) (ext_preserv_pos formula-decl nil substitution nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (rhs const-decl "term" rewrite_rules nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (next_inst_dp_is_inn_chained_and_mnt subtype "inn_dp_termination.dp`2" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(inn_dp_termination.sigma)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp`1)))")) (next_inst_dp_is_inn_chained_and_mnt_TCC1-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (next_inst_dp_is_inn_chained_and_mnt subtype "inn_dp_termination.dp`2" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(inn_dp_termination.sigma)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp`1)))"))) (next_inst_dp_is_inn_chained_and_mnt_TCC2 0 (next_inst_dp_is_inn_chained_and_mnt_TCC2-1 nil 3761499258 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (ext def-decl "term" substitution nil) (PRED type-eq-decl nil defined_types nil) (is_normal_form? const-decl "bool" ars_terminology nil) (non_root_reduction? const-decl "bool" reduction nil) (lhs const-decl "term" rewrite_rules nil) (terminating? const-decl "bool" noetherian nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (reducible? const-decl "bool" ars_terminology nil) (reduction_fix? const-decl "bool" reduction nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (defined? const-decl "bool" rewrite_rules nil) (member const-decl "bool" sets nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (rhs const-decl "term" rewrite_rules nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (next_inst_dp_is_inn_chained_and_mnt subtype "inn_dp_termination.dp`2" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp`1))"))) (next_inst_dp_is_inn_chained_and_mnt_TCC3 0 (next_inst_dp_is_inn_chained_and_mnt_TCC3-1 nil 3761499258 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (ext def-decl "term" substitution nil) (PRED type-eq-decl nil defined_types nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (defined? const-decl "bool" rewrite_rules nil) (member const-decl "bool" sets nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (reduction_fix? const-decl "bool" reduction nil) (non_root_reduction? const-decl "bool" reduction nil) (term type-decl nil term_adt nil) (reducible? const-decl "bool" ars_terminology nil) (is_normal_form? const-decl "bool" ars_terminology nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (terminating? const-decl "bool" noetherian nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (next_inst_dp_is_inn_chained_and_mnt subtype "subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(inn_dp_termination.sigma)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp`1)), inn_dp_termination.dp`2)" "{s: term_adt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].term | inn_dp_termination.minimal_innermost_non_terminating?(inn_dp_termination.E)(s)}"))) (next_inst_dp_is_inn_chained_and_mnt_TCC4 0 (next_inst_dp_is_inn_chained_and_mnt_TCC4-2 nil 3761500810 ("" (skeep* :preds? t) (("" (typepred "next_dp_sub`1") (("" (hide-all-but (-1 1)) (("" (expand "dep_pair_alt?") (("" (flatten) nil nil)) nil)) nil)) nil)) nil) ((Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (next_inst_dp_is_inn_chained_and_mnt subtype "inn_dp_termination.next_dp_sub`1`2" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.next_dp_sub`1`1))")) (next_inst_dp_is_inn_chained_and_mnt_TCC4-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (next_inst_dp_is_inn_chained_and_mnt subtype "inn_dp_termination.next_dp_sub`1`2" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.next_dp_sub`1`1))"))) (next_inst_dp_is_inn_chained_and_mnt_TCC5 0 (next_inst_dp_is_inn_chained_and_mnt_TCC5-2 nil 3761500843 ("" (skeep* :preds? t) (("" (replaces -6) (("" (expand "dep_pair?") (("" (expand "dep_pair_alt?") (("" (flatten) (("" (assert) (("" (inst?) (("" (assert) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dep_pair_alt? const-decl "bool" dependency_pairs nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (rhs const-decl "term" rewrite_rules nil) (positions? type-eq-decl nil positions nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (set type-eq-decl nil sets nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (dep_pair? const-decl "bool" dependency_pairs nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (next_inst_dp_is_inn_chained_and_mnt subtype "inn_dp_termination.std_dp" "dep_pair[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](inn_dp_termination.E)")) (next_inst_dp_is_inn_chained_and_mnt_TCC5-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (next_inst_dp_is_inn_chained_and_mnt subtype "inn_dp_termination.std_dp" "dep_pair[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](inn_dp_termination.E)"))) (next_inst_dp_is_inn_chained_and_mnt_TCC6 0 (next_inst_dp_is_inn_chained_and_mnt_TCC6-2 nil 3761500876 ("" (skeep* :preds? t) (("" (replaces -8) (("" (replaces -7) (("" (typepred "dp_and_sub_from_int_nrnf(E)
                                         (subtermOF
                                          (ext(sigma)(rhs(dp`1)), dp`2))`1") (("" (hide-all-but (-1 1)) (("" (expand "dep_pair_alt?") (("" (flatten) (("" (expand "dep_pair?") (("" (assert) (("" (inst?) (("" (assert) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lhs const-decl "term" rewrite_rules nil) (non_root_reduction? const-decl "bool" reduction nil) (is_normal_form? const-decl "bool" ars_terminology nil) (PRED type-eq-decl nil defined_types nil) (rhs const-decl "term" rewrite_rules nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ext def-decl "term" substitution nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (dp_and_sub_from_int_nrnf const-decl "[dep_pair_alt(E), Sub]" inn_dp_termination nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (dep_pair? const-decl "bool" dependency_pairs nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (next_inst_dp_is_inn_chained_and_mnt subtype "inn_dp_termination.next_std_dp" "dep_pair[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](inn_dp_termination.E)")) (next_inst_dp_is_inn_chained_and_mnt_TCC6-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (next_inst_dp_is_inn_chained_and_mnt subtype "inn_dp_termination.next_std_dp" "dep_pair[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](inn_dp_termination.E)"))) (next_inst_dp_is_inn_chained_and_mnt 0 (next_inst_dp_is_inn_chained_and_mnt-1 nil 3761502173 ("" (skeep* :preds? t) (("" (assert) (("" (expand "dp_and_sub_from_int_nrnf") (("" (typepred "choose({(sigma_1: Sub),
                                                                   (e: rewrite_rule),
                                                                   (p: positions?(rhs(e)))
                                                                   |
                                                                   member(e, E)
                                                                   AND
                                                                   ext(sigma_1)(lhs(e))
                                                                   =
                                                                   mint_to_nit_nrnf
                                                                   (E)
                                                                   (subtermOF[variable, symbol, arity]
                                                                    (ext[variable, symbol, arity]
                                                                     (sigma)
                                                                     (rhs[variable, symbol, arity]
                                                                      (dp`1)),
                                                                     dp`2))
                                                                   AND
                                                                   minimal_innermost_non_terminating?
                                                                   (E)
                                                                   (subtermOF
                                                                    (ext(sigma_1)(rhs(e)), p))})") (("1" (name-replace "s_e_p" "choose({(sigma_1: Sub),
                                                                                 (e: rewrite_rule),
                                                                                 (p: positions?(rhs(e)))
                                                                                 |
                                                                                 member(e, E)
                                                                                 AND
                                                                                 ext(sigma_1)(lhs(e))
                                                                                 =
                                                                                 mint_to_nit_nrnf
                                                                                 (E)
                                                                                 (subtermOF[variable, symbol, arity]
                                                                                  (ext[variable, symbol, arity]
                                                                                   (sigma)
                                                                                   (rhs[variable, symbol, arity]
                                                                                    (dp`1)),
                                                                                   dp`2))
                                                                                 AND
                                                                                 minimal_innermost_non_terminating?
                                                                                 (E)
                                                                                 (subtermOF
                                                                                  (ext(sigma_1)(rhs(e)), p))})") (("1" (expand "mint_to_nit_nrnf") (("1" (typepred "choose({t: term |
                                                             RTC(non_root_innermost_reduction?(E))
                                                                (subtermOF[variable, symbol, arity]
                                                                     (ext[variable, symbol, arity]
                                                                          (sigma)(rhs[variable, symbol, arity](dp`1)),
                                                                      dp`2),
                                                                 t)
                                                              AND
                                                              is_normal_form?(non_root_reduction?(E))(t) AND NOT terminating?(innermost_reduction?(E))(t)})") (("1" (name-replace "cTerm" "choose({t: term |
                                                                           RTC(non_root_innermost_reduction?(E))
                                                                              (subtermOF[variable, symbol, arity]
                                                                                   (ext[variable, symbol, arity]
                                                                                        (sigma)(rhs[variable, symbol, arity](dp`1)),
                                                                                    dp`2),
                                                                               t)
                                                                            AND
                                                                            is_normal_form?(non_root_reduction?(E))(t) AND NOT terminating?(innermost_reduction?(E))(t)})") (("1" (prop) (("1" (expand "inn_chained_dp?") (("1" (assert) (("1" (lemma "subterm_ext_commute") (("1" (inst -1 "dp`2" "rhs(dp`1)" "sigma") (("1" (assert) (("1" (expand "dep_pair_alt?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (use "subterm_ext_commute") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -1 "ext(s_e_p`1)(lhs(s_e_p`2))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "dp_and_sub_from_int_nrnf_TCC2") (("2" (inst -1 "E" "subtermOF(ext(sigma)(rhs(dp`1)),dp`2)" " mint_to_nit_nrnf(E)(subtermOF[variable, symbol, arity]
                                                                                 (ext[variable, symbol, arity]
                                                                                  (sigma)
                                                                                  (rhs[variable, symbol, arity](dp`1)),
                                                                                  dp`2))") nil nil)) nil)) nil) ("3" (hide 2) (("3" (skeep* :preds? t) (("3" (rewrite "ext_preserv_pos") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((non_root_reduction? const-decl "bool" reduction nil) (is_normal_form? const-decl "bool" ars_terminology nil) (PRED type-eq-decl nil defined_types nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (subtermOF def-decl "term" subterm nil) (mint_to_nit_nrnf const-decl "term" inn_dp_termination nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (lhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (positions? type-eq-decl nil positions nil) (rhs const-decl "term" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil) (inn_chained_dp? const-decl "bool" inn_dp_termination nil) (subterm_ext_commute formula-decl nil substitution nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (terminating? const-decl "bool" noetherian nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (dp_and_sub_from_int_nrnf_TCC2 subtype-tcc nil inn_dp_termination nil) (ext_preserv_pos formula-decl nil substitution nil) (dp_and_sub_from_int_nrnf const-decl "[dep_pair_alt(E), Sub]" inn_dp_termination nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil)) (next_dp_and_sub_TCC1 0 (next_dp_and_sub_TCC1-3 "" 3884907027 ("" (skeep) (("" (typepred "dp_s`1") (("" (expand "dep_pair_alt?") (("" (flatten) nil nil)) nil)) nil)) nil) nil shostak (next_dp_and_sub subtype "inn_dp_termination.dp_s`1`2" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_s`1`1))")) (next_dp_and_sub_TCC1-2 nil 3761500941 ("" (skeep) (("" (rewrite "ext_preserv_pos") (("" (typepred "dp_s`1") (("" (expand "dep_pair_alt?") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((lhs const-decl "term" rewrite_rules nil) (non_root_reduction? const-decl "bool" reduction nil) (is_normal_form? const-decl "bool" ars_terminology nil) (PRED type-eq-decl nil defined_types nil) (rhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (next_dp_and_sub subtype "inn_dp_termination.dp_s`1`2" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_s`1`1))")) (next_dp_and_sub_TCC1-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (next_dp_and_sub subtype "inn_dp_termination.dp_s`1`2" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_s`1`1))"))) (next_dp_and_sub_TCC2 0 (next_dp_and_sub_TCC3-2 nil 3761501034 ("" (skeep :preds? t) (("" (typepred "dp_s`1") (("" (hide -2 -3 -4 -5) (("" (expand "dep_pair_alt?") (("" (expand "dep_pair?") (("" (flatten) (("" (assert) (("" (expand "defined?") (("" (assert) (("" (inst?) (("" (assert) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lhs const-decl "term" rewrite_rules nil) (non_root_reduction? const-decl "bool" reduction nil) (is_normal_form? const-decl "bool" ars_terminology nil) (PRED type-eq-decl nil defined_types nil) (rhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (defined? const-decl "bool" rewrite_rules nil) (dep_pair? const-decl "bool" dependency_pairs nil)) nil (next_dp_and_sub subtype "(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].lhs(inn_dp_termination.dp_s`1`1), subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_s`1`1), inn_dp_termination.dp_s`1`2))" "dep_pair[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](inn_dp_termination.E)")) (next_dp_and_sub_TCC3-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (next_dp_and_sub subtype "(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].lhs(inn_dp_termination.dp_s`1`1), subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_s`1`1), inn_dp_termination.dp_s`1`2))" "dep_pair[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](inn_dp_termination.E)"))) (next_dp_and_sub_TCC3 0 (next_dp_and_sub_TCC4-1 nil 3761499258 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (defined? const-decl "bool" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (member const-decl "bool" sets nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (rhs const-decl "term" rewrite_rules nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (next_dp_and_sub subtype "inn_dp_termination.dp_`2" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_`1))"))) (next_dp_and_sub_TCC4 0 (next_dp_and_sub_TCC5-1 nil 3761499258 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Vars const-decl "set[(V)]" subterm nil) (subset? const-decl "bool" sets nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (E!1 skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (e!1 skolem-const-decl "{e | member(e, E!1)}" inn_dp_termination nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (sigma!1 skolem-const-decl "Sub[variable, symbol, arity]" inn_dp_termination nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (dp!1 skolem-const-decl "dep_pair_alt[variable, symbol, arity](E!1)" inn_dp_termination nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (lhs const-decl "term" rewrite_rules nil) (defined? const-decl "bool" rewrite_rules nil) (member const-decl "bool" sets nil) (dep_pair? const-decl "bool" dependency_pairs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (rhs const-decl "term" rewrite_rules nil) (Dom const-decl "set[(V)]" substitution nil) (/= const-decl "boolean" notequal nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil)) nil (next_dp_and_sub subtype "(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].lhs(inn_dp_termination.dp_`1), subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_`1), inn_dp_termination.dp_`2))" "dep_pair[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](inn_dp_termination.E)"))) (next_dp_and_sub_TCC5 0 (next_dp_and_sub_TCC5-1 "" 3884907090 ("" (skeep) (("" (rewrite "ext_preserv_pos") (("" (typepred "dp_s`1") (("" (expand "dep_pair_alt?") (("" (propax) nil nil)) nil)) nil)) nil)) nil) nil shostak (next_dp_and_sub subtype "inn_dp_termination.dp_s`1`2" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(inn_dp_termination.dp_s`2)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_s`1`1)))")) (next_dp_and_sub_TCC2-2 nil 3761500999 ("" (skeep) (("" (typepred "dp_s`1") (("" (expand "dep_pair_alt?") (("" (flatten) nil nil)) nil)) nil)) nil) ((ext_preserv_pos formula-decl nil substitution nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (ext def-decl "term" substitution nil) (rhs const-decl "term" rewrite_rules nil) (PRED type-eq-decl nil defined_types nil) (is_normal_form? const-decl "bool" ars_terminology nil) (non_root_reduction? const-decl "bool" reduction nil) (lhs const-decl "term" rewrite_rules nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil (next_dp_and_sub subtype "inn_dp_termination.dp_s`1`2" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(inn_dp_termination.dp_s`2)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_s`1`1)))")) (next_dp_and_sub_TCC2-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (next_dp_and_sub subtype "inn_dp_termination.dp_s`1`2" "positions?[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity](substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(inn_dp_termination.dp_s`2)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_s`1`1)))"))) (next_dp_and_sub_TCC6 0 (next_dp_and_sub_TCC6-1 nil 3761499258 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (ext def-decl "term" substitution nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (rhs const-decl "term" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (reduction_fix? const-decl "bool" reduction nil) (non_root_reduction? const-decl "bool" reduction nil) (term type-decl nil term_adt nil) (reducible? const-decl "bool" ars_terminology nil) (is_normal_form? const-decl "bool" ars_terminology nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (terminating? const-decl "bool" noetherian nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (next_dp_and_sub subtype "subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(inn_dp_termination.dp_s`2)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_s`1`1)), inn_dp_termination.dp_s`1`2)" "{s: term_adt[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].term | inn_dp_termination.minimal_innermost_non_terminating?(inn_dp_termination.E)(s)}"))) (next_dp_and_sub_TCC7 0 (next_dp_and_sub_TCC7-2 nil 3761501068 ("" (skeep :preds? t) (("" (use "next_inst_dp_is_inn_chained_and_mnt") (("" (assert) (("" (flatten) (("" (assert) (("" (hide-all-but (-2 1)) (("" (name-replace "ss" "dp_and_sub_from_int_nrnf
                                            (E)
                                            (subtermOF
                                             (ext(dp_s`2)(rhs(dp_s`1`1)),
                                              dp_s`1`2))`2") (("" (name-replace "tt" "rhs(dp_and_sub_from_int_nrnf
                                              (E)
                                              (subtermOF
                                               (ext(dp_s`2)(rhs(dp_s`1`1)),
                                                dp_s`1`2))`1`1)") (("" (name-replace "pp" "dp_and_sub_from_int_nrnf(E)
                                             (subtermOF
                                              (ext(dp_s`2)(rhs(dp_s`1`1)),
                                               dp_s`1`2))") (("" (use "subterm_ext_commute") (("" (assert) (("" (hide -1 2) (("" (expand "tt") (("" (expand "pp") (("" (typepred "dp_and_sub_from_int_nrnf(E)
                                       (subtermOF
                                        (ext(dp_s`2)(rhs(dp_s`1`1)),
                                         dp_s`1`2))`1") (("" (expand "dep_pair_alt?") (("" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((next_inst_dp_is_inn_chained_and_mnt formula-decl nil inn_dp_termination nil) (lhs const-decl "term" rewrite_rules nil) (non_root_reduction? const-decl "bool" reduction nil) (is_normal_form? const-decl "bool" ars_terminology nil) (PRED type-eq-decl nil defined_types nil) (rhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (subterm_ext_commute formula-decl nil substitution nil) (pp skolem-const-decl "[dep_pair_alt[variable, symbol, arity](E), Sub[variable, symbol, arity]]" inn_dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (tt skolem-const-decl "term[variable, symbol, arity]" inn_dp_termination nil) (dp_and_sub_from_int_nrnf const-decl "[dep_pair_alt(E), Sub]" inn_dp_termination nil) (= const-decl "[T, T -> boolean]" equalities nil)) nil (next_dp_and_sub subtype "inn_dp_termination.dp_and_sub_from_int_nrnf(inn_dp_termination.E)(subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(inn_dp_termination.dp_s`2)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_s`1`1)), inn_dp_termination.dp_s`1`2))" "{(dp_: dependency_pairs[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].dep_pair_alt(inn_dp_termination.E), sigma_: substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].Sub) | booleans.AND(inn_dp_termination.inn_chained_dp?(inn_dp_termination.E)((rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].lhs(inn_dp_termination.dp_s`1`1), subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_s`1`1), inn_dp_termination.dp_s`1`2)), (rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].lhs(dp_`1), subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(dp_`1), dp_`2)))(inn_dp_termination.dp_s`2, sigma_), inn_dp_termination.minimal_innermost_non_terminating?(inn_dp_termination.E)(subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(sigma_)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(dp_`1)), dp_`2)))}")) (next_dp_and_sub_TCC7-1 nil 3761499258 ("" (subtype-tcc) nil nil) nil nil (next_dp_and_sub subtype "inn_dp_termination.dp_and_sub_from_int_nrnf(inn_dp_termination.E)(subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(inn_dp_termination.dp_s`2)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_s`1`1)), inn_dp_termination.dp_s`1`2))" "{(dp_: dependency_pairs[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].dep_pair_alt(inn_dp_termination.E), sigma_: substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].Sub) | booleans.AND(inn_dp_termination.inn_chained_dp?(inn_dp_termination.E)((rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].lhs(inn_dp_termination.dp_s`1`1), subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(inn_dp_termination.dp_s`1`1), inn_dp_termination.dp_s`1`2)), (rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].lhs(dp_`1), subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(dp_`1), dp_`2)))(inn_dp_termination.dp_s`2, sigma_), inn_dp_termination.minimal_innermost_non_terminating?(inn_dp_termination.E)(subterm[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].subtermOF(substitution[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].ext(sigma_)(rewrite_rules[inn_dp_termination.variable, inn_dp_termination.symbol, inn_dp_termination.arity].rhs(dp_`1)), dp_`2)))}"))) (inn_dp_termination_implies_noetherian 0 (inn_dp_termination_implies_noetherian-2 "" 3790334516 ("" (skeep) (("" (rewrite "inn_dp_termination_and_inn_alt_eq" :dir rl) (("" (expand "noetherian?") (("" (rewrite "no_infinite_descending_sequence") (("" (expand "empty?") (("" (expand "member") (("" (expand "descending?") (("" (expand "converse") (("" (skolem 1 "seqTerms") (("" (inst-cp -2 0) (("" (assert) (("" (case "NOT terminating?(innermost_reduction?(E))(seqTerms(0))") (("1" (use "inn_non_terminating_has_mint") (("1" (skeep) (("1" (hide -3 -4 1) (("1" (lemma "recursion_theorem[[dep_pair_alt(E), Sub]]") (("1" (name-replace "mint1" "subtermOF(seqTerms(0),p)") (("1" (inst -1 "{(dp: dep_pair_alt(E), sigma: Sub) | is_normal_form?(non_root_reduction?(E))(ext(sigma)(lhs(dp`1))) AND
                                                                minimal_innermost_non_terminating?(E)(subtermOF(ext(sigma)(rhs(dp`1)), dp`2))}" "dp_and_sub_from_int_nrnf(E)(mint1)" "next_dp_and_sub(E)") (("1" (skeep* :preds? t) (("1" (expand "inn_dp_termination_alt?") (("1" (inst -4 "LAMBDA(i:nat): u(i)`1" "LAMBDA(j:nat): u(j)`2") (("1" (expand "inn_infinite_dep_chain?") (("1" (skeep) (("1" (inst -2 "i") (("1" (typepred "u(i)") (("1" (typepred "u(i+1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (prop) nil nil)) nil) ("3" (expand "member") (("3" (assert) (("3" (expand "dp_and_sub_from_int_nrnf") (("3" (with-tccs (typepred "choose({(sigma: Sub),(e: rewrite_rule),(p: positions?(rhs(e)))
                                                                 |
                                                                 member(e, E)
                                                                 AND
                                                                 ext(sigma)(lhs(e))
                                                                 =
                                                                 mint_to_nit_nrnf(E)(mint1)
                                                                 AND
                                                                 minimal_innermost_non_terminating?
                                                                 (E)
                                                                 (subtermOF
                                                                  (ext(sigma)(rhs(e)),
                                                                   p))})")) (("3" (assert) (("3" (expand "mint_to_nit_nrnf") (("3" (with-tccs (typepred "choose({t: term
                                                           |
                                                           RTC
                                                           (non_root_innermost_reduction?(E))
                                                           (mint1, t)
                                                           AND
                                                           is_normal_form?
                                                           (non_root_reduction?(E))(t)
                                                           AND
                                                           NOT
                                                           terminating?
                                                           (innermost_reduction?(E))(t)})")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (typepred "dp") (("4" (expand "dep_pair_alt?") (("4" (flatten) (("4" (rewrite "ext_preserv_pos") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "dp_and_sub_from_int_nrnf(E)(subtermOF(seqTerms(0), p))") nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -4) (("2" (expand "terminating?") (("2" (inst 1 "seqTerms") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inn_dp_termination_and_inn_alt_eq formula-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (no_infinite_descending_sequence formula-decl nil well_foundedness orders) (pred type-eq-decl nil defined_types nil) (converse const-decl "pred[[T2, T1]]" relation_defs nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (member const-decl "bool" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (terminating? const-decl "bool" noetherian nil) (sequence type-eq-decl nil sequences nil) (recursion_theorem formula-decl nil seq_recursion_theorem nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (TRUE const-decl "bool" booleans nil) (minimal_innermost_non_terminating? const-decl "bool" inn_dp_termination nil) (mint1 skolem-const-decl "term[variable, symbol, arity]" inn_dp_termination nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_normal_form? const-decl "bool" ars_terminology nil) (non_root_reduction? const-decl "bool" reduction nil) (ext def-decl "term" substitution nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (dp_and_sub_from_int_nrnf const-decl "[dep_pair_alt(E), Sub]" inn_dp_termination nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (next_dp_and_sub const-decl "{(dp_: dep_pair_alt(E), sigma_: Sub) |
   inn_chained_dp?(E)
                  ((lhs(dp_s`1`1), subtermOF(rhs(dp_s`1`1), dp_s`1`2)),
                   (lhs(dp_`1), subtermOF(rhs(dp_`1), dp_`2)))
                  (dp_s`2, sigma_)
    AND
    minimal_innermost_non_terminating?(E)
                                      (subtermOF
                                       (ext(sigma_)(rhs(dp_`1)), dp_`2))}" inn_dp_termination nil) (inn_chained_dp? const-decl "bool" inn_dp_termination nil) (dep_pair type-eq-decl nil dependency_pairs nil) (dep_pair? const-decl "bool" dependency_pairs nil) (inn_dp_termination_alt? const-decl "bool" inn_dp_termination nil) (inn_infinite_dep_chain? const-decl "bool" inn_dp_termination nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (mint_to_nit_nrnf const-decl "term" inn_dp_termination nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (ext_preserv_pos formula-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (p skolem-const-decl "positions?[variable, symbol, arity](seqTerms(0))" inn_dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" inn_dp_termination nil) (seqTerms skolem-const-decl "sequence[term[variable, symbol, arity]]" inn_dp_termination nil) (inn_non_terminating_has_mint formula-decl nil inn_dp_termination nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (descending? const-decl "bool" monotone_sequences orders) (empty? const-decl "bool" sets nil) (noetherian? const-decl "bool" noetherian nil)) shostak) (inn_dp_termination_implies_noetherian-1 nil 3761502212 ("" (skeep) (("" (rewrite "inn_dp_termination_and_inn_alt_eq" :dir rl) (("" (expand "noetherian?") (("" (rewrite "no_infinite_descending_sequence") (("" (expand "empty?") (("" (expand "member") (("" (expand "descending?") (("" (expand "converse") (("" (skolem 1 "seqTerms") (("" (inst-cp -2 0) (("" (assert) (("" (case "NOT terminating?(innermost_reduction?(E))(seqTerms(0))") (("1" (use "inn_non_terminating_has_mint") (("1" (skeep) (("1" (hide -3 -4 1) (("1" (lemma "recursion_theorem[[dep_pair_alt(E), Sub]]") (("1" (name-replace "mint1" "subtermOF(seqTerms(0),p)") (("1" (inst -1 "{(dp: dep_pair_alt(E), sigma: Sub) | is_normal_form?(non_root_reduction?(E))(ext(sigma)(lhs(dp`1))) AND
                                                                minimal_innermost_non_terminating?(E)(subtermOF(ext(sigma)(rhs(dp`1)), dp`2))}" "dp_and_sub_from_int_nrnf(E)(mint1)" "next_dp_and_sub(E)") (("1" (skeep* :preds? t) (("1" (expand "inn_dp_termination_alt?") (("1" (inst -4 "LAMBDA(i:nat): u(i)`1" "LAMBDA(j:nat): u(j)`2") (("1" (expand "inn_infinite_dep_chain?") (("1" (skeep) (("1" (inst -2 "i") (("1" (typepred "u(i)") (("1" (typepred "u(i+1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (prop) (("1" (skeep) (("1" (prop) nil nil)) nil) ("2" (assert) (("2" (skeep :preds? t) (("2" (typepred "next_dp_and_sub(E)(x1)") (("2" (assert) (("2" (expand "inn_chained_dp?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "member") (("3" (assert) (("3" (expand "dp_and_sub_from_int_nrnf") (("3" (with-tccs (typepred "choose({(sigma: Sub),(e: rewrite_rule),(p: positions?(rhs(e)))
                                                                 |
                                                                 member(e, E)
                                                                 AND
                                                                 ext(sigma)(lhs(e))
                                                                 =
                                                                 mint_to_nit_nrnf(E)(mint1)
                                                                 AND
                                                                 minimal_innermost_non_terminating?
                                                                 (E)
                                                                 (subtermOF
                                                                  (ext(sigma)(rhs(e)),
                                                                   p))})")) (("3" (assert) (("3" (expand "mint_to_nit_nrnf") (("3" (with-tccs (typepred "choose({t: term
                                                           |
                                                           RTC
                                                           (non_root_innermost_reduction?(E))
                                                           (mint1, t)
                                                           AND
                                                           is_normal_form?
                                                           (non_root_reduction?(E))(t)
                                                           AND
                                                           NOT
                                                           terminating?
                                                           (innermost_reduction?(E))(t)})")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (typepred "dp") (("4" (expand "dep_pair_alt?") (("4" (flatten) (("4" (rewrite "ext_preserv_pos") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "dp_and_sub_from_int_nrnf(E)(subtermOF(seqTerms(0), p))") nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -4) (("2" (expand "terminating?") (("2" (inst 1 "seqTerms") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (no_infinite_descending_sequence formula-decl nil well_foundedness orders) (innermost_reduction? const-decl "bool" innermost_reduction nil) (member const-decl "bool" sets nil) (terminating? const-decl "bool" noetherian nil) (recursion_theorem formula-decl nil seq_recursion_theorem nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (is_normal_form? const-decl "bool" ars_terminology nil) (non_root_reduction? const-decl "bool" reduction nil) (ext def-decl "term" substitution nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (dep_pair type-eq-decl nil dependency_pairs nil) (dep_pair? const-decl "bool" dependency_pairs nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (non_root_innermost_reduction? const-decl "bool" innermost_reduction nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (ext_preserv_pos formula-decl nil substitution nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (descending? const-decl "bool" monotone_sequences orders) (empty? const-decl "bool" sets nil) (noetherian? const-decl "bool" noetherian nil)) nil)) (inn_dp_termination_iff_innermost_noetherian 0 (inn_dp_termination_iff_innermost_noetherian-1 nil 3761502238 ("" (skeep) (("" (prop) (("1" (rewrite "inn_dp_termination_implies_noetherian") nil nil) ("2" (rewrite "inn_noetherian_implies_inn_dp_termination") nil nil)) nil)) nil) ((set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (inn_dp_termination_implies_noetherian formula-decl nil inn_dp_termination nil) (inn_noetherian_implies_inn_dp_termination formula-decl nil inn_dp_termination nil)) nil)) (inn_dp_termination_noetherian 0 (inn_dp_termination_noetherian-1 nil 3761502266 ("" (skeep) (("" (expand "inn_dp_termination?") (("" (expand "noetherian?") (("" (lemma "no_infinite_descending_sequence[[dep_pair(E),Sub]]") (("" (inst?) (("" (prop) (("1" (hide -1 -2) (("1" (expand "empty?") (("1" (expand "member") (("1" (expand "converse") (("1" (expand "descending?") (("1" (expand "inn_chain") (("1" (expand "inn_infinite_dep_chain?") (("1" (skeep) (("1" (inst -2 "LAMBDA(i:nat): (seq(i),sigmas(i))") (("1" (skeep) (("1" (inst -1 "n" "1+n") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1 3) (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "descending?") (("2" (expand "converse") (("2" (expand "inn_infinite_dep_chain?") (("2" (expand "inn_chain") (("2" (skeep) (("2" (inst -1 "LAMBDA(i:nat): x(i)`1" "LAMBDA(i:nat): x(i)`2") (("2" (skeep) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inn_dp_termination? const-decl "bool" inn_dp_termination nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (dep_pair type-eq-decl nil dependency_pairs nil) (dep_pair? const-decl "bool" dependency_pairs nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" inn_dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil inn_dp_termination nil) (variable formal-nonempty-type-decl nil inn_dp_termination nil) (no_infinite_descending_sequence formula-decl nil well_foundedness orders) (empty? const-decl "bool" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sequence type-eq-decl nil sequences nil) (inn_infinite_dep_chain? const-decl "bool" inn_dp_termination nil) (descending? const-decl "bool" monotone_sequences orders) (member const-decl "bool" sets nil) (inn_chain const-decl "bool" inn_dp_termination nil) (converse const-decl "pred[[T2, T1]]" relation_defs nil) (pred type-eq-decl nil defined_types nil) (noetherian? const-decl "bool" noetherian nil)) nil)))
