(dp_termination (IMP_dependency_pairs_TCC1 0 (IMP_dependency_pairs_TCC1-1 nil 3765573363 ("" (rewrite "var_countable") nil nil) ((var_countable formula-decl nil dp_termination nil)) nil (IMP_dependency_pairs assuming "dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].dependency_pairs" "var_countable: ASSUMPTION countability[term_adt[dependency_pairs.variable, dependency_pairs.symbol, dependency_pairs.arity].term].is_countably_infinite(variables_term[dependency_pairs.variable, dependency_pairs.symbol, dependency_pairs.arity].V)"))) (dp_termination_alt?_TCC1 0 (dp_termination_alt?_TCC1-1 nil 3763209458 ("" (skeep* :preds? t) (("" (typepred "dps(i)") (("" (expand "dep_pair_alt?") (("" (flatten) nil nil)) nil)) nil)) nil) ((sequence type-eq-decl nil sequences nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (dp_termination_alt? subtype "dp_termination.dps(dp_termination.i)`2" "positions?[dp_termination.variable, dp_termination.symbol, dp_termination.arity](rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dps(dp_termination.i)`1))"))) (dp_termination_alt?_TCC2 0 (dp_termination_alt?_TCC2-1 nil 3763209458 ("" (skeep* :preds? t) (("" (replaces -2) (("" (assert) (("" (typepred "dps(x1)") (("" (expand "dep_pair_alt?") (("" (expand "dep_pair?") (("" (flatten) (("" (assert) (("" (inst?) (("" (assert) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sequence type-eq-decl nil sequences nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (dep_pair? const-decl "bool" dependency_pairs nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (rhs const-decl "term" rewrite_rules nil) (positions? type-eq-decl nil positions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (dp_termination_alt? subtype "dp_termination.seq" "sequence[dep_pair[variable, symbol, arity](E)]"))) (dp_termination_and_alt_eq 0 (dp_termination_and_alt_eq-1 nil 3763209469 ("" (skeep*) (("" (prop) (("1" (expand "dp_termination_alt?") (("1" (expand "dp_termination?") (("1" (skeep*) (("1" (inst -1 "(LAMBDA(i:nat): rule_and_pos_from_dp(E)(seq(i)))" "sigmas") (("1" (expand "infinite_dep_chain?") (("1" (skolem 1 ("i" "j")) (("1" (inst?) (("1" (flatten) (("1" (assert) (("1" (expand "chained_dp?") (("1" (assert) (("1" (expand "rule_and_pos_from_dp") (("1" (typepred "choose({(e: rewrite_rule), (p: position)
                                                                                                |
                                                                                                member(e, E)
                                                                                                AND
                                                                                                lhs(e) = seq(i)`1
                                                                                                AND
                                                                                                positionsOF(rhs(e))(p)
                                                                                                AND
                                                                                                subtermOF(rhs(e), p) = seq(i)`2})") (("1" (name-replace "choose1" "choose({(e: rewrite_rule), (p: position)
                                                                                                                    |
                                                                                                                    member(e, E)
                                                                                                                    AND
                                                                                                                    lhs(e) = seq(i)`1
                                                                                                                    AND
                                                                                                                    positionsOF(rhs(e))(p)
                                                                                                                    AND
                                                                                                                    subtermOF(rhs(e), p) = seq(i)`2})") (("1" (typepred "choose({(e: rewrite_rule), (p: position) |
                                                                                                            member(e, E) AND
                                                                                                             lhs(e) = seq(1 + i)`1 AND
                                                                                                              positionsOF(rhs(e))(p) AND
                                                                                                               subtermOF(rhs(e), p) = seq(1 + i)`2})") (("1" (name-replace "choose2" "choose({(e: rewrite_rule), (p: position) |
                                                                                                                                member(e, E) AND
                                                                                                                                 lhs(e) = seq(1 + i)`1 AND
                                                                                                                                  positionsOF(rhs(e))(p) AND
                                                                                                                                   subtermOF(rhs(e), p) = seq(1 + i)`2})") (("1" (replaces -8) (("1" (replaces -2) nil nil)) nil)) nil) ("2" (hide -6 3) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (typepred "seq(i + 1)") (("2" (expand "dep_pair?") (("2" (flatten) (("2" (skeep*) (("2" (inst -6 "(e,p)") (("2" (assert) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 3) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (typepred "seq(i)") (("2" (expand "dep_pair?") (("2" (flatten) (("2" (skeep*) (("2" (inst -6 "(e,p)") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (typepred "seq(i)") (("2" (hide -2) (("2" (expand "dep_pair?") (("2" (expand "dep_pair_alt?") (("2" (flatten) (("2" (assert) (("2" (skeep*) (("2" (expand "rule_and_pos_from_dp") (("2" (typepred "choose({(e: rewrite_rule), (p: position) |
                                                                                                 member(e, E) AND
                                                                                                  lhs(e) = seq(i)`1 AND
                                                                                                   positionsOF(rhs(e))(p) AND
                                                                                                    subtermOF(rhs(e), p) = seq(i)`2})") (("1" (assert) (("1" (name-replace "ee" "choose({(e: rewrite_rule), (p: position) |
                                         member(e, E) AND
                                          lhs(e) = seq(i)`1 AND
                                           positionsOF(rhs(e))(p) AND
                                            subtermOF(rhs(e), p) = seq(i)`2})") (("1" (hide-all-but (-1 1)) (("1" (expand "member") (("1" (expand "lhs") (("1" (typepred "ee`1") (("1" (expand "rewrite_rule?") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "(e,p)") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "dp_termination_alt?") (("2" (skeep) (("2" (expand "dp_termination?") (("2" (inst -1 "(LAMBDA(i:nat): (lhs(dps(i)`1), subtermOF(rhs(dps(i)`1),dps(i)`2)))" "sigmas") (("1" (skeep) (("1" (hide -) (("1" (typepred "dps(i)") (("1" (expand "dep_pair_alt?") (("1" (expand "dep_pair?") (("1" (flatten) (("1" (assert) (("1" (expand "defined?") (("1" (assert) (("1" (inst 1 "dps(i)`1") (("1" (assert) (("1" (inst 1 "dps(i)`2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "dps(i)") (("2" (expand "dep_pair_alt?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dp_termination? const-decl "bool" dp_termination nil) (seq skolem-const-decl "sequence[dep_pair[variable, symbol, arity](E)]" dp_termination nil) (sequence type-eq-decl nil sequences nil) (rule_and_pos_from_dp const-decl "[rewrite_rule, position]" dependency_pairs nil) (dep_pair type-eq-decl nil dependency_pairs nil) (dep_pair? const-decl "bool" dependency_pairs nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (chained_dp? const-decl "bool" dp_termination nil) (empty? const-decl "bool" sets nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (rhs const-decl "term" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (lhs const-decl "term" rewrite_rules nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (infinite_dep_chain? const-decl "bool" dp_termination nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (dp_termination_alt? const-decl "bool" dp_termination nil) (dps skolem-const-decl "sequence[dep_pair_alt[variable, symbol, arity](E)]" dp_termination nil) (defined? const-decl "bool" rewrite_rules nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil)) (noetherian_implies_dp_termination 0 (noetherian_implies_dp_termination-1 nil 3763209509 ("" (skeep) (("" (lemma "dp_termination_and_alt_eq") (("" (inst?) (("" (assert) (("" (hide 2) (("" (rewrite "R_is_Noet_iff_TC_is") (("" (assert) (("" (expand "noetherian?") (("" (expand "dp_termination_alt?") (("" (rewrite "no_infinite_descending_sequence") (("" (expand "empty?") (("" (skeep :preds? t) (("" (expand "member") (("" (expand "descending?") (("" (expand "converse") (("" (assert) (("" (inst -2 "(LAMBDA(i:nat): term_pos_dps_alt(E)(dps,sigmas,i)`1)") (("" (induct "n") (("1" (assert) (("1" (expand "term_pos_dps_alt") (("1" (expand "term_pos_dps_alt") (("1" (typepred "dps(0)" "dps(1)") (("1" (expand "dep_pair_alt?") (("1" (flatten) (("1" (expand "infinite_dep_chain?") (("1" (inst -11 0 1) (("1" (assert) (("1" (expand "chained_dp?") (("1" (lemma "non_root_subset_reduction") (("1" (inst?) (("1" (lemma "Closure_monotony") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (hide -1 -2 -3 -5 -6) (("1" (expand "subset?") (("1" (expand "member") (("1" (inst?) (("1" (assert) (("1" (lemma "reduction_is_subs_op") (("1" (inst -1 "E") (("1" (flatten) (("1" (lemma "lhs_reduces_to_rhs") (("1" (inst -1 "E" "dps(1)`1") (("1" (expand "close_subs?") (("1" (inst -2 "lhs(dps(1)`1)" "rhs(dps(1)`1)" "sigmas(1)") (("1" (assert) (("1" (rewrite "comp_op_iff_comp_cont") (("1" (lemma "closure_comp_cont") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (hide -1) (("1" (expand "comp_cont?" -1) (("1" (inst -1 "dps(0)`2" "ext(sigmas(0))(rhs(dps(0)`1))") (("1" (rewrite "ext_preserv_pos") (("1" (inst -1 "ext(sigmas(0))(subtermOF(rhs(dps(0)`1), dps(0)`2))" "ext(sigmas(1))(lhs(dps(1)`1))") (("1" (assert) (("1" (expand "TC" 1) (("1" (expand "RTC" -1) (("1" (expand "IUnion") (("1" (skeep*) (("1" (inst 1 "i+1") (("1" (lemma "iterate_add_applied") (("1" (inst -1 "reduction?(E)" "i" "1" "replaceTerm(ext(sigmas(0))(rhs(dps(0)`1)),ext(sigmas(0))(subtermOF(rhs(dps(0)`1), dps(0)`2)),dps(0)`2)" "replaceTerm(ext(sigmas(0))(rhs(dps(0)`1)),
                                                                                                      ext(sigmas(1))(lhs(dps(1)`1)),
                                                                                                      dps(0)`2)" "replaceTerm(ext(sigmas(0))(rhs(dps(0)`1)),
                                                                                                      ext(sigmas(1))(rhs(dps(1)`1)),
                                                                                                      dps(0)`2)") (("1" (assert) (("1" (rewrite "iterate_1") (("1" (prop) (("1" (lemma "replace_subterm_of_term") (("1" (inst -1 "dps(0)`2" "ext(sigmas(0))(rhs(dps(0)`1))") (("1" (rewrite "ext_preserv_pos") (("1" (lemma "subterm_of_ext") (("1" (inst -1 "dps(0)`2" "empty_seq" "sigmas(0)" "rhs(dps(0)`1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -6 2) (("2" (expand "comp_cont?") (("2" (inst -3 "dps(0)`2" "ext(sigmas(0))(rhs(dps(0)`1))") (("2" (rewrite "ext_preserv_pos") (("2" (inst -3 "ext(sigmas(1))(lhs(dps(1)`1))" "ext(sigmas(1))(rhs(dps(1)`1))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (expand "term_pos_dps_alt" 1) (("2" (expand "term_pos_dps_alt" 1 (3 4)) (("2" (expand "term_pos_dps_alt" -1 2) (("2" (expand "infinite_dep_chain?") (("2" (inst -2 "1+j" "2+j") (("2" (assert) (("2" (expand "chained_dp?") (("2" (lemma "non_root_subset_reduction") (("2" (inst?) (("2" (lemma "Closure_monotony") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (hide -1 -2 -3 -5 -6) (("2" (expand "subset?") (("2" (expand "member") (("2" (inst?) (("2" (assert) (("2" (typepred "dps(1+j)" "dps(2+j)") (("2" (expand "dep_pair_alt?") (("2" (flatten) (("2" (lemma "lhs_reduces_to_rhs") (("2" (inst-cp -1 "E" "dps(1 + j)`1") (("2" (inst -1 "E" "dps(2 + j)`1") (("2" (lemma "ext_preserv_pos") (("2" (inst-cp -1 "dps(1 + j)`2" "rhs(dps(1 + j)`1)" "sigmas(1 + j)") (("2" (assert) (("2" (inst -1 "dps(2 + j)`2" "rhs(dps(2 + j)`1)" "sigmas(2 + j)") (("2" (assert) (("2" (lemma "reduction_is_subs_op") (("2" (inst -1 "E") (("2" (flatten) (("2" (expand "close_subs?") (("2" (inst-cp -1 "lhs(dps(1 + j)`1)" "rhs(dps(1 + j)`1)" "sigmas(1 + j)") (("2" (assert) (("2" (inst -1 "lhs(dps(2 + j)`1)" "rhs(dps(2 + j)`1)" "sigmas(2 + j)") (("2" (assert) (("2" (rewrite "replace_associativity") (("2" (hide -6 -7 -8 -9 -10 -11 -12 -13 -14 -15 -16 -17 -20) (("2" (rewrite "comp_op_iff_comp_cont") (("2" (lemma "closure_comp_cont") (("2" (inst?) (("2" (assert) (("2" (flatten) (("2" (hide -3) (("2" (expand "comp_cont?" -5) (("2" (inst-cp -5 "dps(1 + j)`2" "ext(sigmas(1 + j))(rhs(dps(1 + j)`1))") (("2" (assert) (("2" (inst -6 "ext(sigmas(2 + j))(lhs(dps(2 + j)`1))" "ext(sigmas(2 + j))(rhs(dps(2 + j)`1))") (("2" (assert) (("2" (hide -3) (("2" (expand "comp_cont?" -2) (("2" (inst-cp -2 "dps(1 + j)`2" "ext(sigmas(1 + j))(rhs(dps(1 + j)`1))") (("2" (assert) (("2" (inst -3 "ext(sigmas(1 + j))
                                                     (subtermOF(rhs(dps(1 + j)`1), dps(1 + j)`2))" "ext(sigmas(2 + j))(lhs(dps(2 + j)`1))") (("2" (assert) (("2" (lemma "replace_subterm_of_term") (("2" (inst -1 "dps(1 + j)`2" "ext(sigmas(1 + j))(rhs(dps(1 + j)`1))") (("2" (assert) (("2" (lemma "subterm_of_ext") (("2" (inst -1 "dps(1 + j)`2" "empty_seq" "sigmas(1 + j)" "rhs(dps(1 + j)`1)") (("2" (assert) (("2" (replace -1 -5 rl) (("2" (replace -2 -5) (("2" (hide -1 -2) (("2" (typepred "term_pos_dps_alt(E)(dps, sigmas, j)") (("2" (inst -3 "term_pos_dps_alt(E)(dps, sigmas, j)`2" "term_pos_dps_alt(E)(dps, sigmas, j)`1") (("2" (assert) (("2" (inst -3 "ext(sigmas(1 + j))(rhs(dps(1 + j)`1))" "replaceTerm(ext(sigmas(1 + j))(rhs(dps(1 + j)`1)),ext(sigmas(2 + j))
                                                                   (lhs(dps(2 + j)`1)),
                                                                dps(1 + j)`2)") (("2" (assert) (("2" (hide -4) (("2" (expand "RTC") (("2" (expand "TC" 1) (("2" (expand "IUnion") (("2" (skeep) (("2" (inst 1 "i + 1") (("2" (lemma "iterate_add_applied") (("2" (inst -1 "reduction?(E)" "i" "1" "replaceTerm(term_pos_dps_alt(E)(dps, sigmas, j)`1,
                                                                    ext(sigmas(1 + j))
                                                                       (rhs(dps(1 + j)`1)),
                                                                    term_pos_dps_alt(E)(dps, sigmas, j)`2)" "replaceTerm(term_pos_dps_alt(E)(dps, sigmas, j)`1,
                                                                    replaceTerm(ext
                                                                                (sigmas(1 + j))
                                                                                (rhs(dps(1 + j)`1)),
                                                                                ext
                                                                                (sigmas(2 + j))
                                                                                (lhs(dps(2 + j)`1)),
                                                                                dps(1 + j)`2),
                                                                    term_pos_dps_alt(E)(dps, sigmas, j)`2)" "replaceTerm(term_pos_dps_alt(E)(dps, sigmas, j)`1,
                                                                    replaceTerm(ext
                                                                                (sigmas(1 + j))
                                                                                (rhs(dps(1 + j)`1)),
                                                                                ext
                                                                                (sigmas(2 + j))
                                                                                (rhs(dps(2 + j)`1)),
                                                                                dps(1 + j)`2),
                                                                    term_pos_dps_alt(E)(dps, sigmas, j)`2)") (("2" (assert) (("2" (hide-all-but (-1 -5 -6 1)) (("2" (inst - "term_pos_dps_alt(E)(dps, sigmas, j)`2" "term_pos_dps_alt(E)(dps, sigmas, j)`1") (("2" (assert) (("2" (inst -2 "replaceTerm(ext(sigmas(1 + j))(rhs(dps(1 + j)`1)),ext(sigmas(2 + j))
                                                                          (lhs(dps(2 + j)`1)),
                                                                       dps(1 + j)`2)" "replaceTerm(ext(sigmas(1 + j))(rhs(dps(1 + j)`1)),ext(sigmas(2 + j))
                                                                          (rhs(dps(2 + j)`1)),
                                                                       dps(1 + j)`2)") (("2" (assert) (("2" (rewrite "iterate_1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dp_termination_and_alt_eq formula-decl nil dp_termination nil) (R_is_Noet_iff_TC_is formula-decl nil noetherian nil) (PRED type-eq-decl nil defined_types nil) (reduction? const-decl "bool" reduction nil) (noetherian? const-decl "bool" noetherian nil) (no_infinite_descending_sequence formula-decl nil well_foundedness orders) (pred type-eq-decl nil defined_types nil) (converse const-decl "pred[[T2, T1]]" relation_defs nil) (transitive? const-decl "bool" relations nil) (transitive type-eq-decl nil relations_closure nil) (TC const-decl "transitive" relations_closure nil) (transitive_converse application-judgement "(transitive?[T])" relation_converse_props nil) (descending? const-decl "bool" monotone_sequences orders) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat_induction formula-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (chained_dp? const-decl "bool" dp_termination nil) (non_root_reduction? const-decl "bool" reduction nil) (subset? const-decl "bool" sets nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (ext def-decl "term" substitution nil) (reduction_is_subs_op formula-decl nil reduction nil) (comp_op_iff_comp_cont formula-decl nil compatibility nil) (comp_cont? const-decl "bool" compatibility nil) (ext_preserv_pos formula-decl nil substitution nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (TRUE const-decl "bool" booleans nil) (iterate_add_applied formula-decl nil relation_iterate orders) (subterm_of_ext formula-decl nil substitution nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (replace_subterm_of_term formula-decl nil replacement nil) (iterate_1 formula-decl nil relation_iterate orders) (replaceTerm def-decl "term" replacement nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IUnion const-decl "set[T]" indexed_sets nil) (closure_comp_cont formula-decl nil compatibility nil) (close_subs? const-decl "bool" reduction nil) (lhs_reduces_to_rhs formula-decl nil reduction nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (Closure_monotony formula-decl nil relations_closure nil) (non_root_subset_reduction formula-decl nil reduction nil) (infinite_dep_chain? const-decl "bool" dp_termination nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (replace_associativity formula-decl nil replacement nil) (int_minus_int_is_int application-judgement "int" integers nil) (j skolem-const-decl "nat" dp_termination nil) (dps skolem-const-decl "sequence[dep_pair_alt[variable, symbol, arity](E)]" dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (sequence type-eq-decl nil sequences nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (term_pos_dps_alt def-decl "{(t, p) | positionsOF(t)(p)}" dependency_pairs nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (dp_termination_alt? const-decl "bool" dp_termination nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil)) nil)) (mnt_is_app 0 (mnt_is_app-2 nil 3762593796 ("" (skeep) (("" (expand "minimal_non_terminating?") (("" (flatten) (("" (hide -1) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((minimal_non_terminating? const-decl "bool" dp_termination nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (Vars const-decl "set[(V)]" subterm nil) (subset? const-decl "bool" sets nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (empty_seq const-decl "finseq" finite_sequences nil) (only_empty_seq const-decl "positions" positions nil) (subtermOF def-decl "term" subterm nil) (replaceTerm def-decl "term" replacement nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (e!1 skolem-const-decl "{e | member(e, E)}" dp_termination nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (union const-decl "set" sets nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (finseq type-eq-decl nil finite_sequences nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (seq!1 skolem-const-decl "sequence[term[variable, symbol, arity]]" dp_termination nil) (sigma!1 skolem-const-decl "Sub[variable, symbol, arity]" dp_termination nil) (= const-decl "[T, T -> boolean]" equalities nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](seq!1(0))" dp_termination nil) (ext def-decl "term" substitution nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (positions? type-eq-decl nil positions nil) (sequence type-eq-decl nil sequences nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (NOT const-decl "[bool -> bool]" booleans nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (reduction? const-decl "bool" reduction nil) (term type-decl nil term_adt nil) (terminating? const-decl "bool" noetherian nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Dom const-decl "set[(V)]" substitution nil) (/= const-decl "boolean" notequal nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil)) nil) (mnt_is_app-1 nil 3760195666 ("" (skeep) (("" (expand "minimal_innermost_non_terminating?") (("" (flatten) (("" (hide -1) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (ext def-decl "term" substitution nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (finseq type-eq-decl nil finite_sequences nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (union const-decl "set" sets nil) (catenate const-decl "positions" positions nil) (add_first const-decl "finseq" seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (replaceTerm def-decl "term" replacement nil) (subtermOF def-decl "term" subterm nil) (only_empty_seq const-decl "positions" positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (subset? const-decl "bool" sets nil) (Vars const-decl "set[(V)]" subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (reduction_fix? const-decl "bool" reduction nil) (non_root_reduction? const-decl "bool" reduction nil) (reducible? const-decl "bool" ars_terminology nil) (is_normal_form? const-decl "bool" ars_terminology nil) (innermost_reduction_fix? const-decl "bool" innermost_reduction nil) (innermost_reduction? const-decl "bool" innermost_reduction nil) (terminating? const-decl "bool" noetherian nil) (Dom const-decl "set[(V)]" substitution nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil)) shostak)) (args_minimal 0 (args_minimal-1 nil 3762527423 ("" (skeep :preds? t) (("" (expand "minimal_non_terminating?") (("" (prop) (("1" (expand "finseq_appl") (("1" (skeep) (("1" (inst -1 "#(i+1)") (("1" (expand "subtermOF") (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (expand "#") (("1" (expand "rest") (("1" (expand "^") (("1" (rewrite "subterm_empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (prop) (("1" (hide 2 3) (("1" (grind) (("1" (inst 1 "1+i") (("1" (inst 1 "empty_seq") (("1" (prop) (("1" (expand "positionsOF") (("1" (expand "only_empty_seq") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "empty_seq") (("2" (propax) nil nil)) nil) ("3" (decompose-equality 1) (("3" (skeep :preds? t) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (skolem 1 "ps") (("2" (typepred "ps") (("2" (case "length(ps)=1") (("1" (inst -3 "first(ps) - 1") (("1" (expand "subtermOF") (("1" (expand "empty_seq") (("1" (decompose-equality 1) (("1" (expand "finseq_appl") (("1" (expand "rest") (("1" (expand "^") (("1" (rewrite "subterm_empty_seq") nil nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "first(ps)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil) ("2" (inst -2 "#(first(ps))`seq(0) - 1") (("1" (expand "#") (("1" (lemma "terminating_all_subterms") (("1" (inst -1 "E" "subtermOF(t, #(ps`seq(0)))") (("1" (assert) (("1" (lemma "pos_subterm") (("1" (inst -1 "#(ps`seq(0))" "rest(ps)" "t") (("1" (prop) (("1" (inst -2 "rest(ps)") (("1" (assert) (("1" (replace -3 -2 rl) (("1" (hide -3) (("1" (case "#(ps`seq(0)) o rest(ps) = ps") (("1" (assert) nil nil) ("2" (hide-all-but (1 2 3)) (("2" (grind) (("1" (decompose-equality 3) (("1" (decompose-equality) nil nil)) nil) ("2" (decompose-equality 2) (("1" (decompose-equality) (("1" (typepred "x!1") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "n") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 1) (("2" (hide 4) (("2" (expand "subtermOF") (("2" (expand "finseq_appl") (("2" (expand "first") (("2" (expand "finseq_appl") (("2" (expand "#") (("2" (expand "rest") (("2" (expand "^") (("2" (rewrite "subterm_empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 1 2 3)) (("3" (case "#(ps`seq(0)) o rest(ps) = ps") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (grind) (("1" (decompose-equality 3) (("1" (decompose-equality) nil nil)) nil) ("2" (decompose-equality 2) (("1" (decompose-equality) (("1" (typepred "x!1") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "n") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 1 3 6 7) (("4" (expand "subtermOF") (("4" (expand "finseq_appl") (("4" (expand "first") (("4" (expand "rest") (("4" (expand "#") (("4" (expand "^") (("4" (expand "finseq_appl") (("4" (rewrite "subterm_empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "#") (("2" (expand "positionsOF") (("2" (expand "only_empty_seq") (("2" (expand "union") (("2" (expand "member") (("2" (assert) (("2" (prop) (("2" (expand "IUnion") (("2" (skeep) (("2" (expand "catenate") (("2" (expand "finseq_appl") (("2" (skeep) (("2" (inst 2 "i_1") (("2" (inst 2 "empty_seq") (("2" (prop) (("1" (expand "member") (("1" (hide -1) (("1" (expand "positionsOF") (("1" (expand "only_empty_seq") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (expand "union") (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 3)) (("3" (expand "empty_seq") (("3" (decompose-equality 2) (("3" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "first(ps)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("3" (expand "empty_seq") (("3" (decompose-equality 3) (("3" (decompose-equality) nil nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minimal_non_terminating? const-decl "bool" dp_termination nil) (terminating_all_subterms formula-decl nil reduction nil) (O const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (pos_subterm formula-decl nil subterm nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (ps skolem-const-decl "{p: positions?(t) | NOT p = empty_seq}" dp_termination nil) (not_empty_seq type-eq-decl nil seq_extras structures) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (rhs const-decl "term" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (TRUE const-decl "bool" booleans nil) (epsilon const-decl "T" epsilons nil) (pred type-eq-decl nil defined_types nil) (FALSE const-decl "bool" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (i skolem-const-decl "below[length(args(t))]" dp_termination nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (t skolem-const-decl "{t: term |
   app?(t) AND length(args(t)) > 0 AND NOT terminating?(reduction?(E))(t)}" dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (reduction? const-decl "bool" reduction nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (terminating? const-decl "bool" noetherian nil) (PRED type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (positions? type-eq-decl nil positions nil) (int_minus_int_is_int application-judgement "int" integers nil) (first const-decl "T" seq_extras structures) (^ const-decl "finseq" finite_sequences nil) (subterm_empty_seq formula-decl nil subterm nil) (rest const-decl "finseq" seq_extras structures) (subtermOF def-decl "term" subterm nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (<= const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (only_empty_seq const-decl "positions" positions nil) (member const-decl "bool" sets nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (union const-decl "set" sets nil)) nil)) (non_terminating_has_mnt 0 (non_terminating_has_mnt-1 nil 3760195556 ("" (skeep) (("" (induct "t") (("1" (typepred "t!1") (("1" (propax) nil nil)) nil) ("2" (skeep :preds? t) (("2" (hide 2) (("2" (expand "terminating?") (("2" (skeep) (("2" (inst -2 0) (("2" (assert) (("2" (use "reducible_is_app") (("2" (assert) (("2" (expand "reducible?") (("2" (inst 1 "seq(1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (case "arity(app1_var) =0") (("1" (hide -3) (("1" (inst 2 "empty_seq") (("1" (rewrite "subterm_empty_seq") (("1" (expand "minimal_non_terminating?") (("1" (assert) (("1" (skeep :preds? t) (("1" (expand "positionsOF") (("1" (assert) (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "empty_seq_is_position") nil nil)) nil)) nil) ("2" (expand "terminating?" 2) (("2" (skeep*) (("2" (case "minimal_non_terminating?(E)(app(app1_var, app2_var))") (("1" (inst 2 "empty_seq") (("1" (rewrite "subterm_empty_seq") nil nil) ("2" (use "empty_seq_is_position") nil nil)) nil) ("2" (case "FORALL(t:term | app?(t) AND length(args(t)) > 0 AND 
    	   NOT terminating?(reduction?(E))(t)):
      minimal_non_terminating?(E)(t) IFF
         FORALL(i: below[length(args(t))]): 
	  terminating?(reduction?(E))(args(t)(i))") (("1" (inst -1 "app(app1_var, app2_var)") (("1" (assert) (("1" (skeep) (("1" (inst -2 "i") (("1" (expand "finseq_appl") (("1" (prop) (("1" (skeep) (("1" (inst 4 "add_first(i+1,p)") (("1" (expand "subtermOF" 4) (("1" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (expand "first") (("2" (expand "finseq_appl") (("2" (expand "add_first") (("2" (assert) (("2" (case "insert?[posnat](1 + i, p, 0)`seq(0) - 1 = i AND rest(insert?(1 + i, p, 0)) = p") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (prop) (("1" (expand "insert?") (("1" (propax) nil nil)) nil) ("2" (expand "insert?") (("2" (expand "rest") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (expand "^") (("2" (grind) (("1" (decompose-equality 2) (("1" (decompose-equality) nil nil)) nil) ("2" (decompose-equality 2) (("2" (decompose-equality) nil nil)) nil) ("3" (decompose-equality 4) (("1" (decompose-equality) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "p") (("2" (hide -2 -5 2 3) (("2" (expand "positionsOF" 1) (("2" (expand "union") (("2" (expand "member") (("2" (expand "only_empty_seq") (("2" (prop) (("2" (expand "IUnion") (("2" (inst 2 "i+1") (("2" (expand "catenate") (("2" (inst 2 "p") (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -3 3) (("2" (expand "minimal_non_terminating?") (("2" (prop) (("1" (expand "terminating?") (("1" (inst 1 "seq") (("1" (prop) nil nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (hide-all-but (-1 -2 2)) (("2" (lemma "terminating_all_subterms") (("2" (inst -1 "E" "app[variable, symbol, arity](app1_var, app2_var)") (("2" (assert) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "args_minimal") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((term type-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (terminating? const-decl "bool" noetherian nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (reduction? const-decl "bool" reduction nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (subtermOF def-decl "term" subterm nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (term_induction formula-decl nil term_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (reducible? const-decl "bool" ars_terminology nil) (sequence type-eq-decl nil sequences nil) (reducible_is_app formula-decl nil reduction nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (app1_var skolem-const-decl "symbol" dp_termination nil) (app2_var skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var)}" dp_termination nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (only_empty_seq const-decl "positions" positions nil) (subterm_empty_seq formula-decl nil subterm nil) (empty_seq_is_position formula-decl nil positions nil) (TRUE const-decl "bool" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (terminating_all_subterms formula-decl nil reduction nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (add_first const-decl "finseq" seq_extras structures) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "below[length(app2_var)]" dp_termination nil) (p skolem-const-decl "positions?[variable, symbol, arity](app2_var`seq(i))" dp_termination nil) (insert? const-decl "finseq" seq_extras structures) (^ const-decl "finseq" finite_sequences nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FALSE const-decl "bool" booleans nil) (even? const-decl "bool" integers nil) (uint8 type-eq-decl nil integertypes nil) (exp2 def-decl "posnat" exp2 nil) (pred type-eq-decl nil defined_types nil) (epsilon const-decl "T" epsilons nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rest const-decl "finseq" seq_extras structures) (upto nonempty-type-eq-decl nil nat_types nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (first const-decl "T" seq_extras structures) (int_minus_int_is_int application-judgement "int" integers nil) (union const-decl "set" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (member const-decl "bool" sets nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (args_minimal formula-decl nil dp_termination nil)) nil)) (positions_of_infnr_reduction 0 (positions_of_infnr_reduction-1 nil 3760196789 ("" (skeep* :preds? t) (("" (inst 1 "LAMBDA(i:nat): choose({p: positions?(seqt(i)) | NOT p = empty_seq AND reduction_fix?(E)(seqt(i), seqt(i + 1), p)})") (("1" (skeep) (("1" (typepred "choose({p: positions?(seqt(j)) | NOT p = empty_seq AND
                                   reduction_fix?(E)
                                                            (seqt(j),
                                                             seqt(j + 1),
                                                             p)})") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -2 "j") (("2" (expand "non_root_reduction?") (("2" (skeep) (("2" (inst?) (("2" (expand "reduction_fix?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "non_root_reduction?") (("2" (inst -2 "i") (("2" (skeep) (("2" (inst?) (("2" (expand "reduction_fix?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (reduction_fix? const-decl "bool" reduction nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (seqt skolem-const-decl "sequence[term[variable, symbol, arity]]" dp_termination nil) (sequence type-eq-decl nil sequences nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (choose const-decl "(p)" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (member const-decl "bool" sets nil) (non_root_reduction? const-decl "bool" reduction nil) (empty? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (positions_of_inf_reduction 0 (positions_of_inf_reduction-1 nil 3763232164 ("" (skeep* :preds? t) (("" (inst 1 "LAMBDA(i:nat): choose({p: positions?(seqt(i)) | reduction_fix?(E)(seqt(i), seqt(i + 1), p)})") (("1" (skeep) (("1" (typepred "choose({p: positions?(seqt(j)) | 
                                       reduction_fix?(E)
                                                                (seqt(j),
                                                                 seqt(j + 1),
                                                                 p)})") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -2 "j") (("2" (expand "reduction?") (("2" (skeep) (("2" (inst?) (("2" (expand "reduction_fix?") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (expand "reduction?") (("2" (inst -2 "i") (("2" (skeep) (("2" (inst?) (("2" (expand "reduction_fix?") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (reduction_fix? const-decl "bool" reduction nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (seqt skolem-const-decl "sequence[term[variable, symbol, arity]]" dp_termination nil) (sequence type-eq-decl nil sequences nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (choose const-decl "(p)" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (reduction? const-decl "bool" reduction nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (empty? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil)) (exists_inf_red_arg_in_inf_nr_red_TCC1 0 (exists_inf_red_arg_in_inf_nr_red_TCC1-2 "" 3790334291 ("" (skeep :preds? t) nil nil) nil shostak (exists_inf_red_arg_in_inf_nr_red subtype "dp_termination.seqt(0)" "(term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].app?)")) (exists_inf_red_arg_in_inf_nr_red_TCC1-1 nil 3765557633 ("" (skeep :preds? t) (("" (inst?) (("" (flatten) (("" (use "reducible_is_app") (("" (assert) (("" (expand "reducible?") (("" (expand "reduction_fix?") (("" (skeep) (("" (inst 1 "seqt(1)") (("" (assert) (("" (expand "reduction?") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (exists_inf_red_arg_in_inf_nr_red subtype "dp_termination.seqt(0)" "(term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].app?)"))) (exists_inf_red_arg_in_inf_nr_red_TCC2 0 (exists_inf_red_arg_in_inf_nr_red_TCC2-1 nil 3765557633 ("" (skeep* :preds? t) (("" (inst -3 "i") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (exists_inf_red_arg_in_inf_nr_red subtype "dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (i: naturalnumbers.nat): (booleans.NOT)(seqp(i) = finite_sequences[posnat].empty_seq)}"))) (exists_inf_red_arg_in_inf_nr_red 0 (exists_inf_red_arg_in_inf_nr_red-2 "" 3790334292 ("" (skeep* :preds? t) (("" (lemma "infinite_pigeonhole[nat, {l: posnat | l<= length(args(seqt(0)))}]") (("1" (inst -1 "args_of_pos_seq(seqp)") (("1" (skolem -1 "l") (("1" (typepred "l") (("1" (inst 2 "l") (("1" (expand "inf_red_arg_in_inf_nr_im_red") (("1" (expand "singleton") (("1" (expand "inverse_image") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (case "RTC(non_root_reduction?(E))(seqt(0), seqt(x1))") (("1" (expand "args_of_pos_seq") (("1" (use "non_root_rtc_preserves_root_symbol") (("1" (assert) (("1" (flatten) (("1" (inst -4 "x1") (("1" (flatten) (("1" (hide -3 -5) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "seq_of_relation_RTC") (("2" (assert) (("2" (skeep) (("2" (inst?) (("2" (flatten) (("2" (expand "non_root_reduction?") (("2" (inst 1 "seqp(k)") (("2" (typepred "seqp") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) (("3" (inst -2 "i") (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_finite_type") (("2" (inst 1 "length(args(seqt(0))) + 1" "LAMBDA(l: posnat | l <= length(args(seqt(0)))): l") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil) ("3" (hide-all-but -1) (("3" (expand "is_finite_type") (("3" (lemma "infinite_def[nat]") (("3" (inst -1 "{x:nat | x >=0}") (("3" (prop) (("1" (expand "is_finite") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sequence type-eq-decl nil sequences nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (<= const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (infinite_pigeonhole formula-decl nil infinite_pigeonhole orders) (NOT const-decl "[bool -> bool]" booleans nil) (is_finite_type const-decl "bool" finite_sets nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_reduction? const-decl "bool" reduction nil) (non_root_rtc_preserves_root_symbol formula-decl nil reduction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (first const-decl "T" seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (union const-decl "set" sets nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (k skolem-const-decl "{k: nat | k < x1}" dp_termination nil) (x1 skolem-const-decl "nat" dp_termination nil) (seq_of_relation_RTC formula-decl nil relations_closure nil) (singleton const-decl "(singleton?)" sets nil) (member const-decl "bool" sets nil) (inverse_image const-decl "set[D]" function_image nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (position type-eq-decl nil positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (seqt skolem-const-decl "{seqt: sequence[term[variable, symbol, arity]] | app?(seqt(0))}" dp_termination nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (seqp skolem-const-decl "{seqp: sequence[position[variable, symbol, arity]] |
   FORALL (n: nat):
     positionsOF(seqt(n))(seqp(n)) AND
      NOT empty_seq = seqp(n) AND
       reduction_fix?(E)(seqt(n), seqt(1 + n), seqp(n))}" dp_termination nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (injective? const-decl "bool" functions nil) (N skolem-const-decl "nat" dp_termination nil) (g skolem-const-decl "[nat -> below[N]]" dp_termination nil) (is_finite const-decl "bool" finite_sets nil) (infinite_def formula-decl nil infinite_nat_def sets_aux) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak) (exists_inf_red_arg_in_inf_nr_red-1 nil 3765557673 ("" (skeep* :preds? t) (("" (lemma "infinite_pigeonhole[nat, {l: posnat | l<= length(args(seqt(0)))}]") (("1" (inst -1 "args_of_pos_seq(seqp)") (("1" (skolem -1 "l") (("1" (typepred "l") (("1" (inst 2 "l") (("1" (expand "inf_red_arg_in_inf_nr_im_red") (("1" (expand "singleton") (("1" (expand "inverse_image") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (case "RTC(non_root_reduction?(E))(seqt(0), seqt(x1))") (("1" (expand "args_of_pos_seq") (("1" (use "non_root_rtc_preserves_root_symbol") (("1" (assert) (("1" (flatten) (("1" (inst -4 "x1") (("1" (flatten) (("1" (hide -3 -5) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "seq_of_relation_RTC") (("2" (assert) (("2" (skeep) (("2" (inst?) (("2" (flatten) (("2" (expand "non_root_reduction?") (("2" (inst 1 "seqp(k)") (("2" (typepred "seqp") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) (("3" (inst -2 "i") (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_finite_type") (("2" (inst 1 "length(args(seqt(0))) + 1" "LAMBDA(l: posnat | l <= length(args(seqt(0)))): l") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil) ("3" (hide-all-but -1) (("3" (expand "is_finite_type") (("3" (lemma "infinite_def[nat]") (("3" (inst -1 "{x:nat | x >=0}") (("3" (prop) (("1" (expand "is_finite") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (expand "injective?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term type-decl nil term_adt nil) (infinite_pigeonhole formula-decl nil infinite_pigeonhole orders) (is_finite_type const-decl "bool" finite_sets nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_reduction? const-decl "bool" reduction nil) (non_root_rtc_preserves_root_symbol formula-decl nil reduction nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (first const-decl "T" seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (union const-decl "set" sets nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (seq_of_relation_RTC formula-decl nil relations_closure nil) (singleton const-decl "(singleton?)" sets nil) (member const-decl "bool" sets nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (is_finite const-decl "bool" finite_sets nil) (infinite_def formula-decl nil infinite_nat_def sets_aux)) nil)) (exists_nth_in_inf_nr_red_TCC1 0 (exists_nth_in_inf_nr_red_TCC1-1 nil 3765559456 ("" (skeep* :preds? t) (("" (inst -3 "i") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (exists_nth_in_inf_nr_red subtype "dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (i: naturalnumbers.nat): (booleans.NOT)(seqp(i) = finite_sequences[posnat].empty_seq)}"))) (exists_nth_in_inf_nr_red_TCC2 0 (exists_nth_in_inf_nr_red_TCC2-2 nil 3765569845 ("" (skolem 1 ("E" "seqt" "seqp" "l1" "m")) (("" (prop) (("" (expand "is_finite") (("" (inst 1 "m" "LAMBDA(k: nat |
                             args_of_pos_seq(seqp)(k) = l1 AND
                              k < m): k") (("" (expand "injective?") (("" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (position type-eq-decl nil positions nil) (sequence type-eq-decl nil sequences nil) (NOT const-decl "[bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (< const-decl "bool" reals nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil)) nil (exists_nth_in_inf_nr_red subtype "{k: naturalnumbers.nat | booleans.AND(dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].args_of_pos_seq(dp_termination.seqp)(k) = dp_termination.l, reals.<(k, dp_termination.m))}" "finite_set[nat]")) (exists_nth_in_inf_nr_red_TCC2-1 nil 3765559456 ("" (subtype-tcc) nil nil) nil nil (exists_nth_in_inf_nr_red subtype "{k: naturalnumbers.nat | booleans.AND(dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].args_of_pos_seq(dp_termination.seqp)(k) = dp_termination.l, reals.<(k, dp_termination.m))}" "finite_set[nat]"))) (exists_nth_in_inf_nr_red 0 (exists_nth_in_inf_nr_red-1 nil 3765559491 ("" (skeep) (("" (skeep) (("" (skeep :preds? t) (("" (skeep :preds? t) (("" (with-tccs (induct "n")) (("1" (expand "inf_red_arg_in_inf_nr_im_red") (("1" (expand "inverse_image") (("1" (expand "member") (("1" (expand "singleton") (("1" (use "infinite_nonempty[nat]") (("1" (inst 1 "min({x: nat | args_of_pos_seq(seqp)(x) = l})") (("1" (with-tccs (typepred "min({x: nat |
                                                                                                                              args_of_pos_seq(seqp)(x) = l})")) (("1" (prop) (("1" (hide -1) (("1" (with-tccs (case "nonempty?({k: nat |
                                                                                 args_of_pos_seq(seqp)(k) = l AND
                                                                                  k < min({x: nat | args_of_pos_seq(seqp)(x) = l})})")) (("1" (with-tccs (name "nnat" "choose({k: nat |
                                                                                                                                                                                                                                                        args_of_pos_seq(seqp)(k) = l AND
                                                                                                                                                                                                                                                         k <
                                                                                                                                                                                                                                                          min({x: nat | args_of_pos_seq(seqp)(x) = l})})")) (("1" (inst -3 "nnat") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "nonempty_card[nat]") (("2" (hide-all-but (-1 1 2)) (("2" (with-tccs (name-replace "sset" "{k: nat |
                                                                  args_of_pos_seq(seqp)(k) = l AND
                                                                   k < min({x: nat | args_of_pos_seq(seqp)(x) = l})}")) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -5 "i") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "i") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep* :preds? t) (("2" (case "nonempty?({x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})") (("1" (case "is_finite[nat]({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m})") (("1" (inst 1 " min({x: nat |
                                                                                                                                                  args_of_pos_seq(seqp)(x) = l AND x > m})") (("1" (prop) (("1" (typepred "min({x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})") (("1" (propax) nil nil) ("2" (propax) nil nil)) nil) ("2" (with-tccs (case "{k: nat |
                                                                                      args_of_pos_seq(seqp)(k) = l AND
                                                                                       k < min({x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})} = add(m,{x: nat | args_of_pos_seq(seqp)(x) = l AND x < m})")) (("1" (replaces -1) (("1" (use " card_add[nat]") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "add") (("2" (hide -6 2) (("2" (expand "member") (("2" (decompose-equality) (("2" (iff) (("2" (typepred "min({x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})") (("2" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst?) (("2" (assert) nil nil)) nil) ("3" (inst?) (("3" (assert) nil nil)) nil) ("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -4 1)) (("2" (expand "is_finite") (("2" (inst 1 "m" "LAMBDA(k: nat |
                                                                                                                                                   args_of_pos_seq(seqp)(k) = l AND k < m): k") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "l") (("2" (expand "inf_red_arg_in_inf_nr_im_red") (("2" (expand "inverse_image") (("2" (expand "singleton") (("2" (expand "member") (("2" (case "{x: nat | args_of_pos_seq(seqp)(x) = l} = union({x: nat | args_of_pos_seq(seqp)(x) = l AND x <= m}, {x: nat | args_of_pos_seq(seqp)(x) = l AND x > m})") (("1" (replace -1 1) (("1" (lemma "infinite_union[nat]") (("1" (inst? -1) (("1" (assert) (("1" (prop) (("1" (hide-all-but (-2 1)) (("1" (expand "is_finite") (("1" (inst 1 "m+1" "LAMBDA (x: nat |
                                                                                                                                                                       args_of_pos_seq(seqp)(x) = l AND x <= m) : x") (("1" (expand "injective?") (("1" (skeep) nil nil)) nil) ("2" (typepred "seqp") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "infinite_nonempty[nat]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "union") (("2" (expand "member") (("2" (decompose-equality) (("2" (iff) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (injective? const-decl "bool" functions nil) (m skolem-const-decl "nat" dp_termination nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (add const-decl "(nonempty?)" sets nil) (card_add formula-decl nil finite_sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (infinite_union formula-decl nil infinite_sets_def nil) (union const-decl "set" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[posnat]" positions nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability sets_aux) (member const-decl "bool" sets nil) (infinite_nonempty judgement-tcc nil infinite_sets_def nil) (infinite_set type-eq-decl nil infinite_sets_def nil) (nonempty_card formula-decl nil finite_sets nil) (choose const-decl "(p)" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (nonempty? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (inverse_image const-decl "set[D]" function_image nil) (seqt skolem-const-decl "{seqt: sequence[term[variable, symbol, arity]] | app?(seqt(0))}" dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (seqp skolem-const-decl "{seqp: sequence[position[variable, symbol, arity]] |
   FORALL (n: nat):
     positionsOF(seqt(n))(seqp(n)) AND
      NOT empty_seq = seqp(n) AND
       reduction_fix?(E)(seqt(n), seqt(1 + n), seqp(n))}" dp_termination nil) (l skolem-const-decl "{l: posnat |
   l <= length(args(seqt(0))) AND inf_red_arg_in_inf_nr_im_red(seqp)(l)}" dp_termination nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (< const-decl "bool" reals nil) (is_finite const-decl "bool" finite_sets nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (position type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (sequence type-eq-decl nil sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil)) (nth_index_std_TCC1 0 (nth_index_std_TCC2-1 nil 3765568262 ("" (skolem 1 ("E" "seqt" "seqp" "l1" "n")) (("" (typepred ("E" "seqt" "seqp" "l1" "n")) (("" (lemma "exists_nth_in_inf_nr_red") (("" (inst -1 "E" "seqt" "seqp" "l1" "n") (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (skeep) (("" (assert) (("" (inst? -9) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (sequence type-eq-decl nil sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (empty? const-decl "bool" sets nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (exists_nth_in_inf_nr_red formula-decl nil dp_termination nil)) nil (nth_index_std subtype "{m: naturalnumbers.nat | booleans.AND(dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].args_of_pos_seq(dp_termination.seqp)(m) = dp_termination.l, finite_sets[nat].card({k: naturalnumbers.nat | booleans.AND(dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].args_of_pos_seq(dp_termination.seqp)(k) = dp_termination.l, reals.<(k, m))}) = dp_termination.n)}" "(sets[nat].nonempty?)"))) (nth_index_std_increasing_TCC1 0 (nth_index_std_increasing_TCC1-1 nil 3765568262 ("" (skeep* :preds? t) nil nil) nil nil (nth_index_std_increasing subtype "dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (n: naturalnumbers.nat): booleans.AND(positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positionsOF(dp_termination.seqt(n))(seqp(n)), booleans.AND((booleans.NOT)(finite_sequences[posnat].empty_seq = seqp(n)), reduction[dp_termination.variable, dp_termination.symbol, dp_termination.arity].reduction_fix?(dp_termination.E)(dp_termination.seqt(n), dp_termination.seqt((number_fields.+)(1, n)), seqp(n))))}"))) (nth_index_std_increasing 0 (nth_index_std_increasing-1 nil 3765568280 ("" (skeep* :preds? t) (("" (expand "nth_index_std") (("" (with-tccs (typepred "choose({m: nat |
                                              args_of_pos_seq(seqp)(m) = l AND
                                               card({k: nat |
                                                       args_of_pos_seq(seqp)(k) = l AND k < m})
                                                = i})")) (("" (with-tccs (name-replace "ith_index" "choose({m: nat |
                                                          args_of_pos_seq(seqp)(m) = l AND
                                                           card({k: nat |
                                                                   args_of_pos_seq(seqp)(k) = l AND k < m})
                                                            = i})")) (("" (with-tccs (name-replace "jth_index" "choose({m: nat |
                                                                       args_of_pos_seq(seqp)(m) = l AND
                                                                        card({k: nat |
                                                                                args_of_pos_seq(seqp)(k) = l AND k < m})
                                                                         = j})")) (("" (case "subset?({k_1: nat | args_of_pos_seq(seqp)(k_1) = l AND k_1 < jth_index},
                                                                                                                            {k_1: nat | args_of_pos_seq(seqp)(k_1) = l AND k_1 < ith_index})") (("1" (with-tccs (use "card_subset[nat]") :tcc-step (skip)) (("1" (expand "is_finite") (("1" (inst 1 "jth_index" "LAMBDA(i:nat | args_of_pos_seq[variable, symbol, arity](seqp)(i) =
                                      l AND i < jth_index): i") (("1" (expand "injective?") (("1" (skeep) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?") (("2" (expand "member") (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth_index_std const-decl "nat" dp_termination nil) (subset? const-decl "bool" sets nil) (injective? const-decl "bool" functions nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (card_subset formula-decl nil finite_sets nil) (ith_index skolem-const-decl "({m: nat |
    args_of_pos_seq(seqp)(m) = l AND
     card({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m}) = i})" dp_termination nil) (jth_index skolem-const-decl "({m: nat |
    args_of_pos_seq(seqp)(m) = l AND
     card({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m}) = j})" dp_termination nil) (j skolem-const-decl "{j: nat | i < j}" dp_termination nil) (i skolem-const-decl "nat" dp_termination nil) (l skolem-const-decl "{l: posnat |
   l <= length(args(seqt(0))) AND inf_red_arg_in_inf_nr_im_red(seqp)(l)}" dp_termination nil) (seqp skolem-const-decl "{seqp: sequence[position[variable, symbol, arity]] |
   FORALL (n: nat):
     positionsOF(seqt(n))(seqp(n)) AND
      NOT empty_seq = seqp(n) AND
       reduction_fix?(E)(seqt(n), seqt(1 + n), seqp(n))}" dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (seqt skolem-const-decl "{seqt: sequence[term[variable, symbol, arity]] | app?(seqt(0))}" dp_termination nil) (member const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (position type-eq-decl nil positions nil) (sequence type-eq-decl nil sequences nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (< const-decl "bool" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil)) (nth_index_std_continuous_TCC1 0 (nth_index_std_continuous_TCC1-1 nil 3765568342 ("" (skeep* :preds? t) nil nil) nil nil (nth_index_std_continuous subtype "dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (n: naturalnumbers.nat): booleans.AND(positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positionsOF(dp_termination.seqt(n))(seqp(n)), booleans.AND((booleans.NOT)(finite_sequences[posnat].empty_seq = seqp(n)), reduction[dp_termination.variable, dp_termination.symbol, dp_termination.arity].reduction_fix?(dp_termination.E)(dp_termination.seqt(n), dp_termination.seqt((number_fields.+)(1, n)), seqp(n))))}"))) (nth_index_std_continuous_TCC2 0 (nth_index_std_continuous_TCC2-1 nil 3765568342 ("" (skeep* :preds? t) (("" (expand "is_finite") (("" (inst 1 "nth_index_std(E)(seqt)(seqp)(l)(i + 1)" "LAMBDA(k_1: nat |
                               args_of_pos_seq(seqp)(k_1) = l AND
                                k_1 < nth_index_std(E)(seqt)(seqp)(l)(i + 1)): k_1") (("" (expand "injective?") (("" (skeep) nil nil)) nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (< const-decl "bool" reals nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (nth_index_std const-decl "nat" dp_termination nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (sequence type-eq-decl nil sequences nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (nth_index_std_continuous subtype "{k_1: naturalnumbers.nat | booleans.AND(dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].args_of_pos_seq(dp_termination.seqp)(k_1) = dp_termination.l, reals.<(k_1, dp_termination.nth_index_std(dp_termination.E)(dp_termination.seqt)(dp_termination.seqp)(dp_termination.l)((number_fields.+)(dp_termination.i, 1))))}" "finite_set[nat]"))) (nth_index_std_continuous_TCC3 0 (nth_index_std_continuous_TCC3-1 nil 3765568342 ("" (skeep* :preds? t) (("" (expand "is_finite") (("" (inst 1 "nth_index_std(E)(seqt)(seqp)(l)(i)" "LAMBDA(k_1: nat |
                               args_of_pos_seq(seqp)(k_1) = l AND
                                k_1 < nth_index_std(E)(seqt)(seqp)(l)(i)): k_1") (("" (expand "injective?") (("" (skeep) nil nil)) nil)) nil)) nil)) nil) ((is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (< const-decl "bool" reals nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (nth_index_std const-decl "nat" dp_termination nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (sequence type-eq-decl nil sequences nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (nth_index_std_continuous subtype "{k_1: naturalnumbers.nat | booleans.AND(dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].args_of_pos_seq(dp_termination.seqp)(k_1) = dp_termination.l, reals.<(k_1, dp_termination.nth_index_std(dp_termination.E)(dp_termination.seqt)(dp_termination.seqp)(dp_termination.l)(dp_termination.i)))}" "finite_set[nat]"))) (nth_index_std_continuous 0 (nth_index_std_continuous-5 "" 3804707798 ("" (skeep* :preds? t) (("" (expand "nth_index_std") (("" (with-tccs (typepred "choose({m: nat |
                                                         args_of_pos_seq(seqp)(m) = l AND
                                                          card({k: nat |
                                                                  args_of_pos_seq(seqp)(k) = l AND
                                                                   k < m})
                                                           = 1 + i})") :tcc-step (skip)) (("1" (with-tccs (name-replace "i1nth_index_std" "choose({m: nat |
                                                                               args_of_pos_seq(seqp)(m) = l AND
                                                                                card({k: nat |
                                                                                        args_of_pos_seq(seqp)(k) = l AND
                                                                                         k < m})
                                                                                 = 1 + i})")) (("1" (with-tccs (typepred "choose({m: nat | args_of_pos_seq(seqp)(m) = l AND card({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m}) = i})") :tcc-step (then (flatten) (subtype-tcc :exclude ("V" "Dom" "args_of_pos_seq" "inverse_image" "is_finite" "injective?")))) (("1" (hide 2) (("1" (skeep) (("1" (expand "is_finite") (("1" (inst 1 "m" "LAMBDA(k: nat |
                                                                 args_of_pos_seq(seqp)(k) = l AND k < m): k") (("1" (expand "injective?") (("1" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_red") (("2" (inst -1 "E" "seqt" "seqp" "l" "1 + i") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                                                 args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth_index_std const-decl "nat" dp_termination nil) (exists_nth_in_inf_nr_red formula-decl nil dp_termination nil) (int_minus_int_is_int application-judgement "int" integers nil) (injective? const-decl "bool" functions nil) (seqt skolem-const-decl "{seqt: sequence[term[variable, symbol, arity]] | app?(seqt(0))}" dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (seqp skolem-const-decl "{seqp: sequence[position[variable, symbol, arity]] |
   FORALL (n: nat):
     positionsOF(seqt(n))(seqp(n)) AND
      NOT empty_seq = seqp(n) AND
       reduction_fix?(E)(seqt(n), seqt(1 + n), seqp(n))}" dp_termination nil) (l skolem-const-decl "{l: posnat |
   l <= length(args(seqt(0))) AND inf_red_arg_in_inf_nr_im_red(seqp)(l)}" dp_termination nil) (i skolem-const-decl "nat" dp_termination nil) (rhs const-decl "term" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[posnat]" positions nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[nat]" countability sets_aux) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (position type-eq-decl nil positions nil) (sequence type-eq-decl nil sequences nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (< const-decl "bool" reals nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (finite_set type-eq-decl nil finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak) (nth_index_std_continuous-4 "" 3804362530 ("" (skeep* :preds? t) (("" (expand "nth_index_std") (("" (with-tccs (typepred "choose({m: nat |
                                                   args_of_pos_seq(seqp)(m) = l AND
                                                    card({k: nat |
                                                            args_of_pos_seq(seqp)(k) = l AND
                                                             k < m})
                                                     = 1 + i})") :tcc-step (skip)) (("1" (with-tccs (name-replace "i1nth_index_std" "choose({m: nat |
                                                                     args_of_pos_seq(seqp)(m) = l AND
                                                                      card({k: nat |
                                                                              args_of_pos_seq(seqp)(k) = l AND
                                                                               k < m})
                                                                       = 1 + i})")) (("1" (with-tccs (typepred "choose({m: nat | args_of_pos_seq(seqp)(m) = l AND card({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m}) = i})") :tcc-step (then (flatten) (subtype-tcc :exclude ("V" "Dom" "args_of_pos_seq" "inverse_image" "is_finite" "injective?")))) (("1" (with-tccs (name-replace "ith_index" "choose({m: nat |
                                                                                       args_of_pos_seq(seqp)(m) = l AND
                                                                                        card({k: nat |
                                                                                                args_of_pos_seq(seqp)(k) = l
                                                                                                AND
                                                                                                k < m})
                                                                                         = i})")) (("1" (assert) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_red") (("2" (inst -1 "E" "seqt" "seqp" "l" "1 + i") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                                         args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (finite_set type-eq-decl nil finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)) shostak) (nth_index_std_continuous-3 nil 3765569043 ("" (skeep* :preds? t) (("" (expand "nth_index_std") (("" (with-tccs (typepred "choose({m: nat |
                                                args_of_pos_seq(seqp)(m) = l AND
                                                 card({k: nat |
                                                         args_of_pos_seq(seqp)(k) = l AND
                                                          k < m})
                                                  = 1 + i})") :tcc-step (skip)) (("1" (with-tccs (name-replace "i1nth_index_std" "choose({m: nat |
                                                                args_of_pos_seq(seqp)(m) = l AND
                                                                 card({k: nat |
                                                                         args_of_pos_seq(seqp)(k) = l AND
                                                                          k < m})
                                                                  = 1 + i})")) (("1" (with-tccs (typepred "choose({m: nat |
                                                                  args_of_pos_seq(seqp)(m) = l AND
                                                                   card({k: nat |
                                                                           args_of_pos_seq(seqp)(k) = l
                                                                           AND
                                                                           k < m})
                                                                    = i})")) (("1" (with-tccs (name-replace "ith_index" "choose({m: nat |
                                                                                  args_of_pos_seq(seqp)(m) = l AND
                                                                                   card({k: nat |
                                                                                           args_of_pos_seq(seqp)(k) = l
                                                                                           AND
                                                                                           k < m})
                                                                                    = i})")) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_red") (("2" (inst -1 "E" "seqt" "seqp" "l" "1 + i") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                                     args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (first const-decl "T" seq_extras structures) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (finite_set type-eq-decl nil finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)) nil) (nth_index_std_continuous-2 nil 3765568906 ("" (skeep* :preds? t) (("" (expand "nth_index_std") (("" (with-tccs (typepred "choose({m: nat |
                                          args_of_pos_seq(seqp)(m) = l AND
                                           card({k: nat |
                                                   args_of_pos_seq(seqp)(k) = l AND
                                                    k < m})
                                            = 1 + i})")) (("1" (with-tccs (name-replace "i1nth_index_std" "choose({m: nat |
                                                      args_of_pos_seq(seqp)(m) = l AND
                                                       card({k: nat |
                                                               args_of_pos_seq(seqp)(k) = l AND
                                                                k < m})
                                                        = 1 + i})")) (("1" (with-tccs (typepred "choose({m: nat |
                                                        args_of_pos_seq(seqp)(m) = l AND
                                                         card({k: nat |
                                                                 args_of_pos_seq(seqp)(k) = l
                                                                 AND
                                                                 k < m})
                                                          = i})")) (("1" (with-tccs (name-replace "ith_index" "choose({m: nat |
                                                                    args_of_pos_seq(seqp)(m) = l AND
                                                                     card({k: nat |
                                                                             args_of_pos_seq(seqp)(k) = l
                                                                             AND
                                                                             k < m})
                                                                      = i})")) (("1" (assert) nil))) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_red") (("2" (inst -1 "E" "seqt(0)" "seqt" "seqp" "l" "i") (("2" (skeep) (("2" (inst -3 "m") (("2" (assert) nil))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                                     args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil))))))))))))))) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_red") (("2" (inst -1 "E" "seqt(0)" "seqt" "seqp" "l" "1 + i") (("2" (skeep) (("2" (inst?) (("2" (assert) nil))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                             args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil)))))))))))))))) nil) nil nil) (nth_index_std_continuous-1 nil 3765568387 ("" (skeep* :preds? t) (("" (expand "nth_index_std") (("" (with-tccs (typepred "choose({m: nat |
                                       args_of_pos_seq(seqp)(m) = l AND
                                        card({k: nat |
                                                args_of_pos_seq(seqp)(k) = l AND
                                                 k < m})
                                         = 1 + i})")) (("1" (with-tccs (name-replace "i1nth_index_std" "choose({m: nat |
                                                 args_of_pos_seq(seqp)(m) = l AND
                                                  card({k: nat |
                                                          args_of_pos_seq(seqp)(k) = l AND
                                                           k < m})
                                                   = 1 + i})")) (("1" (with-tccs (typepred "choose({m: nat |
                                                   args_of_pos_seq(seqp)(m) = l AND
                                                    card({k: nat |
                                                            args_of_pos_seq(seqp)(k) = l
                                                            AND
                                                            k < m})
                                                     = i})")) (("1" (with-tccs (name-replace "ith_index" "choose({m: nat |
                                                             args_of_pos_seq(seqp)(m) = l AND
                                                              card({k: nat |
                                                                      args_of_pos_seq(seqp)(k) = l
                                                                      AND
                                                                      k < m})
                                                               = i})")) (("1" (assert) nil))) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_red") (("2" (inst -1 "E" "seqt(0)" "seqt" "seqp" "l" "i") (("2" (skeep) (("2" (inst -3 "m") (("2" (assert) nil))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                               args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil))))))))))))))) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (lemma "exists_nth_in_inf_nr_red") (("2" (inst -1 "E" "seqt(0)" "seqt" "seqp" "l" "1 + i") (("2" (skeep) (("2" (inst?) (("2" (assert) nil))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (expand "is_finite") (("3" (inst 1 "m" "LAMBDA(k: nat |
                                         args_of_pos_seq(seqp)(k) = l AND k < m): k") (("3" (expand "injective?") (("3" (skeep) nil)))))))))))))))) nil) nil nil)) (argument_protected_in_non_nth_index_std_TCC1 0 (argument_protected_in_non_nth_index_std_TCC1-1 nil 3765569246 ("" (skeep* :preds? t) nil nil) nil nil (argument_protected_in_non_nth_index_std subtype "dp_termination.seqp" "{seqp: sequences[position[variable, symbol, arity]].sequence | FORALL (n: naturalnumbers.nat): booleans.AND(positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positionsOF(dp_termination.seqt(n))(seqp(n)), booleans.AND((booleans.NOT)(finite_sequences[posnat].empty_seq = seqp(n)), reduction[dp_termination.variable, dp_termination.symbol, dp_termination.arity].reduction_fix?(dp_termination.E)(dp_termination.seqt(n), dp_termination.seqt((number_fields.+)(1, n)), seqp(n))))}"))) (argument_protected_in_non_nth_index_std_TCC2 0 (argument_protected_in_non_nth_index_std_TCC2-1 nil 3765569246 ("" (skeep* :preds? t) (("" (inst -2 "j") (("" (flatten) (("" (assert) (("" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (empty_seq const-decl "finseq" finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (sequence type-eq-decl nil sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (empty_0 formula-decl nil seq_extras structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (argument_protected_in_non_nth_index_std subtype "dp_termination.seqp(dp_termination.j)" "not_empty_seq[posnat]"))) (argument_protected_in_non_nth_index_std 0 (argument_protected_in_non_nth_index_std-1 nil 3765569307 ("" (skeep* :preds? t) (("" (prop) (("1" (expand "nth_index_std") (("1" (with-tccs (typepred "choose({m: nat |
                                                args_of_pos_seq(seqp)(m) = l AND
                                                 card({k: nat |
                                                         args_of_pos_seq(seqp)(k) = l AND
                                                          k < m})
                                                  = 0})")) (("1" (with-tccs (name-replace "zeroth_index" "choose({m: nat |
                                                             args_of_pos_seq(seqp)(m) = l AND
                                                              card({k: nat |
                                                                      args_of_pos_seq(seqp)(k) =
                                                                       l
                                                                       AND k < m})
                                                               = 0})")) (("1" (lemma "card_empty?[nat]") (("1" (inst?) (("1" (assert) (("1" (iff) (("1" (prop) (("1" (hide -1 -4) (("1" (expand "empty?") (("1" (expand "member") (("1" (inst -1 "j") (("1" (assert) (("1" (expand "args_of_pos_seq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_finite") (("2" (inst 1 "zeroth_index" "LAMBDA(k_1: nat |
                                                                 args_of_pos_seq(seqp)(k_1) = l AND
                                                                  k_1 < zeroth_index): k_1") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "nth_index_std_continuous") (("2" (inst?) (("2" (assert) (("2" (expand "nth_index_std") (("2" (with-tccs (typepred "choose({m: nat |
                                                    args_of_pos_seq(seqp)(m) = l AND
                                                     card({k: nat |
                                                             args_of_pos_seq(seqp)(k) = l AND k < m})
                                                      = 1 + n})")) (("2" (with-tccs (name-replace "n1_index" "choose({m: nat |
                                                            args_of_pos_seq(seqp)(m) = l AND
                                                             card({k: nat |
                                                                     args_of_pos_seq(seqp)(k) = l AND k < m})
                                                              = 1 + n})")) (("2" (with-tccs (typepred "choose({m: nat |
                                                                args_of_pos_seq(seqp)(m) = l AND
                                                                 card({k: nat |
                                                                         args_of_pos_seq(seqp)(k) = l AND k < m})
                                                                  = n})") :tcc-step (skip)) (("1" (with-tccs (name-replace "n_index" "choose({m: nat |
                                                                                  args_of_pos_seq(seqp)(m) = l AND
                                                                                   card({k: nat |
                                                                                           args_of_pos_seq(seqp)(k) = l AND k < m})
                                                                                    = n})")) (("1" (typepred "min({m : nat | m > n_index AND m <= j AND
                                                                               args_of_pos_seq(seqp)(m) = l})") (("1" (name-replace "min_j_index" "min({m: nat |
                                                                                           m > n_index AND
                                                                                            m <= j AND args_of_pos_seq(seqp)(m) = l})") (("1" (case "strict_subset?({k: nat | args_of_pos_seq(seqp)(k) = l AND k < n_index}, {k_1: nat |
                                                                                                                                                        args_of_pos_seq(seqp)(k_1) = l AND k_1 < min_j_index})") (("1" (use "card_strict_subset[nat]") (("1" (assert) (("1" (replace -8) (("1" (case "strict_subset?({k_1: nat |
                                                                                                                                                                                            args_of_pos_seq(seqp)(k_1) = l AND k_1 < min_j_index}, {k: nat | args_of_pos_seq(seqp)(k) = l AND k < n1_index})") (("1" (hide -3) (("1" (use "card_strict_subset[nat]") (("1" (assert) nil nil) ("2" (expand "is_finite") (("2" (inst 1 "n1_index" "LAMBDA(k_1: nat |
                                                                                                                                                                                         args_of_pos_seq(seqp)(k_1) = l AND
                                                                                                                                                                                          k_1 < n1_index): k_1") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil) ("3" (expand "is_finite") (("3" (inst 1 "min_j_index" "LAMBDA(k_1: nat |
                                                                                                                                                                           args_of_pos_seq(seqp)(k_1) = l AND
                                                                                                                                                                            k_1 < min_j_index): k_1") (("3" (expand "injective?") (("3" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "strict_subset?") (("2" (prop) (("1" (expand "subset?") (("1" (expand "member") (("1" (skeep) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (decompose-equality -1) (("2" (inst -1 "min_j_index") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_finite") (("2" (inst 1 "min_j_index" "LAMBDA(k_1: nat |
                                                                                                                                       args_of_pos_seq(seqp)(k_1) = l AND
                                                                                                                                        k_1 < min_j_index): k_1") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil) ("3" (expand "is_finite") (("3" (inst 1 "n_index" "LAMBDA(k_1: nat |
                                                                                                                                       args_of_pos_seq(seqp)(k_1) = l AND
                                                                                                                                        k_1 < n_index): k_1") (("3" (expand "injective?") (("3" (skeep) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "strict_subset?") (("2" (prop) (("1" (expand "subset?") (("1" (expand "member") (("1" (skeep) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (decompose-equality -1) (("2" (inst -1 "n_index") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -1 "j") (("2" (assert) (("2" (hide-all-but (-14 1)) (("2" (expand "args_of_pos_seq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "is_finite") (("2" (inst 1 "m" "LAMBDA(k: nat |
                                                                           args_of_pos_seq(seqp)(k) = l AND
                                                                            k < m): k") (("2" (expand "injective?") (("2" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((< const-decl "bool" reals nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (nonempty? const-decl "bool" sets nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (sequence type-eq-decl nil sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (choose const-decl "(p)" sets nil) (card_empty? formula-decl nil finite_sets nil) (injective? const-decl "bool" functions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (zeroth_index skolem-const-decl "({m: nat |
    args_of_pos_seq(seqp)(m) = l AND
     card({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m}) = 0})" dp_termination nil) (l skolem-const-decl "{l: posnat |
   l <= length(args(seqt(0))) AND inf_red_arg_in_inf_nr_im_red(seqp)(l)}" dp_termination nil) (seqp skolem-const-decl "{seqp: sequence[position[variable, symbol, arity]] |
   FORALL (n: nat):
     positionsOF(seqt(n))(seqp(n)) AND
      NOT empty_seq = seqp(n) AND
       reduction_fix?(E)(seqt(n), seqt(1 + n), seqp(n))}" dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (seqt skolem-const-decl "{seqt: sequence[term[variable, symbol, arity]] | app?(seqt(0))}" dp_termination nil) (nth_index_std const-decl "nat" dp_termination nil) (nth_index_std_continuous formula-decl nil dp_termination nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (strict_subset? const-decl "bool" sets nil) (strict_subset_is_strict_order name-judgement "(strict_order?[set[T]])" sets_lemmas nil) (n1_index skolem-const-decl "({m: nat |
    args_of_pos_seq(seqp)(m) = l AND
     card({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m}) = 1 + n})" dp_termination nil) (subset? const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (n skolem-const-decl "nat" dp_termination nil) (n_index skolem-const-decl "({m: nat |
    args_of_pos_seq(seqp)(m) = l AND
     card({k: nat | args_of_pos_seq(seqp)(k) = l AND k < m}) = n})" dp_termination nil) (j skolem-const-decl "nat" dp_termination nil) (min_j_index skolem-const-decl "{a |
   (a > n_index AND a <= j AND args_of_pos_seq(seqp)(a) = l) AND
    FORALL (x: nat):
      x > n_index AND x <= j AND args_of_pos_seq(seqp)(x) = l IMPLIES
       a <= x}" dp_termination nil) (card_strict_subset formula-decl nil finite_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil)) (inf_deriv_of_mnt_has_min_root_reduction_index 0 (inf_deriv_of_mnt_has_min_root_reduction_index-2 nil 3785694325 ("" (skeep :preds? t) (("" (case "FORALL (n: nat):
                                    RTC(non_root_reduction?[variable, symbol, arity](E))
                                        (seqt(0), seqt(n)) AND NOT seqp(n) = empty_seq") (("1" (lemma "exists_inf_red_arg_in_inf_nr_red") (("1" (inst -1 "E" "seqt" "seqp") (("1" (hide 1) (("1" (skeep :preds? t) (("1" (copy -6) (("1" (expand "minimal_non_terminating?" -1) (("1" (flatten) (("1" (hide 1) (("1" (inst -1 "#(l)") (("1" (expand "terminating?") (("1" (with-tccs (inst 1 "LAMBDA(i:nat): IF i=0 THEN subtermOF(seqt(0), #(l)) ELSE subtermOF(seqt(nth_index_std(E)(seqt)(seqp)(l)(i - 1) + 1), #(l)) ENDIF") :tcc-step (skip)) (("1" (skeep) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (replaces -1) (("2" (case-replace "subtermOF(seqt(0),  #(l)) =
                                         subtermOF(seqt(nth_index_std(E)(seqt)(seqp)(l)(0)), #(l))" :hide? t) (("1" (with-tccs (name-replace "n1th_index_std" "nth_index_std(E)(seqt)(seqp)(l)(0)")) (("1" (inst -5 "n1th_index_std") (("1" (flatten) (("1" (case "first(seqp(n1th_index_std)) = l") (("1" (case " #(l) o rest(seqp(n1th_index_std)) = seqp(n1th_index_std)") (("1" (expand "reduction?") (("1" (expand "reduction_fix?") (("1" (skeep* :preds? t) (("1" (inst 2 "e" "sigma" "rest(seqp(n1th_index_std))") (("1" (lemma "pos_subterm") (("1" (inst -1 " #(l)" "rest(seqp(n1th_index_std))" "seqt(n1th_index_std)") (("1" (assert) (("1" (use "replace_distributivity") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "pos_subterm_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "seq_first_rest_1[posnat]") (("2" (assert) (("2" (hide-all-but (-5 1)) (("2" (inst -1 "n1th_index_std") (("2" (flatten) (("2" (use "empty_0[posnat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n1th_index_std") (("2" (expand "nth_index_std") (("2" (expand "args_of_pos_seq") (("2" (with-tccs (typepred "choose({m: nat |
                                                             first(seqp(m)) = l AND
                                                              card({k: nat | first(seqp(k)) = l AND k < m}) =
                                                               0})")) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (inst -1 "n1th_index_std") (("3" (flatten) (("3" (use "empty_0[posnat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "fseq_t" "(#length := nth_index_std(E)(seqt)(seqp)(l)(0) + 1,
                                                             seq := LAMBDA(i:below[nth_index_std(E)(seqt)(seqp)(l)(0)+1]): seqt(i) #)") (("2" (name "fseq_p" "(#length := nth_index_std(E)(seqt)(seqp)(l)(0) + 1,
                                                             seq := LAMBDA(i:below[nth_index_std(E)(seqt)(seqp)(l)(0)+1]): seqp(i) #)") (("2" (lemma "arg_preservation_in_finite_rtc") (("2" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide -2 -3) (("1" (expand "fseq_t") (("1" (inst -1 "nth_index_std(E)(seqt)(seqp)(l)(0)") (("1" (expand "fseq_p") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (skeep :preds? t) (("2" (expand "fseq_t") (("2" (expand "fseq_p") (("2" (inst -6 "n!1") (("2" (flatten) (("2" (assert) (("2" (inst -5 "n!1") (("2" (flatten) (("2" (assert) (("2" (use "argument_protected_in_non_nth_index_std") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "fseq_t") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "fseq_p") (("3" (expand "fseq_t") (("3" (propax) nil nil)) nil)) nil) ("4" (expand "finseq_appl") (("4" (hide -1 -2) (("4" (expand "fseq_t") (("4" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (use "reducible_is_app") (("2" (assert) (("2" (hide-all-but (-5 1)) (("2" (inst?) (("2" (flatten) (("2" (expand "reducible?") (("2" (inst 1 "seqt(1)") (("2" (expand "reduction?") (("2" (expand "reduction_fix?") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -4 "nth_index_std(E)(seqt)(seqp)(l)(0)") (("3" (flatten) (("3" (use "non_root_rtc_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) (("4" (case-replace "subtermOF(seqt(1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)), #(l)) = subtermOF(seqt(nth_index_std(E)(seqt)(seqp)(l)(n)), #(l)) " :hide? t) (("1" (with-tccs (name-replace "n1th_index_std" "nth_index_std(E)(seqt)(seqp)(l)(n)")) (("1" (inst -5 "n1th_index_std") (("1" (flatten) (("1" (case "first(seqp(n1th_index_std)) = l") (("1" (case " #(l) o rest(seqp(n1th_index_std)) = seqp(n1th_index_std)") (("1" (expand "reduction?") (("1" (expand "reduction_fix?") (("1" (skeep* :preds? t) (("1" (inst 2 "e" "sigma" "rest(seqp(n1th_index_std))") (("1" (lemma "pos_subterm") (("1" (inst -1 " #(l)" "rest(seqp(n1th_index_std))" "seqt(n1th_index_std)") (("1" (assert) (("1" (use "replace_distributivity") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "pos_subterm_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "seq_first_rest_1[posnat]") (("2" (assert) (("2" (inst -5 "n1th_index_std") (("2" (flatten) (("2" (hide-all-but (-1 5)) (("2" (use "empty_0[posnat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n1th_index_std") (("2" (expand "nth_index_std") (("2" (expand "args_of_pos_seq") (("2" (with-tccs (typepred "choose({m: nat |
                                                                                                                                                                                                                                                                                                                          first(seqp(m)) = l AND
                                                                                                                                                                                                                                                                                                                           card({k: nat | first(seqp(k)) = l AND k < m})
                                                                                                                                                                                                                                                                                                                            =  n})")) nil nil)) nil)) nil)) nil)) nil) ("3" (inst -4 "n1th_index_std") (("3" (flatten) (("3" (hide-all-but (-1 4)) (("3" (use "empty_0[posnat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "l_seq" "nth_index_std(E)(seqt)(seqp)(l)(n) - nth_index_std(E)(seqt)(seqp)(l)(n - 1)") (("2" (name "fseq_p" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqp(i + 1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)) #)") (("1" (name "fseq_t" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqt(i + 1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)) #)") (("1" (lemma "arg_preservation_in_finite_rtc") (("1" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (expand "finseq_appl") (("1" (prop) (("1" (expand "fseq_t") (("1" (inst -1 "l_seq - 1") (("1" (expand "l_seq") (("1" (propax) nil nil)) nil) ("2" (expand "l_seq") (("2" (assert) (("2" (lemma "nth_index_std_increasing") (("2" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 4) (("2" (skeep :preds? t) (("2" (expand "fseq_t") (("2" (expand "fseq_p") (("2" (inst -6 "1 +nth_index_std(E)
                                                                                    (seqt)
                                                                                    (seqp)
                                                                                    (l)
                                                                                    (n - 1)
                                                                       + n!1") (("2" (flatten) (("2" (assert) (("2" (hide -7) (("2" (inst -5 "1 +nth_index_std(E)
                                                                                    (seqt)
                                                                                    (seqp)
                                                                                    (l)
                                                                                    (n - 1)
                                                                       + n!1") (("2" (flatten) (("2" (assert) (("2" (expand "l_seq") (("2" (name-replace "index" "1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1) +
                                                          n!1") (("2" (lemma "argument_protected_in_non_nth_index_std") (("2" (inst -1 "E" "seqt" "seqp" "l" "index") (("2" (assert) (("2" (hide -6 -7 -8 2) (("2" (prop) (("2" (expand "index") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 4) (("2" (expand "finseq_appl") (("2" (expand "fseq_t") (("2" (inst -5 "1 +nth_index_std(E)
                                                                                (seqt)
                                                                                (seqp)
                                                                                (l)
                                                                                (n - 1)
                                                                   ") (("2" (flatten) (("2" (use "non_root_rtc_preserves_root_symbol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 4) (("3" (expand "fseq_p") (("3" (expand "l_seq") (("3" (expand "fseq_t") (("3" (expand "l_seq") (("3" (lemma "nth_index_std_increasing") (("3" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 -2 4) (("4" (expand "fseq_t") (("4" (expand "l_seq") (("4" (expand "finseq_appl") (("4" (lemma "nth_index_std_increasing") (("4" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("4" (assert) (("4" (prop) (("1" (hide-all-but (-1 -2)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-7 1)) (("2" (name-replace "index" "1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)") (("2" (inst?) (("2" (flatten) (("2" (use "reducible_is_app") (("2" (assert) (("2" (expand "reducible?") (("2" (expand "reduction_fix?") (("2" (skeep) (("2" (expand "reduction?") (("2" (inst 1 "seqt(1 + index)") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "l_seq") (("2" (lemma "nth_index_std_increasing") (("2" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (inst -4 "nth_index_std(E)(seqt)(seqp)(l)(n)") (("3" (flatten) (("3" (use "non_root_rtc_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "1 + nth_index_std(E)(seqt)(seqp)(l)(i - 1)") (("1" (flatten) (("1" (use "non_root_rtc_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (hide-all-but (-5 2)) (("3" (inst?) (("3" (flatten) (("3" (use "reducible_is_app") (("3" (prop) (("3" (expand "reducible?") (("3" (inst 1 "seqt(1)") (("3" (expand "reduction_fix?") (("3" (expand "reduction?") (("3" (skeep) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep* :preds? t) (("4" (inst -7 "n") (("4" (flatten) (("4" (assert) (("4" (inst -7 "n") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) nil nil) ("6" (skeep) (("6" (assert) nil nil)) nil) ("7" (skeep) (("7" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil) ("2" (rewrite "positions_of_arg") (("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (inst? -2) (("2" (flatten) (("2" (assert) (("2" (inst? -2) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (inst?) (("3" (flatten) (("3" (use "reducible_is_app") (("3" (assert) (("3" (expand "reducible?") (("3" (inst 1 "seqt(1)") (("3" (expand "reduction?") (("3" (expand "reduction_fix?") (("3" (skeep) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (case "EXISTS (m: nat):
                          seqp(m) = empty_seq") (("1" (hide-all-but (-1 2)) (("1" (inst 1 "min({i:nat | seqp(i) = empty_seq})") (("1" (typepred "min({i: nat | seqp(i) = empty_seq})") (("1" (assert) (("1" (skeep) (("1" (inst -2 "k") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -1 "m") (("2" (assert) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (skeep) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (hide 1) (("2" (generalize "n" "n" :fnums (1)) (("2" (reveal 2) (("2" (induct "n" 2) (("1" (expand "RTC") (("1" (expand "IUnion") (("1" (inst 1 0) (("1" (expand "iterate") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 0) nil nil) ("3" (skeep) (("3" (inst -2 "j") (("3" (flatten) (("3" (expand "RTC") (("3" (expand "IUnion") (("3" (skeep) (("3" (prop) (("1" (inst 1 "i + 1") (("1" (lemma "iterate_add") (("1" (inst -1 "non_root_reduction?(E)" "i" "1") (("1" (replaces -1) (("1" (expand "o") (("1" (inst 1 "seqt(j)") (("1" (assert) (("1" (expand "iterate" 1) (("1" (expand "o ") (("1" (inst 1 "seqt(j)") (("1" (expand "iterate" 1) (("1" (hide -1) (("1" (expand "non_root_reduction?") (("1" (inst 1 "seqp(j)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 2 "1 + j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (sequence type-eq-decl nil sequences nil) (non_root_reduction? const-decl "bool" reduction nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (pred type-eq-decl nil defined_types nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (seqt skolem-const-decl "sequence[term[variable, symbol, arity]]" dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (seqp skolem-const-decl "{seqp: sequence[position[variable, symbol, arity]] |
   FORALL (n: nat):
     positionsOF(seqt(n))(seqp(n)) AND
      reduction_fix?(E)(seqt(n), seqt(1 + n), seqp(n))}" dp_termination nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (terminating? const-decl "bool" noetherian nil) (i skolem-const-decl "nat" dp_termination nil) (/= const-decl "boolean" notequal nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (seq_first_rest_1 formula-decl nil seq_extras structures) (empty_0 formula-decl nil seq_extras structures) (reduction? const-decl "bool" reduction nil) (pos_subterm_ax formula-decl nil subterm nil) (pos_subterm formula-decl nil subterm nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (replace_distributivity formula-decl nil replacement nil) (member const-decl "bool" sets nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (n1th_index_std skolem-const-decl "nat" dp_termination nil) (rest const-decl "finseq" seq_extras structures) (O const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (nonempty? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (< const-decl "bool" reals nil) (choose const-decl "(p)" sets nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (fseq_t skolem-const-decl "[# length: posint,
   seq:
     [below[nth_index_std(E)(seqt)(seqp)(l)(0) + 1] ->
        term[variable, symbol, arity]] #]" dp_termination nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (fseq_p skolem-const-decl "[# length: posint,
   seq:
     [below[nth_index_std(E)(seqt)(seqp)(l)(0) + 1] ->
        position[variable, symbol, arity]] #]" dp_termination nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (argument_protected_in_non_nth_index_std formula-decl nil dp_termination nil) (reducible? const-decl "bool" ars_terminology nil) (reducible_is_app formula-decl nil reduction nil) (arg_preservation_in_finite_rtc formula-decl nil reduction nil) (posint nonempty-type-eq-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (positions_of_arg formula-decl nil positions nil) (non_root_rtc_preserves_pos_args formula-decl nil reduction nil) (n1th_index_std skolem-const-decl "nat" dp_termination nil) (non_root_rtc_preserves_root_symbol formula-decl nil reduction nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (index skolem-const-decl "posint" dp_termination nil) (nth_index_std_increasing formula-decl nil dp_termination nil) (fseq_p skolem-const-decl "[# length: int, seq: [below[l_seq] -> position[variable, symbol, arity]] #]" dp_termination nil) (fseq_t skolem-const-decl "[# length: int, seq: [below[l_seq] -> term[variable, symbol, arity]] #]" dp_termination nil) (l_seq skolem-const-decl "int" dp_termination nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (nth_index_std const-decl "nat" dp_termination nil) (subtermOF def-decl "term" subterm nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (l skolem-const-decl "{l: posnat | l <= length(args(seqt(0)))}" dp_termination nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (<= const-decl "bool" reals nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (exists_inf_red_arg_in_inf_nr_red formula-decl nil dp_termination nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (empty? const-decl "bool" sets nil) (iterate_add formula-decl nil relation_iterate orders) (O const-decl "bool" relation_props nil) (iterate def-decl "pred[[T, T]]" relation_iterate orders) (IUnion const-decl "set[T]" indexed_sets nil) (nat_induction formula-decl nil naturalnumbers nil)) nil) (inf_deriv_of_mnt_has_min_root_reduction_index-1 nil 3763920092 ("" (skeep :preds? t) (("" (case "FORALL (n: nat):
                             RTC(non_root_reduction?[variable, symbol, arity](E))
                                 (seqt(0), seqt(n)) AND NOT seqp(n) = empty_seq") (("1" (lemma "exists_inf_red_arg_in_inf_nr_red") (("1" (inst -1 "E" "seqt" "seqp") (("1" (hide 1) (("1" (skeep :preds? t) (("1" (copy -6) (("1" (expand "minimal_non_terminating?" -1) (("1" (flatten) (("1" (hide 1) (("1" (inst -1 "#(l)") (("1" (expand "terminating?") (("1" (with-tccs (inst 1 "LAMBDA(i:nat): IF i=0 THEN subtermOF(seqt(0), #(l)) ELSE subtermOF(seqt(nth_index_std(E)(seqt)(seqp)(l)(i - 1) + 1), #(l)) ENDIF")) (("1" (skeep) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (replaces -1) (("2" (case-replace "subtermOF(seqt(0),  #(l)) =
                             subtermOF(seqt(nth_index_std(E)(seqt)(seqp)(l)(0)), #(l))" :hide? t) (("1" (with-tccs (name-replace "n1th_index_std" "nth_index_std(E)(seqt)(seqp)(l)(0)")) (("1" (inst -5 "n1th_index_std") (("1" (flatten) (("1" (case "first(seqp(n1th_index_std)) = l") (("1" (case " #(l) o rest(seqp(n1th_index_std)) = seqp(n1th_index_std)") (("1" (expand "reduction?") (("1" (expand "reduction_fix?") (("1" (skeep* :preds? t) (("1" (inst 2 "e" "sigma" "rest(seqp(n1th_index_std))") (("1" (lemma "pos_subterm") (("1" (inst -1 " #(l)" "rest(seqp(n1th_index_std))" "seqt(n1th_index_std)") (("1" (assert) (("1" (use "replace_distributivity") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "pos_subterm_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "seq_first_rest_1[posnat]") (("2" (assert) (("2" (hide-all-but (-5 1)) (("2" (inst -1 "n1th_index_std") (("2" (flatten) (("2" (use "empty_0[posnat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n1th_index_std") (("2" (expand "nth_index_std") (("2" (expand "args_of_pos_seq") (("2" (with-tccs (typepred "choose({m: nat |
                                            first(seqp(m)) = l AND
                                             card({k: nat | first(seqp(k)) = l AND k < m}) =
                                              0})")) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (inst -1 "n1th_index_std") (("3" (flatten) (("3" (use "empty_0[posnat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "fseq_t" "(#length := nth_index_std(E)(seqt)(seqp)(l)(0) + 1,
                                          seq := LAMBDA(i:below[nth_index_std(E)(seqt)(seqp)(l)(0)+1]): seqt(i) #)") (("2" (name "fseq_p" "(#length := nth_index_std(E)(seqt)(seqp)(l)(0) + 1,
                                          seq := LAMBDA(i:below[nth_index_std(E)(seqt)(seqp)(l)(0)+1]): seqp(i) #)") (("2" (lemma "arg_preservation_in_finite_rtc") (("2" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide -2 -3) (("1" (expand "fseq_t") (("1" (inst -1 "nth_index_std(E)(seqt)(seqp)(l)(0)") (("1" (expand "fseq_p") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (skeep :preds? t) (("2" (expand "fseq_t") (("2" (expand "fseq_p") (("2" (inst -6 "n!1") (("2" (flatten) (("2" (assert) (("2" (inst -5 "n!1") (("2" (flatten) (("2" (assert) (("2" (use "argument_protected_in_non_nth_index_std") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "fseq_t") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "fseq_p") (("3" (expand "fseq_t") (("3" (propax) nil nil)) nil)) nil) ("4" (expand "finseq_appl") (("4" (hide -1 -2) (("4" (expand "fseq_t") (("4" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (use "reducible_is_app") (("2" (assert) (("2" (hide-all-but (-5 1)) (("2" (inst?) (("2" (flatten) (("2" (expand "reducible?") (("2" (inst 1 "seqt(1)") (("2" (expand "reduction?") (("2" (expand "reduction_fix?") (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -4 "nth_index_std(E)(seqt)(seqp)(l)(0)") (("3" (flatten) (("3" (use "non_root_rtc_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) (("4" (case-replace "subtermOF(seqt(1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)), #(l)) = subtermOF(seqt(nth_index_std(E)(seqt)(seqp)(l)(n)), #(l)) " :hide? t) (("1" (with-tccs (name-replace "n1th_index_std" "nth_index_std(E)(seqt)(seqp)(l)(n)")) (("1" (inst -5 "n1th_index_std") (("1" (flatten) (("1" (case "first(seqp(n1th_index_std)) = l") (("1" (case " #(l) o rest(seqp(n1th_index_std)) = seqp(n1th_index_std)") (("1" (expand "reduction?") (("1" (expand "reduction_fix?") (("1" (skeep* :preds? t) (("1" (inst 2 "e" "sigma" "rest(seqp(n1th_index_std))") (("1" (lemma "pos_subterm") (("1" (inst -1 " #(l)" "rest(seqp(n1th_index_std))" "seqt(n1th_index_std)") (("1" (assert) (("1" (use "replace_distributivity") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "pos_subterm_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "seq_first_rest_1[posnat]") (("2" (assert) (("2" (inst -5 "n1th_index_std") (("2" (flatten) (("2" (hide-all-but (-1 5)) (("2" (use "empty_0[posnat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "n1th_index_std") (("2" (expand "nth_index_std") (("2" (expand "args_of_pos_seq") (("2" (with-tccs (typepred "choose({m: nat |
                                                                                                                                                                                                                                                                                                         first(seqp(m)) = l AND
                                                                                                                                                                                                                                                                                                          card({k: nat | first(seqp(k)) = l AND k < m})
                                                                                                                                                                                                                                                                                                           =  n})")) nil nil)) nil)) nil)) nil)) nil) ("3" (inst -4 "n1th_index_std") (("3" (flatten) (("3" (hide-all-but (-1 4)) (("3" (use "empty_0[posnat]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "l_seq" "nth_index_std(E)(seqt)(seqp)(l)(n) - nth_index_std(E)(seqt)(seqp)(l)(n - 1)") (("2" (name "fseq_p" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqp(i + 1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)) #)") (("1" (name "fseq_t" "(#length := l_seq, seq := LAMBDA(i:below[l_seq]): seqt(i + 1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)) #)") (("1" (lemma "arg_preservation_in_finite_rtc") (("1" (inst -1 "E" "fseq_t" "fseq_p" "l") (("1" (expand "finseq_appl") (("1" (prop) (("1" (expand "fseq_t") (("1" (inst -1 "l_seq - 1") (("1" (expand "l_seq") (("1" (propax) nil nil)) nil) ("2" (expand "l_seq") (("2" (assert) (("2" (lemma "nth_index_std_increasing") (("2" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 4) (("2" (skeep :preds? t) (("2" (expand "fseq_t") (("2" (expand "fseq_p") (("2" (inst -6 "1 +nth_index_std(E)
                                                                (seqt)
                                                                (seqp)
                                                                (l)
                                                                (n - 1)
                                                   + n!1") (("2" (flatten) (("2" (assert) (("2" (hide -7) (("2" (inst -5 "1 +nth_index_std(E)
                                                                (seqt)
                                                                (seqp)
                                                                (l)
                                                                (n - 1)
                                                   + n!1") (("2" (flatten) (("2" (assert) (("2" (expand "l_seq") (("2" (name-replace "index" "1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1) +
                                      n!1") (("2" (lemma "argument_protected_in_non_nth_index_std") (("2" (inst -1 "E" "seqt" "seqp" "l" "index") (("2" (assert) (("2" (hide -6 -7 -8 2) (("2" (prop) (("2" (expand "index") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 4) (("2" (expand "finseq_appl") (("2" (expand "fseq_t") (("2" (inst -5 "1 +nth_index_std(E)
                                                              (seqt)
                                                              (seqp)
                                                              (l)
                                                              (n - 1)
                                                 ") (("2" (flatten) (("2" (use "non_root_rtc_preserves_root_symbol") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 4) (("3" (expand "fseq_p") (("3" (expand "l_seq") (("3" (expand "fseq_t") (("3" (expand "l_seq") (("3" (lemma "nth_index_std_increasing") (("3" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 -2 4) (("4" (expand "fseq_t") (("4" (expand "l_seq") (("4" (expand "finseq_appl") (("4" (lemma "nth_index_std_increasing") (("4" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("4" (assert) (("4" (prop) (("1" (hide-all-but (-1 -2)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-7 1)) (("2" (name-replace "index" "1 + nth_index_std(E)(seqt)(seqp)(l)(n - 1)") (("2" (inst?) (("2" (flatten) (("2" (use "reducible_is_app") (("2" (assert) (("2" (expand "reducible?") (("2" (expand "reduction_fix?") (("2" (skeep) (("2" (expand "reduction?") (("2" (inst 1 "seqt(1 + index)") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "l_seq") (("2" (lemma "nth_index_std_increasing") (("2" (inst -1 "E" "seqt" "seqp" "l" "n - 1" "n") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (inst -4 "nth_index_std(E)(seqt)(seqp)(l)(n)") (("3" (flatten) (("3" (use "non_root_rtc_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "1 + nth_index_std(E)(seqt)(seqp)(l)(i - 1)") (("1" (flatten) (("1" (use "non_root_rtc_preserves_pos_args") (("1" (assert) nil nil) ("2" (rewrite "positions_of_arg") nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (hide-all-but (-5 2)) (("3" (inst?) (("3" (flatten) (("3" (use "reducible_is_app") (("3" (prop) (("3" (expand "reducible?") (("3" (inst 1 "seqt(1)") (("3" (expand "reduction_fix?") (("3" (expand "reduction?") (("3" (skeep) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep* :preds? t) (("4" (inst -7 "n") (("4" (flatten) (("4" (assert) (("4" (inst -7 "n") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) nil nil) ("6" (skeep) (("6" (assert) nil nil)) nil) ("7" (skeep) (("7" (rewrite "positions_of_arg") nil nil)) nil)) nil)) nil) ("2" (rewrite "positions_of_arg") (("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (inst? -2) (("2" (flatten) (("2" (assert) (("2" (inst? -2) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (inst?) (("3" (flatten) (("3" (use "reducible_is_app") (("3" (assert) (("3" (expand "reducible?") (("3" (inst 1 "seqt(1)") (("3" (expand "reduction?") (("3" (expand "reduction_fix?") (("3" (skeep) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (case "EXISTS (m: nat):
                 seqp(m) = empty_seq") (("1" (hide-all-but (-1 2)) (("1" (inst 1 "min({i:nat | seqp(i) = empty_seq})") (("1" (typepred "min({i: nat | seqp(i) = empty_seq})") (("1" (assert) (("1" (skeep) (("1" (inst -2 "k") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (skeep) (("2" (inst -1 "m") (("2" (assert) (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (skeep) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (hide 1) (("2" (generalize "n" "n" :fnums (1)) (("2" (reveal 2) (("2" (induct "n" 2) (("1" (expand "RTC") (("1" (expand "IUnion") (("1" (inst 1 0) (("1" (expand "iterate") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 0) nil nil) ("3" (skeep) (("3" (inst -2 "j") (("3" (flatten) (("3" (expand "RTC") (("3" (expand "IUnion") (("3" (skeep) (("3" (prop) (("1" (inst 1 "i + 1") (("1" (lemma "iterate_add") (("1" (inst -1 "non_root_reduction?(E)" "i" "1") (("1" (replaces -1) (("1" (expand "o") (("1" (inst 1 "seqt(j)") (("1" (assert) (("1" (expand "iterate" 1) (("1" (expand "o ") (("1" (inst 1 "seqt(j)") (("1" (expand "iterate" 1) (("1" (hide -1) (("1" (expand "non_root_reduction?") (("1" (inst 1 "seqp(j)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 2 "1 + j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (non_root_reduction? const-decl "bool" reduction nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (term type-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (terminating? const-decl "bool" noetherian nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (seq_first_rest_1 formula-decl nil seq_extras structures) (empty_0 formula-decl nil seq_extras structures) (reduction? const-decl "bool" reduction nil) (pos_subterm_ax formula-decl nil subterm nil) (pos_subterm formula-decl nil subterm nil) (rhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (replace_distributivity formula-decl nil replacement nil) (member const-decl "bool" sets nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (rest const-decl "finseq" seq_extras structures) (O const-decl "finseq" finite_sequences nil) (args_of_pos_seq const-decl "posnat" dependency_pairs nil) (nonempty? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (choose const-decl "(p)" sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (reducible? const-decl "bool" ars_terminology nil) (reducible_is_app formula-decl nil reduction nil) (arg_preservation_in_finite_rtc formula-decl nil reduction nil) (positions_of_arg formula-decl nil positions nil) (non_root_rtc_preserves_pos_args formula-decl nil reduction nil) (non_root_rtc_preserves_root_symbol formula-decl nil reduction nil) (inf_red_arg_in_inf_nr_im_red const-decl "bool" dependency_pairs nil) (subtermOF def-decl "term" subterm nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (empty? const-decl "bool" sets nil) (iterate_add formula-decl nil relation_iterate orders) (iterate def-decl "pred[[T, T]]" relation_iterate orders)) shostak)) (position_of_replaced_term 0 (position_of_replaced_term-1 nil 3765117984 ("" (measure-induct "length(p1)" "p1") (("" (skeep*) (("" (case-replace "x = empty_seq" :hide? t) (("1" (hide -1) (("1" (expand "replaceTerm") (("1" (expand "empty_seq" -2 1) (("1" (rewrite "empty_o_seq") nil nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x)") (("2" (prop) (("1" (inst -1 "subtermOF(t1, #(first(x)))" "t2" "p2") (("1" (prop) (("1" (hide -2) (("1" (expand "positionsOF" -1) (("1" (expand "IUnion") (("1" (expand "union") (("1" (expand "catenate") (("1" (expand "member") (("1" (expand "finseq_appl") (("1" (expand "only_empty_seq") (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (skeep*) (("1" (expand "subtermOF") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (expand "rest" 2 1) (("2" (lift-if) (("2" (prop) (("2" (replaces -2) (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (rewrite "subterm_empty_seq") (("1" (rewrite "first_add") (("1" (rewrite "rest_add_first") (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (expand "#") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "subterm_empty_seq") (("2" (rewrite "rest_add_first") (("2" (rewrite "first_add") (("2" (expand "first") (("2" (expand "finseq_appl") (("2" (expand "#") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "first_add") (("3" (rewrite "rest_add_first") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "replace_distributivity") (("2" (inst -1 "#(first(x))" "rest(x)" "t1" "t2") (("2" (use "seq_first_rest_1[posnat]") (("2" (expand "/=") (("2" (rewrite "empty_0[posnat]") (("2" (assert) (("2" (replace -2 1 :dir rl :hide? t) (("2" (replace -1 1 rl) (("2" (expand "positionsOF" -3) (("2" (expand "IUnion") (("2" (expand "union") (("2" (expand "catenate") (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (assert) (("2" (expand "only_empty_seq") (("2" (prop) (("1" (hide-all-but (-2 2)) (("1" (use "seq_empty[posnat]") (("1" (prop) (("1" (rewrite "empty_0[posnat]") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 3)) (("2" (use "seq_empty[posnat]") (("2" (prop) (("2" (rewrite "empty_0[posnat]") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 4)) (("3" (use "seq_empty[posnat]") (("3" (prop) (("3" (rewrite "empty_0[posnat]") nil nil)) nil)) nil)) nil) ("4" (skeep*) (("4" (lemma "args_subterm") (("4" (expand "finseq_appl") (("4" (inst -1 "replaceTerm(t1, t2, x)" "i_1 - 1") (("1" (replaces -1) (("1" (assert) (("1" (case "first(x) = i_1 AND rest(x) o p2 = x_2") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide-all-but (-2 1 5)) (("2" (prop) (("1" (expand "first") (("1" (expand "finseq_appl") (("1" (expand "o ") (("1" (decompose-equality -1) (("1" (decompose-equality -2) (("1" (inst -1 0) (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "add_first") (("1" (expand "insert?") (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (lemma "empty_0[posnat]") (("2" (inst -1 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (lemma "empty_0[posnat]") (("2" (inst -1 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "seq_first_rest_1[posnat]") (("2" (inst?) (("2" (prop) (("1" (replace -1 -2) (("1" (rewrite "add_first_is_o") (("1" (lemma "equal_prefix[posnat]") (("1" (inst -1 "#(first(x))" "rest(x) o p2" "x_2") (("1" (assert) (("1" (case-replace "first(x) = i_1") (("1" (use "o_assoc[posnat]") (("1" (assert) nil nil)) nil) ("2" (hide -1 2 3) (("2" (expand "o ") (("2" (flatten) (("2" (decompose-equality -2) (("2" (inst -1 0) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "empty_0[posnat]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "positionsOF" -1) (("2" (expand "union") (("2" (expand "IUnion") (("2" (expand "catenate") (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (expand "only_empty_seq") (("2" (lift-if) (("2" (assert) (("2" (prop) (("2" (skeep*) (("2" (lemma "args_subterm") (("2" (inst -1 "t1" "i_1 - 1") (("1" (assert) (("1" (expand "finseq_appl") (("1" (replaces -1) (("1" (replaces -2) (("1" (rewrite "first_add") (("1" (expand "positionsOF" 3) (("1" (expand "union") (("1" (expand "IUnion") (("1" (expand "catenate") (("1" (expand "member") (("1" (expand "only_empty_seq") (("1" (assert) (("1" (prop) (("1" (expand "finseq_appl") (("1" (inst 4 "i_1") (("1" (inst 4 "empty_seq") (("1" (rewrite "empty_seq_is_position") (("1" (hide-all-but (4)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (expand "/=") (("3" (rewrite "empty_0[posnat]") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (use "length_rest[posnat]") (("2" (assert) (("2" (expand "/=") (("2" (rewrite "empty_0[posnat]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (rest const-decl "finseq" seq_extras structures) (length_rest formula-decl nil seq_extras structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (/= const-decl "boolean" notequal nil) (x skolem-const-decl "position[variable, symbol, arity]" dp_termination nil) (t1 skolem-const-decl "term[variable, symbol, arity]" dp_termination nil) (finite_sequence type-eq-decl nil finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (subtermOF def-decl "term" subterm nil) (replace_distributivity formula-decl nil replacement nil) (seq_first_rest_1 formula-decl nil seq_extras structures) (empty_0 formula-decl nil seq_extras structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (p2 skolem-const-decl "position[variable, symbol, arity]" dp_termination nil) (insert? const-decl "finseq" seq_extras structures) (equal_prefix formula-decl nil seq_extras structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (int_times_int_is_int application-judgement "int" integers nil) (o_assoc formula-decl nil finite_sequences nil) (add_first_is_o formula-decl nil seq_extras structures) (int_plus_int_is_int application-judgement "int" integers nil) (t2 skolem-const-decl "term[variable, symbol, arity]" dp_termination nil) (args_subterm formula-decl nil subterm nil) (seq_empty formula-decl nil seq_extras structures) (IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (<= const-decl "bool" reals nil) (add_first const-decl "finseq" seq_extras structures) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (subterm_empty_seq formula-decl nil subterm nil) (int_minus_int_is_int application-judgement "int" integers nil) (rest_add_first formula-decl nil seq_extras structures) (first_add formula-decl nil seq_extras structures) (^ const-decl "finseq" finite_sequences nil) (only_empty_seq const-decl "positions" positions nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (empty_seq_is_position formula-decl nil positions nil) (empty_o_seq formula-decl nil seq_extras structures) (= const-decl "[T, T -> boolean]" equalities nil) (empty_seq const-decl "finseq" finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (replaceTerm def-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (mnt_reduces_at_root_to_nt_TCC1 0 (mnt_reduces_at_root_to_nt_TCC1-1 nil 3763224751 ("" (skeep :preds? t) (("" (rewrite "empty_seq_is_position") nil nil)) nil) ((empty_seq_is_position formula-decl nil positions nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil)) nil (mnt_reduces_at_root_to_nt subtype "finite_sequences[posnat].empty_seq" "positions?[dp_termination.variable, dp_termination.symbol, dp_termination.arity](dp_termination.t)"))) (mnt_reduces_at_root_to_nt 0 (mnt_reduces_at_root_to_nt-1 nil 3763570940 ("" (skeep :preds? t) (("" (expand "minimal_non_terminating?") (("" (flatten) (("" (expand "terminating?" 1) (("" (skeep) (("" (use "positions_of_inf_reduction") (("" (prop) (("1" (skeep) (("1" (use "inf_deriv_of_mnt_has_min_root_reduction_index") (("1" (assert) (("1" (skeep) (("1" (case "RTC(non_root_reduction?(E))(s, seq(j))") (("1" (inst 1 "seq(j)" "seq(j + 1)") (("1" (assert) (("1" (inst -4 "j") (("1" (assert) nil nil)) nil)) nil) ("2" (hide -8) (("2" (expand "terminating?") (("2" (inst 1 "LAMBDA(i:nat): seq(i + 1 +j)") (("2" (assert) (("2" (skeep) (("2" (inst -6 "1 + n + j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "s") (("3" (case "FORALL ( jj : upto[j]) : minimal_non_terminating?(E)(seq(jj))") (("1" (inst? -1) nil nil) ("2" (induct "jj") (("1" (assert) nil nil) ("2" (hide 2) (("2" (skolem 1 "i") (("2" (prop) (("2" (hide -3 -4 -8 -10) (("2" (expand "minimal_non_terminating?") (("2" (prop) (("1" (hide-all-but (-1 -7)) (("1" (expand "terminating?") (("1" (inst 1 "LAMBDA(k:nat): seq(k + 1 + i)") (("1" (assert) (("1" (skeep) (("1" (inst -1 "1 + n + i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -5 "i") (("2" (inst -4 "i") (("2" (prop) (("1" (assert) nil nil) ("2" (hide -3 -6 3) (("2" (skeep :preds? t) (("2" (name-replace "si" "seq(i)") (("2" (name-replace "sii" "seq(i+1)") (("2" (name-replace "pp" "seqp(i)") (("2" (case "parallel(pp,p)") (("1" (expand "reduction_fix?") (("1" (skeep) (("1" (lemma "preserv_unchanged_pos") (("1" (inst -1 "pp" "p" "si" "ext(sigma)(rhs(e))") (("1" (assert) (("1" (lemma "replace_persistence") (("1" (inst -1 "pp" "p" "si" "ext(sigma)(rhs(e))") (("1" (assert) (("1" (inst -6 "p") (("1" (assert) nil nil) ("2" (expand "si") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "parallel") (("2" (prop) (("1" (expand "<=") (("1" (skeep) (("1" (replaces -1) (("1" (inst -3 "pp") (("1" (expand "reduction_fix?") (("1" (skeep) (("1" (expand "terminating?") (("1" (skolem -2 "sqii") (("1" (flatten) (("1" (inst 3 "LAMBDA (i : nat) : IF i = 0 THEN subtermOF(si, pp) ELSE replaceTerm(subtermOF(sii, pp), sqii(i-1), p1) ENDIF") (("1" (skeep) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (replaces -1) (("1" (replaces -2) (("1" (replaces -6) (("1" (use "subterm_of_replace") (("1" (assert) (("1" (replace -1 1) (("1" (use "replace_embedding") (("1" (prop) (("1" (replace -1 1) (("1" (use "replace_subterm_of_term") (("1" (assert) (("1" (prop) (("1" (replace -1 1) (("1" (replace -8 1) (("1" (hide-all-but 1) (("1" (expand "reduction?") (("1" (inst?) (("1" (inst 1 "empty_seq") (("1" (rewrite "subterm_empty_seq") (("1" (expand "replaceTerm") (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -6 1)) (("2" (use "position_of_replaced_term") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -5 1)) (("2" (use "position_of_replaced_term") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "n -1") (("1" (assert) (("1" (expand "reduction?") (("1" (skeep) (("1" (inst 2 "e!1" "sigma!1" "p1 o p!1") (("1" (use "replace_embedding") (("1" (assert) (("1" (split -1) (("1" (replaces -1) (("1" (assert) (("1" (replace -4 2) (("1" (use "replace_associativity") (("1" (prop) (("1" (assert) nil nil) ("2" (lemma "position_of_replaced_term") (("2" (inst -1 "sii" "subtermOF(sii, pp)" "pp" "p1") (("2" (prop) (("1" (lemma "closed_positions") (("1" (inst -1 "pp" "pp o p1" "sii") (("1" (prop) (("1" (hide-all-but 1) (("1" (expand "<=") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "replace_subterm_of_term") (("2" (assert) (("2" (lemma "closed_positions") (("2" (inst -1 "pp" "pp o p1" "sii") (("2" (assert) (("2" (hide-all-but 1) (("2" (expand "<=") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "p!1") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (replaces -8) (("2" (use "subterm_of_replace") (("2" (assert) (("2" (replaces -1) (("2" (hide-all-but (-1 -6 1)) (("2" (use "position_of_replaced_term") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (lemma "closed_positions") (("2" (inst -1 "pp" "pp o p1" "sii") (("2" (assert) (("2" (hide-all-but 1) (("2" (expand "<=") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "p!1") (("2" (lemma "replace_compose_pos") (("2" (inst -1 "p1" "p!1" "subtermOF[variable, symbol, arity](sii, pp)" "sqii(n - 1)") (("2" (prop) (("2" (hide-all-but (-2 1 4 5)) (("2" (lemma " pos_subterm_ax") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (replaces -7) (("2" (use "subterm_of_replace") (("2" (assert) (("2" (replaces -1) (("2" (hide-all-but (-1 -5 2 3 4)) (("2" (lemma "position_of_replaced_term") (("2" (inst -1 "si" "ext(sigma)(rhs(e))" "pp" "p1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (replaces -7) (("4" (use "replace_preserv_pos") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "sii") (("2" (expand "reduction_fix?") (("2" (skeep) (("2" (replaces -5) (("2" (use "subterm_of_replace") (("2" (assert) (("2" (expand "si") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "<=") (("2" (skeep :preds? t) (("2" (inst -4 "p") (("1" (expand "terminating?") (("1" (skeep) (("1" (inst 3 "LAMBDA (k : nat) : IF k = 0 THEN subtermOF(si, p) ELSE seq!1(k-1) ENDIF") (("1" (skeep) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (replaces -1) (("2" (assert) (("2" (expand "reduction_fix?") (("2" (skeep) (("2" (hide -4) (("2" (expand "reduction?") (("2" (inst 2 "e" "sigma" "p1") (("1" (prop) (("1" (use "pos_subterm") (("1" (assert) nil nil)) nil) ("2" (replaces -3) (("2" (replace -6 1) (("2" (replace -1 1) (("2" (lemma "replace_distributivity") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (hide-all-but (-4 1 3 4)) (("2" (use " pos_subterm_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lift-if) (("3" (assert) (("3" (inst? -4) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (hide-all-but (-2 -7 1 2 3)) (("3" (replaces -1) (("3" (use "pos_ax") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "si") (("2" (hide-all-but (-1 -4 1 2 3)) (("2" (replaces -1) (("2" (use "pos_ax") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "RTC") (("2" (expand "IUnion") (("2" (inst 1 "j") (("2" (hide -6) (("2" (case "FORALL ( jj : upto[j]) : iterate(non_root_reduction?(E), jj)(s, seq(jj)) ") (("1" (inst? -1) nil nil) ("2" (hide 2) (("2" (induct "jj") (("1" (expand "iterate") (("1" (assert) nil nil)) nil) ("2" (skolem 1 "i") (("2" (prop) (("2" (expand "iterate" 1) (("2" (expand "o ") (("2" (inst 1 "seq(i)") (("2" (assert) (("2" (inst -5 "i") (("2" (expand "non_root_reduction?") (("2" (inst 1 "seqp(i)") (("1" (flatten) nil nil) ("2" (inst -5 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (inst -1 "n") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst? -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minimal_non_terminating? const-decl "bool" dp_termination nil) (terminating? const-decl "bool" noetherian nil) (positions_of_inf_reduction formula-decl nil dp_termination nil) (sequence type-eq-decl nil sequences nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_reduction? const-decl "bool" reduction nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (upto_induction formula-decl nil bounded_nat_inductions nil) (= const-decl "[T, T -> boolean]" equalities nil) (pos_ax formula-decl nil positions nil) (p1 skolem-const-decl "position[variable, symbol, arity]" dp_termination nil) (replace_distributivity formula-decl nil replacement nil) (pos_subterm formula-decl nil subterm nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (<= const-decl "bool" positions nil) (TRUE const-decl "bool" booleans nil) (replace_preserv_pos formula-decl nil replacement nil) (n skolem-const-decl "nat" dp_termination nil) (sqii skolem-const-decl "sequence[term[variable, symbol, arity]]" dp_termination nil) (O const-decl "finseq" finite_sequences nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](sqii(n - 1))" dp_termination nil) (closed_positions formula-decl nil positions nil) (replace_associativity formula-decl nil replacement nil) (replace_compose_pos formula-decl nil replacement nil) (pos_subterm_ax formula-decl nil subterm nil) (int_plus_int_is_int application-judgement "int" integers nil) (replace_embedding formula-decl nil replacement nil) (position_of_replaced_term formula-decl nil dp_termination nil) (empty_seq_is_position formula-decl nil positions nil) (subterm_empty_seq formula-decl nil subterm nil) (e skolem-const-decl "{e | member[rewrite_rule[variable, symbol, arity]](e, E)}" dp_termination nil) (lhs const-decl "term" rewrite_rules nil) (sigma skolem-const-decl "Sub[variable, symbol, arity]" dp_termination nil) (replace_subterm_of_term formula-decl nil replacement nil) (subterm_of_replace formula-decl nil replacement nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (replaceTerm def-decl "term" replacement nil) (p1 skolem-const-decl "position[variable, symbol, arity]" dp_termination nil) (subtermOF def-decl "term" subterm nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (sii skolem-const-decl "term[variable, symbol, arity]" dp_termination nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pp skolem-const-decl "position[variable, symbol, arity]" dp_termination nil) (preserv_unchanged_pos formula-decl nil replacement nil) (i skolem-const-decl "upto(j)" dp_termination nil) (p skolem-const-decl "{p: positions?(seq(1 + i)) | NOT p = empty_seq}" dp_termination nil) (si skolem-const-decl "term[variable, symbol, arity]" dp_termination nil) (replace_persistence formula-decl nil replacement nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (ext def-decl "term" substitution nil) (rhs const-decl "term" rewrite_rules nil) (member const-decl "bool" sets nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (parallel const-decl "bool" positions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto nonempty-type-eq-decl nil nat_types nil) (<= const-decl "bool" reals nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (reduction? const-decl "bool" reduction nil) (PRED type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (j skolem-const-decl "nat" dp_termination nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (iterate def-decl "pred[[T, T]]" relation_iterate orders) (O const-decl "bool" relation_props nil) (i skolem-const-decl "upto(j)" dp_termination nil) (IUnion const-decl "set[T]" indexed_sets nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (reduction_fix? const-decl "bool" reduction nil) (positions? type-eq-decl nil positions nil) (seqp skolem-const-decl "sequence[position[variable, symbol, arity]]" dp_termination nil) (seq skolem-const-decl "sequence[term[variable, symbol, arity]]" dp_termination nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (inf_deriv_of_mnt_has_min_root_reduction_index formula-decl nil dp_termination nil)) shostak)) (reducible_position_of_terminating_inst_is_app_pos_of_term 0 (reducible_position_of_terminating_inst_is_app_pos_of_term-1 nil 3763571963 ("" (skeep* :preds? t) (("" (lemma "positions_of_ext") (("" (inst -1 "sigma" "t") (("" (expand "union") (("" (expand "member") (("" (assert) (("" (decompose-equality -1) (("" (inst -1 "p") (("" (assert) (("" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (replaces -1) (("2" (lemma "subterm_of_ext") (("2" (inst -1 "p1" "p2" "sigma" "t") (("2" (assert) (("2" (replaces -1) (("2" (expand "terminating_sub?") (("2" (inst -5 "subtermOF(t, p1)") (("1" (expand "terminating?") (("1" (skeep) (("1" (inst 1 "LAMBDA (i : nat) : replaceTerm(sigma(subtermOF(t, p1)), seq(i) ,p2)") (("1" (split 1) (("1" (replace -6 1) (("1" (expand "ext" 1) (("1" (use "replace_subterm_of_term") (("1" (assert) (("1" (expand "ext") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -7 "n") (("2" (lemma "reduction_is_subs_op") (("2" (inst?) (("2" (flatten) (("2" (use "comp_op_iff_comp_cont") (("2" (assert) (("2" (expand "comp_cont?") (("2" (expand "ext" -6) (("2" (inst -1 "p2" "sigma(subtermOF(t, p1))") (("2" (assert) (("2" (inst -1 "seq(n)" "seq(n+1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ext" -3) (("2" (propax) nil nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (hide-all-but (-2 1)) (("1" (grind) nil nil)) nil) ("2" (case "positionsOF(t)(p1 o p2)") (("1" (assert) (("1" (expand "terminating?") (("1" (skeep) (("1" (inst -8 0) (("1" (replaces -7) (("1" (assert) (("1" (expand "Dom") (("1" (expand "/=") (("1" (expand "ext" -8) (("1" (replaces -2 -8) (("1" (use "pos_subterm") (("1" (assert) (("1" (replace -1 -8 :dir rl) (("1" (name-replace "tt" "subtermOF(t, p1 o p2)") (("1" (use "reducible_is_app") (("1" (assert) (("1" (expand "reducible?") (("1" (inst? 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3 4) (("2" (expand "Dom") (("2" (expand "/=") (("2" (expand "ext" -4) (("2" (replace -1 -4) (("2" (use "pos_o_term") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (positions_of_ext formula-decl nil substitution nil) (union const-decl "set" sets nil) (t skolem-const-decl "term[variable, symbol, arity]" dp_termination nil) (p1 skolem-const-decl "position[variable, symbol, arity]" dp_termination nil) (Dom const-decl "set[(V)]" substitution nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (sigma skolem-const-decl "(terminating_sub?(E))" dp_termination nil) (replace_subterm_of_term formula-decl nil replacement nil) (comp_op_iff_comp_cont formula-decl nil compatibility nil) (pred type-eq-decl nil defined_types nil) (reduction? const-decl "bool" reduction nil) (comp_cont? const-decl "bool" compatibility nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduction_is_subs_op formula-decl nil reduction nil) (sequence type-eq-decl nil sequences nil) (replaceTerm def-decl "term" replacement nil) (p2 skolem-const-decl "position[variable, symbol, arity]" dp_termination nil) (terminating? const-decl "bool" noetherian nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (/= const-decl "boolean" notequal nil) (reducible? const-decl "bool" ars_terminology nil) (reducible_is_app formula-decl nil reduction nil) (pos_subterm formula-decl nil subterm nil) (pos_o_term formula-decl nil subterm nil) (subterm_of_ext formula-decl nil substitution nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (ext def-decl "term" substitution nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (finseq type-eq-decl nil finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (member const-decl "bool" sets nil) (terminating_sub? const-decl "bool" reduction nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil)) (terminating_inst_of_rule_with_mint_on_rhs_gives_dp_alt 0 (terminating_inst_of_rule_with_mint_on_rhs_gives_dp_alt-1 nil 3763807517 ("" (skeep* :preds? t) (("" (expand "rewrite_rule?") (("" (flatten) (("" (lemma "mnt_reduces_at_root_to_nt") (("" (inst -1 "E" "subtermOF(ext(sigma)(rhs(e)), p)") (("" (skeep :preds? t) (("" (use "non_root_rtc_preserves_root_symbol") (("1" (assert) (("1" (flatten) (("1" (expand "dep_pair_alt?") (("1" (expand "lhs") (("1" (assert) (("1" (use "reducible_position_of_terminating_inst_is_app_pos_of_term") (("1" (expand "minimal_non_terminating?") (("1" (prop) (("1" (hide -5 -13) (("1" (expand "reduction_fix?") (("1" (skeep :preds? t) (("1" (expand "defined?") (("1" (inst 1 "e!1") (("1" (rewrite* "subterm_empty_seq") (("1" (replaces -9) (("1" (hide-all-but (-5 -6 -7 1)) (("1" (use "ext_preserve_symbol") (("1" (assert) (("1" (replaces -1) (("1" (lemma "ext_preserve_symbol") (("1" (inst -1 "lhs(e!1)" "sigma!1" "empty_seq") (("1" (rewrite* "subterm_empty_seq") (("1" (assert) (("1" (typepred "e!1") (("1" (expand "rewrite_rule?") (("1" (flatten) (("1" (expand "lhs") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-9 1)) (("2" (use "reducible_is_app") (("2" (assert) (("2" (hide 2) (("2" (expand "minimal_non_terminating?") (("2" (flatten) (("2" (hide -) (("2" (expand "terminating?") (("2" (expand "reducible?") (("2" (skeep) (("2" (inst -2 0) (("2" (replaces -1) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rewrite_rule? const-decl "bool" rewrite_rules nil) (mnt_reduces_at_root_to_nt formula-decl nil dp_termination nil) (reducible? const-decl "bool" ars_terminology nil) (sequence type-eq-decl nil sequences nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (terminating? const-decl "bool" noetherian nil) (reducible_is_app formula-decl nil reduction nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (ext_preserve_symbol formula-decl nil substitution nil) (e!1 skolem-const-decl "{e | member[rewrite_rule[variable, symbol, arity]](e, E)}" dp_termination nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty_seq_is_position formula-decl nil positions nil) (subterm_empty_seq formula-decl nil subterm nil) (defined? const-decl "bool" rewrite_rules nil) (reduction_fix? const-decl "bool" reduction nil) (reducible_position_of_terminating_inst_is_app_pos_of_term formula-decl nil dp_termination nil) (lhs const-decl "term" rewrite_rules nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (non_root_rtc_preserves_root_symbol formula-decl nil reduction nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (term type-decl nil term_adt nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (ext def-decl "term" substitution nil) (terminating_sub? const-decl "bool" reduction nil) (sigma skolem-const-decl "(terminating_sub?(E))" dp_termination nil) (rhs const-decl "term" rewrite_rules nil) (member const-decl "bool" sets nil) (e skolem-const-decl "{e | member(e, E)}" dp_termination nil) (p skolem-const-decl "positions?[variable, symbol, arity](ext(sigma)(rhs(e)))" dp_termination nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil)) (mnt_to_nt_by_root_reduction_TCC1 0 (mnt_to_nt_by_root_reduction_TCC1-1 nil 3763825735 ("" (skeep :preds? t) (("" (rewrite "empty_seq_is_position") nil nil)) nil) ((empty_seq_is_position formula-decl nil positions nil) (term type-decl nil term_adt nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil)) nil (mnt_to_nt_by_root_reduction subtype "finite_sequences[posnat].empty_seq" "positions?[dp_termination.variable, dp_termination.symbol, dp_termination.arity](dp_termination.t)"))) (mnt_to_nt_by_root_reduction_TCC2 0 (mnt_to_nt_by_root_reduction_TCC2-1 nil 3763825735 ("" (skeep :preds? t) (("" (use "mnt_reduces_at_root_to_nt") (("" (skeep :preds? t) (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (inst -5 "(t,u)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mnt_reduces_at_root_to_nt formula-decl nil dp_termination nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (nonempty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (reduction? const-decl "bool" reduction nil) (terminating? const-decl "bool" noetherian nil) (PRED type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty? const-decl "bool" sets nil)) nil (mnt_to_nt_by_root_reduction subtype "{(t: term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term, u: term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term) | booleans.AND(dp_termination.minimal_non_terminating?(dp_termination.E)(t), booleans.AND(relations_closure[term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term].RTC(reduction[dp_termination.variable, dp_termination.symbol, dp_termination.arity].non_root_reduction?(dp_termination.E))(dp_termination.s, t), booleans.AND(reduction[dp_termination.variable, dp_termination.symbol, dp_termination.arity].reduction_fix?(dp_termination.E)(t, u, finite_sequences[posnat].empty_seq), (booleans.NOT)(noetherian[term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term].terminating?(reduction[dp_termination.variable, dp_termination.symbol, dp_termination.arity].reduction?(dp_termination.E))(u)))))}" "(sets[[term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term, term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term]].nonempty?)"))) (reduced_nt_by_root_has_mnt_TCC1 0 (reduced_nt_by_root_has_mnt_TCC1-1 nil 3763827790 ("" (skeep* :preds? t) (("" (use "ext_preserv_pos") (("" (assert) nil nil)) nil)) nil) ((ext_preserv_pos formula-decl nil substitution nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (positions? type-eq-decl nil positions nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (rhs const-decl "term" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (reduced_nt_by_root_has_mnt subtype "dp_termination.p" "positions?[dp_termination.variable, dp_termination.symbol, dp_termination.arity](substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.sigma)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.e)))"))) (reduced_nt_by_root_has_mnt 0 (reduced_nt_by_root_has_mnt-1 nil 3763827792 ("" (skeep* :preds? t) (("" (expand "mnt_to_nt_by_root_reduction") (("" (typepred "choose({(t: term), (u: term) |
                   minimal_non_terminating?(E)(t) AND
                    RTC(non_root_reduction?(E))(s, t) AND
                     reduction_fix?(E)(t, u, empty_seq) AND
                      NOT terminating?(reduction?(E))(u)})") (("1" (name-replace "lhs_and_rhs" "choose({(t: term), (u: term) |
                   minimal_non_terminating?(E)(t) AND
                    RTC(non_root_reduction?(E))(s, t) AND
                     reduction_fix?(E)(t, u, empty_seq) AND
                      NOT terminating?(reduction?(E))(u)})") (("1" (expand "reduction_fix?") (("1" (skeep :preds? t) (("1" (rewrite* "subterm_empty_seq") (("1" (case-replace "ext(restriction(sigma)(Vars(lhs(e))))(lhs(e)) = ext(sigma)(lhs(e)) AND ext(restriction(sigma)(Vars(lhs(e))))(rhs(e)) = ext(sigma)(rhs(e))") (("1" (flatten) (("1" (lemma "non_terminating_has_mnt") (("1" (inst -1 "E" "lhs_and_rhs`2") (("1" (skeep :preds? t) (("1" (expand "replaceTerm") (("1" (rewrite "empty_0") (("1" (inst 2 "restriction(sigma)(Vars(lhs(e)))" "e" "p") (("1" (assert) nil nil) ("2" (replaces -10) (("2" (replaces -10) (("2" (lemma "reducible_position_of_terminating_inst_is_app_pos_of_term") (("2" (inst -1 "E" "rhs(e)" "restriction(sigma)(Vars(lhs(e)))" "p") (("1" (replaces -5) (("1" (expand "minimal_non_terminating?" -3) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide-all-but (-3 -4 -8 1)) (("3" (expand "minimal_non_terminating?") (("3" (flatten) (("3" (expand "terminating_sub?") (("3" (skeep :preds? t) (("3" (lemma "pos_vars_subset_pos") (("3" (inst -1 "lhs(e)" "x") (("3" (assert) (("3" (case "EXISTS (p: positions?(lhs(e))): NOT p = empty_seq AND x = subtermOF(lhs(e), p)") (("1" (skeep :preds? t) (("1" (inst -8 "p!1") (("1" (lemma "subterm_of_ext") (("1" (inst -1 "p!1" "empty_seq" "sigma" "lhs(e)") (("1" (assert) (("1" (prop) (("1" (rewrite "subterm_empty_seq") (("1" (rewrite "seq_o_empty") (("1" (expand "restriction" 2) (("1" (expand "member") (("1" (replace -4 -1 rl) (("1" (expand "ext" -1 2) (("1" (assert) (("1" (prop) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "empty_seq_is_position") nil nil) ("3" (hide-all-but (-2 -3 -5 1)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "ext_preserv_pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -4 -5 -6 2 3) (("2" (expand "Dom") (("2" (expand "/=") (("2" (assert) (("2" (expand "restriction") (("2" (expand "member") (("2" (lift-if) (("2" (prop) (("2" (expand "Vars") (("2" (skeep :preds? t) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (typepred "e") (("2" (expand "rewrite_rule?") (("2" (flatten) (("2" (expand "lhs") (("2" (assert) (("2" (expand "subtermOF") (("2" (rewrite "empty_0") (("2" (hide-all-but (-4 -6 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand "rewrite_rule?") (("2" (expand "lhs") (("2" (expand "rhs") (("2" (prop) (("1" (use "restriction_term") (("1" (assert) (("1" (expand "subset?") (("1" (skeep) nil nil)) nil)) nil)) nil) ("2" (use "restriction_term") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (prop) (("3" (rewrite "restriction_Subs") nil nil)) nil) ("4" (rewrite "restriction_Subs") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (use "mnt_reduces_at_root_to_nt") (("2" (skeep) (("2" (inst -3 "(t,u)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep* :preds? t) (("3" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil)) nil) ((mnt_to_nt_by_root_reduction const-decl "[term, term]" dp_termination nil) (empty? const-decl "bool" sets nil) (mnt_reduces_at_root_to_nt formula-decl nil dp_termination nil) (= const-decl "[T, T -> boolean]" equalities nil) (rhs const-decl "term" rewrite_rules nil) (member const-decl "bool" sets nil) (lhs const-decl "term" rewrite_rules nil) (Vars const-decl "set[(V)]" subterm nil) (restriction const-decl "term" substitution nil) (ext def-decl "term" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (non_terminating_has_mnt formula-decl nil dp_termination nil) (empty_0 formula-decl nil seq_extras structures) (reducible_position_of_terminating_inst_is_app_pos_of_term formula-decl nil dp_termination nil) (Dom const-decl "set[(V)]" substitution nil) (subtermOF def-decl "term" subterm nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](lhs(e))" dp_termination nil) (seq_o_empty formula-decl nil seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (/= const-decl "boolean" notequal nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (subset? const-decl "bool" sets nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (only_empty_seq const-decl "positions" positions nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (e!1 skolem-const-decl "{e | member[rewrite_rule[variable, symbol, arity]](e, E)}" dp_termination nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (union const-decl "set" sets nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (seq!1 skolem-const-decl "sequence[term[variable, symbol, arity]]" dp_termination nil) (sigma!1 skolem-const-decl "Sub[variable, symbol, arity]" dp_termination nil) (p!2 skolem-const-decl "positions?[variable, symbol, arity](seq!1(0))" dp_termination nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (sequence type-eq-decl nil sequences nil) (empty_seq_is_position formula-decl nil positions nil) (subterm_of_ext formula-decl nil substitution nil) (ext_preserv_pos formula-decl nil substitution nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (pos_vars_subset_pos formula-decl nil subterm nil) (sigma skolem-const-decl "Sub[variable, symbol, arity]" dp_termination nil) (terminating_sub? const-decl "bool" reduction nil) (p skolem-const-decl "positions?[variable, symbol, arity](lhs_and_rhs`2)" dp_termination nil) (lhs_and_rhs skolem-const-decl "({(t: term, u: term) |
    minimal_non_terminating?(E)(t) AND
     RTC(non_root_reduction?(E))(s, t) AND
      reduction_fix?(E)(t, u, empty_seq) AND
       NOT terminating?(reduction?(E))(u)})" dp_termination nil) (s skolem-const-decl "{s: term | minimal_non_terminating?(E)(s)}" dp_termination nil) (e skolem-const-decl "{e | member[rewrite_rule[variable, symbol, arity]](e, E)}" dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (replaceTerm def-decl "term" replacement nil) (restriction_term formula-decl nil substitution nil) (restriction_Subs formula-decl nil substitution nil) (subterm_empty_seq formula-decl nil subterm nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_reduction? const-decl "bool" reduction nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (terminating? const-decl "bool" noetherian nil) (reduction? const-decl "bool" reduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (dp_and_sub_from_first_root_reduction_TCC1 0 (dp_and_sub_from_first_root_reduction_TCC1-1 nil 3763825735 ("" (skeep* :preds? t) (("" (use "ext_preserv_pos") (("" (assert) nil nil)) nil)) nil) ((ext_preserv_pos formula-decl nil substitution nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (set type-eq-decl nil sets nil) (positions? type-eq-decl nil positions nil) (rhs const-decl "term" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (dp_and_sub_from_first_root_reduction subtype "dp_termination.p" "positions?[dp_termination.variable, dp_termination.symbol, dp_termination.arity](substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.sigma)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.e)))"))) (dp_and_sub_from_first_root_reduction_TCC2 0 (dp_and_sub_from_first_root_reduction_TCC2-1 nil 3763825735 ("" (skeep* :preds? t) (("" (use "reduced_nt_by_root_has_mnt") (("" (skolem -1 ("sigma1" "e1" "p1")) (("" (flatten) (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (inst -5 "(sigma1, e1, p1)") (("" (assert) (("" (typepred "e1") (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((reduced_nt_by_root_has_mnt formula-decl nil dp_termination nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (empty? const-decl "bool" sets nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (rhs const-decl "term" rewrite_rules nil) (positions? type-eq-decl nil positions nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (dp_and_sub_from_first_root_reduction subtype "{(sigma: substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].Sub, e: rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rewrite_rule, p: positions[dp_termination.variable, dp_termination.symbol, dp_termination.arity].positions?(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(e))) | booleans.AND(sets[rewrite_rule[variable, symbol, arity]].member(e, dp_termination.E), booleans.AND(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(sigma)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].lhs(e)) = dp_termination.lhs_term, dp_termination.minimal_non_terminating?(dp_termination.E)(subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(sigma)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(e)), p))))}" "(sets[[Sub[variable, symbol, arity], e: rewrite_rule[variable, symbol, arity], positions?[dp_termination.variable, dp_termination.symbol, dp_termination.arity](rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(e))]].nonempty?)"))) (dp_and_sub_from_first_root_reduction_TCC3 0 (dp_and_sub_from_first_root_reduction_TCC3-2 "" 3804409044 ("" (skeep* :preds? t) (("" (expand "mnt_to_nt_by_root_reduction") (("" (typepred "choose({(t: term), (u: term) |
                 minimal_non_terminating?(E)(t) AND
                  RTC(non_root_reduction?(E))(s, t) AND
                   reduction_fix?(E)(t, u, empty_seq) AND
                    NOT terminating?(reduction?(E))(u)})") (("1" (replaces -8 :dir rl) (("1" (lemma "terminating_inst_of_rule_with_mint_on_rhs_gives_dp_alt") (("1" (inst -1 "E" "sub_e_p`2" "restriction(sub_e_p`1)(Vars(lhs(sub_e_p`2)))" "sub_e_p`3") (("1" (assert) (("1" (use "restriction_term") (("1" (assert) (("1" (hide-all-but 1) (("1" (typepred "sub_e_p`2") (("1" (expand "rewrite_rule?") (("1" (flatten) (("1" (expand "rhs") (("1" (expand "lhs") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "ext_preserv_pos") (("2" (assert) nil nil)) nil) ("3" (use "restriction_Subs") (("3" (assert) (("3" (replaces -7 :dir rl) (("3" (hide-all-but (-1 -2 1)) (("3" (expand "minimal_non_terminating?") (("3" (flatten) (("3" (expand "terminating_sub?") (("3" (skeep :preds? t) (("3" (expand "Dom") (("3" (expand "/=") (("3" (assert) (("3" (expand "restriction" 1) (("3" (expand "member") (("3" (lift-if) (("3" (prop) (("3" (expand "Vars" -1) (("3" (skeep :preds? t) (("3" (inst -5 "p") (("1" (use "subterm_ext_commute") (("1" (assert) (("1" (replace -1 -6) (("1" (replace -3 -6) (("1" (case-replace "ext(sub_e_p`1)(x) = restriction[variable, symbol, arity]
                               (sub_e_p`1)
                               (Vars[variable, symbol, arity]
                                    (lhs[variable, symbol, arity](sub_e_p`2)))
                               (x)") (("1" (hide-all-but (-3 -4 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "ext_preserv_pos") (("2" (assert) (("2" (hide-all-but (-2 -4 -5)) (("2" (typepred "sub_e_p`2") (("2" (expand "rewrite_rule?") (("2" (flatten) (("2" (expand "subtermOF") (("2" (rewrite "empty_0") (("2" (expand "lhs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (use "mnt_reduces_at_root_to_nt") (("2" (skeep :preds? t) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -4 "(t,u)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil) ((mnt_to_nt_by_root_reduction const-decl "[term, term]" dp_termination nil) (empty_seq_is_position formula-decl nil positions nil) (empty? const-decl "bool" sets nil) (mnt_reduces_at_root_to_nt formula-decl nil dp_termination nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (restriction const-decl "term" substitution nil) (rhs const-decl "term" rewrite_rules nil) (member const-decl "bool" sets nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (= const-decl "[T, T -> boolean]" equalities nil) (ext def-decl "term" substitution nil) (lhs const-decl "term" rewrite_rules nil) (lhs_term skolem-const-decl "term[variable, symbol, arity]" dp_termination nil) (subtermOF def-decl "term" subterm nil) (sub_e_p skolem-const-decl "({(sigma: Sub[variable, symbol, arity],
   e: rewrite_rule[variable, symbol, arity],
   p:
     positions?
         [variable, symbol, arity](rhs[variable, symbol, arity](e))) |
    member[rewrite_rule[variable, symbol, arity]](e, E) AND
     ext[variable, symbol, arity](sigma)(lhs[variable, symbol, arity](e)) =
      lhs_term
      AND
      minimal_non_terminating?(E)
                              (subtermOF[variable, symbol, arity]
                                   (ext[variable, symbol, arity]
                                    (sigma)
                                    (rhs[variable, symbol, arity](e)),
                                    p))})" dp_termination nil) (Vars const-decl "set[(V)]" subterm nil) (terminating_sub? const-decl "bool" reduction nil) (restriction_term formula-decl nil substitution nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (ext_preserv_pos formula-decl nil substitution nil) (/= const-decl "boolean" notequal nil) (p skolem-const-decl "positions?[variable, symbol, arity](lhs[variable, symbol, arity](sub_e_p`2))" dp_termination nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (subterm_ext_commute formula-decl nil substitution nil) (empty_0 formula-decl nil seq_extras structures) (subset? const-decl "bool" sets nil) (Dom const-decl "set[(V)]" substitution nil) (restriction_Subs formula-decl nil substitution nil) (terminating_inst_of_rule_with_mint_on_rhs_gives_dp_alt formula-decl nil dp_termination nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_reduction? const-decl "bool" reduction nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (terminating? const-decl "bool" noetherian nil) (reduction? const-decl "bool" reduction nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (dp_and_sub_from_first_root_reduction subtype "(dp_termination.sub_e_p`2, dp_termination.sub_e_p`3)" "dep_pair_alt[dp_termination.variable, dp_termination.symbol, dp_termination.arity](dp_termination.E)")) (dp_and_sub_from_first_root_reduction_TCC3-1 nil 3763825735 ("" (skeep* :preds? t) (("" (expand "mnt_to_nt_by_root_reduction") (("" (typepred "choose({(t: term), (u: term) |
                 minimal_non_terminating?(E)(t) AND
                  RTC(non_root_reduction?(E))(s, t) AND
                   reduction_fix?(E)(t, u, empty_seq) AND
                    NOT terminating?(reduction?(E))(u)})") (("1" (replaces -8 :dir rl) (("1" (lemma "terminating_inst_of_rule_with_mint_on_rhs_gives_dp_alt") (("1" (inst -1 "E" "sub_e_p`2" "restriction(sub_e_p`1)(Vars(lhs(sub_e_p`2)))" "sub_e_p`3") (("1" (assert) (("1" (use "restriction_term") (("1" (assert) (("1" (hide-all-but 1) (("1" (typepred "sub_e_p`2") (("1" (expand "rewrite_rule?") (("1" (flatten) (("1" (expand "rhs") (("1" (expand "lhs") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "ext_preserv_pos") (("2" (assert) nil nil)) nil) ("3" (use "restriction_Subs") (("3" (assert) (("3" (replaces -6 :dir rl) (("3" (hide-all-but (-1 -2 1)) (("3" (expand "minimal_non_terminating?") (("3" (flatten) (("3" (expand "terminating_sub?") (("3" (skeep :preds? t) (("3" (expand "Dom") (("3" (expand "/=") (("3" (assert) (("3" (expand "restriction" 1) (("3" (expand "member") (("3" (lift-if) (("3" (prop) (("3" (expand "Vars" -1) (("3" (skeep :preds? t) (("3" (inst -5 "p") (("1" (use "subterm_ext_commute") (("1" (assert) (("1" (replace -1 -6) (("1" (replace -3 -6) (("1" (case-replace "ext(sub_e_p`1)(x) = restriction[variable, symbol, arity]
                       (sub_e_p`1)
                       (Vars[variable, symbol, arity]
                            (lhs[variable, symbol, arity](sub_e_p`2)))
                       (x)") (("1" (hide-all-but (-3 -4 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "ext_preserv_pos") (("2" (assert) (("2" (hide-all-but (-2 -4 -5)) (("2" (typepred "sub_e_p`2") (("2" (expand "rewrite_rule?") (("2" (flatten) (("2" (expand "subtermOF") (("2" (rewrite "empty_0") (("2" (expand "lhs") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (use "mnt_reduces_at_root_to_nt") (("2" (skeep :preds? t) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -4 "(t,u)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil) ((empty_seq_is_position formula-decl nil positions nil) (empty? const-decl "bool" sets nil) (subterm_ext_commute formula-decl nil substitution nil) (empty_0 formula-decl nil seq_extras structures) (subset? const-decl "bool" sets nil) (Dom const-decl "set[(V)]" substitution nil) (restriction_Subs formula-decl nil substitution nil) (ext_preserv_pos formula-decl nil substitution nil) (restriction_term formula-decl nil substitution nil) (terminating_sub? const-decl "bool" reduction nil) (Vars const-decl "set[(V)]" subterm nil) (subtermOF def-decl "term" subterm nil) (lhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (member const-decl "bool" sets nil) (rhs const-decl "term" rewrite_rules nil) (restriction const-decl "term" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_reduction? const-decl "bool" reduction nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (reduction_fix? const-decl "bool" reduction nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (terminating? const-decl "bool" noetherian nil) (reduction? const-decl "bool" reduction nil)) nil (dp_and_sub_from_first_root_reduction subtype "(dp_termination.sub_e_p`2, dp_termination.sub_e_p`3)" "dep_pair_alt[dp_termination.variable, dp_termination.symbol, dp_termination.arity](dp_termination.E)"))) (next_inst_dp_is_chained_and_mnt_TCC1 0 (next_inst_dp_is_chained_and_mnt_TCC1-1 nil 3763825735 ("" (skeep* :preds? t) (("" (expand "dep_pair_alt?") (("" (flatten) (("" (use "ext_preserv_pos") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((dep_pair_alt? const-decl "bool" dependency_pairs nil) (ext_preserv_pos formula-decl nil substitution nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (rhs const-decl "term" rewrite_rules nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (next_inst_dp_is_chained_and_mnt subtype "dp_termination.dp`2" "positions?[dp_termination.variable, dp_termination.symbol, dp_termination.arity](substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.sigma)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp`1)))"))) (next_inst_dp_is_chained_and_mnt_TCC2 0 (next_inst_dp_is_chained_and_mnt_TCC2-1 nil 3763825735 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (ext def-decl "term" substitution nil) (terminating? const-decl "bool" noetherian nil) (reduction? const-decl "bool" reduction nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (defined? const-decl "bool" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (member const-decl "bool" sets nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (rhs const-decl "term" rewrite_rules nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (next_inst_dp_is_chained_and_mnt subtype "dp_termination.dp`2" "positions?[dp_termination.variable, dp_termination.symbol, dp_termination.arity](rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp`1))"))) (next_inst_dp_is_chained_and_mnt_TCC3 0 (next_inst_dp_is_chained_and_mnt_TCC3-1 nil 3763825735 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (ext def-decl "term" substitution nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (defined? const-decl "bool" rewrite_rules nil) (member const-decl "bool" sets nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (lhs const-decl "term" rewrite_rules nil) (rhs const-decl "term" rewrite_rules nil) (reduction? const-decl "bool" reduction nil) (term type-decl nil term_adt nil) (terminating? const-decl "bool" noetherian nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (next_inst_dp_is_chained_and_mnt subtype "subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.sigma)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp`1)), dp_termination.dp`2)" "{s: term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term | dp_termination.minimal_non_terminating?(dp_termination.E)(s)}"))) (next_inst_dp_is_chained_and_mnt_TCC4 0 (next_inst_dp_is_chained_and_mnt_TCC4-1 nil 3763825735 ("" (skeep* :preds? t) (("" (typepred "next_dp_sub`1") (("" (expand "dep_pair_alt?") (("" (flatten) nil nil)) nil)) nil)) nil) ((Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (next_inst_dp_is_chained_and_mnt subtype "dp_termination.next_dp_sub`1`2" "positions?[dp_termination.variable, dp_termination.symbol, dp_termination.arity](rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.next_dp_sub`1`1))"))) (next_inst_dp_is_chained_and_mnt_TCC5 0 (next_inst_dp_is_chained_and_mnt_TCC5-2 "" 3804432011 ("" (skeep* :preds? t) (("" (hide-all-but (-1 -5 1)) (("" (expand "dep_pair_alt?") (("" (expand "dep_pair?") (("" (flatten) (("" (assert) (("" (inst?) (("" (assert) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dep_pair? const-decl "bool" dependency_pairs nil) (positions? type-eq-decl nil positions nil) (rhs const-decl "term" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (set type-eq-decl nil sets nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (next_inst_dp_is_chained_and_mnt subtype "dp_termination.std_dp" "dep_pair[dp_termination.variable, dp_termination.symbol, dp_termination.arity](dp_termination.E)")) (next_inst_dp_is_chained_and_mnt_TCC5-1 nil 3763825735 ("" (skeep* :preds? t) (("" (hide-all-but (-2 -5 1)) (("" (expand "dep_pair_alt?") (("" (expand "dep_pair?") (("" (flatten) (("" (assert) (("" (inst?) (("" (assert) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dep_pair? const-decl "bool" dependency_pairs nil) (positions? type-eq-decl nil positions nil) (rhs const-decl "term" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (set type-eq-decl nil sets nil) (position type-eq-decl nil positions nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil)) nil (next_inst_dp_is_chained_and_mnt subtype "dp_termination.std_dp" "dep_pair[dp_termination.variable, dp_termination.symbol, dp_termination.arity](dp_termination.E)"))) (next_inst_dp_is_chained_and_mnt_TCC6 0 (next_inst_dp_is_chained_and_mnt_TCC6-1 nil 3763825735 ("" (skeep* :preds? t) (("" (replaces -7) (("" (typepred "next_dp_sub`1") (("" (hide-all-but (-1 1)) (("" (expand "dep_pair_alt?") (("" (expand "dep_pair?") (("" (flatten) (("" (assert) (("" (inst?) (("" (assert) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dep_pair? const-decl "bool" dependency_pairs nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (rhs const-decl "term" rewrite_rules nil) (positions? type-eq-decl nil positions nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (next_inst_dp_is_chained_and_mnt subtype "dp_termination.next_std_dp" "dep_pair[dp_termination.variable, dp_termination.symbol, dp_termination.arity](dp_termination.E)"))) (next_inst_dp_is_chained_and_mnt 0 (next_inst_dp_is_chained_and_mnt-1 nil 3763834823 ("" (skeep* :preds? t) (("" (assert) (("" (expand "dp_and_sub_from_first_root_reduction") (("" (typepred "choose
                                     ({(sigma_1: Sub),
                                       (e: rewrite_rule),
                                       (p: positions?(rhs(e)))
                                       |
                                       member(e, E)
                                       AND
                                       ext(sigma_1)(lhs(e))
                                       =
                                       mnt_to_nt_by_root_reduction
                                       (E)
                                       (subtermOF
                                        (ext(sigma)(rhs(dp`1)), dp`2))`1
                                       AND
                                       minimal_non_terminating?
                                       (E)
                                       (subtermOF
                                        (ext(sigma_1)(rhs(e)), p))})") (("1" (name-replace "s_e_p" "choose
                                     ({(sigma_1: Sub),
                                       (e: rewrite_rule),
                                       (p: positions?(rhs(e)))
                                       |
                                       member(e, E)
                                       AND
                                       ext(sigma_1)(lhs(e))
                                       =
                                       mnt_to_nt_by_root_reduction
                                       (E)
                                       (subtermOF
                                        (ext(sigma)(rhs(dp`1)), dp`2))`1
                                       AND
                                       minimal_non_terminating?
                                       (E)
                                       (subtermOF
                                        (ext(sigma_1)(rhs(e)), p))})") (("1" (expand "mnt_to_nt_by_root_reduction") (("1" (typepred "choose({(t: term), (u: term) |
                 minimal_non_terminating?(E)(t) AND
                  RTC(non_root_reduction?(E))
                     (subtermOF(ext(sigma)(rhs(dp`1)), dp`2), t)
                   AND
                   reduction_fix?(E)(t, u, empty_seq) AND
                    NOT terminating?(reduction?(E))(u)})") (("1" (name-replace "cTerm" "choose({(t: term), (u: term) |
                 minimal_non_terminating?(E)(t) AND
                  RTC(non_root_reduction?(E))
                     (subtermOF(ext(sigma)(rhs(dp`1)), dp`2), t)
                   AND
                   reduction_fix?(E)(t, u, empty_seq) AND
                    NOT terminating?(reduction?(E))(u)})") (("1" (prop) (("1" (expand "chained_dp?") (("1" (assert) (("1" (lemma "subterm_ext_commute") (("1" (inst -1 "dp`2" "rhs(dp`1)" "sigma") (("1" (assert) (("1" (expand "dep_pair_alt?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (typepred "s_e_p`3") (("2" (use "subterm_ext_commute") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (use "mnt_reduces_at_root_to_nt") (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (skeep) (("2" (inst -3 "(t,u)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (rewrite "empty_seq_is_position") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "reduced_nt_by_root_has_mnt") (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (skolem -1 ("sigma1" "e1" "p1")) (("2" (inst -2 "(sigma1, e1, p1)") (("2" (flatten) (("2" (assert) (("2" (typepred "e1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep :preds? t) (("3" (use "ext_preserv_pos") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (subtermOF def-decl "term" subterm nil) (mnt_to_nt_by_root_reduction const-decl "[term, term]" dp_termination nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (lhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (positions? type-eq-decl nil positions nil) (rhs const-decl "term" rewrite_rules nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (empty_seq_is_position formula-decl nil positions nil) (empty? const-decl "bool" sets nil) (mnt_reduces_at_root_to_nt formula-decl nil dp_termination nil) (chained_dp? const-decl "bool" dp_termination nil) (subterm_ext_commute formula-decl nil substitution nil) (pred type-eq-decl nil defined_types nil) (reflexive_transitive? const-decl "bool" relations_closure nil) (reflexive_transitive type-eq-decl nil relations_closure nil) (RTC const-decl "reflexive_transitive" relations_closure nil) (non_root_reduction? const-decl "bool" reduction nil) (reduction_fix? const-decl "bool" reduction nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (terminating? const-decl "bool" noetherian nil) (reduction? const-decl "bool" reduction nil) (reduced_nt_by_root_has_mnt formula-decl nil dp_termination nil) (ext_preserv_pos formula-decl nil substitution nil) (dp_and_sub_from_first_root_reduction const-decl "[dep_pair_alt(E), Sub]" dp_termination nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (next_dp_and_subs_TCC1 0 (next_dp_and_subs_TCC1-1 nil 3763836407 ("" (skeep* :preds? t) (("" (typepred "dp_s`1") (("" (expand "dep_pair_alt?") (("" (flatten) (("" (use "ext_preserv_pos") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((rhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (next_dp_and_subs subtype "dp_termination.dp_s`1`2" "positions?[dp_termination.variable, dp_termination.symbol, dp_termination.arity](rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_s`1`1))"))) (next_dp_and_subs_TCC2 0 (next_dp_and_subs_TCC3-1 nil 3763836407 ("" (skeep* :preds? t) (("" (hide -) (("" (typepred "dp_s`1") (("" (expand "dep_pair_alt?") (("" (expand "dep_pair?") (("" (flatten) (("" (assert) (("" (inst?) (("" (assert) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dep_pair? const-decl "bool" dependency_pairs nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (ext def-decl "term" substitution nil) (rhs const-decl "term" rewrite_rules nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (next_dp_and_subs subtype "(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].lhs(dp_termination.dp_s`1`1), subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_s`1`1), dp_termination.dp_s`1`2))" "dep_pair[dp_termination.variable, dp_termination.symbol, dp_termination.arity](dp_termination.E)"))) (next_dp_and_subs_TCC3 0 (next_dp_and_subs_TCC4-1 nil 3763836407 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (defined? const-decl "bool" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (member const-decl "bool" sets nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (rhs const-decl "term" rewrite_rules nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (next_dp_and_subs subtype "dp_termination.dp_`2" "positions?[dp_termination.variable, dp_termination.symbol, dp_termination.arity](rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_`1))"))) (next_dp_and_subs_TCC4 0 (next_dp_and_subs_TCC5-1 nil 3763836407 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Vars const-decl "set[(V)]" subterm nil) (subset? const-decl "bool" sets nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (E!1 skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (e!1 skolem-const-decl "{e | member(e, E!1)}" dp_termination nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (sigma!1 skolem-const-decl "Sub[variable, symbol, arity]" dp_termination nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (dp!1 skolem-const-decl "dep_pair_alt[variable, symbol, arity](E!1)" dp_termination nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (lhs const-decl "term" rewrite_rules nil) (defined? const-decl "bool" rewrite_rules nil) (member const-decl "bool" sets nil) (dep_pair? const-decl "bool" dependency_pairs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (rhs const-decl "term" rewrite_rules nil) (Dom const-decl "set[(V)]" substitution nil) (/= const-decl "boolean" notequal nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil)) nil (next_dp_and_subs subtype "(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].lhs(dp_termination.dp_`1), subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_`1), dp_termination.dp_`2))" "dep_pair[dp_termination.variable, dp_termination.symbol, dp_termination.arity](dp_termination.E)"))) (next_dp_and_subs_TCC5 0 (next_dp_and_subs_TCC5-1 "" 3884906757 ("" (skeep* :preds? t) (("" (typepred "dp_s`1") (("" (expand "dep_pair_alt?") (("" (flatten) (("" (use "ext_preserv_pos") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak (next_dp_and_subs subtype "dp_termination.dp_s`1`2" "positions?[dp_termination.variable, dp_termination.symbol, dp_termination.arity](substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.dp_s`2)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_s`1`1)))")) (next_dp_and_subs_TCC2-1 nil 3763836407 ("" (skeep* :preds? t) (("" (hide -) (("" (typepred "dp_s`1") (("" (expand "dep_pair_alt?") (("" (flatten) nil nil)) nil)) nil)) nil)) nil) ((rhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (ext_preserv_pos formula-decl nil substitution nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (next_dp_and_subs subtype "dp_termination.dp_s`1`2" "positions?[dp_termination.variable, dp_termination.symbol, dp_termination.arity](substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.dp_s`2)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_s`1`1)))"))) (next_dp_and_subs_TCC6 0 (next_dp_and_subs_TCC6-1 nil 3763836407 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (ext def-decl "term" substitution nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (rhs const-decl "term" rewrite_rules nil) (lhs const-decl "term" rewrite_rules nil) (reduction? const-decl "bool" reduction nil) (term type-decl nil term_adt nil) (terminating? const-decl "bool" noetherian nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (next_dp_and_subs subtype "subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.dp_s`2)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_s`1`1)), dp_termination.dp_s`1`2)" "{s: term_adt[dp_termination.variable, dp_termination.symbol, dp_termination.arity].term | dp_termination.minimal_non_terminating?(dp_termination.E)(s)}"))) (next_dp_and_subs_TCC7 0 (next_dp_and_subs_TCC7-1 nil 3763836407 ("" (skeep* :preds? t) (("" (use "next_inst_dp_is_chained_and_mnt") (("" (assert) (("" (flatten) (("" (assert) (("" (hide -1 -3) (("" (lemma "subterm_ext_commute") (("" (inst -1 "dp_and_sub_from_first_root_reduction
                                    (E)
                                    (subtermOF[variable, symbol, arity]
                                     (ext[variable, symbol, arity]
                                      (dp_s`2)
                                      (rhs[variable, symbol, arity]
                                       (dp_s`1`1)),
                                      dp_s`1`2))`1`2" "_" "_") (("" (inst -1 "rhs[variable, symbol, arity]
                                     (dp_and_sub_from_first_root_reduction
                                      (E)
                                      (subtermOF[variable, symbol, arity]
                                       (ext[variable, symbol, arity]
                                        (dp_s`2)
                                        (rhs[variable, symbol, arity]
                                         (dp_s`1`1)),
                                        dp_s`1`2))`1`1)" "_") (("" (inst -1 "dp_and_sub_from_first_root_reduction
                                     (E)
                                     (subtermOF[variable, symbol, arity]
                                      (ext[variable, symbol, arity]
                                       (dp_s`2)
                                       (rhs[variable, symbol, arity]
                                        (dp_s`1`1)),
                                       dp_s`1`2))`2") (("" (assert) (("" (hide 2) (("" (typepred "dp_and_sub_from_first_root_reduction(E)
                                                      (subtermOF
                                                       [variable,
                                                        symbol,
                                                        arity]
                                                       (ext
                                                        [variable,
                                                         symbol,
                                                         arity]
                                                        (dp_s`2)
                                                        (rhs
                                                         [variable,
                                                          symbol,
                                                          arity]
                                                         (dp_s`1`1)),
                                                        dp_s`1`2))`1") (("" (expand "dep_pair_alt?") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((next_inst_dp_is_chained_and_mnt formula-decl nil dp_termination nil) (rhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (dp_and_sub_from_first_root_reduction const-decl "[dep_pair_alt(E), Sub]" dp_termination nil) (NOT const-decl "[bool -> bool]" booleans nil) (subterm_ext_commute formula-decl nil substitution nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (next_dp_and_subs subtype "dp_termination.dp_and_sub_from_first_root_reduction(dp_termination.E)(subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(dp_termination.dp_s`2)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_s`1`1)), dp_termination.dp_s`1`2))" "{(dp_: dependency_pairs[dp_termination.variable, dp_termination.symbol, dp_termination.arity].dep_pair_alt(dp_termination.E), sigma_: substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].Sub) | booleans.AND(dp_termination.chained_dp?(dp_termination.E)((rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].lhs(dp_termination.dp_s`1`1), subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_termination.dp_s`1`1), dp_termination.dp_s`1`2)), (rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].lhs(dp_`1), subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_`1), dp_`2)))(dp_termination.dp_s`2, sigma_), dp_termination.minimal_non_terminating?(dp_termination.E)(subterm[dp_termination.variable, dp_termination.symbol, dp_termination.arity].subtermOF(substitution[dp_termination.variable, dp_termination.symbol, dp_termination.arity].ext(sigma_)(rewrite_rules[dp_termination.variable, dp_termination.symbol, dp_termination.arity].rhs(dp_`1)), dp_`2)))}"))) (dp_termination_implies_noetherian 0 (dp_termination_implies_noetherian-1 nil 3763836700 ("" (skeep) (("" (rewrite "dp_termination_and_alt_eq" :dir rl) (("" (expand "noetherian?") (("" (rewrite "no_infinite_descending_sequence") (("" (expand "empty?") (("" (expand "member") (("" (expand "descending?") (("" (expand "converse") (("" (skolem 1 "seqTerms") (("" (inst-cp -2 0) (("" (assert) (("" (case "NOT terminating?(reduction?(E))(seqTerms(0))") (("1" (use "non_terminating_has_mnt") (("1" (skeep) (("1" (hide -3 -4 1) (("1" (lemma "recursion_theorem[[dep_pair_alt(E), Sub]]") (("1" (name-replace "mnt1" "subtermOF(seqTerms(0),p)") (("1" (inst -1 "{(dp: dep_pair_alt(E), sigma: Sub) | minimal_non_terminating?(E)(subtermOF(ext(sigma)(rhs(dp`1)), dp`2))}" "dp_and_sub_from_first_root_reduction(E)(mnt1)" "next_dp_and_subs(E)") (("1" (skolem -1 "u1") (("1" (flatten) (("1" (expand "dp_termination_alt?") (("1" (inst -4 "LAMBDA(i:nat): u1(i)`1" "LAMBDA(j:nat): u1(j)`2") (("1" (expand "infinite_dep_chain?") (("1" (skeep) (("1" (inst -2 "i") (("1" (typepred "u1(i)") (("1" (typepred "u1(i+1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "member") (("2" (expand "dp_and_sub_from_first_root_reduction") (("2" (typepred "choose
                                            ({(sigma: Sub),
                                              (e: rewrite_rule),
                                              (p: positions?(rhs(e)))
                                              |
                                              member(e, E)
                                              AND
                                              ext(sigma)(lhs(e))
                                              =
                                              mnt_to_nt_by_root_reduction
                                              (E)(mnt1)`1
                                              AND
                                              minimal_non_terminating?
                                              (E)
                                              (subtermOF
                                               (ext(sigma)(rhs(e)), p))})") (("1" (propax) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep :preds? t) (("3" (expand "dep_pair_alt?") (("3" (flatten) (("3" (assert) (("3" (use "ext_preserv_pos") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "dp_and_sub_from_first_root_reduction(E)(subtermOF(seqTerms(0), p))") nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -4) (("2" (expand "terminating?") (("2" (inst 1 "seqTerms") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dp_termination_and_alt_eq formula-decl nil dp_termination nil) (variable formal-nonempty-type-decl nil dp_termination nil) (symbol formal-nonempty-type-decl nil dp_termination nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" dp_termination nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (no_infinite_descending_sequence formula-decl nil well_foundedness orders) (pred type-eq-decl nil defined_types nil) (converse const-decl "pred[[T2, T1]]" relation_defs nil) (reduction? const-decl "bool" reduction nil) (member const-decl "bool" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (terminating? const-decl "bool" noetherian nil) (sequence type-eq-decl nil sequences nil) (recursion_theorem formula-decl nil seq_recursion_theorem nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (dep_pair_alt? const-decl "bool" dependency_pairs nil) (dep_pair_alt type-eq-decl nil dependency_pairs nil) (V const-decl "set[term[variable, symbol, arity]]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (TRUE const-decl "bool" booleans nil) (minimal_non_terminating? const-decl "bool" dp_termination nil) (mnt1 skolem-const-decl "term[variable, symbol, arity]" dp_termination nil) (ext def-decl "term" substitution nil) (rhs const-decl "term" rewrite_rules nil) (dp_and_sub_from_first_root_reduction const-decl "[dep_pair_alt(E), Sub]" dp_termination nil) (next_dp_and_subs const-decl "{(dp_: dep_pair_alt(E), sigma_: Sub) |
   chained_dp?(E)
              ((lhs(dp_s`1`1), subtermOF(rhs(dp_s`1`1), dp_s`1`2)),
               (lhs(dp_`1), subtermOF(rhs(dp_`1), dp_`2)))
              (dp_s`2, sigma_)
    AND
    minimal_non_terminating?(E)(subtermOF(ext(sigma_)(rhs(dp_`1)), dp_`2))}" dp_termination nil) (lhs const-decl "term" rewrite_rules nil) (chained_dp? const-decl "bool" dp_termination nil) (dep_pair type-eq-decl nil dependency_pairs nil) (dep_pair? const-decl "bool" dependency_pairs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (infinite_dep_chain? const-decl "bool" dp_termination nil) (dp_termination_alt? const-decl "bool" dp_termination nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (mnt_to_nt_by_root_reduction const-decl "[term, term]" dp_termination nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (ext_preserv_pos formula-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (p skolem-const-decl "positions?[variable, symbol, arity](seqTerms(0))" dp_termination nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" dp_termination nil) (seqTerms skolem-const-decl "sequence[term[variable, symbol, arity]]" dp_termination nil) (non_terminating_has_mnt formula-decl nil dp_termination nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (descending? const-decl "bool" monotone_sequences orders) (empty? const-decl "bool" sets nil) (noetherian? const-decl "bool" noetherian nil)) nil)))
