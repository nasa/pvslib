(substitution (Ren?_TCC1 0 (Ren?_TCC1-1 nil 3414773644 ("" (skolem-typepred) (("" (flatten) (("" (skolem-typepred) (("" (hide -4) (("" (expand* "Ran" "member") (("" (inst 1 "x1!1") nil nil)) nil)) nil)) nil)) nil)) nil) ((Ran const-decl "set[term[variable, symbol, arity]]" substitution nil) (member const-decl "bool" sets nil) (Dom const-decl "set[(V)]" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (Ren? subtype "restrict[(variables_term[substitution.variable, substitution.symbol, substitution.arity].V), (substitution.Dom(substitution.sigma)), term_adt[substitution.variable, substitution.symbol, substitution.arity].term].restrict(substitution.sigma)" "[(substitution.Dom(substitution.sigma)) -> (substitution.Ran(substitution.sigma))]"))) (range_finite 0 (range_finite-1 nil 3415026692 ("" (skolem-typepred) (("" (expand* "Sub?" "Ren?" "subset?" "member") (("" (flatten) (("" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].bijective_inverse_exists") (("" (inst -1 "rho!1") (("" (expand "exists1") (("" (flatten) (("" (hide -2) (("" (skosimp*) (("" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].bij_inv_is_bij_alt") (("" (inst -1 "rho!1" "x!1") (("" (expand "bijective?" -1) (("" (flatten) (("" (expand "is_finite") (("" (skolem-typepred) (("" (inst 1 "N!1" "f!1 o x!1") (("" (lemma "function_props[(Ran(rho!1)), (Dom(rho!1)), below[N!1]].composition_injective") (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (Ran const-decl "set[term[variable, symbol, arity]]" substitution nil) (Dom const-decl "set[(V)]" substitution nil) (bijective_inverse_exists formula-decl nil function_inverse_def nil) (exists1 const-decl "bool" exists1 nil) (bij_inv_is_bij_alt formula-decl nil function_inverse_def nil) (is_finite const-decl "bool" finite_sets nil) (O const-decl "T3" function_props nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (f!1 skolem-const-decl "[(Dom(rho!1)) -> below[N!1]]" substitution nil) (N!1 skolem-const-decl "nat" substitution nil) (injective? const-decl "bool" functions nil) (composition_injective judgement-tcc nil function_props nil) (x!1 skolem-const-decl "[(Ran(rho!1)) -> (Dom(rho!1))]" substitution nil) (inverse? const-decl "bool" function_inverse_def nil) (restrict const-decl "R" restrict nil) (bijective? const-decl "bool" functions nil) (rho!1 skolem-const-decl "Ren" substitution nil) (Ren type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (exists_var 0 (exists_var-1 nil 3414319958 ("" (skolem-typepred) (("" (case "NOT empty?(complement(union(V1!1, V2!1)))") (("1" (lemma "choose_member") (("1" (inst -1 "complement(union(V1!1, V2!1))") (("1" (prop) (("1" (expand "member") (("1" (expand "extend" -1 1) (("1" (prop) (("1" (expand "complement" -2 1) (("1" (expand "member") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "empty?") (("2" (skosimp*) (("2" (inst?) (("2" (expand "member") (("2" (expand "extend") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (lemma "var_countable") (("2" (case-replace "complement(union(V1!1, V2!1)) = difference(V, union(V1!1, V2!1))" :hide? T) (("1" (lemma "countable_props[term].countably_infinite_difference") (("1" (inst -1 "V" "union(V1!1, V2!1)") (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality 1) (("2" (iff) (("2" (prop) (("1" (expand "restrict") (("1" (expand* "complement" "difference" "union" "member") (("1" (expand "extend") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand* "restrict" "complement" "difference" "union" "member" "extend") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((union const-decl "set" sets nil) (complement const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (finite_union application-judgement "finite_set[(V)]" substitution nil) (extend const-decl "R" extend nil) (FALSE const-decl "bool" booleans nil) (member const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (choose_member formula-decl nil sets_lemmas nil) (var_countable formula-decl nil substitution nil) (countably_infinite_difference judgement-tcc nil countable_props sets_aux) (injective? const-decl "bool" functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (surjective? const-decl "bool" functions nil) (V2!1 skolem-const-decl "finite_set[(V)]" substitution nil) (x!1 skolem-const-decl "(V)" substitution nil) (V1!1 skolem-const-decl "finite_set[(V)]" substitution nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bijective? const-decl "bool" functions nil) (countably_infinite_set type-eq-decl nil countability sets_aux) (is_countably_infinite const-decl "bool" countability sets_aux) (difference const-decl "set" sets nil) (restrict const-decl "R" restrict nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_extend application-judgement "finite_set[T]" extend_set_props nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (restriction_Dom 0 (restriction_Dom-1 nil 3411923200 ("" (skeep) (("" (expand* "subset?" "member" "Dom" "restriction") (("" (skeep) (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (restriction const-decl "term" substitution nil) (Dom const-decl "set[(V)]" substitution nil) (subset? const-decl "bool" sets nil)) shostak)) (restriction_Dom_fin 0 (restriction_Dom_fin-1 nil 3411923327 ("" (skeep) (("" (lemma "restriction_Dom") (("" (inst?) (("" (lemma "fsetvar.finite_subset") (("" (typepred "sigma") (("" (expand "Sub?") (("" (inst?) (("" (lemma "fsetvar.finite_subset") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((restriction_Dom formula-decl nil substitution nil) (finite_subset formula-decl nil finite_sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (restriction const-decl "term" substitution nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (Dom const-decl "set[(V)]" substitution nil) (sigma skolem-const-decl "Sub" substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil)) shostak)) (restriction_Subs 0 (restriction_Subs-1 nil 3411923411 ("" (skeep) (("" (lemma "restriction_Dom_fin") (("" (inst?) (("" (expand "Sub?") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((restriction_Dom_fin formula-decl nil substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil)) shostak)) (dom_restriction 0 (dom_restriction-1 nil 3411923505 ("" (skeep) (("" (expand* "subset?" "member") (("" (skeep) (("" (expand "Dom") (("" (expand "restriction") (("" (lift-if) (("" (prop) (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (Dom const-decl "set[(V)]" substitution nil) (restriction const-decl "term" substitution nil)) shostak)) (Dom_union 0 (Dom_union-1 nil 3400451836 ("" (skeep) (("" (decompose-equality) (("" (expand* "Dom" "union_subs" "union" "member") (("" (lift-if) (("" (expand "Dom") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((Dom const-decl "set[(V)]" substitution nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (disjoint_D? const-decl "bool" substitution nil) (disjoint_D type-eq-decl nil substitution nil) (union_subs const-decl "term" substitution nil) (union const-decl "set" sets nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (member const-decl "bool" sets nil)) shostak)) (union_is_sub 0 (union_is_sub-1 nil 3400459156 ("" (skeep) (("" (typepred "sgi`1" "sgi`2") (("" (expand "Sub?") (("" (lemma "fsetvar.finite_union") (("" (inst -1 "Dom(sgi`1)" "Dom(sgi`2)") (("" (lemma "Dom_union") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((disjoint_D type-eq-decl nil substitution nil) (disjoint_D? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finite_union judgement-tcc nil finite_sets nil) (Dom_union formula-decl nil substitution nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (Dom const-decl "set[(V)]" substitution nil) (sgi skolem-const-decl "disjoint_D" substitution nil)) shostak)) (union_commute_TCC1 0 (union_commute_TCC1-1 nil 3402055579 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (/= const-decl "boolean" notequal nil) (Dom const-decl "set[(V)]" substitution nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil) (disjoint_D? const-decl "bool" substitution nil)) nil (union_commute subtype "(substitution.sigma, substitution.tau)" "disjoint_D"))) (union_commute_TCC2 0 (union_commute_TCC2-1 nil 3402055579 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (/= const-decl "boolean" notequal nil) (Dom const-decl "set[(V)]" substitution nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil) (disjoint_D? const-decl "bool" substitution nil)) nil (union_commute subtype "(substitution.tau, substitution.sigma)" "disjoint_D"))) (union_commute 0 (union_commute-1 nil 3402055580 ("" (skeep) (("" (decompose-equality) (("" (expand "union_subs") (("" (lift-if) (("" (lift-if) (("" (prop) (("" (expand* "disjoint?" "empty?" "intersection") (("" (inst?) (("" (expand "member" 2 1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (disjoint_D? const-decl "bool" substitution nil) (disjoint_D type-eq-decl nil substitution nil) (union_subs const-decl "term" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (member const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil)) shostak)) (ext_TCC1 0 (ext_TCC1-1 nil 3391263310 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (V const-decl "set[term]" variables_term nil)) nil (ext subtype "substitution.t" "(variables_term[substitution.variable, substitution.symbol, substitution.arity].V)"))) (ext_TCC2 0 (ext_TCC2-1 nil 3391263310 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (finite_sequence type-eq-decl nil finite_sequences nil) (<< adt-def-decl "(strict_well_founded?[term])" term_adt nil) (subterm adt-def-decl "boolean" term_adt nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (ext termination "substitution.ext(substitution.sigma)(finite_sequences[term_adt[substitution.variable, substitution.symbol, substitution.arity].term].finseq_appl(substitution.st)(substitution.n))" "nil"))) (ext_TCC3 0 (ext_TCC3-1 nil 3391263310 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (finite_sequence type-eq-decl nil finite_sequences nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (ext subtype "substitution.sst" "{args: finite_sequences[term_adt[substitution.variable, substitution.symbol, substitution.arity].term].finite_sequence | args`length = substitution.arity(substitution.f)}"))) (iden_subs 0 (iden_subs-1 nil 3397944522 ("" (expand "Sub?") (("" (case-replace "Dom(identity) = emptyset") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Dom" "identity" "emptyset") nil nil)) nil)) nil)) nil) ((variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (= const-decl "[T, T -> boolean]" equalities nil) (Dom const-decl "set[(V)]" substitution nil) (bijective? const-decl "bool" functions nil) (identity const-decl "(bijective?[T, T])" identity nil) (emptyset const-decl "set" sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[(V)]" substitution nil) (Sub? const-decl "bool" substitution nil)) shostak)) (iden_rename_TCC1 0 (iden_rename_TCC1-1 nil 3414771081 ("" (rewrite "iden_subs") nil nil) ((iden_subs formula-decl nil substitution nil)) nil (iden_rename subtype "identity[(variables_term[substitution.variable, substitution.symbol, substitution.arity].V)].identity" "Sub"))) (iden_rename 0 (iden_rename-2 "" 3790333299 ("" (expand "Ren?") (("" (expand "subset?") (("" (expand "member") (("" (expand "Ran") (("" (typepred "identity") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (Ran const-decl "set[term[variable, symbol, arity]]" substitution nil) (Dom const-decl "set[(V)]" substitution nil) (restrict const-decl "R" restrict nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (bijective? const-decl "bool" functions nil) (identity const-decl "(bijective?[T, T])" identity nil) (member const-decl "bool" sets nil) (Ren? const-decl "bool" substitution nil) (restrict_of_inj_is_inj application-judgement "(injective?[S, R])" restrict nil)) shostak) (iden_rename-1 nil 3414771211 ("" (expand "Ren?") (("" (expand "subset?") (("" (skosimp*) (("" (expand "member") (("" (expand "Ran") (("" (skosimp*) (("" (typepred "identity") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (identity const-decl "(bijective?[T, T])" identity nil) (member const-decl "bool" sets nil)) shostak)) (ext_iden 0 (ext_iden-1 nil 3391281937 ("" (induct "t") (("1" (skeep) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (decompose-equality 1) (("1" (grind) nil nil) ("2" (decompose-equality 1) (("1" (inst?) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (decompose-equality 1) (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("3" (rewrite "iden_subs") nil nil)) nil) ((iden_subs formula-decl nil substitution nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (< const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term_app_extensionality formula-decl nil term_adt nil) (below type-eq-decl nil nat_types nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (app1_var skolem-const-decl "symbol" substitution nil) (app2_var skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var)}" substitution nil) (identity_preserves application-judgement "S" identity_props nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (ext def-decl "term" substitution nil) (Sub type-eq-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (bijective? const-decl "bool" functions nil) (identity const-decl "(bijective?[T, T])" identity nil)) shostak)) (restriction_term_TCC1 0 (restriction_term_TCC1-1 nil 3411924525 ("" (lemma "restriction_Subs") (("" (skosimp*) (("" (inst?) nil nil)) nil)) nil) ((variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (restriction_Subs formula-decl nil substitution nil)) nil (restriction_term subtype "substitution.restriction(substitution.sigma)(substitution.Vs)" "Sub"))) (restriction_term 0 (restriction_term-1 nil 3411924525 ("" (induct "t") (("1" (skeep) (("1" (skeep) (("1" (expand "ext") (("1" (expand "subset?") (("1" (inst?) (("1" (expand "restriction") (("1" (lift-if) (("1" (prop) (("1" (hide 2) (("1" (expand* "member" "Vars") (("1" (inst 2 "empty_seq") (("1" (expand "subtermOF") (("1" (lift-if) (("1" (rewrite "empty_0") nil nil)) nil)) nil) ("2" (expand "positionsOF") (("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "ext" 1) (("2" (lift-if) (("2" (prop) (("2" (decompose-equality 2) (("1" (decompose-equality 1) (("1" (expand "finseq_appl") (("1" (inst -1 "x!1") (("1" (inst -1 "Vs" "sigma") (("1" (assert) (("1" (hide 1) (("1" (expand "subset?") (("1" (skosimp*) (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (expand "member") (("1" (expand "Vars") (("1" (skosimp*) (("1" (inst 2 "add_first(x!1 + 1, p!1)") (("1" (expand "subtermOF" 2) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (lemma "fsepn.rest_add_first") (("2" (expand "finseq_appl") (("2" (inst -1 "p!1" "1 + x!1") (("2" (replaces -1) (("2" (rewrite "first_add") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positionsOF") (("2" (expand "union") (("2" (prop) (("2" (hide 1) (("2" (expand "member") (("2" (expand "IUnion") (("2" (typepred "x!1") (("2" (inst 1 "x!1 + 1") (("2" (expand "catenate") (("2" (inst 1 "p!1") (("2" (typepred "p!1") (("2" (expand* "finseq_appl" "member") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (rewrite "restriction_Subs") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (rewrite "restriction_Subs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (rewrite "restriction_Subs") nil nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (add_first const-decl "finseq" seq_extras structures) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (x!1 skolem-const-decl "below[app2_var`length]" substitution nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](app2_var`seq(x!1))" substitution nil) (rest_add_first formula-decl nil seq_extras structures) (first_add formula-decl nil seq_extras structures) (int_minus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (insert? const-decl "finseq" seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (union const-decl "set" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (<= const-decl "bool" reals nil) (catenate const-decl "positions" positions nil) (NOT const-decl "[bool -> bool]" booleans nil) (restriction_Subs formula-decl nil substitution nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term_app_extensionality formula-decl nil term_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (< const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app1_var skolem-const-decl "symbol" substitution nil) (app2_var skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var)}" substitution nil) (sigma skolem-const-decl "Sub" substitution nil) (Vs skolem-const-decl "set[(V)]" substitution nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (vars1_var skolem-const-decl "variable" substitution nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (positions? type-eq-decl nil positions nil) (empty_0 formula-decl nil seq_extras structures) (subtermOF def-decl "term" subterm nil) (only_empty_seq const-decl "positions" positions nil) (member const-decl "bool" sets nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (ext def-decl "term" substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (Vars const-decl "set[(V)]" subterm nil) (restriction const-decl "term" substitution nil)) shostak)) (restriction_union_TCC1 0 (restriction_union_TCC1-1 nil 3411923193 ("" (skosimp*) (("" (rewrite "union_is_sub") nil nil)) nil) ((union_is_sub formula-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (disjoint_D? const-decl "bool" substitution nil) (disjoint_D type-eq-decl nil substitution nil)) nil (restriction_union subtype "substitution.union_subs(substitution.sg1, substitution.sg2)" "Sub"))) (restriction_union 0 (restriction_union-1 nil 3411924894 ("" (induct "t") (("1" (skeep) (("1" (skeep) (("1" (expand "ext" 1 1) (("1" (expand "disjoint?" -2) (("1" (expand "empty?" -2) (("1" (expand "union_subs") (("1" (lift-if) (("1" (expand "member") (("1" (prop) (("1" (expand "ext") (("1" (propax) nil nil)) nil) ("2" (inst -3 "vars(vars1_var)") (("2" (expand* "intersection" "member") (("2" (expand "Vars" 3) (("2" (prop) (("2" (inst 1 "empty_seq") (("1" (expand "subtermOF") (("1" (lift-if) (("1" (rewrite "empty_0") nil nil)) nil)) nil) ("2" (expand "positionsOF") (("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "Dom" 3) (("3" (prop) (("3" (expand "ext") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "ext" 1) (("2" (lift-if) (("2" (prop) (("2" (decompose-equality 2) (("1" (decompose-equality 1) (("1" (expand "finseq_appl") (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (expand "disjoint?" (-2 2)) (("1" (expand "empty?" (-2 2)) (("1" (skosimp*) (("1" (inst?) (("1" (expand* "intersection" "member") (("1" (prop) (("1" (expand "Vars") (("1" (skosimp*) (("1" (inst 1 "add_first(x!1 + 1, p!1)") (("1" (expand "subtermOF" 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (lemma "fsepn.rest_add_first") (("2" (inst -1 "p!1" "x!1 + 1") (("2" (rewrite "first_add") (("2" (replaces -1) (("2" (expand "finseq_appl") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positionsOF") (("2" (expand "union") (("2" (prop) (("2" (hide 1) (("2" (expand "member") (("2" (expand "IUnion") (("2" (typepred "x!1") (("2" (inst 1 "x!1 + 1") (("2" (expand "catenate") (("2" (inst 1 "p!1") (("2" (typepred "p!1") (("2" (expand* "finseq_appl" "member") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (rewrite "union_is_sub") nil nil)) nil) ("3" (skeep) (("3" (expand "disjoint_D?") (("3" (propax) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (rewrite "union_is_sub") nil nil)) nil) ("3" (skeep) (("3" (expand "disjoint_D?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (rewrite "union_is_sub") nil nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (expand "disjoint_D?") (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (catenate const-decl "positions" positions nil) (<= const-decl "bool" reals nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (IUnion const-decl "set[T]" indexed_sets nil) (union const-decl "set" sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (insert? const-decl "finseq" seq_extras structures) (int_minus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (first_add formula-decl nil seq_extras structures) (rest_add_first formula-decl nil seq_extras structures) (p!1 skolem-const-decl "positions?[variable, symbol, arity](app2_var`seq(x!1))" substitution nil) (x!1 skolem-const-decl "below[app2_var`length]" substitution nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (add_first const-decl "finseq" seq_extras structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (union_is_sub formula-decl nil substitution nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term_app_extensionality formula-decl nil term_adt nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (sg2 skolem-const-decl "Sub" substitution nil) (sg1 skolem-const-decl "Sub" substitution nil) (app2_var skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var)}" substitution nil) (app1_var skolem-const-decl "symbol" substitution nil) (finite_sequence type-eq-decl nil finite_sequences nil) (< const-decl "bool" reals nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (only_empty_seq const-decl "positions" positions nil) (subtermOF def-decl "term" subterm nil) (empty_0 formula-decl nil seq_extras structures) (positions? type-eq-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (vars1_var skolem-const-decl "variable" substitution nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (member const-decl "bool" sets nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (ext def-decl "term" substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (disjoint_D type-eq-decl nil substitution nil) (union_subs const-decl "term" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (disjoint? const-decl "bool" sets nil) (Dom const-decl "set[(V)]" substitution nil) (Vars const-decl "set[(V)]" subterm nil) (disjoint_D? const-decl "bool" substitution nil)) shostak)) (ext_preserv_pos 0 (ext_preserv_pos-1 nil 3433011581 ("" (measure-induct+ "length(p)" "p") (("" (skeep) (("" (expand "positionsOF" 1) (("" (lift-if) (("" (prop) (("1" (hide -2) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "positionsOF") (("2" (lift-if) (("2" (prop) (("2" (expand "only_empty_seq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand* "union" "member" "only_empty_seq") (("3" (flatten) (("3" (expand "positionsOF" -2) (("3" (lift-if) (("3" (prop) (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil) ("3" (expand* "union" "member" "only_empty_seq") (("3" (prop) (("3" (expand "IUnion") (("3" (skolem * "i1") (("3" (expand "catenate" -1) (("3" (skolem * "q1") (("3" (flatten) (("3" (expand "member") (("3" (lemma "seq_extras[posnat].seq_first_rest") (("3" (inst -1 "x!1") (("3" (prop) (("1" (lemma "seq_extras[posnat].first_equal") (("1" (inst -1 "rest(x!1)" "q1" "first(x!1)" "i1") (("1" (assert) (("1" (flatten) (("1" (replace -2 * rl) (("1" (hide -3) (("1" (inst -5 "rest(x!1)") (("1" (inst 5 "i1") (("1" (expand "catenate") (("1" (inst 5 "rest(x!1)") (("1" (expand "member") (("1" (assert) (("1" (inst -5 "args(s)(i1 - 1)" "sigma") (("1" (prop) (("1" (case-replace "ext(sigma)(args(s)(i1 - 1)) = args(ext(sigma)(s))(i1 - 1)") (("1" (hide-all-but 1) (("1" (expand "finseq_appl") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (rewrite "length_rest") (("2" (prop) (("2" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i1") (("2" (expand "ext" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq type-eq-decl nil finite_sequences nil) (first_equal formula-decl nil seq_extras structures) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (length_rest formula-decl nil seq_extras structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty_0 formula-decl nil seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sigma skolem-const-decl "Sub" substitution nil) (i1 skolem-const-decl "upto?[position[variable, symbol, arity]](length(args(s)))" substitution nil) (s skolem-const-decl "term[variable, symbol, arity]" substitution nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rest const-decl "finseq" seq_extras structures) (/= const-decl "boolean" notequal nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (<= const-decl "bool" reals nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (seq_first_rest formula-decl nil seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (union const-decl "set" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (add_first const-decl "finseq" seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (member const-decl "bool" sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (ext def-decl "term" substitution nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (subterm_ext_commute_TCC1 0 (subterm_ext_commute_TCC1-1 nil 3433011808 ("" (skosimp*) (("" (lemma "ext_preserv_pos") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((ext_preserv_pos formula-decl nil substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (subterm_ext_commute subtype "substitution.p" "positions[substitution.variable, substitution.symbol, substitution.arity].positions?(substitution.ext(substitution.sigma)(substitution.s))"))) (subterm_ext_commute 0 (subterm_ext_commute-2 "" 3804433152 ("" (measure-induct+ "length(p)" "p") (("1" (skeep) (("1" (expand "positionsOF" -2) (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) (("1" (expand "subtermOF" (-5 1)) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst?) (("2" (assert) (("2" (expand "subtermOF" (-5 2)) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand* "union" "member" "only_empty_seq") (("3" (prop) (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) (("1" (expand "subtermOF" (-4 3)) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "IUnion") (("2" (skolem * "i1") (("2" (expand "catenate") (("2" (skolem * "y1") (("2" (expand "member") (("2" (flatten) (("2" (expand "subtermOF" 3) (("2" (lift-if) (("2" (prop) (("2" (lemma "fsepn.seq_first_rest") (("2" (inst?) (("2" (assert) (("2" (replace -1 -3) (("2" (lemma "fsepn.first_equal") (("2" (inst -1 "rest(x!1)" "y1" "first(x!1)" "i1") (("2" (assert) (("2" (flatten) (("2" (inst -6 "rest(x!1)") (("2" (inst -6 "args(s)(i1 - 1)" "sigma") (("2" (replace -1 * rl) (("2" (replace -2 * rl) (("2" (prop) (("1" (case-replace "ext(sigma)(args(s)(first(x!1) - 1)) = args(ext(sigma)(s))(first(x!1) - 1)") (("1" (hide-all-but 1) (("1" (expand "finseq_appl") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (rewrite "length_rest") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "ext_preserv_pos") nil nil) ("3" (rewrite "ext_preserv_pos") nil nil)) nil) nil shostak) (subterm_ext_commute-1 nil 3433011808 ("" (measure-induct+ "length(p)" "p") (("1" (skeep) (("1" (expand "positionsOF" -2) (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) (("1" (expand "subtermOF" (-5 1)) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst?) (("2" (assert) (("2" (expand "subtermOF" (-5 2)) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand* "union" "member" "only_empty_seq") (("3" (prop) (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) (("1" (expand "subtermOF" (-4 3)) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "IUnion") (("2" (skolem * "i1") (("2" (expand "catenate") (("2" (skolem * "y1") (("2" (expand "member") (("2" (flatten) (("2" (expand "subtermOF" 3) (("2" (lift-if) (("2" (prop) (("2" (lemma "fsepn.seq_first_rest") (("2" (inst?) (("2" (assert) (("2" (replace -1 -3) (("2" (lemma "fsepn.first_equal") (("2" (inst -1 "rest(x!1)" "y1" "first(x!1)" "i1") (("2" (assert) (("2" (flatten) (("2" (inst -6 "rest(x!1)") (("2" (inst -6 "args(s)(i1 - 1)" "sigma") (("2" (replace -1 * rl) (("2" (replace -2 * rl) (("2" (prop) (("1" (case-replace "ext(sigma)(args(s)(first(x!1) - 1)) = args(ext(sigma)(s))(first(x!1) - 1)") (("1" (hide-all-but 1) (("1" (expand "finseq_appl") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (rewrite "length_rest") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (rewrite "ext_preserv_pos") nil nil)) nil) ("3" (rewrite "ext_preserv_pos") nil nil)) nil) ((ext_preserv_pos formula-decl nil substitution nil) (length_rest formula-decl nil seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rest const-decl "finseq" seq_extras structures) (/= const-decl "boolean" notequal nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (<= const-decl "bool" reals nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (first_equal formula-decl nil seq_extras structures) (int_minus_int_is_int application-judgement "int" integers nil) (seq_first_rest formula-decl nil seq_extras structures) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (union const-decl "set" sets nil) (member const-decl "bool" sets nil) (finseq type-eq-decl nil finite_sequences nil) (empty_0 formula-decl nil seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (ext def-decl "term" substitution nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (positions_of_ext 0 (positions_of_ext-1 nil 3433012604 ("" (induct "t") (("1" (skeep) (("1" (skeep) (("1" (decompose-equality) (("1" (iff) (("1" (prop) (("1" (expand "union") (("1" (prop) (("1" (expand "member") (("1" (hide 1) (("1" (inst 1 "empty_seq" "x!1") (("1" (rewrite "empty_o_seq") (("1" (expand "subtermOF") (("1" (assert) (("1" (rewrite "empty_0") (("1" (assert) (("1" (hide -1) (("1" (expand "positionsOF") (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "union" "member") (("2" (prop) (("1" (rewrite "ext_preserv_pos") nil nil) ("2" (skosimp*) (("2" (expand "ext") (("2" (assert) (("2" (expand "positionsOF" -2) (("2" (expand "only_empty_seq") (("2" (expand "subtermOF") (("2" (rewrite "empty_0") (("2" (assert) (("2" (replaces -2) (("2" (rewrite "empty_o_seq") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (decompose-equality 1) (("2" (iff) (("2" (split) (("1" (flatten) (("1" (expand* "union" "member") (("1" (prop) (("1" (expand "positionsOF" -1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-2 1)) (("1" (expand "positionsOF") (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-2 2)) (("2" (grind) nil nil)) nil) ("3" (expand* "union" "member") (("3" (expand "IUnion") (("3" (prop) (("1" (hide-all-but (-1 3)) (("1" (grind) nil nil)) nil) ("2" (skosimp*) (("2" (expand "catenate") (("2" (skosimp*) (("2" (expand "member") (("2" (inst -3 "i!1 - 1") (("1" (inst -3 "sigma") (("1" (decompose-equality -3) (("1" (expand "finseq_appl") (("1" (expand "ext" -2) (("1" (prop) (("1" (grind) nil nil) ("2" (expand "finseq_appl") (("2" (inst -2 "x!2") (("2" (iff) (("2" (prop) (("1" (hide (-3 6)) (("1" (expand "positionsOF" 5) (("1" (assert) (("1" (expand* "union" "member") (("1" (prop) (("1" (expand "IUnion") (("1" (inst 6 "i!1") (("1" (expand "catenate") (("1" (inst 6 "x!2") (("1" (expand* "member" "finseq_appl") nil nil)) nil)) nil) ("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst 5 "add_first(i!1, p1!1)" "p2!1") (("2" (prop) (("1" (lemma "fsepn.add_first_compo") (("1" (inst -1 "p1!1" "p2!1" "i!1") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "positionsOF" 1) (("2" (assert) (("2" (expand* "union" "member") (("2" (prop) (("2" (expand "IUnion") (("2" (inst 2 "i!1") (("1" (expand "catenate") (("1" (inst 2 "p1!1") (("1" (expand* "member" "finseq_appl") nil nil)) nil)) nil) ("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subtermOF" 1) (("3" (lift-if) (("3" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (lemma "fsepn.rest_add_first") (("2" (inst -1 "p1!1" "i!1") (("2" (rewrite "fsepn.first_add") (("2" (replaces -1) (("2" (expand "finseq_appl") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "subtermOF" 1) (("4" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (lemma "fsepn.rest_add_first") (("2" (inst -1 "p1!1" "i!1") (("2" (rewrite "fsepn.first_add") (("2" (replaces -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positionsOF" -2) (("2" (lift-if) (("2" (prop) (("1" (expand "only_empty_seq") (("1" (hide -4) (("1" (inst 1 "x!1" "x!1") (("1" (prop) (("1" (hide-all-but (-2 1)) (("1" (grind) nil nil)) nil) ("2" (expand "positionsOF") (("2" (prop) (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand* "union" "member") (("2" (prop) (("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "positionsOF") (("3" (lift-if) (("3" (prop) (("1" (expand "only_empty_seq") (("1" (propax) nil nil)) nil) ("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil) ("3" (expand* "union" "member") (("3" (prop) (("3" (expand "only_empty_seq") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "only_empty_seq") (("2" (hide -4) (("2" (grind) nil nil)) nil)) nil) ("3" (expand* "union" "member") (("3" (prop) (("1" (expand "only_empty_seq") (("1" (hide -3) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "IUnion") (("2" (skosimp*) (("2" (expand "catenate") (("2" (skosimp*) (("2" (expand "member") (("2" (inst -4 "i!1 - 1") (("1" (inst -4 "sigma") (("1" (decompose-equality -4) (("1" (expand "finseq_appl") (("1" (expand "ext" -2) (("1" (prop) (("1" (grind) nil nil) ("2" (expand "finseq_appl") (("2" (inst -2 "x!2") (("2" (iff) (("2" (prop) (("1" (hide -3) (("1" (inst 5 "x!1" "empty_seq") (("1" (prop) (("1" (rewrite "seq_o_empty") nil nil) ("2" (expand "positionsOF" 1) (("2" (assert) (("2" (expand* "union" "member") (("2" (prop) (("2" (expand "IUnion") (("2" (inst 2 "i!1") (("1" (expand "catenate") (("1" (inst 2 "x!2") (("1" (expand* "member" "finseq_appl") nil nil)) nil)) nil) ("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "positionsOF") (("3" (lift-if) (("3" (expand "only_empty_seq") (("3" (prop) (("3" (expand* "union" "member") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst 4 "add_first(i!1, p1!1)" "p2!1") (("2" (prop) (("1" (lemma "fsepn.add_first_compo") (("1" (inst -1 "p1!1" "p2!1" "i!1") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "positionsOF" 1) (("2" (assert) (("2" (expand* "union" "member") (("2" (prop) (("2" (expand "IUnion") (("2" (inst 2 "i!1") (("1" (expand "catenate") (("1" (inst 2 "p1!1") (("1" (expand* "member" "finseq_appl") nil nil)) nil)) nil) ("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "subtermOF" 1) (("3" (lift-if) (("3" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (lemma "fsepn.rest_add_first") (("2" (inst -1 "p1!1" "i!1") (("2" (rewrite "fsepn.first_add") (("2" (replaces -1) (("2" (expand "finseq_appl") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "subtermOF" 1) (("4" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (lemma "fsepn.rest_add_first") (("2" (inst -1 "p1!1" "i!1") (("2" (rewrite "fsepn.first_add") (("2" (replaces -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand* "union" "member") (("2" (prop) (("1" (rewrite "ext_preserv_pos") nil nil) ("2" (skosimp*) (("2" (replaces -1) (("2" (lemma "ext_preserv_pos") (("2" (inst -1 "p1!1" "app(app1_var, app2_var)" "sigma") (("2" (assert) (("2" (hide -5) (("2" (lemma "subterm_ext_commute") (("2" (inst -1 "p1!1" "app(app1_var, app2_var)" "sigma") (("2" (assert) (("2" (replace -1 -5 rl) (("2" (hide (-1 -4)) (("2" (rewrite "pos_o_term") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (i!1 skolem-const-decl "upto?[position[variable, symbol, arity]](length
                                         (args
                                          (ext
                                           (sigma)
                                           (app(app1_var, app2_var)))))" substitution nil) (seq_o_empty formula-decl nil seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (sigma skolem-const-decl "Sub" substitution nil) (app1_var skolem-const-decl "symbol" substitution nil) (app2_var skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var)}" substitution nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (i!1 skolem-const-decl "upto?[position[variable, symbol, arity]](length
                                         (args
                                          (ext
                                           (sigma)
                                           (app(app1_var, app2_var)))))" substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (add_first_compo formula-decl nil seq_extras structures) (rest_add_first formula-decl nil seq_extras structures) (first_add formula-decl nil seq_extras structures) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (subterm_ext_commute formula-decl nil substitution nil) (pos_o_term formula-decl nil subterm nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (empty_o_seq formula-decl nil seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (empty_0 formula-decl nil seq_extras structures) (empty_seq const-decl "finseq" finite_sequences nil) (member const-decl "bool" sets nil) (ext_preserv_pos formula-decl nil substitution nil) (TRUE const-decl "bool" booleans nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (O const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (union const-decl "set" sets nil) (ext def-decl "term" substitution nil) (positionsOF def-decl "positions" positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil)) shostak)) (dom_o 0 (dom_o-1 nil 3397939849 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (ext def-decl "term" substitution nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (comp const-decl "term" substitution nil) (Dom const-decl "set[(V)]" substitution nil) (member const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil) (union const-decl "set" sets nil) (subset? const-decl "bool" sets nil)) shostak)) (dom_o_fin 0 (dom_o_fin-1 nil 3397941768 ("" (skeep) (("" (lemma "dom_o") (("" (inst?) (("" (typepred "sigma" "tau") (("" (expand "Sub?") (("" (lemma "fsetvar.finite_union") (("" (inst?) (("" (lemma "fsetvar.finite_subset") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dom_o formula-decl nil substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_union judgement-tcc nil finite_sets nil) (finite_subset formula-decl nil finite_sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (comp const-decl "term" substitution nil) (union const-decl "set" sets nil) (finite_set type-eq-decl nil finite_sets nil) (tau skolem-const-decl "Sub" substitution nil) (is_finite const-decl "bool" finite_sets nil) (Dom const-decl "set[(V)]" substitution nil) (sigma skolem-const-decl "Sub" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil)) shostak)) (subs_o 0 (subs_o-1 nil 3397942181 ("" (skeep) (("" (expand "Sub?") (("" (rewrite "dom_o_fin") nil nil)) nil)) nil) ((Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (dom_o_fin formula-decl nil substitution nil)) shostak)) (ext_o_TCC1 0 (ext_o_TCC1-1 nil 3397937614 ("" (skosimp*) (("" (rewrite "subs_o") nil nil)) nil) ((subs_o formula-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil)) nil (ext_o subtype "substitution.comp(substitution.sigma, substitution.tau)" "Sub"))) (ext_o 0 (ext_o-2 "" 3790333311 ("" (skeep) (("" (decompose-equality) (("" (generalize "x!1" "t") (("" (induct "t") (("1" (skeep) (("1" (expand "o") (("1" (expand "ext" 1 (1 3)) (("1" (expand "comp") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "o") (("2" (grind) (("2" (decompose-equality 2) (("1" (decompose-equality) (("1" (decompose-equality) (("1" (lemma "dom_o_fin") (("1" (expand "is_finite") (("1" (expand "injective?") (("1" (inst?) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "dom_o_fin") (("2" (expand* "is_finite" "injective?") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "dom_o_fin") (("2" (expand* "is_finite" "injective?") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "subs_o") nil nil)) nil)) nil)) nil)) nil) ((set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (ext def-decl "term" substitution nil) (comp const-decl "term" substitution nil) (O const-decl "T3" function_props nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (sigma skolem-const-decl "Sub" substitution nil) (tau skolem-const-decl "Sub" substitution nil) (term_induction formula-decl nil term_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Dom const-decl "set[(V)]" substitution nil) (app2_var skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var)}" substitution nil) (app1_var skolem-const-decl "symbol" substitution nil) (finite_sequence type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (injective? const-decl "bool" functions nil) (is_finite const-decl "bool" finite_sets nil) (term_app_extensionality formula-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (dom_o_fin formula-decl nil substitution nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (subs_o formula-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil)) shostak) (ext_o-1 nil 3391276210 ("" (skeep) (("" (decompose-equality) (("" (generalize "x!1" "t") (("" (induct "t") (("1" (skeep) (("1" (expand "o") (("1" (expand "ext" 1 (1 3)) (("1" (expand "comp") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "o") (("2" (grind) (("2" (decompose-equality 2) (("1" (decompose-equality) (("1" (decompose-equality) (("1" (lemma "dom_o_fin") (("1" (expand "is_finite") (("1" (expand "injective?") (("1" (inst?) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "dom_o_fin") (("2" (expand* "is_finite" "injective?") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "dom_o_fin") (("2" (expand* "is_finite" "injective?") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (rewrite "subs_o") nil nil)) nil)) nil)) nil)) nil)) nil) ((set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (term type-decl nil term_adt nil) (term_induction formula-decl nil term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (is_finite const-decl "bool" finite_sets nil) (term_app_extensionality formula-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak)) (subs_o_identity 0 (subs_o_identity-1 nil 3415022965 ("" (skosimp*) (("" (decompose-equality 1) (("" (expand "comp") (("" (lemma "ext_iden") (("" (inst?) (("" (typepred "x!1") (("" (expand "V") (("" (expand "ext" -2) (("" (assert) (("" (replaces -2) (("" (expand "ext" 1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (comp const-decl "term" substitution nil) (bijective? const-decl "bool" functions nil) (identity const-decl "(bijective?[T, T])" identity nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (ext_iden formula-decl nil substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (ext def-decl "term" substitution nil) (TRUE const-decl "bool" booleans nil)) shostak)) (ext_subs_o_identity_TCC1 0 (ext_subs_o_identity_TCC1-1 nil 3415023419 ("" (skosimp*) (("" (rewrite "subs_o") nil nil)) nil) ((subs_o formula-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (bijective? const-decl "bool" functions nil) (identity const-decl "(bijective?[T, T])" identity nil)) nil (ext_subs_o_identity subtype "substitution.comp(substitution.sigma, identity[(variables_term[substitution.variable, substitution.symbol, substitution.arity].V)].identity)" "Sub"))) (ext_subs_o_identity 0 (ext_subs_o_identity-1 nil 3415023419 ("" (skosimp*) (("" (lemma "subs_o_identity") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((subs_o_identity formula-decl nil substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil)) shostak)) (o_ass 0 (o_ass-1 nil 3391336147 ("" (skeep) (("" (decompose-equality) (("" (expand "comp" 1 (1 3 4)) (("" (rewrite "ext_o") (("" (expand "o") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (comp const-decl "term" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (ext_o formula-decl nil substitution nil) (O const-decl "T3" function_props nil)) shostak)) (inverse_renaming 0 (inverse_renaming-2 "" 3790333314 ("" (skolem-typepred) (("" (expand "Ren?") (("" (flatten) (("" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].bijective_inverse_exists") (("" (inst -1 "rho!1") (("" (expand "exists1") (("" (flatten) (("" (hide -2) (("" (skosimp*) (("" (inst 1 "extend_to_identity((Ran(rho!1)),(Dom(rho!1)),x!1)") (("1" (skosimp*) (("1" (expand "comp") (("1" (case "vars?(rho!1(x!2))") (("1" (expand "ext") (("1" (assert) (("1" (expand "extend_to_identity") (("1" (lift-if) (("1" (expand "bijective?") (("1" (flatten) (("1" (prop) (("1" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].comp_inverse_left_inj_alt") (("1" (inst -1 "x!2" "rho!1" "x!1") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "restrict" 1) (("2" (expand "Ran" 1) (("2" (expand "member" 1) (("2" (inst 1 "x!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -5 -6 1)) (("2" (expand* "subset?" "member") (("2" (inst -1 "rho!1(x!2)") (("2" (expand "V") (("2" (assert) (("2" (expand* "Ran" "member") (("2" (inst 2 "x!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "Dom(extend_to_identity[(V)]((restrict[term[variable, symbol, arity],((V[variable, symbol, arity])), boolean]((Ran(rho!1)))), (Dom(rho!1)), x!1))= Ran(rho!1)") (("1" (case "Ran(extend_to_identity[(V)]((restrict[term[variable, symbol, arity],((V[variable, symbol, arity])), boolean]((Ran(rho!1)))), (Dom(rho!1)), x!1)) = Dom(rho!1)") (("1" (split) (("1" (expand "Sub?") (("1" (replaces -2) (("1" (hide-all-but (-3 1)) (("1" (lemma "range_finite") (("1" (inst?) (("1" (lemma "restrict_set_props[term, (V)].restrict_finite") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].bij_inv_is_bij_alt") (("2" (inst -1 "rho!1" "x!1") (("2" (expand "Ren?" 1) (("2" (split) (("1" (expand* "subset?" "member" "V") (("1" (skosimp*) (("1" (decompose-equality -3) (("1" (inst -1 "x!2") (("1" (iff) (("1" (assert) (("1" (expand "extend" -1) (("1" (expand "V") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?" 1) (("2" (split) (("1" (expand "injective?" 1) (("1" (skosimp*) (("1" (expand "restrict" -1 (1 3)) (("1" (expand "extend_to_identity" -1) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (expand "bijective?" -4) (("1" (flatten) (("1" (expand "injective?" -4) (("1" (inst -4 "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?" -3) (("2" (flatten) (("2" (expand "surjective?") (("2" (decompose-equality -5) (("2" (inst -1 "x2!1") (("2" (iff) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?" 1) (("2" (skolem-typepred) (("2" (expand "bijective?" -2) (("2" (flatten) (("2" (expand "surjective?" -3) (("2" (decompose-equality -4) (("2" (inst -1 "y!1") (("2" (iff) (("2" (assert) (("2" (expand "extend" -1) (("2" (prop) (("2" (inst -5 "y!1") (("2" (skolem-typepred) (("2" (decompose-equality -7) (("2" (inst -1 "x!2") (("1" (iff) (("1" (expand "restrict" -1 2) (("1" (inst 1 "x!2") (("1" (expand "restrict" 1 1) (("1" (expand "extend_to_identity" 1) (("1" (expand "restrict" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -9 1)) (("2" (expand* "subset?" "member" "V") (("2" (inst -2 "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality 1) (("2" (iff) (("2" (prop) (("1" (expand "extend" 1) (("1" (prop) (("1" (expand "V") (("1" (expand "Ran" -2 1) (("1" (expand "member") (("1" (skolem-typepred) (("1" (flatten) (("1" (expand "extend_to_identity" -4) (("1" (lift-if) (("1" (decompose-equality -5) (("1" (inst -1 "x!3") (("1" (iff) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Ran" -1 1) (("2" (expand "member") (("2" (skolem-typepred) (("2" (flatten) (("2" (expand "extend_to_identity" -3) (("2" (lift-if) (("2" (decompose-equality -4) (("2" (inst -1 "x!3") (("2" (iff) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Ran" 1 1) (("2" (expand "member") (("2" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].bij_inv_is_bij_alt") (("2" (inst -1 "rho!1" "x!1") (("2" (expand "bijective?" -1) (("2" (flatten) (("2" (expand "surjective?") (("2" (expand "extend" -3) (("2" (prop) (("2" (inst -4 "x!2") (("2" (skolem-typepred) (("2" (decompose-equality -6) (("2" (case "V(x!3)") (("1" (inst -2 "x!3") (("1" (iff) (("1" (expand "restrict" -2 2) (("1" (inst 1 "x!3") (("1" (assert) (("1" (expand "extend_to_identity" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -9 1)) (("2" (expand* "subset?" "member" "V") (("2" (inst -2 "x!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality 1) (("2" (iff) (("2" (prop) (("1" (expand "Dom" -1 1) (("1" (prop) (("1" (expand "extend_to_identity") (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Dom" 1 1) (("2" (expand "extend_to_identity") (("2" (lift-if) (("2" (prop) (("2" (hide -3) (("2" (expand "restrict" -1) (("2" (expand "Ran" -1) (("2" (expand "member" -1) (("2" (skosimp*) (("2" (replaces -2 -3) (("2" (expand "bijective?") (("2" (flatten) (("2" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].comp_inverse_left_inj_alt") (("2" (inst -1 "x!3" "rho!1" "x!1") (("2" (expand "restrict" -1) (("2" (expand "Dom" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (split) (("1" (skosimp*) (("1" (prop) (("1" (hide-all-but (-1 -4 1)) (("1" (expand* "Ran" "subset?" "member" "V") (("1" (skosimp*) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil) ("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].bij_inv_is_bij_alt") (("2" (inst -1 "rho!1" "x!1") (("2" (hide-all-but (-1 1)) (("2" (expand "bijective?") (("2" (expand* "injective?" "surjective?") (("2" (flatten) (("2" (split) (("1" (skosimp*) (("1" (inst -2 "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -2 "y!1") (("2" (skosimp*) (("2" (inst 1 "x!2") (("2" (expand "restrict") (("2" (typepred "rho!1") (("2" (hide -1) (("2" (expand "Ren?") (("2" (flatten) (("2" (hide -2) (("2" (typepred "x!2") (("2" (hide -3) (("2" (expand* "Ran" "subset?" "member" "V") (("2" (skosimp*) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (split) (("1" (skosimp*) (("1" (prop) (("1" (hide-all-but (-1 -4 1)) (("1" (expand* "Ran" "subset?" "member" "V") (("1" (skosimp*) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil) ("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].bij_inv_is_bij_alt") (("2" (inst -1 "rho!1" "x!1") (("2" (hide-all-but (-1 1)) (("2" (expand "bijective?") (("2" (expand* "injective?" "surjective?") (("2" (flatten) (("2" (split) (("1" (skosimp*) (("1" (inst -2 "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -2 "y!1") (("2" (skosimp*) (("2" (inst 1 "x!2") (("2" (expand "restrict") (("2" (typepred "rho!1") (("2" (hide -1) (("2" (expand "Ren?") (("2" (flatten) (("2" (hide -2) (("2" (typepred "x!2") (("2" (hide -3) (("2" (expand* "Ran" "subset?" "member" "V") (("2" (skosimp*) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Ran const-decl "set[term[variable, symbol, arity]]" substitution nil) (Dom const-decl "set[(V)]" substitution nil) (bijective_inverse_exists formula-decl nil function_inverse_def nil) (exists1 const-decl "bool" exists1 nil) (x!1 skolem-const-decl "[(Ran(rho!1)) -> (Dom(rho!1))]" substitution nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (extend_to_identity const-decl "T" extending_rename nil) (comp const-decl "term" substitution nil) (subset? const-decl "bool" sets nil) (ext def-decl "term" substitution nil) (injective? const-decl "bool" functions nil) (inverse? const-decl "bool" function_inverse_def nil) (comp_inverse_left_inj_alt formula-decl nil function_inverse_def nil) (member const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subset_is_partial_order name-judgement "(partial_order?[set[term[variable, symbol, arity]]])" substitution nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (x!2 skolem-const-decl "(Ran(rho!1))" substitution nil) (/= const-decl "boolean" notequal nil) (x!3 skolem-const-decl "(V)" substitution nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (bij_inv_is_bij_alt formula-decl nil function_inverse_def nil) (x!2 skolem-const-decl "(Ran(rho!1))" substitution nil) (y!1 skolem-const-decl "(Ran(extend_to_identity[(V)]
         ((restrict
               [term[variable, symbol, arity],
                (V[variable, symbol, arity]), bool]
               ((Ran(rho!1)))),
          (Dom(rho!1)), x!1)))" substitution nil) (surjective? const-decl "bool" functions nil) (restrict_finite formula-decl nil restrict_set_props nil) (range_finite formula-decl nil substitution nil) (TRUE const-decl "bool" booleans nil) (x!2 skolem-const-decl "term[variable, symbol, arity]" substitution nil) (x!3 skolem-const-decl "(Ran(rho!1))" substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (x!2 skolem-const-decl "(Ran(rho!1))" substitution nil) (rho!1 skolem-const-decl "Ren" substitution nil) (bijective? const-decl "bool" functions nil) (restrict const-decl "R" restrict nil) (Ren type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak) (inverse_renaming-1 nil 3415024734 ("" (skolem-typepred) (("" (expand "Ren?") (("" (flatten) (("" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].bijective_inverse_exists") (("" (inst -1 "rho!1") (("" (expand "exists1") (("" (flatten) (("" (hide -2) (("" (skosimp*) (("" (inst 1 "extend_to_identity((Ran(rho!1)),(Dom(rho!1)),x!1)") (("1" (skosimp*) (("1" (expand "comp") (("1" (case "vars?(rho!1(x!2))") (("1" (expand "ext") (("1" (assert) (("1" (expand "extend_to_identity") (("1" (lift-if) (("1" (expand "bijective?") (("1" (flatten) (("1" (prop) (("1" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].comp_inverse_left_inj_alt") (("1" (inst -1 "x!2" "rho!1" "x!1") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "restrict" 1) (("2" (expand "Ran" 1) (("2" (expand "member" 1) (("2" (inst 1 "x!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -5 -6 1)) (("2" (expand* "subset?" "member") (("2" (inst -1 "rho!1(x!2)") (("2" (expand "V") (("2" (assert) (("2" (expand* "Ran" "member") (("2" (inst 2 "x!2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "Dom(extend_to_identity[(V)]((restrict[term[variable, symbol, arity],((V[variable, symbol, arity])), boolean]((Ran(rho!1)))), (Dom(rho!1)), x!1))= Ran(rho!1)") (("1" (case "Ran(extend_to_identity[(V)]((restrict[term[variable, symbol, arity],((V[variable, symbol, arity])), boolean]((Ran(rho!1)))), (Dom(rho!1)), x!1)) = Dom(rho!1)") (("1" (split) (("1" (expand "Sub?") (("1" (replaces -2) (("1" (hide-all-but (-3 1)) (("1" (lemma "range_finite") (("1" (inst?) (("1" (lemma "restrict_set_props[term, (V)].restrict_finite") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].bij_inv_is_bij_alt") (("2" (inst -1 "rho!1" "x!1") (("2" (expand "Ren?" 1) (("2" (split) (("1" (expand* "subset?" "member" "V") (("1" (skosimp*) (("1" (decompose-equality -3) (("1" (inst -1 "x!2") (("1" (iff) (("1" (assert) (("1" (expand "extend" -1) (("1" (expand "V") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?" 1) (("2" (split) (("1" (expand "injective?" 1) (("1" (skosimp*) (("1" (expand "restrict" -1 (1 3)) (("1" (expand "extend_to_identity" -1) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (expand "bijective?" -4) (("1" (flatten) (("1" (expand "injective?" -4) (("1" (inst -4 "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "bijective?" -3) (("2" (flatten) (("2" (expand "surjective?") (("2" (decompose-equality -5) (("2" (inst -1 "x2!1") (("2" (iff) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "bijective?" -3) (("3" (flatten) (("3" (expand "surjective?") (("3" (decompose-equality -5) (("3" (inst -1 "x1!1") (("3" (iff) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?" 1) (("2" (skolem-typepred) (("2" (expand "bijective?" -2) (("2" (flatten) (("2" (expand "surjective?" -3) (("2" (decompose-equality -4) (("2" (inst -1 "y!1") (("2" (iff) (("2" (assert) (("2" (expand "extend" -1) (("2" (prop) (("2" (inst -5 "y!1") (("2" (skolem-typepred) (("2" (decompose-equality -7) (("2" (inst -1 "x!2") (("1" (iff) (("1" (expand "restrict" -1 2) (("1" (inst 1 "x!2") (("1" (expand "restrict" 1 1) (("1" (expand "extend_to_identity" 1) (("1" (expand "restrict" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -9 1)) (("2" (expand* "subset?" "member" "V") (("2" (inst -2 "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality 1) (("2" (iff) (("2" (prop) (("1" (expand "extend" 1) (("1" (prop) (("1" (expand "V") (("1" (expand "Ran" -2 1) (("1" (expand "member") (("1" (skolem-typepred) (("1" (flatten) (("1" (expand "extend_to_identity" -4) (("1" (lift-if) (("1" (decompose-equality -5) (("1" (inst -1 "x!3") (("1" (iff) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Ran" -1 1) (("2" (expand "member") (("2" (skolem-typepred) (("2" (flatten) (("2" (expand "extend_to_identity" -3) (("2" (lift-if) (("2" (decompose-equality -4) (("2" (inst -1 "x!3") (("2" (iff) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Ran" 1 1) (("2" (expand "member") (("2" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].bij_inv_is_bij_alt") (("2" (inst -1 "rho!1" "x!1") (("2" (expand "bijective?" -1) (("2" (flatten) (("2" (expand "surjective?") (("2" (expand "extend" -3) (("2" (prop) (("2" (inst -4 "x!2") (("2" (skolem-typepred) (("2" (decompose-equality -6) (("2" (case "V(x!3)") (("1" (inst -2 "x!3") (("1" (iff) (("1" (expand "restrict" -2 2) (("1" (inst 1 "x!3") (("1" (assert) (("1" (expand "extend_to_identity" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -9 1)) (("2" (expand* "subset?" "member" "V") (("2" (inst -2 "x!3") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality 1) (("2" (iff) (("2" (prop) (("1" (expand "Dom" -1 1) (("1" (prop) (("1" (expand "extend_to_identity") (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Dom" 1 1) (("2" (expand "extend_to_identity") (("2" (lift-if) (("2" (prop) (("2" (hide -3) (("2" (expand "restrict" -1) (("2" (expand "Ran" -1) (("2" (expand "member" -1) (("2" (skosimp*) (("2" (replaces -2 -3) (("2" (expand "bijective?") (("2" (flatten) (("2" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].comp_inverse_left_inj_alt") (("2" (inst -1 "x!3" "rho!1" "x!1") (("2" (expand "restrict" -1) (("2" (expand "Dom" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (split) (("1" (skosimp*) (("1" (prop) (("1" (hide-all-but (-1 -4 1)) (("1" (expand* "Ran" "subset?" "member" "V") (("1" (skosimp*) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil) ("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].bij_inv_is_bij_alt") (("2" (inst -1 "rho!1" "x!1") (("2" (hide-all-but (-1 1)) (("2" (expand "bijective?") (("2" (expand* "injective?" "surjective?") (("2" (flatten) (("2" (split) (("1" (skosimp*) (("1" (inst -2 "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -2 "y!1") (("2" (skosimp*) (("2" (inst 1 "x!2") (("2" (expand "restrict") (("2" (typepred "rho!1") (("2" (hide -1) (("2" (expand "Ren?") (("2" (flatten) (("2" (hide -2) (("2" (typepred "x!2") (("2" (hide -3) (("2" (expand* "Ran" "subset?" "member" "V") (("2" (skosimp*) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (split) (("1" (skosimp*) (("1" (prop) (("1" (hide-all-but (-1 -4 1)) (("1" (expand* "Ran" "subset?" "member" "V") (("1" (skosimp*) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "restrict") (("2" (propax) nil nil)) nil) ("3" (expand "restrict") (("3" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "function_inverse_def[(Dom(rho!1)), (Ran(rho!1))].bij_inv_is_bij_alt") (("2" (inst -1 "rho!1" "x!1") (("2" (hide-all-but (-1 1)) (("2" (expand "bijective?") (("2" (expand* "injective?" "surjective?") (("2" (flatten) (("2" (split) (("1" (skosimp*) (("1" (inst -2 "x1!1" "x2!1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -2 "y!1") (("2" (skosimp*) (("2" (inst 1 "x!2") (("2" (expand "restrict") (("2" (typepred "rho!1") (("2" (hide -1) (("2" (expand "Ren?") (("2" (flatten) (("2" (hide -2) (("2" (typepred "x!2") (("2" (hide -3) (("2" (expand* "Ran" "subset?" "member" "V") (("2" (skosimp*) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((extend_to_identity const-decl "T" extending_rename nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil)) shostak)) (inverse_rename_identity_TCC1 0 (inverse_rename_identity_TCC1-1 nil 3415643854 ("" (skosimp*) (("" (rewrite "subs_o") nil nil)) nil) ((subs_o formula-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Ren type-eq-decl nil substitution nil)) nil (inverse_rename_identity subtype "substitution.comp(substitution.rho1, substitution.rho)" "Sub"))) (inverse_rename_identity 0 (inverse_rename_identity-1 nil 3415643891 ("" (induct "t") (("1" (skosimp*) (("1" (expand "ext") (("1" (rewrite "Vars_is_var") (("1" (expand* "subset?" "member") (("1" (inst -1 "vars(vars1_var!1)") (("1" (inst -2 "vars(vars1_var!1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "ext" 1) (("2" (lift-if) (("2" (prop) (("2" (decompose-equality 2) (("1" (decompose-equality 1) (("1" (decompose-equality 1) (("1" (expand "finseq_appl") (("1" (inst -1 "x!1") (("1" (inst?) (("1" (prop) (("1" (hide (-2 2)) (("1" (expand* "subset?" "member") (("1" (skosimp*) (("1" (inst -2 "x!2") (("1" (assert) (("1" (hide 1) (("1" (lemma "vars_term_is_union") (("1" (inst -1 "app(app1_var!1, app2_var!1)") (("1" (assert) (("1" (replaces -1) (("1" (expand "IUnion") (("1" (expand "finseq_appl") (("1" (inst 2 "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (rewrite "subs_o") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (rewrite "subs_o") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (rewrite "subs_o") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (rewrite "subs_o") nil nil)) nil)) nil)) nil) ((subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app1_var!1 skolem-const-decl "symbol" substitution nil) (app2_var!1 skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var!1)}" substitution nil) (rho1!1 skolem-const-decl "Ren" substitution nil) (rho!1 skolem-const-decl "Ren" substitution nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (term_app_extensionality formula-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (TRUE const-decl "bool" booleans nil) (IUnion const-decl "set[T]" indexed_sets nil) (vars_term_is_union formula-decl nil subterm nil) (subs_o formula-decl nil substitution nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (Vars_is_var formula-decl nil subterm nil) (member const-decl "bool" sets nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (ext def-decl "term" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Ren type-eq-decl nil substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (Vars const-decl "set[(V)]" subterm nil) (Dom const-decl "set[(V)]" substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (comp const-decl "term" substitution nil)) shostak)) (idemp_sub_term_empty_inter 0 (idemp_sub_term_empty_inter-1 nil 3455282628 ("" (induct "t") (("1" (skosimp*) (("1" (prop) (("1" (expand "empty?") (("1" (skosimp*) (("1" (expand "intersection") (("1" (expand "member") (("1" (flatten) (("1" (expand "Dom") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "empty?") (("2" (inst -1 "vars(vars1_var!1)") (("1" (expand "intersection") (("1" (expand "member") (("1" (prop) (("1" (expand "Dom") (("1" (prop) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "Vars") (("2" (inst 1 "empty_seq") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "V") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (prop) (("1" (expand "empty?" 1) (("1" (expand "intersection" 1) (("1" (expand "member" 1) (("1" (skosimp) (("1" (expand "Vars" -3) (("1" (skosimp*) (("1" (typepred "p!1") (("1" (expand "positionsOF") (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "seq_extras[posnat].empty_0") (("1" (inst -1 "p!1") (("1" (assert) (("1" (expand "subtermOF") (("1" (typepred "x!1") (("1" (expand "V") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "union") (("2" (expand "member") (("2" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "seq_extras[posnat].empty_0") (("1" (inst -1 "p!1") (("1" (expand "subtermOF") (("1" (assert) (("1" (typepred "x!1") (("1" (expand "V") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "IUnion") (("2" (skosimp*) (("2" (expand "catenate") (("2" (skosimp*) (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (inst -6 "i!1 -1") (("2" (inst -6 "sigma!1") (("2" (prop) (("1" (expand* "empty?" "intersection") (("1" (inst -2 "x!1") (("1" (expand "member") (("1" (prop) (("1" (expand "Vars") (("1" (inst 1 "x!2") (("1" (expand "subtermOF" -6) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 -2)) (("1" (typepred "x!1") (("1" (expand "V") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (replaces -4) (("2" (rewrite "first_add") (("2" (rewrite "rest_add_first") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ext" -3) (("2" (expand "finseq_appl") (("2" (decompose-equality -3) (("2" (decompose-equality -1) (("2" (decompose-equality -1) (("2" (inst -1 "i!1 -1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ext" 1) (("2" (lift-if) (("2" (prop) (("2" (decompose-equality 2) (("2" (decompose-equality 1) (("2" (decompose-equality 1) (("2" (expand "finseq_appl") (("2" (inst -2 "x!1") (("2" (inst -2 "sigma!1") (("2" (assert) (("2" (expand* "empty?" "intersection") (("2" (skosimp*) (("2" (inst -1 "x!2") (("2" (expand "member") (("2" (prop) (("2" (expand "Vars") (("2" (skosimp*) (("2" (typepred "p!1") (("2" (inst 1 "add_first(x!1 + 1, p!1)") (("1" (expand "subtermOF" 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (rewrite "first_add") (("2" (rewrite "rest_add_first") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positionsOF" 1) (("2" (expand "union") (("2" (prop) (("2" (expand* "member" "finseq_appl") (("2" (expand "IUnion") (("2" (inst 2 "x!1 + 1") (("2" (expand "catenate") (("2" (inst 2 "p!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (add_first const-decl "finseq" seq_extras structures) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (x!1 skolem-const-decl "below[app2_var!1`length]" substitution nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](app2_var!1`seq(x!1))" substitution nil) (insert? const-decl "finseq" seq_extras structures) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (term_app_extensionality formula-decl nil term_adt nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (empty_0 formula-decl nil seq_extras structures) (IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (app1_var!1 skolem-const-decl "symbol" substitution nil) (app2_var!1 skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var!1)}" substitution nil) (i!1 skolem-const-decl "upto?[position[variable, symbol, arity]](length(app2_var!1))" substitution nil) (x!2 skolem-const-decl "position[variable, symbol, arity]" substitution nil) (first_add formula-decl nil seq_extras structures) (rest_add_first formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (union const-decl "set" sets nil) (finseq type-eq-decl nil finite_sequences nil) (vars1_var!1 skolem-const-decl "variable" substitution nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (/= const-decl "boolean" notequal nil) (empty_seq const-decl "finseq" finite_sequences nil) (only_empty_seq const-decl "positions" positions nil) (subtermOF def-decl "term" subterm nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (positions? type-eq-decl nil positions nil) (member const-decl "bool" sets nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (Vars const-decl "set[(V)]" subterm nil) (Dom const-decl "set[(V)]" substitution nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (ext def-decl "term" substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil)) shostak)) (idemp_sub_iff_empty_intersection 0 (idemp_sub_iff_empty_intersection-1 nil 3455282711 ("" (skosimp*) (("" (prop) (("1" (lemma "idemp_sub_term_empty_inter") (("1" (expand "idempotent_sub?" -2) (("1" (decompose-equality -2) (("1" (expand "empty?" 1) (("1" (skosimp*) (("1" (expand "intersection" -3) (("1" (expand "member") (("1" (prop) (("1" (expand "VRan") (("1" (expand "IUnion") (("1" (skosimp*) (("1" (inst -1 "i!1") (("1" (expand "comp") (("1" (inst -2 "sigma!1(i!1)" "sigma!1") (("1" (assert) (("1" (expand* "empty?" "intersection" "member") (("1" (inst -2 "x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "idemp_sub_term_empty_inter") (("2" (expand "idempotent_sub?") (("2" (decompose-equality 1) (("2" (expand "comp") (("2" (inst -1 "sigma!1(x!1)" "sigma!1") (("2" (assert) (("2" (expand* "empty?" "intersection" "member") (("2" (skosimp*) (("2" (inst -3 "x!2") (("2" (assert) (("2" (expand "VRan") (("2" (expand "IUnion") (("2" (inst 2 "x!1") (("2" (expand "Dom") (("2" (prop) (("2" (hide 1) (("2" (replace -1 -2) (("2" (lemma "Vars_is_var") (("2" (inst -1 "x!1") (("2" (typepred "x!1") (("2" (expand "V") (("2" (assert) (("2" (decompose-equality -2) (("2" (inst -1 "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((idempotent_sub? const-decl "bool" substitution nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (Dom const-decl "set[(V)]" substitution nil) (VRan const-decl "set[(V)]" substitution nil) (member const-decl "bool" sets nil) (comp const-decl "term" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (idemp_sub_term_empty_inter formula-decl nil substitution nil) (Vars_is_var formula-decl nil subterm nil) (NOT const-decl "[bool -> bool]" booleans nil) (Vars const-decl "set[(V)]" subterm nil) (x!1 skolem-const-decl "(V)" substitution nil) (sigma!1 skolem-const-decl "Sub" substitution nil)) shostak)) (Dom_DSigma 0 (Dom_DSigma-1 nil 3455194395 ("" (skosimp*) (("" (expand* "subset?" "union" "singleton" "member" "restrict") (("" (skosimp*) (("" (expand "Dom") (("" (prop) (("" (expand "DSigma") (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((union const-decl "set" sets nil) (member const-decl "bool" sets nil) (restrict const-decl "R" restrict nil) (singleton const-decl "(singleton?)" sets nil) (subset? const-decl "bool" sets nil) (Dom const-decl "set[(V)]" substitution nil) (DSigma const-decl "term" substitution nil)) shostak)) (Dom_DSigma_is_finite 0 (Dom_DSigma_is_finite-1 nil 3455195630 ("" (skosimp*) (("" (lemma "Dom_DSigma") (("" (inst?) (("" (lemma "finite_singleton[term]") (("" (copy -1) (("" (inst -1 "s!1") (("" (inst -2 "x!1") (("" (lemma "finite_union[term]") (("" (inst?) (("" (lemma "finite_subset[(V)]") (("" (inst -1 "restrict
                        [term[variable, symbol, arity],
                         (V[variable, symbol, arity]), boolean]
                        (union(singleton(s!1), singleton(x!1)))" "Dom(DSigma(s!1, x!1))") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Dom_DSigma formula-decl nil substitution nil) (finite_singleton judgement-tcc nil finite_sets nil) (finite_union judgement-tcc nil finite_sets nil) (finite_subset formula-decl nil finite_sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (nonempty_finite_union1 application-judgement "non_empty_finite_set[term[variable, symbol, arity]]" substitution nil) (restrict const-decl "R" restrict nil) (union const-decl "set" sets nil) (Dom const-decl "set[(V)]" substitution nil) (DSigma const-decl "term" substitution nil) (finite_restrict application-judgement "finite_set[S]" restrict_set_props nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[term[variable, symbol, arity]]" substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[(V)]" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil)) shostak)) (DSigma_is_Sub 0 (DSigma_is_Sub-1 nil 3455193672 ("" (skeep) (("" (expand "Sub?") (("" (lemma "Dom_DSigma_is_finite") (("" (inst?) nil nil)) nil)) nil)) nil) ((Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (Dom_DSigma_is_finite formula-decl nil substitution nil)) shostak)) (DSigma_do_nothing_TCC1 0 (DSigma_do_nothing_TCC1-1 nil 3457538363 ("" (skosimp*) (("" (rewrite "DSigma_is_Sub") nil nil)) nil) ((DSigma_is_Sub formula-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil)) nil (DSigma_do_nothing subtype "substitution.DSigma(substitution.t, substitution.x)" "Sub"))) (DSigma_do_nothing 0 (DSigma_do_nothing-1 nil 3457538363 ("" (induct "s") (("1" (skosimp*) (("1" (expand "ext") (("1" (expand "DSigma") (("1" (lift-if) (("1" (prop) (("1" (expand "empty?") (("1" (inst -2 "empty_seq") (("1" (expand "member") (("1" (expand "Pos_var") (("1" (expand "extend") (("1" (prop) (("1" (expand "subtermOF") (("1" (lift-if) (("1" (prop) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "positionsOF") (("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "ext" 1) (("2" (lift-if) (("2" (prop) (("2" (decompose-equality 2) (("1" (decompose-equality 1) (("1" (decompose-equality 1) (("1" (expand "finseq_appl") (("1" (inst -1 "x!2") (("1" (inst -1 "t!1" "x!1") (("1" (assert) (("1" (hide 1) (("1" (expand "empty?") (("1" (skosimp*) (("1" (expand "member") (("1" (expand "Pos_var" -1) (("1" (expand "extend") (("1" (prop) (("1" (inst -3 "add_first(x!2 + 1, x!3)") (("1" (expand "Pos_var") (("1" (expand "extend") (("1" (prop) (("1" (expand "subtermOF" 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (rewrite "first_add") (("2" (rewrite "rest_add_first") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (expand "positionsOF" 1) (("2" (expand* "union" "member") (("2" (prop) (("2" (expand "IUnion") (("2" (inst 2 "x!2 + 1") (("2" (expand "catenate") (("2" (inst 2 "x!3") (("2" (expand* "member" "finseq_appl") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (rewrite "DSigma_is_Sub") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (rewrite "DSigma_is_Sub") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (rewrite "DSigma_is_Sub") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (rewrite "DSigma_is_Sub") nil nil)) nil)) nil)) nil) ((< const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app1_var!1 skolem-const-decl "symbol" substitution nil) (app2_var!1 skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var!1)}" substitution nil) (t!1 skolem-const-decl "term[variable, symbol, arity]" substitution nil) (x!1 skolem-const-decl "(V)" substitution nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (term_app_extensionality formula-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (add_first const-decl "finseq" seq_extras structures) (union const-decl "set" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (<= const-decl "bool" reals nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (insert? const-decl "finseq" seq_extras structures) (first_add formula-decl nil seq_extras structures) (int_minus_int_is_int application-judgement "int" integers nil) (rest_add_first formula-decl nil seq_extras structures) (DSigma_is_Sub formula-decl nil substitution nil) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (subtermOF def-decl "term" subterm nil) (positionsOF def-decl "positions" positions nil) (only_empty_seq const-decl "positions" positions nil) (extend const-decl "R" extend nil) (member const-decl "bool" sets nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (ext def-decl "term" substitution nil) (Sub type-eq-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (empty? const-decl "bool" sets nil) (positions type-eq-decl nil positions nil) (Pos_var const-decl "positions" subterm nil) (Sub? const-decl "bool" substitution nil) (DSigma const-decl "term" substitution nil)) shostak)) (Rhop_TCC1 0 (Rhop_TCC1-1 nil 3415343891 ("" (skosimp*) (("" (typepred "rho!1") (("" (expand "Ren?") (("" (flatten) (("" (hide (-1 -3)) (("" (expand* "subset?" "member") (("" (inst -1 "rho!1(z!1)") (("" (assert) (("" (expand* "Ran" "member") (("" (inst 1 "z!1") (("" (expand "Dom") (("" (prop) (("" (typepred "z!1") (("" (expand "V") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Ren type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (Dom const-decl "set[(V)]" substitution nil) (Ran const-decl "set[term[variable, symbol, arity]]" substitution nil)) nil (Rhop subtype "substitution.rho(substitution.z)" "(variables_term[substitution.variable, substitution.symbol, substitution.arity].V)"))) (SigmaP_Dom 0 (SigmaP_Dom-1 nil 3412022140 ("" (skeep) (("" (expand* "subset?" "member") (("" (skolem * "x2") (("" (flatten) (("" (expand* "union" "member") (("" (expand "Dom") (("" (prop) (("" (expand* "SigmaP" "singleton") (("" (lift-if) (("" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (Dom const-decl "set[(V)]" substitution nil) (singleton const-decl "(singleton?)" sets nil) (SigmaP const-decl "term" substitution nil) (union const-decl "set" sets nil)) shostak)) (SigmaP_Dom_fin 0 (SigmaP_Dom_fin-1 nil 3412061516 ("" (skeep) (("" (lemma "SigmaP_Dom") (("" (inst?) (("" (assert) (("" (typepred "sigma") (("" (expand "Sub?") (("" (lemma "fsetvar.finite_union") (("" (inst?) (("" (lemma "fsetvar.finite_subset") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SigmaP_Dom formula-decl nil substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[(V)]" substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[term[variable, symbol, arity]]" substitution nil) (is_finite const-decl "bool" finite_sets nil) (Dom const-decl "set[(V)]" substitution nil) (sigma skolem-const-decl "Sub" substitution nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (nonempty_union2 application-judgement "(nonempty?)" sets nil) (union const-decl "set" sets nil) (x skolem-const-decl "(V)" substitution nil) (SigmaP const-decl "term" substitution nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (finite_subset formula-decl nil finite_sets nil) (finite_union judgement-tcc nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (SigmaP_Subs 0 (SigmaP_Subs-1 nil 3412062111 ("" (skeep) (("" (expand "Sub?") (("" (lemma "SigmaP_Dom_fin") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((Sub? const-decl "bool" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub type-eq-decl nil substitution nil) (SigmaP_Dom_fin formula-decl nil substitution nil)) shostak)) (SigmaP_is_RSigma_TCC1 0 (SigmaP_is_RSigma_TCC1-1 nil 3412063083 ("" (skosimp*) (("" (rewrite "SigmaP_Subs") nil nil)) nil) ((SigmaP_Subs formula-decl nil substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil)) nil (SigmaP_is_RSigma subtype "substitution.SigmaP(substitution.sigma, substitution.t, substitution.x, substitution.p)" "Sub"))) (SigmaP_is_RSigma 0 (SigmaP_is_RSigma-1 nil 3412063183 ("" (skeep) (("" (expand "RSigma") (("" (skeep) (("" (prop) (("1" (expand "SigmaP") (("1" (assert) nil nil)) nil) ("2" (expand "SigmaP") (("2" (lemma "replace_subterm_of_term") (("2" (inst?) (("2" (assert) (("2" (replace -1 1 rl) (("2" (expand "comp_cont?") (("2" (inst?) (("2" (assert) (("2" (inst -4 "subtermOF(sigma(x), p)" "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RSigma const-decl "bool" substitution nil) (SigmaP const-decl "term" substitution nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (replace_subterm_of_term formula-decl nil replacement nil) (comp_cont? const-decl "bool" compatibility nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil)) shostak)) (SigmaP_equivalence_TCC1 0 (SigmaP_equivalence_TCC1-1 nil 3673477505 ("" (skosimp) (("" (hide 1) (("" (typepred x!1) (("" (expand* V ext) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((ext def-decl "term" substitution nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil)) nil (SigmaP_equivalence subtype "substitution.p2" "positions[substitution.variable, substitution.symbol, substitution.arity].positions?(substitution.sigma(substitution.x))"))) (SigmaP_equivalence_TCC2 0 (SigmaP_equivalence_TCC2-1 nil 3673477505 ("" (skosimp) (("" (lemma SigmaP_Subs) (("" (inst -1 p2!1 sigma!1 t!1 x!1) (("" (assert) (("" (typepred x!1) (("" (expand* V ext) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SigmaP_Subs formula-decl nil substitution nil) (ext def-decl "term" substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (SigmaP_equivalence subtype "substitution.SigmaP(substitution.sigma, substitution.t, substitution.x, substitution.p2)" "Sub"))) (SigmaP_equivalence 0 (SigmaP_equivalence-1 nil 3673477505 ("" (induct s) (("1" (skeep) (("1" (skeep) (("1" (expand SigmaP) (("1" (case "x = vars(vars1_var)") (("1" (hide 2) (("1" (replace -1 1) (("1" (expand member) (("1" (expand Vars) (("1" (inst 1 empty_seq) (("1" (grind) nil nil) ("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand ext 3 2) (("2" (assert) (("2" (expand ext 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand ext 2) (("2" (assert) (("2" (lift-if) (("2" (case "length(app2_var) = 0") (("1" (assert) nil nil) ("2" (split) (("1" (propax) nil nil) ("2" (assert) (("2" (decompose-equality) (("1" (decompose-equality) (("1" (decompose-equality) (("1" (inst -1 "x!1") (("1" (inst -1 "p2" "sigma" "t" "x") (("1" (assert) (("1" (expand finseq_appl) (("1" (prop) (("1" (hide-all-but (-1 3)) (("1" (expand* member Vars) (("1" (skosimp*) (("1" (inst 1 " add_first(x!1 + 1, p!1)") (("1" (expand subtermOF 1) (("1" (lift-if) (("1" (prop) (("1" (hide -2 1) (("1" (expand add_first) (("1" (expand insert?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand finseq_appl) (("2" (rewrite rest_add_first) (("2" (rewrite first_add) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand positionsOF) (("2" (expand union) (("2" (flatten) (("2" (hide 1) (("2" (expand member) (("2" (expand IUnion) (("2" (inst 1 "x!1 + 1") (("2" (expand finseq_appl) (("2" (expand catenate) (("2" (inst 1 p!1) (("2" (typepred p!1) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma SigmaP_Subs) (("2" (inst -1 p2 sigma t x) (("2" (assert) (("2" (typepred x) (("2" (expand V) (("2" (expand ext -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide-all-but (-2 1)) (("3" (typepred x) (("3" (expand V) (("3" (expand ext -2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma SigmaP_Subs) (("2" (inst -1 p2 sigma t x) (("2" (assert) (("2" (hide-all-but (-2 1)) (("2" (typepred x) (("2" (expand V) (("2" (expand ext -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (lemma SigmaP_Subs) (("3" (inst -1 p2 sigma t x) (("3" (assert) (("3" (hide-all-but (-3 1)) (("3" (typepred x) (("3" (expand V) (("3" (expand ext -2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma SigmaP_Subs) (("2" (inst -1 p2 sigma t x) (("2" (assert) (("2" (hide-all-but (-2 1)) (("2" (typepred x) (("2" (expand V) (("2" (expand ext -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide-all-but (-2 1)) (("3" (typepred x) (("3" (expand V) (("3" (expand ext -2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (lemma SigmaP_Subs) (("3" (inst -1 p2 sigma t x) (("3" (assert) (("3" (hide-all-but (-1 1)) (("3" (typepred x) (("3" (expand V) (("3" (expand ext -2) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (hide 1) (("4" (typepred x) (("4" (expand V) (("4" (expand ext -2) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((< const-decl "bool" reals nil) (app1_var skolem-const-decl "symbol" substitution nil) (app2_var skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var)}" substitution nil) (sigma skolem-const-decl "Sub" substitution nil) (x skolem-const-decl "(V)" substitution nil) (p2 skolem-const-decl "position[variable, symbol, arity]" substitution nil) (t skolem-const-decl "term[variable, symbol, arity]" substitution nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (term_app_extensionality formula-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (<= const-decl "bool" reals nil) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (union const-decl "set" sets nil) (insert? const-decl "finseq" seq_extras structures) (rest_add_first formula-decl nil seq_extras structures) (int_minus_int_is_int application-judgement "int" integers nil) (first_add formula-decl nil seq_extras structures) (p!1 skolem-const-decl "positions?[variable, symbol, arity](app2_var`seq(x!1))" substitution nil) (x!1 skolem-const-decl "below[app2_var`length]" substitution nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (add_first const-decl "finseq" seq_extras structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (SigmaP_Subs formula-decl nil substitution nil) (finite_sequence type-eq-decl nil finite_sequences nil) (vars1_var skolem-const-decl "variable" substitution nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (subtermOF def-decl "term" subterm nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (only_empty_seq const-decl "positions" positions nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (positions? type-eq-decl nil positions nil) (SigmaP const-decl "term" substitution nil) (term type-decl nil term_adt nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (Vars const-decl "set[(V)]" subterm nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (ext def-decl "term" substitution nil)) shostak)) (SigmaP_vs_replaceTerm_linearR_TCC1 0 (SigmaP_vs_replaceTerm_linearR_TCC1-1 nil 3673477505 ("" (skosimp*) (("" (lemma Pos_var_is_finite) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (Pos_var_is_finite formula-decl nil subterm nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil)) nil (SigmaP_vs_replaceTerm_linearR subtype "subterm[substitution.variable, substitution.symbol, substitution.arity].Pos_var(substitution.s, substitution.x)" "finite_set[position[variable, symbol, arity]]"))) (SigmaP_vs_replaceTerm_linearR_TCC2 0 (SigmaP_vs_replaceTerm_linearR_TCC2-1 nil 3673477505 ("" (skosimp) (("" (expand ext -3) (("" (assert) nil nil)) nil)) nil) ((ext def-decl "term" substitution nil)) nil (SigmaP_vs_replaceTerm_linearR subtype "substitution.p2" "positions[substitution.variable, substitution.symbol, substitution.arity].positions?(substitution.sigma(substitution.x))"))) (SigmaP_vs_replaceTerm_linearR_TCC3 0 (SigmaP_vs_replaceTerm_linearR_TCC3-1 nil 3673477505 ("" (skosimp) (("" (lemma SigmaP_Subs) (("" (inst -1 p2!1 sigma!1 t!1 x!1) (("" (expand ext -4) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((SigmaP_Subs formula-decl nil substitution nil) (ext def-decl "term" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (SigmaP_vs_replaceTerm_linearR subtype "substitution.SigmaP(substitution.sigma, substitution.t, substitution.x, substitution.p2)" "Sub"))) (SigmaP_vs_replaceTerm_linearR_TCC4 0 (SigmaP_vs_replaceTerm_linearR_TCC4-2 "" 3790333324 ("" (skosimp*) (("" (assert) (("" (lemma "subterm_ext_commute") (("" (inst -1 "p1!1" "s!1" "sigma!1") (("" (assert) (("" (rewrite pos_o_term) (("" (lemma positions_of_ext) (("" (inst -1 sigma!1 s!1) (("" (decompose-equality -1) (("" (inst -1 p1!1) (("" (iff) (("" (flatten) (("" (hide -1) (("" (expand* union member) (("" (inst 1 p1!1 empty_seq) (("" (rewrite seq_o_empty) (("" (assert) (("" (hide-all-but 1) (("" (expand* positionsOF only_empty_seq empty_seq) (("" (lift-if) (("" (assert) (("" (prop) (("" (expand* union member) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (pos_o_term formula-decl nil subterm nil) (ext def-decl "term" substitution nil) (member const-decl "bool" sets nil) (seq_o_empty formula-decl nil seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (union const-decl "set" sets nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (positions_of_ext formula-decl nil substitution nil) (subterm_ext_commute formula-decl nil substitution nil)) shostak (SigmaP_vs_replaceTerm_linearR subtype "finite_sequences[posnat].o(substitution.p1, substitution.p2)" "positions[substitution.variable, substitution.symbol, substitution.arity].positions?(substitution.ext(substitution.sigma)(substitution.s))")) (SigmaP_vs_replaceTerm_linearR_TCC4-1 nil 3673477505 ("" (skosimp*) (("" (assert) (("" (lemma "subterm_ext_commute") (("" (inst -1 "p1!1" "s!1" "sigma!1") (("" (assert) (("" (replace -3 -1 rl) (("" (replace -1 -4 rl) (("" (rewrite pos_o_term) (("" (lemma positions_of_ext) (("" (inst -1 sigma!1 s!1) (("" (decompose-equality -1) (("" (inst -1 p1!1) (("" (iff) (("" (flatten) (("" (hide -1) (("" (expand* union member) (("" (inst 1 p1!1 empty_seq) (("" (rewrite seq_o_empty) (("" (assert) (("" (hide-all-but 1) (("" (expand* positionsOF only_empty_seq empty_seq) (("" (lift-if) (("" (assert) (("" (prop) (("" (expand* union member) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (pos_o_term formula-decl nil subterm nil) (member const-decl "bool" sets nil) (seq_o_empty formula-decl nil seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (union const-decl "set" sets nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil)) nil (SigmaP_vs_replaceTerm_linearR subtype "finite_sequences[posnat].o(substitution.p1, substitution.p2)" "positions[substitution.variable, substitution.symbol, substitution.arity].positions?(substitution.ext(substitution.sigma)(substitution.s))"))) (SigmaP_vs_replaceTerm_linearR 0 (SigmaP_vs_replaceTerm_linearR-1 nil 3673481464 ("" (lemma finite_sets[position].card_def) (("" (lemma finite_sets[position].card_one) (("" (expand singleton) (("" (induct s) (("1" (skeep) (("1" (skeep) (("1" (case "vars(vars1_var) = x") (("1" (replace -1) (("1" (expand ext 1 1) (("1" (lift-if) (("1" (assert) (("1" (expand SigmaP) (("1" (expand positionsOF -3) (("1" (expand only_empty_seq) (("1" (replace -3 1) (("1" (rewrite empty_o_seq) (("1" (expand ext 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand positionsOF -2) (("2" (assert) (("2" (expand only_empty_seq) (("2" (replace -2 -4) (("2" (expand subtermOF -4) (("2" (rewrite empty_0) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (name-replace "sym" "app1_var") (("2" (expand ext 1 1) (("2" (lift-if) (("2" (assert) (("2" (case "length(app2_var) = 0") (("1" (hide-all-but (-1 -3 -4 -6 1)) (("1" (expand positionsOF) (("1" (assert) (("1" (expand only_empty_seq) (("1" (replace -3 -4) (("1" (expand subtermOF) (("1" (rewrite empty_0) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand finseq_appl 2) (("2" (expand replaceTerm 2) (("2" (lift-if) (("2" (case "length(p1 o p2) = 0") (("1" (hide 2) (("1" (rewrite empty_0) (("1" (lemma seq_empty[posnat]) (("1" (inst -1 p1 p2) (("1" (assert) (("1" (flatten) (("1" (hide-all-but (-1 -5 -6 -8)) (("1" (rewrite empty_0) (("1" (replace -1 -4) (("1" (hide -1 -3) (("1" (expand subtermOF) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (rewrite empty_0) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (decompose-equality 3) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (expand finseq_appl) (("2" (expand ext 1 2) (("2" (expand finseq_appl) (("2" (expand ext 1 3) (("2" (expand finseq_appl) (("2" (expand replace 1) (("2" (decompose-equality 1) (("1" (lift-if) (("1" (expand finseq_appl) (("1" (case "x!1 = first(p1 o p2) - 1") (("1" (assert) (("1" (inst -2 x!1) (("1" (inst -2 "rest(p1)" p2 sigma t x) (("1" (assert) (("1" (prop) (("1" (replace -2 1 rl) (("1" (assert) (("1" (rewrite rest_compo) (("1" (hide-all-but (-3 -4 -6 1)) (("1" (prop) (("1" (rewrite empty_0) (("1" (expand subtermOF) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma rest_of_positions) (("2" (inst -1 p1 "app(sym, app2_var)") (("2" (assert) (("2" (prop) (("1" (replace -2 1) (("1" (expand finseq_appl) (("1" (rewrite first_compo) (("1" (hide-all-but (-3 -4 -6 1)) (("1" (prop) (("1" (rewrite empty_0) (("1" (expand subtermOF) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -4 -6)) (("2" (expand subtermOF) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2 -3 -5 1)) (("3" (replaces -4) (("3" (expand subtermOF 1 1) (("3" (lift-if) (("3" (prop) (("1" (hide 1) (("1" (expand subtermOF) (("1" (assert) nil nil)) nil)) nil) ("2" (expand finseq_appl) (("2" (replace -1 2) (("2" (rewrite first_compo) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2 3 4) (("4" (case "length(p1) /= 0") (("1" (prop) (("1" (lemma Var_occurs_only_once_also_in_subterms) (("1" (inst -1 p1 "app(sym, app2_var)" x) (("1" (assert) (("1" (copy -9) (("1" (inst -1 "Pos_var(app(sym, app2_var), x)") (("1" (inst -10 "Pos_var(app2_var`seq(x!1), x)") (("1" (replace -1 -8 rl) (("1" (replace -10 2 rl) (("1" (hide -1 -9 -10) (("1" (assert) (("1" (rewrite first_compo) (("1" (expand subtermOF -1) (("1" (assert) (("1" (lift-if -1) (("1" (assert) (("1" (case "length( #(first(p1))) /= 0") (("1" (assert) (("1" (expand* finseq_appl) (("1" (expand first -2 1) (("1" (expand* finseq_appl) (("1" (assert) (("1" (case " length( #(first(p1))) = 1") (("1" (expand subtermOF -3) (("1" (lift-if) (("1" (expand rest -3 1) (("1" (expand* ^ min empty_seq) (("1" (assert) (("1" (expand "#" -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (prop) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (prop) (("2" (hide-all-but (-1 -3 -6)) (("2" (expand subtermOF) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -7) (("2" (assert) (("2" (case "member(x, Vars(app2_var`seq(x!1)))") (("1" (expand member) (("1" (inst -7 "Pos_var(app(sym, app2_var), x)") (("1" (replace -7 -6 rl) (("1" (hide -4 -7 2 3 4) (("1" (rewrite card_one) (("1" (skosimp) (("1" (case "length(p1) = 0") (("1" (expand subtermOF) (("1" (assert) nil nil)) nil) ("2" (expand singleton) (("2" (decompose-equality -5) (("2" (copy -1) (("2" (case "EXISTS p: positionsOF(app(sym, app2_var))(p) & p /= p1 & subtermOF(app(sym, app2_var), p) = x") (("1" (skeep -1) (("1" (inst -3 p1) (("1" (inst -4 p) (("1" (case "Pos_var(app(sym, app2_var), x)(p1) & Pos_var(app(sym, app2_var), x)(p)") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (split) (("1" (expand Pos_var 1) (("1" (expand extend) (("1" (propax) nil nil)) nil)) nil) ("2" (expand Pos_var 1) (("2" (expand extend) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (expand Vars -1) (("2" (skosimp) (("2" (expand subtermOF -4) (("2" (assert) (("2" (expand finseq_appl) (("2" (inst 1 "add_first(x!1 + 1, p!1)") (("2" (split) (("1" (expand positionsOF 1) (("1" (expand* union IUnion only_empty_seq catenate finseq_appl member) (("1" (prop) (("1" (inst 2 "1 + x!1" p!1) (("1" (hide 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (prop) (("2" (rewrite first_compo) (("2" (lemma seq_first_rest[posnat]) (("2" (inst -1 p1) (("2" (assert) (("2" (replace -1 -2) (("2" (hide -1) (("2" (lemma first_equal[posnat]) (("2" (inst -1 p!1 "rest(p1)" "1 + x!1" "first(p1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand subtermOF 1) (("3" (lift-if) (("3" (prop) (("1" (hide-all-but -1) (("1" (expand* add_first insert?) (("1" (assert) nil nil)) nil)) nil) ("2" (expand finseq_appl) (("2" (lemma rest_add_first[posnat]) (("2" (inst -1 p!1 "1 + x!1") (("2" (replaces -1) (("2" (lemma first_add[posnat]) (("2" (inst -1 p!1 "1 + x!1") (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand member) (("2" (hide -2 -4 -5 -6 2 4 5) (("2" (lemma SigmaP_equivalence) (("2" (inst -1 p2 "app2_var`seq(x!1)" sigma t x) (("2" (assert) (("2" (expand member) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but (-4 -5 -6 2 3)) (("2" (lemma ext_preserv_pos) (("2" (inst -1 p1 "app(sym, app2_var)" sigma) (("2" (assert) (("2" (replaces -4) (("2" (lemma subterm_ext_commute) (("2" (inst -1 p1 "app(sym, app2_var)" sigma) (("2" (assert) (("2" (replace -1 -4 rl) (("2" (lemma rest_of_positions) (("2" (inst -1 "p1 o p2" "ext(sigma)(app(sym, app2_var))") (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand finseq_appl) (("1" (case "args(ext(sigma)(app(sym, app2_var)))`seq(first(p1 o p2) - 1) = ext(sigma)(app2_var`seq(first(o(p1, p2)) - 1))") (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma pos_o_term) (("2" (inst -1 p1 p2 "ext(sigma)(app(sym, app2_var))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide-all-but (-3 -4 -6 2)) (("3" (case "length(p1) = 0") (("1" (expand subtermOF -4) (("1" (assert) nil nil)) nil) ("2" (rewrite first_compo) (("2" (expand* positionsOF union IUnion member only_empty_seq) (("2" (rewrite empty_0) (("2" (assert) (("2" (skosimp) (("2" (expand catenate) (("2" (skosimp) (("2" (expand add_first) (("2" (expand insert?) (("2" (decompose-equality -3) (("2" (decompose-equality -2) (("2" (inst -1 0) (("1" (expand first 2) (("1" (expand finseq_appl) (("1" (expand member) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (rewrite SigmaP_Subs) (("4" (expand ext -4) (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (skeep) (("5" (expand ext -4) (("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (expand ext -4) (("3" (rewrite SigmaP_Subs) nil nil)) nil)) nil) ("4" (skeep) (("4" (expand ext -4) (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (lemma ext_preserv_pos) (("3" (inst -1 p1 s sigma) (("3" (assert) (("3" (hide 2) (("3" (replace -5 -4) (("3" (lemma subterm_ext_commute) (("3" (inst -1 p1 s sigma) (("3" (assert) (("3" (replace -1 -5 rl) (("3" (lemma pos_o_term) (("3" (inst -1 p1 p2 "ext(sigma)(s)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (expand ext -3) (("4" (assert) (("4" (rewrite SigmaP_Subs) nil nil)) nil)) nil)) nil) ("5" (skeep) (("5" (expand ext -3) (("5" (assert) nil nil)) nil)) nil) ("6" (skeep) (("6" (hide-all-but 1) (("6" (lemma Pos_var_is_finite) (("6" (inst -1 s x) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((card_one formula-decl nil finite_sets nil) (Pos_var const-decl "positions" subterm nil) (is_finite const-decl "bool" finite_sets nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (ext def-decl "term" substitution nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (Card const-decl "nat" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (SigmaP const-decl "term" substitution nil) (O const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (replaceTerm def-decl "term" replacement nil) (term_induction formula-decl nil term_adt nil) (empty_seq const-decl "finseq" finite_sequences nil) (empty_0 formula-decl nil seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (empty_o_seq formula-decl nil seq_extras structures) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (seq_empty formula-decl nil seq_extras structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (app1_var skolem-const-decl "symbol" substitution nil) (app2_var skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var)}" substitution nil) (sigma skolem-const-decl "Sub" substitution nil) (x skolem-const-decl "(V)" substitution nil) (p2 skolem-const-decl "position[variable, symbol, arity]" substitution nil) (t skolem-const-decl "term[variable, symbol, arity]" substitution nil) (rest const-decl "finseq" seq_extras structures) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (replace const-decl "finseq" seq_extras structures) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (term_app_extensionality formula-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (SigmaP_Subs formula-decl nil substitution nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (ext_preserv_pos formula-decl nil substitution nil) (subterm_ext_commute formula-decl nil substitution nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pos_o_term formula-decl nil subterm nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Var_occurs_only_once_also_in_subterms formula-decl nil subterm nil) (TRUE const-decl "bool" booleans nil) (rest_of_positions formula-decl nil positions nil) (first_compo formula-decl nil seq_extras structures) (rest_compo formula-decl nil seq_extras structures) (SigmaP_equivalence formula-decl nil substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[position[variable, symbol, arity]]" substitution nil) (extend const-decl "R" extend nil) (IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (union const-decl "set" sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (first_equal formula-decl nil seq_extras structures) (seq_first_rest formula-decl nil seq_extras structures) (first_add formula-decl nil seq_extras structures) (rest_add_first formula-decl nil seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (Vars const-decl "set[(V)]" subterm nil) (member const-decl "bool" sets nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (p1 skolem-const-decl "position[variable, symbol, arity]" substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (finite_sequence type-eq-decl nil finite_sequences nil) (Pos_var_is_finite formula-decl nil subterm nil) (singleton const-decl "(singleton?)" sets nil) (card_def formula-decl nil finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (position type-eq-decl nil positions nil)) shostak)) (gamma_Dom 0 (gamma_Dom-1 nil 3414315311 ("" (skeep) (("" (skoletin* 1) (("" (expand* "subset?" "member") (("" (skolem * "z") (("" (flatten) (("" (expand* "union" "member") (("" (expand "Dom") (("" (prop) (("" (expand* "gamma" "singleton") (("" (lift-if) (("" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (= const-decl "[T, T -> boolean]" equalities nil) (union const-decl "set" sets nil) (Dom const-decl "set[(V)]" substitution nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[term[variable, symbol, arity]]" substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[(V)]" substitution nil) (nonempty_union2 application-judgement "(nonempty?)" sets nil) (subset? const-decl "bool" sets nil) (gamma const-decl "term" substitution nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (/= const-decl "boolean" notequal nil) (member const-decl "bool" sets nil)) shostak)) (gamma_Dom_fin 0 (gamma_Dom_fin-1 nil 3414333203 ("" (skeep) (("" (lemma "gamma_Dom") (("" (inst?) (("" (assert) (("" (typepred "sg1" "sg2") (("" (expand "Sub?") (("" (lemma "fsetvar.finite_union") (("" (inst?) (("" (lemma "fsetvar.finite_union") (("" (inst -1 "union(Dom(sg1), Dom(sg2))" "singleton(y)") (("" (lemma "fsetvar.finite_subset") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gamma_Dom formula-decl nil substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[(V)]" substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[term[variable, symbol, arity]]" substitution nil) (nonempty_union2 application-judgement "(nonempty?)" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (is_finite const-decl "bool" finite_sets nil) (Dom const-decl "set[(V)]" substitution nil) (sg1 skolem-const-decl "Sub" substitution nil) (sg2 skolem-const-decl "Sub" substitution nil) (finite_set type-eq-decl nil finite_sets nil) (union const-decl "set" sets nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (y skolem-const-decl "(V)" substitution nil) (gamma const-decl "term" substitution nil) (finite_subset formula-decl nil finite_sets nil) (finite_union judgement-tcc nil finite_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil)) shostak)) (gamma_Subs 0 (gamma_Subs-1 nil 3414333618 ("" (skeep) (("" (expand "Sub?") (("" (lemma "gamma_Dom_fin") (("" (inst?) nil nil)) nil)) nil)) nil) ((Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (gamma_Dom_fin formula-decl nil substitution nil)) shostak)) (gamma_is_RSigma_TCC1 0 (gamma_is_RSigma_TCC1-1 nil 3414333817 ("" (skosimp*) (("" (rewrite "gamma_Subs") nil nil)) nil) ((gamma_Subs formula-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil)) nil (gamma_is_RSigma subtype "substitution.gamma(substitution.sg1, substitution.sg2, substitution.x, substitution.y)" "Sub"))) (gamma_is_RSigma_TCC2 0 (gamma_is_RSigma_TCC2-1 nil 3414333817 ("" (skosimp*) (("" (rewrite "gamma_Subs") nil nil)) nil) ((gamma_Subs formula-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil)) nil (gamma_is_RSigma subtype "substitution.gamma(substitution.sg2, substitution.sg2, substitution.x, substitution.y)" "Sub"))) (gamma_is_RSigma 0 (gamma_is_RSigma-1 nil 3414333817 ("" (skeep) (("" (expand "RSigma") (("" (skosimp*) (("" (prop) (("1" (inst -1 "y!1") (("1" (assert) (("1" (expand "gamma") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "z") (("2" (assert) (("2" (expand "gamma") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RSigma const-decl "bool" substitution nil) (gamma const-decl "term" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil)) shostak)) (gamma_term_TCC1 0 (gamma_term_TCC1-1 nil 3414334177 ("" (skosimp*) (("" (rewrite "gamma_Subs") nil nil)) nil) ((gamma_Subs formula-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil)) nil (gamma_term subtype "substitution.gamma(substitution.sg1, substitution.sg2, substitution.x, substitution.y)" "Sub"))) (gamma_term_TCC2 0 (gamma_term_TCC2-1 nil 3414334177 ("" (skosimp*) (("" (rewrite "gamma_Subs") nil nil)) nil) ((gamma_Subs formula-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil)) nil (gamma_term subtype "substitution.gamma(substitution.sg2, substitution.sg2, substitution.x, substitution.y)" "Sub"))) (gamma_term 0 (gamma_term-2 "" 3790333333 ("" (induct "t") (("1" (skeep) (("1" (skeep) (("1" (split) (("1" (expand "ext") (("1" (expand "gamma") (("1" (lift-if) (("1" (prop) (("1" (typepred "y") (("1" (expand "V") (("1" (expand* "Vars" "member") (("1" (inst 2 "empty_seq") (("1" (expand "subtermOF") (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (hide (-1 -2 2 3)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 2)) (("2" (expand "positionsOF") (("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ext") (("2" (expand "gamma") (("2" (lift-if) (("2" (prop) (("2" (typepred "y") (("2" (expand "V") (("2" (expand* "Vars" "member") (("2" (inst 2 "empty_seq") (("1" (expand "subtermOF") (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (hide (-1 -2 2 3)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 2)) (("2" (expand "positionsOF") (("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (split) (("1" (expand "ext" 1) (("1" (lift-if) (("1" (prop) (("1" (decompose-equality 2) (("1" (decompose-equality 1) (("1" (expand "finseq_appl") (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (expand* "Vars" "member") (("1" (skosimp*) (("1" (inst 2 "add_first(x!1 + 1, p!1)") (("1" (expand "subtermOF" 2) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (rewrite "rest_add_first") (("2" (rewrite "first_add") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positionsOF") (("2" (expand* "union" "member") (("2" (prop) (("2" (expand "IUnion") (("2" (typepred "x!1" "p!1") (("2" (inst 2 "x!1 + 1") (("2" (expand* "catenate" "finseq_appl") (("2" (inst 2 "p!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (rewrite "gamma_Subs") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (rewrite "gamma_Subs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ext" 1) (("2" (lift-if) (("2" (prop) (("2" (decompose-equality 2) (("1" (decompose-equality 1) (("1" (expand "finseq_appl") (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (expand* "Vars" "member") (("1" (skosimp*) (("1" (inst 2 "add_first(x!1 + 1, p!1)") (("1" (expand "subtermOF" 2) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (rewrite "rest_add_first") (("2" (rewrite "first_add") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positionsOF") (("2" (expand* "union" "member") (("2" (prop) (("2" (expand "IUnion") (("2" (typepred "x!1" "p!1") (("2" (inst 2 "x!1 + 1") (("2" (expand* "catenate" "finseq_appl") (("2" (inst 2 "p!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (rewrite "gamma_Subs") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (rewrite "gamma_Subs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide-all-but 2) (("3" (rewrite "gamma_Subs") nil nil)) nil)) nil) ("4" (skeep) (("4" (hide-all-but 2) (("4" (rewrite "gamma_Subs") nil nil)) nil)) nil)) nil) ((y skolem-const-decl "(V)" substitution nil) (x skolem-const-decl "(V)" substitution nil) (sg2 skolem-const-decl "Sub" substitution nil) (sg1 skolem-const-decl "Sub" substitution nil) (app2_var skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var)}" substitution nil) (app1_var skolem-const-decl "symbol" substitution nil) (finite_sequence type-eq-decl nil finite_sequences nil) (< const-decl "bool" reals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (term_app_extensionality formula-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (gamma_Subs formula-decl nil substitution nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (add_first const-decl "finseq" seq_extras structures) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (x!1 skolem-const-decl "below[app2_var`length]" substitution nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](app2_var`seq(x!1))" substitution nil) (first_add formula-decl nil seq_extras structures) (int_minus_int_is_int application-judgement "int" integers nil) (rest_add_first formula-decl nil seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (union const-decl "set" sets nil) (IUnion const-decl "set[T]" indexed_sets nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (<= const-decl "bool" reals nil) (catenate const-decl "positions" positions nil) (x!1 skolem-const-decl "below[app2_var`length]" substitution nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](app2_var`seq(x!1))" substitution nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (vars1_var skolem-const-decl "variable" substitution nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (positions? type-eq-decl nil positions nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (subtermOF def-decl "term" subterm nil) (only_empty_seq const-decl "positions" positions nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (ext def-decl "term" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (Vars const-decl "set[(V)]" subterm nil) (gamma const-decl "term" substitution nil)) shostak) (gamma_term-1 nil 3414334178 ("" (induct "t") (("1" (skeep) (("1" (skeep) (("1" (split) (("1" (expand "ext") (("1" (expand "gamma") (("1" (lift-if) (("1" (prop) (("1" (typepred "y") (("1" (expand "V") (("1" (expand* "Vars" "member") (("1" (expand "restrict") (("1" (inst 2 "empty_seq") (("1" (expand "subtermOF") (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (hide (-1 -2 2 3)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 2)) (("2" (expand "positionsOF") (("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ext") (("2" (expand "gamma") (("2" (lift-if) (("2" (prop) (("2" (typepred "y") (("2" (expand "V") (("2" (expand* "Vars" "member") (("2" (expand "restrict") (("2" (inst 2 "empty_seq") (("1" (expand "subtermOF") (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (hide (-1 -2 2 3)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 2)) (("2" (expand "positionsOF") (("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (split) (("1" (expand "ext" 1) (("1" (lift-if) (("1" (prop) (("1" (decompose-equality 2) (("1" (decompose-equality 1) (("1" (expand "finseq_appl") (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (expand* "Vars" "member") (("1" (expand "restrict") (("1" (skosimp*) (("1" (inst 2 "add_first(x!1 + 1, p!1)") (("1" (expand "subtermOF" 2) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (rewrite "rest_add_first") (("2" (rewrite "first_add") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positionsOF") (("2" (expand* "union" "member") (("2" (prop) (("2" (expand "IUnion") (("2" (typepred "x!1" "p!1") (("2" (inst 2 "x!1 + 1") (("2" (expand* "catenate" "finseq_appl") (("2" (inst 2 "p!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (rewrite "gamma_Subs") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (rewrite "gamma_Subs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "ext" 1) (("2" (lift-if) (("2" (prop) (("2" (decompose-equality 2) (("1" (decompose-equality 1) (("1" (expand "finseq_appl") (("1" (inst?) (("1" (assert) (("1" (hide 1) (("1" (expand* "Vars" "member") (("1" (expand "restrict") (("1" (skosimp*) (("1" (inst 2 "add_first(x!1 + 1, p!1)") (("1" (expand "subtermOF" 2) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (rewrite "rest_add_first") (("2" (rewrite "first_add") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positionsOF") (("2" (expand* "union" "member") (("2" (prop) (("2" (expand "IUnion") (("2" (typepred "x!1" "p!1") (("2" (inst 2 "x!1 + 1") (("2" (expand* "catenate" "finseq_appl") (("2" (inst 2 "p!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (rewrite "gamma_Subs") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (rewrite "gamma_Subs") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide-all-but 2) (("3" (rewrite "gamma_Subs") nil nil)) nil)) nil) ("4" (skeep) (("4" (hide-all-but 2) (("4" (rewrite "gamma_Subs") nil nil)) nil)) nil)) nil) ((finite_sequence type-eq-decl nil finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (term_app_extensionality formula-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (add_first const-decl "finseq" seq_extras structures) (first_add formula-decl nil seq_extras structures) (rest_add_first formula-decl nil seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (union const-decl "set" sets nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (catenate const-decl "positions" positions nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (only_empty_seq const-decl "positions" positions nil) (term_induction formula-decl nil term_adt nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (member const-decl "bool" sets nil) (Vars const-decl "set[(V)]" subterm nil)) shostak)) (Rhop_Dom 0 (Rhop_Dom-1 nil 3415344970 ("" (skosimp*) (("" (decompose-equality 3) (("" (iff) (("" (prop) (("1" (expand* "union" "member") (("1" (flatten) (("1" (expand* "Dom" "singleton") (("1" (prop) (("1" (expand "Rhop") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "union" "member") (("2" (prop) (("1" (expand* "Dom") (("1" (prop) (("1" (expand "Rhop") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "singleton" "Dom") (("2" (prop) (("2" (expand "Rhop") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonempty_singleton_finite application-judgement "non_empty_finite_set[(V)]" substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[term[variable, symbol, arity]]" substitution nil) (nonempty_union2 application-judgement "(nonempty?)" sets nil) (Dom const-decl "set[(V)]" substitution nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Ren type-eq-decl nil substitution nil) (Rhop const-decl "(V)" substitution nil) (union const-decl "set" sets nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (member const-decl "bool" sets nil)) shostak)) (Rhop_Ran 0 (Rhop_Ran-1 nil 3415556802 ("" (skosimp*) (("" (decompose-equality 4) (("" (iff) (("" (prop) (("1" (expand* "union" "member") (("1" (prop) (("1" (expand* "Ran" "singleton") (("1" (skosimp*) (("1" (expand "member") (("1" (expand "Dom" -1) (("1" (prop) (("1" (expand "Rhop") (("1" (lift-if) (("1" (prop) (("1" (inst 4 "x!3") (("1" (assert) (("1" (expand "Dom" 4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "union" "member") (("2" (prop) (("1" (expand "Ran") (("1" (skosimp*) (("1" (expand "member") (("1" (inst 1 "x!3") (("1" (split) (("1" (lemma "Rhop_Dom") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (expand* "union" "mmeber") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Rhop") (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "singleton" "Ran") (("2" (inst 1 "x!1") (("2" (expand "member") (("2" (split) (("1" (lemma "Rhop_Dom") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (expand* "union" "member" "singleton") nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Rhop") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonempty_union2 application-judgement "(nonempty?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[(V)]" substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[term[variable, symbol, arity]]" substitution nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Ran const-decl "set[term[variable, symbol, arity]]" substitution nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Ren type-eq-decl nil substitution nil) (Rhop const-decl "(V)" substitution nil) (union const-decl "set" sets nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (Dom const-decl "set[(V)]" substitution nil) (member const-decl "bool" sets nil) (Rhop_Dom formula-decl nil substitution nil) (TRUE const-decl "bool" booleans nil)) shostak)) (Rhop_Dom_fin 0 (Rhop_Dom_fin-1 nil 3415345354 ("" (skosimp*) (("" (lemma "Rhop_Dom") (("" (inst?) (("" (assert) (("" (typepred "rho!1") (("" (hide -2) (("" (expand "Sub?") (("" (replaces -2) (("" (rewrite "finite_union") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Rhop_Dom formula-decl nil substitution nil) (TRUE const-decl "bool" booleans nil) (singleton const-decl "(singleton?)" sets nil) (singleton? const-decl "bool" sets nil) (Dom const-decl "set[(V)]" substitution nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_union judgement-tcc nil finite_sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[(V)]" substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[term[variable, symbol, arity]]" substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (Ren type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil)) shostak)) (Rhop_Subs 0 (Rhop_Subs-1 nil 3415345503 ("" (skeep) (("" (expand "Sub?") (("" (rewrite "Rhop_Dom_fin") nil nil)) nil)) nil) ((Sub? const-decl "bool" substitution nil) (Ren type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (Rhop_Dom_fin formula-decl nil substitution nil)) shostak)) (Rhop_Ren_TCC1 0 (Rhop_Ren_TCC1-1 nil 3415344914 ("" (skosimp*) (("" (rewrite "Rhop_Subs") nil nil)) nil) ((Rhop_Subs formula-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Ren type-eq-decl nil substitution nil)) nil (Rhop_Ren subtype "substitution.Rhop(substitution.rho, substitution.x, substitution.y)" "Sub"))) (Rhop_Ren 0 (Rhop_Ren-1 nil 3415345574 ("" (skeep) (("" (expand "Ren?") (("" (split) (("1" (expand* "subset?" "member") (("1" (skolem 1 "z1") (("1" (flatten) (("1" (expand* "Ran" "member") (("1" (skolem -1 "z2") (("1" (flatten) (("1" (typepred "Rhop(rho, x, y)(z2)") (("1" (expand "V") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "rho") (("2" (expand* "Ren?" "bijective?" "injective?" "surjective?") (("2" (flatten) (("2" (expand "restrict") (("2" (split) (("1" (skosimp*) (("1" (lemma "Rhop_Dom") (("1" (inst?) (("1" (assert) (("1" (decompose-equality -1) (("1" (expand "Rhop" -2) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (inst -5 "x1!1" "x2!1") (("1" (assert) nil nil) ("2" (inst -2 "x2!1") (("2" (iff) (("2" (typepred "x2!1") (("2" (prop) (("2" (expand* "union" "member") (("2" (prop) (("2" (expand "singleton") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -2 "x1!1") (("3" (iff) (("3" (typepred "x1!1") (("3" (prop) (("3" (expand* "union" "member") (("3" (prop) (("3" (expand "singleton") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Ran" 5) (("2" (inst 5 "x1!1") (("2" (expand "member") (("2" (assert) (("2" (inst -3 "x1!1") (("2" (iff) (("2" (typepred "x1!1") (("2" (prop) (("2" (expand* "union" "member") (("2" (expand "singleton") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "Ran" 4) (("3" (inst 4 "x2!1") (("3" (assert) (("3" (expand "member") (("3" (inst -3 "x2!1") (("3" (iff) (("3" (typepred "x2!1") (("3" (prop) (("3" (expand* "union" "member") (("3" (expand "singleton") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (case-replace "y!1 = y") (("1" (inst 1 "x") (("1" (expand "Rhop" 1) (("1" (propax) nil nil)) nil) ("2" (lemma "Rhop_Dom") (("2" (inst?) (("2" (assert) (("2" (decompose-equality -1) (("2" (inst -1 "x") (("2" (expand* "union" "member") (("2" (expand "singleton") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "y!1") (("1" (skosimp*) (("1" (inst 2 "x!1") (("1" (expand "Rhop" 2) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "x!1") (("2" (lemma "Rhop_Dom") (("2" (inst?) (("2" (assert) (("2" (decompose-equality -1) (("2" (inst -1 "x!1") (("2" (expand* "union" "member") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "Rhop_Ran") (("2" (inst?) (("2" (assert) (("2" (decompose-equality -1) (("2" (typepred "y!1") (("2" (inst -2 "y!1") (("2" (iff) (("2" (prop) (("2" (expand* "union" "member") (("2" (expand "singleton") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Ren? const-decl "bool" substitution nil) (Rhop_Dom formula-decl nil substitution nil) (subset_is_partial_order name-judgement "(partial_order?[set[term[variable, symbol, arity]]])" substitution nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (rho skolem-const-decl "Ren" substitution nil) (x skolem-const-decl "(V)" substitution nil) (y skolem-const-decl "(V)" substitution nil) (x1!1 skolem-const-decl "(Dom(Rhop(rho, x, y)))" substitution nil) (x2!1 skolem-const-decl "(Dom(Rhop(rho, x, y)))" substitution nil) (nonempty_union2 application-judgement "(nonempty?)" sets nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[term[variable, symbol, arity]]" substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[(V)]" substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (Dom const-decl "set[(V)]" substitution nil) (union const-decl "set" sets nil) (singleton? const-decl "bool" sets nil) (singleton const-decl "(singleton?)" sets nil) (Rhop_Ran formula-decl nil substitution nil) (x!1 skolem-const-decl "(Dom(rho))" substitution nil) (y!1 skolem-const-decl "(Ran(Rhop(rho, x, y)))" substitution nil) (restrict const-decl "R" restrict nil) (injective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (bijective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (Rhop const-decl "(V)" substitution nil) (Ren type-eq-decl nil substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Ran const-decl "set[term[variable, symbol, arity]]" substitution nil)) shostak)) (ext_replace_ext 0 (ext_replace_ext-3 "" 3804433204 ("" (measure-induct+ "length(p)" "p") (("1" (skeep) (("1" (expand "replaceTerm" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "ext" 2 1) (("1" (lift-if) (("1" (prop) (("1" (decompose-equality 1) (("1" (expand "ext" 1) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (hide-all-but (-1 -4 2)) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (grind) (("1" (hide (-1 1)) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "positionsOF") (("2" (lift-if) (("2" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 2) (("1" (hide -1) (("1" (expand "ext") (("1" (lift-if) (("1" (prop) (("1" (hide (1 2)) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "replace" 1 3) (("2" (lift-if) (("2" (prop) (("1" (hide (-2 1 2)) (("1" (lemma "ext_preserv_pos") (("1" (inst?) (("1" (inst?) (("1" (assert) (("1" (hide -3) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 2) (("1" (expand "replace" 1 1) (("1" (lift-if) (("1" (expand "ext" 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 -3 4)) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (lift-if) (("1" (prop) (("1" (expand "finseq_appl") (("1" (grind) (("1" (expand "ext" 1) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (lemma "fset.nth_x") (("2" (inst -1 "args(s)" "replaceTerm(args(s)(first(x!1) - 1), t, rest(x!1))" "first(x!1) - 1") (("2" (replaces -1) (("2" (inst -1 "rest(x!1)") (("2" (inst -1 "args(s)(first(x!1) - 1)" "sigma" "t") (("2" (rewrite "length_rest") (("2" (prop) (("1" (case-replace "ext(sigma)(args(s)(first(x!1) - 1)) = args(ext(sigma)(s))(first(x!1) - 1)") (("1" (hide-all-but (-2 1 4 6)) (("1" (expand "ext" 1 2) (("1" (lift-if) (("1" (prop) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positionsOF") (("2" (lift-if) (("2" (prop) (("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "rest_of_positions") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (grind) (("3" (expand "ext" 2) (("3" (lift-if) (("3" (lift-if) (("3" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (prop) (("1" (grind) (("1" (case-replace "length(args(ext(sigma)(s))) = args(s)`length") (("1" (expand "ext" 1) (("1" (lift-if) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (case-replace "length(args(ext(sigma)(s))) = args(s)`length") (("2" (expand "ext" 1) (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (lemma "ext_preserv_pos") (("3" (inst?) (("3" (inst?) (("3" (assert) (("3" (lemma "rest_of_positions") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("3" (hide 3) (("3" (skosimp*) (("3" (prop) (("1" (grind) (("1" (case-replace "length(args(ext(sigma)(s))) = args(s)`length") (("1" (expand "ext" 1) (("1" (lift-if) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (case-replace "length(args(ext(sigma)(s))) = args(s)`length") (("2" (expand "ext" 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide (-1 3)) (("4" (skosimp*) (("4" (lemma "ext_preserv_pos") (("4" (inst?) (("4" (inst?) (("4" (assert) (("4" (lemma "rest_of_positions") (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide (-1 3)) (("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "ext_preserv_pos") nil nil) ("3" (hide 2) (("3" (rewrite "ext_preserv_pos") nil nil)) nil)) nil) nil shostak) (ext_replace_ext-2 "" 3790333341 ("" (measure-induct+ "length(p)" "p") (("1" (skeep) (("1" (expand "replaceTerm" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "ext" 2 1) (("1" (lift-if) (("1" (prop) (("1" (decompose-equality 1) (("1" (expand "ext" 1) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (hide-all-but (-1 -4 2)) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (grind) (("1" (hide (-1 1)) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "positionsOF") (("2" (lift-if) (("2" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 2) (("1" (hide -1) (("1" (expand "ext") (("1" (lift-if) (("1" (prop) (("1" (hide (1 2)) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "replace" 1 3) (("2" (lift-if) (("2" (prop) (("1" (hide (-2 1 2)) (("1" (lemma "ext_preserv_pos") (("1" (inst?) (("1" (inst?) (("1" (assert) (("1" (hide -3) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 2) (("1" (expand "replace" 1 1) (("1" (lift-if) (("1" (expand "ext" 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 -3 4)) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (lift-if) (("1" (prop) (("1" (expand "finseq_appl") (("1" (grind) (("1" (expand "ext" 1) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (lemma "fset.nth_x") (("2" (inst -1 "args(s)" "replaceTerm(args(s)(first(x!1) - 1), t, rest(x!1))" "first(x!1) - 1") (("2" (replaces -1) (("2" (inst -1 "rest(x!1)") (("2" (inst -1 "args(s)(first(x!1) - 1)" "sigma" "t") (("2" (rewrite "length_rest") (("2" (prop) (("1" (case-replace "ext(sigma)(args(s)(first(x!1) - 1)) = args(ext(sigma)(s))(first(x!1) - 1)") (("1" (hide-all-but (-2 1 4 6)) (("1" (expand "ext" 1 2) (("1" (lift-if) (("1" (prop) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positionsOF") (("2" (lift-if) (("2" (prop) (("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "rest_of_positions") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (grind) (("3" (expand "ext" 2) (("3" (lift-if) (("3" (lift-if) (("3" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (prop) (("1" (grind) (("1" (case-replace "length(args(ext(sigma)(s))) = args(s)`length") (("1" (expand "ext" 1) (("1" (lift-if) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (case-replace "length(args(ext(sigma)(s))) = args(s)`length") (("2" (expand "ext" 1) (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (lemma "ext_preserv_pos") (("3" (inst?) (("3" (inst?) (("3" (assert) (("3" (lemma "rest_of_positions") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("3" (hide 3) (("3" (skosimp*) (("3" (prop) (("1" (grind) (("1" (case-replace "length(args(ext(sigma)(s))) = args(s)`length") (("1" (expand "ext" 1) (("1" (lift-if) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (case-replace "length(args(ext(sigma)(s))) = args(s)`length") (("2" (expand "ext" 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide (-1 3)) (("4" (skosimp*) (("4" (lemma "ext_preserv_pos") (("4" (inst?) (("4" (inst?) (("4" (assert) (("4" (lemma "rest_of_positions") (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide (-1 3)) (("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -3 2)) (("2" (rewrite "ext_preserv_pos") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "ext_preserv_pos") nil nil)) nil)) nil) ((rest_of_positions formula-decl nil positions nil) (length_rest formula-decl nil seq_extras structures) (nth_x formula-decl nil seq_extras structures) (TRUE const-decl "bool" booleans nil) (member const-decl "bool" sets nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (union const-decl "set" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (sigma skolem-const-decl "Sub" substitution nil) (ext_preserv_pos formula-decl nil substitution nil) (s skolem-const-decl "term[variable, symbol, arity]" substitution nil) (t skolem-const-decl "term[variable, symbol, arity]" substitution nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (empty_0 formula-decl nil seq_extras structures) (only_empty_seq const-decl "positions" positions nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term_app_extensionality formula-decl nil term_adt nil) (rest const-decl "finseq" seq_extras structures) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (replace const-decl "finseq" seq_extras structures) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (x!1 skolem-const-decl "position[variable, symbol, arity]" substitution nil) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (/= const-decl "boolean" notequal nil) (finseq type-eq-decl nil finite_sequences nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (replaceTerm def-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (ext def-decl "term" substitution nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak) (ext_replace_ext-1 nil 3433012308 ("" (measure-induct+ "length(p)" "p") (("1" (skeep) (("1" (expand "replaceTerm" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "ext" 2 1) (("1" (lift-if) (("1" (prop) (("1" (decompose-equality 1) (("1" (expand "ext" 1) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (hide-all-but (-1 -4 2)) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (grind) (("1" (hide (-1 1)) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "positionsOF") (("2" (lift-if) (("2" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 2) (("1" (hide -1) (("1" (expand "ext") (("1" (lift-if) (("1" (prop) (("1" (hide (1 2)) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "replace" 1 3) (("2" (lift-if) (("2" (prop) (("1" (hide (-2 1 2)) (("1" (lemma "ext_preserv_pos") (("1" (inst?) (("1" (inst?) (("1" (assert) (("1" (hide -3) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 2) (("1" (expand "replace" 1 1) (("1" (lift-if) (("1" (expand "ext" 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 -3 4)) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("1" (lift-if) (("1" (prop) (("1" (expand "finseq_appl") (("1" (grind) (("1" (expand "ext" 1) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (lemma "fset.nth_x") (("2" (inst -1 "args(s)" "replaceTerm(args(s)(first(x!1) - 1), t, rest(x!1))" "first(x!1) - 1") (("2" (replaces -1) (("2" (inst -1 "rest(x!1)") (("2" (inst -1 "args(s)(first(x!1) - 1)" "sigma" "t") (("2" (rewrite "length_rest") (("2" (prop) (("1" (case-replace "ext(sigma)(args(s)(first(x!1) - 1)) = args(ext(sigma)(s))(first(x!1) - 1)") (("1" (hide-all-but (-2 1 4 6)) (("1" (expand "ext" 1 2) (("1" (lift-if) (("1" (prop) (("1" (expand "positionsOF") (("1" (lift-if) (("1" (prop) (("1" (expand "only_empty_seq") (("1" (lemma "fsepn.empty_0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positionsOF") (("2" (lift-if) (("2" (prop) (("2" (expand "only_empty_seq") (("2" (lemma "fsepn.empty_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "rest_of_positions") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (grind) (("3" (expand "ext" 2) (("3" (lift-if) (("3" (lift-if) (("3" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (prop) (("1" (grind) (("1" (case-replace "length(args(ext(sigma)(s))) = args(s)`length") (("1" (expand "ext" 1) (("1" (lift-if) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (case-replace "length(args(ext(sigma)(s))) = args(s)`length") (("2" (expand "ext" 1) (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (lemma "ext_preserv_pos") (("3" (inst?) (("3" (inst?) (("3" (assert) (("3" (lemma "rest_of_positions") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("3" (hide 3) (("3" (skosimp*) (("3" (prop) (("1" (grind) (("1" (case-replace "length(args(ext(sigma)(s))) = args(s)`length") (("1" (expand "ext" 1) (("1" (lift-if) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (case-replace "length(args(ext(sigma)(s))) = args(s)`length") (("2" (expand "ext" 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide (-1 3)) (("4" (skosimp*) (("4" (lemma "ext_preserv_pos") (("4" (inst?) (("4" (inst?) (("4" (assert) (("4" (lemma "rest_of_positions") (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide (-1 3)) (("5" (skosimp*) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 -3 2)) (("2" (rewrite "ext_preserv_pos") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "ext_preserv_pos") nil nil)) nil)) nil) ((empty_seq const-decl "finseq" finite_sequences nil) (^ const-decl "finseq" finite_sequences nil) (only_empty_seq const-decl "positions" positions nil) (empty_0 formula-decl nil seq_extras structures) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (term_app_extensionality formula-decl nil term_adt nil) (rest const-decl "finseq" seq_extras structures) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (replace const-decl "finseq" seq_extras structures) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (finseq type-eq-decl nil finite_sequences nil) (member const-decl "bool" sets nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (catenate const-decl "positions" positions nil) (union const-decl "set" sets nil) (nth_x formula-decl nil seq_extras structures) (rest_of_positions formula-decl nil positions nil) (length_rest formula-decl nil seq_extras structures) (replaceTerm def-decl "term" replacement nil) (positions? type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (position type-eq-decl nil positions nil) (well_founded? const-decl "bool" orders nil)) shostak)) (rename_preserv_pos 0 (rename_preserv_pos-1 nil 3433013098 ("" (induct "t") (("1" (skeep) (("1" (skeep) (("1" (expand "ext") (("1" (typepred "rho") (("1" (expand* "Ren?" "bijective?" "injective?" "surjective?") (("1" (flatten) (("1" (case "member(vars(vars1_var), Dom(rho))") (("1" (hide (-4 -5)) (("1" (expand* "subset?" "Ran" "member") (("1" (inst -3 "rho(vars(vars1_var))") (("1" (prop) (("1" (expand "V") (("1" (expand "positionsOF") (("1" (assert) nil nil)) nil)) nil) ("2" (inst 1 "vars(vars1_var)") nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "positionsOF" 1) (("2" (lift-if) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (decompose-equality 2) (("3" (lift-if) (("3" (expand "union") (("3" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (union const-decl "set" sets nil) (only_empty_seq const-decl "positions" positions nil) (<= const-decl "bool" reals nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (finseq type-eq-decl nil finite_sequences nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (empty_seq const-decl "finseq" finite_sequences nil) (add_first const-decl "finseq" seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (bijective? const-decl "bool" functions nil) (surjective? const-decl "bool" functions nil) (injective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (Dom const-decl "set[(V)]" substitution nil) (Ran const-decl "set[term[variable, symbol, arity]]" substitution nil) (subset? const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subset_is_partial_order name-judgement "(partial_order?[set[term[variable, symbol, arity]]])" substitution nil) (is_finite const-decl "bool" finite_sets nil) (/= const-decl "boolean" notequal nil) (NOT const-decl "[bool -> bool]" booleans nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (ext def-decl "term" substitution nil) (positionsOF def-decl "positions" positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (Ren type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil)) shostak)) (subterm_of_ext_TCC1 0 (subterm_of_ext_TCC1-1 nil 3433013216 ("" (skosimp*) (("" (lemma "ext_preserv_pos") (("" (inst -1 "p!1" "t!1" "sigma!1") (("" (assert) (("" (lemma "subterm_ext_commute") (("" (inst -1 "p!1" "t!1" "sigma!1") (("" (assert) (("" (lemma "pos_o_term") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ext_preserv_pos formula-decl nil substitution nil) (pos_o_term formula-decl nil subterm nil) (ext def-decl "term" substitution nil) (subterm_ext_commute formula-decl nil substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (subterm_of_ext subtype "finite_sequences[posnat].o(substitution.p, substitution.p1)" "positions[substitution.variable, substitution.symbol, substitution.arity].positions?(substitution.ext(substitution.sigma)(substitution.t))"))) (subterm_of_ext 0 (subterm_of_ext-1 nil 3433013217 ("" (skeep) (("" (prop) (("1" (lemma "ext_preserv_pos") (("1" (inst -1 "p" "t" "sigma") (("1" (assert) (("1" (lemma "subterm_ext_commute") (("1" (inst -1 "p" "t" "sigma") (("1" (assert) (("1" (replace -1 -4 rl) (("1" (lemma "pos_o_term") (("1" (inst?) (("1" (assert) (("1" (lemma "pos_subterm") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "subterm_ext_commute") (("2" (inst -1 "p" "t" "sigma") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (subterm_ext_commute formula-decl nil substitution nil) (pos_o_term formula-decl nil subterm nil) (pos_subterm formula-decl nil subterm nil) (ext def-decl "term" substitution nil) (ext_preserv_pos formula-decl nil substitution nil)) shostak)) (rename_preserv_inclusion 0 (rename_preserv_inclusion-1 nil 3433013383 ("" (induct "t") (("1" (skosimp*) (("1" (rewrite "Vars_is_var") (("1" (expand* "subset?" "member" "Vars") (("1" (skosimp*) (("1" (inst -1 "vars(vars1_var!1)") (("1" (skolem-typepred) (("1" (typepred "p!1") (("1" (expand "ext" -1) (("1" (typepred "rho!1") (("1" (expand "Ren?") (("1" (flatten) (("1" (hide -3) (("1" (expand* "subset?" "member") (("1" (inst -2 "rho!1(vars(vars1_var!1))") (("1" (prop) (("1" (expand "V") (("1" (expand "positionsOF" -3) (("1" (assert) (("1" (expand "only_empty_seq") (("1" (replaces -3) (("1" (expand "subtermOF" -5) (("1" (rewrite "empty_0") (("1" (inst 1 "p!2") (("1" (lemma "subterm_ext_commute") (("1" (inst -1 "p!2" "s!1" "rho!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (rewrite "ext_preserv_pos") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "Ran" "member") (("2" (inst 1 "vars(vars1_var!1)") (("2" (expand "Dom") (("2" (prop) (("2" (inst 1 "p!2") (("1" (lemma "subterm_ext_commute") (("1" (inst -1 "p!2" "s!1" "rho!1") (("1" (assert) (("1" (replaces -6) (("1" (expand "ext" -1 2) (("1" (replaces -1) (("1" (hide-all-but (-3 -5 1)) (("1" (expand "positionsOF") (("1" (expand "only_empty_seq") (("1" (replaces -1) (("1" (expand* "subtermOF" "ext") (("1" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (rewrite "ext_preserv_pos") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "V") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "vars_term_is_union") (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (lemma "vars_term_is_union") (("2" (inst -1 "ext(rho!1)(app(app1_var!1, app2_var!1))") (("2" (lift-if) (("2" (prop) (("1" (expand "ext" -1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 -2)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (replaces -1) (("2" (expand* "subset?" "member") (("2" (skosimp*) (("2" (expand "IUnion" -3) (("2" (skosimp*) (("2" (inst -1 "i!1") (("1" (inst?) (("1" (prop) (("1" (inst -1 "x!1") (("1" (assert) (("1" (hide-all-but (-2 1)) (("1" (case-replace "args(ext(rho!1)(app(app1_var!1, app2_var!1)))`seq(i!1) = ext(rho!1)(app2_var!1`seq(i!1))") (("1" (hide (-1 2)) (("1" (expand "ext") (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (typepred "i!1") (("1" (grind) nil nil)) nil) ("2" (typepred "i!1") (("2" (grind) nil nil)) nil) ("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("1" (typepred "i!1") (("1" (grind) nil nil)) nil) ("2" (typepred "i!1") (("2" (grind) nil nil)) nil) ("3" (decompose-equality 2) (("1" (grind) nil nil) ("2" (decompose-equality 1) (("1" (grind) nil nil) ("2" (decompose-equality 1) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -2 "x!2") (("2" (prop) (("2" (expand "IUnion") (("2" (inst 1 "i!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2)) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_sequence type-eq-decl nil finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (term_app_extensionality formula-decl nil term_adt nil) (i!1 skolem-const-decl "below[length(args(ext(rho!1)(app(app1_var!1, app2_var!1))))]" substitution nil) (app2_var!1 skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var!1)}" substitution nil) (app1_var!1 skolem-const-decl "symbol" substitution nil) (rho!1 skolem-const-decl "Ren" substitution nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (< const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IUnion const-decl "set[T]" indexed_sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (vars_term_is_union formula-decl nil subterm nil) (member const-decl "bool" sets nil) (vars1_var!1 skolem-const-decl "variable" substitution nil) (only_empty_seq const-decl "positions" positions nil) (subtermOF def-decl "term" subterm nil) (rho!1 skolem-const-decl "Ren" substitution nil) (s!1 skolem-const-decl "term[variable, symbol, arity]" substitution nil) (p!2 skolem-const-decl "positions?[variable, symbol, arity](s!1)" substitution nil) (subterm_ext_commute formula-decl nil substitution nil) (ext_preserv_pos formula-decl nil substitution nil) (empty_0 formula-decl nil seq_extras structures) (finseq type-eq-decl nil finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (TRUE const-decl "bool" booleans nil) (Dom const-decl "set[(V)]" substitution nil) (Ran const-decl "set[term[variable, symbol, arity]]" substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (Vars_is_var formula-decl nil subterm nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (ext def-decl "term" substitution nil) (Vars const-decl "set[(V)]" subterm nil) (subset? const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Ren type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil)) shostak)) (same_substitution 0 (same_substitution-1 nil 3433013496 ("" (induct "t") (("1" (skosimp*) (("1" (expand "ext") (("1" (rewrite "Vars_is_var") (("1" (expand "member") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "ext" -2) (("2" (lift-if) (("2" (prop) (("1" (hide -2) (("1" (expand "member") (("1" (typepred "x!1") (("1" (expand "V") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality -1) (("2" (decompose-equality -1) (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (expand "Vars" -3) (("2" (skosimp*) (("2" (expand "subtermOF") (("2" (lift-if) (("2" (prop) (("1" (hide-all-but -2) (("1" (typepred "x!1") (("1" (expand "V") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (inst -2 "first(p!1) - 1") (("1" (inst -3 "first(p!1) - 1") (("1" (inst?) (("1" (assert) (("1" (inst?) (("1" (prop) (("1" (expand "Vars") (("1" (inst 1 "rest(p!1)") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((AND const-decl "[bool, bool -> bool]" booleans nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (< const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (app1_var!1 skolem-const-decl "symbol" substitution nil) (app2_var!1 skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var!1)}" substitution nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](app(app1_var!1, app2_var!1))" substitution nil) (rest const-decl "finseq" seq_extras structures) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (empty_seq const-decl "finseq" finite_sequences nil) (only_empty_seq const-decl "positions" positions nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (Vars_is_var formula-decl nil subterm nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (Vars const-decl "set[(V)]" subterm nil) (member const-decl "bool" sets nil) (ext def-decl "term" substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil)) shostak)) (same_term 0 (same_term-1 nil 3433013569 ("" (induct "t") (("1" (skosimp*) (("1" (expand "ext") (("1" (inst?) (("1" (assert) (("1" (expand "member") (("1" (rewrite "Vars_is_var") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "ext" 1) (("2" (lift-if) (("2" (prop) (("2" (decompose-equality 2) (("2" (decompose-equality 1) (("2" (expand "finseq_appl") (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (skosimp*) (("2" (inst?) (("2" (assert) (("2" (expand "member") (("2" (expand "Vars") (("2" (hide 2) (("2" (skosimp*) (("2" (inst 2 "add_first(x!1 + 1, p!1)") (("1" (expand "subtermOF" 2) (("1" (lift-if) (("1" (prop) (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (lemma "fsepn.rest_add_first") (("2" (inst -1 "p!1" "1 + x!1") (("2" (rewrite "first_add") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positionsOF") (("2" (expand "union") (("2" (prop) (("2" (hide 1) (("2" (expand "member") (("2" (expand "IUnion") (("2" (inst 1 "1 + x!1") (("2" (expand "catenate") (("2" (inst 1 "p!1") (("2" (expand "finseq_appl") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil nat_types nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (< const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (term_app_extensionality formula-decl nil term_adt nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (<= const-decl "bool" reals nil) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (union const-decl "set" sets nil) (subtermOF def-decl "term" subterm nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (insert? const-decl "finseq" seq_extras structures) (rest_add_first formula-decl nil seq_extras structures) (first_add formula-decl nil seq_extras structures) (int_minus_int_is_int application-judgement "int" integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (app1_var!1 skolem-const-decl "symbol" substitution nil) (app2_var!1 skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var!1)}" substitution nil) (add_first const-decl "finseq" seq_extras structures) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (x!1 skolem-const-decl "below[app2_var!1`length]" substitution nil) (positions? type-eq-decl nil positions nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](app2_var!1`seq(x!1))" substitution nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (Vars_is_var formula-decl nil subterm nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (ext def-decl "term" substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (Vars const-decl "set[(V)]" subterm nil) (member const-decl "bool" sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil)) shostak)) (term_is_a_var 0 (term_is_a_var-1 nil 3415014431 ("" (skosimp*) (("" (typepred "rho!1") (("" (hide -1) (("" (expand "Ren?") (("" (flatten) (("" (hide -2) (("" (expand* "subset?" "member" "V") (("" (inst -1 "t!1") (("" (assert) (("" (typepred "x!1") (("" (expand "V") (("" (expand "ext") (("" (lift-if) (("" (prop) (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Ren type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ext def-decl "term" substitution nil) (Ran const-decl "set[term[variable, symbol, arity]]" substitution nil) (Dom const-decl "set[(V)]" substitution nil) (/= const-decl "boolean" notequal nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) shostak)) (vars_term_rename 0 (vars_term_rename-1 nil 3415010657 ("" (skosimp*) (("" (expand "restrict") (("" (expand* "subset?" "member") (("" (skosimp*) (("" (expand "Vars" -2) (("" (skosimp*) (("" (lemma "rename_preserv_pos") (("" (inst?) (("" (typepred "p!1") (("" (decompose-equality -2) (("" (inst -1 "p!1") (("" (assert) (("" (hide -2) (("" (lemma "subterm_ext_commute") (("" (inst -1 "p!1" "t!1" "rho!1") (("" (assert) (("" (replaces -1) (("" (expand "positionsOF") (("" (lift-if) (("" (prop) (("1" (expand* "only_empty_seq" "subtermOF") (("1" (rewrite "empty_0") (("1" (assert) (("1" (expand "ext") (("1" (lemma "Vars_is_var") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (expand "Ran") (("1" (inst 1 "t!1") (("1" (expand "member") (("1" (decompose-equality -3) (("1" (inst -1 "t!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "only_empty_seq" "subtermOF") (("2" (rewrite "empty_0") (("2" (assert) (("2" (lemma "term_is_a_var") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand* "union" "member") (("3" (prop) (("1" (expand* "only_empty_seq" "subtermOF") (("1" (rewrite "empty_0") (("1" (assert) (("1" (lemma "term_is_a_var") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "IUnion") (("2" (skosimp*) (("2" (expand "catenate") (("2" (skosimp*) (("2" (expand "member") (("2" (expand "finseq_appl") (("2" (expand "subtermOF") (("2" (lift-if) (("2" (prop) (("1" (replaces -4) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (replace -3 -1) (("2" (rewrite "rest_add_first") (("2" (rewrite "first_add") (("2" (lemma "term_is_a_var") (("2" (inst?) (("2" (assert) (("2" (expand "Ran") (("2" (expand "ext" -2) (("2" (inst 4 "subtermOF(args(t!1)`seq(i!1 - 1), x!2)") (("2" (assert) (("2" (expand "member") (("2" (case "Vars(t!1)(subtermOF(args(t!1)`seq(i!1 - 1), x!2))") (("1" (decompose-equality -6) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide (-2 -5 5)) (("2" (expand* "Vars" "V") (("2" (inst 1 "p!1") (("2" (expand "subtermOF" 1 1) (("2" (expand "finseq_appl") (("2" (replace -3 1) (("2" (rewrite "rest_add_first") (("2" (rewrite "first_add") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((restrict const-decl "R" restrict nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Ren type-eq-decl nil substitution nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm_ext_commute formula-decl nil substitution nil) (finseq type-eq-decl nil finite_sequences nil) (empty_0 formula-decl nil seq_extras structures) (Dom const-decl "set[(V)]" substitution nil) (Ran const-decl "set[term[variable, symbol, arity]]" substitution nil) (Vars_is_var formula-decl nil subterm nil) (only_empty_seq const-decl "positions" positions nil) (subtermOF def-decl "term" subterm nil) (term_is_a_var formula-decl nil substitution nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (upto? nonempty-type-eq-decl nil IUnion_extra nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (finite_sequence type-eq-decl nil finite_sequences nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (<= const-decl "bool" reals nil) (rest_add_first formula-decl nil seq_extras structures) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (first_add formula-decl nil seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (insert? const-decl "finseq" seq_extras structures) (add_first const-decl "finseq" seq_extras structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (catenate const-decl "positions" positions nil) (IUnion const-decl "set[T]" indexed_sets nil) (union const-decl "set" sets nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (ext def-decl "term" substitution nil) (positions? type-eq-decl nil positions nil) (rename_preserv_pos formula-decl nil substitution nil) (Vars const-decl "set[(V)]" subterm nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil)) shostak)) (exists_renaming 0 (exists_renaming-1 nil 3414762942 ("" (measure-induct+ "card(V1)" "V1") (("" (skolem-typepred) (("" (typepred "x!1") (("" (case "card(x!1) = 0") (("1" (lemma "finite_sets[(V)].empty_card") (("1" (inst?) (("1" (assert) (("1" (hide (-3 -4 -5)) (("1" (inst 1 "identity") (("1" (splash 1) (("1" (case-replace " restrict[term[variable, symbol, arity], ((V[variable, symbol, arity])),
                                     boolean]
                                    (Ran(identity)) = emptyset") (("1" (lemma "intersection_empty") (("1" (inst -1 "V2!1") (("1" (expand "disjoint?") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (replace -1 -2 rl) (("2" (hide (-1 -3 2)) (("2" (decompose-equality 1) (("2" (expand "Ran") (("2" (expand "restrict") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality 1) (("2" (expand "Dom") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (rewrite "iden_subs") (("2" (rewrite "iden_rename") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "finite_sets[(V)].empty_card") (("2" (inst?) (("2" (assert) (("2" (lemma "sets_lemmas[(V)].choose_rest") (("2" (inst?) (("2" (assert) (("2" (inst -4 "rest(x!1)") (("2" (inst -4 "V2!1") (("2" (lemma "finite_sets[(V)].card_rest") (("2" (inst?) (("2" (assert) (("2" (skosimp*) (("2" (lemma "exists_var") (("2" (inst -1 "x!1" "union(Ran(rho!1), V2!1)") (("1" (skosimp*) (("1" (expand "member") (("1" (expand* "union" "member") (("1" (flatten) (("1" (expand "restrict" 2) (("1" (flatten) (("1" (expand "extend") (("1" (name-replace "y!1" "choose(x!1)") (("1" (case "y!1 /= z!1") (("1" (prop) (("1" (inst 7 "Rhop(rho!1, y!1, z!1)") (("1" (split) (("1" (hide -6) (("1" (lemma "Rhop_Dom") (("1" (inst?) (("1" (prop) (("1" (replace -6 -1) (("1" (rewrite "add_as_union") (("1" (assert) nil nil)) nil)) nil) ("2" (replace -6 -1) (("2" (hide-all-but (-1 6)) (("2" (expand* "rest" "y!1") (("2" (expand "remove") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "Rhop_Ran") (("2" (inst?) (("2" (prop) (("1" (replaces -1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skosimp*) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (flatten) (("1" (expand "restrict") (("1" (inst -9 "x!2") (("1" (assert) (("1" (case "x!2 = z!1") (("1" (assert) nil nil) ("2" (expand* "union" "member" "singleton") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6 -1) (("2" (hide-all-but (-1 6)) (("2" (expand* "rest" "y!1" "remove") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "Rhop_Subs") (("1" (rewrite "Rhop_Ren") (("1" (replace -6 -1) (("1" (hide-all-but (-1 6)) (("1" (expand "y!1") (("1" (expand "rest") (("1" (expand "remove") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6 -1) (("2" (hide-all-but (-1 6)) (("2" (expand* "rest" "y!1") (("2" (expand "remove") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (prop) (("2" (typepred "y!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-6 4)) (("2" (lemma "range_finite") (("2" (inst?) (("2" (lemma "restrict_set_props[term[variable, symbol, arity], ((V[variable, symbol, arity]))].restrict_finite") (("2" (inst?) (("2" (assert) (("2" (hide 2) (("2" (rewrite "finite_union") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (iden_subs formula-decl nil substitution nil) (iden_rename formula-decl nil substitution nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (intersection_empty formula-decl nil sets_lemmas nil) (finite_intersection2 application-judgement "finite_set[(V)]" substitution nil) (finite_intersection1 application-judgement "finite_set[term[variable, symbol, arity]]" substitution nil) (finite_extend application-judgement "finite_set[T]" extend_set_props nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[term[variable, symbol, arity]]" substitution nil) (finite_emptyset name-judgement "finite_set[(V)]" substitution nil) (empty? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (FALSE const-decl "bool" booleans nil) (extend const-decl "R" extend nil) (emptyset const-decl "set" sets nil) (identity const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (empty_card formula-decl nil finite_sets nil) (choose_rest formula-decl nil sets_lemmas nil) (union const-decl "set" sets nil) (rho!1 skolem-const-decl "Ren" substitution nil) (V2!1 skolem-const-decl "finite_set[(V)]" substitution nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (Rhop_Subs formula-decl nil substitution nil) (Rhop_Ren formula-decl nil substitution nil) (Rhop_Dom formula-decl nil substitution nil) (add_as_union formula-decl nil sets_lemmas nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[(V)]" substitution nil) (nonempty_singleton_finite application-judgement "non_empty_finite_set[term[variable, symbol, arity]]" substitution nil) (nonempty_finite_union2 application-judgement "non_empty_finite_set[(V)]" substitution nil) (int_minus_int_is_int application-judgement "int" integers nil) (remove const-decl "set" sets nil) (nonempty_union2 application-judgement "(nonempty?)" sets nil) (singleton const-decl "(singleton?)" sets nil) (Rhop_Ran formula-decl nil substitution nil) (z!1 skolem-const-decl "(V)" substitution nil) (y!1 skolem-const-decl "(x!1)" substitution nil) (x!1 skolem-const-decl "finite_set[(V)]" substitution nil) (Rhop const-decl "(V)" substitution nil) (/= const-decl "boolean" notequal nil) (range_finite formula-decl nil substitution nil) (restrict_finite formula-decl nil restrict_set_props nil) (finite_union judgement-tcc nil finite_sets nil) (exists_var formula-decl nil substitution nil) (nonempty_add_finite application-judgement "non_empty_finite_set[(V)]" substitution nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (card_rest formula-decl nil finite_sets nil) (rest const-decl "set" sets nil) (finite_rest application-judgement "finite_set[(V)]" substitution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Ran const-decl "set[term[variable, symbol, arity]]" substitution nil) (restrict const-decl "R" restrict nil) (disjoint? const-decl "bool" sets nil) (Dom const-decl "set[(V)]" substitution nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Ren type-eq-decl nil substitution nil) (Ren? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (add_parallel_pos 0 (add_parallel_pos-1 nil 3433013664 ("" (skosimp*) (("" (typepred "fst!1") (("" (expand "SPP?") (("" (flatten) (("" (rewrite "add_first_parallel_pos_to_PP_is_PP") (("" (hide -1) (("" (hide -2) (("" (expand "SP?") (("" (skosimp*) (("" (lemma "fspos.nth_add_first") (("" (inst?) (("" (inst?) (("1" (prop) (("1" (replaces -2) (("1" (typepred "p!1") (("1" (rewrite "ext_preserv_pos") nil nil)) nil)) nil) ("2" (replaces -1) (("2" (inst -1 "i!1 - 1") (("1" (rewrite "ext_preserv_pos") nil nil) ("2" (hide 3) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 2)) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SPP type-eq-decl nil positions nil) (SPP? const-decl "bool" positions nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (SP? const-decl "bool" positions nil) (nth_add_first formula-decl nil seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (add_first const-decl "finseq" seq_extras structures) (t!1 skolem-const-decl "term[variable, symbol, arity]" substitution nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](t!1)" substitution nil) (fst!1 skolem-const-decl "SPP[variable, symbol, arity](t!1)" substitution nil) (i!1 skolem-const-decl "below[length(add_first(p!1, fst!1))]" substitution nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (insert? const-decl "finseq" seq_extras structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (ext_preserv_pos formula-decl nil substitution nil) (int_minus_int_is_int application-judgement "int" integers nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (PP type-eq-decl nil positions nil) (PP? const-decl "bool" positions nil) (add_first_parallel_pos_to_PP_is_PP formula-decl nil positions nil)) shostak)) (ext_parallel_pos 0 (ext_parallel_pos-1 nil 3433013738 ("" (skosimp*) (("" (typepred "fst!1") (("" (expand "SPP?") (("" (flatten) (("" (assert) (("" (hide -1) (("" (expand "SP?") (("" (skosimp*) (("" (inst -1 "i!1") (("" (rewrite "ext_preserv_pos") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SPP type-eq-decl nil positions nil) (SPP? const-decl "bool" positions nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil substitution nil) (variable formal-nonempty-type-decl nil substitution nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (ext_preserv_pos formula-decl nil substitution nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (< const-decl "bool" reals nil) (SP? const-decl "bool" positions nil)) shostak)) (rest_parallel_first_TCC1 0 (rest_parallel_first_TCC1-1 nil 3433013782 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (term type-decl nil term_adt nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (SPP? const-decl "bool" positions nil) (SPP type-eq-decl nil positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (SP? const-decl "bool" positions nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rest const-decl "finseq" seq_extras structures) (< const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (rest_parallel_first subtype "0" "below[fst`length]"))) (rest_parallel_first 0 (rest_parallel_first-1 nil 3433013782 ("" (skolem 1 ("t" "fst")) (("" (flatten) (("" (case "length(rest(fst)) = 0") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (lemma "fspos.rest_pos") (("2" (inst -1 "fst") (("2" (assert) (("2" (inst -1 "i!1") (("1" (expand "finseq_appl") (("1" (typepred "fst") (("1" (expand* "SPP?" "PP?") (("1" (flatten) (("1" (hide -2) (("1" (prop) (("1" (grind) nil nil) ("2" (inst -1 "i!1 + 1" "0") (("1" (assert) (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil) ("2" (hide (-1 4)) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (i!1 skolem-const-decl "below[length(rest(fst))]" substitution nil) (fst skolem-const-decl "SPP[variable, symbol, arity](t)" substitution nil) (t skolem-const-decl "term[variable, symbol, arity]" substitution nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (PP? const-decl "bool" positions nil) (rest_pos formula-decl nil seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (parallel const-decl "bool" positions nil) (<= const-decl "bool" positions nil) (O const-decl "finseq" finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (^ const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (rest const-decl "finseq" seq_extras structures) (term type-decl nil term_adt nil) (SPP? const-decl "bool" positions nil) (SPP type-eq-decl nil positions nil)) shostak)) (rest_parallel_pos_parallel 0 (rest_parallel_pos_parallel-1 nil 3433013833 ("" (skolem 1 ("t" "fst" "p")) (("" (flatten) (("" (case "length(rest(fst)) = 0") (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (skosimp*) (("2" (lemma "fspos.rest_pos") (("2" (inst?) (("2" (assert) (("2" (inst -1 "i!1") (("1" (expand "finseq_appl") (("1" (inst -2 "i!1 + 1") (("1" (assert) nil nil) ("2" (hide (-1 3)) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (i!1 skolem-const-decl "below[length(rest(fst))]" substitution nil) (fst skolem-const-decl "SPP[variable, symbol, arity](t)" substitution nil) (t skolem-const-decl "term[variable, symbol, arity]" substitution nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (rest_pos formula-decl nil seq_extras structures) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (empty_seq const-decl "finseq" finite_sequences nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (<= const-decl "bool" positions nil) (parallel const-decl "bool" positions nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (rest const-decl "finseq" seq_extras structures) (term type-decl nil term_adt nil) (SPP? const-decl "bool" positions nil) (SPP type-eq-decl nil positions nil)) shostak)) (vars_subst_not_in 0 (vars_subst_not_in-1 nil 3457723991 ("" (induct "t") (("1" (skosimp*) (("1" (expand* "Dom" "member") (("1" (expand "Vars" -3) (("1" (skosimp*) (("1" (case "Dom(sigma!1)(vars(vars1_var!1))") (("1" (expand "Dom") (("1" (prop) (("1" (inst -1 "sigma!1(vars(vars1_var!1))") (("1" (prop) (("1" (expand "Vars") (("1" (inst 1 "p!1") (("1" (expand "ext") (("1" (propax) nil nil)) nil) ("2" (typepred "p!1") (("2" (expand "ext") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Ran") (("2" (expand "ext") (("2" (inst 1 "vars(vars1_var!1)") (("2" (expand "member") (("2" (expand "Dom") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Dom") (("2" (assert) (("2" (prop) (("2" (typepred "p!1") (("2" (expand "ext") (("2" (expand "positionsOF") (("2" (expand "only_empty_seq") (("2" (replaces -1) (("2" (expand "subtermOF") (("2" (lift-if) (("2" (prop) (("1" (inst -4 "sigma!1(vars(vars1_var!1))") (("1" (prop) (("1" (expand "Vars") (("1" (inst 1 "empty_seq") (("1" (expand "subtermOF") (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil) ("2" (expand "positionsOF") (("2" (expand "only_empty_seq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Ran") (("2" (inst 1 "x!1") (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (hide-all-but 1) (("2" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "V") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "member") (("2" (lemma "vars_term_is_union") (("2" (inst?) (("2" (lift-if) (("2" (prop) (("1" (expand "Vars" -6) (("1" (skosimp*) (("1" (hide -2) (("1" (expand "subtermOF" -5) (("1" (lift-if) (("1" (prop) (("1" (expand "ext" -2) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 -2)) (("1" (typepred "x!1") (("1" (expand "V") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (typepred "x!1") (("2" (expand "V") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (typepred "p!1") (("2" (expand "positionsOF") (("2" (lift-if) (("2" (prop) (("2" (expand "only_empty_seq") (("2" (rewrite "empty_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality -1) (("2" (inst -1 "x!1") (("2" (iff) (("2" (prop) (("2" (expand "IUnion") (("2" (skosimp*) (("2" (expand "finseq_appl") (("2" (inst -3 "i!1") (("1" (inst?) (("1" (assert) (("1" (prop) (("1" (case-replace "args(ext(sigma!1)(app(app1_var!1, app2_var!1)))`seq(i!1) = ext(sigma!1)(app2_var!1`seq(i!1))") (("1" (hide-all-but 1) (("1" (expand "ext" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "ext") (("1" (lift-if) (("1" (prop) (("1" (typepred "i!1") (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vars_term_is_union formula-decl nil subterm nil) (IUnion const-decl "set[T]" indexed_sets nil) (args adt-accessor-decl "[d: (app?) -> {args: finite_sequence[term] | args`length = arity(f(d))}]" term_adt nil) (f adt-accessor-decl "[(app?) -> symbol]" term_adt nil) (< const-decl "bool" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (i!1 skolem-const-decl "below[length(args(ext(sigma!1)(app(app1_var!1, app2_var!1))))]" substitution nil) (app2_var!1 skolem-const-decl "{args: finite_sequence[term[variable, symbol, arity]] |
   args`length = arity(app1_var!1)}" substitution nil) (app1_var!1 skolem-const-decl "symbol" substitution nil) (sigma!1 skolem-const-decl "Sub" substitution nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finite_sequence type-eq-decl nil finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (app? adt-recognizer-decl "[term -> boolean]" term_adt nil) (app adt-constructor-decl "[[f: symbol, {args: finite_sequence[term] | args`length = arity(f)}] ->
   (app?)]" term_adt nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (vars adt-constructor-decl "[variable -> (vars?)]" term_adt nil) (p!1 skolem-const-decl "positions?[variable, symbol, arity](ext(sigma!1)(vars(vars1_var!1)))" substitution nil) (positions? type-eq-decl nil positions nil) (vars1_var!1 skolem-const-decl "variable" substitution nil) (sigma!1 skolem-const-decl "Sub" substitution nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (TRUE const-decl "bool" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (empty_0 formula-decl nil seq_extras structures) (empty_seq const-decl "finseq" finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (subtermOF def-decl "term" subterm nil) (only_empty_seq const-decl "positions" positions nil) (term_induction formula-decl nil term_adt nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (ext def-decl "term" substitution nil) (Vars const-decl "set[(V)]" subterm nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (Ran const-decl "set[term[variable, symbol, arity]]" substitution nil) (Dom const-decl "set[(V)]" substitution nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil)) shostak)) (ext_preserve_symbol_TCC1 0 (ext_preserve_symbol_TCC1-1 nil 3512829487 ("" (skosimp) (("" (rewrite ext_preserv_pos) nil nil)) nil) ((ext_preserv_pos formula-decl nil substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil)) nil (ext_preserve_symbol subtype "substitution.p" "positions[substitution.variable, substitution.symbol, substitution.arity].positions?(substitution.ext(substitution.sig)(substitution.s))"))) (ext_preserve_symbol_TCC2 0 (ext_preserve_symbol_TCC2-1 nil 3512829487 ("" (skosimp) (("" (rewrite "subterm_ext_commute") (("" (expand ext) (("" (assert) (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((subterm_ext_commute formula-decl nil substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (ext def-decl "term" substitution nil)) nil (ext_preserve_symbol subtype "subterm[substitution.variable, substitution.symbol, substitution.arity].subtermOF(substitution.ext(substitution.sig)(substitution.s), substitution.p)" "(term_adt[substitution.variable, substitution.symbol, substitution.arity].app?)"))) (ext_preserve_symbol 0 (ext_preserve_symbol-1 nil 3512829488 ("" (skosimp*) (("" (rewrite "subterm_ext_commute") (("" (grind) nil nil)) nil)) nil) ((subterm_ext_commute formula-decl nil substitution nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil substitution nil) (symbol formal-nonempty-type-decl nil substitution nil) (arity formal-const-decl "[symbol -> nat]" substitution nil) (position type-eq-decl nil positions nil) (term type-decl nil term_adt nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (ext def-decl "term" substitution nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak)))
