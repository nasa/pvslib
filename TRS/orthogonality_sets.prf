(orthogonality_sets (IMP_orthogonality_basis_TCC1 0 (IMP_orthogonality_basis_TCC1-1 nil 3673558695 ("" (rewrite var_countable) nil nil) ((var_countable formula-decl nil orthogonality_sets nil)) nil (IMP_orthogonality_basis assuming "orthogonality_basis[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].orthogonality_basis" "var_countable: ASSUMPTION countability[term_adt[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].term].is_countably_infinite(variables_term[orthogonality_basis.variable, orthogonality_basis.symbol, orthogonality_basis.arity].V)"))) (Pos_Over_character 0 (Pos_Over_character-1 nil 3673303436 ("" (skosimp*) (("" (expand "Pos_Over") (("" (expand "set_of_prop_related_nb") (("" (expand "member") (("" (prop) (("" (expand "PP?" 2) (("" (expand "finseq_appl") (("" (prop) (("" (skosimp*) (("" (expand "parallel") (("" (prop) (("1" (expand "add_first") (("1" (expand "insert?") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (expand "finseq_appl") (("1" (prop) (("1" (assert) nil nil) ("2" (inst 5 "j!1 - 1") (("1" (assert) (("1" (prop) (("1" (inst 4 "fsp2!1`seq(j!1 - 1)") (("1" (prop) (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst?) nil nil)) nil)) nil) ("2" (expand "<=") (("2" (inst 1 "empty_seq") (("2" (rewrite "seq_o_empty") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (inst 4 "fsp2!1`seq(i!1 - 1)") (("1" (prop) (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("4" (expand "PP?") (("4" (prop) (("1" (assert) (("1" (hide (-3 5 6)) (("1" (typepred i!1 j!1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (inst -1 "i!1 - 1" "j!1 - 1") (("1" (assert) (("1" (expand "parallel") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "add_first") (("2" (expand "insert?") (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (expand "finseq_appl") (("2" (prop) (("1" (assert) nil nil) ("2" (inst 5 "i!1 - 1") (("1" (assert) (("1" (prop) (("1" (inst 4 "fsp2!1`seq(i!1 - 1)") (("1" (prop) (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst?) nil nil)) nil)) nil) ("2" (expand "<=") (("2" (inst 1 "empty_seq") (("2" (rewrite "seq_o_empty") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (inst 4 "fsp2!1`seq(j!1 - 1)") (("1" (prop) (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("4" (expand "PP?") (("4" (prop) (("1" (hide (-3 5 6)) (("1" (typepred i!1 j!1) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (inst -1 "j!1 - 1" "i!1 - 1") (("1" (assert) (("1" (expand "parallel") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (member const-decl "bool" sets nil) (PP? const-decl "bool" positions nil) (parallel const-decl "bool" positions nil) (O const-decl "finseq" finite_sequences nil) (add_first const-decl "finseq" seq_extras structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (<= const-decl "bool" positions nil) (seq_o_empty formula-decl nil seq_extras structures) (empty_seq const-decl "finseq" finite_sequences nil) (seq2set const-decl "finite_set[T]" seq2set structures) (below type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (p!1 skolem-const-decl "position[variable, symbol, arity]" orthogonality_sets nil) (fsp2!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (j!1 skolem-const-decl "below[add_first(p!1, fsp2!1)`length]" orthogonality_sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (i!1 skolem-const-decl "below[add_first(p!1, fsp2!1)`length]" orthogonality_sets nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (insert? const-decl "finseq" seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (set_of_prop_related_nb const-decl "set[T]" predicate_fseq2set nil)) shostak)) (pos_up_in_Pos_Over 0 (pos_up_in_Pos_Over-1 nil 3673111928 ("" (skosimp*) (("" (expand "Pos_Over") (("" (expand "set_of_prop_related_nb") (("" (expand "member") (("" (assert) (("" (skosimp) (("" (expand "seq2set") (("" (expand "finseq_appl") (("" (skosimp*) (("" (expand "<=") (("" (skosimp) (("" (expand "PP?") (("" (expand "finseq_appl") (("" (prop) (("1" (case "fsp2!1`length = 0") (("1" (typepred kk!2) (("1" (hide-all-but (-1 -2)) (("1" (assert) nil nil)) nil)) nil) ("2" (case "fsp2!1`length = 1") (("1" (case-replace "kk!2 = kk!3") (("1" (replaces -6) (("1" (hide (-1 -2 -3 -4)) (("1" (replaces -1) (("1" (lemma equal_prefix[posnat]) (("1" (inst -1 "p1!1" "empty_seq" "p2!1 o p1!2") (("1" (rewrite seq_o_empty) (("1" (assert) (("1" (rewrite "o_assoc") (("1" (assert) (("1" (lemma seq_empty[posnat]) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (typepred kk!2 kk!3) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (inst -1 kk!2 kk!3) (("2" (prop) (("1" (expand "parallel") (("1" (prop) (("1" (expand "<=") (("1" (replaces -4) (("1" (replaces -3) (("1" (hide 1) (("1" (inst 1 "p1!2 o p2!1") (("1" (rewrite "o_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1) (("2" (replaces -3) (("2" (replaces -2) (("2" (hide (-1 1)) (("2" (lemma equal_prefix[posnat]) (("2" (inst -1 "p1!1" "empty_seq" "p2!1 o p1!2") (("2" (rewrite seq_o_empty) (("2" (assert) (("2" (rewrite "o_assoc") (("2" (assert) (("2" (lemma seq_empty[posnat]) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (member const-decl "bool" sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (<= const-decl "bool" positions nil) (PP? const-decl "bool" positions nil) (TRUE const-decl "bool" booleans nil) (O const-decl "finseq" finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (seq_empty formula-decl nil seq_extras structures) (o_assoc formula-decl nil finite_sequences nil) (seq_o_empty formula-decl nil seq_extras structures) (equal_prefix formula-decl nil seq_extras structures) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (parallel const-decl "bool" positions nil) (seq2set const-decl "finite_set[T]" seq2set structures) (set_of_prop_related_nb const-decl "set[T]" predicate_fseq2set nil)) shostak)) (union_positions 0 (union_positions-1 nil 3673120661 ("" (skosimp) (("" (decompose-equality) (("" (iff) (("" (prop) (("1" (expand* "union" "member") (("1" (flatten) (("1" (case "seq2set(fsp2!1)(x!1)") (("1" (expand "Pos_Equal") (("1" (expand "intersection") (("1" (expand "intersection") (("1" (expand "member") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Pos_Over") (("2" (expand "set_of_prop_related_nb") (("2" (expand "member") (("2" (prop) (("2" (skosimp) (("2" (expand "Pos_Under") (("2" (expand "set_of_prop_related_b") (("2" (expand "member") (("2" (assert) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "set_of_prop_related_b_is_subset[position]") (("2" (inst -1 "<=" "fsp1!1" "fsp2!1") (("2" (lemma "set_of_prop_related_nb_is_subset[position]") (("2" (inst -1 "<=" "fsp1!1" "fsp2!1") (("2" (expand "Pos_Over") (("2" (expand "Pos_Equal") (("2" (expand "Pos_Under") (("2" (lemma "union_upper_bound[position]") (("2" (inst-cp -1 "intersection(fsp1!1, fsp2!1)" "set_of_prop_related_b(<=)(fsp1!1, fsp2!1)" "seq2set(fsp1!1)") (("2" (assert) (("2" (inst -1 "set_of_prop_related_nb(<=)(fsp1!1, fsp2!1)" "union(intersection(fsp1!1, fsp2!1), set_of_prop_related_b(<=)(fsp1!1, fsp2!1))" "seq2set(fsp1!1)") (("2" (assert) (("2" (split) (("1" (hide (-2 -3 -4)) (("1" (expand "subset?") (("1" (expand "member") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but 2) (("2" (expand "subset?") (("2" (expand "member") (("2" (skosimp) (("2" (expand "intersection") (("2" (expand "intersection") (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_sequence type-eq-decl nil finite_sequences nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (finseq type-eq-decl nil finite_sequences nil) (union const-decl "set" sets nil) (Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (Pos_Equal const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (Pos_Under const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (set type-eq-decl nil sets nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set_of_prop_related_b const-decl "set[T]" predicate_fseq2set nil) (set_of_prop_related_nb const-decl "set[T]" predicate_fseq2set nil) (intersection const-decl "set" sets nil) (intersection const-decl "set[T]" predicate_fseq2set nil) (member const-decl "bool" sets nil) (<= const-decl "bool" positions nil) (PRED type-eq-decl nil defined_types nil) (union_upper_bound formula-decl nil sets_lemmas nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subset? const-decl "bool" sets nil) (set_of_prop_related_nb_is_subset formula-decl nil predicate_fseq2set nil) (set_of_prop_related_b_is_subset formula-decl nil predicate_fseq2set nil)) shostak)) (Pos_Over_and_Pos_Equal_is_PP_TCC1 0 (Pos_Over_and_Pos_Equal_is_PP_TCC1-1 nil 3673274463 ("" (skosimp) (("" (rewrite "finite_union") (("1" (hide 2) (("1" (rewrite "finite_union") (("1" (hide 2) (("1" (expand "Pos_Equal") (("1" (expand "intersection") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "Pos_Over") (("2" (rewrite set_of_prop_related_nb_is_finite) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "Pos_Over") (("2" (rewrite set_of_prop_related_nb_is_finite) nil nil)) nil)) nil)) nil)) nil) ((finite_union judgement-tcc nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (finseq type-eq-decl nil finite_sequences nil) (Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (union const-decl "set" sets nil) (Pos_Equal const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (position type-eq-decl nil positions nil) (intersection const-decl "set[T]" predicate_fseq2set nil) (finite_intersection2 application-judgement "finite_set[position[variable, symbol, arity]]" orthogonality_sets nil) (set_of_prop_related_nb_is_finite formula-decl nil predicate_fseq2set nil) (PRED type-eq-decl nil defined_types nil) (<= const-decl "bool" positions nil)) nil (Pos_Over_and_Pos_Equal_is_PP subtype "sets[position[variable, symbol, arity]].union(orthogonality_sets.Pos_Over(orthogonality_sets.fsp1, orthogonality_sets.fsp2), sets[position[variable, symbol, arity]].union(orthogonality_sets.Pos_Over(orthogonality_sets.fsp2, orthogonality_sets.fsp1), orthogonality_sets.Pos_Equal(orthogonality_sets.fsp1, orthogonality_sets.fsp2)))" "finite_set[position[variable, symbol, arity]]"))) (Pos_Over_and_Pos_Equal_is_PP 0 (Pos_Over_and_Pos_Equal_is_PP-1 nil 3673274465 ("" (skeep) (("" (expand PP? 1) (("" (expand finseq_appl) (("" (prop) (("" (skeep 2) (("" (name-replace "A" "union(Pos_Over(fsp1, fsp2), union(Pos_Over(fsp2, fsp1),Pos_Equal(fsp1, fsp2)))") (("" (lemma "set2seq_lem[position]") (("" (inst?) (("" (assert) (("" (expand finseq_appl) (("" (inst-cp -1 "i") (("1" (inst -1 "j") (("1" (expand "A" -1 1) (("1" (expand "A" -2 1) (("1" (expand* "union" "member") (("1" (prop) (("1" (expand "Pos_Over") (("1" (lemma set_of_prop_related_nb_is_subset[position]) (("1" (inst -1 "<=" "fsp1" "fsp2") (("1" (expand* "subset?" "member") (("1" (inst-cp -1 "set2seq(A)`seq(i)") (("1" (inst -1 "set2seq(A)`seq(j)") (("1" (assert) (("1" (hide (-3 -4 -6)) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp*) (("1" (expand PP?) (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide (1 3)) (("1" (typepred "kk!1" "kk!2") (("1" (case "fsp1`length = 0") (("1" (hide (-5 -6)) (("1" (grind) nil nil)) nil) ("2" (lemma set2seq_neq[position]) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (inst -1 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "kk!2" "kk!1") (("2" (assert) (("2" (hide 5) (("2" (prop) (("2" (replaces -1) (("2" (lemma set2seq_neq[position]) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (inst -1 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma set_of_prop_related_nb_is_subset[position]) (("2" (inst-cp -1 "<=" "fsp2" "fsp1") (("2" (inst -1 "<=" "fsp1" "fsp2") (("2" (expand* "subset?" "member" "Pos_Over") (("2" (inst -1 "set2seq(A)`seq(j)") (("2" (inst -2 "set2seq(A)`seq(i)") (("2" (assert) (("2" (expand* "seq2set" "finseq_appl") (("2" (skosimp*) (("2" (expand "set_of_prop_related_nb") (("2" (expand "member") (("2" (expand "parallel") (("2" (prop) (("1" (hide (-4 -5 1 3)) (("1" (inst 1 "fsp2`seq(kk!2)") (("1" (assert) nil nil)) nil)) nil) ("2" (hide (-4 -5 2 3)) (("2" (inst 1 "fsp1`seq(kk!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand* Pos_Equal Pos_Over) (("3" (expand "intersection") (("3" (expand "intersection") (("3" (expand "member") (("3" (flatten) (("3" (lemma set_of_prop_related_nb_is_subset[position]) (("3" (inst -1 "<=" "fsp1" "fsp2") (("3" (expand* "subset?" "member") (("3" (inst -1 "set2seq(A)`seq(j)") (("3" (assert) (("3" (hide (-3 -4 -6)) (("3" (expand* "seq2set" "finseq_appl") (("3" (skosimp*) (("3" (expand PP?) (("3" (expand "finseq_appl") (("3" (prop) (("1" (hide (1 3)) (("1" (typepred "kk!1" "kk!2") (("1" (case "fsp1`length = 0") (("1" (hide (-5 -6)) (("1" (grind) nil nil)) nil) ("2" (lemma set2seq_neq[position]) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (inst -1 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "kk!2" "kk!1") (("2" (assert) (("2" (hide 5) (("2" (prop) (("2" (replaces -1) (("2" (lemma set2seq_neq[position]) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (inst -1 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma set_of_prop_related_nb_is_subset[position]) (("4" (inst-cp -1 "<=" "fsp2" "fsp1") (("4" (inst -1 "<=" "fsp1" "fsp2") (("4" (expand* "subset?" "member" "Pos_Over") (("4" (inst -2 "set2seq(A)`seq(j)") (("4" (inst -1 "set2seq(A)`seq(i)") (("4" (assert) (("4" (expand* "seq2set" "finseq_appl") (("4" (skosimp*) (("4" (expand "set_of_prop_related_nb") (("4" (expand "member") (("4" (expand "parallel") (("4" (prop) (("1" (hide (-4 -5 1 3)) (("1" (inst 1 "fsp1`seq(kk!1)") (("1" (assert) nil nil)) nil)) nil) ("2" (hide (-4 -5 2 3)) (("2" (inst 1 "fsp2`seq(kk!2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "Pos_Over") (("5" (lemma set_of_prop_related_nb_is_subset[position]) (("5" (inst -1 "<=" "fsp2" "fsp1") (("5" (expand* "subset?" "member") (("5" (inst-cp -1 "set2seq(A)`seq(i)") (("5" (inst -1 "set2seq(A)`seq(j)") (("5" (assert) (("5" (hide (-3 -4 -5)) (("5" (expand* "seq2set" "finseq_appl") (("5" (skosimp*) (("5" (expand PP?) (("5" (expand "finseq_appl") (("5" (prop) (("1" (hide (1 3)) (("1" (typepred "kk!1" "kk!2") (("1" (case "fsp2`length = 0") (("1" (hide (-5 -6)) (("1" (grind) nil nil)) nil) ("2" (lemma set2seq_neq[position]) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (inst -1 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "kk!2" "kk!1") (("2" (assert) (("2" (hide 5) (("2" (prop) (("2" (replaces -1) (("2" (lemma set2seq_neq[position]) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (inst -1 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand* Pos_Equal Pos_Over) (("6" (expand "intersection") (("6" (expand "intersection") (("6" (expand "member") (("6" (flatten) (("6" (lemma set_of_prop_related_nb_is_subset[position]) (("6" (inst -1 "<=" "fsp2" "fsp1") (("6" (expand* "subset?" "member") (("6" (inst -1 "set2seq(A)`seq(j)") (("6" (assert) (("6" (hide (-2 -4 -5)) (("6" (expand* "seq2set" "finseq_appl") (("6" (skosimp*) (("6" (expand PP?) (("6" (expand "finseq_appl") (("6" (prop) (("1" (hide (1 3)) (("1" (typepred "kk!1" "kk!2") (("1" (case "fsp2`length = 0") (("1" (hide (-5 -6)) (("1" (grind) nil nil)) nil) ("2" (lemma set2seq_neq[position]) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (inst -1 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "kk!2" "kk!1") (("2" (assert) (("2" (hide 5) (("2" (prop) (("2" (replaces -1) (("2" (lemma set2seq_neq[position]) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (inst -1 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand* Pos_Equal Pos_Over) (("7" (expand "intersection") (("7" (expand "intersection") (("7" (expand "member") (("7" (flatten) (("7" (lemma set_of_prop_related_nb_is_subset[position]) (("7" (inst -1 "<=" "fsp1" "fsp2") (("7" (expand* "subset?" "member") (("7" (inst -1 "set2seq(A)`seq(i)") (("7" (assert) (("7" (hide (-2 -4 -6)) (("7" (expand* "seq2set" "finseq_appl") (("7" (skosimp*) (("7" (expand PP?) (("7" (expand "finseq_appl") (("7" (prop) (("1" (hide (1 3)) (("1" (typepred "kk!1" "kk!2") (("1" (case "fsp1`length = 0") (("1" (hide (-5 -6)) (("1" (grind) nil nil)) nil) ("2" (lemma set2seq_neq[position]) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (inst -1 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "kk!1" "kk!2") (("2" (assert) (("2" (hide 5) (("2" (prop) (("2" (replaces -1) (("2" (lemma set2seq_neq[position]) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (inst -1 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (expand* Pos_Equal Pos_Over) (("8" (expand "intersection") (("8" (expand "intersection") (("8" (expand "member") (("8" (flatten) (("8" (lemma set_of_prop_related_nb_is_subset[position]) (("8" (inst -1 "<=" "fsp2" "fsp1") (("8" (expand* "subset?" "member") (("8" (inst -1 "set2seq(A)`seq(i)") (("8" (assert) (("8" (hide (-2 -3 -5)) (("8" (expand* "seq2set" "finseq_appl") (("8" (skosimp*) (("8" (expand PP?) (("8" (expand "finseq_appl") (("8" (prop) (("1" (hide (1 3)) (("1" (typepred "kk!1" "kk!2") (("1" (case "fsp2`length = 0") (("1" (hide (-5 -6)) (("1" (grind) nil nil)) nil) ("2" (lemma set2seq_neq[position]) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (inst -1 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "kk!1" "kk!2") (("2" (assert) (("2" (hide 5) (("2" (prop) (("2" (replaces -1) (("2" (lemma set2seq_neq[position]) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (inst -1 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("9" (expand "Pos_Equal") (("9" (expand "intersection") (("9" (expand "intersection") (("9" (expand "member") (("9" (flatten) (("9" (hide (-2 -4 -6 1)) (("9" (expand* "seq2set" "finseq_appl") (("9" (skosimp*) (("9" (expand PP?) (("9" (expand "finseq_appl") (("9" (prop) (("1" (hide 2) (("1" (typepred "kk!1" "kk!2") (("1" (case "fsp1`length = 0") (("1" (hide (-5 -6)) (("1" (grind) nil nil)) nil) ("2" (lemma set2seq_neq[position]) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (inst -1 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "kk!1" "kk!2") (("2" (assert) (("2" (hide 4) (("2" (prop) (("2" (replaces -1) (("2" (lemma set2seq_neq[position]) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (inst -1 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "j") (("2" (expand "A") (("2" (rewrite "set2seq_length") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i") (("2" (expand "A") (("2" (rewrite "set2seq_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PP? const-decl "bool" positions nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (position type-eq-decl nil positions nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (union const-decl "set" sets nil) (finseq type-eq-decl nil finite_sequences nil) (Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (Pos_Equal const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (j skolem-const-decl "below[set2seq(union(Pos_Over(fsp1, fsp2),
                    union(Pos_Over(fsp2, fsp1),
                          Pos_Equal(fsp1, fsp2))))`length]" orthogonality_sets nil) (set_of_prop_related_nb_is_subset formula-decl nil predicate_fseq2set nil) (subset? const-decl "bool" sets nil) (TRUE const-decl "bool" booleans nil) (set2seq_neq formula-decl nil set2seq structures) (NOT const-decl "[bool -> bool]" booleans nil) (seq2set const-decl "finite_set[T]" seq2set structures) (PRED type-eq-decl nil defined_types nil) (<= const-decl "bool" positions nil) (set_of_prop_related_nb const-decl "set[T]" predicate_fseq2set nil) (parallel const-decl "bool" positions nil) (intersection const-decl "set[T]" predicate_fseq2set nil) (intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (finite_sequence type-eq-decl nil finite_sequences nil) (set2seq def-decl "finite_sequence[T]" set2seq structures) (fsp1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (fsp2 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (i skolem-const-decl "below[set2seq(union(Pos_Over(fsp1, fsp2),
                    union(Pos_Over(fsp2, fsp1),
                          Pos_Equal(fsp1, fsp2))))`length]" orthogonality_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (A skolem-const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (set2seq_length formula-decl nil set2seq structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (set2seq_lem formula-decl nil set2seq structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak)) (Pos_Over_and_Pos_Equal_dominance 0 (Pos_Over_and_Pos_Equal_dominance-1 nil 3673279986 ("" (expand "dominates?") (("" (skeep) (("" (skeep) (("" (expand* "seq2set" "finseq_appl") (("" (skolem -3 "i") (("" (typepred i) (("" (lemma union_positions) (("" (inst -1 fsp1 fsp2) (("" (assert) (("" (case "seq2set(fsp1)(fsp1`seq(i))") (("1" (replaces -2) (("1" (expand* "union" "member") (("1" (split) (("1" (inst 1 "fsp1`seq(i)") (("1" (assert) (("1" (expand <=) (("1" (inst 1 empty_seq) (("1" (rewrite seq_o_empty) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "fsp1`seq(i)") (("2" (assert) (("2" (expand <=) (("2" (inst 1 empty_seq) (("2" (rewrite seq_o_empty) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "Pos_Under") (("3" (lemma set_of_prop_related_b_character[position]) (("3" (expand finseq_appl) (("3" (inst -1 "<=" "fsp1`seq(i)" "fsp1" "fsp2") (("3" (assert) (("3" (skolem -1 j) (("3" (expand "set_of_prop_related") (("3" (expand "member") (("3" (flatten) (("3" (expand <= -2) (("3" (skosimp) (("3" (lemma pos_up_in_Pos_Over) (("3" (inst -1 fsp2 fsp1 "fsp2`seq(j)" "p1!1") (("3" (prop) (("1" (inst 2 "fsp2`seq(j)") (("1" (assert) (("1" (hide-all-but (-2 -8 2)) (("1" (expand <=) (("1" (inst 1 p1!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite empty_0) (("2" (replaces -1) (("2" (rewrite seq_o_empty) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand* "seq2set" "finseq_appl") (("3" (inst?) nil nil)) nil)) nil) ("4" (hide-all-but (-2 1)) (("4" (expand* "seq2set" "finseq_appl") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "seq2set" "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (seq2set const-decl "finite_set[T]" seq2set structures) (below type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finite_sequence type-eq-decl nil finite_sequences nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (Pos_Under const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (set_of_prop_related const-decl "set[T]" predicate_fseq2set nil) (empty_0 formula-decl nil seq_extras structures) (pos_up_in_Pos_Over formula-decl nil orthogonality_sets nil) (PRED type-eq-decl nil defined_types nil) (set_of_prop_related_b_character formula-decl nil predicate_fseq2set nil) (<= const-decl "bool" positions nil) (seq_o_empty formula-decl nil seq_extras structures) (empty_seq const-decl "finseq" finite_sequences nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (union_positions formula-decl nil orthogonality_sets nil) (dominates? const-decl "bool" predicate_fseq2set nil)) shostak)) (fork_in_Pos_Over_aux_TCC1 0 (fork_in_Pos_Over_aux_TCC1-2 "" 3790334198 ("" (skosimp) (("" (expand parallel_reduction_fix?) (("" (skosimp) (("" (lemma Pos_Over_character) (("" (inst -1 "#(p!1)" "fsp2!1" "p!1") (("" (assert) (("" (split) (("1" (lemma replace_par_pos_preservs_pos) (("1" (inst -1 fsp2!1 "sigma_rhs(fss!1, fse!1)" p!1 t!1) (("1" (expand SPP?) (("1" (expand sigma_rhs 1) (("1" (expand empty_seq) (("1" (prop) (("1" (rewrite add_first_parallel_pos_to_SP_is_SP) nil nil) ("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (lemma replace_par_pos_preservs_PP) (("2" (inst -1 fsp2!1 "sigma_rhs(fss!1, fse!1)" t!1) (("2" (expand sigma_rhs -1 1) (("2" (expand* SPP? finseq_appl) (("2" (inst -1 i!1) (("2" (lemma closed_positions) (("2" (inst -1 p!1 "fsp2!1`seq(i!1)" t2!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand* SPP? finseq_appl) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (Pos_Over_character formula-decl nil orthogonality_sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (closed_positions formula-decl nil positions nil) (< const-decl "bool" reals nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (SPP? const-decl "bool" positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (SP type-eq-decl nil positions nil) (SP? const-decl "bool" positions nil) (add_first_parallel_pos_to_SP_is_SP formula-decl nil positions nil) (subset? const-decl "bool" predicate_fseq2set nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (= const-decl "[T, T -> boolean]" equalities nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak (fork_in_Pos_Over_aux subtype "orthogonality_sets.p" "positions[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].positions?(orthogonality_sets.t2)")) (fork_in_Pos_Over_aux_TCC1-1 nil 3673282463 ("" (skosimp) (("" (expand parallel_reduction_fix?) (("" (skosimp) (("" (lemma Pos_Over_character) (("" (inst -1 "#(p!1)" "fsp2!1" "p!1") (("" (assert) (("" (split) (("1" (lemma replace_par_pos_preservs_pos) (("1" (inst -1 fsp2!1 "sigma_rhs(fss!1, fse!1)" p!1 t!1) (("1" (expand SPP?) (("1" (expand sigma_rhs 1) (("1" (expand empty_seq) (("1" (prop) (("1" (rewrite add_first_parallel_pos_to_SP_is_SP) nil nil) ("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (lemma replace_par_pos_preservs_PP) (("2" (inst -1 fsp2!1 "sigma_rhs(fss!1, fse!1)" t!1) (("2" (expand sigma_rhs -1 1) (("2" (expand* SPP? finseq_appl) (("2" (inst -1 i!1) (("2" (replace -8 -1 rl) (("2" (lemma closed_positions) (("2" (inst -1 p!1 "fsp2!1`seq(i!1)" t2!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand* SPP? finseq_appl) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (Pos_Over_character formula-decl nil orthogonality_sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (closed_positions formula-decl nil positions nil) (< const-decl "bool" reals nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (SPP? const-decl "bool" positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (SP type-eq-decl nil positions nil) (SP? const-decl "bool" positions nil) (add_first_parallel_pos_to_SP_is_SP formula-decl nil positions nil) (subset? const-decl "bool" predicate_fseq2set nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (= const-decl "[T, T -> boolean]" equalities nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (fork_in_Pos_Over_aux subtype "orthogonality_sets.p" "positions[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].positions?(orthogonality_sets.t2)"))) (fork_in_Pos_Over_aux_TCC2 0 (fork_in_Pos_Over_aux_TCC2-2 "" 3803876293 ("" (skosimp) (("" (expand SPP?) (("" (rewrite complement_pos_is_PP) (("" (flatten) (("" (expand* SP? finseq_appl) (("" (skosimp) (("" (lemma complement_pos_character) (("" (inst -1 fsp2!1 p!1 "complement_pos(p!1, fsp2!1)`seq(i!1)") (("" (prop) (("1" (skosimp) (("1" (inst -6 i!2) (("1" (rewrite pos_subterm_ax) nil nil)) nil)) nil) ("2" (expand* "seq2set" "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (fork_in_Pos_Over_aux subtype "orthogonality_basis[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].complement_pos(orthogonality_sets.p, orthogonality_sets.fsp2)" "positions[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].SPP(subterm[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].subtermOF(orthogonality_sets.t, orthogonality_sets.p))")) (fork_in_Pos_Over_aux_TCC2-1 nil 3673282463 ("" (skosimp) (("" (expand SPP?) (("" (rewrite complement_pos_is_PP) (("" (flatten) (("" (expand* SP? finseq_appl) (("" (skosimp) (("" (lemma complement_pos_character) (("" (inst -1 fsp2!1 p!1 "complement_pos(p!1, fsp2!1)`seq(i!1)") (("" (prop) (("1" (skosimp) (("1" (inst -3 i!2) (("1" (rewrite pos_subterm_ax) nil nil)) nil)) nil) ("2" (expand* "seq2set" "finseq_appl") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SPP? const-decl "bool" positions nil) (< const-decl "bool" reals nil) (complement_pos def-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (seq2set const-decl "finite_set[T]" seq2set structures) (below type-eq-decl nil naturalnumbers nil) (term type-decl nil term_adt nil) (pos_subterm_ax formula-decl nil subterm nil) (complement_pos_character formula-decl nil orthogonality_basis nil) (SP? const-decl "bool" positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (complement_pos_is_PP formula-decl nil orthogonality_basis nil)) nil (fork_in_Pos_Over_aux subtype "orthogonality_basis[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].complement_pos(orthogonality_sets.p, orthogonality_sets.fsp2)" "positions[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].SPP(subterm[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].subtermOF(orthogonality_sets.t, orthogonality_sets.p))"))) (fork_in_Pos_Over_aux 0 (fork_in_Pos_Over_aux-1 nil 3673282473 ("" (measure-induct "fsp2`length" fsp2) (("1" (skeep) (("1" (skeep) (("1" (case "x`length=0") (("1" (hide -2) (("1" (expand complement_pos) (("1" (expand empty_seq) (("1" (assert) (("1" (expand parallel_reduction_fix?) (("1" (inst 1 empty_seq empty_seq) (("1" (expand empty_seq) (("1" (skosimp) (("1" (expand replace_par_pos) (("1" (assert) (("1" (expand subtermsOF 1) (("1" (expand sigma_lhs 1) (("1" (expand empty_seq) (("1" (decompose-equality 1) (("1" (skeep) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand subset?) (("2" (expand* "subset?" "member") (("2" (skeep) (("2" (expand "seq2set") (("2" (expand "finseq_appl") (("2" (skeep) (("2" (typepred "kk") (("2" (expand empty_seq) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand parallel_reduction_fix? -3) (("2" (skosimp) (("2" (expand* replace_par_pos finseq_appl) (("2" (assert) (("2" (inst -1 "rest(x)") (("2" (rewrite length_rest) (("2" (inst -1 E p "replaceTerm(t, sigma_rhs(fss!1, fse!1)`seq(0),
                                                           x`seq(0))" t2) (("2" (expand SPP?) (("2" (rewrite rest_of_PP_is_PP) (("2" (flatten) (("2" (prop) (("1" (expand complement_pos 2) (("1" (lift-if) (("1" (prop) (("1" (expand parallel_reduction_fix?) (("1" (skosimp) (("1" (inst 1 "add_first(fse!1`seq(0), fse!2)" "add_first(fss!1`seq(0), fss!2)") (("1" (expand add_first 1 (1 2 3 4)) (("1" (expand insert?) (("1" (assert) (("1" (prop) (("1" (expand* add_first insert? finseq_appl) (("1" (expand subtermsOF 1) (("1" (expand sigma_lhs 1) (("1" (expand finseq_appl) (("1" (decompose-equality) (("1" (lift-if) (("1" (prop) (("1" (expand subtermsOF -11) (("1" (expand sigma_lhs -11) (("1" (expand finseq_appl) (("1" (decompose-equality -11) (("1" (inst -1 0) (("1" (typepred "choose(complement_pos_set(<=, o)(p, x`seq(0)))") (("1" (expand complement_pos_set -1 1) (("1" (expand emptyset) (("1" (prop) (("1" (replace -3 2 rl) (("1" (lemma pos_subterm) (("1" (inst -1 p "choose(complement_pos_set(<=, o)(p, x`seq(0)))" t) (("1" (expand* SP? finseq_appl) (("1" (inst -12 0) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* SP? finseq_appl) (("2" (inst -10 x1!1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma complement_pos_character) (("2" (inst -1 "rest(x)" p "complement_pos(p, rest(x))`seq(x!1 - 1)") (("1" (prop) (("1" (skosimp) (("1" (typepred i!1) (("1" (expand rest -1) (("1" (expand rest -2 1) (("1" (expand* ^ min empty_seq) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (expand subtermsOF -6) (("1" (expand sigma_lhs -6) (("1" (expand finseq_appl) (("1" (decompose-equality -6) (("1" (inst -1 "x!1 - 1") (("1" (replace -1 6 rl) (("1" (hide -1 -7) (("1" (lemma pos_subterm) (("1" (inst-cp -1 p "complement_pos(p, rest(x))`seq(x!1 - 1)" "replaceTerm(t,
                                                                                                               sigma_rhs(fss!1, fse!1)`seq(0),
                                                                                                               x`seq(0))") (("1" (prop) (("1" (inst -2 p "complement_pos(p, rest(x))`seq(x!1 - 1)" t) (("1" (prop) (("1" (replace -1 6 rl) (("1" (replace -2 6 rl) (("1" (hide -1 -2) (("1" (replace -1 6 rl) (("1" (lemma replace_persistence) (("1" (inst -1 "x`seq(0)" "x`seq(1+i!1)" t "sigma_rhs(fss!1, fse!1)`seq(0)") (("1" (expand* SP? PP? finseq_appl) (("1" (inst-cp -8 1+i!1) (("1" (inst -8 0) (("1" (assert) (("1" (inst -6 0 1+i!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* SP? finseq_appl) (("2" (inst -8 1+i!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_preserv_parallel_pos) (("2" (inst -1 "x`seq(0)" "x`seq(1+i!1)" t "sigma_rhs(fss!1, fse!1)`seq(0)") (("2" (expand* SP? PP? finseq_appl) (("2" (inst-cp -9 1+i!1) (("2" (inst -9 0) (("2" (assert) (("2" (inst -7 0 1+i!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -8 -9 -15) (("2" (rewrite pos_subterm_ax) (("2" (hide 2) (("2" (lemma complement_pos_character) (("2" (inst -1 "rest(x)" p "complement_pos(p, rest(x))`seq(x1!1)") (("2" (prop) (("1" (skosimp) (("1" (typepred i!3) (("1" (expand rest -1) (("1" (expand rest -2 1) (("1" (expand* ^ min empty_seq) (("1" (replace -2 1 rl) (("1" (expand* SP? PP? finseq_appl) (("1" (rewrite replace_preserv_parallel_pos) (("1" (inst -11 1+i!3) nil nil) ("2" (inst -11 0) nil nil) ("3" (inst -10 0 1+i!3) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand seq2set 1) (("2" (expand finseq_appl) (("2" (inst 1 x1!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand seq2set 1) (("2" (expand finseq_appl) (("2" (inst 1 x!1-1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but (-2 -3 1)) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (skeep) nil nil) ("6" (skeep) nil nil) ("7" (skeep) (("7" (hide -4 -5 3) (("7" (lemma complement_pos_character) (("7" (inst -1 "rest(x)" p "complement_pos(p, rest(x))`seq(i_1 - 1)") (("1" (prop) (("1" (skosimp) (("1" (typepred i!1) (("1" (expand rest -1) (("1" (expand rest -2 1) (("1" (expand* ^ min empty_seq) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (expand* SP? finseq_appl) (("1" (inst -7 1+i!1) (("1" (rewrite pos_subterm_ax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand seq2set 1) (("2" (expand finseq_appl) (("2" (inst 1 i_1-1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("8" (skeep) (("8" (assert) nil nil)) nil) ("9" (skosimp) (("9" (typepred "choose(complement_pos_set(<=, o)(p, x`seq(0)))") (("9" (expand complement_pos_set -1 1) (("9" (expand emptyset) (("9" (prop) (("9" (hide -7 -8 3) (("9" (expand* SP? finseq_appl) (("9" (inst -8 0) (("9" (rewrite pos_subterm_ax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand replace_par_pos 1) (("2" (rewrite sigma_rhs_rest) (("1" (rewrite rest_add_first) (("1" (rewrite rest_add_first) (("1" (rewrite rest_add_first) (("1" (expand finseq_appl) (("1" (expand* add_first insert? finseq_appl) (("1" (expand sigma_rhs 1 1) (("1" (expand finseq_appl) (("1" (expand sigma_rhs -5 1) (("1" (expand finseq_appl) (("1" (typepred "choose(complement_pos_set(<=, o)(p, x`seq(0)))") (("1" (expand complement_pos_set -1 1) (("1" (expand emptyset) (("1" (prop) (("1" (replace -2 -7) (("1" (rewrite replace_distributivity -7) (("1" (expand* SP? finseq_appl) (("1" (inst -9 0) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand add_first 1) (("2" (expand insert?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred (fse!1 fse!2)) (("2" (hide-all-but (-1 -2 1 2)) (("2" (expand "subset?") (("2" (expand* "subset?" "member" "seq2set" "finseq_appl") (("2" (skosimp*) (("2" (inst -1 "x!1") (("2" (inst -2 "x!1") (("2" (assert) (("2" (hide 3) (("2" (expand* add_first insert? finseq_appl) (("2" (lift-if) (("2" (prop) (("1" (inst 1 0) nil nil) ("2" (inst 3 "kk!1 - 1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand parallel_reduction_fix?) (("2" (skosimp) (("2" (inst 2 fse!2 fss!2) (("2" (assert) (("2" (split) (("1" (hide -4 -10) (("1" (expand* nonempty? empty? member) (("1" (expand subtermsOF (-4 1)) (("1" (expand sigma_lhs (-4 1)) (("1" (expand* empty_seq finseq_appl) (("1" (lift-if 1) (("1" (prop) (("1" (decompose-equality 1) (("1" (decompose-equality 1) (("1" (skeep) nil nil)) nil) ("2" (skeep) nil nil)) nil) ("2" (lift-if) (("2" (assert) (("2" (decompose-equality 2) (("1" (lemma complement_pos_character) (("1" (inst -1 "rest(x)" p "complement_pos(p, rest(x))`seq(x!1)") (("1" (prop) (("1" (skosimp) (("1" (typepred i!1) (("1" (expand rest -1) (("1" (expand rest -2 1) (("1" (expand* ^ min empty_seq) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (decompose-equality -6) (("1" (inst -1 x!1) (("1" (replace -1 5 rl) (("1" (hide -1) (("1" (expand* SP? PP? finseq_appl) (("1" (rewrite replace_persistence) (("1" (inst -7 0) nil nil) ("2" (hide-all-but (-3 -6 -12 1 8)) (("2" (expand "Pos_Over") (("2" (lemma set_of_prop_related_nb_character[position]) (("2" (inst -1 "<=" "p" "#(p)" "x") (("2" (assert) (("2" (expand "set_of_prop_related") (("2" (expand "finseq_appl") (("2" (expand "parallel") (("2" (expand "set_of_prop_related_nb") (("2" (flatten) (("2" (prop) (("1" (hide-all-but (-1 3)) (("1" (inst 1 "x`seq(0)") (("1" (assert) (("1" (expand "member") (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand <= -1) (("2" (skosimp) (("2" (inst -2 p1!1) (("2" (expand complement_pos_set 2) (("2" (expand emptyset) (("2" (assert) (("2" (prop) (("1" (expand <= 1) (("1" (inst 1 p1!1) nil nil)) nil) ("2" (hide (-3 -4 1)) (("2" (inst 2 "x`seq(0)") (("2" (split) (("1" (expand "member") (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst?) nil nil)) nil)) nil)) nil) ("2" (expand "<=") (("2" (inst 1 "empty_seq") (("2" (rewrite "seq_o_empty") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* SP? PP? finseq_appl) (("2" (inst-cp -10 1+i!1) (("2" (lemma replace_persistence) (("2" (inst -1 "x`seq(0)" p t "sigma_rhs(fss!1, fse!1)`seq(0)") (("2" (inst -11 0) (("2" (assert) (("2" (hide -8 -14 2 5) (("2" (expand "Pos_Over") (("2" (lemma set_of_prop_related_nb_character[position]) (("2" (inst -1 "<=" "p" "#(p)" "x") (("2" (assert) (("2" (expand "set_of_prop_related") (("2" (expand "finseq_appl") (("2" (expand "parallel") (("2" (expand "set_of_prop_related_nb") (("2" (flatten) (("2" (prop) (("1" (hide-all-but (-1 6)) (("1" (inst 1 "x`seq(0)") (("1" (assert) (("1" (expand "member") (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand <= -1) (("2" (skosimp) (("2" (inst -6 p1!1) (("2" (expand complement_pos_set 5) (("2" (expand emptyset) (("2" (assert) (("2" (prop) (("1" (expand <= 1) (("1" (inst 1 p1!1) nil nil)) nil) ("2" (hide-all-but (-1 -2 1 6)) (("2" (inst 2 "x`seq(0)") (("2" (split) (("1" (expand "member") (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst?) nil nil)) nil)) nil)) nil) ("2" (expand "<=") (("2" (inst 1 "empty_seq") (("2" (rewrite "seq_o_empty") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand* SP? PP? finseq_appl) (("3" (hide -8 4) (("3" (rewrite replace_preserv_parallel_pos) (("1" (inst -9 0) nil nil) ("2" (hide 2) (("2" (hide-all-but (-5 -14 1)) (("2" (expand "Pos_Over") (("2" (lemma set_of_prop_related_nb_character[position]) (("2" (inst -1 "<=" "p" "#(p)" "x") (("2" (assert) (("2" (expand "set_of_prop_related") (("2" (expand "finseq_appl") (("2" (expand "parallel") (("2" (expand "set_of_prop_related_nb") (("2" (flatten) (("2" (prop) (("1" (hide-all-but (-1 2)) (("1" (inst 1 "x`seq(0)") (("1" (assert) (("1" (expand "member") (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand <= -1) (("2" (skosimp) (("2" (inst -2 p1!1) (("2" (expand complement_pos_set 2) (("2" (expand emptyset) (("2" (assert) (("2" (prop) (("1" (expand <= 1) (("1" (inst 1 p1!1) nil nil)) nil) ("2" (inst 2 "x`seq(0)") (("2" (split) (("1" (expand "member") (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst?) nil nil)) nil)) nil)) nil) ("2" (expand "<=") (("2" (inst 1 "empty_seq") (("2" (rewrite "seq_o_empty") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand* SP? PP? finseq_appl) (("4" (hide-all-but (-10 1)) (("4" (inst -1 "0") nil nil)) nil)) nil) ("5" (hide-all-but (1 6)) (("5" (expand sigma_rhs) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "seq2set") (("2" (expand finseq_appl) (("2" (inst 1 x!1) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but (-3 1)) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (lemma complement_pos_character) (("3" (inst -1 "rest(x)" p "complement_pos(p, rest(x))`seq(i)") (("3" (prop) (("1" (skosimp) (("1" (typepred i!1) (("1" (expand rest -1) (("1" (expand rest -2 1) (("1" (expand* ^ min empty_seq) (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (expand* SP? finseq_appl) (("1" (inst -8 1+i!1) (("1" (hide-all-but (-1 -8 5)) (("1" (replaces -1) (("1" (rewrite pos_subterm_ax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "seq2set" "finseq_appl") (("2" (inst 1 i) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite replace_persistence -4) (("1" (expand* SP? finseq_appl) (("1" (inst -6 0) nil nil)) nil) ("2" (hide -3 -4 -10 2) (("2" (expand "Pos_Over") (("2" (lemma set_of_prop_related_nb_character[position]) (("2" (inst -1 "<=" "p" "#(p)" "x") (("2" (assert) (("2" (expand "set_of_prop_related") (("2" (expand "finseq_appl") (("2" (expand "parallel") (("2" (expand "set_of_prop_related_nb") (("2" (flatten) (("2" (prop) (("1" (hide-all-but (-1 4)) (("1" (inst 1 "x`seq(0)") (("1" (assert) (("1" (expand "member") (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand <= -1) (("2" (skosimp) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 p1!1) (("2" (expand "member") (("2" (expand complement_pos_set 2) (("2" (expand emptyset) (("2" (assert) (("2" (prop) (("1" (expand <= 1) (("1" (inst 1 p1!1) nil nil)) nil) ("2" (inst 3 "x`seq(0)") (("2" (split) (("1" (expand "seq2set") (("1" (expand "finseq_appl") (("1" (inst?) nil nil)) nil)) nil) ("2" (expand "<=") (("2" (inst 1 "empty_seq") (("2" (rewrite "seq_o_empty") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand rest 1) (("2" (expand* ^ min empty_seq) (("2" (assert) (("2" (prop) (("1" (expand SP?) (("1" (skeep) nil nil)) nil) ("2" (expand SP?) (("2" (skeep) nil nil)) nil) ("3" (expand* SP? PP? finseq_appl) (("3" (assert) (("3" (skosimp) (("3" (rewrite replace_preserv_parallel_pos) (("1" (inst -2 1+i!1) nil nil) ("2" (inst -2 0) nil nil) ("3" (inst -1 0 1+i!1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (expand parallel_reduction_fix?) (("3" (inst 1 "rest(fse!1)" "rest(fss!1)") (("1" (prop) (("1" (hide-all-but (-3 1)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil) ("3" (expand rest 1) (("3" (expand* ^ min empty_seq) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (lift-if) (("3" (assert) (("3" (prop) (("1" (expand subtermsOF 1) (("1" (expand sigma_lhs 1) (("1" (expand empty_seq) (("1" (decompose-equality 1) (("1" (skeep) nil nil)) nil)) nil)) nil)) nil) ("2" (expand subtermsOF 1) (("2" (expand sigma_lhs 1) (("2" (expand empty_seq) (("2" (decompose-equality 1) (("2" (skeep) nil nil)) nil)) nil)) nil)) nil) ("3" (expand subtermsOF 3) (("3" (expand sigma_lhs 3) (("3" (expand empty_seq) (("3" (decompose-equality 3) nil nil)) nil)) nil)) nil) ("4" (expand subtermsOF 1) (("4" (expand sigma_lhs 1) (("4" (expand empty_seq) (("4" (decompose-equality 1) (("4" (skeep) nil nil)) nil)) nil)) nil)) nil) ("5" (expand subtermsOF 1) (("5" (expand sigma_lhs 1) (("5" (expand empty_seq) (("5" (decompose-equality 1) (("5" (skeep) nil nil)) nil)) nil)) nil)) nil) ("6" (expand subtermsOF 3) (("6" (expand sigma_lhs 3) (("6" (expand empty_seq) (("6" (decompose-equality 3) nil nil)) nil)) nil)) nil) ("7" (assert) nil nil) ("8" (expand subtermsOF 1) (("8" (expand sigma_lhs 1) (("8" (expand empty_seq) (("8" (decompose-equality 1) (("8" (skeep) nil nil)) nil)) nil)) nil)) nil) ("9" (expand subtermsOF 1) (("9" (expand sigma_lhs 1) (("9" (expand empty_seq) (("9" (decompose-equality 1) (("9" (skeep) nil nil)) nil)) nil)) nil)) nil) ("10" (expand subtermsOF 3) (("10" (expand sigma_lhs 3) (("10" (expand empty_seq) (("10" (decompose-equality 3) nil nil)) nil)) nil)) nil) ("11" (expand subtermsOF 1) (("11" (expand sigma_lhs 1) (("11" (expand empty_seq) (("11" (decompose-equality 1) (("11" (skeep) nil nil)) nil)) nil)) nil)) nil) ("12" (expand subtermsOF 1) (("12" (expand sigma_lhs 1) (("12" (expand empty_seq) (("12" (decompose-equality 1) (("12" (skeep) nil nil)) nil)) nil)) nil)) nil) ("13" (assert) nil nil) ("14" (assert) nil nil) ("15" (expand* subtermsOF sigma_lhs) (("15" (expand* empty_seq finseq_appl) (("15" (decompose-equality 3) (("1" (decompose-equality 1) (("1" (decompose-equality -5) (("1" (inst -1 "1+x!1") (("1" (expand* SP? PP? finseq_appl) (("1" (rewrite replace_persistence) (("1" (inst -3 0) nil nil) ("2" (inst -3 "1+x!1") nil nil) ("3" (inst -2 0 "1+x!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand* SP? finseq_appl) (("2" (inst -4 x1!1) nil nil)) nil)) nil) ("2" (skeep) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (expand* SP? PP? finseq_appl) (("3" (rewrite replace_preserv_parallel_pos) (("1" (inst -2 "1+i") nil nil) ("2" (inst -2 0) nil nil) ("3" (inst -1 0 "1+i") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (expand* SP? PP? finseq_appl) (("3" (rewrite replace_preserv_parallel_pos) (("1" (inst -2 "1+i") nil nil) ("2" (inst -2 0) nil nil) ("3" (inst -1 0 "1+i") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (rewrite sigma_rhs_rest) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred fse!1) (("2" (expand "subset?") (("2" (lemma rest_subset[rewrite_rule]) (("2" (inst?) (("2" (lemma subset_transitive[rewrite_rule]) (("2" (inst -1 "seq2set(rest(fse!1))" "seq2set(fse!1)" "E") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma Pos_Over_character) (("4" (inst -1 "#(p)" "x" "p") (("4" (assert) (("4" (split) (("1" (hide -2) (("1" (expand "PP?") (("1" (prop) (("1" (hide-all-but (-1 2)) (("1" (expand* add_first insert?) (("1" (assert) nil nil)) nil)) nil) ("2" (expand finseq_appl) (("2" (expand* add_first insert? finseq_appl) (("2" (inst -1 1 0) (("1" (assert) (("1" (rewrite replace_preserv_parallel_pos) (("1" (expand* SP? finseq_appl) (("1" (inst -2 0) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (hide -9) (("2" (lemma replace_preserv_parallel_pos) (("2" (inst -1 "x`seq(0)" "x`seq(i!1)" t "sigma_rhs(fss!1, fse!1)`seq(0)") (("2" (expand* SP? PP? finseq_appl) (("2" (inst-cp -4 i!1) (("2" (inst -4 0) (("2" (case "i!1=0") (("1" (assert) (("1" (hide -2 -4) (("1" (replaces -1) (("1" (lemma replace_preserv_pos) (("1" (inst -1 "x`seq(0)" t "sigma_rhs(fss!1, fse!1)`seq(0)") (("1" (assert) (("1" (lemma pos_ax) (("1" (expand <= -3) (("1" (skosimp) (("1" (inst -1 p p1!1 "replaceTerm(t, sigma_rhs(fss!1, fse!1)`seq(0), x`seq(0))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (prop) (("1" (expand <= -2) (("1" (skosimp) (("1" (lemma pos_ax) (("1" (inst -1 p p1!1 "replaceTerm(t, sigma_rhs(fss!1, fse!1)`seq(0), x`seq(0))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -2 0 i!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "Pos_Over") (("5" (expand "set_of_prop_related_nb") (("5" (prop) (("5" (hide-all-but (-1 1 2)) (("5" (skosimp) (("5" (expand "member") (("5" (expand "seq2set") (("5" (expand "finseq_appl") (("5" (skosimp) (("5" (expand "rest") (("5" (expand "^") (("5" (lift-if) (("5" (prop) (("1" (hide 2) (("1" (typepred "kk!1") (("1" (grind) nil nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "kk!1") (("2" (grind) nil nil)) nil)) nil) ("3" (inst 4 x!1) (("3" (assert) (("3" (inst 4 "1 + kk!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand SPP?) (("2" (flatten) (("2" (rewrite complement_pos_is_PP) (("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (lemma complement_pos_character) (("2" (inst -1 fsp2 p "complement_pos(p, fsp2)`seq(i)") (("2" (prop) (("1" (skosimp) (("1" (inst -3 i!1) (("1" (rewrite pos_subterm_ax) nil nil)) nil)) nil) ("2" (expand* "seq2set" "finseq_appl") (("2" (inst 1 i) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (lemma Pos_Over_character) (("3" (inst -1 "#(p)" "fsp2" "p") (("3" (assert) (("3" (split) (("1" (expand parallel_reduction_fix?) (("1" (skosimp) (("1" (replaces -6) (("1" (rewrite replace_par_pos_preservs_pos) (("1" (expand SPP?) (("1" (rewrite add_first_parallel_pos_to_SP_is_SP) nil nil)) nil) ("2" (expand sigma_rhs 1) (("2" (expand empty_seq) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (lemma replace_par_pos_preservs_PP) (("2" (expand finseq_appl) (("2" (expand* parallel_reduction_fix?) (("2" (skosimp) (("2" (replaces -7) (("2" (inst -1 fsp2 "sigma_rhs(fss!1, fse!1)" t) (("2" (assert) (("2" (expand sigma_rhs -1 1) (("2" (inst -1 i!1) (("2" (lemma closed_positions) (("2" (inst -1 p "fsp2`seq(i!1)" "replace_par_pos(t, fsp2, sigma_rhs(fss!1, fse!1))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand SPP?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((closed_positions formula-decl nil positions nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (add_first_parallel_pos_to_SP_is_SP formula-decl nil positions nil) (SP type-eq-decl nil positions nil) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (complement_pos_is_PP formula-decl nil orthogonality_basis nil) (= const-decl "[T, T -> boolean]" equalities nil) (subset? const-decl "bool" predicate_fseq2set nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" orthogonality_sets nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (sigma_lhs const-decl "finseq[term]" orthogonality_basis nil) (t skolem-const-decl "term" orthogonality_sets nil) (p skolem-const-decl "position[variable, symbol, arity]" orthogonality_sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (epsilon const-decl "T" epsilons nil) (TRUE const-decl "bool" booleans nil) (FALSE const-decl "bool" booleans nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (empty_seq const-decl "finseq" finite_sequences nil) (length_rest formula-decl nil seq_extras structures) (Pos_Over_character formula-decl nil orthogonality_sets nil) (pos_ax formula-decl nil positions nil) (replace_preserv_pos formula-decl nil replacement nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (fss!1 skolem-const-decl "finseq[Sub[variable, symbol, arity]]" orthogonality_sets nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (rest_subset formula-decl nil predicate_fseq2set nil) (subset_transitive formula-decl nil sets_lemmas nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (kk!1 skolem-const-decl "below(length
        (add_first[rewrite_rule[variable, symbol, arity]]
             (fse!1`seq(0), fse!2)))" orthogonality_sets nil) (rest_add_first formula-decl nil seq_extras structures) (rhs const-decl "term" rewrite_rules nil) (replace_distributivity formula-decl nil replacement nil) (sigma_rhs_rest formula-decl nil orthogonality_basis nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (x skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (PRED type-eq-decl nil defined_types nil) (complement_pos_set const-decl "set[T]" predicate_fseq2set nil) (<= const-decl "bool" positions nil) (O const-decl "finseq" finite_sequences nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (fss!2 skolem-const-decl "finseq[Sub[variable, symbol, arity]]" orthogonality_sets nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (lhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (emptyset const-decl "set" sets nil) (SP? const-decl "bool" positions nil) (pos_subterm formula-decl nil subterm nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (x!1 skolem-const-decl "below[1 + complement_pos(p, rest(x))`length]" orthogonality_sets nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pos_subterm_ax formula-decl nil subterm nil) (replace_preserv_parallel_pos formula-decl nil replacement nil) (replace_persistence formula-decl nil replacement nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (complement_pos_character formula-decl nil orthogonality_basis nil) (i_1 skolem-const-decl "below[1 +
       complement_pos[variable, symbol, arity]
           (p, rest[position[variable, symbol, arity]](x))`length]" orthogonality_sets nil) (insert? const-decl "finseq" seq_extras structures) (fse!2 skolem-const-decl "{fse | subset?(fse, E)}" orthogonality_sets nil) (fse!1 skolem-const-decl "{fse | subset?(fse, E)}" orthogonality_sets nil) (add_first const-decl "finseq" seq_extras structures) (set_of_prop_related const-decl "set[T]" predicate_fseq2set nil) (parallel const-decl "bool" positions nil) (seq_o_empty formula-decl nil seq_extras structures) (set_of_prop_related_nb const-decl "set[T]" predicate_fseq2set nil) (set_of_prop_related_nb_character formula-decl nil predicate_fseq2set nil) (fss!2 skolem-const-decl "finseq[Sub[variable, symbol, arity]]" orthogonality_sets nil) (empty? const-decl "bool" sets nil) (rest_of_PP_is_PP formula-decl nil positions nil) (PP? const-decl "bool" positions nil) (PP type-eq-decl nil positions nil) (replaceTerm def-decl "term" replacement nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (rest const-decl "finseq" seq_extras structures) (positions? type-eq-decl nil positions nil) (subtermOF def-decl "term" subterm nil) (complement_pos def-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (SPP? const-decl "bool" positions nil) (SPP type-eq-decl nil positions nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (fork_in_Pos_Over_TCC1 0 (fork_in_Pos_Over_TCC1-1 nil 3673307865 ("" (subtype-tcc) nil nil) ((N!1 skolem-const-decl "nat" orthogonality_sets nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (N!1 skolem-const-decl "nat" orthogonality_sets nil) (fse!1 skolem-const-decl "{fse | subset?(fse, E!1)}" orthogonality_sets nil) (fss!1 skolem-const-decl "finseq[Sub[variable, symbol, arity]]" orthogonality_sets nil) (fsp2!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (t!1 skolem-const-decl "term" orthogonality_sets nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (SPP type-eq-decl nil positions nil) (sigma!1 skolem-const-decl "Sub[variable, symbol, arity]" orthogonality_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (t2!1 skolem-const-decl "term" orthogonality_sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (kk!1 skolem-const-decl "below(length(fsp1!1))" orthogonality_sets nil) (fsp1!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (e!1 skolem-const-decl "{e | member(e, E!1)}" orthogonality_sets nil) (E!1 skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" orthogonality_sets nil) (vars? adt-recognizer-decl "[term -> boolean]" term_adt nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (rhs const-decl "term" rewrite_rules nil) (sigma_lhs const-decl "finseq[term]" orthogonality_basis nil) (lhs const-decl "term" rewrite_rules nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (subset? const-decl "bool" sets nil) (Vars const-decl "set[(V)]" subterm nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" predicate_fseq2set nil) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil naturalnumbers nil) (Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (seq2set const-decl "finite_set[T]" seq2set structures) (member const-decl "bool" sets nil) (O const-decl "finseq" finite_sequences nil) (<= const-decl "bool" positions nil) (set_of_prop_related_nb const-decl "set[T]" predicate_fseq2set nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (Dom const-decl "set[(V)]" substitution nil) (/= const-decl "boolean" notequal nil) (V const-decl "set[term]" variables_term nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil)) nil (fork_in_Pos_Over subtype "orthogonality_sets.p" "positions[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].positions?(orthogonality_sets.t)"))) (fork_in_Pos_Over_TCC2 0 (fork_in_Pos_Over_TCC2-2 "" 3803876460 ("" (skosimp*) (("" (expand "Pos_Over") (("" (lemma set_of_prop_related_nb_is_subset[position]) (("" (inst -1 "<=" "fsp1!1" "fsp2!1") (("" (expand* "subset?" "member") (("" (inst?) (("" (assert) (("" (expand* "seq2set" "finseq_appl") (("" (skosimp) (("" (expand SPP?) (("" (flatten) (("" (expand parallel_reduction_fix? -4) (("" (skosimp) (("" (replace -7 1) (("" (lemma replace_par_pos_preservs_PP) (("" (inst -1 fsp1!1 "sigma_rhs(fss!1, fse!1)" t!1) (("" (expand SPP?) (("" (expand sigma_rhs -1 1) (("" (expand empty_seq) (("" (expand finseq_appl) (("" (assert) (("" (inst -1 kk!1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (fork_in_Pos_Over subtype "orthogonality_sets.p" "positions[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].positions?(orthogonality_sets.t1)")) (fork_in_Pos_Over_TCC2-1 nil 3673307865 ("" (skosimp*) (("" (expand "Pos_Over") (("" (lemma set_of_prop_related_nb_is_subset[position]) (("" (inst -1 "<=" "fsp1!1" "fsp2!1") (("" (expand* "subset?" "member") (("" (inst?) (("" (assert) (("" (expand* "seq2set" "finseq_appl") (("" (skosimp) (("" (expand SPP?) (("" (flatten) (("" (expand parallel_reduction_fix? -6) (("" (skosimp) (("" (replace -9 1) (("" (lemma replace_par_pos_preservs_PP) (("" (inst -1 fsp1!1 "sigma_rhs(fss!1, fse!1)" t!1) (("" (expand SPP?) (("" (expand sigma_rhs -1 1) (("" (expand empty_seq) (("" (expand finseq_appl) (("" (assert) (("" (inst -1 kk!1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (PRED type-eq-decl nil defined_types nil) (<= const-decl "bool" positions nil) (finseq type-eq-decl nil finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (seq2set const-decl "finite_set[T]" seq2set structures) (SPP? const-decl "bool" positions nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (subset? const-decl "bool" predicate_fseq2set nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (= const-decl "[T, T -> boolean]" equalities nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (empty_seq const-decl "finseq" finite_sequences nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (set_of_prop_related_nb_is_subset formula-decl nil predicate_fseq2set nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (position type-eq-decl nil positions nil)) nil (fork_in_Pos_Over subtype "orthogonality_sets.p" "positions[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].positions?(orthogonality_sets.t1)"))) (fork_in_Pos_Over_TCC3 0 (fork_in_Pos_Over_TCC3-2 "" 3803887646 ("" (skosimp) (("" (skeep) (("" (expand parallel_reduction_fix? -2) (("" (skosimp) (("" (lemma Pos_Over_character) (("" (inst -1 "fsp1!1" "fsp2!1" "p!1") (("" (assert) (("" (expand SPP?) (("" (flatten) (("" (split) (("1" (replace -6 1) (("1" (rewrite replace_par_pos_preservs_pos) (("1" (expand SPP?) (("1" (rewrite add_first_parallel_pos_to_SP_is_SP) nil nil)) nil) ("2" (expand sigma_rhs 1) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (lemma replace_par_pos_preservs_PP) (("2" (inst -1 fsp2!1 "sigma_rhs(fss!1, fse!1)" t!1) (("2" (expand sigma_rhs -1 1) (("2" (expand finseq_appl) (("2" (inst -1 i!1) (("2" (replace -7 -1 rl) (("2" (lemma closed_positions) (("2" (inst -1 p!1 "fsp2!1`seq(i!1)" t2!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (fork_in_Pos_Over subtype "orthogonality_sets.p" "positions[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].positions?(orthogonality_sets.t2)")) (fork_in_Pos_Over_TCC3-1 nil 3673307865 ("" (skosimp) (("" (skeep) (("" (expand parallel_reduction_fix? -4) (("" (skosimp) (("" (lemma Pos_Over_character) (("" (inst -1 "fsp1!1" "fsp2!1" "p!1") (("" (assert) (("" (expand SPP?) (("" (flatten) (("" (split) (("1" (replace -10 1) (("1" (rewrite replace_par_pos_preservs_pos) (("1" (expand SPP?) (("1" (rewrite add_first_parallel_pos_to_SP_is_SP) nil nil)) nil) ("2" (expand sigma_rhs 1) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (lemma replace_par_pos_preservs_PP) (("2" (inst -1 fsp2!1 "sigma_rhs(fss!1, fse!1)" t!1) (("2" (expand sigma_rhs -1 1) (("2" (expand finseq_appl) (("2" (inst -1 i!1) (("2" (replace -11 -1 rl) (("2" (lemma closed_positions) (("2" (inst -1 p!1 "fsp2!1`seq(i!1)" t2!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (SPP? const-decl "bool" positions nil) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (term type-decl nil term_adt nil) (set type-eq-decl nil sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (= const-decl "[T, T -> boolean]" equalities nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (subset? const-decl "bool" predicate_fseq2set nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (SP type-eq-decl nil positions nil) (SP? const-decl "bool" positions nil) (add_first_parallel_pos_to_SP_is_SP formula-decl nil positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (< const-decl "bool" reals nil) (closed_positions formula-decl nil positions nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (Pos_Over_character formula-decl nil orthogonality_sets nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil)) nil (fork_in_Pos_Over subtype "orthogonality_sets.p" "positions[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].positions?(orthogonality_sets.t2)"))) (fork_in_Pos_Over 0 (fork_in_Pos_Over-1 nil 3673307939 ("" (skeep) (("" (lemma set_of_prop_related_nb_is_subset[position]) (("" (inst -1 "<=" "fsp1" "fsp2") (("" (expand* "subset?" "member") (("" (inst -1 "p") (("" (expand "Pos_Over") (("" (assert) (("" (expand* "seq2set" "finseq_appl") (("" (skosimp) (("" (lemma fork_in_Pos_Over_aux) (("" (inst -1 E fsp2 p t t2) (("" (assert) (("" (prop) (("1" (expand parallel_reduction_fix? -5) (("1" (skosimp -5) (("1" (inst 1 "fse!1`seq(kk!1)" "fss!1`seq(kk!1)") (("1" (split) (("1" (expand subtermsOF -7) (("1" (expand sigma_lhs -7) (("1" (lift-if) (("1" (expand* empty_seq finseq_appl) (("1" (prop) (("1" (hide -3) (("1" (decompose-equality -2) (("1" (inst -1 kk!1) (("1" (assert) nil nil)) nil) ("2" (expand SPP?) (("2" (flatten) (("2" (expand SP? -7) (("2" (expand finseq_appl) (("2" (inst -7 x!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_par_pos_subterm) (("2" (inst -1 fsp1 "sigma_rhs(fss!1, fse!1)" t) (("2" (expand SPP?) (("2" (expand sigma_rhs -1 1) (("2" (expand empty_seq) (("2" (expand finseq_appl) (("2" (flatten) (("2" (assert) (("2" (inst -1 kk!1) (("2" (replace -11 -1 rl) (("2" (expand sigma_rhs -1) (("2" (expand finseq_appl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand parallel_reduction? 1) (("3" (inst 1 "complement_pos(p, fsp2)") nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (typepred fse!1) (("3" (expand* "subset?" "member") (("3" (expand* "subset?" "member") (("3" (inst?) (("3" (assert) (("3" (expand* "seq2set" "finseq_appl") (("3" (inst 1 kk!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand SPP?) (("2" (flatten) (("2" (expand SP? -3) (("2" (expand finseq_appl) (("2" (inst -3 kk!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-6 1)) (("3" (expand "Pos_Over") (("3" (expand "set_of_prop_related_nb") (("3" (prop) (("3" (hide (-1 2)) (("3" (expand "member") (("3" (expand "seq2set") (("3" (expand "finseq_appl") (("3" (inst 1 0) (("1" (expand "#") (("1" (propax) nil nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set_of_prop_related_nb_is_subset formula-decl nil predicate_fseq2set nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (seq2set const-decl "finite_set[T]" seq2set structures) (fork_in_Pos_Over_aux formula-decl nil orthogonality_sets nil) (set_of_prop_related_nb const-decl "set[T]" predicate_fseq2set nil) (finite_sequence type-eq-decl nil finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (p skolem-const-decl "position[variable, symbol, arity]" orthogonality_sets nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (fsp1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (below type-eq-decl nil naturalnumbers nil) (kk!1 skolem-const-decl "below(length(fsp1))" orthogonality_sets nil) (subset? const-decl "bool" predicate_fseq2set nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" orthogonality_sets nil) (fse!1 skolem-const-decl "{fse | subset?(fse, E)}" orthogonality_sets nil) (V const-decl "set[term]" variables_term nil) (Sub? const-decl "bool" substitution nil) (Sub type-eq-decl nil substitution nil) (fss!1 skolem-const-decl "finseq[Sub[variable, symbol, arity]]" orthogonality_sets nil) (parallel_reduction? const-decl "bool" orthogonality_basis nil) (SPP type-eq-decl nil positions nil) (complement_pos def-decl "finseq[position[variable, symbol, arity]]" orthogonality_basis nil) (replace_par_pos_subterm formula-decl nil orthogonality_basis nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (lhs const-decl "term" rewrite_rules nil) (ext def-decl "term" substitution nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (sigma_lhs const-decl "finseq[term]" orthogonality_basis nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" positions nil) (PRED type-eq-decl nil defined_types nil)) shostak)) (subterm_joinability_TCC1 0 (subterm_joinability_TCC1-1 nil 3673309211 ("" (skosimp) (("" (expand "Pos_Over") (("" (rewrite "finite_union") (("1" (hide 2) (("1" (rewrite "finite_union") (("1" (hide 2) (("1" (expand "Pos_Equal") (("1" (expand "intersection") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite set_of_prop_related_nb_is_finite) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite set_of_prop_related_nb_is_finite) nil nil)) nil)) nil)) nil)) nil) ((Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (set_of_prop_related_nb_is_finite formula-decl nil predicate_fseq2set nil) (finite_intersection2 application-judgement "finite_set[position[variable, symbol, arity]]" orthogonality_sets nil) (intersection const-decl "set[T]" predicate_fseq2set nil) (position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Pos_Equal const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (union const-decl "set" sets nil) (<= const-decl "bool" positions nil) (set_of_prop_related_nb const-decl "set[T]" predicate_fseq2set nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (finite_union judgement-tcc nil finite_sets nil)) nil (subterm_joinability subtype "sets[position[variable, symbol, arity]].union(orthogonality_sets.Pos_Over(orthogonality_sets.fsp1, orthogonality_sets.fsp2), sets[position[variable, symbol, arity]].union(orthogonality_sets.Pos_Over(orthogonality_sets.fsp2, orthogonality_sets.fsp1), orthogonality_sets.Pos_Equal(orthogonality_sets.fsp1, orthogonality_sets.fsp2)))" "finite_set[position[variable, symbol, arity]]"))) (subterm_joinability_TCC2 0 (subterm_joinability_TCC2-2 "" 3803913889 ("" (expand finseq_appl) (("" (skosimp*) (("" (hide -2) (("" (expand parallel_reduction_fix?) (("" (skosimp) (("" (lemma replace_par_pos_preservs_PP) (("" (inst -1 fsp1!1 "sigma_rhs(fss!1, fse!1)" t!1) (("" (expand sigma_rhs -1 1) (("" (expand* SPP? empty_seq finseq_appl) (("" (flatten) (("" (assert) (("" (lift-if) (("" (assert) (("" (lemma "set2seq_lem[position]") (("" (expand finseq_appl) (("" (inst?) (("" (replace -3 -1 rl) (("" (inst?) (("1" (expand* "union" "member") (("1" (prop) (("1" (expand "Pos_Over") (("1" (lemma "set_of_prop_related_nb_is_subset[position]") (("1" (inst -1 "<=" "fsp1!1" "fsp2!1") (("1" (expand* "subset?" "member") (("1" (inst?) (("1" (assert) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (replace -1 1 rl) (("1" (inst -3 "kk!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma Pos_Over_character) (("2" (inst -1 "fsp2!1" "fsp1!1" "fsp!1`seq(i!1)") (("2" (assert) (("2" (split) (("1" (replace -8 1) (("1" (rewrite replace_par_pos_preservs_pos) (("1" (hide 2) (("1" (expand SPP?) (("1" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (hide 2) (("1" (expand "Pos_Over") (("1" (lemma "set_of_prop_related_nb_is_subset[position]") (("1" (inst -1 "<=" "fsp2!1" "fsp1!1") (("1" (hide -14) (("1" (expand* "subset?" "member") (("1" (inst?) (("1" (assert) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (expand SP?) (("1" (expand finseq_appl) (("1" (hide -4 -13) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand sigma_rhs 1) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -3 i!2) (("2" (lemma closed_positions) (("2" (inst -1 "fsp!1`seq(i!1)" "fsp1!1`seq(i!2)" "t1!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "Pos_Equal") (("3" (expand "intersection") (("3" (expand "intersection") (("3" (expand "member") (("3" (flatten) (("3" (hide -2) (("3" (expand "seq2set") (("3" (expand "finseq_appl") (("3" (skosimp) (("3" (replace -1 1 rl) (("3" (inst -2 "kk!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (replace -3 -1) (("2" (rewrite "set2seq_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (subterm_joinability subtype "finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_sets.fsp)(orthogonality_sets.i)" "positions[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].positions?(orthogonality_sets.t1)")) (subterm_joinability_TCC2-1 nil 3673309211 ("" (expand finseq_appl) (("" (skosimp*) (("" (hide -5) (("" (expand parallel_reduction_fix?) (("" (skosimp) (("" (lemma replace_par_pos_preservs_PP) (("" (inst -1 fsp1!1 "sigma_rhs(fss!1, fse!1)" t!1) (("" (expand sigma_rhs -1 1) (("" (expand* SPP? empty_seq finseq_appl) (("" (flatten) (("" (assert) (("" (lift-if) (("" (assert) (("" (lemma "set2seq_lem[position]") (("" (expand finseq_appl) (("" (inst?) (("" (replace -12 -1 rl) (("" (inst?) (("1" (expand* "union" "member") (("1" (prop) (("1" (expand "Pos_Over") (("1" (lemma "set_of_prop_related_nb_is_subset[position]") (("1" (inst -1 "<=" "fsp1!1" "fsp2!1") (("1" (expand* "subset?" "member") (("1" (inst?) (("1" (assert) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (replace -1 1 rl) (("1" (inst -3 "kk!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma Pos_Over_character) (("2" (inst -1 "fsp2!1" "fsp1!1" "fsp!1`seq(i!1)") (("2" (assert) (("2" (split) (("1" (replace -12 1) (("1" (rewrite replace_par_pos_preservs_pos) (("1" (hide 2) (("1" (expand SPP?) (("1" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (hide 2) (("1" (expand "Pos_Over") (("1" (lemma "set_of_prop_related_nb_is_subset[position]") (("1" (inst -1 "<=" "fsp2!1" "fsp1!1") (("1" (hide -14) (("1" (expand* "subset?" "member") (("1" (inst?) (("1" (assert) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (hide -7) (("1" (expand SP?) (("1" (expand finseq_appl) (("1" (hide -4) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand sigma_rhs 1) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -3 i!2) (("2" (lemma closed_positions) (("2" (inst -1 "fsp!1`seq(i!1)" "fsp1!1`seq(i!2)" "t1!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "Pos_Equal") (("3" (expand "intersection") (("3" (expand "intersection") (("3" (expand "member") (("3" (flatten) (("3" (hide -2) (("3" (expand "seq2set") (("3" (expand "finseq_appl") (("3" (skosimp) (("3" (replace -1 1 rl) (("3" (inst -2 "kk!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (replace -12 -1) (("2" (rewrite "set2seq_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (set2seq_lem formula-decl nil set2seq structures) (Pos_Equal const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (union const-decl "set" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (fsp!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (i!1 skolem-const-decl "below[fsp!1`length]" orthogonality_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (fsp1!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (fsp2!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (below type-eq-decl nil naturalnumbers nil) (set2seq def-decl "finite_sequence[T]" set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (set2seq_length formula-decl nil set2seq structures) (set_of_prop_related_nb_is_subset formula-decl nil predicate_fseq2set nil) (subset? const-decl "bool" sets nil) (seq2set const-decl "finite_set[T]" seq2set structures) (PRED type-eq-decl nil defined_types nil) (<= const-decl "bool" positions nil) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (SP type-eq-decl nil positions nil) (SP? const-decl "bool" positions nil) (add_first_parallel_pos_to_SP_is_SP formula-decl nil positions nil) (closed_positions formula-decl nil positions nil) (Pos_Over_character formula-decl nil orthogonality_sets nil) (intersection const-decl "set[T]" predicate_fseq2set nil) (intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (SPP? const-decl "bool" positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (subset? const-decl "bool" predicate_fseq2set nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (= const-decl "[T, T -> boolean]" equalities nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (subterm_joinability subtype "finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_sets.fsp)(orthogonality_sets.i)" "positions[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].positions?(orthogonality_sets.t1)"))) (subterm_joinability_TCC3 0 (subterm_joinability_TCC3-2 "" 3803914363 ("" (expand finseq_appl) (("" (skosimp) (("" (skosimp) (("" (expand parallel_reduction_fix?) (("" (skosimp) (("" (lemma replace_par_pos_preservs_PP) (("" (inst -1 fsp2!1 "sigma_rhs(fss!1, fse!1)" t!1) (("" (expand sigma_rhs -1 1) (("" (expand* SPP? empty_seq finseq_appl) (("" (flatten) (("" (assert) (("" (lift-if) (("" (assert) (("" (lemma "set2seq_lem[position]") (("" (expand finseq_appl) (("" (inst?) (("" (replace -3 -1 rl) (("" (inst?) (("1" (hide -3) (("1" (expand* "union" "member") (("1" (prop) (("1" (lemma Pos_Over_character) (("1" (inst -1 "fsp1!1" "fsp2!1" "fsp!1`seq(i!1)") (("1" (assert) (("1" (split) (("1" (replace -7 1) (("1" (rewrite replace_par_pos_preservs_pos) (("1" (expand SPP?) (("1" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (expand "Pos_Over") (("1" (lemma "set_of_prop_related_nb_is_subset[position]") (("1" (inst -1 "<=" "fsp1!1" "fsp2!1") (("1" (expand* "subset?" "member") (("1" (inst?) (("1" (assert) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (hide -9) (("1" (hide (-4 2 3)) (("1" (expand SP?) (("1" (expand finseq_appl) (("1" (inst? -11) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand sigma_rhs 1) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -3 i!2) (("2" (lemma closed_positions) (("2" (inst -1 "fsp!1`seq(i!1)" "fsp2!1`seq(i!2)" "t2!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Pos_Over") (("2" (lemma "set_of_prop_related_nb_is_subset[position]") (("2" (inst -1 "<=" "fsp2!1" "fsp1!1") (("2" (expand* "subset?" "member") (("2" (inst?) (("2" (assert) (("2" (expand* "seq2set" "finseq_appl") (("2" (skosimp) (("2" (replace -1 1 rl) (("2" (inst -3 "kk!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "Pos_Equal") (("3" (expand "intersection") (("3" (expand "intersection") (("3" (expand "member") (("3" (flatten) (("3" (hide -1) (("3" (expand "seq2set") (("3" (expand finseq_appl) (("3" (skosimp) (("3" (inst -2 "kk!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (replace -3 -1) (("2" (rewrite "set2seq_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (subterm_joinability subtype "finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_sets.fsp)(orthogonality_sets.i)" "positions[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].positions?(orthogonality_sets.t2)")) (subterm_joinability_TCC3-1 nil 3673309211 ("" (expand finseq_appl) (("" (skosimp) (("" (skosimp) (("" (hide -4) (("" (expand parallel_reduction_fix?) (("" (skosimp) (("" (lemma replace_par_pos_preservs_PP) (("" (inst -1 fsp2!1 "sigma_rhs(fss!1, fse!1)" t!1) (("" (expand sigma_rhs -1 1) (("" (expand* SPP? empty_seq finseq_appl) (("" (flatten) (("" (assert) (("" (lift-if) (("" (assert) (("" (lemma "set2seq_lem[position]") (("" (expand finseq_appl) (("" (inst?) (("" (replace -12 -1 rl) (("" (inst?) (("1" (hide -12) (("1" (expand* "union" "member") (("1" (prop) (("1" (lemma Pos_Over_character) (("1" (inst -1 "fsp1!1" "fsp2!1" "fsp!1`seq(i!1)") (("1" (assert) (("1" (split) (("1" (replace -12 1) (("1" (rewrite replace_par_pos_preservs_pos) (("1" (expand SPP?) (("1" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (expand "Pos_Over") (("1" (lemma "set_of_prop_related_nb_is_subset[position]") (("1" (inst -1 "<=" "fsp1!1" "fsp2!1") (("1" (expand* "subset?" "member") (("1" (inst?) (("1" (assert) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (hide -9) (("1" (hide (-4 2 3)) (("1" (expand SP?) (("1" (expand finseq_appl) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand sigma_rhs 1) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (inst -3 i!2) (("2" (lemma closed_positions) (("2" (inst -1 "fsp!1`seq(i!1)" "fsp2!1`seq(i!2)" "t2!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Pos_Over") (("2" (lemma "set_of_prop_related_nb_is_subset[position]") (("2" (inst -1 "<=" "fsp2!1" "fsp1!1") (("2" (expand* "subset?" "member") (("2" (inst?) (("2" (assert) (("2" (expand* "seq2set" "finseq_appl") (("2" (skosimp) (("2" (replace -1 1 rl) (("2" (inst -3 "kk!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "Pos_Equal") (("3" (expand "intersection") (("3" (expand "intersection") (("3" (expand "member") (("3" (flatten) (("3" (hide -1) (("3" (expand "seq2set") (("3" (expand finseq_appl) (("3" (skosimp) (("3" (inst -2 "kk!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (replace -12 -1) (("2" (rewrite "set2seq_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (set2seq_lem formula-decl nil set2seq structures) (Pos_Equal const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (union const-decl "set" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (fsp!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (i!1 skolem-const-decl "below[fsp!1`length]" orthogonality_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (fsp1!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (fsp2!1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (below type-eq-decl nil naturalnumbers nil) (set2seq def-decl "finite_sequence[T]" set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (set2seq_length formula-decl nil set2seq structures) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (intersection const-decl "set[T]" predicate_fseq2set nil) (Pos_Over_character formula-decl nil orthogonality_sets nil) (closed_positions formula-decl nil positions nil) (<= const-decl "bool" positions nil) (PRED type-eq-decl nil defined_types nil) (seq2set const-decl "finite_set[T]" seq2set structures) (subset? const-decl "bool" sets nil) (set_of_prop_related_nb_is_subset formula-decl nil predicate_fseq2set nil) (add_first_parallel_pos_to_SP_is_SP formula-decl nil positions nil) (SP? const-decl "bool" positions nil) (SP type-eq-decl nil positions nil) (positions type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions? type-eq-decl nil positions nil) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (NOT const-decl "[bool -> bool]" booleans nil) (SPP? const-decl "bool" positions nil) (empty_seq const-decl "finseq" finite_sequences nil) (subset? const-decl "bool" predicate_fseq2set nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (= const-decl "[T, T -> boolean]" equalities nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (subterm_joinability subtype "finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_sets.fsp)(orthogonality_sets.i)" "positions[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].positions?(orthogonality_sets.t2)"))) (subterm_joinability 0 (subterm_joinability-1 nil 3673309242 ("" (skeep) (("" (skeep) (("" (expand finseq_appl) (("" (lemma "set2seq_lem[position]") (("" (expand finseq_appl) (("" (inst?) (("" (replace -7 -1 rl) (("" (inst?) (("1" (expand* "union" "member") (("1" (prop) (("1" (lemma "fork_in_Pos_Over") (("1" (inst -1 E fsp1 fsp2 "fsp`seq(i)" t t1 t2) (("1" (assert) (("1" (skosimp) (("1" (lemma Parallel_Moves_Lemma) (("1" (inst -1 E e!1 sigma!1 "subtermOF(t2, fsp`seq(i))") (("1" (assert) (("1" (skosimp) (("1" (inst 1 s!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma fork_in_Pos_Over) (("2" (inst -1 E fsp2 fsp1 "fsp`seq(i)" t t2 t1) (("2" (assert) (("2" (skosimp) (("2" (lemma Parallel_Moves_Lemma) (("2" (inst -1 E e!1 sigma!1 "subtermOF(t1, fsp`seq(i))") (("2" (assert) (("2" (skosimp) (("2" (inst 1 s!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "Pos_Equal") (("3" (expand "intersection") (("3" (expand "intersection") (("3" (expand "member") (("3" (flatten) (("3" (expand "seq2set") (("3" (expand "finseq_appl") (("3" (skosimp*) (("3" (lemma non_ambiguous_implies_same_term) (("3" (inst -1 "E" "empty_seq" "subtermOF(t, fsp`seq(i))" "subtermOF(t1, fsp`seq(i))" "subtermOF(t2, fsp`seq(i))") (("1" (expand Orthogonal?) (("1" (flatten) (("1" (assert) (("1" (prop) (("1" (inst 2 "subtermOF(t1, fsp`seq(i))") (("1" (replace -1 2 rl) (("1" (lemma parallel_reduction_reflexive) (("1" (inst -1 E) (("1" (expand reflexive?) (("1" (inst -1 "subtermOF(t1, fsp`seq(i))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand positionsOF) (("2" (expand* only_empty_seq union empty_seq member) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (hide -1 2) (("2" (grind) nil nil)) nil) ("3" (hide 1 3) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2 -5 -7 3) (("3" (expand reduction_fix?) (("3" (expand parallel_reduction_fix?) (("3" (skosimp) (("3" (inst 1 "fse!1`seq(kk!1)" "fss!1`seq(kk!1)") (("1" (expand empty_seq) (("1" (expand subtermOF 1 1) (("1" (expand replaceTerm 1) (("1" (replace -1 1 rl) (("1" (split) (("1" (expand* subtermsOF sigma_lhs empty_seq finseq_appl) (("1" (assert) (("1" (decompose-equality -6) (("1" (inst -1 kk!1) nil nil) ("2" (hide-all-but (-5 1)) (("2" (expand "SPP?") (("2" (flatten) (("2" (expand* SP? finseq_appl) (("2" (inst -2 x!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_par_pos_subterm) (("2" (expand finseq_appl) (("2" (inst -1 fsp1 "sigma_rhs(fss!1, fse!1)" t) (("2" (assert) (("2" (expand sigma_rhs -1 1) (("2" (inst -1 kk!1) (("2" (expand sigma_rhs -1 2) (("2" (expand finseq_appl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide-all-but (-4 1)) (("3" (typepred "fse!1" "kk!1") (("3" (replaces -3) (("3" (expand* "subset?" "member") (("3" (expand* "subset?" "member" "seq2set" "finseq_appl") (("3" (inst?) (("3" (assert) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -1 -4 -6 3) (("4" (expand empty_seq) (("4" (expand reduction_fix?) (("4" (expand parallel_reduction_fix?) (("4" (skosimp) (("4" (inst 1 "fse!1`seq(kk!2)" "fss!1`seq(kk!2)") (("1" (expand subtermOF 1 1) (("1" (expand replaceTerm 1) (("1" (replace -1 1 rl) (("1" (split) (("1" (expand* subtermsOF sigma_lhs empty_seq finseq_appl) (("1" (assert) (("1" (decompose-equality -6) (("1" (inst -1 kk!2) nil nil) ("2" (hide-all-but (-5 1)) (("2" (expand "SPP?") (("2" (flatten) (("2" (expand "SP?") (("2" (expand "finseq_appl") (("2" (inst -2 x!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma replace_par_pos_subterm) (("2" (expand finseq_appl) (("2" (inst -1 fsp2 "sigma_rhs(fss!1, fse!1)" t) (("2" (expand sigma_rhs -1 (1 3)) (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (assert) (("2" (inst -1 kk!2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide-all-but (-4 1)) (("3" (typepred "fse!1" "kk!2") (("3" (replaces -3) (("3" (expand* "subset?" "member") (("3" (expand* "subset?" "member" "seq2set" "finseq_appl") (("3" (inst?) (("3" (assert) (("3" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -4 -6 -8 2)) (("2" (replace -1 1 rl) (("2" (lemma replace_par_pos_preservs_PP) (("2" (expand parallel_reduction_fix?) (("2" (skosimp) (("2" (inst -1 fsp2 "sigma_rhs(fss!1, fse!1)" t) (("2" (assert) (("2" (expand sigma_rhs -1 1) (("2" (expand "finseq_appl") (("2" (inst -1 kk!2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide (-2 -5 -7 -8 2)) (("3" (replace -1 1 rl) (("3" (lemma replace_par_pos_preservs_PP) (("3" (expand parallel_reduction_fix?) (("3" (skosimp) (("3" (inst -1 fsp1 "sigma_rhs(fss!1, fse!1)" t) (("3" (assert) (("3" (expand sigma_rhs -1 1) (("3" (expand "finseq_appl") (("3" (inst -1 kk!1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (replace -1 1 rl) (("4" (hide-all-but (-4 1)) (("4" (expand "SPP?") (("4" (flatten) (("4" (expand "SP?") (("4" (expand "finseq_appl") (("4" (inst -2 kk!1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (typepred "i") (("2" (replaces -2) (("2" (rewrite "set2seq_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((position type-eq-decl nil positions nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set2seq_lem formula-decl nil set2seq structures) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (union const-decl "set" sets nil) (finseq type-eq-decl nil finite_sequences nil) (Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (Pos_Equal const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (fsp2 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (fsp1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (i skolem-const-decl "below[fsp`length]" orthogonality_sets nil) (fsp skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (< const-decl "bool" reals nil) (set2seq_length formula-decl nil set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (set2seq def-decl "finite_sequence[T]" set2seq structures) (below type-eq-decl nil naturalnumbers nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (subtermOF def-decl "term" subterm nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (Parallel_Moves_Lemma formula-decl nil orthogonality_basis nil) (fork_in_Pos_Over formula-decl nil orthogonality_sets nil) (intersection const-decl "set[T]" predicate_fseq2set nil) (seq2set const-decl "finite_set[T]" seq2set structures) (t skolem-const-decl "term" orthogonality_sets nil) (t1 skolem-const-decl "term" orthogonality_sets nil) (t2 skolem-const-decl "term" orthogonality_sets nil) (empty_seq const-decl "finseq" finite_sequences nil) (reflexive? const-decl "bool" relations nil) (parallel_reduction_reflexive formula-decl nil orthogonality_basis nil) (IUnion const-decl "set[T]" indexed_sets nil) (catenate const-decl "positions" positions nil) (add_first const-decl "finseq" seq_extras structures) (insert? const-decl "finseq" seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (only_empty_seq const-decl "positions" positions nil) (reduction_fix? const-decl "bool" reduction nil) (TRUE const-decl "bool" booleans nil) (subset? const-decl "bool" sets nil) (replaceTerm def-decl "term" replacement nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil) (NOT const-decl "[bool -> bool]" booleans nil) (ext def-decl "term" substitution nil) (lhs const-decl "term" rewrite_rules nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (sigma_lhs const-decl "finseq[term]" orthogonality_basis nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (replace_par_pos_subterm formula-decl nil orthogonality_basis nil) (fss!1 skolem-const-decl "finseq[Sub[variable, symbol, arity]]" orthogonality_sets nil) (fse!1 skolem-const-decl "{fse | subset?(fse, E)}" orthogonality_sets nil) (E skolem-const-decl "set[rewrite_rule[variable, symbol, arity]]" orthogonality_sets nil) (subset? const-decl "bool" predicate_fseq2set nil) (kk!1 skolem-const-decl "below(length(fsp1))" orthogonality_sets nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (kk!2 skolem-const-decl "below(length(fsp2))" orthogonality_sets nil) (fse!1 skolem-const-decl "{fse | subset?(fse, E)}" orthogonality_sets nil) (fss!1 skolem-const-decl "finseq[Sub[variable, symbol, arity]]" orthogonality_sets nil) (Orthogonal? const-decl "bool" orthogonality_basis nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (non_ambiguous_implies_same_term formula-decl nil orthogonality_basis nil) (intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak)) (subterms_joinability_TCC1 0 (subterms_joinability_TCC1-1 nil 3673309211 ("" (subtype-tcc) nil nil) ((< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (finseq type-eq-decl nil finite_sequences nil) (set type-eq-decl nil sets nil) (subset? const-decl "bool" predicate_fseq2set nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (SP? const-decl "bool" positions nil) (SPP? const-decl "bool" positions nil) (lhs const-decl "term" rewrite_rules nil) (Pos_var const-decl "positions" subterm nil) (Card const-decl "nat" finite_sets nil) (linear? const-decl "bool" orthogonality_basis nil) (Left_Linear? const-decl "bool" orthogonality_basis nil) (empty_seq const-decl "finseq" finite_sequences nil) (rhs const-decl "term" rewrite_rules nil) (Vars const-decl "set[(V)]" subterm nil) (member const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil) (unifier const-decl "bool" unification nil) (U const-decl "set[Sub[variable, symbol, arity]]" unification nil) (<= const-decl "bool" unification nil) (mgu const-decl "bool" unification nil) (ntCP? const-decl "bool" orthogonality_basis nil) (Ambiguous? const-decl "bool" orthogonality_basis nil) (Orthogonal? const-decl "bool" orthogonality_basis nil) (Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (intersection const-decl "set[T]" predicate_fseq2set nil) (Pos_Equal const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (subterms_joinability subtype "orthogonality_sets.i" "below[length(fst)]"))) (subterms_joinability_TCC2 0 (subterms_joinability_TCC2-1 nil 3673309211 ("" (skosimp*) (("" (lemma subterm_joinability_TCC3) (("" (expand finseq_appl) (("" (inst -1 E!1 fsp!1 fsp1!1 fsp2!1 t!1 t1!1 t2!1) (("" (assert) (("" (inst -1 i!1 "fst!1`seq(i!1)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subterm_joinability_TCC3 subtype-tcc nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil nat_types nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (position type-eq-decl nil positions nil) (finseq type-eq-decl nil finite_sequences nil) (< const-decl "bool" reals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (subterms_joinability subtype "finite_sequences[position[variable, symbol, arity]].finseq_appl(orthogonality_sets.fsp)(orthogonality_sets.i)" "positions[orthogonality_sets.variable, orthogonality_sets.symbol, orthogonality_sets.arity].positions?(orthogonality_sets.t2)"))) (subterms_joinability 0 (subterms_joinability-1 nil 3673313129 ("" (expand finseq_appl) (("" (skeep) (("" (lemma subterm_joinability) (("" (expand finseq_appl) (("" (inst -1 E fsp fsp1 fsp2 t t1 t2) (("" (assert) (("" (expand "SPP?") (("" (flatten) (("" (expand parallel_reduction_fix?) (("" (skosimp*) (("" (lemma seq_construct1[term]) (("" (inst -1 "parallel_reduction?(E)" "subtermsOF(t1, fsp)" "subtermsOF(t2, fsp)" "fsp`length") (("1" (expand subtermsOF -1) (("1" (expand finseq_appl) (("1" (prop) (("1" (skosimp) (("1" (inst 1 "fseq!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand SP? 1) (("2" (expand finseq_appl) (("2" (skeep) (("2" (lemma "set2seq_lem[position]") (("2" (expand finseq_appl) (("2" (inst?) (("2" (replace -15 -1 rl) (("2" (inst?) (("1" (expand* "union" "member") (("1" (prop) (("1" (lemma Pos_Over_character) (("1" (inst -1 "fsp1" "fsp2" "fsp`seq(i)") (("1" (split) (("1" (replace -15 1) (("1" (rewrite replace_par_pos_preservs_pos) (("1" (expand SPP?) (("1" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (hide-all-but (-2 -5 1)) (("1" (expand "Pos_Over") (("1" (lemma set_of_prop_related_nb_is_subset[position]) (("1" (inst?) (("1" (expand* "subset?" "member") (("1" (inst?) (("1" (assert) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (replace -1 1 rl) (("1" (hide (-1 -2)) (("1" (expand* "SP?" "finseq_appl") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand sigma_rhs 1) (("2" (hide-all-but (-13 1)) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (lemma replace_par_pos_preservs_PP) (("2" (expand finseq_appl) (("2" (inst -1 fsp2 "sigma_rhs(fss!2, fse!2)" t) (("2" (expand sigma_rhs -1 1) (("2" (assert) (("2" (inst -1 "i!1") (("2" (lemma closed_positions) (("2" (inst -1 "fsp`seq(i)" "fsp2`seq(i!1)" "t2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma replace_par_pos_preservs_PP) (("2" (expand finseq_appl) (("2" (inst -1 fsp2 "sigma_rhs(fss!2, fse!2)" t) (("2" (expand sigma_rhs -1 1) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) (("2" (expand "Pos_Over") (("2" (lemma set_of_prop_related_nb_is_subset[position]) (("2" (inst?) (("2" (expand* "subset?" "member") (("2" (inst?) (("2" (assert) (("2" (expand* "seq2set" "finseq_appl") (("2" (skosimp) (("2" (replace -1 1 rl) (("2" (hide-all-but (-2 -16 1)) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma replace_par_pos_preservs_PP) (("3" (expand finseq_appl) (("3" (inst -1 fsp2 "sigma_rhs(fss!2, fse!2)" t) (("3" (expand sigma_rhs -1 1) (("3" (expand empty_seq) (("3" (lift-if) (("3" (assert) (("3" (expand "Pos_Equal") (("3" (expand "intersection") (("3" (expand "intersection") (("3" (expand "member") (("3" (flatten) (("3" (hide -2) (("3" (expand "seq2set") (("3" (expand "finseq_appl") (("3" (skosimp) (("3" (replace -2 1 rl) (("3" (hide-all-but (-1 -15 1)) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-14 1)) (("2" (typepred "i") (("2" (replaces -2) (("2" (rewrite "set2seq_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 2) (("3" (expand SP? 1) (("3" (expand finseq_appl) (("3" (skeep) (("3" (lemma "set2seq_lem[position]") (("3" (expand finseq_appl) (("3" (inst?) (("3" (replace -15 -1 rl) (("3" (inst?) (("1" (expand* "union" "member") (("1" (prop) (("1" (lemma replace_par_pos_preservs_PP) (("1" (expand finseq_appl) (("1" (inst -1 fsp1 "sigma_rhs(fss!1, fse!1)" t) (("1" (expand sigma_rhs -1 1) (("1" (expand empty_seq) (("1" (lift-if) (("1" (assert) (("1" (expand "Pos_Over") (("1" (lemma set_of_prop_related_nb_is_subset[position]) (("1" (inst?) (("1" (expand* "subset?" "member") (("1" (inst?) (("1" (assert) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (replace -1 1 rl) (("1" (hide-all-but (-2 -12 1)) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma Pos_Over_character) (("2" (inst -1 "fsp2" "fsp1" "fsp`seq(i)") (("2" (split) (("1" (replace -11 1) (("1" (rewrite replace_par_pos_preservs_pos) (("1" (expand SPP?) (("1" (rewrite add_first_parallel_pos_to_SP_is_SP) (("1" (hide-all-but (-2 -7 1)) (("1" (expand "Pos_Over") (("1" (lemma set_of_prop_related_nb_is_subset[position]) (("1" (inst?) (("1" (expand* "subset?" "member") (("1" (inst?) (("1" (assert) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (replace -1 1 rl) (("1" (hide (-1 -2)) (("1" (expand* "SP?" "finseq_appl") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand sigma_rhs 1) (("2" (hide-all-but (-9 1)) (("2" (expand empty_seq) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (lemma replace_par_pos_preservs_PP) (("2" (expand finseq_appl) (("2" (inst -1 fsp1 "sigma_rhs(fss!1, fse!1)" t) (("2" (expand sigma_rhs -1 1) (("2" (assert) (("2" (inst -1 "i!1") (("2" (lemma closed_positions) (("2" (inst -1 "fsp`seq(i)" "fsp1`seq(i!1)" "t1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (propax) nil nil)) nil)) nil)) nil) ("3" (lemma replace_par_pos_preservs_PP) (("3" (expand finseq_appl) (("3" (inst -1 fsp1 "sigma_rhs(fss!1, fse!1)" t) (("3" (expand sigma_rhs -1 1) (("3" (expand empty_seq) (("3" (lift-if) (("3" (assert) (("3" (expand "Pos_Equal") (("3" (expand "intersection") (("3" (expand "intersection") (("3" (expand "member") (("3" (flatten) (("3" (hide -3) (("3" (expand* "seq2set" "finseq_appl") (("3" (skosimp) (("3" (replace -2 1 rl) (("3" (hide-all-but (-1 -11 1)) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-14 1)) (("2" (typepred "i") (("2" (replaces -2) (("2" (rewrite "set2seq_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SP? const-decl "bool" positions nil) (t1 skolem-const-decl "term" orthogonality_sets nil) (fsp skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (t2 skolem-const-decl "term" orthogonality_sets nil) (PRED type-eq-decl nil defined_types nil) (parallel_reduction? const-decl "bool" orthogonality_basis nil) (SP type-eq-decl nil positions nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (intersection const-decl "set[T]" predicate_fseq2set nil) (intersection const-decl "set" sets nil) (Pos_Over_character formula-decl nil orthogonality_sets nil) (subset? const-decl "bool" predicate_fseq2set nil) (sigma_rhs const-decl "finseq[term]" orthogonality_basis nil) (Sub type-eq-decl nil substitution nil) (Sub? const-decl "bool" substitution nil) (V const-decl "set[term]" variables_term nil) (replace_par_pos_preservs_pos formula-decl nil orthogonality_basis nil) (positions? type-eq-decl nil positions nil) (positionsOF def-decl "positions" positions nil) (positions type-eq-decl nil positions nil) (add_first_parallel_pos_to_SP_is_SP formula-decl nil positions nil) (<= const-decl "bool" positions nil) (seq2set const-decl "finite_set[T]" seq2set structures) (subset? const-decl "bool" sets nil) (set_of_prop_related_nb_is_subset formula-decl nil predicate_fseq2set nil) (empty_seq const-decl "finseq" finite_sequences nil) (replace_par_pos_preservs_PP formula-decl nil orthogonality_basis nil) (closed_positions formula-decl nil positions nil) (set2seq_length formula-decl nil set2seq structures) (finite_sequence type-eq-decl nil finite_sequences nil) (set2seq def-decl "finite_sequence[T]" set2seq structures) (below type-eq-decl nil naturalnumbers nil) (fsp2 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (fsp1 skolem-const-decl "finseq[position[variable, symbol, arity]]" orthogonality_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (i skolem-const-decl "below[length(fsp)]" orthogonality_sets nil) (< const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (union const-decl "set" sets nil) (Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (Pos_Equal const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (set2seq_lem formula-decl nil set2seq structures) (i skolem-const-decl "below[length(fsp)]" orthogonality_sets nil) (seq_construct1 formula-decl nil predicate_fseq2set nil) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (SPP? const-decl "bool" positions nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (set type-eq-decl nil sets nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (subterm_joinability formula-decl nil orthogonality_sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak)) (parallel_reduction_has_DP 0 (parallel_reduction_has_DP-3 nil 3664823465 ("" (auto-rewrite (finseq_appl member)) (("" (skosimp) (("" (expand diamond_property?) (("" (skeep) (("" (expand parallel_reduction? (-2 -3)) (("" (skosimp*) (("" (assert) (("" (typepred fsp!2) (("" (typepred fsp!1) (("" (expand SPP?) (("" (flatten) (("" (lemma Pos_Over_and_Pos_Equal_dominance) (("" (expand "dominates?") (("" (inst-cp -1 fsp!1 fsp!2) (("" (inst -1 fsp!2 fsp!1) (("" (assert) (("" (name-replace "A" "union(Pos_Over(fsp!1, fsp!2), union(Pos_Over(fsp!2, fsp!1), Pos_Equal(fsp!1, fsp!2)))") (("" (case "SPP?(x)(set2seq(A))") (("1" (lemma replace_par_pos_dominance) (("1" (expand "dominates?") (("1" (inst -1 "E!1" "set2seq(A)" "fsp!1" "y" "x") (("1" (assert) (("1" (prop) (("1" (lemma replace_par_pos_dominance) (("1" (expand "dominates?") (("1" (inst -1 "E!1" "set2seq(A)" "fsp!2" "z" "x") (("1" (assert) (("1" (prop) (("1" (hide -4 -5) (("1" (expand* parallel_reduction_fix? finseq_appl) (("1" (skosimp*) (("1" (lemma subterms_joinability) (("1" (expand finseq_appl) (("1" (inst -1 E!1 "set2seq(A)" fsp!1 fsp!2 x y z) (("1" (assert) (("1" (expand A -1 1) (("1" (skosimp) (("1" (lemma parallel_reduction_context) (("1" (expand finseq_appl) (("1" (inst 1 "replace_par_pos(x, set2seq(A), fst!1)") (("1" (split) (("1" (inst -1 "E!1" "set2seq(A)" "subtermsOF(y, set2seq(A))" "fst!1" "x") (("1" (assert) (("1" (expand subtermsOF 2) (("1" (assert) (("1" (skeep 2) (("1" (inst -2 i) (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "E!1" "set2seq(A)" "subtermsOF(z, set2seq(A))" "fst!1" "x") (("2" (assert) (("2" (expand subtermsOF 2) (("2" (assert) (("2" (skeep 2) (("2" (inst -2 i) (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "E!1" "set2seq(A)" "subtermsOF(z, set2seq(A))" "fst!1" "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "x!1") (("2" (assert) (("2" (skosimp) (("2" (expand* "union" "member") (("2" (split) (("1" (inst 1 "y!1") (("1" (rewrite "set2seq_seq2set_is_set") (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (expand A) (("1" (expand* "union" "member") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand A) (("2" (expand "Pos_Over") (("2" (rewrite "finite_union") (("1" (hide 2) (("1" (rewrite "finite_union") (("1" (hide 2) (("1" (expand "Pos_Equal") (("1" (expand "intersection") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "set_of_prop_related_nb_is_finite") nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "set_of_prop_related_nb_is_finite") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -5 1)) (("2" (inst 1 "y!1") (("2" (rewrite "set2seq_seq2set_is_set") (("1" (assert) (("1" (expand A) (("1" (expand* "union" "member") nil nil)) nil)) nil) ("2" (hide (-1 -2 2)) (("2" (expand A) (("2" (expand "Pos_Over") (("2" (rewrite "finite_union") (("1" (hide 2) (("1" (rewrite "finite_union") (("1" (hide 2) (("1" (expand "Pos_Equal") (("1" (expand "intersection") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "set_of_prop_related_nb_is_finite") nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "set_of_prop_related_nb_is_finite") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2 -4 -5 -7 -9 1)) (("3" (expand "Pos_Equal") (("3" (expand "intersection") (("3" (expand "intersection") (("3" (expand "member") (("3" (flatten) (("3" (inst 1 "y!1") (("3" (rewrite "set2seq_seq2set_is_set") (("1" (assert) (("1" (expand A) (("1" (expand* "union" "member") (("1" (expand "Pos_Equal") (("1" (expand "intersection") (("1" (expand "intersection") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand A) (("2" (expand "Pos_Over") (("2" (rewrite "finite_union") (("1" (hide 2) (("1" (rewrite "finite_union") (("1" (hide 2) (("1" (expand "Pos_Equal") (("1" (expand "intersection") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "set_of_prop_related_nb_is_finite") nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "set_of_prop_related_nb_is_finite") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but (-1 -4 1)) (("2" (inst -2 "x!1") (("2" (assert) (("2" (skosimp) (("2" (inst?) (("2" (rewrite "set2seq_seq2set_is_set") (("1" (assert) nil nil) ("2" (hide (-1 -2 -3 2)) (("2" (expand A) (("2" (expand "Pos_Over") (("2" (rewrite "finite_union") (("1" (hide 2) (("1" (rewrite "finite_union") (("1" (hide 2) (("1" (expand "Pos_Equal") (("1" (expand "intersection") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "set_of_prop_related_nb_is_finite") nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "set_of_prop_related_nb_is_finite") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -5 -6 1)) (("2" (expand "SPP?") (("2" (split) (("1" (expand A) (("1" (rewrite Pos_Over_and_Pos_Equal_is_PP) nil nil)) nil) ("2" (hide (-1 -3)) (("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (lemma "set2seq_lem[position]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "i") (("2" (expand "A" -1 1) (("2" (expand* "union" "subset?" "member") (("2" (split) (("1" (hide -3) (("1" (lemma "set_of_prop_related_nb_is_subset[position]") (("1" (inst -1 "<=" "fsp!1" "fsp!2") (("1" (expand* "subset?" "member") (("1" (inst?) (("1" (expand "Pos_Over") (("1" (assert) (("1" (expand* "seq2set" "finseq_appl") (("1" (skosimp) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (lemma "set_of_prop_related_nb_is_subset[position]") (("2" (inst -1 "<=" "fsp!2" "fsp!1") (("2" (expand* "subset?" "member") (("2" (inst?) (("2" (expand "Pos_Over") (("2" (assert) (("2" (expand* "seq2set" "finseq_appl") (("2" (skosimp) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -3) (("3" (expand "Pos_Equal") (("3" (expand "intersection") (("3" (expand "intersection") (("3" (expand "member") (("3" (flatten) (("3" (hide -2) (("3" (expand* "seq2set" "finseq_appl") (("3" (skosimp) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "A") (("3" (expand "Pos_Over") (("3" (rewrite "finite_union") (("1" (hide 2) (("1" (rewrite "finite_union") (("1" (hide 2) (("1" (expand "Pos_Equal") (("1" (expand "intersection") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "set_of_prop_related_nb_is_finite") nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "set_of_prop_related_nb_is_finite") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((SPP type-eq-decl nil positions nil) (SPP? const-decl "bool" positions nil) (finseq type-eq-decl nil finite_sequences nil) (position type-eq-decl nil positions nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (term type-decl nil term_adt nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Pos_Over_and_Pos_Equal_dominance formula-decl nil orthogonality_sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (finite_sequence type-eq-decl nil finite_sequences nil) (set2seq def-decl "finite_sequence[T]" set2seq structures) (parallel_reduction_fix? const-decl "bool" orthogonality_basis nil) (subterms_joinability formula-decl nil orthogonality_sets nil) (A skolem-const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (parallel_reduction_context formula-decl nil orthogonality_basis nil) (fst!1 skolem-const-decl "finseq[term]" orthogonality_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (replace_par_pos def-decl "term" orthogonality_basis nil) (subtermsOF const-decl "finseq[term]" orthogonality_basis nil) (SP type-eq-decl nil positions nil) (SP? const-decl "bool" positions nil) (< const-decl "bool" reals nil) (set2seq_length formula-decl nil set2seq structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (set2seq_seq2set_is_set formula-decl nil predicate_fseq2set nil) (<= const-decl "bool" positions nil) (set_of_prop_related_nb const-decl "set[T]" predicate_fseq2set nil) (PRED type-eq-decl nil defined_types nil) (finite_union judgement-tcc nil finite_sets nil) (intersection const-decl "set[T]" predicate_fseq2set nil) (finite_intersection2 application-judgement "finite_set[position[variable, symbol, arity]]" orthogonality_sets nil) (set_of_prop_related_nb_is_finite formula-decl nil predicate_fseq2set nil) (intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (replace_par_pos_dominance formula-decl nil orthogonality_basis nil) (below type-eq-decl nil naturalnumbers nil) (seq2set const-decl "finite_set[T]" seq2set structures) (subset? const-decl "bool" sets nil) (set_of_prop_related_nb_is_subset formula-decl nil predicate_fseq2set nil) (set2seq_lem formula-decl nil set2seq structures) (Pos_Over_and_Pos_Equal_is_PP formula-decl nil orthogonality_sets nil) (Pos_Equal const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (Pos_Over const-decl "set[position[variable, symbol, arity]]" orthogonality_sets nil) (union const-decl "set" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (dominates? const-decl "bool" predicate_fseq2set nil) (parallel_reduction? const-decl "bool" orthogonality_basis nil) (diamond_property? const-decl "bool" ars_terminology nil)) nil) (parallel_reduction_has_DP-2 nil 3664806969 ("" (auto-rewrite (finseq_appl member)) (("" (skosimp) (("" (expand diamond_property?) (("" (skeep) (("" (expand parallel_reduction? (-2 -3)) (("" (skosimp*) (("" (assert) (("" (lemma Pos_Over_and_Pos_Equal_dominance) (("" (expand "dominates?") (("" (inst-cp -1 fsp!1 fsp!2 x) (("" (inst -1 fsp!2 fsp!1 x) (("" (assert) (("" (name-replace "A" "Pos_Over(fsp!1, fsp!2) o
                                             Pos_Over(fsp!2, fsp!1)
                                             o Pos_Equal(fsp!1, fsp!2)") (("1" (case "SPP?(x)(A)") (("1" (lemma replace_par_pos_dominance) (("1" (expand "dominates?") (("1" (inst -1 E!1 A fsp!1 y x) (("1" (assert) (("1" (prop) (("1" (lemma replace_par_pos_dominance) (("1" (expand "dominates?") (("1" (inst -1 E!1 A fsp!2 z x) (("1" (assert) (("1" (prop) (("1" (hide -4 -5) (("1" (expand* parallel_reduction_fix? finseq_appl) (("1" (skosimp*) (("1" (lemma subterms_joinability) (("1" (expand finseq_appl) (("1" (inst -1 E!1 A fsp!1 fsp!2 x y z) (("1" (assert) (("1" (expand A -1 1) (("1" (skosimp) (("1" (lemma parallel_reduction_context) (("1" (expand finseq_appl) (("1" (inst 1 "replace_par_pos(x, A, fst!1)") (("1" (split) (("1" (inst -1 E!1 A "subtermsOF(y, A)" fst!1 x) (("1" (assert) (("1" (expand subtermsOF 2) (("1" (assert) (("1" (skeep 2) (("1" (inst -2 i) (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 E!1 A "subtermsOF(z, A)" fst!1 x) (("2" (assert) (("2" (expand subtermsOF 2) (("2" (expand finseq_appl) (("2" (skeep 2) (("2" (inst -2 i) (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -3 i) (("2" (skosimp) (("2" (expand o -3) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (inst 1 "j!1 + Pos_Over(fsp!1, fsp!2)`length") (("1" (expand A 1) (("1" (expand o 1) (("1" (assert) nil nil)) nil)) nil) ("2" (expand A 1) (("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (inst 2 "j!1 - Pos_Over(fsp!2, fsp!1)`length") (("1" (expand A 2) (("1" (expand o 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand A 1) (("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -2 -4 -5 -6 -7 3) (("3" (lemma Pos_Equal_is_sub_seq) (("3" (inst -1 fsp!2 fsp!1) (("3" (typepred (fsp!1 fsp!2)) (("3" (expand* SPP?) (("3" (flatten) (("3" (assert) (("3" (lemma Pos_Equal_character) (("3" (inst -1 fsp!2 fsp!1) (("3" (assert) (("3" (expand* subseq finseq_appl) (("3" (inst -1 "-1 * Pos_Over(fsp!1, fsp!2)`length - Pos_Over(fsp!2, fsp!1)`length + j!1") (("1" (inst -6 "-1 * Pos_Over(fsp!1, fsp!2)`length - Pos_Over(fsp!2, fsp!1)`length + j!1") (("1" (lemma same_pos_in_Pos_Equal) (("1" (inst -1 fsp!1 fsp!2 "Pos_Equal(fsp!2, fsp!1)`seq
                                     (-1 * Pos_Over(fsp!1, fsp!2)`length - Pos_Over(fsp!2, fsp!1)`length + j!1)") (("1" (assert) (("1" (hide -7) (("1" (expand* member_seq finseq_appl) (("1" (prop) (("1" (skosimp) (("1" (inst 2 "i!1 + Pos_Over(fsp!1, fsp!2)`length + Pos_Over(fsp!2, fsp!1)`length") (("1" (expand A 2) (("1" (expand o 2) (("1" (assert) nil nil)) nil)) nil) ("2" (expand A 1) (("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred j!1) (("2" (expand o -1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred j!1) (("2" (expand o -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -3 i) (("2" (skosimp) (("2" (inst 1 j!1) (("2" (expand A 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand A 1) (("2" (typepred (fsp!1 fsp!2)) (("2" (expand SPP?) (("2" (flatten) (("2" (rewrite Pos_Over_and_Pos_Equal_is_PP) (("2" (expand o 1) (("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (prop) (("1" (lemma Pos_Over_is_sub_seq) (("1" (inst -1 fsp!1 fsp!2) (("1" (assert) (("1" (expand* subseq finseq_appl) (("1" (inst -1 i) (("1" (expand* member_seq finseq_appl) (("1" (skosimp) (("1" (inst -5 i!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma Pos_Over_is_sub_seq) (("2" (inst -1 fsp!2 fsp!1) (("2" (assert) (("2" (expand* subseq finseq_appl) (("2" (inst -1 "i - Pos_Over(fsp!1, fsp!2)`length") (("2" (expand* member_seq finseq_appl) (("2" (skosimp) (("2" (inst -6 i!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma Pos_Equal_is_sub_seq) (("3" (inst -1 fsp!1 fsp!2) (("3" (assert) (("3" (expand* subseq member_seq finseq_appl) (("3" (inst -1 "-1 * Pos_Over(fsp!1, fsp!2)`length - Pos_Over(fsp!2, fsp!1)`length + i") (("3" (skosimp) (("3" (inst -3 i!1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred fsp!2) (("2" (expand SPP?) (("2" (flatten) nil nil)) nil)) nil) ("3" (typepred fsp!1) (("3" (expand SPP?) (("3" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((O const-decl "finseq" finite_sequences nil) (set type-eq-decl nil sets nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (term type-decl nil term_adt nil) (finseq type-eq-decl nil finite_sequences nil)) nil) (parallel_reduction_has_DP-1 nil 3549740761 ("" (auto-rewrite (finseq_appl member)) (("" (skosimp) (("" (expand diamond_property?) (("" (skeep) (("" (expand parallel_reduction? (-2 -3)) (("" (skosimp*) (("" (assert) (("" (lemma Pos_Over_and_Pos_Equal_dominance) (("" (inst-cp -1 fsp!1 fsp!2 x) (("" (inst -1 fsp!2 fsp!1 x) (("" (assert) (("" (name-replace "A" "Pos_Over(fsp!1, fsp!2) o
                                           Pos_Over(fsp!2, fsp!1)
                                           o Pos_Equal(fsp!1, fsp!2)") (("1" (case "SPP?(x)(A)") (("1" (lemma replace_par_pos_dominance) (("1" (inst -1 E!1 A fsp!1 y x) (("1" (assert) (("1" (prop) (("1" (lemma replace_par_pos_dominance) (("1" (inst -1 E!1 A fsp!2 z x) (("1" (assert) (("1" (prop) (("1" (hide -4 -5) (("1" (expand* parallel_reduction_fix? finseq_appl) (("1" (skosimp*) (("1" (lemma subterms_joinability) (("1" (expand finseq_appl) (("1" (inst -1 E!1 A fsp!1 fsp!2 x y z) (("1" (assert) (("1" (expand A -1 1) (("1" (skosimp) (("1" (lemma parallel_reduction_context) (("1" (expand finseq_appl) (("1" (inst 1 "replace_par_pos(x, A, fst!1)") (("1" (split) (("1" (inst -1 E!1 A "subtermsOF(y, A)" fst!1 x) (("1" (assert) (("1" (expand subtermsOF 2) (("1" (assert) (("1" (skeep 2) (("1" (inst -2 i) (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 E!1 A "subtermsOF(z, A)" fst!1 x) (("2" (assert) (("2" (expand subtermsOF 2) (("2" (expand finseq_appl) (("2" (skeep 2) (("2" (inst -2 i) (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -3 i) (("2" (skosimp) (("2" (expand o -3) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (inst 1 "j!1 + Pos_Over(fsp!1, fsp!2)`length") (("1" (expand A 1) (("1" (expand o 1) (("1" (assert) nil nil)) nil)) nil) ("2" (expand A 1) (("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (inst 2 "j!1 - Pos_Over(fsp!2, fsp!1)`length") (("1" (expand A 2) (("1" (expand o 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand A 1) (("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -2 -4 -5 -6 -7 3) (("3" (lemma Pos_Equal_is_sub_seq) (("3" (inst -1 fsp!2 fsp!1) (("3" (typepred (fsp!1 fsp!2)) (("3" (expand* SPP?) (("3" (flatten) (("3" (assert) (("3" (lemma Pos_Equal_character) (("3" (inst -1 fsp!2 fsp!1) (("3" (assert) (("3" (expand* subseq finseq_appl) (("3" (inst -1 "-1 * Pos_Over(fsp!1, fsp!2)`length - Pos_Over(fsp!2, fsp!1)`length + j!1") (("1" (inst -6 "-1 * Pos_Over(fsp!1, fsp!2)`length - Pos_Over(fsp!2, fsp!1)`length + j!1") (("1" (lemma same_pos_in_Pos_Equal) (("1" (inst -1 fsp!1 fsp!2 "Pos_Equal(fsp!2, fsp!1)`seq
                     (-1 * Pos_Over(fsp!1, fsp!2)`length - Pos_Over(fsp!2, fsp!1)`length + j!1)") (("1" (assert) (("1" (hide -7) (("1" (expand* member_seq finseq_appl) (("1" (prop) (("1" (skosimp) (("1" (inst 2 "i!1 + Pos_Over(fsp!1, fsp!2)`length + Pos_Over(fsp!2, fsp!1)`length") (("1" (expand A 2) (("1" (expand o 2) (("1" (assert) nil nil)) nil)) nil) ("2" (expand A 1) (("2" (expand o 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred j!1) (("2" (expand o -1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred j!1) (("2" (expand o -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -3 i) (("2" (skosimp) (("2" (inst 1 j!1) (("2" (expand A 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand A 1) (("2" (typepred (fsp!1 fsp!2)) (("2" (expand SPP?) (("2" (flatten) (("2" (rewrite Pos_Over_and_Pos_Equal_is_PP) (("2" (expand o 1) (("2" (expand* SP? finseq_appl) (("2" (skeep) (("2" (prop) (("1" (lemma Pos_Over_is_sub_seq) (("1" (inst -1 fsp!1 fsp!2) (("1" (assert) (("1" (expand* subseq finseq_appl) (("1" (inst -1 i) (("1" (expand* member_seq finseq_appl) (("1" (skosimp) (("1" (inst -5 i!1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma Pos_Over_is_sub_seq) (("2" (inst -1 fsp!2 fsp!1) (("2" (assert) (("2" (expand* subseq finseq_appl) (("2" (inst -1 "i - Pos_Over(fsp!1, fsp!2)`length") (("2" (expand* member_seq finseq_appl) (("2" (skosimp) (("2" (inst -6 i!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma Pos_Equal_is_sub_seq) (("3" (inst -1 fsp!1 fsp!2) (("3" (assert) (("3" (expand* subseq member_seq finseq_appl) (("3" (inst -1 "-1 * Pos_Over(fsp!1, fsp!2)`length - Pos_Over(fsp!2, fsp!1)`length + i") (("3" (skosimp) (("3" (inst -3 i!1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred fsp!2) (("2" (expand SPP?) (("2" (flatten) nil nil)) nil)) nil) ("3" (typepred fsp!1) (("3" (expand SPP?) (("3" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((O const-decl "finseq" finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (set type-eq-decl nil sets nil) (term type-decl nil term_adt nil) (finseq type-eq-decl nil finite_sequences nil)) shostak)) (Orthogonal_implies_confluent 0 (Orthogonal_implies_confluent-1 nil 3445676656 ("" (skosimp) (("" (assert) (("" (expand confluent?) (("" (skeep) (("" (lemma parallel_reduction_RTC) (("" (inst -1 E!1) (("" (expand joinable?) (("" (lemma parallel_reduction_has_DP) (("" (inst -1 E!1) (("" (lemma DP_implies_StC) (("" (inst -1 "parallel_reduction?(E!1)") (("" (assert) (("" (lemma Strong_Confl_implies_Confl) (("" (inst -1 "parallel_reduction?(E!1)") (("" (assert) (("" (expand confluent?) (("" (inst -1 x y z) (("" (assert) (("" (expand joinable?) (("" (skosimp) (("" (inst 1 z!1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((term type-decl nil term_adt nil) (rewrite_rule? const-decl "bool" rewrite_rules nil) (rewrite_rule type-eq-decl nil rewrite_rules nil) (set type-eq-decl nil sets nil) (Orthogonal? const-decl "bool" orthogonality_basis nil) (Orthogonal type-eq-decl nil orthogonality_basis nil) (parallel_reduction_has_DP formula-decl nil orthogonality_sets nil) (DP_implies_StC formula-decl nil results_confluence nil) (Strong_Confl_implies_Confl formula-decl nil results_confluence nil) (PRED type-eq-decl nil defined_types nil) (parallel_reduction? const-decl "bool" orthogonality_basis nil) (joinable? const-decl "bool" ars_terminology nil) (parallel_reduction_RTC formula-decl nil orthogonality_basis nil) (variable formal-nonempty-type-decl nil orthogonality_sets nil) (symbol formal-nonempty-type-decl nil orthogonality_sets nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity formal-const-decl "[symbol -> nat]" orthogonality_sets nil) (confluent? const-decl "bool" ars_terminology nil)) shostak)))
