(|counting_pvs0_type| (G_TCC1 0 (G_TCC1-1 |nil| 3665445335 ("" (LEMMA "T_bij_nat") (("" (SKEEP) (("" (INST?) NIL NIL)) NIL)) NIL) ((FF SKOLEM-CONST-DECL "[T -> nat]" |counting_pvs0_type| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|injective?| CONST-DECL "bool" |functions| NIL) (|T_bij_nat| FORMULA-DECL NIL |counting_pvs0_type| NIL)) NIL (G EXISTENCE "" "{F: [counting_pvs0_type.T -> naturalnumbers.nat] | functions[counting_pvs0_type.T, nat].injective?(F)}"))) (|base_TCC1| 0 (|base_TCC1-2| "" 3885321997 ("" (SKEEP) (("" (EXPAND "is_finite") (("" (INST + "n+2" "LAMBDA (e:(inbase(n))): IF cnst?(e) and G(get_val(e))<=n then G(get_val(e)) ELSE n+1 ENDIF") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (LIFT-IF -3) (("1" (SPLIT -3) (("1" (FLATTEN) (("1" (TYPEPRED "G") (("1" (EXPAND "injective?") (("1" (INST?) (("1" (ASSERT) (("1" (LEMMA "PVS0Expr_cnst_extensionality") (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (TYPEPRED "x1") (("2" (EXPAND "inbase") (("2" (SPLIT -1) (("1" (TYPEPRED "x2") (("1" (EXPAND "inbase") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF -1) (("2" (SPLIT -1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (TYPEPRED "x1") (("2" (EXPAND "inbase") (("2" (SPLIT -1) (("1" (TYPEPRED "x2") (("1" (EXPAND "inbase") (("1" (SPLIT -1) (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|base| SUBTYPE "counting_pvs0_type.inbase(counting_pvs0_type.n)" "finite_set[PVS0Expr[T]]")) (|base_TCC1-1| |nil| 3664903592 ("" (SKEEP) (("" (EXPAND "is_finite") (("" (INST + "n+2" "LAMBDA (e:(inbase(n))): IF cnst?(e) and G(get_val(e))<=n then G(get_val(e)) ELSE n+1 ENDIF") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (LIFT-IF -1) (("1" (SPLIT -1) (("1" (FLATTEN) (("1" (LIFT-IF -3) (("1" (SPLIT -3) (("1" (FLATTEN) (("1" (TYPEPRED (G)) (("1" (EXPAND "injective?") (("1" (INST?) (("1" (ASSERT) (("1" (LEMMA "PVS0Expr_cnst_extensionality") (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (TYPEPRED (X1)) (("2" (EXPAND "inbase") (("2" (SPLIT -1) (("1" (TYPEPRED (X2)) (("1" (EXPAND "inbase") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LIFT-IF -1) (("2" (SPLIT -1) (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL) ("2" (TYPEPRED (X1)) (("2" (EXPAND "inbase") (("2" (SPLIT -1) (("1" (TYPEPRED (X2)) (("1" (EXPAND "inbase") (("1" (SPLIT -1) (("1" (ASSERT) NIL NIL) ("2" (FLATTEN) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (ASSERT) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|PVS0Expr_cnst_extensionality| FORMULA-DECL NIL |PVS0Expr_adt| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL) (|PVS0Expr| TYPE-DECL NIL |PVS0Expr_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|inbase| CONST-DECL "bool" |counting_pvs0_type| NIL) (|n| SKOLEM-CONST-DECL "nat" |counting_pvs0_type| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|cnst?| ADT-RECOGNIZER-DECL "[PVS0Expr -> boolean]" |PVS0Expr_adt| NIL) (<= CONST-DECL "bool" |reals| NIL) (|injective?| CONST-DECL "bool" |functions| NIL) (G CONST-DECL "{F: [T -> nat] | injective?(F)}" |counting_pvs0_type| NIL) (|get_val| ADT-ACCESSOR-DECL "[(cnst?) -> T]" |PVS0Expr_adt| NIL) (< CONST-DECL "bool" |reals| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL)) NIL (|base| SUBTYPE "counting_pvs0_type.inbase(counting_pvs0_type.n)" "finite_set[PVS0Expr[T]]"))) (|inop1_at_TCC1| 0 (|inop1_at_TCC1-1| |nil| 3665481394 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|inop1_at| SUBTYPE "counting_pvs0_type.e" "{x: PVS0Expr_adt[counting_pvs0_type.T].PVS0Expr | booleans.OR(PVS0Expr_adt[counting_pvs0_type.T].op1?(x), PVS0Expr_adt[counting_pvs0_type.T].rec?(x))}"))) (|inop1_at_TCC2| 0 (|inop1_at_TCC2-1| |nil| 3665481394 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL) (|PVS0Expr| TYPE-DECL NIL |PVS0Expr_adt| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|member| CONST-DECL "bool" |sets| NIL)) NIL (|inop1_at| SUBTYPE "counting_pvs0_type.e" "{x: PVS0Expr_adt[counting_pvs0_type.T].PVS0Expr | booleans.OR(PVS0Expr_adt[counting_pvs0_type.T].op1?(x), PVS0Expr_adt[counting_pvs0_type.T].op2?(x))}"))) (|op1_at_TCC1| 0 (|op1_at_TCC1-2| "" 3885322057 ("" (SKEEP) (("" (TYPEPRED "fexp") (("" (EXPAND "is_finite") (("" (SKEEP) (("" (INST 1 "N" "lambda(e: (inop1_at(fexp, n))): f(get_arg(e))") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (INST -1 "get_arg(x1)" "get_arg(x2)") (("1" (ASSERT) (("1" (LEMMA "PVS0Expr_op1_extensionality") (("1" (INST -1 "x1" "x2") (("1" (ASSERT) (("1" (TYPEPRED "x1") (("1" (TYPEPRED "x2") (("1" (EXPAND "inop1_at") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "x2") (("2" (ASSERT) (("2" (EXPAND "inop1_at") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED "x1") (("3" (EXPAND "inop1_at") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP :PREDS? T) (("2" (EXPAND "inop1_at") (("2" (EXPAND "member") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (SKEEP :PREDS? T) (("3" (ASSERT) (("3" (EXPAND "inop1_at") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|op1_at| SUBTYPE "counting_pvs0_type.inop1_at(counting_pvs0_type.fexp, counting_pvs0_type.n)" "finite_set[PVS0Expr[T]]")) (|op1_at_TCC1-1| |nil| 3665449744 ("" (SKEEP) (("" (TYPEPRED (FEXP)) (("" (EXPAND "is_finite") (("" (SKEEP) (("" (INST 1 "N" "lambda(e: (inop1_at(fexp, n))): f(get_arg(e))") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (INST -1 "get_arg(x1)" "get_arg(x2)") (("1" (ASSERT) (("1" (LEMMA "PVS0Expr_op1_extensionality") (("1" (INST -1 "x1" "x2") (("1" (ASSERT) (("1" (TYPEPRED (X1)) (("1" (TYPEPRED (X2)) (("1" (EXPAND "inop1_at") (("1" (FLATTEN) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (X2)) (("2" (ASSERT) (("2" (EXPAND "inop1_at") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("3" (TYPEPRED (X1)) (("3" (EXPAND "inop1_at") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP :PREDS? T) (("2" (EXPAND "inop1_at") (("2" (EXPAND "member") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (SKEEP :PREDS? T) (("3" (ASSERT) (("3" (EXPAND "inop1_at") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|PVS0Expr| TYPE-DECL NIL |PVS0Expr_adt| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|member| CONST-DECL "bool" |sets| NIL) (|injective?| CONST-DECL "bool" |functions| NIL) (|PVS0Expr_op1_extensionality| FORMULA-DECL NIL |PVS0Expr_adt| NIL) (|x2| SKOLEM-CONST-DECL "(inop1_at(fexp, n))" |counting_pvs0_type| NIL) (|x1| SKOLEM-CONST-DECL "(inop1_at(fexp, n))" |counting_pvs0_type| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|inop1_at| CONST-DECL "bool" |counting_pvs0_type| NIL) (|fexp| SKOLEM-CONST-DECL "finite_set[PVS0Expr[T]]" |counting_pvs0_type| NIL) (|n| SKOLEM-CONST-DECL "nat" |counting_pvs0_type| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|op1?| ADT-RECOGNIZER-DECL "[PVS0Expr -> boolean]" |PVS0Expr_adt| NIL) (|rec?| ADT-RECOGNIZER-DECL "[PVS0Expr -> boolean]" |PVS0Expr_adt| NIL) (|get_arg| SHARED-ADT-ACCESSOR-DECL "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" |PVS0Expr_adt| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (< CONST-DECL "bool" |reals| NIL)) NIL (|op1_at| SUBTYPE "counting_pvs0_type.inop1_at(counting_pvs0_type.fexp, counting_pvs0_type.n)" "finite_set[PVS0Expr[T]]"))) (|op1_upto_TCC1| 0 (|op1_upto_TCC1-2| |nil| 3665775964 ("" (SKOLEM 1 ("fexp" "_")) (("" (INDUCT "n") (("1" (CASE-REPLACE "inop1_upto(fexp, 0) = inop1_at(fexp, 0)") (("1" (ASSERT) (("1" (LEMMA "op1_at_TCC1") (("1" (INST?) NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "inop1_upto") (("2" (EXPAND "inop1_at") (("2" (ASSERT) (("2" (IFF) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (CASE "inop1_upto(fexp, j+1) = union(inop1_upto(fexp, j), inop1_at(fexp, j+1))") (("1" (LEMMA "op1_at_TCC1") (("1" (INST?) (("1" (REPLACES -2) (("1" (ASSERT) (("1" (LEMMA "finite_union[PVS0Expr[T]]") (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "union") (("2" (IFF) (("2" (GROUND) (("1" (EXPAND "inop1_upto") (("1" (EXPAND "member") (("1" (EXPAND "inop1_at") (("1" (FLATTEN) (("1" (EXPAND "member") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "inop1_upto") (("2" (EXPAND "member") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "member") (("3" (EXPAND "inop1_at") (("3" (EXPAND "inop1_upto") (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL) (|PVS0Expr| TYPE-DECL NIL |PVS0Expr_adt| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|inop1_upto| CONST-DECL "bool" |counting_pvs0_type| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|op1_at_TCC1| SUBTYPE-TCC NIL |counting_pvs0_type| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|inop1_at| CONST-DECL "bool" |counting_pvs0_type| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|union| CONST-DECL "set" |sets| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|finite_union| JUDGEMENT-TCC NIL |finite_sets| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|member| CONST-DECL "bool" |sets| NIL)) NIL (|op1_upto| SUBTYPE "counting_pvs0_type.inop1_upto(counting_pvs0_type.fexp, counting_pvs0_type.n)" "finite_set[PVS0Expr[T]]"))) (|inop2_at_TCC1| 0 (|inop2_at_TCC1-1| |nil| 3665481394 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL) (|PVS0Expr| TYPE-DECL NIL |PVS0Expr_adt| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|member| CONST-DECL "bool" |sets| NIL)) NIL (|inop2_at| SUBTYPE "counting_pvs0_type.e" "{x: PVS0Expr_adt[counting_pvs0_type.T].PVS0Expr | booleans.OR(PVS0Expr_adt[counting_pvs0_type.T].op1?(x), PVS0Expr_adt[counting_pvs0_type.T].op2?(x))}"))) (|finpair_TCC1| 0 (|finpair_TCC1-2| "" 3885322109 ("" (SKEEP :PREDS? T) (("" (EXPAND "is_finite") (("" (SKEEP) (("" (NAME "F" "lambda(e: (infinpair(fexp))): (f(e`1), f(e`2))") (("1" (CASE "injective?[(infinpair(fexp)), [below[N], below[N]]](F)") (("1" (LEMMA "is_finite_cross[below[N], below[N]]") (("1" (ASSERT) (("1" (EXPAND "is_finite_type") (("1" (CASE "EXISTS (M:nat), (g: [below[N] -> below[M]]): injective?(g)") (("1" (GROUND) (("1" (SKEEP :PREDS? T) (("1" (INST 1 "N!1" "g o F") (("1" (LEMMA "composition_injective[(infinpair(fexp)), [below[N], below[N]], below[N!1]]") (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (INST 1 "N" "id") (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (EXPAND "id") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (EXPAND "F") (("2" (DECOMPOSE-EQUALITY 1) (("1" (FLATTEN) (("1" (INST -4 "x1`1" "x2`1") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (INST -3 "x1`2" "x2`2") (("2" (ASSERT) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (TYPEPRED "e") (("2" (EXPAND "infinpair") (("2" (EXPAND "member") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED "e") (("3" (EXPAND "infinpair") (("3" (EXPAND "member") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|finpair| SUBTYPE "counting_pvs0_type.infinpair(counting_pvs0_type.fexp)" "finite_set[[PVS0Expr[T], PVS0Expr[T]]]")) (|finpair_TCC1-1| |nil| 3665489802 ("" (SKEEP :PREDS? T) (("" (EXPAND "is_finite") (("" (SKEEP) (("" (NAME "F" "lambda(e: (infinpair(fexp))): (f(e`1), f(e`2))") (("1" (CASE "injective?[(infinpair(fexp)), [below[N], below[N]]](F)") (("1" (LEMMA "is_finite_cross[below[N], below[N]]") (("1" (ASSERT) (("1" (EXPAND "is_finite_type") (("1" (CASE "EXISTS (M:nat), (g: [below[N] -> below[M]]): injective?(g)") (("1" (GROUND) (("1" (SKEEP :PREDS? T) (("1" (INST 1 "N!1" "g o F") (("1" (LEMMA "composition_injective[(infinpair(fexp)), [below[N], below[N]], below[N!1]]") (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (INST 1 "N" "id") (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (EXPAND "id") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (EXPAND "F") (("2" (DECOMPOSE-EQUALITY 1) (("1" (FLATTEN) (("1" (INST -4 "x1`1" "x2`1") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (INST -3 "x1`2" "x2`2") (("2" (ASSERT) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (TYPEPRED (E)) (("2" (EXPAND "infinpair") (("2" (EXPAND "member") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED (E)) (("3" (EXPAND "infinpair") (("3" (EXPAND "member") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|is_finite| CONST-DECL "bool" |finite_sets| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL) (|PVS0Expr| TYPE-DECL NIL |PVS0Expr_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|infinpair| CONST-DECL "bool" |counting_pvs0_type| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (F SKOLEM-CONST-DECL "[(infinpair(fexp)) -> [below[N], below[N]]]" |counting_pvs0_type| NIL) (|is_finite_cross| FORMULA-DECL NIL |finite_cross| |finite_sets|) (|is_finite_type| CONST-DECL "bool" |finite_sets| NIL) (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL) (|bijective?| CONST-DECL "bool" |functions| NIL) (O CONST-DECL "T3" |function_props| NIL) (N SKOLEM-CONST-DECL "nat" |counting_pvs0_type| NIL) (N!1 SKOLEM-CONST-DECL "nat" |counting_pvs0_type| NIL) (|g| SKOLEM-CONST-DECL "[[below[N], below[N]] -> below[N!1]]" |counting_pvs0_type| NIL) (|composition_injective| JUDGEMENT-TCC NIL |function_props| NIL) (|injective?| CONST-DECL "bool" |functions| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|member| CONST-DECL "bool" |sets| NIL)) NIL (|finpair| SUBTYPE "counting_pvs0_type.infinpair(counting_pvs0_type.fexp)" "finite_set[[PVS0Expr[T], PVS0Expr[T]]]"))) (|op2_at_TCC1| 0 (|op2_at_TCC1-2| "" 3885322149 ("" (SKEEP) (("" (LEMMA "finpair_TCC1") (("" (INST?) (("" (EXPAND "is_finite") (("" (SKEEP) (("" (NAME "F" "lambda (ee:(inop2_at(fexp, n))): (get_arg1(ee), get_arg2(ee)) ") (("1" (CASE "injective?[ (inop2_at(fexp, n)), (infinpair(fexp))](F)") (("1" (INST 1 "N" " f o F") (("1" (ASSERT) (("1" (LEMMA "composition_injective[(inop2_at(fexp, n)), (infinpair(fexp)), below[N]]") (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-2 2)) (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (EXPAND "F") (("2" (TYPEPRED "x1") (("2" (EXPAND "inop2_at") (("2" (FLATTEN) (("2" (TYPEPRED "x2") (("2" (EXPAND "inop2_at") (("2" (FLATTEN) (("2" (LEMMA "PVS0Expr_op2_extensionality") (("2" (INST -1 "x1" "x2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE (-2 2)) (("3" (SKEEP) (("3" (EXPAND "infinpair") (("3" (EXPAND "F") (("3" (TYPEPRED "x1") (("3" (EXPAND "inop2_at") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (TYPEPRED "ee") (("2" (EXPAND "inop2_at") (("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|op2_at| SUBTYPE "counting_pvs0_type.inop2_at(counting_pvs0_type.fexp, counting_pvs0_type.n)" "finite_set[PVS0Expr[T]]")) (|op2_at_TCC1-1| |nil| 3665481394 ("" (SKEEP) (("" (LEMMA "finpair_TCC1") (("" (INST?) (("" (EXPAND "is_finite") (("" (SKEEP) (("" (NAME "F" "lambda (ee:(inop2_at(fexp, n))): (get_arg1(ee), get_arg2(ee)) ") (("1" (CASE "injective?[ (inop2_at(fexp, n)), (infinpair(fexp))](F)") (("1" (INST 1 "N" " f o F") (("1" (ASSERT) (("1" (LEMMA "composition_injective[(inop2_at(fexp, n)), (infinpair(fexp)), below[N]]") (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-2 2)) (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (EXPAND "F") (("2" (TYPEPRED (X1)) (("2" (EXPAND "inop2_at") (("2" (FLATTEN) (("2" (TYPEPRED (X2)) (("2" (EXPAND "inop2_at") (("2" (FLATTEN) (("2" (LEMMA "PVS0Expr_op2_extensionality") (("2" (INST -1 "x1" "x2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE (-2 2)) (("3" (SKEEP) (("3" (EXPAND "infinpair") (("3" (EXPAND "F") (("3" (TYPEPRED (X1)) (("3" (EXPAND "inop2_at") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (TYPEPRED (EE)) (("2" (EXPAND "inop2_at") (("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|finpair_TCC1| SUBTYPE-TCC NIL |counting_pvs0_type| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|inop2_at| CONST-DECL "bool" |counting_pvs0_type| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|op2?| ADT-RECOGNIZER-DECL "[PVS0Expr -> boolean]" |PVS0Expr_adt| NIL) (|get_arg1| ADT-ACCESSOR-DECL "[(op2?) -> PVS0Expr]" |PVS0Expr_adt| NIL) (|get_arg2| ADT-ACCESSOR-DECL "[(op2?) -> PVS0Expr]" |PVS0Expr_adt| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|PVS0Expr_op2_extensionality| FORMULA-DECL NIL |PVS0Expr_adt| NIL) (F SKOLEM-CONST-DECL "[(inop2_at(fexp, n)) -> [PVS0Expr[T], PVS0Expr[T]]]" |counting_pvs0_type| NIL) (< CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (O CONST-DECL "T3" |function_props| NIL) (|composition_injective| JUDGEMENT-TCC NIL |function_props| NIL) (|infinpair| CONST-DECL "bool" |counting_pvs0_type| NIL) (|injective?| CONST-DECL "bool" |functions| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|PVS0Expr| TYPE-DECL NIL |PVS0Expr_adt| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL)) NIL (|op2_at| SUBTYPE "counting_pvs0_type.inop2_at(counting_pvs0_type.fexp, counting_pvs0_type.n)" "finite_set[PVS0Expr[T]]"))) (|op2_upto_TCC1| 0 (|op2_upto_TCC1-2| |nil| 3665775993 ("" (SKOLEM 1 ("fexp" "_")) (("" (INDUCT "n") (("1" (CASE-REPLACE "inop2_upto(fexp, 0) = inop2_at(fexp, 0)") (("1" (LEMMA "op2_at_TCC1") (("1" (INST?) NIL NIL)) NIL) ("2" (HIDE 2) (("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "inop2_upto") (("2" (EXPAND "inop2_at") (("2" (IFF) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (CASE "inop2_upto(fexp, j+1) = union(inop2_upto(fexp, j), inop2_at(fexp, j+1))") (("1" (LEMMA "op2_at_TCC1") (("1" (INST?) (("1" (REPLACES -2) (("1" (LEMMA "finite_union[PVS0Expr[T]]") (("1" (INST?) (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "union") (("2" (IFF) (("2" (GROUND) (("1" (EXPAND "inop2_upto") (("1" (EXPAND "member") (("1" (EXPAND "inop2_at") (("1" (FLATTEN) (("1" (EXPAND "member") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "inop2_upto") (("2" (EXPAND "member") (("2" (ASSERT) (("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "member") (("3" (EXPAND "inop2_at") (("3" (EXPAND "inop2_upto") (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL) (|PVS0Expr| TYPE-DECL NIL |PVS0Expr_adt| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|inop2_upto| CONST-DECL "bool" |counting_pvs0_type| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|op2_at_TCC1| SUBTYPE-TCC NIL |counting_pvs0_type| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|inop2_at| CONST-DECL "bool" |counting_pvs0_type| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|union| CONST-DECL "set" |sets| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|finite_union| JUDGEMENT-TCC NIL |finite_sets| NIL) (|fexp| SKOLEM-CONST-DECL "finite_set[PVS0Expr[T]]" |counting_pvs0_type| NIL) (|j| SKOLEM-CONST-DECL "nat" |counting_pvs0_type| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|member| CONST-DECL "bool" |sets| NIL)) NIL (|op2_upto| SUBTYPE "counting_pvs0_type.inop2_upto(counting_pvs0_type.fexp, counting_pvs0_type.n)" "finite_set[PVS0Expr[T]]"))) (|fintrip_TCC1| 0 (|fintrip_TCC1-2| "" 3885322177 ("" (SKEEP) (("" (TYPEPRED "fexp") (("" (EXPAND "is_finite") (("" (SKEEP) (("" (NAME "F" "lambda(e: (infintrip(fexp))): ((f(e`1), f(e`2)), f(e`3))") (("1" (LEMMA "is_finite_cross[below[N], below[N]]") (("1" (EXPAND "is_finite_type") (("1" (CASE "EXISTS (M:nat), (g: [below[N] -> below[M]]): injective?(g)") (("1" (GROUND) (("1" (LEMMA "is_finite_cross[[below[N], below[N]], below[N]]") (("1" (EXPAND "is_finite_type") (("1" (GROUND) (("1" (CASE "injective?[(infintrip(fexp)), [[below[N], below[N]], below[N]]](F)") (("1" (SKEEP :PREDS? T) (("1" (INST 1 "N!1" "g o F") (("1" (LEMMA "composition_injective[(infintrip(fexp)), [[below[N], below[N]], below[N]], below[N!1]]") (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-1 -2 -3 2)) (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (DECOMPOSE-EQUALITY 1) (("1" (EXPAND "F") (("1" (INST -3 "x1`1" "x2`1") (("1" (ASSERT) (("1" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "F") (("2" (FLATTEN) (("2" (INST -5 "x1`2" "x2`2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "F") (("3" (FLATTEN) (("3" (INST -5 "x1`3" "x2`3") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (INST 1 "N" "id") (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (EXPAND "id") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP :PREDS? T) (("2" (EXPAND "infintrip") (("2" (EXPAND "member") (("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ("3" (SKEEP :PREDS? T) (("3" (EXPAND "infintrip") (("3" (FLATTEN) (("3" (EXPAND "member") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP :PREDS? T) (("4" (EXPAND "infintrip") (("4" (EXPAND "member") (("4" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|fintrip| SUBTYPE "counting_pvs0_type.infintrip(counting_pvs0_type.fexp)" "finite_set[[PVS0Expr[T], PVS0Expr[T], PVS0Expr[T]]]")) (|fintrip_TCC1-1| |nil| 3665491138 ("" (SKEEP) (("" (TYPEPRED (FEXP)) (("" (EXPAND "is_finite") (("" (SKEEP) (("" (NAME "F" "lambda(e: (infintrip(fexp))): ((f(e`1), f(e`2)), f(e`3))") (("1" (LEMMA "is_finite_cross[below[N], below[N]]") (("1" (EXPAND "is_finite_type") (("1" (CASE "EXISTS (M:nat), (g: [below[N] -> below[M]]): injective?(g)") (("1" (GROUND) (("1" (LEMMA "is_finite_cross[[below[N], below[N]], below[N]]") (("1" (EXPAND "is_finite_type") (("1" (GROUND) (("1" (CASE "injective?[(infintrip(fexp)), [[below[N], below[N]], below[N]]](F)") (("1" (SKEEP :PREDS? T) (("1" (INST 1 "N!1" "g o F") (("1" (LEMMA "composition_injective[(infintrip(fexp)), [[below[N], below[N]], below[N]], below[N!1]]") (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE (-1 -2 -3 2)) (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (DECOMPOSE-EQUALITY 1) (("1" (EXPAND "F") (("1" (INST -3 "x1`1" "x2`1") (("1" (ASSERT) (("1" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "F") (("2" (FLATTEN) (("2" (INST -5 "x1`2" "x2`2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "F") (("3" (FLATTEN) (("3" (INST -5 "x1`3" "x2`3") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (INST 1 "N" "id") (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (EXPAND "id") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP :PREDS? T) (("2" (EXPAND "infintrip") (("2" (EXPAND "member") (("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL) ("3" (SKEEP :PREDS? T) (("3" (EXPAND "infintrip") (("3" (FLATTEN) (("3" (EXPAND "member") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP :PREDS? T) (("4" (EXPAND "infintrip") (("4" (EXPAND "member") (("4" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|PVS0Expr| TYPE-DECL NIL |PVS0Expr_adt| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|member| CONST-DECL "bool" |sets| NIL) (|is_finite_cross| FORMULA-DECL NIL |finite_cross| |finite_sets|) (|injective?| CONST-DECL "bool" |functions| NIL) (|composition_injective| JUDGEMENT-TCC NIL |function_props| NIL) (|g| SKOLEM-CONST-DECL "[[[below[N], below[N]], below[N]] -> below[N!1]]" |counting_pvs0_type| NIL) (N!1 SKOLEM-CONST-DECL "nat" |counting_pvs0_type| NIL) (N SKOLEM-CONST-DECL "nat" |counting_pvs0_type| NIL) (F SKOLEM-CONST-DECL "[(infintrip(fexp)) -> [[below[N], below[N]], below[N]]]" |counting_pvs0_type| NIL) (|fexp| SKOLEM-CONST-DECL "finite_set[PVS0Expr[T]]" |counting_pvs0_type| NIL) (O CONST-DECL "T3" |function_props| NIL) (|bijective?| CONST-DECL "bool" |functions| NIL) (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL) (|is_finite_type| CONST-DECL "bool" |finite_sets| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|infintrip| CONST-DECL "bool" |counting_pvs0_type| NIL)) NIL (|fintrip| SUBTYPE "counting_pvs0_type.infintrip(counting_pvs0_type.fexp)" "finite_set[[PVS0Expr[T], PVS0Expr[T], PVS0Expr[T]]]"))) (|ite_set_TCC1| 0 (|ite_set_TCC1-2| "" 3885322208 ("" (SKEEP) (("" (LEMMA "fintrip_TCC1") (("" (INST?) (("" (EXPAND "is_finite") (("" (SKEEP) (("" (NAME "F" "lambda (ee:(inite_set(fexp))): (get_cond(ee), get_if(ee), get_else(ee)) ") (("1" (CASE "injective?[ (inite_set(fexp)), (infintrip(fexp))](F)") (("1" (INST 1 "N" " f o F") (("1" (LEMMA "composition_injective[(inite_set(fexp)), (infintrip(fexp)), below[N]]") (("1" (INST?) NIL NIL)) NIL)) NIL) ("2" (HIDE (-2 2)) (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (EXPAND "F") (("2" (FLATTEN) (("2" (LEMMA "PVS0Expr_ite_extensionality") (("2" (INST -1 "x1" "x2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE (-2 2)) (("3" (SKEEP) (("3" (EXPAND "infintrip") (("3" (EXPAND "F") (("3" (TYPEPRED "x1") (("3" (EXPAND "inite_set") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (TYPEPRED "ee") (("2" (EXPAND "inite_set") (("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|ite_set| SUBTYPE "counting_pvs0_type.inite_set(counting_pvs0_type.fexp)" "finite_set[PVS0Expr[T]]")) (|ite_set_TCC1-1| |nil| 3665403166 ("" (SKEEP) (("" (LEMMA "fintrip_TCC1") (("" (INST?) (("" (EXPAND "is_finite") (("" (SKEEP) (("" (NAME "F" "lambda (ee:(inite_set(fexp))): (get_cond(ee), get_if(ee), get_else(ee)) ") (("1" (CASE "injective?[ (inite_set(fexp)), (infintrip(fexp))](F)") (("1" (INST 1 "N" " f o F") (("1" (LEMMA "composition_injective[(inite_set(fexp)), (infintrip(fexp)), below[N]]") (("1" (INST?) NIL NIL)) NIL)) NIL) ("2" (HIDE (-2 2)) (("2" (EXPAND "injective?") (("2" (SKEEP) (("2" (EXPAND "F") (("2" (FLATTEN) (("2" (LEMMA "PVS0Expr_ite_extensionality") (("2" (INST -1 "x1" "x2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE (-2 2)) (("3" (SKEEP) (("3" (EXPAND "infintrip") (("3" (EXPAND "F") (("3" (TYPEPRED (X1)) (("3" (EXPAND "inite_set") (("3" (ASSERT) (("3" (FLATTEN) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (TYPEPRED (EE)) (("2" (EXPAND "inite_set") (("2" (FLATTEN) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|fintrip_TCC1| SUBTYPE-TCC NIL |counting_pvs0_type| NIL) (|inite_set| CONST-DECL "bool" |counting_pvs0_type| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|ite?| ADT-RECOGNIZER-DECL "[PVS0Expr -> boolean]" |PVS0Expr_adt| NIL) (|get_cond| ADT-ACCESSOR-DECL "[(ite?) -> PVS0Expr]" |PVS0Expr_adt| NIL) (|get_if| ADT-ACCESSOR-DECL "[(ite?) -> PVS0Expr]" |PVS0Expr_adt| NIL) (|get_else| ADT-ACCESSOR-DECL "[(ite?) -> PVS0Expr]" |PVS0Expr_adt| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|PVS0Expr_ite_extensionality| FORMULA-DECL NIL |PVS0Expr_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (O CONST-DECL "T3" |function_props| NIL) (F SKOLEM-CONST-DECL "[(inite_set(fexp)) -> [PVS0Expr[T], PVS0Expr[T], PVS0Expr[T]]]" |counting_pvs0_type| NIL) (|fexp| SKOLEM-CONST-DECL "finite_set[PVS0Expr[T]]" |counting_pvs0_type| NIL) (N SKOLEM-CONST-DECL "nat" |counting_pvs0_type| NIL) (|f| SKOLEM-CONST-DECL "[(infintrip(fexp)) -> below[N]]" |counting_pvs0_type| NIL) (|composition_injective| JUDGEMENT-TCC NIL |function_props| NIL) (|infintrip| CONST-DECL "bool" |counting_pvs0_type| NIL) (|injective?| CONST-DECL "bool" |functions| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|PVS0Expr| TYPE-DECL NIL |PVS0Expr_adt| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL)) NIL (|ite_set| SUBTYPE "counting_pvs0_type.inite_set(counting_pvs0_type.fexp)" "finite_set[PVS0Expr[T]]"))) (|inrec_set_TCC1| 0 (|inrec_set_TCC1-1| |nil| 3665403166 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|inrec_set| SUBTYPE "counting_pvs0_type.e" "{x: PVS0Expr_adt[counting_pvs0_type.T].PVS0Expr | booleans.OR(PVS0Expr_adt[counting_pvs0_type.T].op1?(x), PVS0Expr_adt[counting_pvs0_type.T].rec?(x))}"))) (|rec_set_TCC1| 0 (|rec_set_TCC1-2| "" 3885322243 ("" (SKEEP) (("" (TYPEPRED "fexp") (("" (EXPAND "is_finite") (("" (SKEEP :PREDS? T) (("" (INST 1 "N" "LAMBDA(e:(inrec_set(fexp))): f(get_arg(e))") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (INST - "get_arg(x1)" "get_arg(x2)") (("1" (ASSERT) (("1" (LEMMA "PVS0Expr_rec_extensionality") (("1" (INST -1 "x1" "x2") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED "x2") (("2" (EXPAND "inrec_set") (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (TYPEPRED "x1") (("3" (EXPAND "inrec_set") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP :PREDS? T) (("2" (EXPAND "inrec_set") (("2" (FLATTEN) (("2" (EXPAND "member") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP :PREDS? T) (("3" (EXPAND "inrec_set") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK (|rec_set| SUBTYPE "counting_pvs0_type.inrec_set(counting_pvs0_type.fexp)" "finite_set[PVS0Expr[T]]")) (|rec_set_TCC1-1| |nil| 3665403166 ("" (SKEEP) (("" (TYPEPRED (FEXP)) (("" (EXPAND "is_finite") (("" (SKEEP :PREDS? T) (("" (INST 1 "N" "LAMBDA(e:(inrec_set(fexp))): f(get_arg(e))") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (INST - "get_arg(x1)" "get_arg(x2)") (("1" (ASSERT) (("1" (LEMMA "PVS0Expr_rec_extensionality") (("1" (INST -1 "x1" "x2") (("1" (ASSERT) NIL NIL) ("2" (TYPEPRED (X2)) (("2" (EXPAND "inrec_set") (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (TYPEPRED (X1)) (("3" (EXPAND "inrec_set") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP :PREDS? T) (("2" (EXPAND "inrec_set") (("2" (FLATTEN) (("2" (EXPAND "member") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP :PREDS? T) (("3" (EXPAND "inrec_set") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|PVS0Expr| TYPE-DECL NIL |PVS0Expr_adt| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|member| CONST-DECL "bool" |sets| NIL) (|injective?| CONST-DECL "bool" |functions| NIL) (|PVS0Expr_rec_extensionality| FORMULA-DECL NIL |PVS0Expr_adt| NIL) (|x2| SKOLEM-CONST-DECL "(inrec_set(fexp))" |counting_pvs0_type| NIL) (|x1| SKOLEM-CONST-DECL "(inrec_set(fexp))" |counting_pvs0_type| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|inrec_set| CONST-DECL "bool" |counting_pvs0_type| NIL) (|fexp| SKOLEM-CONST-DECL "finite_set[PVS0Expr[T]]" |counting_pvs0_type| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|op1?| ADT-RECOGNIZER-DECL "[PVS0Expr -> boolean]" |PVS0Expr_adt| NIL) (|rec?| ADT-RECOGNIZER-DECL "[PVS0Expr -> boolean]" |PVS0Expr_adt| NIL) (|get_arg| SHARED-ADT-ACCESSOR-DECL "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" |PVS0Expr_adt| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) NIL (|rec_set| SUBTYPE "counting_pvs0_type.inrec_set(counting_pvs0_type.fexp)" "finite_set[PVS0Expr[T]]"))) (|level_set_member| 0 (|level_set_member-1| |nil| 3665414687 ("" (SKEEP) (("" (EXPAND "level_set" 1) (("" (EXPAND "member" 1) (("" (EXPAND "union" 1 1) (("" (FLATTEN) (("" (EXPAND "member" +) (("" (EXPAND "union" 2 1) (("" (FLATTEN) (("" (EXPAND "member" +) (("" (EXPAND "union" 3 1) (("" (FLATTEN) (("" (EXPAND "member" +) (("" (EXPAND "union" 4 1) (("" (FLATTEN) (("" (EXPAND "member" +) (("" (EXPAND "union" 5 1) (("" (FLATTEN) (("" (EXPAND "member" +) (("" (EXPAND "member") (("" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|level_set| CONST-DECL "finite_set[PVS0Expr[T]]" |counting_pvs0_type| NIL) (|union| CONST-DECL "set" |sets| NIL) (|member| CONST-DECL "bool" |sets| NIL)) SHOSTAK)) (|level_TCC1| 0 (|level_TCC1-1| |nil| 3665405240 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL)) NIL (|level| SUBTYPE "(number_fields.-)(counting_pvs0_type.n, 1)" "nat"))) (|level_TCC2| 0 (|level_TCC2-1| |nil| 3665405240 ("" (TERMINATION-TCC) NIL NIL) NIL NIL (|level| TERMINATION "counting_pvs0_type.level((number_fields.-)(counting_pvs0_type.n, 1))" "NIL"))) (|levels_increase| 0 (|levels_increase-1| |nil| 3665415148 ("" (SKOLEM 1 ("m" "_" "e")) (("" (CASE "FORALL (k:nat): member(e, level(m)) IMPLIES member(e, level(m+k))") (("1" (SKEEP) (("1" (INST -1 "n-m") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (INDUCT "k") (("1" (ASSERT) (("1" (FLATTEN) NIL NIL)) NIL) ("2" (SKEEP) (("2" (ASSERT) (("2" (HIDE -2) (("2" (EXPAND "level" 1) (("2" (LEMMA "level_set_member") (("2" (INST -1 "level(j+m)" "e" "1+j+m") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|nnint_plus_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL) (|PVS0Expr| TYPE-DECL NIL |PVS0Expr_adt| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|member| CONST-DECL "bool" |sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|level| DEF-DECL "finite_set[PVS0Expr[T]]" |counting_pvs0_type| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|m| SKOLEM-CONST-DECL "nat" |counting_pvs0_type| NIL) (|n| SKOLEM-CONST-DECL "nat" |counting_pvs0_type| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|nat_induction| FORMULA-DECL NIL |naturalnumbers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|level_set_member| FORMULA-DECL NIL |counting_pvs0_type| NIL)) SHOSTAK)) (|levels_cover| 0 (|levels_cover-1| |nil| 3665406228 ("" (INDUCT "e" 1 PVS0EXPR_INDUCTION) (("1" (SKEEP) (("1" (INST + "G(cnst1_var)") (("1" (EXPAND "member") (("1" (EXPAND "level") (("1" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "base") (("1" (EXPAND "inbase") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (LEMMA "level_set_member") (("2" (INST -1 "level(G(cnst1_var) - 1)" "cnst(cnst1_var)" "G(cnst1_var)") (("1" (CASE "member(cnst(cnst1_var), base(G(cnst1_var)))") (("1" (ASSERT) (("1" (EXPAND "member") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (HIDE -) (("2" (EXPAND "member") (("2" (EXPAND "base") (("2" (EXPAND "inbase") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST + "0") (("2" (EXPAND "member") (("2" (EXPAND "level") (("2" (EXPAND "base") (("2" (EXPAND "inbase") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (SKEEP) (("3" (NAME "N" " max(n, op11_var)") (("3" (LEMMA "levels_increase") (("3" (INST -1 "n" "N" "op12_var") (("3" (ASSERT) (("3" (INST 1 "1+N") (("3" (LEMMA "level_set_member") (("3" (EXPAND "level" 1) (("3" (INST -1 "level(N)" "op1(op11_var, op12_var)" "1+N") (("3" (CASE "member(op1(op11_var, op12_var), op1_upto(level(N), 1 + N))") (("1" (ASSERT) NIL NIL) ("2" (EXPAND "member") (("2" (EXPAND "op1_upto") (("2" (EXPAND "inop1_upto") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (SKEEP) (("4" (SKEEP) (("4" (NAME "N" "max(op21_var, max(n!1, n))") (("4" (LEMMA "levels_increase") (("4" (INST-CP -1 "n!1" "N" "op23_var") (("4" (INST -1 "n" "N" "op22_var") (("4" (ASSERT) (("4" (INST 1 "1+N") (("4" (LEMMA "level_set_member") (("4" (EXPAND "level" 1) (("4" (INST -1 "level(N)" "op2(op21_var, op22_var, op23_var)" "1+N") (("4" (CASE "member(op2(op21_var, op22_var, op23_var),
                                                        op2_upto(level(N), 1 + N))") (("1" (ASSERT) NIL NIL) ("2" (EXPAND "member") (("2" (EXPAND "op2_upto") (("2" (EXPAND "inop2_upto") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (SKEEP) (("5" (SKEEP) (("5" (INST + "n+1") (("5" (EXPAND "member") (("5" (EXPAND "level" 1) (("5" (CASE "rec_set(level(n))(rec(rec1_var))") (("1" (LEMMA "level_set_member") (("1" (INST -1 "level(n)" "rec(rec1_var)" "1+n") (("1" (EXPAND "member") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "rec_set") (("2" (EXPAND "inrec_set") (("2" (EXPAND "member") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (SKEEP) (("6" (SKEEP) (("6" (SKEEP) (("6" (SKEEP) (("6" (NAME "N" "max(n!2, max(n!1, n))") (("6" (LEMMA "levels_increase") (("6" (INST-CP -1 "n!2" "N" "ite3_var") (("6" (ASSERT) (("6" (INST-CP -1 "n!1" "N" "ite2_var") (("6" (ASSERT) (("6" (INST-CP -1 "n" "N" "ite1_var") (("6" (ASSERT) (("6" (HIDE -1) (("6" (INST 1 "1+N") (("6" (EXPAND "level" 1) (("6" (LEMMA "level_set_member") (("6" (INST -1 "level(N)" "ite(ite1_var, ite2_var, ite3_var)" "1+N") (("6" (CASE "member(ite(ite1_var, ite2_var, ite3_var), ite_set(level(N)))") (("1" (ASSERT) NIL NIL) ("2" (HIDE (-1 2)) (("2" (EXPAND "ite_set") (("2" (EXPAND "inite_set") (("2" (EXPAND "member") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|ite?| ADT-RECOGNIZER-DECL "[PVS0Expr -> boolean]" |PVS0Expr_adt| NIL) (|ite| ADT-CONSTRUCTOR-DECL "[[PVS0Expr, PVS0Expr, PVS0Expr] -> (ite?)]" |PVS0Expr_adt| NIL) (|inite_set| CONST-DECL "bool" |counting_pvs0_type| NIL) (|ite_set| CONST-DECL "finite_set[PVS0Expr[T]]" |counting_pvs0_type| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|inrec_set| CONST-DECL "bool" |counting_pvs0_type| NIL) (|rec_set| CONST-DECL "finite_set[PVS0Expr[T]]" |counting_pvs0_type| NIL) (|rec?| ADT-RECOGNIZER-DECL "[PVS0Expr -> boolean]" |PVS0Expr_adt| NIL) (|rec| ADT-CONSTRUCTOR-DECL "[PVS0Expr -> (rec?)]" |PVS0Expr_adt| NIL) (|op2_upto| CONST-DECL "finite_set[PVS0Expr[T]]" |counting_pvs0_type| NIL) (|inop2_upto| CONST-DECL "bool" |counting_pvs0_type| NIL) (|op2| ADT-CONSTRUCTOR-DECL "[[nat, PVS0Expr, PVS0Expr] -> (op2?)]" |PVS0Expr_adt| NIL) (|op2?| ADT-RECOGNIZER-DECL "[PVS0Expr -> boolean]" |PVS0Expr_adt| NIL) (<= CONST-DECL "bool" |reals| NIL) (|max| CONST-DECL "{p: real | p >= m AND p >= n}" |real_defs| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|nonneg_rat_max| APPLICATION-JUDGEMENT "{s: nonneg_rat | s >= q AND s >= r}" |real_defs| NIL) (|nat_max| APPLICATION-JUDGEMENT "{k: nat | i <= k AND j <= k}" |real_defs| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|op1_upto| CONST-DECL "finite_set[PVS0Expr[T]]" |counting_pvs0_type| NIL) (|inop1_upto| CONST-DECL "bool" |counting_pvs0_type| NIL) (|op1| ADT-CONSTRUCTOR-DECL "[[nat, PVS0Expr] -> (op1?)]" |PVS0Expr_adt| NIL) (|op1?| ADT-RECOGNIZER-DECL "[PVS0Expr -> boolean]" |PVS0Expr_adt| NIL) (|levels_increase| FORMULA-DECL NIL |counting_pvs0_type| NIL) (|base| CONST-DECL "finite_set[PVS0Expr[T]]" |counting_pvs0_type| NIL) (|inbase| CONST-DECL "bool" |counting_pvs0_type| NIL) (|level_set_member| FORMULA-DECL NIL |counting_pvs0_type| NIL) (|cnst| ADT-CONSTRUCTOR-DECL "[T -> (cnst?)]" |PVS0Expr_adt| NIL) (|cnst?| ADT-RECOGNIZER-DECL "[PVS0Expr -> boolean]" |PVS0Expr_adt| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|cnst1_var| SKOLEM-CONST-DECL "T" |counting_pvs0_type| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (G CONST-DECL "{F: [T -> nat] | injective?(F)}" |counting_pvs0_type| NIL) (|injective?| CONST-DECL "bool" |functions| NIL) (|PVS0Expr_induction| FORMULA-DECL NIL |PVS0Expr_adt| NIL) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL) (|level| DEF-DECL "finite_set[PVS0Expr[T]]" |counting_pvs0_type| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|member| CONST-DECL "bool" |sets| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|PVS0Expr| TYPE-DECL NIL |PVS0Expr_adt| NIL)) SHOSTAK)) (|nat_onto_PVS0Expr| 0 (|nat_onto_PVS0Expr-1| |nil| 3665419284 ("" (LEMMA "nat_surjection") (("" (INST -1 "level") (("" (LEMMA "levels_cover") (("" (ASSERT) (("" (SPLIT -2) (("1" (PROPAX) NIL NIL) ("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|level| DEF-DECL "finite_set[PVS0Expr[T]]" |counting_pvs0_type| NIL) (|levels_cover| FORMULA-DECL NIL |counting_pvs0_type| NIL) (|nat_surjection| FORMULA-DECL NIL |nat_surjection| |sets_aux|) (T FORMAL-NONEMPTY-TYPE-DECL NIL |counting_pvs0_type| NIL) (|PVS0Expr| TYPE-DECL NIL |PVS0Expr_adt| NIL)) SHOSTAK)))
