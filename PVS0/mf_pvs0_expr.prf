(mf_pvs0_expr (semantic_rel_expr_TCC1 0 (semantic_rel_expr_TCC1-1 nil 3603051502 ("" (subtype-tcc) nil nil) nil nil (semantic_rel_expr subtype "mf_pvs0_expr.expr" "{x: mf_PVS0Expr_adt[mf_pvs0_expr.Val].mf_PVS0Expr | booleans.OR(mf_PVS0Expr_adt[mf_pvs0_expr.Val].op1?(x), mf_PVS0Expr_adt[mf_pvs0_expr.Val].rec?(x))}"))) (semantic_rel_expr_TCC2 0 (semantic_rel_expr_TCC2-1 nil 3603051502 ("" (subtype-tcc) nil nil) nil nil (semantic_rel_expr subtype "mf_pvs0_expr.expr" "{x: mf_PVS0Expr_adt[mf_pvs0_expr.Val].mf_PVS0Expr | booleans.OR(mf_PVS0Expr_adt[mf_pvs0_expr.Val].op1?(x), mf_PVS0Expr_adt[mf_pvs0_expr.Val].op2?(x))}"))) (semantic_rel_expr_TCC3 0 (semantic_rel_expr_TCC3-1 nil 3603051502 ("" (subtype-tcc) nil nil) nil nil (semantic_rel_expr subtype "mf_pvs0_expr.expr" "{x: mf_PVS0Expr_adt[mf_pvs0_expr.Val].mf_PVS0Expr | booleans.OR(mf_PVS0Expr_adt[mf_pvs0_expr.Val].op1?(x), mf_PVS0Expr_adt[mf_pvs0_expr.Val].op2?(x))}"))) (semantic_rel_expr_TCC4 0 (semantic_rel_expr_TCC4-1 nil 3603051502 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (semantic_rel_expr subtype "mf_pvs0_expr.expr" "{x: mf_PVS0Expr_adt[mf_pvs0_expr.Val].mf_PVS0Expr | booleans.OR(mf_PVS0Expr_adt[mf_pvs0_expr.Val].op1?(x), mf_PVS0Expr_adt[mf_pvs0_expr.Val].rec?(x))}"))) (eval_expr_TCC1 0 (eval_expr_TCC1-1 nil 3602330945 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (eval_expr subtype "mf_pvs0_expr.expr" "{x: mf_PVS0Expr_adt[mf_pvs0_expr.Val].mf_PVS0Expr | booleans.OR(mf_PVS0Expr_adt[mf_pvs0_expr.Val].op1?(x), mf_PVS0Expr_adt[mf_pvs0_expr.Val].op2?(x))}"))) (eval_expr_TCC2 0 (eval_expr_TCC2-1 nil 3602330945 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("" (assert) (("" (hide 3) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (reduce_nat adt-def-decl "[mf_PVS0Expr -> nat]" mf_PVS0Expr_adt nil) (sizepvs0 const-decl "[mf_PVS0Expr -> nat]" mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.arg, mf_pvs0_expr.env)" "nil"))) (eval_expr_TCC3 0 (eval_expr_TCC3-1 nil 3602330945 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("" (assert) (("" (hide 3) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (reduce_nat adt-def-decl "[mf_PVS0Expr -> nat]" mf_PVS0Expr_adt nil) (sizepvs0 const-decl "[mf_PVS0Expr -> nat]" mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.arg2, mf_pvs0_expr.env)" "nil"))) (eval_expr_TCC4 0 (eval_expr_TCC4-1 nil 3602330945 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (eval_expr subtype "mf_pvs0_expr.expr" "{x: mf_PVS0Expr_adt[mf_pvs0_expr.Val].mf_PVS0Expr | booleans.OR(mf_PVS0Expr_adt[mf_pvs0_expr.Val].op1?(x), mf_PVS0Expr_adt[mf_pvs0_expr.Val].op2?(x))}"))) (eval_expr_TCC5 0 (eval_expr_TCC5-1 nil 3602330945 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("" (assert) (("" (hide 3) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (reduce_nat adt-def-decl "[mf_PVS0Expr -> nat]" mf_PVS0Expr_adt nil) (sizepvs0 const-decl "[mf_PVS0Expr -> nat]" mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.arg1, mf_pvs0_expr.env)" "nil"))) (eval_expr_TCC6 0 (eval_expr_TCC6-1 nil 3602330945 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("" (assert) (("" (hide 4) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (reduce_nat adt-def-decl "[mf_PVS0Expr -> nat]" mf_PVS0Expr_adt nil) (sizepvs0 const-decl "[mf_PVS0Expr -> nat]" mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.arg1, mf_pvs0_expr.env)" "nil"))) (eval_expr_TCC7 0 (eval_expr_TCC7-1 nil 3602330945 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("" (assert) (("" (hide 3) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (reduce_nat adt-def-decl "[mf_PVS0Expr -> nat]" mf_PVS0Expr_adt nil) (sizepvs0 const-decl "[mf_PVS0Expr -> nat]" mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.arg2, mf_pvs0_expr.env)" "nil"))) (eval_expr_TCC8 0 (eval_expr_TCC8-1 nil 3602330945 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("" (assert) (("" (hide 3) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (reduce_nat adt-def-decl "[mf_PVS0Expr -> nat]" mf_PVS0Expr_adt nil) (sizepvs0 const-decl "[mf_PVS0Expr -> nat]" mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.cnd, mf_pvs0_expr.env)" "nil"))) (eval_expr_TCC9 0 (eval_expr_TCC9-1 nil 3602330945 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (eval_expr subtype "(number_fields.-)(mf_pvs0_expr.i, 1)" "nat"))) (eval_expr_TCC10 0 (eval_expr_TCC10-1 nil 3709912304 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("1" (assert) nil nil) ("2" (hide 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (list type-decl nil list_adt nil) (sizepvs0 const-decl "[mf_PVS0Expr -> nat]" mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (i skolem-const-decl "nat" mf_pvs0_expr nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)((number_fields.-)(mf_pvs0_expr.i, 1), list_props[mf_PVS0Expr_adt[mf_pvs0_expr.Val].mf_PVS0Expr].nth(mf_pvs0_expr.pvs0`4, mf_pvs0_expr.n), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v))" "nil"))) (eval_expr_TCC11 0 (eval_expr_TCC11-1 nil 3709912304 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("" (assert) (("" (hide 3) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (reduce_nat adt-def-decl "[mf_PVS0Expr -> nat]" mf_PVS0Expr_adt nil) (sizepvs0 const-decl "[mf_PVS0Expr -> nat]" mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.arg, mf_pvs0_expr.env)" "nil"))) (eval_expr_ge_n_j_TCC1 0 (eval_expr_ge_n_j_TCC1-1 nil 3603101849 ("" (skeep) (("" (assert) nil nil)) nil) nil nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].None" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC2 0 (eval_expr_ge_n_j_TCC2-2 nil 3799663822 ("" (skeep*) (("" (assert) (("" (skeep) (("" (replaces -2) (("" (expand "eval_expr") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.v)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}")) (eval_expr_ge_n_j_TCC2-1 nil 3603101849 ("" (skeep* :preds? t) (("" (assert) (("" (skeep) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil) nil nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.v)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC3 0 (eval_expr_ge_n_j_TCC3-1 nil 3603101849 ("" (skeep*) (("" (assert) (("" (skeep 2) (("" (replaces -1) (("" (expand "eval_expr") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.env)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC4 0 (eval_expr_ge_n_j_TCC4-1 nil 3603101849 ("" (skeep*) (("" (assert) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "mf_pvs0_expr.expr" "{x: mf_PVS0Expr_adt[mf_pvs0_expr.Val].mf_PVS0Expr | booleans.OR(mf_PVS0Expr_adt[mf_pvs0_expr.Val].op1?(x), mf_PVS0Expr_adt[mf_pvs0_expr.Val].op2?(x))}"))) (eval_expr_ge_n_j_TCC5 0 (eval_expr_ge_n_j_TCC5-2 nil 3603102572 ("" (skeep*) (("" (assert) (("" (skeep 2) (("" (typepred "v") (("" (assert) (("" (insteep -1) (("" (replaces -2) (("" (replaces -2) (("" (expand "eval_expr" 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (upfrom nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.eval_op1(mf_pvs0_expr.pvs0)(mf_PVS0Expr_adt[mf_pvs0_expr.Val].get_op(mf_pvs0_expr.expr), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v)))" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}")) (eval_expr_ge_n_j_TCC5-1 nil 3603101849 ("" (recursive-judgement-tcc) nil nil) nil nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.eval_op1(mf_pvs0_expr.pvs0)(mf_PVS0Expr_adt[mf_pvs0_expr.Val].get_op(mf_pvs0_expr.expr), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v)))" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC6 0 (eval_expr_ge_n_j_TCC6-2 nil 3603102676 ("" (skeep*) (("" (assert) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].None" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}")) (eval_expr_ge_n_j_TCC6-1 nil 3603101849 ("" (recursive-judgement-tcc) nil nil) nil nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].None" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC7 0 (eval_expr_ge_n_j_TCC7-1 nil 3603101849 ("" (skeep*) (("" (assert) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "mf_pvs0_expr.expr" "{x: mf_PVS0Expr_adt[mf_pvs0_expr.Val].mf_PVS0Expr | booleans.OR(mf_PVS0Expr_adt[mf_pvs0_expr.Val].op1?(x), mf_PVS0Expr_adt[mf_pvs0_expr.Val].op2?(x))}"))) (eval_expr_ge_n_j_TCC8 0 (eval_expr_ge_n_j_TCC8-2 nil 3603103146 ("" (skeep*) (("" (assert) (("" (skeep 2) (("" (typepred "v1") (("" (typepred "v2") (("" (assert) (("" (insteep -) (("" (insteep -) (("" (replaces -4 2) (("" (expand "eval_expr" 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (upfrom nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.eval_op2(mf_pvs0_expr.pvs0)(mf_PVS0Expr_adt[mf_pvs0_expr.Val].get_op(mf_pvs0_expr.expr), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v1), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v2)))" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}")) (eval_expr_ge_n_j_TCC8-1 nil 3603101849 ("" (recursive-judgement-tcc) nil nil) nil nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.eval_op2(mf_pvs0_expr.pvs0)(mf_PVS0Expr_adt[mf_pvs0_expr.Val].get_op(mf_pvs0_expr.expr), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v1), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v2)))" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC9 0 (eval_expr_ge_n_j_TCC9-2 nil 3603103387 ("" (skeep*) (("" (assert) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].None" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC10 0 (eval_expr_ge_n_j_TCC10-1 nil 3603101849 ("" (skeep* :preds? t) (("" (assert) (("" (skeep) (("" (replace -4) (("" (expand "eval_expr" 3) (("" (inst?) (("" (assert) (("" (typepred "v3(pvs0)(i, arg1, env)") (("" (assert) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "mf_pvs0_expr.v3(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.arg1, mf_pvs0_expr.env)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC11 0 (eval_expr_ge_n_j_TCC11-3 nil 3746196793 ("" (skeep* :preds? t) (("" (assert) (("" (skeep) (("" (replace -4) (("" (expand "eval_expr" 2) (("" (inst?) (("" (assert) (("" (typepred "v3(pvs0)(i, arg2, env)") (("" (assert) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "mf_pvs0_expr.v3(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.arg2, mf_pvs0_expr.env)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}")) (eval_expr_ge_n_j_TCC11-2 nil 3746196673 ("" (skeep* :preds? t) (("" (assert) (("" (skeep) (("" (replace -3) (("" (expand "eval_expr" 3) (("" (inst?) (("" (assert) (("" (typepred "v3(pvs0)(i, arg1, env)") (("" (assert) (("" (inst?) nil)))))))))))))))))) nil) nil nil (eval_expr_ge_n_j_ subtype "mf_pvs0_expr.v3(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.arg2, mf_pvs0_expr.env)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}")) (eval_expr_ge_n_j_TCC11-1 nil 3603101849 ("" (skeep*) (("" (assert) (("" (skeep) (("" (typepred "vc") (("" (assert) (("" (insteep -) (("" (replaces -2 2) (("" (expand "eval_expr" 2) (("" (assert) (("" (typepred "v3(pvs0)(n, arg2, env)") (("" (assert) (("" (insteep -) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) nil (eval_expr_ge_n_j_ subtype "mf_pvs0_expr.v3(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.arg2, mf_pvs0_expr.env)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC12 0 (eval_expr_ge_n_j_TCC12-2 nil 3603103536 ("" (skeep*) (("" (assert) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].None" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}")) (eval_expr_ge_n_j_TCC12-1 nil 3603101849 ("" (recursive-judgement-tcc) nil nil) nil nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].None" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC13 0 (eval_expr_ge_n_j_TCC13-1 nil 3603101849 ("" (skeep* :preds? t) (("" (assert) nil nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "(number_fields.-)(mf_pvs0_expr.i, 1)" "nat"))) (eval_expr_ge_n_j_TCC14 0 (eval_expr_ge_n_j_TCC14-1 nil 3709912304 ("" (skeep* :preds? t) (("" (assert) (("" (skeep) (("" (insteep -) (("" (replaces -5 2) (("" (expand "eval_expr" 2) (("" (assert) (("" (typepred "v3(pvs0)(i - 1, nth[mf_PVS0Expr[Val]](pvs0`4, n), val[Val](v))") (("" (assert) (("" (flatten) (("" (inst -2 "m-1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (upfrom nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (eval_expr_ge_n_j_ subtype "mf_pvs0_expr.v3(mf_pvs0_expr.pvs0)((number_fields.-)(mf_pvs0_expr.i, 1), list_props[mf_PVS0Expr_adt[mf_pvs0_expr.Val].mf_PVS0Expr].nth(mf_pvs0_expr.pvs0`4, mf_pvs0_expr.n), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v))" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC15 0 (eval_expr_ge_n_j_TCC15-3 "" 3804630560 ("" (skeep* :preds? t) (("" (assert) (("" (skeep) (("" (typepred "m") (("" (replace -6) (("" (expand "eval_expr" 3) (("" (inst -3 "m") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (upfrom nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.pvs0`3)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}")) (eval_expr_ge_n_j_TCC15-2 nil 3799664364 ("" (skeep* :preds? t) (("" (assert) (("" (skeep) (("" (typepred "m") (("" (replace -6) (("" (expand "eval_expr" 3) (("" (inst -2 "m") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.pvs0`3)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}")) (eval_expr_ge_n_j_TCC15-1 nil 3709912304 ("" (skeep* :preds? t) (("" (assert) (("" (skeep) (("" (typepred "m") (("" (replace -5) (("" (expand "eval_expr" 3) (("" (inst -2 "m") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.pvs0`3)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC16 0 (eval_expr_ge_n_j_TCC16-1 nil 3746195529 ("" (recursive-judgement-tcc) nil nil) nil nil (eval_expr_ge_n_j_ subtype "Maybe[mf_pvs0_expr.Val].None" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), booleans.AND(reals.>(mf_pvs0_expr.i, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.i)): myv = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}"))) (eval_expr_gt_0 0 (eval_expr_gt_0-1 nil 3665383025 ("" (skeep) (("" (assert) (("" (flatten) (("" (lemma "eval_expr_ge_n_j") (("" (inst -1 "env" "expr" "n" "pvs0") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (eval_expr_ge_n_j recursive-judgement-axiom nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil)) shostak)) (eval_expr_ge_n 0 (eval_expr_ge_n-1 nil 3603061172 ("" (skeep*) (("" (skoletin 1) (("" (flatten) (("" (lemma "eval_expr_ge_n_j") (("" (inst -1 "env" "expr" "n" "pvs0") (("" (assert) (("" (flatten) (("" (insteep -) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (eval_expr_ge_n_j recursive-judgement-axiom nil mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (semantic_rel_eval_expr 0 (semantic_rel_eval_expr-3 nil 3665233766 ("" (skeep*) (("" (lemma "semantic_rel_expr_induction") (("" (inst -1 "pvs0" _) (("" (inst -1 "LAMBDA(x:mf_PVS0Expr,e:Val,v:Val):EXISTS (n:posnat): LET myv = eval_expr(pvs0)(n,x,e) IN
                                                some?(myv) AND v=val(myv)") (("" (split -) (("1" (inst -1 "expr" "env" "val") (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (skosimp*) (("2" (split -) (("1" (flatten) (("1" (inst 1 "1") (("1" (expand "eval_expr") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst 1 "1") (("2" (expand "eval_expr") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skeep -2) (("3" (skeep -3) (("3" (insteep 1) (("3" (beta) (("3" (flatten) (("3" (expand "eval_expr" +) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (skeep -2) (("4" (skolem -3 "n1") (("4" (skoletin -3 :postfix "1") (("4" (skolem -6 "n2") (("4" (skoletin -6 :postfix "2") (("4" (flatten) (("4" (inst 1 "max(n1,n2)") (("4" (skoletin 1) (("4" (lemma "eval_expr_ge_n") (("4" (copy -1) (("4" (insteep -1 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_arg1(expr!1)") ("env" "env!1"))) (("1" (replace -9 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -2 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_arg2(expr!1)") ("env" "env!1"))) (("1" (replace -6 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -3) (("1" (replaces -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (flatten) (("5" (skeep -2) (("5" (skolem -3 "n1") (("5" (skoletin -3 :postfix "1") (("5" (lemma "eval_expr_ge_n") (("5" (copy -1) (("5" (split -7) (("1" (flatten) (("1" (skolem -2 "n2") (("1" (skoletin -2 :postfix "1") (("1" (flatten) (("1" (inst 2 "max(n1,n2)") (("1" (skoletin 2) (("1" (insteep -7 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_cond(expr!1)") ("env" "env!1"))) (("1" (replace -10 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -6 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_if(expr!1)") ("env" "env!1"))) (("1" (replace -4 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -1) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skolem -3 "n2") (("2" (skoletin -3 :postfix "2") (("2" (flatten) (("2" (inst 1 "max(n1,n2)") (("2" (skoletin 1) (("2" (insteep -7 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_cond(expr!1)") ("env" "env!1"))) (("1" (replace -11 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -8 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_else(expr!1)") ("env" "env!1"))) (("1" (replace -4 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (flatten) (("6" (skeep -2) (("6" (skolem -3 "n1") (("6" (skoletin -3 :postfix "1") (("6" (flatten) (("6" (lemma "eval_expr_ge_n") (("6" (copy -1) (("6" (assert) (("6" (prop) (("1" (skeep) (("1" (expand "eval_expr" 1) (("1" (assert) (("1" (inst 1 "n1+n+1") (("1" (assert) (("1" (inst -5 "pvs0" "n1" "n1+n+1" "get_arg(expr!1)" "env!1") (("1" (assert) (("1" (inst -6 "pvs0" "n" "n1+n" "nth(pvs0`4, get_from_list(expr!1))" "valarg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_expr" 2) (("2" (assert) (("2" (inst 2 "n1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((semantic_rel_expr_induction formula-decl nil mf_pvs0_expr nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (AND const-decl "[bool, bool -> bool]" booleans nil) (upfrom nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_arg1 adt-accessor-decl "[(op2?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (get_arg2 adt-accessor-decl "[(op2?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}" real_defs nil) (posint_max application-judgement "{k: posint | i <= k AND j <= k}" real_defs nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (eval_expr_ge_n formula-decl nil mf_pvs0_expr nil) (n2 skolem-const-decl "posnat" mf_pvs0_expr nil) (n1 skolem-const-decl "posnat" mf_pvs0_expr nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (max_ge formula-decl nil real_defs nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_cond adt-accessor-decl "[(ite?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (get_else adt-accessor-decl "[(ite?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (n2 skolem-const-decl "posnat" mf_pvs0_expr nil) (get_if adt-accessor-decl "[(ite?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (n2 skolem-const-decl "posnat" mf_pvs0_expr nil) (n1 skolem-const-decl "posnat" mf_pvs0_expr nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil) (semantic_rel_eval_expr-2 nil 3603111426 ("" (skeep*) (("" (lemma "semantic_rel_expr_induction") (("" (insteep -1 :but "P") (("" (inst -1 "LAMBDA(x:mf_PVS0Expr,e:Val,v:Val):EXISTS (n:posnat): LET myv = eval_expr(false_val,eval_op1,eval_op2)(n,x,body,e) IN
                                    some?(myv) AND v=val(myv)") (("" (split -) (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (skosimp*) (("2" (split -) (("1" (flatten) (("1" (inst 1 "1") (("1" (expand "eval_expr") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst 1 "1") (("2" (expand "eval_expr") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skeep -2) (("3" (skeep -3) (("3" (insteep 1) (("3" (beta) (("3" (flatten) (("3" (expand "eval_expr" +) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (skeep -2) (("4" (skolem -3 "n1") (("4" (skoletin -3 :postfix "1") (("4" (skolem -6 "n2") (("4" (skoletin -6 :postfix "2") (("4" (flatten) (("4" (inst 1 "max(n1,n2)") (("4" (skoletin 1) (("4" (lemma "eval_expr_ge_n") (("4" (copy -1) (("4" (insteep -1 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_arg1(expr!1)") ("env" "env!1"))) (("1" (replace -9 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -2 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_arg2(expr!1)") ("env" "env!1"))) (("1" (replace -6 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -3) (("1" (assert) (("1" (replaces -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (flatten) (("5" (skeep -2) (("5" (skolem -3 "n1") (("5" (skoletin -3 :postfix "1") (("5" (lemma "eval_expr_ge_n") (("5" (copy -1) (("5" (split -7) (("1" (flatten) (("1" (skolem -3 "n2") (("1" (skoletin -3 :postfix "2") (("1" (flatten) (("1" (inst 1 "max(n1,n2)") (("1" (skoletin 1) (("1" (insteep -7 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_cond(expr!1)") ("env" "env!1"))) (("1" (replace -11 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -8 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_if(expr!1)") ("env" "env!1"))) (("1" (replace -4 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -1) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skolem -2 "n2") (("2" (skoletin -2 :postfix "2") (("2" (flatten) (("2" (inst 2 "max(n1,n2)") (("2" (skoletin 2) (("2" (insteep -6 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_cond(expr!1)") ("env" "env!1"))) (("1" (replace -10 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -7 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_else(expr!1)") ("env" "env!1"))) (("1" (replace -4 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (flatten) (("6" (skeep -2) (("6" (skolem -3 "n1") (("6" (skoletin -3 :postfix "1") (("6" (flatten) (("6" (skolem -7 "n2") (("6" (skoletin -7 :postfix "2") (("6" (flatten) (("6" (inst 1 "n1+n2+1") (("6" (skoletin 1) (("6" (lemma "eval_expr_ge_n") (("6" (copy -1) (("6" (insteep -1 :but (("n" "n1") ("m" "n1+n2+1") ("expr" "get_arg(expr!1)") ("env" "env!1"))) (("6" (replace -9 :dir rl) (("6" (assert) (("6" (assert) (("6" (insteep -2 :but (("n" "n2") ("m" "n1+n2") ("expr" "body") ("env" "LAMBDA(v:(vr?)):valarg"))) (("6" (replace -6 :dir rl) (("6" (assert) (("6" (expand "eval_expr" -3) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (get_arg1 adt-accessor-decl "[(op2?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (get_arg2 adt-accessor-decl "[(op2?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (get_cond adt-accessor-decl "[(ite?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (get_else adt-accessor-decl "[(ite?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (get_if adt-accessor-decl "[(ite?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil)) nil) (semantic_rel_eval_expr-1 nil 3603110753 ("" (skeep*) (("" (lemma "semantic_rel_expr_induction") (("" (insteep -1 :but "P") (("" (inst -1 "LAMBDA(x:mf_PVS0Expr,e:Val,v:Val):EXISTS (n:posnat): LET myv = eval_expr(false_val,eval_op1,eval_op2)(n,x,body,e) IN
                            some?(myv) AND v=val(myv) AND semantic_rel_expr(false_val,eval_op1,eval_op2)(x,body,e,v)") (("" (split -) (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (skosimp*) (("2" (split -) (("1" (flatten) (("1" (inst 1 "1") (("1" (expand "eval_expr") (("1" (assert) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst 1 "1") (("2" (expand "eval_expr") (("2" (assert) (("2" (expand "semantic_rel_expr") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skeep -2) (("3" (skeep -3) (("3" (insteep 1) (("3" (beta) (("3" (flatten) (("3" (expand "eval_expr" +) (("3" (assert) (("3" (expand "semantic_rel_expr" 1) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (skeep -2) (("4" (skolem -3 "n1") (("4" (skoletin -3 :postfix "1") (("4" (skolem -6 "n2") (("4" (skoletin -6 :postfix "2") (("4" (flatten) (("4" (inst 1 "max(n1,n2)") (("4" (skoletin 1) (("4" (lemma "eval_expr_ge_n") (("4" (copy -1) (("4" (insteep -1 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_arg1(expr!1)") ("env" "env!1"))) (("1" (replace -11 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -2 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_arg2(expr!1)") ("env" "env!1"))) (("1" (replace -7 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -3) (("1" (assert) (("1" (replaces -3) (("1" (assert) (("1" (expand "semantic_rel_expr" 1) (("1" (insteep 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (flatten) (("5" (skeep -2) (("5" (skolem -3 "n1") (("5" (skoletin -3 :postfix "1") (("5" (lemma "eval_expr_ge_n") (("5" (copy -1) (("5" (split -7) (("1" (flatten) (("1" (skolem -3 "n2") (("1" (skoletin -3 :postfix "2") (("1" (flatten) (("1" (inst 1 "max(n1,n2)") (("1" (skoletin 1) (("1" (insteep -8 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_cond(expr!1)") ("env" "env!1"))) (("1" (replace -13 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -9 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_if(expr!1)") ("env" "env!1"))) (("1" (replace -5 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -1) (("1" (replaces -1) (("1" (assert) (("1" (expand "semantic_rel_expr" 1) (("1" (insteep 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skolem -2 "n2") (("2" (skoletin -2 :postfix "2") (("2" (flatten) (("2" (inst 2 "max(n1,n2)") (("2" (skoletin 2) (("2" (insteep -7 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_cond(expr!1)") ("env" "env!1"))) (("1" (replace -12 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -8 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_else(expr!1)") ("env" "env!1"))) (("1" (replace -5 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -1) (("1" (assert) (("1" (expand "semantic_rel_expr" 1) (("1" (insteep 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (flatten) (("6" (skeep -2) (("6" (skolem -3 "n1") (("6" (skoletin -3 :postfix "1") (("6" (flatten) (("6" (skolem -8 "n2") (("6" (skoletin -8 :postfix "2") (("6" (flatten) (("6" (inst 1 "n1+n2+1") (("6" (skoletin 1) (("6" (lemma "eval_expr_ge_n") (("6" (copy -1) (("6" (insteep -1 :but (("n" "n1") ("m" "n1+n2+1") ("expr" "get_arg(expr!1)") ("env" "env!1"))) (("6" (replace -11 :dir rl) (("6" (assert) (("6" (assert) (("6" (insteep -2 :but (("n" "n2") ("m" "n1+n2") ("expr" "body") ("env" "valarg"))) (("6" (replace -7 :dir rl) (("6" (assert) (("6" (expand "eval_expr" -3) (("6" (assert) (("6" (expand "semantic_rel_expr" 1) (("6" (insteep 1) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((get_arg1 adt-accessor-decl "[(op2?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (get_arg2 adt-accessor-decl "[(op2?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (get_cond adt-accessor-decl "[(ite?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (get_else adt-accessor-decl "[(ite?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (get_if adt-accessor-decl "[(ite?) -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil)) nil)) (eval_expr_n_pos 0 (eval_expr_n_pos-1 nil 3642524186 ("" (skeep*) (("" (typepred "eval_expr(pvs0)(n, expr, env)") (("" (assert) nil nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (deterministic_expr 0 (deterministic_expr-1 nil 3603044754 ("" (skeep*) (("" (lemma "semantic_rel_eval_expr") (("" (copy -1) (("" (insteep -1 :but (("val" "val1"))) (("" (assert) (("" (insteep -2 :but (("val" "val2"))) (("" (assert) (("" (skolem -1 "n1") (("" (skolem -2 "n2") (("" (flatten) (("" (lemma "eval_expr_ge_n") (("" (copy -1) (("" (insteep -2 :but (("n" "n1") ("m" "max(n1,n2)"))) (("1" (insteep -1 :but (("n" "n2") ("m" "max(n1,n2)"))) (("1" (assert) (("1" (ground) nil nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((semantic_rel_eval_expr formula-decl nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (max_ge formula-decl nil real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (n2 skolem-const-decl "nat" mf_pvs0_expr nil) (n1 skolem-const-decl "nat" mf_pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (eval_expr_ge_n formula-decl nil mf_pvs0_expr nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (eval_expr_semantic_rel_j_TCC1 0 (eval_expr_semantic_rel_j_TCC1-1 nil 3642104985 ("" (skeep) (("" (assert) nil nil)) nil) ((eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].None" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC2 0 (eval_expr_semantic_rel_j_TCC2-1 nil 3642104985 ("" (skeep*) (("" (replaces -2) (("" (expand "semantic_rel_expr") (("" (propax) nil nil)) nil)) nil)) nil) ((semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.v)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC3 0 (eval_expr_semantic_rel_j_TCC3-2 "" 3804631313 ("" (skeep*) (("" (replaces -2) (("" (expand "semantic_rel_expr") (("" (propax) nil nil)) nil)) nil)) nil) ((semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.env)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}")) (eval_expr_semantic_rel_j_TCC3-1 nil 3642104985 ("" (skeep*) (("" (replaces -1) (("" (expand "semantic_rel_expr") (("" (propax) nil nil)) nil)) nil)) nil) nil nil (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.env)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC4 0 (eval_expr_semantic_rel_j_TCC4-1 nil 3642104985 ("" (skeep*) (("" (assert) nil nil)) nil) ((eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "mf_pvs0_expr.expr" "{x: mf_PVS0Expr_adt[mf_pvs0_expr.Val].mf_PVS0Expr | booleans.OR(mf_PVS0Expr_adt[mf_pvs0_expr.Val].op1?(x), mf_PVS0Expr_adt[mf_pvs0_expr.Val].op2?(x))}"))) (eval_expr_semantic_rel_j_TCC5 0 (eval_expr_semantic_rel_j_TCC5-2 nil 3799664514 ("" (skeep*) (("" (replace -2) (("" (expand "semantic_rel_expr" 2) (("" (inst 2 "val(v)") (("" (typepred "v") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (NOT const-decl "[bool -> bool]" booleans nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.eval_op1(mf_pvs0_expr.pvs0)(mf_PVS0Expr_adt[mf_pvs0_expr.Val].get_op(mf_pvs0_expr.expr), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v)))" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}")) (eval_expr_semantic_rel_j_TCC5-1 nil 3642104985 ("" (skeep*) (("" (replace -1) (("" (expand "semantic_rel_expr" 2) (("" (inst 2 "val(v)") (("" (typepred "v") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.eval_op1(mf_pvs0_expr.pvs0)(mf_PVS0Expr_adt[mf_pvs0_expr.Val].get_op(mf_pvs0_expr.expr), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v)))" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC6 0 (eval_expr_semantic_rel_j_TCC6-1 nil 3642104985 ("" (assert) nil nil) nil nil (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].None" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC7 0 (eval_expr_semantic_rel_j_TCC7-1 nil 3642104985 ("" (skeep*) (("" (assert) nil nil)) nil) ((eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "mf_pvs0_expr.expr" "{x: mf_PVS0Expr_adt[mf_pvs0_expr.Val].mf_PVS0Expr | booleans.OR(mf_PVS0Expr_adt[mf_pvs0_expr.Val].op1?(x), mf_PVS0Expr_adt[mf_pvs0_expr.Val].op2?(x))}"))) (eval_expr_semantic_rel_j_TCC8 0 (eval_expr_semantic_rel_j_TCC8-2 nil 3799664535 ("" (skeep*) (("" (replace -2) (("" (expand "semantic_rel_expr" 2) (("" (inst 2 "val(v1)" "val(v2)") (("" (typepred "v1" "v2") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (NOT const-decl "[bool -> bool]" booleans nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.eval_op2(mf_pvs0_expr.pvs0)(mf_PVS0Expr_adt[mf_pvs0_expr.Val].get_op(mf_pvs0_expr.expr), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v1), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v2)))" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}")) (eval_expr_semantic_rel_j_TCC8-1 nil 3642104985 ("" (skeep*) (("" (replace -1) (("" (expand "semantic_rel_expr" 2) (("" (inst 2 "val(v1)" "val(v2)") (("" (typepred "v1" "v2") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.eval_op2(mf_pvs0_expr.pvs0)(mf_PVS0Expr_adt[mf_pvs0_expr.Val].get_op(mf_pvs0_expr.expr), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v1), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v2)))" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC9 0 (eval_expr_semantic_rel_j_TCC9-1 nil 3642104985 ("" (assert) nil nil) nil nil (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].None" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC10 0 (eval_expr_semantic_rel_j_TCC10-2 nil 3799664561 ("" (skeep* :preds? t) (("" (assert) (("" (replace -4) (("" (expand "semantic_rel_expr" 3) (("" (inst 3 "val(vc)") (("" (assert) (("" (typepred "v3(pvs0)(i, arg1, env)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "mf_pvs0_expr.v3(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.arg1, mf_pvs0_expr.env)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}")) (eval_expr_semantic_rel_j_TCC10-1 nil 3642104985 ("" (skeep* :preds? t) (("" (assert) (("" (replace -3) (("" (expand "semantic_rel_expr" 3) (("" (inst 3 "val(vc)") (("" (assert) (("" (typepred "v3(pvs0)(i, arg1, env)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) nil (eval_expr_semantic_rel_j_ subtype "mf_pvs0_expr.v3(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.arg1, mf_pvs0_expr.env)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC11 0 (eval_expr_semantic_rel_j_TCC11-2 nil 3799664582 ("" (skeep*) (("" (assert) (("" (expand "semantic_rel_expr") (("" (inst 2 "val(vc)") (("" (replace -2) (("" (typepred "vc") (("" (assert) (("" (typepred "v3(pvs0)(i, arg2, env)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "mf_pvs0_expr.v3(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.arg2, mf_pvs0_expr.env)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}")) (eval_expr_semantic_rel_j_TCC11-1 nil 3642104985 ("" (skeep*) (("" (assert) (("" (expand "semantic_rel_expr") (("" (inst 2 "val(vc)") (("" (replace -1) (("" (typepred "vc") (("" (assert) (("" (typepred "v3(pvs0)(i, arg2, env)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil)) nil (eval_expr_semantic_rel_j_ subtype "mf_pvs0_expr.v3(mf_pvs0_expr.pvs0)(mf_pvs0_expr.i, mf_pvs0_expr.arg2, mf_pvs0_expr.env)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC12 0 (eval_expr_semantic_rel_j_TCC12-2 nil 3665232854 ("" (skeep*) (("" (assert) nil nil)) nil) ((eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].None" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}")) (eval_expr_semantic_rel_j_TCC12-1 nil 3642104985 ("" (skeep*) (("" (typepred "v3(false_val, eval_op1, eval_op2)(n, arg, body, env)") (("" (typepred "v3(false_val, eval_op1, eval_op2)
                               (n - 1, body, body,
                                LAMBDA (v_1: (vr?[Val])): val[T](v))") (("1" (replaces -5 :dir rl) (("1" (name-replace "REC" "v3(false_val, eval_op1, eval_op2)
              (n - 1, body, body, LAMBDA (v_1: (vr?[Val])): val[T](v))") (("1" (assert) (("1" (replaces -3) (("1" (expand "semantic_rel_expr" 2) (("1" (inst? +) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil) ((val adt-accessor-decl "[(some?) -> T]" Maybe structures) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].None" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC13 0 (eval_expr_semantic_rel_j_TCC13-1 nil 3642104985 ("" (skeep*) (("" (assert) nil nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "(number_fields.-)(mf_pvs0_expr.i, 1)" "nat"))) (eval_expr_semantic_rel_j_TCC14 0 (eval_expr_semantic_rel_j_TCC14-2 nil 3799664601 ("" (skeep*) (("" (replace -2) (("" (expand "semantic_rel_expr") (("" (inst 2 "val(v)") (("" (typepred "v") (("" (assert) (("" (typepred "v3(pvs0)
                                 (i - 1, nth[mf_PVS0Expr[Val]](pvs0`4, n),
                                  val[Val](v))") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "mf_pvs0_expr.v3(mf_pvs0_expr.pvs0)((number_fields.-)(mf_pvs0_expr.i, 1), list_props[mf_PVS0Expr_adt[mf_pvs0_expr.Val].mf_PVS0Expr].nth(mf_pvs0_expr.pvs0`4, mf_pvs0_expr.n), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v))" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}")) (eval_expr_semantic_rel_j_TCC14-1 nil 3709912304 ("" (skeep*) (("" (replace -1) (("" (expand "semantic_rel_expr") (("" (inst 2 "val(v)") (("" (typepred "v") (("" (assert) (("" (typepred "v3(pvs0)
                               (i - 1, nth[mf_PVS0Expr[Val]](pvs0`4, n),
                                val[Val](v))") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil)) nil (eval_expr_semantic_rel_j_ subtype "mf_pvs0_expr.v3(mf_pvs0_expr.pvs0)((number_fields.-)(mf_pvs0_expr.i, 1), list_props[mf_PVS0Expr_adt[mf_pvs0_expr.Val].mf_PVS0Expr].nth(mf_pvs0_expr.pvs0`4, mf_pvs0_expr.n), Maybe[mf_pvs0_expr.Val].val(mf_pvs0_expr.v))" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC15 0 (eval_expr_semantic_rel_j_TCC15-2 nil 3799664621 ("" (skeep* :preds? t) (("" (replaces -5) (("" (expand "semantic_rel_expr" 3) (("" (assert) (("" (inst 3 "val(v)") nil nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.pvs0`3)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}")) (eval_expr_semantic_rel_j_TCC15-1 nil 3709912304 ("" (skeep* :preds? t) (("" (replaces -4) (("" (expand "semantic_rel_expr" 3) (("" (assert) (("" (inst 3 "val(v)") nil nil)) nil)) nil)) nil)) nil) ((mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].Some(mf_pvs0_expr.pvs0`3)" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC16 0 (eval_expr_semantic_rel_j_TCC16-1 nil 3746195529 ("" (recursive-judgement-tcc) nil nil) nil nil (eval_expr_semantic_rel_j_ subtype "Maybe[mf_pvs0_expr.Val].None" "{myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_TCC1 0 (eval_expr_semantic_rel_TCC1-2 "" 3885320105 ("" (lemma "eval_expr_ge_n_j") (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) nil shostak (eval_expr_semantic_rel subtype "mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.n, mf_pvs0_expr.expr, mf_pvs0_expr.env)" "{x: {myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))} | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(x), booleans.AND(reals.>(mf_pvs0_expr.n, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.n)): x = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}")) (eval_expr_semantic_rel_TCC1-1 nil 3885253663 ("" (subtype-tcc) nil nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (eval_expr_semantic_rel_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}" mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (eval_expr_ge_n_j recursive-judgement-axiom nil mf_pvs0_expr nil)) nil (eval_expr_semantic_rel subtype "mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.n, mf_pvs0_expr.expr, mf_pvs0_expr.env)" "{x: {myv: Maybe[mf_pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(myv), mf_pvs0_expr.semantic_rel_expr(mf_pvs0_expr.pvs0)(mf_pvs0_expr.expr, mf_pvs0_expr.env, Maybe[mf_pvs0_expr.Val].val(myv)))} | booleans.IMPLIES(Maybe[mf_pvs0_expr.Val].some?(x), booleans.AND(reals.>(mf_pvs0_expr.n, 0), FORALL (m: integers.upfrom(mf_pvs0_expr.n)): x = mf_pvs0_expr.eval_expr(mf_pvs0_expr.pvs0)(m, mf_pvs0_expr.expr, mf_pvs0_expr.env)))}"))) (eval_expr_semantic_rel 0 (eval_expr_semantic_rel-1 nil 3642104637 ("" (skeep*) (("" (skoletin 1) (("" (typepred "eval_expr(pvs0)(n, expr, env)") (("" (hide -2) (("" (flatten) (("" (replaces -4 :dir rl) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((val adt-accessor-decl "[(some?) -> T]" Maybe structures) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (eval_expr_semantic_rel_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}" mf_pvs0_expr nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (eval_expr_terminates 0 (eval_expr_terminates-1 nil 3603051644 ("" (skeep) (("" (split) (("1" (flatten) (("1" (expand "eval_expr_termination") (("1" (expand "terminates_expr") (("1" (skeep) (("1" (insteep -1) (("1" (skeep) (("1" (inst 1 "val(eval_expr(pvs0)(n, expr , env))") (("1" (lemma "eval_expr_semantic_rel") (("1" (beta) (("1" (insteep :but "val") (("1" (inst -1 "val(eval_expr(pvs0)(n, expr, env))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "terminates_expr") (("2" (expand "eval_expr_termination") (("2" (skeep*) (("2" (insteep*) (("2" (skeep) (("2" (lemma "semantic_rel_eval_expr") (("2" (insteep -1) (("2" (assert) (("2" (skeep) (("2" (insteep 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_expr_semantic_rel_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}" mf_pvs0_expr nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_expr nil) (eval_expr_termination const-decl "bool" mf_pvs0_expr nil) (eval_expr_semantic_rel formula-decl nil mf_pvs0_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (Maybe type-decl nil Maybe structures) (boolean nonempty-type-decl nil booleans nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (pvs0 skolem-const-decl "PVS0" mf_pvs0_expr nil) (n skolem-const-decl "nat" mf_pvs0_expr nil) (expr skolem-const-decl "mf_PVS0Expr[Val]" mf_pvs0_expr nil) (env skolem-const-decl "Val" mf_pvs0_expr nil) (Val formal-nonempty-type-decl nil mf_pvs0_expr nil) (terminates_expr const-decl "bool" mf_pvs0_expr nil) (TRUE const-decl "bool" booleans nil) (semantic_rel_eval_expr formula-decl nil mf_pvs0_expr nil)) shostak)))
