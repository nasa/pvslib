(pvs0_eval (pvs0_eval_expr_TCC1 0 (pvs0_eval_expr_TCC1-1 nil 3682847758 ("" (skeep) (("" (typepred "pvs0") (("" (use "terminates_implies_pvs0_tcc") (("" (assert) nil nil)) nil)) nil)) nil) ((terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (terminates_implies_pvs0_tcc formula-decl nil measure_termination nil)) nil (pvs0_eval_expr subtype "pvs0_eval.pvs0" "(measure_termination_defs[pvs0_eval.Val, MT, LAMBDA (m, n: naturalnumbers.nat): reals.<(m, n)].pvs0_tcc_termination)"))) (pvs0_eval_expr_TCC2 0 (pvs0_eval_expr_TCC2-1 nil 3682847758 ("" (skosimp*) (("" (rewrite "wf_nat") nil nil)) nil) ((wf_nat formula-decl nil naturalnumbers nil)) nil (pvs0_eval_expr subtype "LAMBDA (m, n: naturalnumbers.nat): reals.<(m, n)" "(orders[MT].well_founded?)"))) (pvs0_eval_expr_TCC3 0 (pvs0_eval_expr_TCC3-2 nil 3684365534 ("" (skolem 1 "pvs0") (("" (typepred "pvs0") (("" (use "terminates_implies_pvs0_tcc") (("" (assert) nil nil)) nil)) nil)) nil) ((terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (terminates_implies_pvs0_tcc formula-decl nil measure_termination nil)) nil (pvs0_eval_expr subtype "pvs01" "(measure_termination_defs[pvs0_eval.Val, MT, LAMBDA (m, n: naturalnumbers.nat): reals.<(m, n)].pvs0_tcc_termination)"))) (pvs0_eval_expr_TCC4 0 (pvs0_eval_expr_TCC4-1 nil 3682847758 ("" (skeep) (("" (replaces -1) (("" (expand "semantic_rel_expr") (("" (propax) nil nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil)) nil (pvs0_eval_expr subtype "pvs0_eval.v" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}"))) (pvs0_eval_expr_TCC5 0 (pvs0_eval_expr_TCC5-2 nil 3684365451 ("" (skeep) (("" (replaces -1) (("" (expand "semantic_rel_expr") (("" (propax) nil nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil)) nil (pvs0_eval_expr subtype "pvs0_eval.val" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}"))) (pvs0_eval_expr_TCC6 0 (pvs0_eval_expr_TCC6-5 "" 3790336397 ("" (skeep*) (("" (grind) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:0:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "append((:0:),path)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (replace -3) (("2" (expand "valid_path") (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subterm_append formula-decl nil pvs0_props nil) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (path skolem-const-decl "(valid_path(pvs0`4))" pvs0_eval nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (rdc const-decl "list[T]" more_list_props structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (append def-decl "list[T]" list_props nil) (reverse def-decl "list[T]" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (rac const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (null_path formula-decl nil pvs0_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (Path type-eq-decl nil pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0 type-eq-decl nil pvs0_expr nil) (terminating? const-decl "bool" pvs0_lang nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC6-4 nil 3769264240 ("" (skeep*) (("" (grind) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:0:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "append((:0:),path)") (("1" (assert) nil))))))))))))))))))))) ("2" (replace -1) (("2" (replace -3) (("2" (expand "valid_path") (("2" (grind) (("2" (rewrite "null_path") nil)))))))))))))))))))))))) nil) ((subterm_append formula-decl nil pvs0_props nil) nil nil (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (rdc const-decl "list[T]" more_list_props structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (append def-decl "list[T]" list_props nil) (reverse def-decl "list[T]" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (rac const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (null_path formula-decl nil pvs0_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (Path type-eq-decl nil pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0 type-eq-decl nil pvs0_expr nil) (terminating? const-decl "bool" pvs0_lang nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC6-3 nil 3768987944 ("" (skeep*) (("" (assert) nil)) nil) nil nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC6-1 nil 3768986814 ("" (skeep*) (("" (assert) nil)) nil) nil nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC6-2 nil 3684365407 ("" (skeep*) (("" (assert) nil nil)) nil) nil nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}"))) (pvs0_eval_expr_TCC7 0 (pvs0_eval_expr_TCC7-3 "" 3790336397 ("" (skeep) (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg, pvs0_eval.val)" "nil")) (pvs0_eval_expr_TCC7-1 nil 3769264240 ("" (skeep) (("" (rewrite "lex2_lt") (("" (grind) nil)))) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg, pvs0_eval.val)" "nil")) (pvs0_eval_expr_TCC7-2 nil 3684365361 ("" (skeep*) (("" (typepred "v") (("" (hide -3) (("" (replaces -2) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "v") nil nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (Conditions type-eq-decl nil pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (terminating? const-decl "bool" pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg, pvs0_eval.val)" "nil"))) (pvs0_eval_expr_TCC8 0 (pvs0_eval_expr_TCC8-1 "" 3790336398 ("" (skeep*) (("" (grind) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr subtype "pvs0_eval.expr" "{x: PVS0Expr_adt[pvs0_eval.Val].PVS0Expr | booleans.OR(PVS0Expr_adt[pvs0_eval.Val].op1?(x), PVS0Expr_adt[pvs0_eval.Val].op2?(x))}")) (pvs0_eval_expr_TCC8-3 nil 3742984969 ("" (skeep*) (("" (grind) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:0:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "append((:0:),path)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (replace -3) (("2" (expand "valid_path") (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr subtype "pvs0_eval.expr" "{x: PVS0Expr_adt[pvs0_eval.Val].PVS0Expr | booleans.OR(PVS0Expr_adt[pvs0_eval.Val].op1?(x), PVS0Expr_adt[pvs0_eval.Val].op2?(x))}"))) (pvs0_eval_expr_TCC9 0 (pvs0_eval_expr_TCC9-3 "" 3790336398 ("" (skeep*) (("" (typepred "v") (("" (hide -3) (("" (replaces -2) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "v") nil nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (terminating? const-decl "bool" pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr subtype "pvs0_expr[pvs0_eval.Val].eval_op1(pvs0_eval.pvs0)(PVS0Expr_adt[pvs0_eval.Val].get_op(pvs0_eval.expr), pvs0_eval.v)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}")) (pvs0_eval_expr_TCC9-1 nil 3769264240 ("" (skeep*) (("" (typepred "v") (("" (hide -3) (("" (replaces -2) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "v") nil)))))))))) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (terminating? const-decl "bool" pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr subtype "pvs0_expr[pvs0_eval.Val].eval_op1(pvs0_eval.pvs0)(PVS0Expr_adt[pvs0_eval.Val].get_op(pvs0_eval.expr), pvs0_eval.v)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}")) (pvs0_eval_expr_TCC9-2 nil 3742990557 ("" (skeep) (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil) ((well_founded? const-decl "bool" orders nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (Conditions type-eq-decl nil pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil)) nil (pvs0_eval_expr subtype "pvs0_expr[pvs0_eval.Val].eval_op1(pvs0_eval.pvs0)(PVS0Expr_adt[pvs0_eval.Val].get_op(pvs0_eval.expr), pvs0_eval.v)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}"))) (pvs0_eval_expr_TCC10 0 (pvs0_eval_expr_TCC10-2 "" 3790336399 ("" (skeep) (("" (typepred "val") (("" (skeep) (("" (lemma "subterm_append") (("" (inst -1 "get_body(pvs0)" "path") (("" (assert) (("" (inst -1 "(:0:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "append((:0:),path)") (("1" (assert) (("1" (expand "append") (("1" (expand "append") (("1" (expand "path_conditions" 1) (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "valid_path" 1) (("2" (flatten) (("2" (hide 2) (("2" (expand "rac") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (subterm_append formula-decl nil pvs0_props nil) (null_path formula-decl nil pvs0_props nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (path skolem-const-decl "(valid_path(pvs0`4))" pvs0_eval nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)) shostak (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg1, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC10-1 nil 3769264240 ("" (skeep) (("" (typepred "val") (("" (skeep) (("" (lemma "subterm_append") (("" (inst -1 "get_body(pvs0)" "path") (("" (assert) (("" (inst -1 "(:0:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "append((:0:),path)") (("1" (assert) (("1" (expand "append") (("1" (expand "append") (("1" (expand "path_conditions" 1) (("1" (expand "append") (("1" (propax) nil))))))))))) ("2" (grind) nil))))))))))))))))))))))))))))) ("2" (expand "valid_path" 1) (("2" (flatten) (("2" (hide 2) (("2" (expand "rac") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (grind) (("2" (rewrite "null_path") nil))))))))))))))))) ("3" (hide-all-but 1) (("3" (grind) nil)))))))))))))))) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (subterm_append formula-decl nil pvs0_props nil) (null_path formula-decl nil pvs0_props nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) nil nil (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)) nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg1, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC10-3 nil 3742992082 ("" (skeep*) (("" (hide -2) (("" (grind) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:1:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "append((:1:),path)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (replace -3) (("2" (expand "valid_path") (("2" (flatten) (("2" (hide 1) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (Conditions type-eq-decl nil pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (list type-decl nil list_adt nil) (null_path formula-decl nil pvs0_props nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (subterm_append formula-decl nil pvs0_props nil)) nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg1, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}"))) (pvs0_eval_expr_TCC11 0 (pvs0_eval_expr_TCC11-2 "" 3790336400 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg1, pvs0_eval.val)" "nil")) (pvs0_eval_expr_TCC11-1 nil 3682847758 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (hide -2) (("" (grind) nil nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg1, pvs0_eval.val)" "nil"))) (pvs0_eval_expr_TCC12 0 (pvs0_eval_expr_TCC12-2 "" 3790336401 ("" (skeep*) (("" (hide -2) (("" (grind) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:1:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "append((:1:),path)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (replace -3) (("2" (expand "valid_path") (("2" (flatten) (("2" (hide 1) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (null_path formula-decl nil pvs0_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (path skolem-const-decl "(valid_path(pvs0`4))" pvs0_eval nil) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (subterm_append formula-decl nil pvs0_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg2, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC12-1 nil 3769264240 ("" (skeep*) (("" (hide -2) (("" (grind) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:1:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "append((:1:),path)") (("1" (assert) nil))))))))))))))))))))))))))))) ("2" (replace -1) (("2" (replace -3) (("2" (expand "valid_path") (("2" (flatten) (("2" (hide 1) (("2" (grind) (("2" (rewrite "null_path") nil)))))))))))))))))))))))))))))) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (null_path formula-decl nil pvs0_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) nil nil (subterm_append formula-decl nil pvs0_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg2, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC12-3 nil 3707580786 ("" (skeep*) (("" (assert) nil nil)) nil) nil nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg2, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}"))) (pvs0_eval_expr_TCC13 0 (pvs0_eval_expr_TCC13-2 "" 3790336402 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (hide -2) (("" (grind) nil nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg2, pvs0_eval.val)" "nil")) (pvs0_eval_expr_TCC13-1 nil 3769264240 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (hide -2) (("" (grind) nil)))))) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg2, pvs0_eval.val)" "nil")) (pvs0_eval_expr_TCC13-3 nil 3707580821 ("" (skeep*) (("" (typepred "v1") (("" (typepred "v2") (("" (hide (-4 -5)) (("" (replaces -3) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "v1" "v2") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (Conditions type-eq-decl nil pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (terminating? const-decl "bool" pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg2, pvs0_eval.val)" "nil"))) (pvs0_eval_expr_TCC14 0 (pvs0_eval_expr_TCC14-1 "" 3790336402 ("" (skeep) (("" (typepred "val") (("" (skeep) (("" (lemma "subterm_append") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (subterm_append formula-decl nil pvs0_props nil)) shostak (pvs0_eval_expr subtype "pvs0_eval.expr" "{x: PVS0Expr_adt[pvs0_eval.Val].PVS0Expr | booleans.OR(PVS0Expr_adt[pvs0_eval.Val].op1?(x), PVS0Expr_adt[pvs0_eval.Val].op2?(x))}")) (pvs0_eval_expr_TCC14-2 nil 3742992468 ("" (skeep) (("" (typepred "val") (("" (skeep) (("" (lemma "subterm_append") (("" (inst -1 "get_body(pvs0)" "path") (("" (assert) (("" (inst -1 "(:0:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "append((:0:),path)") (("1" (assert) (("1" (expand "append") (("1" (expand "append") (("1" (expand "path_conditions" 1) (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "valid_path" 1) (("2" (flatten) (("2" (hide 2) (("2" (expand "rac") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (subterm_append formula-decl nil pvs0_props nil)) nil (pvs0_eval_expr subtype "pvs0_eval.expr" "{x: PVS0Expr_adt[pvs0_eval.Val].PVS0Expr | booleans.OR(PVS0Expr_adt[pvs0_eval.Val].op1?(x), PVS0Expr_adt[pvs0_eval.Val].op2?(x))}"))) (pvs0_eval_expr_TCC15 0 (pvs0_eval_expr_TCC15-2 "" 3790336403 ("" (skeep*) (("" (typepred "v1") (("" (typepred "v2") (("" (hide (-4 -5)) (("" (replaces -3) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "v1" "v2") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (terminating? const-decl "bool" pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr subtype "pvs0_expr[pvs0_eval.Val].eval_op2(pvs0_eval.pvs0)(PVS0Expr_adt[pvs0_eval.Val].get_op(pvs0_eval.expr), pvs0_eval.v1, pvs0_eval.v2)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}")) (pvs0_eval_expr_TCC15-1 nil 3769264240 ("" (skeep*) (("" (typepred "v1") (("" (typepred "v2") (("" (hide (-4 -5)) (("" (replaces -3) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "v1" "v2") (("" (assert) nil)))))))))))))) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (terminating? const-decl "bool" pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr subtype "pvs0_expr[pvs0_eval.Val].eval_op2(pvs0_eval.pvs0)(PVS0Expr_adt[pvs0_eval.Val].get_op(pvs0_eval.expr), pvs0_eval.v1, pvs0_eval.v2)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}")) (pvs0_eval_expr_TCC15-3 nil 3707580854 ("" (skeep) (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil) ((well_founded? const-decl "bool" orders nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (Conditions type-eq-decl nil pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil)) nil (pvs0_eval_expr subtype "pvs0_expr[pvs0_eval.Val].eval_op2(pvs0_eval.pvs0)(PVS0Expr_adt[pvs0_eval.Val].get_op(pvs0_eval.expr), pvs0_eval.v1, pvs0_eval.v2)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}"))) (pvs0_eval_expr_TCC16 0 (pvs0_eval_expr_TCC16-3 "" 3790336404 ("" (skeep) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:0:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "cons(0,path)") (("1" (assert) (("1" (expand "path_conditions" 1) (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_path formula-decl nil pvs0_props nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (path skolem-const-decl "(valid_path(pvs0`4))" pvs0_eval nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (subterm_append formula-decl nil pvs0_props nil)) shostak (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.cnd, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC16-1 nil 3769264240 ("" (skeep) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:0:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "cons(0,path)") (("1" (assert) (("1" (expand "path_conditions" 1) (("1" (expand "append") (("1" (propax) nil))))))))))))))))))))))))))))))))))))) ("2" (grind) (("2" (rewrite "null_path") nil))) ("3" (hide-all-but 1) (("3" (grind) nil)))))))))))))))) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_path formula-decl nil pvs0_props nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) nil nil (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (subterm_append formula-decl nil pvs0_props nil)) nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.cnd, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC16-2 nil 3742994456 ("" (skeep*) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:1:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 2 "append((:1:),path)") (("1" (assert) (("1" (expand "append") (("1" (expand "append") (("1" (expand "path_conditions" 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "eval_conds" 2) (("1" (inst 2 "vc") (("1" (assert) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (rewrite "null_path") nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (Conditions type-eq-decl nil pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (list type-decl nil list_adt nil) (null_path formula-decl nil pvs0_props nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (subterm_append formula-decl nil pvs0_props nil)) nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.cnd, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}"))) (pvs0_eval_expr_TCC17 0 (pvs0_eval_expr_TCC17-2 "" 3790336404 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.cnd, pvs0_eval.val)" "nil")) (pvs0_eval_expr_TCC17-1 nil 3769264240 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (grind) nil)))) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.cnd, pvs0_eval.val)" "nil")) (pvs0_eval_expr_TCC17-3 nil 3707580886 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (hide (-2 1)) (("" (grind) nil nil)) nil)) nil)) nil) ((well_founded? const-decl "bool" orders nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (Conditions type-eq-decl nil pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.cnd, pvs0_eval.val)" "nil"))) (pvs0_eval_expr_TCC18 0 (pvs0_eval_expr_TCC18-2 "" 3790336406 ("" (skeep*) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:1:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 2 "append((:1:),path)") (("1" (assert) (("1" (expand "append") (("1" (expand "append") (("1" (expand "path_conditions" 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "eval_conds" 2) (("1" (inst 2 "vc") (("1" (assert) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_path formula-decl nil pvs0_props nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (path skolem-const-decl "(valid_path(pvs0`4))" pvs0_eval nil) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (subterm_append formula-decl nil pvs0_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg1, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC18-1 nil 3769264240 ("" (skeep*) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:1:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 2 "append((:1:),path)") (("1" (assert) (("1" (expand "append") (("1" (expand "append") (("1" (expand "path_conditions" 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "eval_conds" 2) (("1" (inst 2 "vc") (("1" (assert) (("1" (replace -2) (("1" (assert) nil))))))))))))))))))))) ("2" (grind) nil))))))))))))))))))))))))))))) ("2" (grind) (("2" (rewrite "null_path") nil))) ("3" (hide-all-but 1) (("3" (grind) nil)))))))))))))))) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_path formula-decl nil pvs0_props nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) nil nil (subterm_append formula-decl nil pvs0_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg1, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC18-4 nil 3742994799 ("" (skeep*) (("" (replace -1) (("" (expand "semantic_rel_expr" 2) (("" (inst 2 "vc") (("" (assert) (("" (typepred "v(pvs0)(arg1, val)") (("1" (propax) nil nil) ("2" (typepred "val") (("2" (lemma "subterm_append") (("2" (skeep) (("2" (inst -1 "get_body(pvs0)" "path") (("2" (beta) (("2" (inst -1 "(:1:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "cons(1,path)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (terminating? const-decl "bool" pvs0_lang nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (Conditions type-eq-decl nil pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (MT type-eq-decl nil pvs0_prelude nil) (subterm_append formula-decl nil pvs0_props nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (rac const-decl "T" more_list_props structures) (rdc const-decl "list[T]" more_list_props structures) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil)) nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg1, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}"))) (pvs0_eval_expr_TCC19 0 (pvs0_eval_expr_TCC19-2 "" 3790336406 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (hide (-2 1)) (("" (grind) nil nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg1, pvs0_eval.val)" "nil")) (pvs0_eval_expr_TCC19-1 nil 3769264240 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (hide (-2 1)) (("" (grind) nil)))))) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg1, pvs0_eval.val)" "nil")) (pvs0_eval_expr_TCC19-4 nil 3742995554 ("" (skeep*) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:2:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "append((:2:),path)") (("1" (assert) (("1" (expand "append") (("1" (expand "append") (("1" (expand "path_conditions" 1) (("1" (expand "append") (("1" (expand "append") (("1" (expand "eval_conds" 1) (("1" (inst 1 "vc") (("1" (assert) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (rewrite "null_path") nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (Conditions type-eq-decl nil pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (list type-decl nil list_adt nil) (null_path formula-decl nil pvs0_props nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (subterm_append formula-decl nil pvs0_props nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg1, pvs0_eval.val)" "nil"))) (pvs0_eval_expr_TCC20 0 (pvs0_eval_expr_TCC20-2 "" 3790336407 ("" (skeep*) (("" (replace -1) (("" (expand "semantic_rel_expr" 2) (("" (inst 2 "vc") (("" (assert) (("" (typepred "v(pvs0)(arg1, val)") (("1" (propax) nil nil) ("2" (typepred "val") (("2" (lemma "subterm_append") (("2" (skeep) (("2" (inst -1 "get_body(pvs0)" "path") (("2" (beta) (("2" (inst -1 "(:1:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "cons(1,path)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (terminating? const-decl "bool" pvs0_lang nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (< const-decl "bool" reals nil) (MT type-eq-decl nil pvs0_prelude nil) (lex2 const-decl "ordinal" lex2 nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (subterm_append formula-decl nil pvs0_props nil) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (path skolem-const-decl "(valid_path(pvs0`4))" pvs0_eval nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (rac const-decl "T" more_list_props structures) (rdc const-decl "list[T]" more_list_props structures) (append def-decl "list[T]" list_props nil) (reverse def-decl "list[T]" list_props nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr subtype "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg1, pvs0_eval.val)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}")) (pvs0_eval_expr_TCC20-1 nil 3769264240 ("" (skeep*) (("" (replace -1) (("" (expand "semantic_rel_expr" 2) (("" (inst 2 "vc") (("" (assert) (("" (typepred "v(pvs0)(arg1, val)") (("1" (propax) nil) ("2" (typepred "val") (("2" (lemma "subterm_append") (("2" (skeep) (("2" (inst -1 "get_body(pvs0)" "path") (("2" (beta) (("2" (inst -1 "(:1:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "cons(1,path)") (("1" (assert) nil))))))))))))))))))))))))))))))) ("2" (grind) nil) ("3" (grind) nil)))))))))))))))))))))))) nil) ((Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (terminating? const-decl "bool" pvs0_lang nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (< const-decl "bool" reals nil) (MT type-eq-decl nil pvs0_prelude nil) (lex2 const-decl "ordinal" lex2 nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (subterm_append formula-decl nil pvs0_props nil) nil nil (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (rac const-decl "T" more_list_props structures) (rdc const-decl "list[T]" more_list_props structures) (append def-decl "list[T]" list_props nil) (reverse def-decl "list[T]" list_props nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr subtype "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg1, pvs0_eval.val)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}")) (pvs0_eval_expr_TCC20-3 nil 3707581320 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (hide -2 -3) (("" (grind) nil nil)) nil)) nil)) nil) ((well_founded? const-decl "bool" orders nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (Conditions type-eq-decl nil pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil)) nil (pvs0_eval_expr subtype "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg1, pvs0_eval.val)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}"))) (pvs0_eval_expr_TCC21 0 (pvs0_eval_expr_TCC21-2 "" 3790336409 ("" (skeep*) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:2:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "append((:2:),path)") (("1" (assert) (("1" (expand "append") (("1" (expand "append") (("1" (expand "path_conditions" 1) (("1" (expand "append") (("1" (expand "append") (("1" (expand "eval_conds" 1) (("1" (inst 1 "vc") (("1" (assert) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_path formula-decl nil pvs0_props nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (path skolem-const-decl "(valid_path(pvs0`4))" pvs0_eval nil) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (subterm_append formula-decl nil pvs0_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg2, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC21-1 nil 3769264240 ("" (skeep*) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:2:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append" -1 2) (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "append((:2:),path)") (("1" (assert) (("1" (expand "append") (("1" (expand "append") (("1" (expand "path_conditions" 1) (("1" (expand "append") (("1" (expand "append") (("1" (expand "eval_conds" 1) (("1" (inst 1 "vc") (("1" (assert) (("1" (replace -2) (("1" (assert) nil))))))))))))))))))))) ("2" (grind) nil))))))))))))))))))))))))))))) ("2" (grind) (("2" (rewrite "null_path") nil))) ("3" (hide-all-but 1) (("3" (grind) nil)))))))))))))))) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_path formula-decl nil pvs0_props nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) nil nil (subterm_append formula-decl nil pvs0_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg2, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC21-4 nil 3742995193 ("" (skeep*) (("" (replace -1) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "vc") (("" (assert) (("" (typepred "v(pvs0)(arg2, val)") (("1" (propax) nil nil) ("2" (typepred "val") (("2" (lemma "subterm_append") (("2" (skeep) (("2" (inst -1 "get_body(pvs0)" "path") (("2" (beta) (("2" (inst -1 "(:2:)") (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "cons(2,path)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (terminating? const-decl "bool" pvs0_lang nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (Conditions type-eq-decl nil pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (MT type-eq-decl nil pvs0_prelude nil) (subterm_append formula-decl nil pvs0_props nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil)) nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg2, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}"))) (pvs0_eval_expr_TCC22 0 (pvs0_eval_expr_TCC22-3 "" 3790336410 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (hide -2 -3) (("" (grind) nil nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg2, pvs0_eval.val)" "nil")) (pvs0_eval_expr_TCC22-1 nil 3769264240 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (hide -2 -3) (("" (grind) nil)))))) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg2, pvs0_eval.val)" "nil")) (pvs0_eval_expr_TCC22-2 nil 3743024789 ("" (skeep) (("" (typepred "val") (("" (lemma "subterm_append") (("" (skeep) (("" (inst -1 "get_body(pvs0)" "path") (("" (beta) (("" (inst -1 "(:0:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "cons(0,path)") (("1" (assert) (("1" (expand "path_conditions" 1) (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (rewrite "null_path") nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (Conditions type-eq-decl nil pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (list type-decl nil list_adt nil) (null_path formula-decl nil pvs0_props nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (subterm_append formula-decl nil pvs0_props nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg2, pvs0_eval.val)" "nil"))) (pvs0_eval_expr_TCC23 0 (pvs0_eval_expr_TCC23-3 "" 3790336411 ("" (skeep*) (("" (replace -1) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "vc") (("" (assert) (("" (typepred "v(pvs0)(arg2, val)") (("1" (propax) nil nil) ("2" (typepred "val") (("2" (lemma "subterm_append") (("2" (skeep) (("2" (inst -1 "get_body(pvs0)" "path") (("2" (beta) (("2" (inst -1 "(:2:)") (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "cons(2,path)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (terminating? const-decl "bool" pvs0_lang nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (< const-decl "bool" reals nil) (MT type-eq-decl nil pvs0_prelude nil) (lex2 const-decl "ordinal" lex2 nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (subterm_append formula-decl nil pvs0_props nil) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (path skolem-const-decl "(valid_path(pvs0`4))" pvs0_eval nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr subtype "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg2, pvs0_eval.val)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}")) (pvs0_eval_expr_TCC23-1 nil 3769264240 ("" (skeep*) (("" (replace -1) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "vc") (("" (assert) (("" (typepred "v(pvs0)(arg2, val)") (("1" (propax) nil) ("2" (typepred "val") (("2" (lemma "subterm_append") (("2" (skeep) (("2" (inst -1 "get_body(pvs0)" "path") (("2" (beta) (("2" (inst -1 "(:2:)") (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rac") (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "cons(2,path)") (("1" (assert) nil))))))))))))))))))))))))))))) ("2" (grind) nil) ("3" (grind) nil)))))))))))))))))))))))) nil) ((Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (terminating? const-decl "bool" pvs0_lang nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (< const-decl "bool" reals nil) (MT type-eq-decl nil pvs0_prelude nil) (lex2 const-decl "ordinal" lex2 nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (subterm_append formula-decl nil pvs0_props nil) nil nil (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (rdc const-decl "list[T]" more_list_props structures) (rac const-decl "T" more_list_props structures) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr subtype "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg2, pvs0_eval.val)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}")) (pvs0_eval_expr_TCC23-2 nil 3684364240 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil) ((well_founded? const-decl "bool" orders nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (Conditions type-eq-decl nil pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil)) nil (pvs0_eval_expr subtype "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg2, pvs0_eval.val)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}"))) (pvs0_eval_expr_TCC24 0 (pvs0_eval_expr_TCC24-2 "" 3790336411 ("" (skeep) (("" (typepred "val") (("" (skeep) (("" (lemma "subterm_append") (("" (inst -1 "get_body(pvs0)" "path") (("" (assert) (("" (inst -1 "(:0:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "cons(0,path)") (("1" (assert) (("1" (expand "path_conditions" 1) (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (subterm_append formula-decl nil pvs0_props nil) (rac const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_path formula-decl nil pvs0_props nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (rdc const-decl "list[T]" more_list_props structures) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (path skolem-const-decl "(valid_path(pvs0`4))" pvs0_eval nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)) shostak (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC24-1 nil 3769264240 ("" (skeep) (("" (typepred "val") (("" (skeep) (("" (lemma "subterm_append") (("" (inst -1 "get_body(pvs0)" "path") (("" (assert) (("" (inst -1 "(:0:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "cons(0,path)") (("1" (assert) (("1" (expand "path_conditions" 1) (("1" (expand "append") (("1" (propax) nil))))))))))))))))))))))))))))) ("2" (grind) (("2" (rewrite "null_path") nil))) ("3" (grind) nil)))))))))))))) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (subterm_append formula-decl nil pvs0_props nil) (rac const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_path formula-decl nil pvs0_props nil) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (rdc const-decl "list[T]" more_list_props structures) nil nil (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)) nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC24-4 nil 3743024942 ("" (skeep*) (("" (inst 1 "(::)") (("1" (grind) nil nil) ("2" (rewrite "null_path") nil nil)) nil)) nil) ((null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (null_path formula-decl nil pvs0_props nil)) nil (pvs0_eval_expr subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.arg, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}"))) (pvs0_eval_expr_TCC25 0 (pvs0_eval_expr_TCC25-2 "" 3790336412 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg, pvs0_eval.val)" "nil")) (pvs0_eval_expr_TCC25-1 nil 3769264240 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (grind) nil)))) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg, pvs0_eval.val)" "nil")) (pvs0_eval_expr_TCC25-5 nil 3743025108 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (flatten) (("" (hide 2) (("" (typepred "wfm_tcc[Val, MT, LAMBDA (m, n: nat): m < n](pvs0)") (("" (expand "pvs0_tcc_termination_pred") (("" (inst -1 "val") (("" (typepred "val") (("" (skeep) (("" (label "wfm" -3) (("" (inst "wfm" "(# `rec_expr:=expr, `cnds:=path_conditions(get_body(pvs0),path), `path:=path #)") (("1" (typepred "v1(pvs0)(arg, val)") (("1" (inst -4 "v") (("1" (assert) (("1" (hide 2) (("1" (replace -4 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -3) (("2" (typepred "val") (("2" (skeep) (("2" (inst 1 "append((:0:),path)") (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "path") (("1" (assert) (("1" (inst -1 "(:0:)") (("1" (split) (("1" (replace -1 1) (("1" (grind) nil nil)) nil) ("2" (lemma "path_conditions_unmodified") (("2" (inst -1 "get_body(pvs0)" "path" "0") (("2" (assert) (("2" (expand "append") (("2" (expand "append") (("2" (replace -1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "valid_path") (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil) ("3" (expand "every") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "valid_paths_subexpr") (("2" (inst -1 "get_body(pvs0)" "path") (("2" (assert) (("2" (inst -1 "(:0:)") (("1" (hide 2 -2) (("1" (expand "valid_path") (("1" (grind) (("1" (rewrite "null_path") nil nil)) nil)) nil)) nil) ("2" (expand "every") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "every") (("3" (expand "every") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "pvs0_tcc_valid_cc") (("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((well_founded? const-decl "bool" orders nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (Conditions type-eq-decl nil pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (valid_paths_subexpr formula-decl nil pvs0_props nil) (subterm_append formula-decl nil pvs0_props nil) (rac const-decl "T" more_list_props structures) (null_path formula-decl nil pvs0_props nil) (rdc const-decl "list[T]" more_list_props structures) (path_conditions_unmodified formula-decl nil pvs0_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (pvs0_tcc_valid_cc const-decl "bool" pvs0_cc nil) (PVS0Expr_CC type-eq-decl nil pvs0_cc nil) (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.arg, pvs0_eval.val)" "nil"))) (pvs0_eval_expr_TCC26 0 (pvs0_eval_expr_TCC26-2 "" 3790336413 ("" (skeep*) (("" (inst 1 "(::)") (("1" (grind) nil nil) ("2" (rewrite "null_path") nil nil)) nil)) nil) ((null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (null_path formula-decl nil pvs0_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr subtype "pvs0_eval.v" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.pvs0`4, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC26-1 nil 3769264240 ("" (skeep*) (("" (inst 1 "(::)") (("1" (grind) nil) ("2" (rewrite "null_path") nil)))) nil) ((null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) nil (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (null_path formula-decl nil pvs0_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr subtype "pvs0_eval.v" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.pvs0`4, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_eval_expr_TCC26-4 nil 3743028368 ("" (skeep*) (("" (typepred "v") (("" (replace -2) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "v") (("" (assert) (("" (typepred "v1(pvs0)(get_body(pvs0), v)") (("1" (propax) nil nil) ("2" (inst 1 "(::)") (("1" (grind) nil nil) ("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (Conditions type-eq-decl nil pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (terminating? const-decl "bool" pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (null_path formula-decl nil pvs0_props nil) (MT type-eq-decl nil pvs0_prelude nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil)) nil (pvs0_eval_expr subtype "pvs0_eval.v" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.pvs0`4, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}"))) (pvs0_eval_expr_TCC27 0 (pvs0_eval_expr_TCC27-3 "" 3790336414 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (flatten) (("" (hide 2) (("" (typepred "wfm_tcc[Val, MT, LAMBDA (m, n: nat): m < n](pvs0)") (("" (expand "pvs0_tcc_termination_pred") (("" (inst -1 "val") (("" (typepred "val") (("" (skeep) (("" (label "wfm" -3) (("" (inst "wfm" "(# `rec_expr:=expr, `cnds:=path_conditions(get_body(pvs0),path), `path:=path #)") (("1" (typepred "v1(pvs0)(arg, val)") (("1" (inst -4 "v") (("1" (assert) (("1" (hide 2) (("1" (replace -4 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -3) (("2" (typepred "val") (("2" (skeep) (("2" (inst 1 "append((:0:),path)") (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "path") (("1" (assert) (("1" (inst -1 "(:0:)") (("1" (split) (("1" (replace -1 1) (("1" (grind) nil nil)) nil) ("2" (lemma "path_conditions_unmodified") (("2" (inst -1 "get_body(pvs0)" "path" "0") (("2" (assert) (("2" (expand "append") (("2" (expand "append") (("2" (replace -1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "valid_path") (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "valid_paths_subexpr") (("2" (inst -1 "get_body(pvs0)" "path") (("2" (assert) (("2" (inst -1 "(:0:)") (("2" (hide 2 -2) (("2" (expand "valid_path") (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "every") (("3" (expand "every") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "pvs0_tcc_valid_cc") (("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ordstruct type-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (valid_paths_subexpr formula-decl nil pvs0_props nil) (subterm_append formula-decl nil pvs0_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (rac const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (null_path formula-decl nil pvs0_props nil) (reverse def-decl "list[T]" list_props nil) (rdc const-decl "list[T]" more_list_props structures) (path_conditions_unmodified formula-decl nil pvs0_props nil) (append def-decl "list[T]" list_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (path skolem-const-decl "(valid_path(pvs0`4))" pvs0_eval nil) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (pvs0_tcc_valid_cc const-decl "bool" pvs0_cc nil) (PVS0Expr_CC type-eq-decl nil pvs0_cc nil) (Conditions type-eq-decl nil pvs0_cc nil) (expr skolem-const-decl "PVS0Expr[Val]" pvs0_eval nil) (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.pvs0`4, pvs0_eval.v)" "nil")) (pvs0_eval_expr_TCC27-1 nil 3769264240 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (flatten) (("" (hide 2) (("" (typepred "wfm_tcc[Val, MT, LAMBDA (m, n: nat): m < n](pvs0)") (("" (expand "pvs0_tcc_termination_pred") (("" (inst -1 "val") (("" (typepred "val") (("" (skeep) (("" (label "wfm" -3) (("" (inst "wfm" "(# `rec_expr:=expr, `cnds:=path_conditions(get_body(pvs0),path), `path:=path #)") (("1" (typepred "v1(pvs0)(arg, val)") (("1" (inst -4 "v") (("1" (assert) (("1" (hide 2) (("1" (replace -4 1) (("1" (assert) nil))))))))) ("2" (hide 2) (("2" (hide -3) (("2" (typepred "val") (("2" (skeep) (("2" (inst 1 "append((:0:),path)") (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "path") (("1" (assert) (("1" (inst -1 "(:0:)") (("1" (split) (("1" (replace -1 1) (("1" (grind) nil))) ("2" (lemma "path_conditions_unmodified") (("2" (inst -1 "get_body(pvs0)" "path" "0") (("2" (assert) (("2" (expand "append") (("2" (expand "append") (("2" (replace -1 1) (("2" (propax) nil))))))))))))))) ("2" (hide 2) (("2" (expand "valid_path") (("2" (grind) (("2" (rewrite "null_path") nil))))))) ("3" (expand "every") (("3" (propax) nil))))))))))) ("2" (lemma "valid_paths_subexpr") (("2" (inst -1 "get_body(pvs0)" "path") (("2" (assert) (("2" (inst -1 "(:0:)") (("1" (hide 2 -2) (("1" (expand "valid_path") (("1" (grind) (("1" (rewrite "null_path") nil))))))) ("2" (expand "every") (("2" (propax) nil))))))))))) ("3" (expand "every") (("3" (expand "every") (("3" (propax) nil))))))))))))))))) ("2" (hide 2) (("2" (expand "pvs0_tcc_valid_cc") (("2" (assert) nil))))) ("3" (assert) nil)))))))))))))))))))))) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lex2_lt formula-decl nil lex2 nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (= const-decl "[T, T -> boolean]" equalities nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ordstruct type-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (valid_paths_subexpr formula-decl nil pvs0_props nil) (subterm_append formula-decl nil pvs0_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (rac const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (null_path formula-decl nil pvs0_props nil) (reverse def-decl "list[T]" list_props nil) (rdc const-decl "list[T]" more_list_props structures) (path_conditions_unmodified formula-decl nil pvs0_props nil) (append def-decl "list[T]" list_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) nil nil (pvs0_tcc_valid_cc const-decl "bool" pvs0_cc nil) (PVS0Expr_CC type-eq-decl nil pvs0_cc nil) (Conditions type-eq-decl nil pvs0_cc nil) nil (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.pvs0`4, pvs0_eval.v)" "nil")) (pvs0_eval_expr_TCC27-2 nil 3743028503 ("" (skeep) (("" (typepred "val") (("" (skeep) (("" (lemma "subterm_append") (("" (inst -1 "get_body(pvs0)" "path") (("" (assert) (("" (inst -1 "(:0:)") (("1" (replace -4) (("1" (replace -2) (("1" (expand "subterm_at" -1 2) (("1" (expand "rdc") (("1" (expand "reverse" -1 2) (("1" (expand "reverse" -1 2) (("1" (expand "append") (("1" (expand "append") (("1" (expand "reverse") (("1" (expand "subterm_at" -1 2) (("1" (inst 1 "cons(0,path)") (("1" (assert) (("1" (expand "path_conditions" 1) (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (rewrite "null_path") nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (Conditions type-eq-decl nil pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (list type-decl nil list_adt nil) (subterm_append formula-decl nil pvs0_props nil) (rac const-decl "T" more_list_props structures) (null_path formula-decl nil pvs0_props nil) (rdc const-decl "list[T]" more_list_props structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)) nil (pvs0_eval_expr termination "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.pvs0`4, pvs0_eval.v)" "nil"))) (pvs0_eval_expr_TCC28 0 (pvs0_eval_expr_TCC28-3 "" 3790336415 ("" (skeep*) (("" (typepred "v") (("" (replace -2) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "v") (("" (assert) (("" (typepred "v1(pvs0)(get_body(pvs0), v)") (("1" (propax) nil nil) ("2" (inst 1 "(::)") (("1" (grind) nil nil) ("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (terminating? const-decl "bool" pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (NOT const-decl "[bool -> bool]" booleans nil) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (null_path formula-decl nil pvs0_props nil) (ordstruct type-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_eval_expr subtype "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.pvs0`4, pvs0_eval.v)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}")) (pvs0_eval_expr_TCC28-2 nil 3769264240 ("" (skeep*) (("" (typepred "v") (("" (replace -2) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "v") (("" (assert) (("" (typepred "v1(pvs0)(get_body(pvs0), v)") (("1" (propax) nil) ("2" (inst 1 "(::)") (("1" (grind) nil) ("2" (rewrite "null_path") nil)))))))))))))))) nil) ((path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (terminating? const-decl "bool" pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (NOT const-decl "[bool -> bool]" booleans nil) nil (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (null_path formula-decl nil pvs0_props nil) (ordstruct type-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (MT type-eq-decl nil pvs0_prelude nil) (< const-decl "bool" reals nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_expr subtype "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.pvs0`4, pvs0_eval.v)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}")) (pvs0_eval_expr_TCC28-1 nil 3710521107 ("" (skeep*) (("" (rewrite "lex2_lt") (("" (grind) nil nil)) nil)) nil) ((well_founded? const-decl "bool" orders nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (MT type-eq-decl nil pvs0_prelude nil) (pvs0_tcc_termination const-decl "bool" measure_termination_defs nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (wfm_tcc const-decl "(pvs0_tcc_termination_pred(pvs0))" measure_termination_defs nil) (terminating? const-decl "bool" pvs0_lang nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (Conditions type-eq-decl nil pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil)) nil (pvs0_eval_expr subtype "pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(pvs0_eval.pvs0`4, pvs0_eval.v)" "{v: pvs0_eval.Val | pvs0_expr[pvs0_eval.Val].semantic_rel_expr(pvs0_eval.pvs0)(pvs0_eval.expr, pvs0_eval.val, v)}"))) (pvs0_eval_TCC1 0 (pvs0_eval_TCC1-1 nil 3683472034 ("" (skeep) (("" (inst 1 "null") (("1" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (rewrite "null_path") nil nil)) nil)) nil) ((null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (null_path formula-decl nil pvs0_props nil)) nil (pvs0_eval subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.pvs0`4, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}"))) (pvs0_eval_correct 0 (pvs0_eval_correct-1 nil 3683501056 ("" (skeep* :preds? t) (("" (typepred "pvs0_eval(pvs0)(arg)") (("" (expand "semantic_rel") (("" (ground) (("" (use "deterministic_expr") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((pvs0_eval const-decl "{v: Val | semantic_rel_expr(pvs0)(pvs0`4, val, v)}" pvs0_eval nil) (terminating? const-decl "bool" pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (NOT const-decl "[bool -> bool]" booleans nil) (deterministic_expr formula-decl nil pvs0_expr nil) (semantic_rel const-decl "bool" pvs0_lang nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (terminates_expr_transitive_TCC1 0 (terminates_expr_transitive_TCC1-1 nil 3742979595 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (Path type-eq-decl nil pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0 type-eq-decl nil pvs0_expr nil)) nil (terminates_expr_transitive subtype "pvs0_eval.path_ext" "(pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.body))"))) (terminates_expr_transitive_TCC2 0 (terminates_expr_transitive_TCC2-1 nil 3742979595 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (Path type-eq-decl nil pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (PVS0 type-eq-decl nil pvs0_expr nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil)) nil (terminates_expr_transitive subtype "pvs0_eval.path" "(pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.body))"))) (terminates_expr_transitive 0 (terminates_expr_transitive-1 "" 3790336426 ("" (skeep) (("" (induct "expr") (("1" (grind) nil nil) ("2" (skeep* :preds? t) (("2" (hide -1 -3) (("2" (lemma "cnst_vr_path_ext") (("2" (inst?) (("2" (assert) (("2" (assert) (("2" (inst 1 "val") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep* :preds? t) (("3" (hide -1 -3) (("3" (lemma "cnst_vr_path_ext") (("3" (inst?) (("3" (assert) (("3" (assert) (("3" (inst 1 "val") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep* :preds? t) (("4" (case "path = path_ext") (("1" (replaces -1) (("1" (inst 1 "val") (("1" (assert) nil nil)) nil)) nil) ("2" (hide -1 -3) (("2" (inst -4 "pvs0" "cons(0,path)" "path_ext") (("1" (assert) (("1" (prop) (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "path") (("1" (assert) (("1" (inst -1 "(:0:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (hide-all-but (-1 -4 1)) (("1" (decompose-equality -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -4 1)) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr" -5) (("2" (skeep) (("2" (inst 1 "valarg") (("2" (assert) (("2" (lemma "op1_rec_path_ext") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -4 1)) (("2" (use "valid_0_path_ext") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep* :preds? t) (("5" (hide -1 -3) (("5" (use "op2_path_ext") (("5" (assert) (("5" (assert) (("5" (prop) (("1" (hide -6) (("1" (inst -5 "pvs0" "cons(0,path)" "path_ext") (("1" (assert) (("1" (hide -9) (("1" (prop) (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "path") (("1" (assert) (("1" (inst -1 "(:0:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (hide-all-but (-2 -5 1)) (("1" (decompose-equality -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -5 1)) (("2" (decompose-equality -2) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "semantic_rel_expr" -6) (("2" (skeep) (("2" (inst 1 "valarg1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -5 1)) (("2" (use "valid_0_path_ext") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -5) (("2" (inst -5 "pvs0" "cons(1,path)" "path_ext") (("1" (assert) (("1" (prop) (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "path") (("1" (assert) (("1" (inst -1 "(:1:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (hide-all-but (-2 -5 1)) (("1" (decompose-equality -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -5 1)) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "semantic_rel_expr" -6) (("2" (skeep) (("2" (inst 1 "valarg2") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "valid_1_path_ext") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (inst 1 "val") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep* :preds? t) (("6" (hide -1 -3) (("6" (case "path_ext = path") (("1" (replaces -1) (("1" (inst 1 "val") (("1" (assert) nil nil)) nil)) nil) ("2" (inst -3 "pvs0" "cons(0,path)" "path_ext") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-1 -3 1)) (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "path") (("1" (assert) (("1" (inst -1 "(:0:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (decompose-equality -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr" -4) (("2" (skeep) (("2" (inst 1 "valarg") (("2" (assert) (("2" (lemma "op1_rec_path_ext") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 1)) (("2" (decompose-equality -2) (("2" (lemma "valid_0_path_ext") (("2" (inst?) (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skeep* :preds? t) (("7" (use "ite_path_ext") (("7" (assert) (("7" (hide -2 -4) (("7" (assert) (("7" (prop) (("1" (hide -5 -6) (("1" (inst -4 "pvs0" "cons(0,path)" "path_ext") (("1" (assert) (("1" (hide -8 2) (("1" (prop) (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "path") (("1" (assert) (("1" (inst -1 "(:0:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (hide-all-but (-2 -4 1)) (("1" (decompose-equality -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -4 1)) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr" -5) (("2" (skeep) (("2" (inst 1 "valarg") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -4 1)) (("2" (use "valid_0_path_ext") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -4 -6) (("2" (lemma "suffix_conds_valid") (("2" (inst -1 "env" "pvs0" "cons(1,path)" "path_ext") (("1" (assert) (("1" (use "path_conditions_cons") (("1" (assert) (("1" (replaces -1) (("1" (expand "eval_conds" -1) (("1" (flatten) (("1" (expand "path_conds_aux") (("1" (skeep -1) (("1" (replace -7 :dir rl) (("1" (inst -6 "pvs0" "cons(1,path)" "path_ext") (("1" (assert) (("1" (decompose-equality -7) (("1" (split -9) (("1" (propax) nil nil) ("2" (hide-all-but (-2 -7 1)) (("2" (lemma "subterm_append") (("2" (inst -1 "get_body(pvs0)" "path") (("2" (assert) (("2" (inst -1 "(:1:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -5 -6 -8 -10 -11 3) (("3" (expand "semantic_rel_expr" -6) (("3" (skeep) (("3" (prop) (("1" (inst 2 "val") nil nil) ("2" (hide-all-but (-1 -6 -8 2)) (("2" (replaces -1) (("2" (lemma "deterministic_expr") (("2" (inst -1 "pvs0" "env" "ite1_var" "val!1" "valarg") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -6 1)) (("2" (use "valid_1_path_ext") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -5 1)) (("2" (use "valid_1_path_ext") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -4 -5) (("3" (lemma "suffix_conds_valid") (("3" (inst -1 "env" "pvs0" "cons(2,path)" "path_ext") (("1" (assert) (("1" (use "path_conditions_cons") (("1" (assert) (("1" (replaces -1) (("1" (expand "eval_conds" -1) (("1" (flatten) (("1" (expand "path_conds_aux") (("1" (skeep -1) (("1" (replace -8 :dir rl) (("1" (inst -7 "pvs0" "cons(2,path)" "path_ext") (("1" (assert) (("1" (decompose-equality -8) (("1" (split -10) (("1" (propax) nil nil) ("2" (hide-all-but (-3 -8 1)) (("2" (lemma "subterm_append") (("2" (inst -1 "get_body(pvs0)" "path") (("2" (assert) (("2" (inst -1 "(:2:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "semantic_rel_expr" -10) (("3" (skeep) (("3" (hide -6 -12 -13 2) (("3" (prop) (("1" (hide-all-but (-5 -6 -10 1)) (("1" (replaces -2) (("1" (lemma "deterministic_expr") (("1" (inst -1 "pvs0" "env" "ite1_var" "val!1" "valarg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "val") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -7 1)) (("2" (use "valid_2_path_ext") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -5 1)) (("2" (use "valid_2_path_ext") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (inst 1 "val") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (grind) nil nil)) nil) ("9" (hide 2) (("9" (grind) nil nil)) nil) ("10" (hide 2) (("10" (grind) nil nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (suffix? def-decl "bool" more_list_props structures) (eval_conds def-decl "bool" pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (PVS0Expr_induction formula-decl nil PVS0Expr_adt nil) (cnst_vr_path_ext formula-decl nil pvs0_props nil) (TRUE const-decl "bool" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (path skolem-const-decl "(valid_path(pvs0`4))" pvs0_eval nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (pvs0 skolem-const-decl "PVS0[Val]" pvs0_eval nil) (reverse def-decl "list[T]" list_props nil) (rdc const-decl "list[T]" more_list_props structures) (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (op2? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (get_op shared-adt-accessor-decl "[{x: PVS0Expr | op1?(x) OR op2?(x)} -> nat]" PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, PVS0Expr] -> (op1?)]" PVS0Expr_adt nil) (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt nil) (append def-decl "list[T]" list_props nil) (rac const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_path formula-decl nil pvs0_props nil) (subterm_append formula-decl nil pvs0_props nil) (op1_rec_path_ext formula-decl nil pvs0_props nil) (valid_0_path_ext formula-decl nil pvs0_props nil) (path skolem-const-decl "(valid_path(pvs0`4))" pvs0_eval nil) (pvs0 skolem-const-decl "PVS0[Val]" pvs0_eval nil) (get_arg2 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil) (get_arg1 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, PVS0Expr, PVS0Expr] -> (op2?)]" PVS0Expr_adt nil) (valid_1_path_ext formula-decl nil pvs0_props nil) (op2_path_ext formula-decl nil pvs0_props nil) (path skolem-const-decl "(valid_path(pvs0`4))" pvs0_eval nil) (pvs0 skolem-const-decl "PVS0[Val]" pvs0_eval nil) (rec adt-constructor-decl "[PVS0Expr -> (rec?)]" PVS0Expr_adt nil) (ite_path_ext formula-decl nil pvs0_props nil) (path skolem-const-decl "(valid_path(pvs0`4))" pvs0_eval nil) (pvs0 skolem-const-decl "PVS0[Val]" pvs0_eval nil) (get_else adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (get_if adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (ite adt-constructor-decl "[[PVS0Expr, PVS0Expr, PVS0Expr] -> (ite?)]" PVS0Expr_adt nil) (get_cond adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (ite? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (suffix_conds_valid formula-decl nil pvs0_props nil) (path_conds_aux const-decl "PVS0Bool" pvs0_props nil) (deterministic_expr formula-decl nil pvs0_expr nil) (path_conditions_cons formula-decl nil pvs0_props nil) (valid_2_path_ext formula-decl nil pvs0_props nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak) (terminates_expr_transitive-5 nil 3707581644 ("" (skeep) (("" (induct "expr") (("1" (grind) nil nil) ("2" (skeep* :preds? t) (("2" (hide -1 -3) (("2" (lemma "cnst_vr_path_ext") (("2" (inst?) (("2" (assert) (("2" (assert) (("2" (inst 1 "val") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep* :preds? t) (("3" (hide -1 -3) (("3" (lemma "cnst_vr_path_ext") (("3" (inst?) (("3" (assert) (("3" (assert) (("3" (inst 1 "val") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep* :preds? t) (("4" (case "path = path_ext") (("1" (replaces -1) (("1" (inst 1 "val") (("1" (assert) nil nil)) nil)) nil) ("2" (hide -1 -3) (("2" (inst -4 "pvs0" "cons(0,path)" "path_ext") (("1" (assert) (("1" (prop) (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "path") (("1" (assert) (("1" (inst -1 "(:0:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (hide-all-but (-1 -4 1)) (("1" (decompose-equality -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -4 1)) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr" -5) (("2" (skeep) (("2" (inst 1 "valarg") (("2" (assert) (("2" (lemma "op1_rec_path_ext") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -4 1)) (("2" (use "valid_0_path_ext") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep* :preds? t) (("5" (hide -1 -3) (("5" (use "op2_path_ext") (("5" (assert) (("5" (assert) (("5" (prop) (("1" (hide -6) (("1" (inst -5 "pvs0" "cons(0,path)" "path_ext") (("1" (assert) (("1" (hide -9) (("1" (prop) (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "path") (("1" (assert) (("1" (inst -1 "(:0:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (hide-all-but (-2 -5 1)) (("1" (decompose-equality -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -5 1)) (("2" (decompose-equality -2) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "semantic_rel_expr" -6) (("2" (skeep) (("2" (inst 1 "valarg1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -5 1)) (("2" (use "valid_0_path_ext") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -5) (("2" (inst -5 "pvs0" "cons(1,path)" "path_ext") (("1" (assert) (("1" (prop) (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "path") (("1" (assert) (("1" (inst -1 "(:1:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (hide-all-but (-2 -5 1)) (("1" (decompose-equality -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -5 1)) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "semantic_rel_expr" -6) (("2" (skeep) (("2" (inst 1 "valarg2") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "valid_1_path_ext") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (inst 1 "val") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep* :preds? t) (("6" (hide -1 -3) (("6" (case "path_ext = path") (("1" (replaces -1) (("1" (inst 1 "val") (("1" (assert) nil nil)) nil)) nil) ("2" (inst -3 "pvs0" "cons(0,path)" "path_ext") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-1 -3 1)) (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "path") (("1" (assert) (("1" (inst -1 "(:0:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (decompose-equality -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr" -4) (("2" (skeep) (("2" (inst 1 "valarg") (("2" (assert) (("2" (lemma "op1_rec_path_ext") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 1)) (("2" (decompose-equality -2) (("2" (lemma "valid_0_path_ext") (("2" (inst?) (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skeep* :preds? t) (("7" (use "ite_path_ext") (("7" (assert) (("7" (hide -2 -4) (("7" (assert) (("7" (prop) (("1" (hide -5 -6) (("1" (inst -4 "pvs0" "cons(0,path)" "path_ext") (("1" (assert) (("1" (hide -8 2) (("1" (prop) (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "path") (("1" (assert) (("1" (inst -1 "(:0:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (hide-all-but (-2 -4 1)) (("1" (decompose-equality -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -4 1)) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr" -5) (("2" (skeep) (("2" (inst 1 "valarg") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -4 1)) (("2" (use "valid_0_path_ext") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -4 -6) (("2" (lemma "suffix_conds_valid") (("2" (inst -1 "env" "pvs0" "cons(1,path)" "path_ext") (("1" (assert) (("1" (use "path_conditions_cons") (("1" (assert) (("1" (replaces -1) (("1" (expand "eval_conds" -1) (("1" (flatten) (("1" (expand "path_conds_aux") (("1" (skeep -1) (("1" (replace -7 :dir rl) (("1" (inst -6 "pvs0" "cons(1,path)" "path_ext") (("1" (assert) (("1" (decompose-equality -7) (("1" (split -9) (("1" (propax) nil nil) ("2" (hide-all-but (-2 -7 1)) (("2" (lemma "subterm_append") (("2" (inst -1 "get_body(pvs0)" "path") (("2" (assert) (("2" (inst -1 "(:1:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -5 -6 -8 -10 -11 3) (("3" (expand "semantic_rel_expr" -6) (("3" (skeep) (("3" (prop) (("1" (inst 2 "val") nil nil) ("2" (hide-all-but (-1 -6 -8 2)) (("2" (replaces -1) (("2" (lemma "deterministic_expr") (("2" (inst -1 "pvs0" "env" "ite1_var" "val!1" "valarg") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -6 1)) (("2" (use "valid_1_path_ext") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -5 1)) (("2" (use "valid_1_path_ext") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -4 -5) (("3" (lemma "suffix_conds_valid") (("3" (inst -1 "env" "pvs0" "cons(2,path)" "path_ext") (("1" (assert) (("1" (use "path_conditions_cons") (("1" (assert) (("1" (replaces -1) (("1" (expand "eval_conds" -1) (("1" (flatten) (("1" (expand "path_conds_aux") (("1" (skeep -1) (("1" (replace -8 :dir rl) (("1" (inst -7 "pvs0" "cons(2,path)" "path_ext") (("1" (assert) (("1" (decompose-equality -8) (("1" (split -10) (("1" (propax) nil nil) ("2" (hide-all-but (-3 -8 1)) (("2" (lemma "subterm_append") (("2" (inst -1 "get_body(pvs0)" "path") (("2" (assert) (("2" (inst -1 "(:2:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "semantic_rel_expr" -10) (("3" (skeep) (("3" (hide -6 -12 -13 2) (("3" (prop) (("1" (hide-all-but (-5 -6 -10 1)) (("1" (replaces -2) (("1" (lemma "deterministic_expr") (("1" (inst -1 "pvs0" "env" "ite1_var" "val!1" "valarg") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "val") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -7 1)) (("2" (use "valid_2_path_ext") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -5 1)) (("2" (use "valid_2_path_ext") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (inst 1 "val") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (grind) nil nil)) nil) ("9" (hide 2) (("9" (grind) nil nil)) nil) ("10" (hide 2) (("10" (grind) nil nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (suffix? def-decl "bool" more_list_props structures) (eval_conds def-decl "bool" pvs0_cc nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (PVS0Expr_induction formula-decl nil PVS0Expr_adt nil) (cnst_vr_path_ext formula-decl nil pvs0_props nil) (TRUE const-decl "bool" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) nil (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) nil (reverse def-decl "list[T]" list_props nil) (rdc const-decl "list[T]" more_list_props structures) (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (op2? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (get_op shared-adt-accessor-decl "[{x: PVS0Expr | op1?(x) OR op2?(x)} -> nat]" PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, PVS0Expr] -> (op1?)]" PVS0Expr_adt nil) (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt nil) (append def-decl "list[T]" list_props nil) (rac const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_path formula-decl nil pvs0_props nil) (subterm_append formula-decl nil pvs0_props nil) (op1_rec_path_ext formula-decl nil pvs0_props nil) (valid_0_path_ext formula-decl nil pvs0_props nil) nil nil (get_arg2 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil) (get_arg1 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, PVS0Expr, PVS0Expr] -> (op2?)]" PVS0Expr_adt nil) (valid_1_path_ext formula-decl nil pvs0_props nil) (op2_path_ext formula-decl nil pvs0_props nil) nil nil (rec adt-constructor-decl "[PVS0Expr -> (rec?)]" PVS0Expr_adt nil) (ite_path_ext formula-decl nil pvs0_props nil) nil nil (get_else adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (get_if adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (ite adt-constructor-decl "[[PVS0Expr, PVS0Expr, PVS0Expr] -> (ite?)]" PVS0Expr_adt nil) (get_cond adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (ite? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (suffix_conds_valid formula-decl nil pvs0_props nil) (path_conds_aux const-decl "PVS0Bool" pvs0_props nil) (deterministic_expr formula-decl nil pvs0_expr nil) (path_conditions_cons formula-decl nil pvs0_props nil) (valid_2_path_ext formula-decl nil pvs0_props nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil)) (suffix_of_valid_conditions 0 (suffix_of_valid_conditions-4 nil 3708106733 ("" (skeep :preds? t) (("" (case "null?(cnds)") (("1" (hide -2 -3) (("1" (expand "valid_conditions?") (("1" (inst 1 "null") (("1" (grind) nil nil) ("2" (rewrite "null_path") nil nil)) nil)) nil)) nil) ("2" (expand "valid_conditions?") (("2" (skeep) (("2" (lemma "condition_is_subterm_append") (("2" (lemma "suffix_supl[PVS0Bool[Val]]") (("2" (inst -1 "cnds" "cnds_ext") (("2" (assert) (("2" (skeep -1) (("2" (inst -2 "expr" "path" "L" "cnds") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (valid_conditions? const-decl "bool" pvs0_eval nil) (null_path formula-decl nil pvs0_props nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (expr skolem-const-decl "PVS0Expr[Val]" pvs0_eval nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (null adt-constructor-decl "(null?)" list_adt nil) (suffix_supl formula-decl nil more_list_props structures) (condition_is_subterm_append formula-decl nil pvs0_props nil)) nil)) (pvs0_eval_conds_TCC1 0 (pvs0_eval_conds_TCC1-1 nil 3707210191 ("" (skeep) (("" (expand "eval_conds") (("" (assert) nil nil)) nil)) nil) ((eval_conds def-decl "bool" pvs0_cc nil)) nil (pvs0_eval_conds subtype "booleans.TRUE" "{b: booleans.bool | b = pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_eval.cnds, pvs0_eval.val)}"))) (pvs0_eval_conds_TCC2 0 (pvs0_eval_conds_TCC2-1 nil 3707210191 ("" (skeep* :preds? t) (("" (expand "valid_rev_conditions?") (("" (skeep* :preds? t) (("" (expand "valid_conditions?") (("" (skeep* :preds? t) (("" (hide -1 -3) (("" (decompose-equality -7) (("" (decompose-equality -10) (("" (lemma "path_of_path_conditions") (("" (inst -1 "get_body(pvs0)" "path!1" "reverse(cdr(cnds))" "cons(car(cnds),cnds_1)") (("" (assert) (("" (prop) (("1" (skeep) (("1" (inst 1 "path_") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -10 1)) (("2" (expand "reverse" -3) (("2" (rewrite "append_append_cons[PVS0Bool[Val]]" :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_rev_conditions? const-decl "bool" pvs0_eval nil) (valid_conditions? const-decl "bool" pvs0_eval nil) (pvs0bool adt-constructor-decl "[PVS0Expr[T] -> (pvs0bool?)]" PVS0Bool_adt nil) (get_expr shared-adt-accessor-decl "[PVS0Bool -> PVS0Expr[T]]" PVS0Bool_adt nil) (pvs0bool? adt-recognizer-decl "[PVS0Bool -> boolean]" PVS0Bool_adt nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (reverse def-decl "list[T]" list_props nil) (append_append_cons formula-decl nil more_list_props structures) (path_of_path_conditions formula-decl nil pvs0_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_conds subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.expr, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}"))) (pvs0_eval_conds_TCC3 0 (pvs0_eval_conds_TCC3-3 nil 3743029546 ("" (skeep* :preds? t) (("" (expand "valid_rev_conditions?") (("" (skeep* :preds? t) (("" (expand "valid_conditions?") (("" (skeep* :preds? t) (("" (hide -1 -3) (("" (decompose-equality -7) (("" (decompose-equality -10) (("" (lemma "path_of_path_conditions") (("" (inst -1 "get_body(pvs0)" "path!1" "reverse(cdr(cnds))" "cons(car(cnds),cnds_1)") (("" (assert) (("" (prop) (("1" (skeep) (("1" (inst 1 "path_") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -10 1)) (("2" (expand "reverse" -3) (("2" (rewrite "append_append_cons[PVS0Bool[Val]]" :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_rev_conditions? const-decl "bool" pvs0_eval nil) (valid_conditions? const-decl "bool" pvs0_eval nil) (pvs0not adt-constructor-decl "[PVS0Expr[T] -> (pvs0not?)]" PVS0Bool_adt nil) (get_expr shared-adt-accessor-decl "[PVS0Bool -> PVS0Expr[T]]" PVS0Bool_adt nil) (pvs0not? adt-recognizer-decl "[PVS0Bool -> boolean]" PVS0Bool_adt nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (reverse def-decl "list[T]" list_props nil) (append_append_cons formula-decl nil more_list_props structures) (path_of_path_conditions formula-decl nil pvs0_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_conds subtype "pvs0_eval.val" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = pvs0_eval.expr, pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}"))) (pvs0_eval_conds_TCC4 0 (pvs0_eval_conds_TCC4-1 "" 3804628963 ("" (skolem 1 ("pp" "val" "revcnds" "a" "cnds")) (("" (flatten) (("" (typepred "revcnds") (("" (expand "valid_rev_conditions?") (("" (skolem -1 "cnds_suff") (("" (flatten) (("" (decompose-equality -3) (("" (inst 1 "cons(car(revcnds), cnds_suff)") (("1" (expand "reverse" -4) (("1" (assert) (("1" (rewrite "append_append_cons[PVS0Bool[Val]]" :dir rl) (("1" (assert) (("1" (expand "eval_conds" 1) (("1" (split -6) (("1" (assert) (("1" (match -1 "pvs0_eval_expr(%%)(%%)" step (inst 1 "%1")) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (match - "pvs0_eval_expr(%%)(%%)" step (inst 2 "%1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "suffix_of_valid_conditions") (("2" (inst? :where 1) (("2" (assert) (("2" (inst -1 "append(reverse(revcnds), cnds_suff)") (("2" (hide 2) (("2" (hide-all-but (-1 1)) (("2" (expand "reverse" 1) (("2" (rewrite "append_append_cons[PVS0Bool[Val]]" :dir rl) (("2" (rewrite "suffix_supl[PVS0Bool[Val]]") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (pvs0_eval_conds subtype "pvs0_eval.cnds_" "(pvs0_eval.valid_rev_conditions?(pvs0_eval.pvs0, pvs0_eval.val))")) (pvs0_eval_conds_TCC4-2 nil 3743031256 ("" (skolem 1 ("pp" "val" "revcnds" "a" "cnds")) (("" (flatten) (("" (typepred "revcnds") (("" (expand "valid_rev_conditions?") (("" (skolem -1 "cnds_suff") (("" (flatten) (("" (decompose-equality -5) (("" (inst 1 "cons(car(revcnds), cnds_suff)") (("1" (expand "reverse" -4) (("1" (assert) (("1" (rewrite "append_append_cons[PVS0Bool[Val]]" :dir rl) (("1" (assert) (("1" (expand "eval_conds" 1) (("1" (split -6) (("1" (assert) (("1" (match -1 "pvs0_eval_expr(%%)(%%)" step (inst 1 "%1")) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (match - "pvs0_eval_expr(%%)(%%)" step (inst 2 "%1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "suffix_of_valid_conditions") (("2" (inst? :where 1) (("2" (assert) (("2" (inst -1 "append(reverse(revcnds), cnds_suff)") (("2" (hide 2) (("2" (hide-all-but (-1 1)) (("2" (expand "reverse" 1) (("2" (rewrite "append_append_cons[PVS0Bool[Val]]" :dir rl) (("2" (rewrite "suffix_supl[PVS0Bool[Val]]") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cnds_suff skolem-const-decl "(valid_conditions?(pp`4))" pvs0_eval nil) (revcnds skolem-const-decl "(valid_rev_conditions?(pp, val))" pvs0_eval nil) (val skolem-const-decl "Val" pvs0_eval nil) (pp skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (valid_conditions? const-decl "bool" pvs0_eval nil) (get_expr shared-adt-accessor-decl "[PVS0Bool -> PVS0Expr[T]]" PVS0Bool_adt nil) (pvs0_eval_expr def-decl "{v: Val | semantic_rel_expr(pvs0)(expr, val, v)}" pvs0_eval nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (eval_conds def-decl "bool" pvs0_cc nil) (append_append_cons formula-decl nil more_list_props structures) (reverse def-decl "list[T]" list_props nil) (append def-decl "list[T]" list_props nil) (suffix_supl formula-decl nil more_list_props structures) (suffix_of_valid_conditions formula-decl nil pvs0_eval nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (valid_rev_conditions? const-decl "bool" pvs0_eval nil)) nil (pvs0_eval_conds subtype "pvs0_eval.cnds_" "(pvs0_eval.valid_rev_conditions?(pvs0_eval.pvs0, pvs0_eval.val))"))) (pvs0_eval_conds_TCC5 0 (pvs0_eval_conds_TCC5-2 nil 3707502413 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (valid_rev_conditions? const-decl "bool" pvs0_eval nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (valid_conditions? const-decl "bool" pvs0_eval nil) (reverse def-decl "list[T]" list_props nil) (terminates_expr const-decl "bool" pvs0_expr nil) (/= const-decl "boolean" notequal nil)) nil (pvs0_eval_conds termination "pvs0_eval.pvs0_eval_conds(pvs0_eval.pvs0)(pvs0_eval.val, pvs0_eval.cnds_)" "nil"))) (pvs0_eval_conds_TCC6 0 (pvs0_eval_conds_TCC6-1 nil 3743074204 ("" (skeep* :preds? t) (("" (lift-if) (("" (prop) (("1" (iff) (("1" (prop) (("1" (typepred "v(pvs0)(val, cnds_)") (("1" (replaces -1) (("1" (expand "eval_conds" 2) (("1" (decompose-equality -5) (("1" (assert) (("1" (inst 2 "pvs0_eval_expr(pvs0)(get_expr(a), val)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "valid_rev_conditions?") (("2" (skeep :preds? t) (("2" (decompose-equality -7) (("2" (inst 1 "cons(car(cnds), cnds_1)") (("1" (expand "reverse" -8) (("1" (assert) (("1" (rewrite "append_append_cons[PVS0Bool[Val]]" :dir rl) (("1" (assert) (("1" (expand "eval_conds" 1) (("1" (assert) (("1" (inst 1 "pvs0_eval_expr(pvs0)(get_expr(a), val)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -8 1)) (("2" (lemma "suffix_of_valid_conditions") (("2" (inst -1 "get_body(pvs0)" "cons[PVS0Bool[Val]](car[PVS0Bool[Val]](cnds), cnds_1)" "append(reverse(cnds), cnds_1)") (("2" (assert) (("2" (hide -2 2) (("2" (expand "reverse") (("2" (rewrite "append_append_cons[PVS0Bool[Val]]" :dir rl) (("2" (rewrite "suffix_supl[PVS0Bool[Val]]") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_conds") (("2" (decompose-equality -6) (("2" (assert) (("2" (flatten) (("2" (skeep) (("2" (typepred "pvs0_eval_expr(pvs0)(get_expr(a), val)") (("2" (replaces -5) (("2" (use "deterministic_expr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "v(pvs0)(val, cnds_)") (("1" (replaces -1) (("1" (expand "eval_conds" -1) (("1" (assert) (("1" (decompose-equality -5) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "valid_rev_conditions?") (("2" (skeep :preds? t) (("2" (inst 1 "cons(car(cnds), cnds_1)") (("1" (expand "reverse" -5) (("1" (assert) (("1" (rewrite "append_append_cons[PVS0Bool[Val]]" :dir rl) (("1" (decompose-equality -7) (("1" (assert) (("1" (expand "eval_conds" 1) (("1" (expand "eval_conds" -4) (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -7 1)) (("2" (lemma "suffix_of_valid_conditions") (("2" (inst -1 "get_body(pvs0)" "cons[PVS0Bool[Val]](car[PVS0Bool[Val]](cnds), cnds_1)" "append(reverse(cnds), cnds_1)") (("2" (assert) (("2" (hide -1 2) (("2" (rewrite "suffix_supl[PVS0Bool[Val]]") (("2" (inst 1 "reverse(cdr(cnds))") (("2" (expand "reverse" 1 2) (("2" (rewrite "append_append_cons[PVS0Bool[Val]]" :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (iff) (("2" (prop) (("1" (typepred "v(pvs0)(val, cnds_)") (("1" (replaces -1) (("1" (expand "eval_conds" 1) (("1" (decompose-equality -5) (("1" (assert) (("1" (inst 1 "pvs0_eval_expr(pvs0)(get_expr(a), val)") (("1" (typepred "pvs0_eval_expr(pvs0)(get_expr(a), val)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "valid_rev_conditions?") (("2" (skeep :preds? t) (("2" (decompose-equality -7) (("2" (inst 1 "cons(car(cnds), cnds_1)") (("1" (expand "reverse" -8) (("1" (assert) (("1" (rewrite "append_append_cons[PVS0Bool[Val]]" :dir rl) (("1" (assert) (("1" (expand "eval_conds" 1) (("1" (inst 1 "pvs0_eval_expr(pvs0)(get_expr(a), val)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "suffix_of_valid_conditions") (("2" (inst -1 "get_body(pvs0)" "cons[PVS0Bool[Val]](car[PVS0Bool[Val]](cnds), cnds_1)" "append(reverse(cnds), cnds_1)") (("2" (assert) (("2" (hide-all-but (-1 -2 -3 -8 1)) (("2" (expand "reverse" 1) (("2" (rewrite "append_append_cons[PVS0Bool[Val]]" :dir rl) (("2" (rewrite "suffix_supl[PVS0Bool[Val]]") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_conds") (("2" (decompose-equality -4) (("2" (assert) (("2" (flatten) (("2" (skeep) (("2" (typepred " pvs0_eval_expr(pvs0)(get_expr(a), val)") (("2" (use "deterministic_expr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "v(pvs0)(val, cnds_)") (("1" (replaces -1) (("1" (expand "eval_conds" -1) (("1" (decompose-equality -4) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "valid_rev_conditions?") (("2" (skeep :preds? t) (("2" (inst 1 "cons(car(cnds), cnds_1)") (("1" (expand "reverse" -4) (("1" (decompose-equality -6) (("1" (assert) (("1" (rewrite "append_append_cons[PVS0Bool[Val]]" :dir rl) (("1" (assert) (("1" (expand "eval_conds" 1) (("1" (expand "eval_conds" -5) (("1" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -6 1)) (("2" (decompose-equality -2) (("2" (lemma "suffix_of_valid_conditions") (("2" (inst -1 "get_body(pvs0)" "cons[PVS0Bool[Val]](car[PVS0Bool[Val]](cnds), cnds_1)" "append(reverse(cnds), cnds_1)") (("2" (assert) (("2" (hide -4 2) (("2" (expand "reverse") (("2" (rewrite "append_append_cons[PVS0Bool[Val]]" :dir rl) (("2" (rewrite "suffix_supl[PVS0Bool[Val]]") (("2" (inst 1 "reverse(cdr(cnds))") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cnds_1 skolem-const-decl "(valid_conditions?(pvs0`4))" pvs0_eval nil) (cnds_1 skolem-const-decl "(valid_conditions?(pvs0`4))" pvs0_eval nil) (cnds_1 skolem-const-decl "(valid_conditions?(pvs0`4))" pvs0_eval nil) (deterministic_expr formula-decl nil pvs0_expr nil) (eval_conds def-decl "bool" pvs0_cc nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (valid_rev_conditions? const-decl "bool" pvs0_eval nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (get_expr shared-adt-accessor-decl "[PVS0Bool -> PVS0Expr[T]]" PVS0Bool_adt nil) (pvs0_eval_expr def-decl "{v: Val | semantic_rel_expr(pvs0)(expr, val, v)}" pvs0_eval nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (valid_conditions? const-decl "bool" pvs0_eval nil) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (val skolem-const-decl "Val" pvs0_eval nil) (cnds skolem-const-decl "(valid_rev_conditions?(pvs0, val))" pvs0_eval nil) (cnds_1 skolem-const-decl "(valid_conditions?(pvs0`4))" pvs0_eval nil) (append_append_cons formula-decl nil more_list_props structures) (reverse def-decl "list[T]" list_props nil) (suffix_of_valid_conditions formula-decl nil pvs0_eval nil) (suffix_supl formula-decl nil more_list_props structures) (append def-decl "list[T]" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_conds subtype "booleans.AND(CASES pvs0_eval.a OF pvs0bool(expr): pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(expr, pvs0_eval.val) /= pvs0_eval.pvs0`3, pvs0not(expr): pvs0_eval.pvs0_eval_expr(pvs0_eval.pvs0)(expr, pvs0_eval.val) = pvs0_eval.pvs0`3 ENDCASES, pvs0_eval.pvs0_eval_conds(pvs0_eval.pvs0)(pvs0_eval.val, pvs0_eval.cnds_))" "{b: booleans.bool | b = pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_eval.cnds, pvs0_eval.val)}"))) (pvs0_eval_conds_corrrect_TCC1 0 (pvs0_eval_conds_corrrect_TCC1-1 nil 3707210483 ("" (skeep* :preds? t) (("" (expand "valid_rev_conditions?") (("" (expand "valid_conditions?") (("" (skeep) (("" (rewrite "reverse_reverse") (("" (inst 1 "(::)") (("1" (prop) (("1" (inst 1 "path") (("1" (rewrite "append_null[PVS0Bool[Val]]") nil nil)) nil) ("2" (expand "eval_conds") (("2" (propax) nil nil)) nil)) nil) ("2" (expand "valid_conditions?") (("2" (inst 1 "(::)") (("1" (expand "path_conditions") (("1" (propax) nil nil)) nil) ("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_rev_conditions? const-decl "bool" pvs0_eval nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (eval_conds def-decl "bool" pvs0_cc nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (Path type-eq-decl nil pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (append_null formula-decl nil list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (null_path formula-decl nil pvs0_props nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (reverse_reverse formula-decl nil list_props nil) (valid_conditions? const-decl "bool" pvs0_eval nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_eval_conds_corrrect subtype "list_props[PVS0Bool_adt[pvs0_eval.Val].PVS0Bool].reverse(pvs0_eval.cnds)" "(pvs0_eval.valid_rev_conditions?(pvs0_eval.pvs0, pvs0_eval.val))"))) (pvs0_eval_conds_corrrect 0 (pvs0_eval_conds_corrrect-1 nil 3707212657 ("" (skeep* :preds? t) (("" (typepred "pvs0_eval_conds(pvs0)(val, reverse(cnds))") (("" (replaces -1) (("" (rewrite "eval_conds_reverse") nil nil)) nil)) nil)) nil) ((valid_conditions? const-decl "bool" pvs0_eval nil) (reverse def-decl "list[T]" list_props nil) (pvs0_eval_conds def-decl "{b: bool | b = eval_conds(pvs0)(cnds, val)}" pvs0_eval nil) (eval_conds def-decl "bool" pvs0_cc nil) (valid_rev_conditions? const-decl "bool" pvs0_eval nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (eval_conds_reverse formula-decl nil pvs0_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (pvs0_tcc_TCC1 0 (pvs0_tcc_TCC1-1 nil 3707210483 ("" (skeep* :preds? t) (("" (expand "valid_rev_conditions?") (("" (rewrite "reverse_reverse") (("" (expand "pvs0_tcc_valid_cc") (("" (flatten) (("" (assert) (("" (inst 1 "(::)") (("1" (rewrite "append_null[PVS0Bool[Val]]") (("1" (prop) (("1" (expand "valid_conditions?") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "eval_conds") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "valid_conditions?") (("2" (inst 1 "(::)") (("1" (grind) nil nil) ("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_rev_conditions? const-decl "bool" pvs0_eval nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (null_path formula-decl nil pvs0_props nil) (append_null formula-decl nil list_props nil) (eval_conds def-decl "bool" pvs0_cc nil) (valid_path def-decl "bool" pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (valid_conditions? const-decl "bool" pvs0_eval nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (pvs0_tcc_valid_cc const-decl "bool" pvs0_cc nil) (PVS0Expr_CC type-eq-decl nil pvs0_cc nil) (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Path type-eq-decl nil pvs0_cc nil) (Conditions type-eq-decl nil pvs0_cc nil) (list type-decl nil list_adt nil) (reverse_reverse formula-decl nil list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_tcc subtype "list_props[PVS0Bool_adt[pvs0_eval.Val].PVS0Bool].reverse(pvs0_eval.cc`cnds)" "(pvs0_eval.valid_rev_conditions?(pvs0_eval.pvs0, pvs0_eval.env))"))) (pvs0_tcc_TCC2 0 (pvs0_tcc_TCC2-2 "" 3790336434 ("" (skeep* :preds? t) (("" (expand "pvs0_tcc_valid_cc") (("" (flatten) (("" (inst 1 "cons(0,cc`path)") (("1" (prop) (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "cc`path") (("1" (assert) (("1" (inst -1 "(:0:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (expand "subterm_at" 1 1) (("1" (case "rdc((:0:)) = (::)") (("1" (replaces -1) (("1" (expand "subterm_at" 1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (typepred "cc`rec_expr") (("2" (replace -2 1 rl) (("2" (hide -2) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pvs0_eval_conds(pvs0)(env, reverse(cc`cnds))") (("2" (replaces -1) (("2" (lemma "eval_conds_reverse") (("2" (lemma "path_conditions_unmodified") (("2" (inst -1 "get_body(pvs0)" "cc`path" 0) (("2" (assert) (("2" (assert) (("2" (replaces -1) (("2" (inst -1 "pvs0" "cc`cnds" "env") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (typepred "cc`rec_expr") (("2" (lemma "valid_0_path_ext") (("2" (inst -1 "get_body(pvs0)" "cc`path") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pvs0_tcc_valid_cc const-decl "bool" pvs0_cc nil) (cc skolem-const-decl "(pvs0_tcc_valid_cc[Val](pvs0`4))" pvs0_eval nil) (PVS0Expr_CC type-eq-decl nil pvs0_cc nil) (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (Conditions type-eq-decl nil pvs0_cc nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (pvs0 skolem-const-decl "(terminating?[Val])" pvs0_eval nil) (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (valid_rev_conditions? const-decl "bool" pvs0_eval nil) (eval_conds def-decl "bool" pvs0_cc nil) (pvs0_eval_conds def-decl "{b: bool | b = eval_conds(pvs0)(cnds, val)}" pvs0_eval nil) (eval_conds_reverse formula-decl nil pvs0_props nil) (path_conditions_unmodified formula-decl nil pvs0_props nil) (subterm_append formula-decl nil pvs0_props nil) (rac const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_path formula-decl nil pvs0_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt nil) (append def-decl "list[T]" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rdc const-decl "list[T]" more_list_props structures) (null adt-constructor-decl "(null?)" list_adt nil) (reverse def-decl "list[T]" list_props nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (valid_0_path_ext formula-decl nil pvs0_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (pvs0_tcc subtype "pvs0_eval.env" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = PVS0Expr_adt[pvs0_eval.Val].get_arg(pvs0_eval.cc`rec_expr), pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}")) (pvs0_tcc_TCC2-1 nil 3707210483 ("" (skeep* :preds? t) (("" (expand "pvs0_tcc_valid_cc") (("" (flatten) (("" (inst 1 "cons(0,cc`path)") (("1" (prop) (("1" (lemma "subterm_append") (("1" (inst -1 "get_body(pvs0)" "cc`path") (("1" (assert) (("1" (inst -1 "(:0:)") (("1" (expand "append") (("1" (expand "append") (("1" (replaces -1) (("1" (expand "subterm_at" 1 1) (("1" (case "rdc((:0:)) = (::)") (("1" (replaces -1) (("1" (expand "subterm_at" 1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (typepred "cc`rec_expr") (("2" (replace -2 1 rl) (("2" (hide -2) (("2" (grind) (("2" (rewrite "null_path") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pvs0_eval_conds(pvs0)(env, reverse(cc`cnds))") (("2" (replaces -1) (("2" (lemma "eval_conds_reverse") (("2" (lemma "path_conditions_unmodified") (("2" (inst -1 "get_body(pvs0)" "cc`path" 0) (("2" (assert) (("2" (assert) (("2" (replaces -1) (("2" (inst -1 "pvs0" "cc`cnds" "env") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (typepred "cc`rec_expr") (("2" (lemma "valid_0_path_ext") (("2" (inst -1 "get_body(pvs0)" "cc`path") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pvs0_tcc_valid_cc const-decl "bool" pvs0_cc nil) nil (PVS0Expr_CC type-eq-decl nil pvs0_cc nil) (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (Conditions type-eq-decl nil pvs0_cc nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) nil (terminating? const-decl "bool" pvs0_lang nil) (PVS0 type-eq-decl nil pvs0_expr nil) (valid_path def-decl "bool" pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (valid_rev_conditions? const-decl "bool" pvs0_eval nil) (eval_conds def-decl "bool" pvs0_cc nil) (pvs0_eval_conds def-decl "{b: bool | b = eval_conds(pvs0)(cnds, val)}" pvs0_eval nil) (eval_conds_reverse formula-decl nil pvs0_props nil) (path_conditions_unmodified formula-decl nil pvs0_props nil) (subterm_append formula-decl nil pvs0_props nil) (rac const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null_path formula-decl nil pvs0_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt nil) (append def-decl "list[T]" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rdc const-decl "list[T]" more_list_props structures) (null adt-constructor-decl "(null?)" list_adt nil) (reverse def-decl "list[T]" list_props nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (valid_0_path_ext formula-decl nil pvs0_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (pvs0_tcc subtype "pvs0_eval.env" "{val: pvs0_eval.Val | EXISTS (path: (pvs0_cc[pvs0_eval.Val].valid_path(pvs0_eval.pvs0`4))): booleans.AND(pvs0_cc[pvs0_eval.Val].subterm_at(pvs0_eval.pvs0`4, path) = PVS0Expr_adt[pvs0_eval.Val].get_arg(pvs0_eval.cc`rec_expr), pvs0_cc[pvs0_eval.Val].eval_conds(pvs0_eval.pvs0)(pvs0_cc[pvs0_eval.Val].path_conditions(pvs0_eval.pvs0`4, path), val))}"))) (pvs0_tccs_correct_TCC1 0 (pvs0_tccs_correct_TCC1-1 nil 3707210483 ("" (subtype-tcc) nil nil) nil nil (pvs0_tccs_correct subtype "LAMBDA (m, n: naturalnumbers.nat): reals.<(m, n)" "(orders[MT].well_founded?)"))) (pvs0_tccs_correct 0 (pvs0_tccs_correct-2 nil 3707469137 ("" (skeep) (("" (prop) (("1" (expand "pvs0_tccs") (("1" (rewrite "every_forall") (("1" (skolem 1 "n") (("1" (expand "pvs0_tcc") (("1" (skeep) (("1" (expand "pvs0_tcc_termination_pred") (("1" (insteep) (("1" (inst -1 "nth(pvs0_ccs(get_body(pvs0)), n)") (("1" (inst? -1) (("1" (assert) (("1" (hide 2) (("1" (lemma "pvs0_eval_conds_corrrect") (("1" (inst?) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "valid_conditions?") (("2" (name-replace "nn" "nth[(pvs0_tcc_valid_cc[Val](get_body(pvs0)))](pvs0_ccs[Val](get_body(pvs0)), n)") (("2" (typepred "nn") (("2" (expand "pvs0_tcc_valid_cc") (("2" (flatten) (("2" (inst? 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "pvs0_tcc_termination_pred") (("2" (skeep* :preds? t) (("2" (expand "pvs0_tccs") (("2" (rewrite "every_forall") (("2" (lemma "pvs0_ccs_completness") (("2" (inst? -1) (("2" (inst? -1) (("2" (lemma "member_nth[(pvs0_tcc_valid_cc(get_body(pvs0)))]") (("2" (inst?) (("2" (assert) (("2" (skeep -1) (("2" (inst -4 "i") (("2" (replaces -1) (("2" (expand "pvs0_tcc") (("2" (insteep -3) (("2" (rewrite "pvs0_eval_conds_corrrect" :dir rl) (("1" (typepred "pvs0_eval_expr(pvs0)(get_arg(cc`rec_expr), env)") (("1" (lemma "deterministic_expr") (("1" (inst? -1) (("1" (inst -1 "vact") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "valid_conditions?") (("2" (expand "pvs0_tcc_valid_cc") (("2" (flatten) (("2" (inst? 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((every_forall formula-decl nil more_list_props structures) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (pvs0_ccs const-decl "list[(pvs0_tcc_valid_cc(expr))]" pvs0_to_dg nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (MT type-eq-decl nil pvs0_prelude nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (WFM type-eq-decl nil measure_termination_defs nil) (pvs0_tcc const-decl "bool" pvs0_eval nil) (Val formal-nonempty-type-decl nil pvs0_eval nil) (Conditions type-eq-decl nil pvs0_cc nil) (Path type-eq-decl nil pvs0_cc nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (boolean nonempty-type-decl nil booleans nil) (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (PVS0Expr_CC type-eq-decl nil pvs0_cc nil) (bool nonempty-type-eq-decl nil booleans nil) (pvs0_tcc_valid_cc const-decl "bool" pvs0_cc nil) (list type-decl nil list_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (terminating? const-decl "bool" pvs0_lang nil) (pvs0_tcc_termination_pred const-decl "bool" measure_termination_defs nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pvs0_eval_conds_corrrect formula-decl nil pvs0_eval nil) (NOT const-decl "[bool -> bool]" booleans nil) (n skolem-const-decl "below(length(pvs0_ccs(pvs0`4)))" pvs0_eval nil) (pvs0 skolem-const-decl "(terminating?)" pvs0_eval nil) (valid_conditions? const-decl "bool" pvs0_eval nil) (get_arg shared-adt-accessor-decl "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt nil) (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (pvs0_eval_expr def-decl "{v: Val | semantic_rel_expr(pvs0)(expr, val, v)}" pvs0_eval nil) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (path_conditions def-decl "Conditions" pvs0_cc nil) (eval_conds def-decl "bool" pvs0_cc nil) (PVS0Bool type-decl nil PVS0Bool_adt nil) (subterm_at def-decl "({res: PVS0Expr | subterm(res, expr)})" pvs0_cc nil) (subterm adt-def-decl "boolean" PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (valid_path def-decl "bool" pvs0_cc nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pvs0_tccs const-decl "bool" pvs0_eval nil) (TRUE const-decl "bool" booleans nil) (member_nth formula-decl nil more_list_props structures) (deterministic_expr formula-decl nil pvs0_expr nil) (pvs0_ccs_completness formula-decl nil pvs0_to_dg nil)) nil)))
