(mf_pvs0_computable (nat2PVS0_limit_TCC1 0 (nat2PVS0_limit_TCC1-1 nil 3755520043 ("" (grind) (("" (inst 1 "0") nil nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil)) nil (nat2PVS0_limit existence "" "number_field"))) (nat2PVS0_limit_TCC2 0 (nat2PVS0_limit_TCC2-1 nil 3755520043 ("" (subtype-tcc) (("" (grind) nil nil)) nil) ((subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (nat2PVS0_limit subtype "mf_PVS0Expr_adt[nat].vr" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))"))) (nat2PVS0_limit_TCC3 0 (nat2PVS0_limit_TCC3-1 nil 3755520043 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (divides const-decl "bool" divides nil) (int_minus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)) nil (nat2PVS0_limit subtype "number_fields./(((number_fields.-)(mf_pvs0_computable.n, 1)), 5)" "nat"))) (nat2PVS0_limit_TCC4 0 (nat2PVS0_limit_TCC4-1 nil 3755520043 ("" (subtype-tcc) (("" (grind) nil nil)) nil) ((subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (divides const-decl "bool" divides nil)) nil (nat2PVS0_limit subtype "mf_PVS0Expr_adt[nat].cnst(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 1)), 5))" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))"))) (nat2PVS0_limit_TCC5 0 (nat2PVS0_limit_TCC5-1 nil 3755520043 ("" (grind) (("" (typepred "floor((5 * x!1 / 5) / (1 + limit!1))") (("" (case "5 * x!1 / 5 = x!1") (("1" (replaces -1) (("1" (case "n!1 = 1") (("1" (grind) nil nil) ("2" (lemma " both_sides_div_pos_lt1") (("2" (inst -1 "1+limit!1" "0" "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_times_int_is_int application-judgement "int" integers nil) (divides const-decl "bool" divides nil) (int_minus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)) nil (nat2PVS0_limit subtype "number_fields./(((number_fields.-)(mf_pvs0_computable.n, 2)), 5)" "int"))) (nat2PVS0_limit_TCC6 0 (nat2PVS0_limit_TCC6-2 nil 3799661538 ("" (grind) (("" (typepred "floor((5 * x!1 / 5) / (1 + limit!1))") (("" (case "5 * x!1 / 5 = x!1") (("1" (replaces -1) (("1" (case "n!1 = 1") (("1" (grind) nil nil) ("2" (lemma " both_sides_div_pos_lt1") (("2" (inst -1 "1+limit!1" "0" "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((* const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (<= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (divides const-decl "bool" divides nil)) nil (nat2PVS0_limit subtype "floor_ceil.floor(number_fields./((number_fields./(((number_fields.-)(mf_pvs0_computable.n, 2)), 5)), ((number_fields.+)(mf_pvs0_computable.limit, 1))))" "nat")) (nat2PVS0_limit_TCC6-1 nil 3755520043 ("" (termination-tcc) (("" (typepred "floor((5 * x!1 / 5) / (1 + limit!1))") (("" (replace -6 :dir rl) (("" (case "((n!1 - 2) / 5) / (1 + limit!1) < n!1") (("1" (assert) nil nil) ("2" (case "((n!1 - 2) / 5) / (1 + limit!1) <= ((n!1 - 2) / 5)") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "both_sides_div_pos_lt2") (("2" (inst -1 "1+limit!1" "1" "((n!1 - 2) / 5)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((* const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_div_pos_lt2 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (nat2PVS0_limit subtype "floor_ceil.floor(number_fields./((number_fields./(((number_fields.-)(mf_pvs0_computable.n, 2)), 5)), ((number_fields.+)(mf_pvs0_computable.limit, 1))))" "nat"))) (nat2PVS0_limit_TCC7 0 (nat2PVS0_limit_TCC7-2 nil 3799661576 ("" (termination-tcc) (("" (typepred "floor((5 * x!1 / 5) / (1 + limit!1))") (("" (replace -6 :dir rl) (("" (case "((n!1 - 2) / 5) / (1 + limit!1) < n!1") (("1" (assert) nil nil) ("2" (case "((n!1 - 2) / 5) / (1 + limit!1) <= ((n!1 - 2) / 5)") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "both_sides_div_pos_lt2") (("2" (inst -1 "1+limit!1" "1" "((n!1 - 2) / 5)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((* const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_div_pos_lt2 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (divides const-decl "bool" divides nil)) nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(floor_ceil.floor(number_fields./((number_fields./(((number_fields.-)(mf_pvs0_computable.n, 2)), 5)), ((number_fields.+)(mf_pvs0_computable.limit, 1)))))" "nil")) (nat2PVS0_limit_TCC7-1 nil 3755520043 ("" (skeep) (("" (typepred "v(limit)(floor(((n - 2) / 5) / (limit + 1)))") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm" -4) (("1" (prop) (("1" (decompose-equality) (("1" (typepred "rem(1 + limit)((n - 2) / 5)") (("1" (assert) nil nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC5") nil nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (integer nonempty-type-from-decl nil integers nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat2PVS0_limit_TCC5 subtype-tcc nil mf_pvs0_computable nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (int_minus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(floor_ceil.floor(number_fields./((number_fields./(((number_fields.-)(mf_pvs0_computable.n, 2)), 5)), ((number_fields.+)(mf_pvs0_computable.limit, 1)))))" "nil"))) (nat2PVS0_limit_TCC8 0 (nat2PVS0_limit_TCC8-2 nil 3799661715 ("" (skeep) (("" (typepred "v(limit)(floor(((n - 2) / 5) / (limit + 1)))") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm" -4) (("1" (prop) (("1" (decompose-equality) (("1" (typepred "rem(1 + limit)((n - 2) / 5)") (("1" (assert) nil nil) ("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil) ("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC6") nil nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (integer nonempty-type-from-decl nil integers nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (< const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (divides const-decl "bool" divides nil) (nat2PVS0_limit_TCC6 subtype-tcc nil mf_pvs0_computable nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (nat2PVS0_limit subtype "mf_PVS0Expr_adt[nat].rec(modulo_arithmetic.rem((number_fields.+)(mf_pvs0_computable.limit, 1))(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 2)), 5)), mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(floor_ceil.floor(number_fields./((number_fields./(((number_fields.-)(mf_pvs0_computable.n, 2)), 5)), ((number_fields.+)(mf_pvs0_computable.limit, 1))))))" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))")) (nat2PVS0_limit_TCC8-1 nil 3755520043 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)) nil (nat2PVS0_limit subtype "mf_PVS0Expr_adt[nat].rec(modulo_arithmetic.rem((number_fields.+)(mf_pvs0_computable.limit, 1))(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 2)), 5)), mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(floor_ceil.floor(number_fields./((number_fields./(((number_fields.-)(mf_pvs0_computable.n, 2)), 5)), ((number_fields.+)(mf_pvs0_computable.limit, 1))))))" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))"))) (nat2PVS0_limit_TCC9 0 (nat2PVS0_limit_TCC9-1 nil 3755520043 ("" (grind) (("" (lemma "nat2tuple_first") (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_times_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (divides const-decl "bool" divides nil) (int_minus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)) nil (nat2PVS0_limit subtype "number_fields./(((number_fields.-)(mf_pvs0_computable.n, 3)), 5)" "nat"))) (nat2PVS0_limit_TCC10 0 (nat2PVS0_limit_TCC10-2 nil 3799661821 ("" (grind) (("" (lemma "nat2tuple_first") (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((nat2tuple_first formula-decl nil tuple2nat numbers) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_times_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (divides const-decl "bool" divides nil)) nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 3)), 5))`2)" "nil")) (nat2PVS0_limit_TCC10-1 nil 3755520043 ("" (skeep) (("" (typepred "v(limit)(nat2tuple((n - 3) / 5)`2)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm" -4) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC8") nil nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (valid_index const-decl "bool" mf_pvs0_computable nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat2PVS0_limit_TCC8 subtype-tcc nil mf_pvs0_computable nil)) nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 3)), 5))`2)" "nil"))) (nat2PVS0_limit_TCC11 0 (nat2PVS0_limit_TCC11-2 nil 3799661862 ("" (skeep) (("" (typepred "v(limit)(nat2tuple((n - 3) / 5)`2)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm" -4) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC9") nil nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (valid_index const-decl "bool" mf_pvs0_computable nil) (< const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat2PVS0_limit_TCC9 subtype-tcc nil mf_pvs0_computable nil)) nil (nat2PVS0_limit subtype "mf_PVS0Expr_adt[nat].op1(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 3)), 5))`1, mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 3)), 5))`2))" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))")) (nat2PVS0_limit_TCC11-1 nil 3755520043 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)) nil (nat2PVS0_limit subtype "mf_PVS0Expr_adt[nat].op1(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 3)), 5))`1, mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 3)), 5))`2))" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))"))) (nat2PVS0_limit_TCC12 0 (nat2PVS0_limit_TCC12-1 nil 3755520043 ("" (skeep) (("" (lemma "nat2tuple_first") (("" (inst-cp -1 "(n - 4) / 5") (("1" (inst -1 "nat2tuple((n - 4) / 5)`2") (("1" (grind) nil nil) ("2" (rewrite "nat2PVS0_limit_TCC11") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC11") nil nil)) nil)) nil)) nil) ((nat2tuple_first formula-decl nil tuple2nat numbers) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (divides const-decl "bool" divides nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_times_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (nat2PVS0_limit subtype "number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5)" "nat"))) (nat2PVS0_limit_TCC13 0 (nat2PVS0_limit_TCC13-3 nil 3799661942 ("" (skeep) (("" (lemma "nat2tuple_first") (("" (inst-cp -1 "(n - 4) / 5") (("1" (inst -1 "nat2tuple((n - 4) / 5)`2") (("1" (grind) nil nil) ("2" (rewrite "nat2PVS0_limit_TCC12") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC12") nil nil)) nil)) nil)) nil) ((nat2tuple_first formula-decl nil tuple2nat numbers) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (divides const-decl "bool" divides nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat2PVS0_limit_TCC12 subtype-tcc nil mf_pvs0_computable nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (n skolem-const-decl "nat" mf_pvs0_computable nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5))`2)`1)" "nil")) (nat2PVS0_limit_TCC13-2 nil 3755606912 ("" (skeep) (("" (lemma "nat2tuple_first") (("" (inst-cp -1 "(n - 4) / 5") (("1" (inst -1 "nat2tuple((n - 4) / 5)`2") (("1" (grind) nil nil) ("2" (rewrite "nat2PVS0_limit_TCC11") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC11") nil nil)) nil)) nil)) nil) ((nat2tuple_first formula-decl nil tuple2nat numbers) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat2PVS0_limit_TCC11 subtype-tcc nil mf_pvs0_computable nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5))`2)`1)" "nil")) (nat2PVS0_limit_TCC13-1 nil 3755520043 ("" (termination-tcc) nil nil) nil nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5))`2)`1)" "nil"))) (nat2PVS0_limit_TCC14 0 (nat2PVS0_limit_TCC14-2 nil 3799662003 ("" (skeep) (("" (lemma "nat2tuple_first") (("" (inst-cp -1 "(n - 4) / 5") (("1" (inst -1 "nat2tuple((n - 4) / 5)`2") (("1" (grind) nil nil) ("2" (rewrite "nat2PVS0_limit_TCC12") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC12") nil nil)) nil)) nil)) nil) ((nat2tuple_first formula-decl nil tuple2nat numbers) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (divides const-decl "bool" divides nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat2PVS0_limit_TCC12 subtype-tcc nil mf_pvs0_computable nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (n skolem-const-decl "nat" mf_pvs0_computable nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5))`2)`2)" "nil")) (nat2PVS0_limit_TCC14-1 nil 3755520043 ("" (skeep) (("" (expand "valid_index" 5) (("" (expand "valid_index_rec") (("" (skeep) (("" (expand "subterm") (("" (prop) (("1" (typepred "v(limit)(nat2tuple(nat2tuple((n - 4) / 5)`2)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC11") nil nil)) nil) ("2" (typepred "v(limit)(nat2tuple(nat2tuple((n - 4) / 5)`2)`2)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC11") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_index const-decl "bool" mf_pvs0_computable nil) (nat2PVS0_limit_TCC11 subtype-tcc nil mf_pvs0_computable nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5))`2)`2)" "nil"))) (nat2PVS0_limit_TCC15 0 (nat2PVS0_limit_TCC15-3 nil 3799662063 ("" (skeep) (("" (expand "valid_index" 5) (("" (expand "valid_index_rec") (("" (skeep) (("" (expand "subterm") (("" (prop) (("1" (typepred "v(limit)(nat2tuple(nat2tuple((n - 4) / 5)`2)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC12") nil nil)) nil) ("2" (typepred "v(limit)(nat2tuple(nat2tuple((n - 4) / 5)`2)`2)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC12") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_index const-decl "bool" mf_pvs0_computable nil) (nat2PVS0_limit_TCC12 subtype-tcc nil mf_pvs0_computable nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (nat2PVS0_limit subtype "mf_PVS0Expr_adt[nat].op2(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5))`1, mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5))`2)`1), mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5))`2)`2))" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))")) (nat2PVS0_limit_TCC15-2 nil 3799662035 ("" (skeep) (("" (expand "valid_index" 5) (("" (expand "valid_index_rec") (("" (skeep) (("" (expand "subterm") (("" (prop) (("1" (typepred "v(limit)(nat2tuple(nat2tuple((n - 4) / 5)`2)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (rewrite "nat2PVS0_limit_TCC11") nil))) ("2" (typepred "v(limit)(nat2tuple(nat2tuple((n - 4) / 5)`2)`2)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (rewrite "nat2PVS0_limit_TCC12") nil)))))))))))))) nil) nil nil (nat2PVS0_limit subtype "mf_PVS0Expr_adt[nat].op2(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5))`1, mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5))`2)`1), mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5))`2)`2))" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))")) (nat2PVS0_limit_TCC15-1 nil 3755520043 ("" (skeep) (("" (prop) (("1" (case "divides(5,n)") (("1" (expand "divides") (("1" (skeep) (("1" (replace -1) (("1" (case "(5 * x - 5) / 5 = x - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "rem_def2" :dir rl) (("2" (rewrite "rem_def2" :dir rl) (("2" (rewrite "rem_def2" :dir rl) (("2" (rewrite "rem_def2" :dir rl) (("2" (case "divides(5, n-0)") (("1" (assert) nil nil) ("2" (rewrite "rem_def2" :dir rl) (("2" (typepred "rem(5)(n)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "n >= 5") (("1" (grind) nil nil) ("2" (rewrite "rem_def2" :dir rl) (("2" (rewrite "rem_def2" :dir rl) (("2" (rewrite "rem_def2" :dir rl) (("2" (rewrite "rem_def2" :dir rl) (("2" (typepred "rem(5)(n)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rem_def2 formula-decl nil modulo_arithmetic nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (NOT const-decl "[bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nat2PVS0_limit subtype "mf_PVS0Expr_adt[nat].op2(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5))`1, mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5))`2)`1), mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 4)), 5))`2)`2))" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))"))) (nat2PVS0_limit_TCC16 0 (nat2PVS0_limit_TCC16-2 nil 3799662103 ("" (skeep) (("" (prop) (("1" (case "divides(5,n)") (("1" (expand "divides") (("1" (skeep) (("1" (replace -1) (("1" (case "(5 * x - 5) / 5 = x - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "rem_def2" :dir rl) (("2" (rewrite "rem_def2" :dir rl) (("2" (rewrite "rem_def2" :dir rl) (("2" (rewrite "rem_def2" :dir rl) (("2" (case "divides(5, n-0)") (("1" (assert) nil nil) ("2" (rewrite "rem_def2" :dir rl) (("2" (typepred "rem(5)(n)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "n >= 5") (("1" (grind) nil nil) ("2" (rewrite "rem_def2" :dir rl) (("2" (rewrite "rem_def2" :dir rl) (("2" (rewrite "rem_def2" :dir rl) (("2" (rewrite "rem_def2" :dir rl) (("2" (typepred "rem(5)(n)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rem_def2 formula-decl nil modulo_arithmetic nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (divides const-decl "bool" divides nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nat2PVS0_limit subtype "number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5)" "nat")) (nat2PVS0_limit_TCC16-1 nil 3755520043 ("" (skeep) (("" (lemma "nat2tuple_first") (("" (inst?) (("1" (assert) nil nil) ("2" (rewrite "nat2PVS0_limit_TCC15") nil nil)) nil)) nil)) nil) ((nat2tuple_first formula-decl nil tuple2nat numbers) (nat2PVS0_limit_TCC15 subtype-tcc nil mf_pvs0_computable nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nat2PVS0_limit subtype "number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5)" "nat"))) (nat2PVS0_limit_TCC17 0 (nat2PVS0_limit_TCC17-2 nil 3799662147 ("" (skeep) (("" (lemma "nat2tuple_first") (("" (inst?) (("1" (assert) nil nil) ("2" (rewrite "nat2PVS0_limit_TCC16") nil nil)) nil)) nil)) nil) ((nat2tuple_first formula-decl nil tuple2nat numbers) (nat2PVS0_limit_TCC16 subtype-tcc nil mf_pvs0_computable nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (n skolem-const-decl "nat" mf_pvs0_computable nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`1)" "nil")) (nat2PVS0_limit_TCC17-1 nil 3755520043 ("" (skeep) (("" (lemma "nat2tuple_first") (("" (inst-cp -1 "(n - 5) / 5") (("1" (inst -1 "nat2tuple((n - 5) / 5)`2") (("1" (grind) nil nil) ("2" (rewrite "nat2PVS0_limit_TCC15") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC15") nil nil)) nil)) nil)) nil) ((nat2tuple_first formula-decl nil tuple2nat numbers) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat2PVS0_limit_TCC15 subtype-tcc nil mf_pvs0_computable nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`1)" "nil"))) (nat2PVS0_limit_TCC18 0 (nat2PVS0_limit_TCC18-6 nil 3799662182 ("" (skeep) (("" (lemma "nat2tuple_first") (("" (inst-cp -1 "(n - 5) / 5") (("1" (inst -1 "nat2tuple((n - 5) / 5)`2") (("1" (grind) nil nil) ("2" (rewrite "nat2PVS0_limit_TCC16") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC16") nil nil)) nil)) nil)) nil) ((nat2tuple_first formula-decl nil tuple2nat numbers) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (divides const-decl "bool" divides nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat2PVS0_limit_TCC16 subtype-tcc nil mf_pvs0_computable nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (n skolem-const-decl "nat" mf_pvs0_computable nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`1)" "nil")) (nat2PVS0_limit_TCC18-5 nil 3799596466 ("" (skeep) (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (skeep) (("" (expand "subterm") (("" (prop) (("1" (typepred "v(limit)(nat2tuple((n - 5) / 5)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (rewrite "nat2PVS0_limit_TCC16") nil))) ("2" (typepred " v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (rewrite "nat2PVS0_limit_TCC16") nil))) ("3" (typepred "v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`2)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (rewrite "nat2PVS0_limit_TCC16") nil)))))))))))))) nil) nil nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`1)" "nil")) (nat2PVS0_limit_TCC18-4 nil 3799596433 ("" (skeep) (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (skeep) (("" (expand "subterm") (("" (prop) (("1" (typepred "v(limit)(nat2tuple((n - 5) / 5)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (rewrite "nat2PVS0_limit_TCC15") nil))) ("2" (typepred " v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (rewrite "nat2PVS0_limit_TCC15") nil))) ("3" (typepred "v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`2)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (rewrite "nat2PVS0_limit_TCC16") nil)))))))))))))) nil) nil nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`1)" "nil")) (nat2PVS0_limit_TCC18-3 nil 3799596377 ("" (skeep) (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (skeep) (("" (expand "subterm") (("" (prop) (("1" (typepred "v(limit)(nat2tuple((n - 5) / 5)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (rewrite "nat2PVS0_limit_TCC15") nil))) ("2" (typepred " v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (rewrite "nat2PVS0_limit_TCC15") nil))) ("3" (typepred "v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`2)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (rewrite "nat2PVS0_limit_TCC15") nil)))))))))))))) nil) nil nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`1)" "nil")) (nat2PVS0_limit_TCC18-2 nil 3755610191 ("" (skeep) (("" (lemma "nat2tuple_first") (("" (inst-cp -1 "(n - 5) / 5") (("1" (inst -1 "nat2tuple((n - 5) / 5)`2") (("1" (grind) nil nil) ("2" (rewrite "nat2PVS0_limit_TCC15") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC15") nil nil)) nil)) nil)) nil) ((nat2tuple_first formula-decl nil tuple2nat numbers) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat2PVS0_limit_TCC15 subtype-tcc nil mf_pvs0_computable nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`1)" "nil")) (nat2PVS0_limit_TCC18-1 nil 3755520043 ("" (termination-tcc) nil nil) nil nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`1)" "nil"))) (nat2PVS0_limit_TCC19 0 (nat2PVS0_limit_TCC19-5 nil 3799662519 ("" (skeep) (("" (lemma "nat2tuple_first") (("" (inst-cp -1 "(n - 5) / 5") (("1" (inst -1 "nat2tuple((n - 5) / 5)`2") (("1" (grind) nil nil) ("2" (rewrite "nat2PVS0_limit_TCC16") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC16") nil nil)) nil)) nil)) nil) ((nat2tuple_first formula-decl nil tuple2nat numbers) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (divides const-decl "bool" divides nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat2PVS0_limit_TCC16 subtype-tcc nil mf_pvs0_computable nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (n skolem-const-decl "nat" mf_pvs0_computable nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`2)" "nil")) (nat2PVS0_limit_TCC19-4 nil 3799662249 ("" (skeep) (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (skeep) (("" (expand "subterm") (("" (prop) (("1" (typepred "v(limit)(nat2tuple((n - 5) / 5)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (rewrite "nat2PVS0_limit_TCC17") nil))) ("2" (typepred " v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (rewrite "nat2PVS0_limit_TCC17") nil))) ("3" (typepred "v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`2)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (rewrite "nat2PVS0_limit_TCC17") nil)))))))))))))) nil) nil nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`2)" "nil")) (nat2PVS0_limit_TCC19-3 nil 3799596293 ("" (skeep*) (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (skeep*) (("" (expand "subterm") (("" (prop) (("1" (typepred "v(limit)(nat2tuple((n - 5) / 5)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (prop) (("1" (case "divides(5, n - 5)") (("1" (expand "divides" -1) (("1" (skeep) (("1" (assert) nil))))) ("2" (hide-all-but (1 3 4 5 6 7)) (("2" (expand "divides") (("2" (typepred "rem(5)(n)") (("2" (skeep) (("2" (case "rem(5)(n)=4") (("1" (inst 2 "q") (("1" (assert) nil))) ("2" (case "rem(5)(n)=3") (("1" (inst 4 "q") (("1" (assert) nil))) ("2" (case "rem(5)(n)=2") (("1" (inst 6 "q") (("1" (assert) nil))) ("2" (case "rem(5)(n)=1") (("1" (inst 8 "q") (("1" (assert) nil))) ("2" (case "rem(5)(n)=0") (("1" (case "q=0") (("1" (assert) nil) ("2" (inst 6 "q-1") (("2" (assert) nil))))) ("2" (assert) nil))))))))))))))))))))) ("2" (assert) (("2" (hide -1 7) (("2" (expand "divides") (("2" (case "n < 5") (("1" (case "n=4") (("1" (inst 2 "0") (("1" (assert) nil))) ("2" (case "n=3") (("1" (inst 4 "0") (("1" (assert) nil))) ("2" (case "n=2") (("1" (inst 6 "0") (("1" (assert) nil))) ("2" (inst 8 "0") (("2" (assert) nil))))))))) ("2" (assert) nil))))))))))))) ("2" (typepred " v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (prop) (("1" (case "divides(5,n-5)") (("1" (expand "divides" -1) (("1" (skeep) (("1" (assert) nil))))) ("2" (hide-all-but (1 3 4 5 6 7)) (("2" (expand "divides") (("2" (typepred "rem(5)(n)") (("2" (skeep) (("2" (case "q=0") (("1" (grind) nil) ("2" (case "rem(5)(n)=0 or rem(5)(n)=1 or rem(5)(n)=2 or rem(5)(n) =3 or rem(5)(n)=4") (("1" (inst 2 "q-1") (("1" (inst + "q") (("1" (inst + "q") (("1" (inst + "q") (("1" (inst + "q") (("1" (assert) nil))))))))))) ("2" (assert) (("2" (prop) (("2" (assert) nil))))))))))))))))))) ("2" (hide -1 7) (("2" (case "n<5") (("1" (expand "divides") (("1" (case "n=4") (("1" (inst 2 "0") (("1" (assert) nil))) ("2" (case "n=3") (("1" (inst 4 "0") (("1" (assert) nil))) ("2" (case "n=2") (("1" (inst 6 "0") (("1" (assert) nil))) ("2" (inst 8 "0") (("2" (assert) nil))))))))))) ("2" (assert) nil))))))))) ("3" (typepred "v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`2)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil))))))) ("2" (hide -1) (("2" (prop) (("1" (case "divides(5,n-5)") (("1" (expand "divides" -1) (("1" (skeep) (("1" (assert) nil))))) ("2" (hide-all-but (1 3 4 5 6 7)) (("2" (expand "divides") (("2" (typepred "rem(5)(n)") (("2" (skeep) (("2" (case "q=0") (("1" (grind) nil) ("2" (case "rem(5)(n)=0 or rem(5)(n)=1 or rem(5)(n)=2 or rem(5)(n) =3 or rem(5)(n)=4") (("1" (inst 2 "q-1") (("1" (inst + "q") (("1" (inst + "q") (("1" (inst + "q") (("1" (inst + "q") (("1" (assert) nil))))))))))) ("2" (prop) (("2" (assert) nil))))))))))))))))) ("2" (case "n < 5") (("1" (expand "divides") (("1" (case "n=4") (("1" (inst 2 "0") (("1" (assert) nil))) ("2" (case "n=3") (("1" (inst 4 "0") (("1" (assert) nil))) ("2" (case "n=2") (("1" (inst 6 "0") (("1" (assert) nil))) ("2" (inst 8 "0") (("2" (assert) nil))))))))))) ("2" (assert) nil)))))))))))))))))))) nil) nil nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`2)" "nil")) (nat2PVS0_limit_TCC19-2 nil 3799596134 ("" (skeep) (("" (lemma "nat2tuple_first") (("" (inst-cp -1 "(n - 5) / 5") (("1" (inst -1 "nat2tuple((n - 5) / 5)`2") (("1" (grind) nil) ("2" (rewrite "nat2PVS0_limit_TCC15") nil))) ("2" (rewrite "nat2PVS0_limit_TCC15") nil)))))) nil) nil nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`2)" "nil")) (nat2PVS0_limit_TCC19-1 nil 3755520043 ("" (skeep) (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (skeep) (("" (expand "subterm") (("" (prop) (("1" (typepred "v(limit)(nat2tuple((n - 5) / 5)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC15") nil nil)) nil) ("2" (typepred " v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC15") nil nil)) nil) ("3" (typepred "v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`2)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC15") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_index const-decl "bool" mf_pvs0_computable nil) (nat2PVS0_limit_TCC15 subtype-tcc nil mf_pvs0_computable nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (nat2PVS0_limit termination "mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`2)" "nil"))) (nat2PVS0_limit_TCC20 0 (nat2PVS0_limit_TCC20-2 "" 3804630499 ("" (skeep*) (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (skeep*) (("" (expand "subterm") (("" (prop) (("1" (typepred "v(limit)(nat2tuple((n - 5) / 5)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (prop) (("1" (case "divides(5, n - 5)") (("1" (expand "divides" -1) (("1" (skeep) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 3 4 5 6 7)) (("2" (expand "divides") (("2" (typepred "rem(5)(n)") (("2" (skeep) (("2" (case "rem(5)(n)=4") (("1" (inst 6 "q") (("1" (assert) nil nil)) nil) ("2" (case "rem(5)(n)=3") (("1" (inst 6 "q") (("1" (assert) nil nil)) nil) ("2" (case "rem(5)(n)=2") (("1" (inst 6 "q") (("1" (assert) nil nil)) nil) ("2" (case "rem(5)(n)=1") (("1" (inst 6 "q") (("1" (assert) nil nil)) nil) ("2" (case "rem(5)(n)=0") (("1" (case "q=0") (("1" (assert) nil nil) ("2" (inst 6 "q-1") (("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -1 7) (("2" (expand "divides") (("2" (case "n < 5") (("1" (case "n=4") (("1" (assert) (("1" (inst 6 "0") (("1" (assert) nil nil)) nil)) nil) ("2" (case "n=3") (("1" (inst 4 "0") (("1" (assert) (("1" (inst 6 "0") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "n=2") (("1" (inst 6 "0") (("1" (assert) nil nil)) nil) ("2" (inst 8 "0") (("2" (assert) (("2" (inst 6 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred " v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (prop) (("1" (case "divides(5,n-5)") (("1" (expand "divides" -1) (("1" (skeep) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 3 4 5 6 7)) (("2" (expand "divides") (("2" (typepred "rem(5)(n)") (("2" (skeep) (("2" (case "q=0") (("1" (grind) nil nil) ("2" (case "rem(5)(n)=0 or rem(5)(n)=1 or rem(5)(n)=2 or rem(5)(n) =3 or rem(5)(n)=4") (("1" (inst 2 "q-1") (("1" (inst + "q") (("1" (inst + "q") (("1" (inst + "q") (("1" (inst + "q") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 7) (("2" (case "n<5") (("1" (expand "divides") (("1" (case "n=4") (("1" (assert) (("1" (inst 6 "0") (("1" (assert) nil nil)) nil)) nil) ("2" (case "n=3") (("1" (inst 4 "0") (("1" (assert) (("1" (inst 6 "0") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "n=2") (("1" (inst 6 "0") (("1" (assert) nil nil)) nil) ("2" (inst 8 "0") (("2" (assert) (("2" (inst 6 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`2)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (prop) (("1" (case "divides(5,n-5)") (("1" (expand "divides" -1) (("1" (skeep) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 3 4 5 6 7)) (("2" (expand "divides") (("2" (typepred "rem(5)(n)") (("2" (skeep) (("2" (case "q=0") (("1" (grind) nil nil) ("2" (case "rem(5)(n)=0 or rem(5)(n)=1 or rem(5)(n)=2 or rem(5)(n) =3 or rem(5)(n)=4") (("1" (inst 2 "q-1") (("1" (inst + "q") (("1" (inst + "q") (("1" (inst + "q") (("1" (inst + "q") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "n < 5") (("1" (expand "divides") (("1" (case "n=4") (("1" (assert) (("1" (inst 6 "0") (("1" (assert) nil nil)) nil)) nil) ("2" (case "n=3") (("1" (inst 4 "0") (("1" (assert) (("1" (inst 6 "0") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "n=2") (("1" (inst 6 "0") (("1" (assert) nil nil)) nil) ("2" (inst 8 "0") (("2" (assert) (("2" (inst 6 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (nat2PVS0_limit subtype "mf_PVS0Expr_adt[nat].ite(mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`1), mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`1), mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`2))" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))")) (nat2PVS0_limit_TCC20-1 nil 3799430194 ("" (skeep*) (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (skeep*) (("" (expand "subterm") (("" (prop) (("1" (typepred "v(limit)(nat2tuple((n - 5) / 5)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (prop) (("1" (case "divides(5, n - 5)") (("1" (expand "divides" -1) (("1" (skeep) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 3 4 5 6 7)) (("2" (expand "divides") (("2" (typepred "rem(5)(n)") (("2" (skeep) (("2" (case "rem(5)(n)=4") (("1" (inst 2 "q") (("1" (assert) nil nil)) nil) ("2" (case "rem(5)(n)=3") (("1" (inst 4 "q") (("1" (assert) nil nil)) nil) ("2" (case "rem(5)(n)=2") (("1" (inst 6 "q") (("1" (assert) nil nil)) nil) ("2" (case "rem(5)(n)=1") (("1" (inst 8 "q") (("1" (assert) nil nil)) nil) ("2" (case "rem(5)(n)=0") (("1" (case "q=0") (("1" (assert) nil nil) ("2" (inst 6 "q-1") (("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -1 7) (("2" (expand "divides") (("2" (case "n < 5") (("1" (case "n=4") (("1" (inst 2 "0") (("1" (assert) nil nil)) nil) ("2" (case "n=3") (("1" (inst 4 "0") (("1" (assert) nil nil)) nil) ("2" (case "n=2") (("1" (inst 6 "0") (("1" (assert) nil nil)) nil) ("2" (inst 8 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred " v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`1)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (prop) (("1" (case "divides(5,n-5)") (("1" (expand "divides" -1) (("1" (skeep) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 3 4 5 6 7)) (("2" (expand "divides") (("2" (typepred "rem(5)(n)") (("2" (skeep) (("2" (case "q=0") (("1" (grind) nil nil) ("2" (case "rem(5)(n)=0 or rem(5)(n)=1 or rem(5)(n)=2 or rem(5)(n) =3 or rem(5)(n)=4") (("1" (inst 2 "q-1") (("1" (inst + "q") (("1" (inst + "q") (("1" (inst + "q") (("1" (inst + "q") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 7) (("2" (case "n<5") (("1" (expand "divides") (("1" (case "n=4") (("1" (inst 2 "0") (("1" (assert) nil nil)) nil) ("2" (case "n=3") (("1" (inst 4 "0") (("1" (assert) nil nil)) nil) ("2" (case "n=2") (("1" (inst 6 "0") (("1" (assert) nil nil)) nil) ("2" (inst 8 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "v(limit)(nat2tuple(nat2tuple((n - 5) / 5)`2)`2)") (("1" (expand "valid_index") (("1" (expand "valid_index_rec") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (prop) (("1" (case "divides(5,n-5)") (("1" (expand "divides" -1) (("1" (skeep) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 3 4 5 6 7)) (("2" (expand "divides") (("2" (typepred "rem(5)(n)") (("2" (skeep) (("2" (case "q=0") (("1" (grind) nil nil) ("2" (case "rem(5)(n)=0 or rem(5)(n)=1 or rem(5)(n)=2 or rem(5)(n) =3 or rem(5)(n)=4") (("1" (inst 2 "q-1") (("1" (inst + "q") (("1" (inst + "q") (("1" (inst + "q") (("1" (inst + "q") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "n < 5") (("1" (expand "divides") (("1" (case "n=4") (("1" (inst 2 "0") (("1" (assert) nil nil)) nil) ("2" (case "n=3") (("1" (inst 4 "0") (("1" (assert) nil nil)) nil) ("2" (case "n=2") (("1" (inst 6 "0") (("1" (assert) nil nil)) nil) ("2" (inst 8 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (< const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_even_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (divides const-decl "bool" divides nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (valid_index const-decl "bool" mf_pvs0_computable nil)) nil (nat2PVS0_limit subtype "mf_PVS0Expr_adt[nat].ite(mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`1), mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`1), mf_pvs0_computable.nat2PVS0_limit(mf_pvs0_computable.limit)(tuple2nat.nat2tuple(tuple2nat.nat2tuple(number_fields./(((number_fields.-)(mf_pvs0_computable.n, 5)), 5))`2)`2))" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))"))) (PVS02nat_limit_TCC1 0 (PVS02nat_limit_TCC1-1 nil 3755520173 ("" (skeep) (("" (typepred "expr") (("" (replace -3) (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (expand "subterm" -2) (("" (skeep) (("" (inst -2 "i" "expr!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_index const-decl "bool" mf_pvs0_computable nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil)) nil (PVS02nat_limit subtype "mf_pvs0_computable.arg1" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))"))) (PVS02nat_limit_TCC2 0 (PVS02nat_limit_TCC2-1 nil 3755520173 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[mf_PVS0Expr])" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil)) nil (PVS02nat_limit termination "mf_pvs0_computable.PVS02nat_limit(mf_pvs0_computable.limit)(mf_pvs0_computable.arg1)" "nil"))) (PVS02nat_limit_TCC3 0 (PVS02nat_limit_TCC3-1 nil 3755520173 ("" (skeep) (("" (typepred "expr") (("" (replace -3) (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (skeep) (("" (inst?) (("" (assert) (("" (expand "subterm") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_index const-decl "bool" mf_pvs0_computable nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil)) nil (PVS02nat_limit subtype "mf_pvs0_computable.arg1" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))"))) (PVS02nat_limit_TCC4 0 (PVS02nat_limit_TCC4-1 nil 3755520173 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[mf_PVS0Expr])" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil)) nil (PVS02nat_limit termination "mf_pvs0_computable.PVS02nat_limit(mf_pvs0_computable.limit)(mf_pvs0_computable.arg1)" "nil"))) (PVS02nat_limit_TCC5 0 (PVS02nat_limit_TCC5-1 nil 3755520173 ("" (skeep) (("" (typepred "expr") (("" (replaces -3) (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (skeep) (("" (inst?) (("" (expand "subterm" -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_index const-decl "bool" mf_pvs0_computable nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (TRUE const-decl "bool" booleans nil)) nil (PVS02nat_limit subtype "mf_pvs0_computable.arg1" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))"))) (PVS02nat_limit_TCC6 0 (PVS02nat_limit_TCC6-1 nil 3755520173 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[mf_PVS0Expr])" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil)) nil (PVS02nat_limit termination "mf_pvs0_computable.PVS02nat_limit(mf_pvs0_computable.limit)(mf_pvs0_computable.arg1)" "nil"))) (PVS02nat_limit_TCC7 0 (PVS02nat_limit_TCC7-1 nil 3755520173 ("" (skeep) (("" (typepred " expr") (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (skeep) (("" (inst?) (("" (replace -3) (("" (expand "subterm" -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_index const-decl "bool" mf_pvs0_computable nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (PVS02nat_limit subtype "mf_pvs0_computable.arg2" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))"))) (PVS02nat_limit_TCC8 0 (PVS02nat_limit_TCC8-1 nil 3755520173 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[mf_PVS0Expr])" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil)) nil (PVS02nat_limit termination "mf_pvs0_computable.PVS02nat_limit(mf_pvs0_computable.limit)(mf_pvs0_computable.arg2)" "nil"))) (PVS02nat_limit_TCC9 0 (PVS02nat_limit_TCC9-1 nil 3755520173 ("" (skeep) (("" (typepred "expr") (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (skeep) (("" (inst?) (("" (replace -3) (("" (expand "subterm" -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_index const-decl "bool" mf_pvs0_computable nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (PVS02nat_limit subtype "mf_pvs0_computable.arg1" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))"))) (PVS02nat_limit_TCC10 0 (PVS02nat_limit_TCC10-1 nil 3755520173 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[mf_PVS0Expr])" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil)) nil (PVS02nat_limit termination "mf_pvs0_computable.PVS02nat_limit(mf_pvs0_computable.limit)(mf_pvs0_computable.arg1)" "nil"))) (PVS02nat_limit_TCC11 0 (PVS02nat_limit_TCC11-2 nil 3755611298 ("" (skeep) (("" (typepred "expr") (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (skeep) (("" (inst?) (("" (replace -3) (("" (expand "subterm" -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_index const-decl "bool" mf_pvs0_computable nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (PVS02nat_limit subtype "mf_pvs0_computable.arg2" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))")) (PVS02nat_limit_TCC11-1 nil 3755520173 ("" (subtype-tcc) nil nil) nil nil (PVS02nat_limit subtype "mf_pvs0_computable.arg2" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))"))) (PVS02nat_limit_TCC12 0 (PVS02nat_limit_TCC12-1 nil 3755520173 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[mf_PVS0Expr])" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil)) nil (PVS02nat_limit termination "mf_pvs0_computable.PVS02nat_limit(mf_pvs0_computable.limit)(mf_pvs0_computable.arg2)" "nil"))) (PVS02nat_limit_TCC13 0 (PVS02nat_limit_TCC13-2 nil 3755611350 ("" (skeep) (("" (typepred "expr") (("" (expand "valid_index") (("" (expand "valid_index_rec") (("" (skeep) (("" (inst?) (("" (replace -3) (("" (expand "subterm" -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((valid_index const-decl "bool" mf_pvs0_computable nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (PVS02nat_limit subtype "mf_pvs0_computable.arg3" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))")) (PVS02nat_limit_TCC13-1 nil 3755520173 ("" (subtype-tcc) nil nil) nil nil (PVS02nat_limit subtype "mf_pvs0_computable.arg3" "(mf_pvs0_computable.valid_index(mf_pvs0_computable.limit))"))) (PVS02nat_limit_TCC14 0 (PVS02nat_limit_TCC14-1 nil 3755520173 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<< adt-def-decl "(strict_well_founded?[mf_PVS0Expr])" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil)) nil (PVS02nat_limit termination "mf_pvs0_computable.PVS02nat_limit(mf_pvs0_computable.limit)(mf_pvs0_computable.arg3)" "nil"))) (nat2PVS0_PVS02nat_limit 0 (nat2PVS0_PVS02nat_limit-1 nil 3756214959 ("" (skeep) (("" (induct "pvsexpr") (("1" (typepred "pvsexpr!1") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (expand "PVS02nat_limit") (("2" (expand "nat2PVS0_limit") (("2" (case "divides(5, 5 * cnst1_var) ") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (prop) (("3" (grind) nil nil)) nil) ("4" (skeep) (("4" (prop) (("1" (expand "PVS02nat_limit" 1) (("1" (expand "nat2PVS0_limit" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "divides") (("1" (propax) nil nil)) nil) ("2" (expand "divides") (("2" (propax) nil nil)) nil) ("3" (case-replace "5 *
                     tuple2nat(op11_var, PVS02nat_limit(limit)(op12_var))
                     / 5 = tuple2nat(op11_var, PVS02nat_limit(limit)(op12_var))") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("4" (expand "divides") (("4" (propax) nil nil)) nil) ("5" (expand "divides") (("5" (inst 3 "tuple2nat(op11_var, PVS02nat_limit(limit)(op12_var))") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "valid_index") (("2" (expand "valid_index_rec") (("2" (skeep) (("2" (inst?) (("2" (expand "subterm" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (split) (("1" (split) (("1" (expand "PVS02nat_limit" 1) (("1" (expand "nat2PVS0_limit" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "divides") (("1" (propax) nil nil)) nil) ("2" (expand "divides") (("2" (propax) nil nil)) nil) ("3" (expand "divides") (("3" (propax) nil nil)) nil) ("4" (case-replace "5
                                             *
                                             tuple2nat
                                             (op21_var,
                                              tuple2nat
                                              (PVS02nat_limit
                                               (limit)(op22_var),
                                               PVS02nat_limit
                                               (limit)(op23_var)))
                                             /
                                             5 = tuple2nat
                                             (op21_var,
                                              tuple2nat
                                              (PVS02nat_limit
                                               (limit)(op22_var),
                                               PVS02nat_limit
                                               (limit)(op23_var)))") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("5" (expand "divides") (("5" (inst 1 "tuple2nat(op21_var,
                   tuple2nat(PVS02nat_limit(limit)(op22_var),
                             PVS02nat_limit(limit)(op23_var)))") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "valid_index") (("2" (expand "valid_index_rec") (("2" (skeep) (("2" (inst?) (("2" (expand "subterm" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "valid_index") (("2" (expand "valid_index_rec") (("2" (skeep) (("2" (inst?) (("2" (expand "subterm" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep) (("6" (prop) (("1" (expand "PVS02nat_limit" 1) (("1" (expand "nat2PVS0_limit" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "divides") (("1" (propax) nil nil)) nil) ("2" (case-replace "(5 * PVS02nat_limit(limit)(rec2_var) +
                                  5 *
                                   (PVS02nat_limit(limit)(rec2_var)
                                    *
                                    limit)
                                  + 5 * rec1_var)
                                 / 5 = PVS02nat_limit(limit)(rec2_var) +
                                  
                                   (PVS02nat_limit(limit)(rec2_var)
                                    *
                                    limit)
                                  + rec1_var") (("1" (case-replace "rem(1 + limit)
             (PVS02nat_limit(limit)(rec2_var) +
               (PVS02nat_limit(limit)(rec2_var) * limit)
               + rec1_var) = rec1_var") (("1" (case-replace "floor((PVS02nat_limit(limit)(rec2_var) +
                                 (PVS02nat_limit(limit)(rec2_var) * limit)
                                 + rec1_var)
                                / (1 + limit))= PVS02nat_limit(limit)(rec2_var)") (("1" (assert) nil nil) ("2" (case-replace "(PVS02nat_limit(limit)(rec2_var) +
              (PVS02nat_limit(limit)(rec2_var) * limit)
              + rec1_var)
             / (1 + limit) = PVS02nat_limit(limit)(rec2_var) + rec1_var/(1+limit)") (("1" (lemma "floor_plus_int") (("1" (inst -1 "PVS02nat_limit(limit)(rec2_var)" "rec1_var / (1 + limit)") (("1" (replace -1) (("1" (assert) (("1" (use "floor_0") (("1" (prop) (("1" (assert) nil nil) ("2" (hide-all-but (-7 1)) (("2" (expand "valid_index") (("2" (expand "valid_index_rec") (("2" (inst -1 "rec1_var" "rec2_var") (("2" (prop) (("1" (lemma "both_sides_div_pos_lt1") (("1" (inst -1 "(1+limit)" "rec1_var" "1+limit") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "subterm") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (case-replace "PVS02nat_limit(limit)(rec2_var) +
        (PVS02nat_limit(limit)(rec2_var) * limit) = PVS02nat_limit(limit)(rec2_var) *(1+limit)") (("1" (name-replace "p" "PVS02nat_limit(limit)(rec2_var)") (("1" (name-replace "l" "(1 + limit)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (case-replace "PVS02nat_limit(limit)(rec2_var) +
           (PVS02nat_limit(limit)(rec2_var) * limit) = PVS02nat_limit(limit)(rec2_var) * (1+limit)") (("1" (name-replace "p" "PVS02nat_limit(limit)(rec2_var)") (("1" (name-replace "l" "1+limit") (("1" (typepred "rem(l)(p * l + rec1_var)") (("1" (skeep) (("1" (rewrite "rem_def2") (("1" (expand "divides") (("1" (inst 1 "p") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (expand "l") (("2" (expand "valid_index") (("2" (expand "valid_index_rec") (("2" (inst -1 "rec1_var" "rec2_var") (("2" (assert) (("2" (expand "subterm") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (expand "divides") (("3" (propax) nil nil)) nil) ("4" (expand "divides") (("4" (propax) nil nil)) nil) ("5" (expand "divides") (("5" (inst 4 "PVS02nat_limit(limit)(rec2_var) + (PVS02nat_limit(limit)(rec2_var) * limit) + rec1_var") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "valid_index") (("2" (expand "valid_index_rec") (("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (expand "subterm" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (skeep) (("7" (split) (("1" (split) (("1" (split) (("1" (expand "PVS02nat_limit" 1) (("1" (expand "nat2PVS0_limit" 1) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (expand "divides") (("2" (propax) nil nil)) nil) ("3" (expand "divides") (("3" (propax) nil nil)) nil) ("4" (expand "divides") (("4" (propax) nil nil)) nil) ("5" (expand "divides") (("5" (propax) nil nil)) nil) ("6" (case-replace "5
                                             *
                                             tuple2nat
                                             (PVS02nat_limit
                                              (limit)(ite1_var),
                                              tuple2nat
                                              (PVS02nat_limit
                                               (limit)(ite2_var),
                                               PVS02nat_limit
                                               (limit)(ite3_var)))
                                             /
                                             5 = tuple2nat
                                             (PVS02nat_limit
                                              (limit)(ite1_var),
                                              tuple2nat
                                              (PVS02nat_limit
                                               (limit)(ite2_var),
                                               PVS02nat_limit
                                               (limit)(ite3_var)))") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "valid_index") (("2" (expand "valid_index_rec") (("2" (skeep) (("2" (inst?) (("2" (expand "subterm" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "valid_index") (("2" (expand "valid_index_rec") (("2" (skeep) (("2" (inst?) (("2" (expand "subterm" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand "valid_index") (("2" (expand "valid_index_rec") (("2" (skeep) (("2" (inst?) (("2" (expand "subterm" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat2PVS0_limit def-decl "(valid_index(limit))" mf_pvs0_computable nil) (PVS02nat_limit def-decl "nat" mf_pvs0_computable nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (mf_PVS0Expr_induction formula-decl nil mf_PVS0Expr_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (divides const-decl "bool" divides nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (tuple2nat const-decl "nat" tuple2nat numbers) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (floor_0 formula-decl nil floor_ceil nil) (floor_plus_int formula-decl nil floor_ceil nil) (posint nonempty-type-eq-decl nil integers nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (integer nonempty-type-from-decl nil integers nil) (<= const-decl "bool" reals nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (l skolem-const-decl "posint" mf_pvs0_computable nil) (rem_def2 formula-decl nil modulo_arithmetic nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak)) (PVS02nat_nat2PVS0_limit 0 (PVS02nat_nat2PVS0_limit-1 nil 3756227594 ("" (skeep) (("" (measure-induct+ "n" "n") (("" (expand "nat2PVS0_limit" 1) (("" (lift-if) (("" (prop) (("1" (grind) nil nil) ("2" (expand "PVS02nat_limit" 1) (("2" (assert) nil nil)) nil) ("3" (expand "PVS02nat_limit" 1) (("3" (inst -2 "floor
                                           (((x!1 - 2) / 5) / (1 + limit))") (("1" (prop) (("1" (replace -1) (("1" (with-tccs (case-replace "2 + 5 * floor(((x!1 - 2) / 5) / (1 + limit)) +
                5 * rem(1 + limit)((x!1 - 2) / 5)
                + 5 * (floor(((x!1 - 2) / 5) / (1 + limit)) * limit) =
         2 +
                 5 * (floor(((x!1 - 2) / 5) / (1 + limit)) * (1+limit) + rem(1 + limit)((x!1 - 2) / 5))")) (("1" (lemma "rem_floor") (("1" (assert) (("1" (inst -1 "1+limit" "(x!1-2)/5") (("1" (replace -1 :dir rl) (("1" (assert) nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC5") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC7") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC6") nil nil)) nil)) nil) ("4" (expand "PVS02nat_limit" 1) (("4" (inst-cp -2 "nat2tuple
                                                    ((x!1 - 3) / 5)`2") (("1" (prop) (("1" (replace -1) (("1" (with-tccs (case-replace "(nat2tuple((x!1 - 3) / 5)`1, nat2tuple((x!1 - 3) / 5)`2) = nat2tuple((x!1 - 3) / 5)")) (("1" (rewrite "tuple2nat_nat2tuple") (("1" (assert) nil nil) ("2" (rewrite "nat2PVS0_limit_TCC9") nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (lemma "nat2tuple_first") (("2" (inst -1 "(x!1 - 3) / 5") (("1" (assert) nil nil) ("2" (rewrite "nat2PVS0_limit_TCC9") nil nil)) nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC9") nil nil)) nil)) nil) ("5" (expand "PVS02nat_limit" 1) (("5" (inst-cp -2 "nat2tuple
                                                (nat2tuple
                                                 ((x!1 - 4) / 5)`2)`2") (("1" (inst -2 "nat2tuple
                                                  (nat2tuple
                                                   ((x!1 - 4) / 5)`2)`1") (("1" (split) (("1" (split) (("1" (replace -1) (("1" (replace -2) (("1" (case "(nat2tuple(nat2tuple((x!1 - 4) / 5)`2)`1,
                                             nat2tuple(nat2tuple((x!1 - 4) / 5)`2)`2) =
                  nat2tuple(nat2tuple((x!1 - 4) / 5)`2)") (("1" (replaces -1) (("1" (rewrite "tuple2nat_nat2tuple") (("1" (case-replace "(nat2tuple((x!1 - 4) / 5)`1, nat2tuple((x!1 - 4) / 5)`2) = nat2tuple((x!1 - 4) / 5)") (("1" (rewrite "tuple2nat_nat2tuple") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (rewrite "nat2PVS0_limit_TCC12") nil nil)) nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC14") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC13") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC12") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC12") nil nil)) nil)) nil) ("6" (expand "PVS02nat_limit" 2) (("6" (inst-cp -1 "nat2tuple
                                                (nat2tuple
                                                 ((x!1 - 5) / 5)`2)`2") (("1" (inst-cp -1 "nat2tuple
                                                  (nat2tuple
                                                   ((x!1 - 5) / 5)`2)`1") (("1" (inst -1 "nat2tuple
                                                     ((x!1 - 5) / 5)`1") (("1" (split) (("1" (split) (("1" (split) (("1" (replace -1) (("1" (replace -2) (("1" (replace -3) (("1" (case-replace "(nat2tuple(nat2tuple((x!1 - 5) / 5)`2)`1,
                                            nat2tuple(nat2tuple((x!1 - 5) / 5)`2)`2) = nat2tuple(nat2tuple((x!1 - 5) / 5)`2)") (("1" (rewrite "tuple2nat_nat2tuple") (("1" (case-replace "(nat2tuple((x!1 - 5) / 5)`1, nat2tuple((x!1 - 5) / 5)`2) = nat2tuple((x!1 - 5) / 5)") (("1" (rewrite "tuple2nat_nat2tuple") (("1" (assert) nil nil) ("2" (rewrite "nat2PVS0_limit_TCC16") nil nil)) nil) ("2" (assert) nil nil) ("3" (rewrite "nat2PVS0_limit_TCC16") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC16") nil nil)) nil) ("2" (assert) nil nil) ("3" (rewrite "nat2PVS0_limit_TCC16") nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC19") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC18") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC17") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC16") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC16") nil nil)) nil) ("2" (rewrite "nat2PVS0_limit_TCC16") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (PVS02nat_limit def-decl "nat" mf_pvs0_computable nil) (nat2PVS0_limit def-decl "(valid_index(limit))" mf_pvs0_computable nil) (nat2PVS0_limit_TCC18 termination-tcc nil mf_pvs0_computable nil) (nat2PVS0_limit_TCC16 subtype-tcc nil mf_pvs0_computable nil) (nat2PVS0_limit_TCC19 termination-tcc nil mf_pvs0_computable nil) (nat2PVS0_limit_TCC17 termination-tcc nil mf_pvs0_computable nil) (nat2PVS0_limit_TCC13 termination-tcc nil mf_pvs0_computable nil) (nat2PVS0_limit_TCC12 subtype-tcc nil mf_pvs0_computable nil) (nat2PVS0_limit_TCC14 termination-tcc nil mf_pvs0_computable nil) (nat2PVS0_limit_TCC9 subtype-tcc nil mf_pvs0_computable nil) (tuple2nat_nat2tuple formula-decl nil tuple2nat numbers) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat2tuple_first formula-decl nil tuple2nat numbers) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nat2PVS0_limit_TCC6 subtype-tcc nil mf_pvs0_computable nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (mod nonempty-type-eq-decl nil euclidean_division nil) (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}" modulo_arithmetic nil) (nat2PVS0_limit_TCC5 subtype-tcc nil mf_pvs0_computable nil) (rem_floor formula-decl nil modulo_arithmetic nil) (nat2PVS0_limit_TCC7 termination-tcc nil mf_pvs0_computable nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (limit skolem-const-decl "nat" mf_pvs0_computable nil) (x!1 skolem-const-decl "nat" mf_pvs0_computable nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (integer nonempty-type-from-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) shostak)) (cons2nat_TCC1 0 (cons2nat_TCC1-1 nil 3799241897 ("" (subtype-tcc) nil nil) nil nil (cons2nat subtype "mf_pvs0_computable.l" "{l: list_adt[nat].list | (booleans.NOT)(list_adt[nat].null?(l))}"))) (cons2nat_TCC2 0 (cons2nat_TCC2-1 nil 3799241897 ("" (subtype-tcc) nil nil) nil nil (cons2nat subtype "mf_pvs0_computable.l" "{l: list_adt[nat].list | (booleans.NOT)(list_adt[nat].null?(l))}"))) (cons2nat_TCC3 0 (cons2nat_TCC3-2 nil 3799242810 ("" (skeep) (("" (typepred "l") (("" (case "null?(rdc(l))") (("1" (expand "rdc") (("1" (rewrite "null_reverse") (("1" (case "null?(l)") (("1" (assert) nil nil) ("2" (expand "length" 2) (("2" (rewrite "length_null_list" :dir rl) (("2" (rewrite "length_null_list" :dir rl) (("2" (lemma "length_reverse[nat]") (("2" (inst -1 "l") (("2" (expand "length" -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (length_null_list formula-decl nil more_list_props structures) (length_reverse formula-decl nil list_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (reverse def-decl "list[T]" list_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (null_reverse formula-decl nil more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rdc const-decl "list[T]" more_list_props structures)) nil (cons2nat subtype "more_list_props[nat].rdc(mf_pvs0_computable.l)" "(list_adt[nat].cons?)")) (cons2nat_TCC3-1 nil 3799241897 ("" (subtype-tcc) nil nil) nil nil (cons2nat subtype "more_list_props[nat].rdc(mf_pvs0_computable.l)" "(list_adt[nat].cons?)"))) (cons2nat_TCC4 0 (cons2nat_TCC4-2 nil 3799242929 ("" (skeep) (("" (typepred "l") (("" (case "null?(rdc(l))") (("1" (expand "rdc") (("1" (rewrite "null_reverse") (("1" (case "null?(l)") (("1" (assert) nil nil) ("2" (expand "length" 2) (("2" (rewrite "length_null_list" :dir rl) (("2" (rewrite "length_null_list" :dir rl) (("2" (lemma "length_reverse[nat]") (("2" (inst -1 "l") (("2" (expand "length" -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "rdc") (("2" (rewrite "length_reverse") (("2" (rewrite "null_reverse") (("2" (rewrite "length_reverse" :dir rl) (("2" (expand "length" 3 2) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (prop) (("2" (rewrite "null_reverse") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (length_null_list formula-decl nil more_list_props structures) (length_reverse formula-decl nil list_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (reverse def-decl "list[T]" list_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (null_reverse formula-decl nil more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rdc const-decl "list[T]" more_list_props structures)) nil (cons2nat termination "mf_pvs0_computable.cons2nat(more_list_props[nat].rdc(mf_pvs0_computable.l))" "nil")) (cons2nat_TCC4-1 nil 3799241897 ("" (termination-tcc) nil nil) nil nil (cons2nat termination "mf_pvs0_computable.cons2nat(more_list_props[nat].rdc(mf_pvs0_computable.l))" "nil"))) (listnat2nat_TCC1 0 (listnat2nat_TCC1-2 nil 3799243227 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (listnat2nat subtype "(number_fields.-)(list_props[nat].length(mf_pvs0_computable.l), 1)" "nat")) (listnat2nat_TCC1-1 nil 3799243092 ("" (subtype-tcc) nil nil) nil nil (listnat2nat subtype "(number_fields.-)(list_props[nat].length(mf_pvs0_computable.l), 1)" "nat"))) (listnat2nat_TCC2 0 (listnat2nat_TCC2-1 nil 3799243092 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (listnat2nat subtype "mf_pvs0_computable.l" "(list_adt[nat].cons?)"))) (nat2listnat_aux_TCC1 0 (nat2listnat_aux_TCC1-1 nil 3799243621 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nat2listnat_aux subtype "(number_fields.-)(mf_pvs0_computable.len, 1)" "nat"))) (nat2listnat_aux_TCC2 0 (nat2listnat_aux_TCC2-1 nil 3799243621 ("" (termination-tcc) nil nil) nil nil (nat2listnat_aux termination "mf_pvs0_computable.nat2listnat_aux((number_fields.-)(mf_pvs0_computable.len, 1), tuple2nat.nat2tuple(mf_pvs0_computable.n)`1)" "nil"))) (length_nat2listnat_aux 0 (length_nat2listnat_aux-1 nil 3799243668 ("" (measure-induct+ "len" "len") (("" (skeep) (("" (expand "nat2listnat_aux" 1) (("" (lift-if) (("" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (inst -1 "x!1-1") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (length_append formula-decl nil list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_singleton formula-decl nil more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (x!1 skolem-const-decl "nat" mf_pvs0_computable nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat2listnat_aux def-decl "list[nat]" mf_pvs0_computable nil) (length def-decl "nat" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil)) (nat2listnat_aux_cons2nat_TCC1 0 (nat2listnat_aux_cons2nat_TCC1-2 nil 3799244086 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (length def-decl "nat" list_props nil)) nil (nat2listnat_aux_cons2nat subtype "(number_fields.-)(list_props[nat].length(mf_pvs0_computable.l), 1)" "nat")) (nat2listnat_aux_cons2nat_TCC1-1 nil 3799243949 ("" (subtype-tcc) nil nil) nil nil (nat2listnat_aux_cons2nat subtype "(number_fields.-)(list_props[nat].length(mf_pvs0_computable.l), 1)" "nat"))) (nat2listnat_aux_cons2nat 0 (nat2listnat_aux_cons2nat-1 nil 3799244185 ("" (measure-induct+ "length(l)" "l") (("1" (expand "nat2listnat_aux" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "cons2nat" 1) (("1" (assert) (("1" (hide -2) (("1" (grind) (("1" (decompose-equality) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "cons2nat" 2) (("2" (assert) (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) (("2" (inst -1 "rdc(x!1)") (("2" (case "length(rdc(x!1))= length(x!1)-1") (("1" (replaces -1) (("1" (assert) (("1" (replaces -1) (("1" (rewrite "rdc_rac") nil nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "length_reverse[nat]") (("2" (inst -1 "x!1") (("2" (replaces -1 :dir rl) (("2" (expand "rdc") (("2" (rewrite "length_reverse") (("2" (expand "length" 1 2) (("2" (lift-if) (("2" (prop) (("1" (typepred "x!1") (("1" (case "null?[nat](x!1)") (("1" (assert) nil nil) ("2" (rewrite "null_reverse") nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "l!1") (("2" (grind) nil nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rac const-decl "T" more_list_props structures) (nth def-decl "T" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (list_cons_extensionality formula-decl nil list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rdc_rac formula-decl nil more_list_props structures) (TRUE const-decl "bool" booleans nil) (length_reverse formula-decl nil list_props nil) (reverse def-decl "list[T]" list_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (null_reverse formula-decl nil more_list_props structures) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rdc const-decl "list[T]" more_list_props structures) (cons2nat def-decl "nat" mf_pvs0_computable nil) (nat2listnat_aux def-decl "list[nat]" mf_pvs0_computable nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil)) (cons2nat_nat2listnat_aux_TCC1 0 (cons2nat_nat2listnat_aux_TCC1-2 nil 3799244481 ("" (skeep) (("" (case "null?[nat](nat2listnat_aux(len, n))") (("1" (rewrite "length_null_list" :dir rl) (("1" (hide 1) (("1" (expand "nat2listnat_aux") (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((nat2listnat_aux def-decl "list[nat]" mf_pvs0_computable nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (length_append formula-decl nil list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_singleton formula-decl nil more_list_props structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length_null_list formula-decl nil more_list_props structures)) nil (cons2nat_nat2listnat_aux subtype "mf_pvs0_computable.nat2listnat_aux(mf_pvs0_computable.len, mf_pvs0_computable.n)" "(list_adt[nat].cons?)")) (cons2nat_nat2listnat_aux_TCC1-1 nil 3799244355 ("" (subtype-tcc) nil nil) nil nil (cons2nat_nat2listnat_aux subtype "mf_pvs0_computable.nat2listnat_aux(mf_pvs0_computable.len, mf_pvs0_computable.n)" "(list_adt[nat].cons?)"))) (cons2nat_nat2listnat_aux 0 (cons2nat_nat2listnat_aux-1 nil 3799244590 ("" (measure-induct+ "len" "len") (("1" (skeep) (("1" (expand "nat2listnat_aux" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "cons2nat" 1) (("1" (expand "length" 1) (("1" (expand "length" 1) (("1" (hide -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "cons2nat" 2) (("2" (lift-if) (("2" (prop) (("1" (expand "nat2listnat_aux" -1) (("1" (lift-if) (("1" (prop) (("1" (rewrite "length_append") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (rewrite "rdc_append") (("2" (rewrite "rac_append") (("2" (case "rdc((: nat2tuple(n)`2 :)) = null") (("1" (case "rac((: nat2tuple(n)`2 :)) = nat2tuple(n)`2") (("1" (replaces -1) (("1" (replaces -1) (("1" (rewrite "append_null") (("1" (inst -1 "x!1-1") (("1" (inst -1 "nat2tuple(n)`1") (("1" (assert) (("1" (replace -1) (("1" (case "(nat2tuple(n)`1, nat2tuple(n)`2) = nat2tuple(n)") (("1" (replaces -1) (("1" (rewrite "tuple2nat_nat2tuple") nil nil)) nil) ("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "cons2nat_nat2listnat_aux_TCC1") (("2" (inst?) nil nil)) nil) ("3" (lemma "cons2nat_nat2listnat_aux_TCC1") (("3" (inst?) nil nil)) nil)) nil) ((cons2nat_nat2listnat_aux_TCC1 subtype-tcc nil mf_pvs0_computable nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (append def-decl "list[T]" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (length_append formula-decl nil list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_singleton formula-decl nil more_list_props structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (rdc_append formula-decl nil more_list_props structures) (rdc const-decl "list[T]" more_list_props structures) (null adt-constructor-decl "(null?)" list_adt nil) (TRUE const-decl "bool" booleans nil) (append_null formula-decl nil list_props nil) (tuple2nat_nat2tuple formula-decl nil tuple2nat numbers) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (x!1 skolem-const-decl "nat" mf_pvs0_computable nil) (reverse def-decl "list[T]" list_props nil) (rac_append formula-decl nil more_list_props structures) (nth def-decl "T" list_props nil) (rac const-decl "T" more_list_props structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (length def-decl "nat" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (cons2nat def-decl "nat" mf_pvs0_computable nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat2listnat_aux def-decl "list[nat]" mf_pvs0_computable nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil)) (listnat2nat_nat2listnat 0 (listnat2nat_nat2listnat-1 nil 3799244925 ("" (skeep) (("" (expand "listnat2nat") (("" (lift-if) (("" (prop) (("1" (expand "nat2listnat") (("1" (assert) (("1" (lemma "cons2nat_nat2listnat_aux_TCC1") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nat2listnat" 2) (("2" (lift-if) (("2" (prop) (("1" (expand "nat2listnat") (("1" (assert) nil nil)) nil) ("2" (rewrite "cons2nat_nat2listnat_aux") (("2" (rewrite "length_nat2listnat_aux") (("2" (assert) (("2" (case "(nat2tuple(n - 1)`1, nat2tuple(n - 1)`2) = nat2tuple(n - 1)") (("1" (replaces -1) (("1" (rewrite "tuple2nat_nat2tuple") (("1" (assert) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((listnat2nat const-decl "nat" mf_pvs0_computable nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cons2nat_nat2listnat_aux_TCC1 subtype-tcc nil mf_pvs0_computable nil) (nat2listnat const-decl "list[nat]" mf_pvs0_computable nil) (cons2nat_nat2listnat_aux formula-decl nil mf_pvs0_computable nil) (TRUE const-decl "bool" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (tuple2nat_nat2tuple formula-decl nil tuple2nat numbers) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length_nat2listnat_aux formula-decl nil mf_pvs0_computable nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil)) (nat2listnat_listnat2nat 0 (nat2listnat_listnat2nat-1 nil 3799245247 ("" (skeep) (("" (expand "listnat2nat") (("" (lift-if) (("" (prop) (("1" (expand "nat2listnat") (("1" (assert) nil nil)) nil) ("2" (expand "nat2listnat") (("2" (assert) (("2" (assert) (("2" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (rewrite "nat2listnat_aux_cons2nat") nil nil)) nil) ("2" (hide 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((listnat2nat const-decl "nat" mf_pvs0_computable nil) (nat2listnat const-decl "list[nat]" mf_pvs0_computable nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons2nat def-decl "nat" mf_pvs0_computable nil) (nat2listnat_aux_cons2nat formula-decl nil mf_pvs0_computable nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (listPVS0nat2nat_TCC1 0 (listPVS0nat2nat_TCC1-2 nil 3799245457 ("" (case "FORALL (l1 : list[mf_PVS0Expr[nat]] , l: (cons?[mf_PVS0Expr[nat]])
                                              | FORALL (i: below[length[mf_PVS0Expr[nat]](l1)]):
                                                  valid_index_rec[nat]
                                                      (nth[mf_PVS0Expr[nat]](l1, i),
                                                       length[mf_PVS0Expr[nat]](l))):
                                    every[mf_PVS0Expr[number]]
                                        (LAMBDA (x1: mf_PVS0Expr[number]):
                                           every[number]
                                               (LAMBDA (x: number):
                                                       number_field_pred(x) AND real_pred(x)
                                                   AND rational_pred(x) AND integer_pred(x) AND x >= 0)
                                               (x1)
                                            AND valid_index(length[mf_PVS0Expr[nat]](l) - 1)(x1))
                                        (l1)") (("1" (skeep) (("1" (inst?) (("1" (typepred "l") (("1" (expand "limited") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (measure-induct+ "length(l1)" "l1") (("1" (skeep) (("1" (expand "every" 1 1) (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (typepred "car(x!1)") (("1" (propax) nil nil)) nil) ("2" (typepred "l") (("2" (inst -3 "0") (("1" (expand "nth" -3) (("1" (expand "valid_index" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (inst -1 "cdr(x!1)") (("3" (inst -1 "l") (("1" (expand "length" -1 2) (("1" (assert) nil nil)) nil) ("2" (typepred "l") (("2" (skeep) (("2" (inst -3 "i+1") (("1" (expand "nth" -3) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (x!1 skolem-const-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_computable nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (l skolem-const-decl "{l: (cons?[mf_PVS0Expr[nat]]) |
   FORALL (i: below[length[mf_PVS0Expr[nat]](x!1)]):
     valid_index_rec[nat]
         (nth[mf_PVS0Expr[nat]](x!1, i), length[mf_PVS0Expr[nat]](l))}" mf_pvs0_computable nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (i skolem-const-decl "below[length[mf_PVS0Expr[nat]](cdr(x!1))]" mf_pvs0_computable nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (l skolem-const-decl "(limited)" mf_pvs0_computable nil) (limited const-decl "bool" mf_pvs0_computable nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (nth def-decl "T" list_props nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil (listPVS0nat2nat subtype "mf_pvs0_computable.l" "list[(valid_index(length[mf_PVS0Expr[nat]](l) - 1))]")) (listPVS0nat2nat_TCC1-1 nil 3799245341 ("" (subtype-tcc) nil nil) nil nil (listPVS0nat2nat subtype "mf_pvs0_computable.l" "list[(valid_index(length[mf_PVS0Expr[nat]](l) - 1))]"))) (listPVS0nat2nat_TCC2 0 (listPVS0nat2nat_TCC2-2 nil 3799245539 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (limited const-decl "bool" mf_pvs0_computable nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (length def-decl "nat" list_props nil)) nil (listPVS0nat2nat subtype "(number_fields.-)(list_props[mf_PVS0Expr[nat]].length(mf_pvs0_computable.l), 1)" "nat")) (listPVS0nat2nat_TCC2-1 nil 3799245341 ("" (subtype-tcc) nil nil) nil nil (listPVS0nat2nat subtype "(number_fields.-)(list_props[mf_PVS0Expr[nat]].length(mf_pvs0_computable.l), 1)" "nat"))) (listPVS0nat2nat_TCC3 0 (listPVS0nat2nat_TCC3-2 nil 3799245710 ("" (grind) nil nil) ((even_times_int_is_even application-judgement "even_int" integers nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (limited const-decl "bool" mf_pvs0_computable nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (length def-decl "nat" list_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (tuple2nat const-decl "nat" tuple2nat numbers) (listnat2nat const-decl "nat" mf_pvs0_computable nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil)) nil (listPVS0nat2nat subtype "(number_fields.-)(mf_pvs0_computable.listnat2nat(list_adt_map[(mf_pvs0_computable.valid_index((number_fields.-)(list_props[mf_PVS0Expr[nat]].length(mf_pvs0_computable.l), 1))), nat].map(mf_pvs0_computable.PVS02nat_limit((number_fields.-)(list_props[mf_PVS0Expr[nat]].length(mf_pvs0_computable.l), 1)))(mf_pvs0_computable.l)), 1)" "nat")) (listPVS0nat2nat_TCC3-1 nil 3799245341 ("" (subtype-tcc) nil nil) nil nil (listPVS0nat2nat subtype "(number_fields.-)(mf_pvs0_computable.listnat2nat(list_adt_map[(mf_pvs0_computable.valid_index((number_fields.-)(list_props[mf_PVS0Expr[nat]].length(mf_pvs0_computable.l), 1))), nat].map(mf_pvs0_computable.PVS02nat_limit((number_fields.-)(list_props[mf_PVS0Expr[nat]].length(mf_pvs0_computable.l), 1)))(mf_pvs0_computable.l)), 1)" "nat"))) (nat2listPVS0nat_TCC1 0 (nat2listPVS0nat_TCC1-2 nil 3799246078 ("" (skeep) (("" (expand "nat2listnat") (("" (expand "nat2listnat_aux") (("" (lift-if) (("" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat2listnat const-decl "list[nat]" mf_pvs0_computable nil) (length_append formula-decl nil list_props nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_singleton formula-decl nil more_list_props structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat2listnat_aux def-decl "list[nat]" mf_pvs0_computable nil)) nil (nat2listPVS0nat subtype "(number_fields.-)(list_props[nat].length(mf_pvs0_computable.nat2listnat((number_fields.+)(mf_pvs0_computable.n, 1))), 1)" "nat")) (nat2listPVS0nat_TCC1-1 nil 3799245897 ("" (subtype-tcc) nil nil) nil nil (nat2listPVS0nat subtype "(number_fields.-)(list_props[nat].length(mf_pvs0_computable.nat2listnat((number_fields.+)(mf_pvs0_computable.n, 1))), 1)" "nat"))) (nat2listPVS0nat_TCC2 0 (nat2listPVS0nat_TCC2-2 nil 3799246227 ("" (lemma "nat2listPVS0nat_TCC1") (("" (grind) nil nil)) nil) ((nat2listnat const-decl "list[nat]" mf_pvs0_computable nil) (nat2listPVS0nat_TCC1 subtype-tcc nil mf_pvs0_computable nil)) nil (nat2listPVS0nat subtype "(number_fields.-)(list_props[nat].length(mf_pvs0_computable.nat2listnat((number_fields.+)(1, mf_pvs0_computable.n))), 1)" "nat")) (nat2listPVS0nat_TCC2-1 nil 3799245897 ("" (subtype-tcc) nil nil) nil nil (nat2listPVS0nat subtype "(number_fields.-)(list_props[nat].length(mf_pvs0_computable.nat2listnat((number_fields.+)(1, mf_pvs0_computable.n))), 1)" "nat"))) (nat2listPVS0nat_TCC3 0 (nat2listPVS0nat_TCC3-2 nil 3799246297 ("" (skeep) (("" (prop) (("1" (case "null?[mf_PVS0Expr[nat]](map[nat, (valid_index(length(nat2listnat(n + 1)) - 1))]
                                                   (nat2PVS0_limit[false_val, lop1, lop2]
                                                        (length[nat](nat2listnat(n + 1)) - 1))
                                                   (nat2listnat(n + 1)))") (("1" (use "length_null_list[mf_PVS0Expr[nat]]") (("1" (assert) (("1" (use "subtype_length[mf_PVS0Expr[nat], (valid_index(length(nat2listnat(n + 1)) - 1))]") (("1" (rewrite "map_length") (("1" (hide -2 1) (("1" (expand "nat2listnat") (("1" (expand "nat2listnat_aux") (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) (("2" (case " length(map[nat, (valid_index(length[nat](nat2listnat(1 + n)) - 1))]
                 (nat2PVS0_limit[false_val, lop1, lop2]
                      (length(nat2listnat_aux(nat2tuple(n)`1 - 1,
                                              nat2tuple
                                              (nat2tuple(n)`2)`1))))
                 (append(nat2listnat_aux(nat2tuple(n)`1 - 1,
                                         nat2tuple(nat2tuple(n)`2)`1),
                         (: nat2tuple(nat2tuple(n)`2)`2 :)))) = length(append(nat2listnat_aux(nat2tuple(n)`1 - 1,
                                         nat2tuple(nat2tuple(n)`2)`1),
                         (: nat2tuple(nat2tuple(n)`2)`2 :)))") (("1" (replace -1) (("1" (hide -1 1) (("1" (rewrite "length_append") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (rewrite "map_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "forall(l : list[mf_PVS0Expr[nat]]): null?[mf_PVS0Expr[nat]](l) OR cons?[mf_PVS0Expr[nat]](l)") (("1" (inst?) (("1" (replace 1) (("1" (propax) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (grind) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (grind) (("4" (expand "nat2listnat_aux") (("4" (lift-if) (("4" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "map[nat, (valid_index(length(nat2listnat(n + 1)) - 1))]
                               (nat2PVS0_limit[false_val, lop1, lop2]
                                    (length[nat](nat2listnat(n + 1)) - 1))
                               (nat2listnat(n + 1))") (("1" (rewrite "every_forall") (("1" (expand "limited") (("1" (skeep) (("1" (inst -1 "i") (("1" (prop) (("1" (expand "valid_index") (("1" (rewrite "map_length") (("1" (use "subtype_length[mf_PVS0Expr[nat],(valid_index(length(nat2listnat(n + 1))
                                                                                                    -
                                                                                                    1))]") (("1" (hide -1) (("1" (rewrite "map_length") (("1" (assert) (("1" (use "subtype_nth[mf_PVS0Expr[number],mf_PVS0Expr[nat]]") (("1" (case "length(map[nat,
                                 (valid_index(length(nat2listnat(n + 1))
                                              -
                                              1))]
                                 (nat2PVS0_limit(length[nat]
                                                 (nat2listnat(1 + n))
                                                 -
                                                 1))
                                 (nat2listnat(1 + n))) =length[nat](nat2listnat(1 + n))") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") nil nil)) nil) ("3" (hide-all-but 1) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but 1) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (length_null_list formula-decl nil more_list_props structures) (n skolem-const-decl "nat" mf_pvs0_computable nil) (subtype_length formula-decl nil subtype_length nil) (nat2listnat_aux def-decl "list[nat]" mf_pvs0_computable nil) (append def-decl "list[T]" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (length_singleton formula-decl nil more_list_props structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_append formula-decl nil list_props nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (map_length formula-decl nil more_map_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (nat2listnat const-decl "list[nat]" mf_pvs0_computable nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (map adt-def-decl "list[T1]" list_adt_map nil) (nat2PVS0_limit def-decl "(valid_index(limit))" mf_pvs0_computable nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (every_forall formula-decl nil more_list_props structures) (subtype_nth formula-decl nil subtype_length nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (limited const-decl "bool" mf_pvs0_computable nil)) nil (nat2listPVS0nat subtype "list_adt_map[nat, (mf_pvs0_computable.valid_index((number_fields.-)(list_props[nat].length(mf_pvs0_computable.nat2listnat((number_fields.+)(mf_pvs0_computable.n, 1))), 1)))].map(mf_pvs0_computable.nat2PVS0_limit((number_fields.-)(list_props[nat].length(mf_pvs0_computable.nat2listnat((number_fields.+)(mf_pvs0_computable.n, 1))), 1)))(mf_pvs0_computable.nat2listnat((number_fields.+)(mf_pvs0_computable.n, 1)))" "(mf_pvs0_computable.limited)")) (nat2listPVS0nat_TCC3-1 nil 3799245897 ("" (subtype-tcc) nil nil) nil nil (nat2listPVS0nat subtype "list_adt_map[nat, (mf_pvs0_computable.valid_index((number_fields.-)(list_props[nat].length(mf_pvs0_computable.nat2listnat((number_fields.+)(mf_pvs0_computable.n, 1))), 1)))].map(mf_pvs0_computable.nat2PVS0_limit((number_fields.-)(list_props[nat].length(mf_pvs0_computable.nat2listnat((number_fields.+)(mf_pvs0_computable.n, 1))), 1)))(mf_pvs0_computable.nat2listnat((number_fields.+)(mf_pvs0_computable.n, 1)))" "(mf_pvs0_computable.limited)"))) (listPVS0nat2nat_nat2listPVS0nat 0 (listPVS0nat2nat_nat2listPVS0nat-2 nil 3799246834 ("" (skeep) (("" (expand "nat2listPVS0nat") (("" (expand "listPVS0nat2nat") (("" (case "length
                                     (map
                                      (nat2PVS0_limit
                                       (length(nat2listnat(1 + n)) - 1))
                                      (nat2listnat(1 + n))) = length[(valid_index
                                                  ((number_fields.-)
                                                   (list_props
                                                    [naturalnumbers.nat].length
                                                    (nat2listnat
                                                     ((number_fields.+)
                                                      (n, 1))),
                                                    1)))]
                                     (map
                                      (nat2PVS0_limit
                                       (length(nat2listnat(1 + n)) - 1))
                                      (nat2listnat(1 + n)))") (("1" (replaces -1) (("1" (rewrite "map_length") (("1" (rewrite "map_list_composition") (("1" (case "PVS02nat_limit(length(nat2listnat(1 + n)) - 1) o
                                                                                                  nat2PVS0_limit(length(nat2listnat(1 + n)) - 1) = (lambda(m : nat): m)") (("1" (replaces -1) (("1" (rewrite "map_identity") (("1" (assert) (("1" (rewrite "listnat2nat_nat2listnat") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (expand "o") (("1" (use "PVS02nat_nat2PVS0_limit") (("1" (hide 2) (("1" (expand "nat2listnat") (("1" (expand "nat2listnat_aux") (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (hide 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (expand "nat2listnat") (("4" (expand "nat2listnat_aux") (("4" (lift-if) (("4" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat2listPVS0nat const-decl "(limited)" mf_pvs0_computable nil) (nat2PVS0_limit def-decl "(valid_index(limit))" mf_pvs0_computable nil) (map adt-def-decl "list[T1]" list_adt_map nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat2listnat const-decl "list[nat]" mf_pvs0_computable nil) (length def-decl "nat" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (map_length formula-decl nil more_map_props nil) (O const-decl "T3" function_props nil) (map_identity formula-decl nil map_identity nil) (listnat2nat_nat2listnat formula-decl nil mf_pvs0_computable nil) (n skolem-const-decl "nat" mf_pvs0_computable nil) (PVS02nat_nat2PVS0_limit formula-decl nil mf_pvs0_computable nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (length_append formula-decl nil list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_singleton formula-decl nil more_list_props structures) (nat2listnat_aux def-decl "list[nat]" mf_pvs0_computable nil) (map_list_composition formula-decl nil map_props nil) (PVS02nat_limit def-decl "nat" mf_pvs0_computable nil) (TRUE const-decl "bool" booleans nil) (listPVS0nat2nat const-decl "nat" mf_pvs0_computable nil)) nil) (listPVS0nat2nat_nat2listPVS0nat-1 nil 3799246703 ("" (skeep) (("" (expand "nat2listPVS0nat") (("" (expand "listPVS0nat2nat") (("" (use "subtype_length[mf_PVS0Expr[nat],(mf_pvs0_computable
                                                            [false_val,
                                                             lop1,
                                                             lop2].valid_index
                                                            ((number_fields.-)
                                                             (list_props
                                                              [naturalnumbers.nat].length
                                                              (nat2listnat
                                                               ((number_fields.+)(n, 1))),
                                                              1)))]") (("1" (replaces -1) (("1" (rewrite "map_length") (("1" (use "subtype_map[(mf_pvs0_computable
                                                                     [false_val,
                                                                      lop1,
                                                                      lop2].valid_index
                                                                     ((number_fields.-)
                                                                      (list_props
                                                                       [naturalnumbers.nat].length
                                                                       (nat2listnat
                                                                        ((number_fields.+)(n, 1))),
                                                                       1))), nat,  (mf_pvs0_computable
                                                                    [false_val,
                                                                     lop1,
                                                                     lop2].valid_index
                                                                    ((number_fields.-)
                                                                     (list_props
                                                                      [mf_PVS0Expr_adt
                                                                       [naturalnumbers.nat].mf_PVS0Expr].length
                                                                      (list_adt_map
                                                                       [naturalnumbers.nat,
                                                                        (mf_pvs0_computable
                                                                         [false_val,
                                                                          lop1,
                                                                          lop2].valid_index
                                                                         ((number_fields.-)
                                                                          (list_props
                                                                           [naturalnumbers.nat].length
                                                                           (nat2listnat
                                                                            ((number_fields.+)(n, 1))),
                                                                           1)))].map
                                                                       (mf_pvs0_computable
                                                                        [false_val,
                                                                         lop1,
                                                                         lop2].nat2PVS0_limit
                                                                        ((number_fields.-)
                                                                         (list_props
                                                                          [naturalnumbers.nat].length
                                                                          (nat2listnat
                                                                           ((number_fields.+)(1, n))),
                                                                          1)))
                                                                       (nat2listnat
                                                                        ((number_fields.+)(1, n)))),
                                                                      1))), nat]") (("1" (replaces -1) (("1" (rewrite "map_list_composition") (("1" (case "PVS02nat_limit(length(nat2listnat(1 + n)) - 1) o
                                                                    nat2PVS0_limit(length(nat2listnat(1 + n)) - 1) = (lambda(m : nat): m)") (("1" (replaces -1) (("1" (rewrite "map_identity") (("1" (assert) (("1" (rewrite "listnat2nat_nat2listnat") (("1" (assert) nil))))))))) ("2" (hide 2) (("2" (decompose-equality) (("1" (expand "o") (("1" (use "PVS02nat_nat2PVS0_limit") (("1" (hide 2) (("1" (expand "nat2listnat") (("1" (expand "nat2listnat_aux") (("1" (lift-if) (("1" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))) ("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))) ("3" (hide 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))) ("2" (hide 2) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))) ("2" (hide 2) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))) ("3" (assert) (("3" (hide 2) (("3" (skeep) (("3" (expand "valid_index") (("3" (use "subtype_length[mf_PVS0Expr[nat], (mf_pvs0_computable
                                                                          [false_val,
                                                                           lop1,
                                                                           lop2].valid_index
                                                                          ((number_fields.-)
                                                                           (list_props
                                                                            [naturalnumbers.nat].length
                                                                            (nat2listnat
                                                                             ((number_fields.+)(n, 1))),
                                                                            1)))]") (("1" (replaces -1) (("1" (rewrite "map_length") (("1" (assert) nil) ("2" (hide 2) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))) ("2" (hide 2) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))) ("3" (hide 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))))))))) ("4" (hide 2) (("4" (rewrite "every_forall") (("1" (skeep) (("1" (prop) (("1" (typepred "nth(map[nat, (valid_index(length(nat2listnat(n + 1)) - 1))]
                                                       (nat2PVS0_limit[false_val, lop1, lop2]
                                                            (length[nat](nat2listnat(1 + n)) - 1))
                                                       (nat2listnat(1 + n)),
                                                   n_1)") (("1" (hide -2) (("1" (use "subtype_nth[mf_PVS0Expr[number], (mf_pvs0_computable
                                                                           [false_val,
                                                                            lop1,
                                                                            lop2].valid_index
                                                                           ((number_fields.-)
                                                                                (list_props[naturalnumbers.nat].length
                                                                                     (nat2listnat((number_fields.+)(n, 1))),
                                                                                 1)))]") (("1" (grind) nil) ("2" (hide-all-but 1) (("2" (typepred "n_1") (("2" (name-replace "nl" "map
                                                                [nat,
                                                                 (valid_index[false_val, lop1, lop2]
                                                                      (length[nat](nat2listnat(n + 1)) - 1))]
                                                                (nat2PVS0_limit[false_val, lop1, lop2]
                                                                     (length[nat](nat2listnat(1 + n)) - 1))
                                                                (nat2listnat(1 + n))") (("1" (use "subtype_length[mf_PVS0Expr[number],(mf_pvs0_computable
                                                                                   [false_val,
                                                                                    lop1,
                                                                                    lop2].valid_index
                                                                                   (((number_fields.-)
                                                                                         (list_props[naturalnumbers.nat].length
                                                                                              (nat2listnat(((number_fields.+)(n, 1)))),
                                                                                          1))))]") (("1" (assert) nil))) ("2" (hide-all-but 1) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (grind) nil))))))))))))))))))) ("3" (hide-all-but 1) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (grind) nil))))))))))))))))) ("2" (hide 2) (("2" (typepred "n_1") (("2" (name-replace "nl" "map
                                                          [nat,
                                                           (valid_index[false_val, lop1, lop2]
                                                                (length[nat](nat2listnat(n + 1)) - 1))]
                                                          (nat2PVS0_limit[false_val, lop1, lop2]
                                                               (length[nat](nat2listnat(1 + n)) - 1))
                                                          (nat2listnat(1 + n))") (("1" (use "subtype_length[mf_PVS0Expr_adt[numbers.number].mf_PVS0Expr, (mf_pvs0_computable
                                                                                 [false_val,
                                                                                  lop1,
                                                                                  lop2].valid_index
                                                                                 ((number_fields.-)
                                                                                      (list_props[naturalnumbers.nat].length
                                                                                           (nat2listnat((number_fields.+)(n, 1))),
                                                                                       1)))]") (("1" (assert) nil))) ("2" (hide-all-but 1) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))) ("3" (hide -1 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))))) ("3" (hide 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))) ("4" (hide 2) (("4" (expand "nat2listnat") (("4" (expand "nat2listnat_aux") (("4" (lift-if) (("4" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))) ("2" (typepred "nth(map[nat, (valid_index(length(nat2listnat(n + 1)) - 1))]
                                                       (nat2PVS0_limit[false_val, lop1, lop2]
                                                            (length[nat](nat2listnat(1 + n)) - 1))
                                                       (nat2listnat(1 + n)),
                                                   n_1)") (("1" (hide -1) (("1" (name-replace "nl" "map[nat, (valid_index(length(nat2listnat(n + 1)) - 1))]
                                                             (nat2PVS0_limit[false_val, lop1, lop2]
                                                                  (length[nat](nat2listnat(1 + n)) - 1))
                                                             (nat2listnat(1 + n))") (("1" (use "subtype_nth[mf_PVS0Expr_adt[numbers.number].mf_PVS0Expr, (mf_pvs0_computable
                                                                                 [false_val,
                                                                                  lop1,
                                                                                  lop2].valid_index
                                                                                 ((number_fields.-)
                                                                                      (list_props[naturalnumbers.nat].length
                                                                                           (nat2listnat((number_fields.+)(n, 1))),
                                                                                       1)))]") (("1" (assert) (("1" (replaces -1) (("1" (expand "nl" 1 1) (("1" (lemma "subtype_length[mf_PVS0Expr_adt[naturalnumbers.nat].mf_PVS0Expr, (valid_index(length(nat2listnat(n + 1)) - 1))]") (("1" (inst -1 "map
                                                                          [nat,
                                                                           (valid_index(length(nat2listnat(n + 1)) - 1))]
                                                                          (nat2PVS0_limit[false_val, lop1, lop2]
                                                                               (length[nat](nat2listnat(1 + n)) - 1))
                                                                          (nat2listnat(1 + n))") (("1" (replaces -1) (("1" (rewrite "map_length") nil))) ("2" (hide -1 2) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))) ("3" (hide -1 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))) ("2" (hide 2) (("2" (typepred "n_1") (("2" (name-replace "nl" "map
                                                          [nat,
                                                           (valid_index[false_val, lop1, lop2]
                                                                (length[nat](nat2listnat(n + 1)) - 1))]
                                                          (nat2PVS0_limit[false_val, lop1, lop2]
                                                               (length[nat](nat2listnat(1 + n)) - 1))
                                                          (nat2listnat(1 + n))") (("1" (use "subtype_length[mf_PVS0Expr_adt[numbers.number].mf_PVS0Expr, (valid_index[false_val, lop1, lop2]
                                                                             (length[nat](nat2listnat(n + 1)) - 1))]") (("1" (assert) nil))) ("2" (hide -1 2) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))) ("3" (hide (-1 2)) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))))) ("3" (hide 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))) ("4" (hide 2) (("4" (expand "nat2listnat") (("4" (expand "nat2listnat_aux") (("4" (lift-if) (("4" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))))) ("2" (skeep) (("2" (hide-all-but 1) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) (("2" (use "subtype_length[mf_PVS0Expr_adt[naturalnumbers.nat].mf_PVS0Expr, (mf_pvs0_computable
                                                                           [false_val,
                                                                            lop1,
                                                                            lop2].valid_index
                                                                           ((number_fields.-)
                                                                                (list_props[naturalnumbers.nat].length
                                                                                     (nat2listnat
                                                                                      ((number_fields.+)(n, 1))),
                                                                                 1)))]") (("1" (replaces -1) (("1" (rewrite "map_length") (("1" (rewrite "length_append") (("1" (assert) nil))))))) ("2" (hide 2 3) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))))))))))))) ("3" (skeep) (("3" (hide -1 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))) ("4" (skeep) (("4" (hide -1 2) (("4" (expand "nat2listnat") (("4" (expand "nat2listnat_aux") (("4" (lift-if) (("4" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))) ("5" (hide 2) (("5" (expand "nat2listnat") (("5" (expand "nat2listnat_aux") (("5" (lift-if) (("5" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))) ("5" (hide 2) (("5" (expand "nat2listnat") (("5" (expand "nat2listnat_aux") (("5" (lift-if) (("5" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))) ("6" (skeep) (("6" (hide 2) (("6" (typepred "x") (("6" (use "subtype_length[mf_PVS0Expr[nat], (mf_pvs0_computable
                                                                   [false_val,
                                                                    lop1,
                                                                    lop2].valid_index
                                                                   ((number_fields.-)
                                                                        (list_props[naturalnumbers.nat].length
                                                                         (nat2listnat
                                                                          ((number_fields.+)(n, 1))),
                                                                         1)))]") (("1" (replaces -1) (("1" (rewrite "map_length") (("1" (hide-all-but 1) (("1" (expand "nat2listnat") (("1" (expand "nat2listnat_aux") (("1" (lift-if) (("1" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))) ("3" (hide-all-but 1) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))))))))) ("2" (hide 2) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))) ("2" (hide 2) (("2" (rewrite "every_forall") (("1" (skeep) (("1" (prop) (("1" (typepred "nth(map[nat, (valid_index(length(nat2listnat(n + 1)) - 1))]
                                           (nat2PVS0_limit[false_val, lop1, lop2]
                                                (length[nat](nat2listnat(1 + n)) - 1))
                                           (nat2listnat(1 + n)),
                                       n_1)") (("1" (hide -2) (("1" (use "subtype_nth[mf_PVS0Expr[number],(mf_pvs0_computable
                                                               [false_val,
                                                                lop1,
                                                                lop2].valid_index
                                                               ((number_fields.-)
                                                                    (list_props[naturalnumbers.nat].length
                                                                         (nat2listnat((number_fields.+)(n, 1))),
                                                                     1))) ]") (("1" (replaces -1) (("1" (assert) (("1" (grind) nil))))) ("2" (hide-all-but 1) (("2" (typepred "n_1") (("2" (use "subtype_length[mf_PVS0Expr_adt[numbers.number].mf_PVS0Expr, (mf_pvs0_computable
                                                                     [false_val,
                                                                      lop1,
                                                                      lop2].valid_index
                                                                     (((number_fields.-)
                                                                           (list_props[naturalnumbers.nat].length
                                                                                (nat2listnat(((number_fields.+)(n, 1)))),
                                                                            1))))]") (("1" (assert) nil) ("2" (hide-all-but 1) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))))) ("3" (hide-all-but 1) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))) ("2" (hide 2) (("2" (typepred "n_1") (("2" (name-replace "nl" "map
                                              [nat,
                                               (valid_index[false_val, lop1, lop2]
                                                    (length[nat](nat2listnat(n + 1)) - 1))]
                                              (nat2PVS0_limit[false_val, lop1, lop2]
                                                   (length[nat](nat2listnat(1 + n)) - 1))
                                              (nat2listnat(1 + n))") (("1" (use "subtype_length[mf_PVS0Expr_adt[numbers.number].mf_PVS0Expr, (mf_pvs0_computable
                                                                     [false_val,
                                                                      lop1,
                                                                      lop2].valid_index
                                                                     ((number_fields.-)
                                                                          (list_props[naturalnumbers.nat].length
                                                                               (nat2listnat((number_fields.+)(n, 1))),
                                                                           1)))]") (("1" (assert) nil))) ("2" (hide -1 2) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))) ("3" (hide -1 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))))) ("3" (hide 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))) ("4" (hide 2) (("4" (expand "nat2listnat") (("4" (expand "nat2listnat_aux") (("4" (lift-if) (("4" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))) ("2" (typepred "nth(map[nat, (valid_index(length(nat2listnat(n + 1)) - 1))]
                                           (nat2PVS0_limit[false_val, lop1, lop2]
                                                (length[nat](nat2listnat(1 + n)) - 1))
                                           (nat2listnat(1 + n)),
                                       n_1)") (("1" (hide -1) (("1" (use "subtype_nth[mf_PVS0Expr_adt[numbers.number].mf_PVS0Expr, (mf_pvs0_computable
                                                               [false_val,
                                                                lop1,
                                                                lop2].valid_index
                                                               ((number_fields.-)
                                                                    (list_props[naturalnumbers.nat].length
                                                                         (nat2listnat((number_fields.+)(n, 1))),
                                                                     1)))]") (("1" (assert) nil) ("2" (hide-all-but 1) (("2" (typepred "n_1") (("2" (use "subtype_length[mf_PVS0Expr_adt[numbers.number].mf_PVS0Expr, (mf_pvs0_computable
                                                                 [false_val,
                                                                  lop1,
                                                                  lop2].valid_index
                                                                 (((number_fields.-)
                                                                       (list_props[naturalnumbers.nat].length
                                                                            (nat2listnat(((number_fields.+)(n, 1)))),
                                                                        1))))]") (("1" (assert) nil) ("2" (hide 2) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (grind) nil))))))))))))))))))) ("3" (hide-all-but 1) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))) ("2" (hide 2) (("2" (typepred "n_1") (("2" (name-replace "nl" "map
                                              [nat,
                                               (valid_index[false_val, lop1, lop2]
                                                    (length[nat](nat2listnat(n + 1)) - 1))]
                                              (nat2PVS0_limit[false_val, lop1, lop2]
                                                   (length[nat](nat2listnat(1 + n)) - 1))
                                              (nat2listnat(1 + n))") (("1" (use "subtype_length[mf_PVS0Expr_adt[numbers.number].mf_PVS0Expr, (mf_pvs0_computable
                                                                     [false_val,
                                                                      lop1,
                                                                      lop2].valid_index
                                                                     ((number_fields.-)
                                                                          (list_props[naturalnumbers.nat].length
                                                                               (nat2listnat((number_fields.+)(n, 1))),
                                                                           1)))]") (("1" (assert) nil))) ("2" (hide -1 2) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))) ("3" (hide -1 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))))) ("3" (hide 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))) ("4" (hide 2) (("4" (expand "nat2listnat") (("4" (expand "nat2listnat_aux") (("4" (lift-if) (("4" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))))) ("2" (hide 2) (("2" (skeep) (("2" (expand "nat2listnat") (("2" (expand "nat2listnat_aux") (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))) ("3" (hide 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil))))))))))))))))) ("3" (hide 2) (("3" (expand "nat2listnat") (("3" (expand "nat2listnat_aux") (("3" (lift-if) (("3" (prop) (("1" (grind) nil) ("2" (rewrite "length_append") (("2" (assert) nil)))))))))))))))))))) nil) nil nil)) (nat2listPVS0nat_listPVS0nat2nat 0 (nat2listPVS0nat_listPVS0nat2nat-1 nil 3799247075 ("" (skeep) (("" (expand "listPVS0nat2nat") (("" (expand "nat2listPVS0nat") (("" (rewrite "nat2listnat_listnat2nat") (("1" (rewrite "map_list_composition") (("1" (rewrite "map_length") (("1" (case "nat2PVS0_limit(length(l) - 1) o PVS02nat_limit(length(l) - 1) = lambda(p : (valid_index(length(l)-1))):p") (("1" (replaces -1) (("1" (rewrite "map_identity") (("1" (use "map_identity[(valid_index(length(l) - 1))]") (("1" (use "subtype_map[(valid_index((number_fields.-)
                                 (list_props
                                      [mf_PVS0Expr_adt
                                       [nat].mf_PVS0Expr].length
                                      (l),
                                  1))),(valid_index((number_fields.-)
                                 (list_props
                                      [mf_PVS0Expr_adt
                                       [nat].mf_PVS0Expr].length
                                      (l),
                                  1))),(valid_index((number_fields.-)
                                 (list_props
                                      [mf_PVS0Expr_adt
                                       [nat].mf_PVS0Expr].length
                                      (l),
                                  1))),(valid_index((number_fields.-)
                                 (list_props[naturalnumbers.nat].length
                                      (nat2listnat
                                       ((number_fields.+)
                                        ((number_fields.-)
                                         (listnat2nat
                                          (list_adt_map
                                           [(valid_index
                                             ((number_fields.-)
                                              (list_props
                                               [mf_PVS0Expr_adt
                                                [nat].mf_PVS0Expr].length
                                               (l),
                                               1))),
                                            naturalnumbers.nat].map
                                           (PVS02nat_limit
                                            ((number_fields.-)
                                             (list_props
                                              [mf_PVS0Expr_adt
                                               [nat].mf_PVS0Expr].length
                                              (l),
                                              1)))
                                           (l)),
                                          1),
                                         1))),
                                  1)))]") (("1" (replace -1 :dir rl) (("1" (replace -2) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (rewrite "nat2listnat_listnat2nat") (("2" (rewrite "map_length") (("2" (typepred "p") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "l") (("3" (grind) nil nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (typepred "l") (("4" (grind) nil nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (skeep) (("5" (typepred "x") (("5" (rewrite "nat2listnat_listnat2nat") (("5" (assert) (("5" (rewrite "map_length") nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide-all-but 1) (("6" (typepred "l") (("6" (rewrite "nat2listnat_listnat2nat") (("6" (rewrite "map_length") (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "o ") (("2" (decompose-equality) (("1" (rewrite "nat2PVS0_PVS02nat_limit") nil nil) ("2" (skeep) (("2" (typepred "l") (("2" (grind) nil nil)) nil)) nil) ("3" (typepred "l") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "l") (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "l") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "map_length") (("1" (typepred "l") (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (typepred "l") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "l") (("3" (rewrite "nat2listnat_listnat2nat") (("1" (grind) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "l") (("4" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "l") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((listPVS0nat2nat const-decl "nat" mf_pvs0_computable nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat2listnat_listnat2nat formula-decl nil mf_pvs0_computable nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index const-decl "bool" mf_pvs0_computable nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (limited const-decl "bool" mf_pvs0_computable nil) (map adt-def-decl "list[T1]" list_adt_map nil) (PVS02nat_limit def-decl "nat" mf_pvs0_computable nil) (map_length formula-decl nil more_map_props nil) (nat2PVS0_PVS02nat_limit formula-decl nil mf_pvs0_computable nil) (TRUE const-decl "bool" booleans nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (l skolem-const-decl "(limited)" mf_pvs0_computable nil) (subtype_map formula-decl nil subtype_map nil) (map_identity formula-decl nil map_identity nil) (O const-decl "T3" function_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (listnat2nat const-decl "nat" mf_pvs0_computable nil) (nat2listnat const-decl "list[nat]" mf_pvs0_computable nil) (nat2PVS0_limit def-decl "(valid_index(limit))" mf_pvs0_computable nil) (map_list_composition formula-decl nil map_props nil) (nat2listPVS0nat const-decl "(limited)" mf_pvs0_computable nil)) nil)))
