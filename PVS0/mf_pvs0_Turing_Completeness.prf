(mf_pvs0_Turing_Completeness (proj_aux_function_TCC1 0 (proj_aux_function_TCC1-1 nil 3768906966 ("" (subtype-tcc) nil nil) nil nil (proj_aux_function subtype "(number_fields.-)(mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.j)" "naturalnumber"))) (proj_aux_function_TCC2 0 (proj_aux_function_TCC2-1 nil 3768906966 ("" (termination-tcc) nil nil) nil nil (proj_aux_function termination "mf_pvs0_Turing_Completeness.proj_aux_function((number_fields.+)(mf_pvs0_Turing_Completeness.j, 1), mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.n, mf_pvs0_basic_programs.pi2(mf_pvs0_Turing_Completeness.x))" "nil"))) (nat2list_TCC1 0 (nat2list_TCC1-1 nil 3776781660 ("" (subtype-tcc) nil nil) nil nil (nat2list subtype "(number_fields.-)(mf_pvs0_Turing_Completeness.n, 1)" "nat"))) (nat2list_TCC2 0 (nat2list_TCC2-1 nil 3776781660 ("" (termination-tcc) nil nil) nil nil (nat2list termination "mf_pvs0_Turing_Completeness.nat2list((number_fields.-)(mf_pvs0_Turing_Completeness.n, 1), mf_pvs0_basic_programs.pi2(mf_pvs0_Turing_Completeness.x))" "nil"))) (nat2list_length 0 (nat2list_length-1 nil 3777216097 ("" (measure-induct+ "n" "n") (("" (skeep) (("" (expand "nat2list" 1) (("" (lift-if) (("" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (inst?) (("1" (assert) (("1" (expand "length" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((x!1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (nat2list def-decl "list[nat]" mf_pvs0_Turing_Completeness nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (well_founded? const-decl "bool" orders nil)) shostak)) (proj_aux_function_not_last 0 (proj_aux_function_not_last-1 nil 3777211983 ("" (measure-induct+ "i-j" ("j" "i")) (("" (skeep) (("" (typepred "x!2") (("" (typepred "n") (("" (expand "proj_aux_function" 1) (("" (typepred "m") (("" (lift-if) (("" (prop) (("" (assert) (("" (inst -5 "1+x!1" "x!2") (("" (inst -5 "pi2(x)" "n" "m") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (proj_aux_function def-decl "nat" mf_pvs0_Turing_Completeness nil) (well_founded? const-decl "bool" orders nil)) shostak)) (proj_aux_function_last_TCC1 0 (proj_aux_function_last_TCC1-1 nil 3777214435 ("" (subtype-tcc) nil nil) nil nil (proj_aux_function_last subtype "(number_fields.-)((number_fields.+)(1, mf_pvs0_Turing_Completeness.n), mf_pvs0_Turing_Completeness.j)" "nat"))) (proj_aux_function_last_TCC2 0 (proj_aux_function_last_TCC2-1 nil 3777214435 ("" (skeep) (("" (rewrite "nat2list_length") (("" (assert) nil nil)) nil)) nil) ((nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil)) nil (proj_aux_function_last subtype "(number_fields.-)(mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.j)" "below[length[nat](nat2list(1 + n - j, x))]"))) (proj_aux_function_last 0 (proj_aux_function_last-2 "" 3804629328 ("" (measure-induct+ "i-j" ("j" "i")) (("1" (skeep) (("1" (expand "proj_aux_function" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "nat2list" 1) (("1" (typepred "n") (("1" (assert) (("1" (expand "nth" 1) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (typepred "x!2") (("2" (case "x!1= x!2") (("1" (typepred "n") (("1" (replace -1) (("1" (replace -2) (("1" (assert) (("1" (expand "nat2list" 2) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "y!1") (("2" (typepred "y!2") (("2" (assert) (("2" (typepred "x!2") (("2" (rewrite "nat2list_length") (("2" (typepred "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (rewrite "nat2list_length") (("3" (typepred "n") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (skeep) (("4" (rewrite "nat2list_length") (("4" (typepred "n") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (grind) nil nil) ("6" (rewrite "nat2list_length") (("6" (typepred "n!1") (("6" (assert) nil nil)) nil)) nil) ("7" (assert) nil nil) ("8" (skeep) (("8" (assert) (("8" (typepred "n") (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (typepred "y!1`2") (("9" (assert) nil nil)) nil) ("10" (rewrite "nat2list_length") (("10" (typepred "n!1") (("10" (assert) nil nil)) nil)) nil) ("11" (typepred "n!1") (("11" (assert) nil nil)) nil) ("12" (skeep) (("12" (rewrite "nat2list_length") (("12" (assert) nil nil)) nil)) nil) ("13" (skeep) (("13" (typepred "n") (("13" (assert) nil nil)) nil)) nil) ("14" (rewrite "nat2list_length") (("14" (typepred "n!1") (("14" (assert) nil nil)) nil)) nil)) nil) ((nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (proj_aux_function def-decl "nat" mf_pvs0_Turing_Completeness nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (nat2list def-decl "list[nat]" mf_pvs0_Turing_Completeness nil) (well_founded? const-decl "bool" orders nil)) shostak) (proj_aux_function_last-1 nil 3777214435 ("" (measure-induct+ "i-j" ("j" "i")) (("1" (skeep) (("1" (expand "proj_aux_function" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "nat2list" 1) (("1" (typepred "n") (("1" (assert) (("1" (expand "nth" 1) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (typepred "x!2") (("2" (case "x!1= x!2") (("1" (typepred "n") (("1" (replace -1) (("1" (replace -2) (("1" (assert) (("1" (expand "nat2list" 2) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "y!1") (("2" (typepred "y!2") (("2" (assert) (("2" (typepred "x!2") (("2" (rewrite "nat2list_length") (("2" (typepred "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (rewrite "nat2list_length") (("3" (typepred "n") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (skeep) (("4" (rewrite "nat2list_length") (("4" (typepred "n1") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (grind) nil nil) ("6" (rewrite "nat2list_length") (("6" (typepred "n!1") (("6" (assert) nil nil)) nil)) nil) ("7" (assert) nil nil) ("8" (skeep) (("8" (assert) (("8" (typepred "n1") (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (typepred "y!1`2") (("9" (assert) nil nil)) nil) ("10" (rewrite "nat2list_length") (("10" (typepred "n!1") (("10" (assert) nil nil)) nil)) nil) ("11" (typepred "n!1") (("11" (assert) nil nil)) nil) ("12" (skeep) (("12" (rewrite "nat2list_length") (("12" (assert) nil nil)) nil)) nil) ("13" (skeep) (("13" (typepred "n") (("13" (assert) nil nil)) nil)) nil) ("14" (rewrite "nat2list_length") (("14" (typepred "n!1") (("14" (assert) nil nil)) nil)) nil)) nil) ((pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil)) shostak)) (nat2list_extension_TCC1 0 (nat2list_extension_TCC1-1 nil 3777301829 ("" (skeep) (("" (rewrite "nat2list_length") (("" (assert) nil nil)) nil)) nil) ((nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil)) nil (nat2list_extension subtype "mf_pvs0_Turing_Completeness.i" "below[length[nat](nat2list(1 + n, x))]"))) (nat2list_extension_TCC2 0 (nat2list_extension_TCC2-1 nil 3777301829 ("" (skeep) (("" (rewrite "nat2list_length") (("" (assert) nil nil)) nil)) nil) ((nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil)) nil (nat2list_extension subtype "mf_pvs0_Turing_Completeness.i" "below[length[nat](nat2list(1 + m, x))]"))) (nat2list_extension 0 (nat2list_extension-1 nil 3777301829 ("" (measure-induct+ "n" "n") (("1" (skeep) (("1" (expand "nat2list" 1 1) (("1" (expand "nat2list" 1 2) (("1" (expand "nth" 1) (("1" (lift-if) (("1" (prop) (("1" (inst -1 "x!1-1") (("1" (assert) (("1" (inst -1 "pi2(x)" "i-1" "m-1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nat2list_length") (("2" (assert) nil nil)) nil) ("3" (rewrite "nat2list_length") (("3" (assert) nil nil)) nil) ("4" (rewrite "nat2list_length") (("4" (assert) nil nil)) nil) ("5" (rewrite "nat2list_length") (("5" (assert) nil nil)) nil)) nil) ((nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (nat2list def-decl "list[nat]" mf_pvs0_Turing_Completeness nil) (well_founded? const-decl "bool" orders nil)) shostak)) (proj_aux_function_works_TCC1 0 (proj_aux_function_works_TCC1-1 nil 3776781660 ("" (skeep) (("" (rewrite "nat2list_length") (("" (assert) nil nil)) nil)) nil) ((nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil)) nil (proj_aux_function_works subtype "(number_fields.-)(mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.j)" "below[length[nat](nat2list(1 + n, x))]"))) (proj_aux_function_works 0 (proj_aux_function_works-1 nil 3776781660 ("" (measure-induct+ "i-j" ("j" "i")) (("1" (skeep) (("1" (expand "proj_aux_function" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "nat2list" 1) (("1" (expand "nth" 1) (("1" (assert) (("1" (typepred "n") (("1" (case "n > 1") (("1" (inst -4 "x!1+1" "x!2") (("1" (inst -4 "pi2(x)" "n") (("1" (assert) (("1" (lemma "nat2list_extension") (("1" (inst -1 "pi2(x)" "n-1" "x!2-x!1-1" "n") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!2") (("2" (case "x!2=x!1") (("1" (typepred "n") (("1" (replace -2) (("1" (assert) (("1" (expand "nat2list" 2) (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nat2list_length") (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (rewrite "nat2list_length") (("3" (assert) nil nil)) nil)) nil) ("4" (skeep) (("4" (rewrite "nat2list_length") (("4" (assert) (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (assert) nil nil) ("6" (rewrite "nat2list_length") (("6" (assert) nil nil)) nil) ("7" (skeep) (("7" (assert) (("7" (rewrite "nat2list_length") (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (rewrite "nat2list_length") (("8" (assert) nil nil)) nil)) nil) ((nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (nat2list_extension formula-decl nil mf_pvs0_Turing_Completeness nil) (proj_aux_function def-decl "nat" mf_pvs0_Turing_Completeness nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (nat2list def-decl "list[nat]" mf_pvs0_Turing_Completeness nil) (well_founded? const-decl "bool" orders nil)) shostak)) (proj_aux_TCC1 0 (proj_aux_TCC1-1 nil 3768906966 ("" (skeep*) (("" (expand "partial_recursive?") (("" (skeep) (("" (expand "nth") (("" (expand "length") (("" (rewrite "map_length") (("" (lift-if) (("" (prop) (("1" (expand "valid_index_rec") (("1" (skeep*) (("1" (grind) (("1" (decompose-equality) nil nil) ("2" (decompose-equality) nil nil)) nil)) nil)) nil) ("2" (typepred "equal") (("2" (expand "partial_recursive?") (("2" (prop) (("2" (inst -4 "i_1-1") (("1" (rewrite "map_nth_rw") (("1" (lemma "valid_index_rec_offset") (("1" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "i_1") (("2" (expand "length" -1) (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((partial_recursive? const-decl "bool" mf_pvs0_computable nil) (nth def-decl "T" list_props nil) (map_length formula-decl nil more_map_props nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (equal const-decl "partial_recursive" mf_pvs0_basic_programs nil) (number nonempty-type-decl nil numbers nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (i_1 skolem-const-decl "below[length(cons[mf_PVS0Expr[nat]]
                 (ite[nat]
                      (op2[nat](0, i, j),
                       rec[nat]
                           (0, k4(op1[nat](0, j), i, n, op1[nat](2, x))),
                       ite[nat]
                           (rec[nat](1, op2[nat](1, i, n)), x,
                            op1[nat](1, x))),
                  map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                      (offset_rec[nat](1))(equal`4)))]" mf_pvs0_Turing_Completeness nil) (below type-eq-decl nil nat_types nil) (map adt-def-decl "list[T1]" list_adt_map nil) (x skolem-const-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (n skolem-const-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (k4 skolem-const-decl "[[mf_PVS0Expr[nat], mf_PVS0Expr[nat], mf_PVS0Expr[nat],
  mf_PVS0Expr[nat]] ->
   mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (j skolem-const-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (< const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (map_nth_rw formula-decl nil more_map_props nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (proj_aux subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].ite(mf_PVS0Expr_adt[nat].op2(0, mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.j), mf_PVS0Expr_adt[nat].rec(0, mf_pvs0_Turing_Completeness.k4(mf_PVS0Expr_adt[nat].op1(0, mf_pvs0_Turing_Completeness.j), mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.n, mf_PVS0Expr_adt[nat].op1(2, mf_pvs0_Turing_Completeness.x))), mf_PVS0Expr_adt[nat].ite(mf_PVS0Expr_adt[nat].rec(1, mf_PVS0Expr_adt[nat].op2(1, mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.n)), mf_pvs0_Turing_Completeness.x, mf_PVS0Expr_adt[nat].op1(1, mf_pvs0_Turing_Completeness.x))), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_basic_programs.equal`4)))" "partial_recursive[false_val, lop1, lop2]"))) (proj_aux_works 0 (proj_aux_works-1 nil 3768921138 ("" (measure-induct+ "if i > j then i -j else 0 endif" ("j" "i")) (("1" (skeep) (("1" (expand "proj_aux" 1) (("1" (expand "semantic_rel" 1) (("1" (expand "nth") (("1" (expand "semantic_rel_expr" 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "eval_op1") (("1" (expand "eval_op2") (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "eval_op1") (("1" (case "x!2 > x!1") (("1" (inst 1 "1") (("1" (prop) (("1" (inst 1 "x!2" "x!1") (("1" (prop) (("1" (expand "lop1") (("1" (expand "length") (("1" (expand "length") (("1" (expand "length") (("1" (assert) (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "pi2") (("1" (expand "o ") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "lop2") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (hide -2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (expand "length") (("2" (assert) (("2" (inst 2 "tuple2nat(x!1+1,tuple2nat(x!2,tuple2nat(n,pi2(x))))") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "x!1+1" "tuple2nat(x!2, tuple2nat(n, pi2(x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "x!1") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (assert) (("2" (assert) (("2" (expand "nth") (("2" (expand "succ") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "x!2" "tuple2nat(n, pi2(x))") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "n" "pi2(x)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(n, x)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "x") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(n, x)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (lift-if) (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (expand "proj_aux_function" 1) (("2" (inst -3 "1+x!1" "x!2") (("2" (inst -3 "n" "pi2(x)") (("2" (assert) (("2" (prop) (("1" (expand "semantic_rel" -1) (("1" (expand "proj_aux") (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "false_val") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (inst 2 "0") (("2" (prop) (("1" (inst 1 "x!2" "x!1") (("1" (prop) (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (expand "lop1") (("1" (expand "length") (("1" (expand "length") (("1" (expand "length") (("1" (lift-if) (("1" (assert) (("1" (expand "length") (("1" (assert) (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "pi2") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "lop2") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (hide -1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "false_val") (("2" (propax) nil nil)) nil) ("3" (expand "proj_aux_function" 1) (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "1") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (expand "nth") (("1" (expand "length") (("1" (inst 1 "tuple2nat(x!2,n)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "x!2" "n") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(n, x)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (lift-if) (("3" (assert) (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(equal`4,0)" "equal`4" "(: ite[nat]
                                               (op2(0,
                                                    op1[nat](1, op1[nat](2, vr)),
                                                    op1[nat](1, vr)),
                                                rec(0,
                                                    op2[nat]
                                                    (1,
                                                     op1(0, op1[nat](1, vr)),
                                                     op2[nat]
                                                     (1,
                                                      op1[nat](1, op1[nat](2, vr)),
                                                      op2[nat]
                                                      (1,
                                                       op1[nat]
                                                       (1, op1[nat](2, op1[nat](2, vr))),
                                                       op1
                                                       (2,
                                                        op1[nat]
                                                        (2,
                                                         op1[nat]
                                                         (2, op1[nat](2, vr)))))))),
                                                ite(rec
                                                    (1,
                                                     op2
                                                     (1,
                                                      op1[nat](1, op1[nat](2, vr)),
                                                      op1[nat]
                                                      (1,
                                                       op1[nat](2, op1[nat](2, vr))))),
                                                    op1[nat]
                                                    (2, op1[nat](2, op1[nat](2, vr))),
                                                    op1
                                                    (1,
                                                     op1[nat]
                                                     (2,
                                                      op1[nat](2, op1[nat](2, vr)))))) :)" "lop1" "lop2" "tuple2nat(x!2, n)" "1") (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (rewrite "map_nth_rw") (("1" (replaces -1 :dir rl) (("1" (lemma "equal_works") (("1" (inst -1 "x!2" "n") (("1" (expand "semantic_rel" -1) (("1" (expand "equal_function") (("1" (assert) (("1" (case "(lop1, lop2, false_val, equal`4) = equal") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (typepred "equal") (("2" (expand "partial_recursive?") (("2" (prop) (("2" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 2 "tuple2nat(n, x)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 " tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "false_val") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 2 "0") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (expand "nth") (("1" (inst 1 "tuple2nat(x!2,n)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "x!2" "n") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(n,x)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 " tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (lift-if) (("3" (expand "length") (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(equal`4,0)" "equal`4" "(: ite[nat]
                                               (op2(0,
                                                    op1[nat](1, op1[nat](2, vr)),
                                                    op1[nat](1, vr)),
                                                rec(0,
                                                    op2[nat]
                                                    (1,
                                                     op1(0, op1[nat](1, vr)),
                                                     op2[nat]
                                                     (1,
                                                      op1[nat](1, op1[nat](2, vr)),
                                                      op2[nat]
                                                      (1,
                                                       op1[nat]
                                                       (1, op1[nat](2, op1[nat](2, vr))),
                                                       op1
                                                       (2,
                                                        op1[nat]
                                                        (2,
                                                         op1[nat]
                                                         (2, op1[nat](2, vr)))))))),
                                                ite(rec
                                                    (1,
                                                     op2
                                                     (1,
                                                      op1[nat](1, op1[nat](2, vr)),
                                                      op1[nat]
                                                      (1,
                                                       op1[nat](2, op1[nat](2, vr))))),
                                                    op1[nat]
                                                    (2, op1[nat](2, op1[nat](2, vr))),
                                                    op1
                                                    (1,
                                                     op1[nat]
                                                     (2,
                                                      op1[nat](2, op1[nat](2, vr)))))) :)" "lop1" "lop2" "tuple2nat(x!2, n)" "0") (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (rewrite "map_nth_rw") (("1" (replaces -1 :dir rl) (("1" (lemma "equal_works") (("1" (inst -1 "x!2" "n") (("1" (expand "equal_function") (("1" (assert) (("1" (expand "semantic_rel") (("1" (case "(lop1, lop2, false_val, equal`4) = equal") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (typepred "equal") (("2" (expand "partial_recursive?") (("2" (prop) (("2" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "x") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(n, x)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ((semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (length_singleton formula-decl nil more_list_props structures) (greater const-decl "nat" mf_pvs0_basic_programs nil) (succ const-decl "nat" mf_pvs0_basic_programs nil) (equal const-decl "partial_recursive" mf_pvs0_basic_programs nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (equal_function const-decl "nat" mf_pvs0_basic_programs nil) (equal_works formula-decl nil mf_pvs0_basic_programs nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (eval_op1 const-decl "Val" mf_pvs0_expr nil) (proj_aux_function def-decl "nat" mf_pvs0_Turing_Completeness nil) (tuple2nat const-decl "nat" tuple2nat numbers) (proj_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (well_founded? const-decl "bool" orders nil)) shostak)) (proj_TCC1 0 (proj_TCC1-1 nil 3768906966 ("" (skeep*) (("" (replaces -1) (("" (replaces -1) (("" (replaces -1) (("" (replaces -1) (("" (expand "partial_recursive?") (("" (skeep) (("" (expand "valid_index_rec") (("" (skeep) (("" (expand "length") (("" (rewrite "map_length") (("" (expand "proj_aux") (("" (expand "length") (("" (rewrite "map_length") (("" (expand "equal") (("" (expand "length") (("" (expand "length") (("" (typepred "i!1") (("" (expand "length") (("" (rewrite "map_length") (("" (expand "proj_aux") (("" (expand "length") (("" (rewrite "map_length") (("" (expand "equal") (("" (expand "length") (("" (expand "length") (("" (expand "map") (("" (expand "map") (("" (expand "map") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "nth") (("" (lift-if) (("" (prop) (("1" (expand "subterm") (("1" (prop) (("1" (decompose-equality) (("1" (assert) nil nil)) nil) ("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (prop) (("1" (decompose-equality) nil nil) ("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (assert) (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((partial_recursive? const-decl "bool" mf_pvs0_computable nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (equal const-decl "partial_recursive" mf_pvs0_basic_programs nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (proj_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil)) nil (proj subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].rec(1, mf_pvs0_Turing_Completeness.k4(mf_PVS0Expr_adt[nat].cnst(0), mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.n, mf_pvs0_Turing_Completeness.x)), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_Turing_Completeness.proj_aux`4)))" "partial_recursive[false_val, lop1, lop2]"))) (proj_works 0 (proj_works-1 nil 3776698817 ("" (skeep) (("" (expand "proj" 1) (("" (expand "semantic_rel" 1) (("" (expand "nth" 1) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "tuple2nat(0,tuple2nat(i,tuple2nat(n,x)))") (("" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "0" "tuple2nat(i, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "i" "tuple2nat(n,x)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(i, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "n" "x") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(n, x)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(i, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(n, x)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(i, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(proj_aux`4,0)" "proj_aux`4" "(: rec(1,
                                 op2[nat]
                                     (1,
                                      cnst(0),
                                      op2[nat]
                                      (1,
                                       op1[nat](1, vr),
                                       op2[nat]
                                       (1,
                                        op1[nat](1, op1[nat](2, vr)),
                                        op1[nat](2, op1[nat](2, vr)))))) :)" "lop1" "lop2" "tuple2nat(0, tuple2nat(i, tuple2nat(n, x)))" "proj_function(i, n, x)") (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (lemma "proj_aux_works") (("1" (inst -1 "0" "i" "n" "x") (("1" (expand "semantic_rel") (("1" (expand "proj_function") (("1" (case "(lop1, lop2, false_val, proj_aux`4) = proj_aux") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((proj const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (tuple2nat const-decl "nat" tuple2nat numbers) (proj_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (proj_function const-decl "nat" mf_pvs0_Turing_Completeness nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (proj_aux_works formula-decl nil mf_pvs0_Turing_Completeness nil) (equal const-decl "partial_recursive" mf_pvs0_basic_programs nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (length_singleton formula-decl nil more_list_props structures) (eval_op1 const-decl "Val" mf_pvs0_expr nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil)) shostak)) (proj_correctness_TCC1 0 (proj_correctness_TCC1-1 nil 3777904173 ("" (skeep) (("" (rewrite "nat2list_length") (("" (assert) nil nil)) nil)) nil) ((nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil)) nil (proj_correctness subtype "mf_pvs0_Turing_Completeness.i" "below[length[nat](nat2list(1 + n, x))]"))) (proj_correctness 0 (proj_correctness-1 nil 3777904174 ("" (lemma "proj_works") (("" (skeep) (("" (inst?) (("" (expand "proj_function") (("" (rewrite "proj_aux_function_works") (("1" (assert) nil nil) ("2" (typepred "n") (("2" (rewrite "proj_aux_function_last") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((proj_function const-decl "nat" mf_pvs0_Turing_Completeness nil) (proj_aux_function_last formula-decl nil mf_pvs0_Turing_Completeness nil) (proj_aux_function_works formula-decl nil mf_pvs0_Turing_Completeness nil) (proj_works formula-decl nil mf_pvs0_Turing_Completeness nil)) shostak)) (expr_comp_TCC1 0 (expr_comp_TCC1-1 nil 3768906966 ("" (skeep*) (("" (typepred "l") (("" (grind) nil nil)) nil)) nil) ((limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil)) nil (expr_comp subtype "list_adt[(mf_pvs0_computable[mf_pvs0_basic_programs.false_val, mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2].limited)].cdr(mf_pvs0_Turing_Completeness.l)" "(list_adt[(mf_pvs0_computable[mf_pvs0_basic_programs.false_val, mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2].limited)].cons?)"))) (expr_comp_TCC2 0 (expr_comp_TCC2-1 nil 3768906966 ("" (termination-tcc) nil nil) nil nil (expr_comp termination "mf_pvs0_Turing_Completeness.expr_comp((number_fields.+)(mf_pvs0_Turing_Completeness.n, list_props[mf_PVS0Expr[nat]].length(list_adt[(mf_pvs0_computable[mf_pvs0_basic_programs.false_val, mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2].limited)].car(mf_pvs0_Turing_Completeness.l))), list_adt[(mf_pvs0_computable[mf_pvs0_basic_programs.false_val, mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2].limited)].cdr(mf_pvs0_Turing_Completeness.l))" "nil"))) (rec_indices_chain_offset_is_limited 0 (rec_indices_chain_offset_is_limited-1 nil 3771599334 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (expand "chain_offset" 1) (("" (lift-if) (("" (prop) (("1" (typepred "car(x!1)") (("1" (expand "limited") (("1" (inst -3 "i") (("1" (rewrite "map_length") (("1" (rewrite "map_nth_rw") (("1" (use "valid_index_rec_offset") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "chain_offset" -1) (("2" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil) ("2" (rewrite "map_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (typepred "car(x!1)") (("1" (expand "limited") (("1" (inst -3 "i") (("1" (rewrite "map_nth_rw") (("1" (lemma "valid_index_rec_offset") (("1" (inst -1 "nth(car(x!1),i)" "length(car(x!1))" "n") (("1" (assert) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (hide-all-but (-1 1)) (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") nil nil)) nil)) nil)) nil) ("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "length(car(x!1)) + n" "i - length(map(offset_rec(n))(car(x!1)))") (("1" (prop) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2 3) (("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "chain_offset" -1) (("2" (rewrite "length_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth_append formula-decl nil more_list_props structures) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (n skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (x!1 skolem-const-decl "(cons?[(limited)])" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "below[length(chain_offset(n, x!1))]" mf_pvs0_Turing_Completeness nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (well_founded? const-decl "bool" orders nil)) shostak)) (rec_indices_expr_comp_is_limited 0 (rec_indices_expr_comp_is_limited-1 nil 3771684102 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (expand "expr_comp" 1) (("" (expand "chain_offset" 1) (("" (lift-if) (("" (prop) (("1" (rewrite "map_length") (("1" (typepred "n") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm" -3) (("1" (expand "subterm" -3) (("1" (decompose-equality) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "length(car(x!1))+n") (("2" (prop) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm" -2) (("1" (prop) (("1" (expand "subterm" -1) (("1" (expand "subterm" -1) (("1" (decompose-equality) (("1" (typepred "n") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "i" "expr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (expr_comp def-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (well_founded? const-decl "bool" orders nil)) shostak)) (chain_offset_length 0 (chain_offset_length-1 nil 3771694926 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (expand "chain_offset" 1) (("" (expand "chain_of_appends" 1) (("" (lift-if) (("" (prop) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (expand "length" -1) (("1" (case "null?(cdr(x!1))") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "length(car(x!1)) + n") (("2" (prop) (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (chain_of_appends def-decl "list[T]" chain_of_appends nil) (chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (well_founded? const-decl "bool" orders nil)) shostak)) (comp_TCC1 0 (comp_TCC1-2 "" 3885312699 ("" (skeep*) (("" (expand "partial_recursive?") (("" (skeep) (("" (expand "length" 1 3) (("" (expand "nth") (("" (lift-if) (("" (prop) (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm") (("1" (expand "subterm") (("1" (prop) (("1" (decompose-equality) (("1" (grind) nil nil)) nil) ("2" (typepred "expr_comp(1 + length[mf_PVS0Expr[nat]](f), l)") (("2" (assert) (("2" (typepred "expr_comp(1 + length[mf_PVS0Expr[nat]](f), l)") (("2" (typepred "expr_comp(1 + length[mf_PVS0Expr[nat]](f), l)") (("2" (expand "subterm") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "rec_indices_expr_comp_is_limited") (("3" (inst?) (("3" (rewrite "chain_offset_length") (("3" (rewrite "chain_offset_length") (("3" (expand "chain_of_appends" 1) (("3" (rewrite "length_append") (("3" (expand "valid_index_rec") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "rec_indices_chain_offset_is_limited") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (comp subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].rec(1, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].cnst(list_props[(mf_pvs0_computable[mf_pvs0_basic_programs.false_val, mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2].limited)].length(mf_pvs0_Turing_Completeness.l)), mf_pvs0_Turing_Completeness.expr_comp((number_fields.+)(1, list_props[mf_PVS0Expr[nat]].length(mf_pvs0_Turing_Completeness.f)), mf_pvs0_Turing_Completeness.l))), mf_pvs0_Turing_Completeness.chain_offset(1, list_adt[(mf_pvs0_computable[mf_pvs0_basic_programs.false_val, mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2].limited)].cons(mf_pvs0_Turing_Completeness.f, mf_pvs0_Turing_Completeness.l))))" "partial_recursive[false_val, lop1, lop2]")) (comp_TCC1-1 nil 3768906966 ("" (skeep) (("" (prop) (("1" (typepred "cons[mf_PVS0Expr[number]]
               (rec[number]
                    (1,
                     op2[nat]
                         (1, cnst[nat](length[(limited)](l)),
                          expr_comp(1 + length[mf_PVS0Expr[nat]](f), l))),
                chain_offset(1, cons[(limited)](f, l)))") (("1" (typepred "chain_offset(1, cons[(limited)](f, l))") (("1" (expand "every" 1 1) (("1" (assert) (("1" (typepred "expr_comp(1 + length[mf_PVS0Expr[nat]](f), l)") (("1" (expand "every" 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (length def-decl "nat" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (rec_indices_chain_offset_is_limited formula-decl nil mf_pvs0_Turing_Completeness nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (map adt-def-decl "list[T1]" list_adt_map nil) (append def-decl "list[T]" list_props nil) (chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (limited const-decl "bool" mf_pvs0_computable nil) (expr_comp def-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (length_append formula-decl nil list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (chain_of_appends def-decl "list[T]" chain_of_appends nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (chain_offset_length formula-decl nil mf_pvs0_Turing_Completeness nil) (rec_indices_expr_comp_is_limited formula-decl nil mf_pvs0_Turing_Completeness nil) (nth def-decl "T" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (comp subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].rec(1, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].cnst(list_props[(mf_pvs0_computable[mf_pvs0_basic_programs.false_val, mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2].limited)].length(mf_pvs0_Turing_Completeness.l)), mf_pvs0_Turing_Completeness.expr_comp((number_fields.+)(1, list_props[mf_PVS0Expr[nat]].length(mf_pvs0_Turing_Completeness.f)), mf_pvs0_Turing_Completeness.l))), mf_pvs0_Turing_Completeness.chain_offset(1, list_adt[(mf_pvs0_computable[mf_pvs0_basic_programs.false_val, mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2].limited)].cons(mf_pvs0_Turing_Completeness.f, mf_pvs0_Turing_Completeness.l))))" "partial_recursive[false_val, lop1, lop2]"))) (list2nat_TCC1 0 (list2nat_TCC1-1 nil 3771257008 ("" (grind) nil nil) ((list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)) nil (list2nat subtype "list_adt[nat].cdr(mf_pvs0_Turing_Completeness.l)" "(list_adt[nat].cons?)"))) (list2nat_TCC2 0 (list2nat_TCC2-1 nil 3771257008 ("" (termination-tcc) nil nil) nil nil (list2nat termination "mf_pvs0_Turing_Completeness.list2nat(list_adt[nat].cdr(mf_pvs0_Turing_Completeness.l))" "nil"))) (offset_rec_chain_offset 0 (offset_rec_chain_offset-1 nil 3772551257 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (expand "chain_offset" 1) (("" (lift-if) (("" (prop) (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") nil nil)) nil) ("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "m" "length(car(x!1))+n") (("2" (prop) (("1" (rewrite "map_append") (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (map_append formula-decl nil map_append nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (offset_composition2 formula-decl nil mf_pvs0_lang nil) (chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (well_founded? const-decl "bool" orders nil)) shostak)) (offset_rec_expr_comp 0 (offset_rec_expr_comp-1 nil 3773068625 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (expand "expr_comp" 1) (("" (lift-if) (("" (prop) (("1" (grind) nil nil) ("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "length(car(x!1))+m" "n") (("2" (prop) (("1" (expand "offset_rec" 2) (("1" (replace -1) (("1" (expand "offset_rec" 2) (("1" (expand "offset_rec" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (expr_comp def-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (well_founded? const-decl "bool" orders nil)) shostak)) (limits_of_chain_offset_TCC1 0 (limits_of_chain_offset_TCC1-1 nil 3772466897 ("" (subtype-tcc) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil) ((subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (l1!1 skolem-const-decl "(limited[false_val, lop1, lop2])" mf_pvs0_Turing_Completeness nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (limited const-decl "bool" mf_pvs0_computable nil) (chain_of_appends def-decl "list[T]" chain_of_appends nil) (take def-decl "list[T]" more_list_props structures)) nil (limits_of_chain_offset subtype "list_props[mf_PVS0Expr[nat]].append(mf_pvs0_Turing_Completeness.l1, mf_pvs0_Turing_Completeness.chain_offset(list_props[mf_PVS0Expr[nat]].length(mf_pvs0_Turing_Completeness.l1), mf_pvs0_Turing_Completeness.l))" "lmf_PVS0Expr[nat]"))) (limits_of_chain_offset_TCC2 0 (limits_of_chain_offset_TCC2-1 nil 3772546375 ("" (subtype-tcc) nil nil) nil nil (limits_of_chain_offset subtype "(number_fields.-)((number_fields.-)(mf_pvs0_Turing_Completeness.k, list_props[mf_PVS0Expr[nat]].length(mf_pvs0_Turing_Completeness.l1)), list_props[mf_PVS0Expr[nat]].length(chain_of_appends[mf_PVS0Expr[nat]].chain_of_appends(more_list_props[list[mf_PVS0Expr[nat]]].take(mf_pvs0_Turing_Completeness.l, mf_pvs0_Turing_Completeness.i))))" "below[length[mf_PVS0Expr[nat]](nth[(limited)](l, i))]"))) (limits_of_chain_offset 0 (limits_of_chain_offset-1 nil 3772466910 ("" (measure-induct+ "length(l)" "l") (("1" (skeep) (("1" (expand "chain_offset" 1) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (typepred "i") (("1" (case "i=0") (("1" (typepred "k") (("1" (replaces -3) (("1" (expand "take" -1) (("1" (assert) (("1" (rewrite subtype_length) (("1" (expand "chain_of_appends" -1) (("1" (expand "length" -1 2) (("1" (expand "take" -2) (("1" (expand "chain_of_appends" -2) (("1" (expand "length" -2 3) (("1" (expand "semantic_rel_expr" 1 1) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (assert) (("1" (rewrite "subtype_length") (("1" (expand "nth" -2) (("1" (assert) (("1" (rewrite "nth_append") (("1" (prop) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(car(x!1), k-length(l1))" "car(x!1)" "l1" "lop1" "lop2" "valarg" "output") (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (expand "nth" 1 (1 3)) (("1" (assert) (("1" (expand "take" 1) (("1" (expand "chain_of_appends" 1) (("1" (expand "length" 1 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "input") (("2" (expand "semantic_rel_expr" 1 1) (("2" (rewrite "map_nth_rw") (("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(car(x!1), k-length(l1))" "car(x!1)" "l1" "lop1" "lop2" "input" "output") (("2" (assert) (("2" (expand "nth" -1 (1 3)) (("2" (expand "take" -1) (("2" (expand "chain_of_appends" -1) (("2" (expand "length" -1 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -1 "cdr(x!1)") (("2" (expand "nth" 2 (1 3)) (("2" (assert) (("2" (typepred "i") (("2" (lift-if) (("2" (split) (("1" (typepred "k") (("1" (flatten) (("1" (replace -3) (("1" (expand "take" -1) (("1" (assert) (("1" (rewrite "subtype_length") (("1" (expand "take" -2) (("1" (expand "chain_of_appends") (("1" (expand "length" -2 3) (("1" (expand "length" -1 2) (("1" (expand "semantic_rel_expr" 1 1) (("1" (rewrite "length_append") (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "chain_offset_length") (("1" (expand "nth" -2) (("1" (assert) (("1" (prop) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (replaces -1) (("1" (rewrite "nth_append") (("1" (rewrite "nth_append") (("1" (rewrite "map_length") (("1" (assert) (("1" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(car(x!1), k - length(l1))" "append(car(x!1),
                                      chain_offset
                                      (length(car(x!1)),
                                       cdr(x!1)))" "l1" "lop1" "lop2" "input" "output") (("1" (rewrite "map_append") (("1" (rewrite "offset_rec_chain_offset") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(car(x!1), k - length(l1))" "car(x!1)" "chain_offset(length(car(x!1)), cdr(x!1))" "lop1" "lop2" "input" "output") (("1" (assert) (("1" (expand "take" 1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "chain_offset" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (expand "take" 1) (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -7) (("3" (typepred "car(x!1)") (("3" (expand "limited" -3) (("3" (prop) (("3" (inst -3 "k - length[mf_PVS0Expr[nat]](l1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "input") (("2" (expand "semantic_rel_expr" 1 1) (("2" (rewrite "nth_append") (("1" (rewrite "nth_append") (("1" (rewrite "map_length") (("1" (assert) (("1" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(car(x!1),k-length(l1))" "append(car(x!1),
                                      chain_offset
                                      (length(car(x!1)),
                                       cdr(x!1)))" "l1" "lop1" "lop2" "input" "output") (("1" (assert) (("1" (rewrite "map_append") (("1" (rewrite "offset_rec_chain_offset") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(car(x!1), k - length(l1))" "car(x!1)" "chain_offset(length(car(x!1)), cdr(x!1))" "lop1" "lop2" "input" "output") (("1" (assert) (("1" (expand "take" -1) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "chain_offset" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (expand "take") (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "car(x!1)") (("3" (expand "limited" -3) (("3" (prop) (("3" (inst -3 "k - length[mf_PVS0Expr[nat]](l1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -2 "append(l1,map
                                      (offset_rec(length(l1)))(car(x!1)))" "i-1" "input" "output" "k") (("1" (rewrite "append_assoc") (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (assert) (("1" (expand "take" 2) (("1" (assert) (("1" (case "length(x!1) < i") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "subtype_length[list_adt
                                         [mf_PVS0Expr_adt
                                          [naturalnumbers.nat].mf_PVS0Expr].list, (limited)]") (("2" (inst?) (("2" (expand "chain_of_appends" 3) (("2" (rewrite "length_append") (("2" (assert) (("2" (assert) (("2" (replace 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "k") (("2" (hide 3) (("2" (prop) (("1" (rewrite "length_append") (("1" (expand "take" -1) (("1" (lemma "subtype_length[list_adt
                                         [mf_PVS0Expr_adt
                                          [naturalnumbers.nat].mf_PVS0Expr].list, (limited)]") (("1" (inst?) (("1" (assert) (("1" (expand "chain_of_appends" -2) (("1" (rewrite "length_append") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_length") (("1" (expand "chain_of_appends" -3) (("1" (rewrite "length_append") nil nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (expand "chain_of_appends" -2) (("2" (rewrite "length_append") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "take" -2) (("2" (expand "nth" -2) (("2" (assert) (("2" (lemma "subtype_length[list_adt
                                         [mf_PVS0Expr_adt
                                          [naturalnumbers.nat].mf_PVS0Expr].list, (limited)]") (("2" (inst?) (("2" (assert) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (assert) (("2" (expand "chain_of_appends" -2) (("2" (rewrite "length_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (hide 3) (("4" (prop) (("1" (grind) nil nil) ("2" (expand "limited") (("2" (skeep) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (typepred "l1") (("1" (expand "limited" -3) (("1" (inst -3 "i!1") (("1" (rewrite "length_append") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (typepred "car(x!1)") (("2" (expand "limited") (("2" (rewrite "map_length") (("2" (inst -3 "i!1-length(l1)") (("1" (rewrite "map_nth_rw") (("1" (lemma "valid_index_rec_offset") (("1" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "i!1") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (typepred "i!1") (("2" (rewrite "length_append") (("2" (rewrite "map_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ((x!1 skolem-const-decl "(cons?[(limited)])" mf_pvs0_Turing_Completeness nil) (offset_rec_chain_offset formula-decl nil mf_pvs0_Turing_Completeness nil) (add_rec_list2 formula-decl nil mf_pvs0_lang nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (k skolem-const-decl "{k: nat |
   k >= length(chain_of_appends(take(x!1, i))) + length(l1) AND
    k <
     length(chain_of_appends(take(x!1, i))) + length(nth(x!1, i)) +
      length(l1)}" mf_pvs0_Turing_Completeness nil) (l1 skolem-const-decl "(limited)" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "below[length(x!1)]" mf_pvs0_Turing_Completeness nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (map_append formula-decl nil map_append nil) (chain_offset_length formula-decl nil mf_pvs0_Turing_Completeness nil) (i!1 skolem-const-decl "below[length(append[mf_PVS0Expr[nat]]
                 (l1,
                  map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                      (offset_rec[nat](length[mf_PVS0Expr[nat]](l1)))
                      (car[(limited)](x!1))))]" mf_pvs0_Turing_Completeness nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (nth_append formula-decl nil more_list_props structures) (add_rec_list formula-decl nil mf_pvs0_lang nil) (subtype_length formula-decl nil subtype_length nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (chain_of_appends def-decl "list[T]" chain_of_appends nil) (take def-decl "list[T]" more_list_props structures) (chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (well_founded? const-decl "bool" orders nil)) shostak)) (chain_offset_prop_TCC1 0 (chain_offset_prop_TCC1-1 nil 3771944398 ("" (subtype-tcc) nil nil) nil nil (chain_offset_prop subtype "mf_pvs0_Turing_Completeness.i" "below[length[(limited[false_val, lop1, lop2])](l)]"))) (chain_offset_prop 0 (chain_offset_prop-1 nil 3771944442 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (expand "chain_offset" 1) (("" (expand "expr_comp" 1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (prop) (("1" (inst 1 "(: output :)") (("1" (skeep) (("1" (typepred "i") (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "list2nat" 1) (("1" (expand "length" 1) (("1" (expand "length" 1) (("1" (expand "semantic_rel" 1) (("1" (expand "semantic_rel" -2) (("1" (expand "nth" -2) (("1" (expand "semantic_rel_expr" -2) (("1" (skeep) (("1" (expand "semantic_rel_expr" -2) (("1" (replaces -2) (("1" (expand "length" -2 2) (("1" (rewrite "map_length") (("1" (rewrite "length_append") (("1" (assert) (("1" (expand "nth" -2) (("1" (rewrite "map_length") (("1" (prop) (("1" (rewrite "map_append") (("1" (rewrite "nth_append") (("1" (rewrite "map_length") (("1" (assert) (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(car(x!1),0)" "car(x!1)" "cons(rec(1 + length(l1), vr),map(offset_rec(1))(l1))" "lop1" "lop2" "input" "output") (("1" (expand "append" -1 1) (("1" (expand "length" 1 2) (("1" (rewrite "map_length") (("1" (expand "length" 1 3) (("1" (rewrite "map_length") (("1" (rewrite "map_nth_rw") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "interm") (("2" (inst -4 "0") (("1" (prop) (("1" (case "interm = (: output :)") (("1" (replaces -1) (("1" (expand "nth" -4 2) (("1" (expand "semantic_rel" 1) (("1" (expand "nth" 1) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "input") (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "length" 1 2) (("1" (rewrite "map_length") (("1" (prop) (("1" (expand "nth" 1) (("1" (rewrite "map_append") (("1" (rewrite "nth_append") (("1" (rewrite "map_length") (("1" (assert) (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (rewrite "map_nth_rw") (("1" (expand "semantic_rel" -5) (("1" (expand "nth" -5 3) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(car(x!1),0)" "nth(x!1,0)" "cons(rec(1 + length(l1), vr),map(offset_rec(1))(l1))" "lop1" "lop2" "input" "output") (("1" (assert) (("1" (expand "append" -1 1) (("1" (expand "length" -1 2) (("1" (rewrite "map_length") (("1" (expand "length" -1 3) (("1" (rewrite "map_length") (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -5 -6 1)) (("2" (grind) (("2" (grind) (("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -1 "cdr(x!1)") (("2" (prop) (("1" (expand "semantic_rel" -1) (("1" (expand "nth" -1) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "eval_op2") (("1" (expand "lop2" -3 1) (("1" (expand "length" -3) (("1" (expand "length" -3) (("1" (assert) (("1" (expand "lop2" -3) (("1" (expand "nth" -3) (("1" (expand "nth" -3) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "rec(length(l1),vr)" "append(l1,
                                        append
                                        (map
                                         (offset_rec(length(l1)))
                                         (car(x!1)),
                                         chain_offset
                                         (length(car(x!1)) + length(l1),
                                          cdr(x!1))))" "(: op2(1, rec(1 + length(l1), vr),
                                 expr_comp(1 + length(car(x!1))
                                           +
                                           length(l1),
                                           cdr(x!1))) :)" "lop1" "lop2" "input" "valarg1") (("1" (expand "append" -1 3) (("1" (expand "append" -1 3) (("1" (expand "length" -1 8) (("1" (expand "length" -1 8) (("1" (expand "length" -1 11) (("1" (expand "length" -1 11) (("1" (expand "offset_rec" -1 4) (("1" (expand "offset_rec" -1 4) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "expr_comp(length(car(x!1)) + length(l1),
                                  cdr(x!1))" "append(l1,
                                        append
                                        (map
                                         (offset_rec(length(l1)))
                                         (car(x!1)),
                                         chain_offset
                                         (length(car(x!1)) + length(l1),
                                          cdr(x!1))))" "(: op2(1, rec(1 + length(l1), vr),
                                 expr_comp(1 + length(car(x!1))
                                           +
                                           length(l1),
                                           cdr(x!1))) :)" "lop1" "lop2" "input" "valarg2") (("1" (expand "append" -1 3) (("1" (expand "append" -1 3) (("1" (expand "length" -1 9) (("1" (expand "length" -1 9) (("1" (expand "length" -1 12) (("1" (expand "length" -1 12) (("1" (rewrite "offset_rec_expr_comp") (("1" (assert) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "expr_comp(length(car(x!1)) + length(l1), cdr(x!1))" "append(l1,
                               append(map
                                      (offset_rec(length(l1)))(car(x!1)),
                                      chain_offset
                                      (length(car(x!1)) + length(l1),
                                       cdr(x!1))))" "(: expr_comp(1 + length(car(x!1))
                                           +
                                           length(l1),
                                           cdr(x!1)) :)" "lop1" "lop2" "input" "valarg2") (("1" (expand "append" -1 3) (("1" (expand "append" -1 1) (("1" (expand "length" -1 3) (("1" (expand "length" -1 3) (("1" (expand "length" -1 6) (("1" (expand "length" -1 6) (("1" (rewrite "offset_rec_expr_comp") (("1" (inst -7 "append(l1,map
                                         (offset_rec(length(l1)))
                                         (car(x!1)))" "input" "valarg2") (("1" (split) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "append_assoc") (("1" (expand "semantic_rel" -1 1) (("1" (expand "nth" -1 1) (("1" (assert) (("1" (skeep) (("1" (inst 1 "cons(valarg1,interm)") (("1" (skeep) (("1" (prop) (("1" (expand "nth" 1) (("1" (lift-if) (("1" (prop) (("1" (lemma "limits_of_chain_offset") (("1" (inst -1 "l1" "x!1" "0" "input" "valarg1" "length(l1)") (("1" (expand "chain_offset" -1 1) (("1" (expand "take" -1) (("1" (assert) (("1" (expand "chain_of_appends" -1) (("1" (expand "length" -1) (("1" (expand "nth" -1 (1 3)) (("1" (expand "semantic_rel" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "interm") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (prop) (("1" (grind) nil nil) ("2" (hide-all-but (1 3)) (("2" (typepred "l1") (("2" (typepred "car(x!1)") (("2" (hide-all-but (-3 -6 1 2)) (("2" (expand "limited") (("2" (skeep) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (inst -3 "i") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst -4 "i_1" "expr") (("1" (rewrite "length_append") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_nth_rw") (("1" (inst -1 "i-length(l1)") (("1" (lemma "valid_index_rec_offset") (("1" (inst -1 "nth(car(x!1), i - length(l1))" "length(car(x!1))" "length(l1)") (("1" (assert) (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst -1 "i_1" "expr") (("1" (assert) (("1" (rewrite "length_append") (("1" (rewrite "map_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel" 1) (("2" (expand "nth" 1) (("2" (expand "semantic_rel_expr" 1) (("2" (skeep) (("2" (expand "eval_op2") (("2" (expand "lop2" 1 3) (("2" (expand "length" 1 16) (("2" (expand "length" 1 16) (("2" (assert) (("2" (expand "lop2" 1 3) (("2" (expand "nth" 1 1) (("2" (expand "nth" 1 1) (("2" (inst 1 "car(interm)" "list2nat(cdr(interm))") (("1" (prop) (("1" (lemma "limits_of_chain_offset") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "rec(length(l1),vr)" "append(l1,
                                        append
                                        (map
                                         (offset_rec(length(l1)))
                                         (car(x!1)),
                                         chain_offset
                                         (length(car(x!1)) + length(l1),
                                          cdr(x!1))))" "(: op2(1, rec(1 + length(l1), vr),
                                 expr_comp(1 + length(car(x!1))
                                           +
                                           length(l1),
                                           cdr(x!1))) :) " "lop1" "lop2" "input" "car(interm)") (("1" (expand "append" -1 3) (("1" (expand "append" -1 3) (("1" (expand "length" -1 8) (("1" (expand "length" -1 8) (("1" (expand "length" -1 11) (("1" (expand "length" -1 11) (("1" (expand "offset_rec" -1 4) (("1" (expand "offset_rec" -1 4) (("1" (assert) (("1" (inst -1 "l1" "x!1" "0" "input" "car(interm)" "length(l1)") (("1" (expand "chain_offset" -1) (("1" (expand "take" 2) (("1" (assert) (("1" (typepred "x!1") (("1" (assert) (("1" (expand "chain_of_appends" 2) (("1" (expand "length" 2) (("1" (inst -3 "0") (("1" (hide-all-but (-3 2)) (("1" (prop) (("1" (expand "semantic_rel") (("1" (expand "nth" -1 4) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2)) (("2" (typepred "interm") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "take" 1) (("2" (split) (("1" (assert) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "length" 2 (3 7)) (("2" (typepred "car(x!1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "expr_comp(length(car(x!1)) + length(l1),
                                  cdr(x!1))" "append(l1,
                                        append
                                        (map
                                         (offset_rec(length(l1)))
                                         (car(x!1)),
                                         chain_offset
                                         (length(car(x!1)) + length(l1),
                                          cdr(x!1))))" "(: op2(1, rec(1 + length(l1), vr),
                                 expr_comp(1 + length(car(x!1))
                                           +
                                           length(l1),
                                           cdr(x!1))) :)" "lop1" "lop2" "input" "list2nat(cdr(interm))") (("1" (expand "append" -1 3) (("1" (expand "append" -1 3) (("1" (expand "length" -1 9) (("1" (expand "length" -1 9) (("1" (expand "length" -1 12) (("1" (expand "length" -1 12) (("1" (rewrite "offset_rec_expr_comp") (("1" (assert) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "expr_comp(length(car(x!1)) + length(l1),
                                  cdr(x!1))" "append(l1,
                                        append
                                        (map
                                         (offset_rec(length(l1)))
                                         (car(x!1)),
                                         chain_offset
                                         (length(car(x!1)) + length(l1),
                                          cdr(x!1))))" "(: 
                                 expr_comp(1 + length(car(x!1))
                                           +
                                           length(l1),
                                           cdr(x!1)) :)" "lop1" "lop2" "input" "list2nat(cdr(interm))") (("1" (expand "append" -1 3) (("1" (expand "append" 1 1) (("1" (expand "length" 1 3) (("1" (expand "length" 1 3) (("1" (expand "length" 1 6) (("1" (expand "length" 1 6) (("1" (rewrite "offset_rec_expr_comp") (("1" (inst -2 "append(l1,map
                                         (offset_rec(length(l1)))
                                         (car(x!1)))" "input" "list2nat(cdr(interm))") (("1" (rewrite "append_assoc") (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (split) (("1" (expand "semantic_rel" -1 1) (("1" (expand "nth" -1 1) (("1" (assert) (("1" (inst 1 "cdr(interm)") (("1" (skeep) (("1" (inst -1 "i+1") (("1" (expand "nth" -1) (("1" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "interm") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 5)) (("2" (prop) (("1" (grind) nil nil) ("2" (typepred "l1") (("2" (typepred "car(x!1)") (("2" (expand "limited") (("2" (skeep) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (inst -7 "i") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst? -8) (("1" (assert) (("1" (rewrite "length_append") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_nth_rw") (("1" (rewrite "length_append") (("1" (inst -3 "i-length(l1)") (("1" (rewrite "map_length") (("1" (rewrite "valid_index_rec_offset" :dir rl) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("3" (inst -1 "0") (("1" (prop) (("1" (expand "list2nat" -2) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "interm") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "interm") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (map_append formula-decl nil map_append nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (offset_composition2 formula-decl nil mf_pvs0_lang nil) (nth_append formula-decl nil more_list_props structures) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (length_singleton formula-decl nil more_list_props structures) (x!1 skolem-const-decl "(cons?[(limited)])" mf_pvs0_Turing_Completeness nil) (list_cons_extensionality formula-decl nil list_adt nil) (interm skolem-const-decl "{interm: (cons?[nat]) | length(interm) = length(x!1)}" mf_pvs0_Turing_Completeness nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (interm skolem-const-decl "{interm: (cons?[nat]) | length(interm) = length(x!1)}" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "below[length(append[mf_PVS0Expr[nat]]
                 (l1,
                  map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                      (offset_rec[nat](length[mf_PVS0Expr[nat]](l1)))
                      (car[(limited)](x!1))))]" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "below[length(cdr(interm))]" mf_pvs0_Turing_Completeness nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (offset_rec_expr_comp formula-decl nil mf_pvs0_Turing_Completeness nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (i skolem-const-decl "below[length(append[mf_PVS0Expr[nat]]
                 (l1,
                  map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                      (offset_rec[nat](length[mf_PVS0Expr[nat]](l1)))
                      (car[(limited)](x!1))))]" mf_pvs0_Turing_Completeness nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (valarg1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (interm skolem-const-decl "{interm: (cons?[nat]) | length(interm) = length(cdr(x!1))}" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "below[length(cons(valarg1, interm))]" mf_pvs0_Turing_Completeness nil) (limits_of_chain_offset formula-decl nil mf_pvs0_Turing_Completeness nil) (take def-decl "list[T]" more_list_props structures) (chain_of_appends def-decl "list[T]" chain_of_appends nil) (tuple2nat const-decl "nat" tuple2nat numbers) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (l1 skolem-const-decl "(limited)" mf_pvs0_Turing_Completeness nil) (list2nat def-decl "nat" mf_pvs0_Turing_Completeness nil) (chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (expr_comp def-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (well_founded? const-decl "bool" orders nil)) shostak)) (comp_is_composition_TCC1 0 (comp_is_composition_TCC1-1 nil 3771257008 ("" (subtype-tcc) nil nil) ((pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (tuple2nat const-decl "nat" tuple2nat numbers) (semantic_rel const-decl "bool" mf_pvs0_lang nil)) nil (comp_is_composition subtype "mf_pvs0_Turing_Completeness.i" "below[length[nat](interm)]"))) (comp_is_composition 0 (comp_is_composition-1 nil 3771851634 ("" (skeep) (("" (prop) (("1" (expand "comp") (("1" (expand "chain_offset" -1) (("1" (lift-if) (("1" (prop) (("1" (typepred "l") (("1" (grind) nil nil)) nil) ("2" (expand "semantic_rel" -1) (("2" (expand "nth" -1) (("2" (expand "semantic_rel_expr" -1) (("2" (expand "length" -1 4) (("2" (case "1 < 1 + (length(f) + length(chain_offset(1 + length(f), l)))") (("1" (assert) (("1" (skeep) (("1" (expand "nth" -3) (("1" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(f,0)" "append(f,
                                                  chain_offset(length(f), l))" "(: rec(1,
                                               op2(1, cnst(length(l)), expr_comp(1+length(f), l))) :)" "lop1" "lop2" "valarg" "output") (("1" (expand "append" -1 2) (("1" (expand "append" -1 2) (("1" (expand "length" -1 4) (("1" (expand "length" -1 4) (("1" (expand "length" -1 5) (("1" (expand "length" -1 5) (("1" (rewrite "map_append") (("1" (rewrite "offset_rec_chain_offset") (("1" (assert) (("1" (expand "semantic_rel_expr" -6) (("1" (skeep) (("1" (expand "eval_op2" -8) (("1" (expand "lop2" -8) (("1" (expand "length" -8) (("1" (expand "length" -8) (("1" (assert) (("1" (expand "nth" -8) (("1" (expand "nth" -8) (("1" (expand "semantic_rel_expr" -6) (("1" (replaces -6) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "expr_comp(length(f),l)" "append(f,
                                                    chain_offset(length(f), l))" "(: rec(1,
                                                 op2(1, cnst(length(l)), expr_comp(1+length(f), l))) :)" "lop1" "lop2" "input" "valarg2") (("1" (expand "append" -1 2) (("1" (expand "append" -1 2) (("1" (expand "length" -1 5) (("1" (expand "length" -1 5) (("1" (expand "length" -1 6) (("1" (expand "length" -1 6) (("1" (rewrite "map_append") (("1" (rewrite "offset_rec_expr_comp") (("1" (rewrite "offset_rec_chain_offset") (("1" (assert) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "expr_comp(length(f), l)" " append(f, chain_offset(length(f), l))" "(: expr_comp(1+length(f), l) :)" "lop1" "lop2" "input" "valarg2") (("1" (expand "append" -1 2) (("1" (expand "append" -1 1) (("1" (expand "length" -1 2) (("1" (expand "length" -1 2) (("1" (expand "length" -1 3) (("1" (expand "length" -1 3) (("1" (rewrite "offset_rec_expr_comp") (("1" (lemma "chain_offset_prop") (("1" (inst -1 "f" "l" "input" "valarg2") (("1" (expand "semantic_rel" -1 1) (("1" (expand "nth" -1 1) (("1" (assert) (("1" (skeep) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(f,0)" "f" "chain_offset(length(f), l)" "lop1" "lop2" "valarg" "output") (("1" (assert) (("1" (inst 2 "interm") (("1" (prop) (("1" (inst -2 "0") (("1" (prop) (("1" (assert) (("1" (expand "semantic_rel" 1) (("1" (assert) (("1" (typepred "interm") (("1" (replace -3) (("1" (expand "length" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst -2 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-7 1 2)) (("2" (expand "length" -1 1) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (typepred "l") (("2" (expand "chain_offset" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "f") (("3" (expand "limited") (("3" (assert) (("3" (prop) (("3" (inst -3 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel" 1) (("2" (expand "comp" 1) (("2" (expand "nth" 1) (("2" (expand "semantic_rel_expr" 1) (("2" (expand "length" 1 5) (("2" (case "1 < 1 + length(chain_offset(1, cons(f, l)))") (("1" (assert) (("1" (expand "nth" 1) (("1" (expand "chain_offset" 1 (2 3)) (("1" (case "length(cons(f, l)) = 1") (("1" (grind) nil nil) ("2" (assert) (("2" (rewrite "nth_append") (("1" (case " 0 < length(map(offset_rec(1))(f))") (("1" (assert) (("1" (rewrite "map_nth_rw") (("1" (skeep) (("1" (inst 2 "tuple2nat(length(interm), list2nat(interm))") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "length(l)" "list2nat(interm)") (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "eval_op2" 1) (("1" (prop) (("1" (expand "chain_offset" 1) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "expr_comp( length(f), l)" "append(f,
                                    chain_offset(length(f), l))" "(: rec(1,
                                 op2(1,
                                     cnst(length(l)),
                                     expr_comp(1 + length(f), l))) :)" "lop1" "lop2" "input" "list2nat(interm)") (("1" (expand "append" -1 2) (("1" (expand "append" -1 2) (("1" (expand "length" -1 5) (("1" (expand "length" -1 5) (("1" (expand "length" -1 6) (("1" (expand "length" -1 6) (("1" (rewrite "map_append") (("1" (rewrite "offset_rec_chain_offset") (("1" (rewrite "offset_rec_expr_comp") (("1" (assert) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "expr_comp( length(f), l)" "append(f,
                                    chain_offset(length(f), l))" "(: 
                                     expr_comp(1 + length(f), l) :)" "lop1" "lop2" "input" "list2nat(interm)") (("1" (expand "append" -1 2) (("1" (expand "append" 1 1) (("1" (expand "length" 1 2) (("1" (expand "length" 1 2) (("1" (expand "length" 1 3) (("1" (expand "length" 1 3) (("1" (rewrite "offset_rec_expr_comp") (("1" (lemma "chain_offset_prop") (("1" (inst -1 "f" "l" "input" "list2nat(interm)") (("1" (expand "semantic_rel" -1 1) (("1" (expand "nth" -1 1) (("1" (assert) (("1" (inst 1 "interm") (("1" (assert) (("1" (skeep) (("1" (inst -4 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "lop2" 1) (("2" (expand "length" 1 2) (("2" (expand "length" 1 2) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (typepred "interm") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(f,0)" "append(f,chain_offset(length(f),l))" "(: rec(1,
                                 op2(1,
                                     cnst(length(l)),
                                     expr_comp(1 + length(f), l))) :)" "lop1" "lop2" "tuple2nat(length(interm), list2nat(interm))" "output") (("1" (expand "append" -1 2) (("1" (expand "append" -1 2) (("1" (expand "length" -1 5) (("1" (expand "length" -1 5) (("1" (expand "length" -1 6) (("1" (expand "length" -1 6) (("1" (rewrite "map_append") (("1" (rewrite "offset_rec_chain_offset") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(f,0)" "f" "chain_offset(length(f), l)" "lop1" "lop2" "tuple2nat(length(interm), list2nat(interm))" "output") (("1" (assert) (("1" (expand "semantic_rel" -3) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "l") (("2" (expand "chain_offset" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "f") (("3" (expand "limited") (("3" (prop) (("3" (inst -3 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (limited const-decl "bool" mf_pvs0_computable nil) (tuple2nat const-decl "nat" tuple2nat numbers) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (f skolem-const-decl "(limited)" mf_pvs0_Turing_Completeness nil) (l skolem-const-decl "(cons?[(limited)])" mf_pvs0_Turing_Completeness nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (expr_comp def-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (offset_rec_chain_offset formula-decl nil mf_pvs0_Turing_Completeness nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (offset_rec_expr_comp formula-decl nil mf_pvs0_Turing_Completeness nil) (chain_offset_prop formula-decl nil mf_pvs0_Turing_Completeness nil) (add_rec_list2 formula-decl nil mf_pvs0_lang nil) (interm skolem-const-decl "{interm: (cons?[nat]) | length(interm) = length(l)}" mf_pvs0_Turing_Completeness nil) (map_append formula-decl nil map_append nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (nth_append formula-decl nil more_list_props structures) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (comp const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (list2nat def-decl "nat" mf_pvs0_Turing_Completeness nil)) shostak)) (min_relation_works 0 (min_relation_works-1 nil 3774364520 ("" (skeep*) (("" (lemma "min_relation_induction") (("" (inst -1 "y" "f" "ans" "lambda(x : nat) : (semantic_rel(lop1, lop2, false_val, f)(tuple2nat(ans, y), 0) AND x <= ans AND
          (FORALL (i: nat | i >= x AND i < ans):
             EXISTS (k: posint):
               semantic_rel(lop1, lop2, false_val, f)(tuple2nat(i, y), k) AND k /= 0)) ") (("" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst?) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) (("3" (inst? -1) (("3" (assert) (("3" (prop) (("3" (inst? -2) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep 2) (("4" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skeep) (("3" (typepred "i") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skeep) (("3" (typepred "i") (("3" (assert) nil nil)) nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (assert) (("5" (skeep) (("5" (case "i=x_1") (("1" (replaces -1) (("1" (skeep -1) (("1" (inst 1 "k_1") (("1" (case "k_1=0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (inst? -7) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep 2) (("6" (prop) (("1" (assert) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (case "i=x_1") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("4" (assert) nil nil) ("5" (skeep) (("5" (case "i=x_1") (("1" (replaces -1) (("1" (skeep -1) (("1" (inst 1 "k_1") (("1" (case "k_1=0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (inst -7 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((min_relation_induction formula-decl nil mf_pvs0_Turing_Completeness nil) (k_1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (k_1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (x_1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (ans skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "{i: nat | i >= x_1 AND i < ans}" mf_pvs0_Turing_Completeness nil) (tuple2nat const-decl "nat" tuple2nat numbers) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil)) shostak)) (min_relation_leq 0 (min_relation_leq-1 nil 3774793758 ("" (lemma "min_relation_induction") (("" (skeep) (("" (inst -1 "y" "f" "ans" "lambda(n : nat):  n <= ans") (("" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (min_relation_induction formula-decl nil mf_pvs0_Turing_Completeness nil)) shostak)) (min_aux_TCC1 0 (min_aux_TCC1-2 "" 3885312754 ("" (skeep*) (("" (expand "partial_recursive?") (("" (skeep*) (("" (expand "length") (("" (rewrite "map_length") (("" (expand "nth") (("" (lift-if) (("" (prop) (("1" (grind) (("1" (decompose-equality) nil nil) ("2" (decompose-equality) nil nil)) nil) ("2" (rewrite "map_nth_rw") (("1" (typepred "f") (("1" (expand "limited") (("1" (inst -3 "i-1") (("1" (use "valid_index_rec_offset") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "length" -1) (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (min_aux subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].ite(mf_PVS0Expr_adt[nat].rec(1, mf_PVS0Expr_adt[nat].vr), mf_PVS0Expr_adt[nat].rec(0, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].op1(0, mf_PVS0Expr_adt[nat].op1(1, mf_PVS0Expr_adt[nat].vr)), mf_PVS0Expr_adt[nat].op1(2, mf_PVS0Expr_adt[nat].vr))), mf_PVS0Expr_adt[nat].op1(1, mf_PVS0Expr_adt[nat].vr)), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_Turing_Completeness.f)))" "partial_recursive[false_val, lop1, lop2]")) (min_aux_TCC1-1 nil 3771594815 ("" (skeep) (("" (prop) (("1" (typepred "map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                    (offset_rec[nat](1))(f)") (("1" (expand "every" 1 1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (lemma "valid_index_rec_offset") (("2" (typepred "f") (("2" (expand "limited") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((partial_recursive? const-decl "bool" mf_pvs0_computable nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (f skolem-const-decl "(limited[false_val, lop1, lop2])" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "below[length(cons[mf_PVS0Expr[nat]]
                 (ite[nat]
                      (rec[nat](1, vr[nat]),
                       rec[nat]
                           (0,
                            op2[nat]
                                (1, op1[nat](0, op1[nat](1, vr[nat])),
                                 op1[nat](2, vr[nat]))),
                       op1[nat](1, vr[nat])),
                  map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                      (offset_rec[nat](1))(f)))]" mf_pvs0_Turing_Completeness nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (below type-eq-decl nil nat_types nil) (map adt-def-decl "list[T1]" list_adt_map nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (map_nth_rw formula-decl nil more_map_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map_length formula-decl nil more_map_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (min_aux subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].ite(mf_PVS0Expr_adt[nat].rec(1, mf_PVS0Expr_adt[nat].vr), mf_PVS0Expr_adt[nat].rec(0, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].op1(0, mf_PVS0Expr_adt[nat].op1(1, mf_PVS0Expr_adt[nat].vr)), mf_PVS0Expr_adt[nat].op1(2, mf_PVS0Expr_adt[nat].vr))), mf_PVS0Expr_adt[nat].op1(1, mf_PVS0Expr_adt[nat].vr)), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_Turing_Completeness.f)))" "partial_recursive[false_val, lop1, lop2]"))) (min_aux_leq_eval_expr_TCC1 0 (min_aux_leq_eval_expr_TCC1-1 nil 3775310495 ("" (grind) nil nil) ((mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (limited const-decl "bool" mf_pvs0_computable nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (min_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil)) nil (min_aux_leq_eval_expr subtype "0" "below[length[mf_PVS0Expr[nat]](min_aux(f)`4)]"))) (min_aux_leq_eval_expr 0 (min_aux_leq_eval_expr-1 nil 3775310495 ("" (measure-induct+ " n " ("n")) (("1" (skeep) (("1" (expand "min_aux" -2) (("1" (expand "nth" -2) (("1" (expand "eval_expr" -2) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (expand "eval_expr" -1) (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (expand "eval_expr" -2 2) (("1" (lift-if) (("1" (prop) (("1" (expand "eval_expr" -3 2) (("1" (lift-if) (("1" (prop) (("1" (expand "eval_expr" -2 2) (("1" (lift-if) (("1" (prop) (("1" (expand "eval_expr" -2 2) (("1" (expand "eval_expr" -2 2) (("1" (expand "eval_expr" -2 2) (("1" (expand "eval_expr" -2 2) (("1" (expand "eval_op1") (("1" (expand "lop1" -2 (3 4)) (("1" (expand "length" -2 (1 2)) (("1" (expand "length" -2 (1 2)) (("1" (assert) (("1" (expand "lop1" -2 5) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (assert) (("1" (expand "lop1" -2 (3 4 5)) (("1" (expand "nth" -2 (2 3 4)) (("1" (expand "nth" -2 (2 3)) (("1" (expand "nth" -2 (2)) (("1" (expand "pi1") (("1" (expand "pi2") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (expand "succ") (("1" (expand "eval_op2") (("1" (expand "lop2" -2 2) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (assert) (("1" (expand "lop2" -2 2) (("1" (expand "nth" -2 2) (("1" (expand "nth" -2 2) (("1" (inst -9 "x!1-1") (("1" (inst -9 "x+1" "y" "f" "ans") (("1" (assert) (("1" (expand "min_aux" 3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_expr" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_expr" 1) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (expand "eval_expr") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_expr" 1) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (expand "eval_expr" 1) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (expand "eval_expr" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_expr" 1) (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (expand "eval_expr" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (expand "eval_expr" -2) (("3" (lift-if) (("3" (prop) (("1" (expand "eval_expr" -2) (("1" (expand "eval_op1") (("1" (expand "lop1" -2) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (assert) (("1" (expand "nth" -2) (("1" (expand "nth" -2) (("1" (expand "pi1") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (decompose-equality -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_expr" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ((val adt-accessor-decl "[(some?) -> T]" Maybe structures) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (succ const-decl "nat" mf_pvs0_basic_programs nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (length_singleton formula-decl nil more_list_props structures) (eval_op1 const-decl "Val" mf_pvs0_expr nil) (eval_expr_semantic_rel_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}" mf_pvs0_computable nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_computable nil) (Some adt-constructor-decl "[T -> (some?)]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (tuple2nat const-decl "nat" tuple2nat numbers) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (Maybe type-decl nil Maybe structures) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (limited const-decl "bool" mf_pvs0_computable nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (min_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (well_founded? const-decl "bool" orders nil)) shostak)) (min_aux_leq 0 (min_aux_leq-1 nil 3774794347 ("" (skeep) (("" (lemma "semantic_rel_eval") (("" (inst?) (("" (assert) (("" (lemma "min_aux_leq_eval_expr") (("" (skeep) (("" (inst?) (("" (inst -1 "y" "f" "n") (("" (assert) (("" (replace -2) (("" (expand "eval" 1) (("" (assert) (("" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((semantic_rel_eval formula-decl nil mf_pvs0_lang nil) (Maybe_Some_extensionality formula-decl nil Maybe structures) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (Some adt-constructor-decl "[T -> (some?)]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (eval const-decl "Maybe[Val]" mf_pvs0_lang nil) (eval_expr_semantic_rel_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}" mf_pvs0_computable nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_computable nil) (min_aux_leq_eval_expr formula-decl nil mf_pvs0_Turing_Completeness nil) (min_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (tuple2nat const-decl "nat" tuple2nat numbers)) shostak)) (min_relation_works2 0 (min_relation_works2-1 nil 3775487172 ("" (measure-induct+ "if ans >= x then ans-x else 0 endif" ("ans" "x")) (("1" (skeep) (("1" (expand "min_relation" 1) (("1" (prop) (("1" (inst -5 "x!2") (("1" (skeep) (("1" (lemma "deterministic") (("1" (inst?) (("1" (inst -1 "k") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (inst -2 "x!1" "1+x!2") (("2" (assert) (("2" (inst -2 "y" "f") (("2" (assert) (("2" (skeep) (("2" (inst -4 "i") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -4 "x!2") (("1" (skeep) (("1" (inst 1 "k") nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ((deterministic formula-decl nil mf_pvs0_lang nil) (x!1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (x!2 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (min_relation inductive-decl "bool" mf_pvs0_Turing_Completeness nil) (tuple2nat const-decl "nat" tuple2nat numbers) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (well_founded? const-decl "bool" orders nil)) shostak)) (min_aux_is_min_relation 0 (min_aux_is_min_relation-1 nil 3774634211 ("" (measure-induct+ "if ans >= x then ans - x else 0 endif" ("x" "ans")) (("1" (skeep) (("1" (prop) (("1" (lemma "min_relation_leq") (("1" (inst?) (("1" (assert) (("1" (assert) (("1" (expand "min_relation" -2) (("1" (prop) (("1" (expand "min_aux" 1) (("1" (expand "semantic_rel" 1) (("1" (expand "nth" 1) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "0") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "nth" 1) (("2" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(f,0)" "f" "(: ite(rec(1, vr),
                                 rec(0,
                                     op2
                                     (1, op1(0, op1(1, vr)), op1(2, vr))),
                                 op1(1, vr)) :)" "lop1" "lop2" "tuple2nat(x!1, y)" "0") (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (expand "semantic_rel" -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "false_val") (("2" (propax) nil nil)) nil) ("3" (expand "semantic_rel_expr" 1) (("3" (inst 1 "tuple2nat(x!1, y)") (("3" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "1+x!1" "x!2") (("2" (lemma "min_relation_leq") (("2" (inst -1 "1+x!1" "y" "f" "x!2") (("2" (assert) (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (expand "semantic_rel" 2) (("2" (expand "min_aux" 2) (("2" (expand "nth" 2) (("2" (expand "semantic_rel_expr" 2) (("2" (skeep) (("2" (inst 2 "k") (("2" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil) ("2" (expand "nth") (("2" (rewrite "map_nth_rw") (("1" (expand "semantic_rel" -3) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(f,0)" "f" "(: ite(rec(1, vr),
                                 rec(0,
                                     op2
                                     (1, op1(0, op1(1, vr)), op1(2, vr))),
                                 op1(1, vr)) :)" "lop1" "lop2" "tuple2nat(x!1, y)" "k") (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr" 2) (("2" (inst 2 "tuple2nat(x!1+1, y)") (("2" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "1+x!1" "y") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "x!1") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "succ") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(x!1, y)") (("2" (expand "semantic_rel_expr" 1) (("2" (expand "eval_op1") (("2" (expand "lop1" 1) (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2" 1) (("3" (expand "length" 1) (("3" (expand "length" 1) (("3" (assert) (("3" (expand "nth" 1) (("3" (expand "nth" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel") (("2" (expand "min_aux" -6) (("2" (assert) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("3" (expand "false_val" -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "min_aux_leq") (("2" (inst?) (("2" (assert) (("2" (assert) (("2" (expand "min_aux" -2) (("2" (expand "semantic_rel" -2) (("2" (expand "nth" -2) (("2" (expand "semantic_rel_expr" -2) (("2" (skeep) (("2" (expand "semantic_rel_expr" -2) (("2" (skeep) (("2" (expand "semantic_rel_expr" -2) (("2" (replaces -2) (("2" (prop) (("1" (expand "nth" -3) (("1" (rewrite "map_nth_rw") (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (replaces -1) (("1" (expand "eval_op1") (("1" (expand "lop1" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (expand "nth" -1 1) (("1" (expand "nth" -1 1) (("1" (expand "pi1") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -1) (("1" (expand "lop1" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (assert) (("1" (expand "nth" -1) (("1" (expand "succ") (("1" (replaces -1) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (replaces -1) (("1" (expand "eval_op1") (("1" (expand "lop1" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (expand "nth" -1) (("1" (expand "nth" -1) (("1" (expand "nth" -1) (("1" (expand "pi2") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -1) (("1" (expand "eval_op2") (("1" (expand "lop2" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (expand "nth" -1) (("1" (expand "nth" -1) (("1" (replaces -1) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(f,0)" "f" "(: ite(rec(1, vr),
                                 rec(0,
                                     op2
                                     (1, op1(0, op1(1, vr)), op1(2, vr))),
                                 op1(1, vr)) :)" "lop1" "lop2" "tuple2nat(x!1,y)" "valarg") (("1" (expand "append" -1 1) (("1" (expand "append" -1 1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (expand "min_relation" 2) (("1" (expand "semantic_rel" 2) (("1" (assert) (("1" (expand "false_val" 1) (("1" (assert) (("1" (prop) (("1" (use "deterministic_expr") (("1" (assert) nil nil)) nil) ("2" (lemma "min_aux_leq") (("2" (inst -1 "1+x!1" "y" "f" "x!2") (("2" (expand "min_aux" -1) (("2" (expand "semantic_rel" -1) (("2" (inst -8 "1+x!1" "x!2") (("2" (assert) (("2" (inst -8 "y" "f") (("2" (assert) (("2" (expand "min_aux" 4) (("2" (expand "semantic_rel" 4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst 1 "valarg") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (expand "nth" -4) (("2" (lemma "add_rec_list") (("2" (rewrite "map_nth_rw") (("1" (inst -1 "false_val" "nth(f,0)" "f" "(: ite(rec(1, vr),
                                 rec(0,
                                     op2
                                     (1, op1(0, op1(1, vr)), op1(2, vr))),
                                 op1(1, vr)) :)" "lop1" "lop2" "tuple2nat(x!1,y)" "valarg") (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (expand "semantic_rel_expr" -3) (("1" (skeep) (("1" (expand "semantic_rel_expr" -3) (("1" (replaces -3) (("1" (expand "eval_op1") (("1" (expand "lop1" -3) (("1" (expand "length" -3) (("1" (expand "length" -3) (("1" (assert) (("1" (expand "nth" -3) (("1" (expand "nth" -3) (("1" (expand "pi1") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (expand "min_relation" 1) (("1" (expand "false_val" -2) (("1" (replaces -2 :dir rl) (("1" (expand "semantic_rel" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ((min_aux_leq formula-decl nil mf_pvs0_Turing_Completeness nil) (deterministic_expr formula-decl nil mf_pvs0_expr nil) (min_relation_leq formula-decl nil mf_pvs0_Turing_Completeness nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (succ const-decl "nat" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (length_singleton formula-decl nil more_list_props structures) (eval_op1 const-decl "Val" mf_pvs0_expr nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (tuple2nat const-decl "nat" tuple2nat numbers) (min_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (min_relation inductive-decl "bool" mf_pvs0_Turing_Completeness nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (well_founded? const-decl "bool" orders nil)) shostak)) (min_aux_correctness 0 (min_aux_correctness-1 nil 3775573925 ("" (skeep) (("" (split) (("1" (flatten) (("1" (rewrite "min_aux_is_min_relation" :dir rl) (("1" (rewrite "min_relation_works") nil nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "min_aux_is_min_relation" :dir rl) (("2" (rewrite "min_relation_works2") (("2" (skeep) (("2" (inst? -3) (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((min_aux_is_min_relation formula-decl nil mf_pvs0_Turing_Completeness nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (limited const-decl "bool" mf_pvs0_computable nil) (min_relation_works formula-decl nil mf_pvs0_Turing_Completeness nil) (min_relation_works2 formula-decl nil mf_pvs0_Turing_Completeness nil)) shostak)) (min_TCC1 0 (min_TCC1-2 "" 3885313138 ("" (skeep) (("" (expand "partial_recursive?") (("" (skeep) (("" (expand "length") (("" (rewrite "map_length") (("" (expand "nth") (("" (lift-if) (("" (prop) (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (decompose-equality) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "min_aux(f)") (("2" (expand "partial_recursive?") (("2" (prop) (("2" (rewrite "map_nth_rw") (("1" (rewrite "valid_index_rec_offset" :dir rl) (("1" (assert) (("1" (typepred "i") (("1" (expand "length" -1) (("1" (rewrite "map_length") (("1" (assert) (("1" (inst -5 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (min subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].rec(1, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].cnst(0), mf_PVS0Expr_adt[nat].vr)), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_Turing_Completeness.min_aux(mf_pvs0_Turing_Completeness.f)`4)))" "partial_recursive[false_val, lop1, lop2]")) (min_TCC1-1 nil 3768906966 ("" (skeep) (("" (typepred "f") (("" (prop) (("1" (typepred "map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                    (offset_rec[nat](1))(min_aux(f)`4)") (("1" (expand "every" 1 1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((partial_recursive? const-decl "bool" mf_pvs0_computable nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (map adt-def-decl "list[T1]" list_adt_map nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (map_nth_rw formula-decl nil more_map_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (below type-eq-decl nil nat_types nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (min_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map_length formula-decl nil more_map_props nil)) nil (min subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].rec(1, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].cnst(0), mf_PVS0Expr_adt[nat].vr)), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_Turing_Completeness.min_aux(mf_pvs0_Turing_Completeness.f)`4)))" "partial_recursive[false_val, lop1, lop2]"))) (min_correctness 0 (min_correctness-1 nil 3775575565 ("" (skeep) (("" (lemma "min_aux_correctness") (("" (inst -1 "0" "y" "f" "ans") (("" (replaces -1 :dir rl) (("" (split) (("1" (flatten) (("1" (assert) (("1" (replace 1) (("1" (hide 1) (("1" (expand "min" -1) (("1" (expand "semantic_rel" -1) (("1" (expand "nth") (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (prop) (("1" (expand "semantic_rel_expr" -3) (("1" (skeep) (("1" (expand "semantic_rel_expr" -3) (("1" (replaces -3) (("1" (expand "semantic_rel_expr" -3) (("1" (replaces -3) (("1" (expand "eval_op2") (("1" (expand "lop2" -3) (("1" (expand "length" -3) (("1" (expand "length" -3) (("1" (assert) (("1" (expand "nth" -3) (("1" (expand "nth" -3) (("1" (replaces -3) (("1" (expand "nth") (("1" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(min_aux(f)`4,0)" "min_aux(f)`4" "(: rec(1, op2(1, cnst(0), vr)) :)" "lop1" "lop2" "tuple2nat(0,y)" "ans") (("1" (expand "append") (("1" (expand "append") (("1" (expand "length") (("1" (expand "length") (("1" (assert) (("1" (expand "semantic_rel") (("1" (case "(lop1, lop2, false_val, min_aux(f)`4) = min_aux(f)") (("1" (assert) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -2) (("2" (hide -1 -2) (("2" (expand "min") (("2" (expand "semantic_rel" 1) (("2" (expand "nth") (("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(0,y)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "0" "y") (("1" (expand "semantic_rel_expr") (("1" (expand "eval_op2") (("1" (expand "lop2") (("1" (expand "length" 1) (("1" (expand "length" 1) (("1" (assert) (("1" (expand "nth") (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(min_aux(f)`4,0)" "min_aux(f)`4" "(: rec(1, op2(1, cnst(0), vr)) :)" "lop1" "lop2" "tuple2nat(0,y)" "ans") (("1" (expand "append") (("1" (expand "append") (("1" (expand "length") (("1" (expand "length") (("1" (assert) (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (hide-all-but (1 -2)) (("1" (expand "semantic_rel") (("1" (case "(lop1, lop2, false_val, min_aux(f)`4) = min_aux(f)") (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (hide -1 2) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((min_aux_correctness formula-decl nil mf_pvs0_Turing_Completeness nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (min_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (tuple2nat const-decl "nat" tuple2nat numbers) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (min const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (f skolem-const-decl "(limited)" mf_pvs0_Turing_Completeness nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil)) shostak)) (prim_recurrence_relation_TCC1 0 (prim_recurrence_relation_TCC1-1 nil 3777215445 ("" (subtype-tcc) nil nil) ((mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (limited const-decl "bool" mf_pvs0_computable nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil)) nil (prim_recurrence_relation subtype "(number_fields.-)(mf_pvs0_Turing_Completeness.x, 1)" "nat"))) (prim_recurrence_TCC1 0 (prim_recurrence_TCC1-1 nil 3768906966 ("" (skeep) (("" (expand "partial_recursive?") (("" (skeep*) (("" (expand "nth" 1) (("" (lift-if) (("" (prop) (("1" (grind) (("1" (decompose-equality -4) nil nil) ("2" (decompose-equality -4) nil nil) ("3" (decompose-equality -4) (("3" (rewrite "length_append") (("3" (rewrite "length_append") (("3" (rewrite "map_length") (("3" (rewrite "map_length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (decompose-equality -4) (("4" (rewrite "length_append") (("4" (rewrite "length_append") (("4" (rewrite "map_length") (("4" (rewrite "map_length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (expand "length" 1 1) (("1" (rewrite "length_append") (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (typepred "recur") (("1" (expand "limited" -3) (("1" (rewrite "map_nth_rw") (("1" (inst -3 "i-1") (("1" (lemma "valid_index_rec_offset") (("1" (inst -1 "nth(recur, i - 1)" "length(recur)" "1") (("1" (assert) (("1" (hide-all-but (-1 1 2)) (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (expand "length" 1 3) (("1" (rewrite "length_append") (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (typepred "final") (("1" (expand "limited" -3) (("1" (inst -3 "-1 - length(recur) + i") (("1" (lemma "valid_index_rec_offset") (("1" (inst -1 "nth(final, -1 - length(recur) + i)" "length(final)" "1 + length[mf_PVS0Expr[nat]](recur)") (("1" (assert) (("1" (hide-all-but (-1 1 2 3)) (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") nil nil)) nil) ("2" (rewrite "map_length") (("2" (expand "length" 2 5) (("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (typepred "sub1") (("2" (expand "partial_recursive?") (("2" (prop) (("2" (rewrite "map_nth_rw") (("1" (inst -4 "-1 - length(final) - length(recur) + i") (("1" (lemma "valid_index_rec_offset") (("1" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1 1) (("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "length" -1 1) (("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (typepred "i") (("2" (expand "length" -1 1) (("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (typepred "i") (("2" (expand "length" -1 1) (("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((partial_recursive? const-decl "bool" mf_pvs0_computable nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (limited const-decl "bool" mf_pvs0_computable nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (sub1 const-decl "partial_recursive" mf_pvs0_basic_programs nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (sub const-decl "partial_recursive" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (i skolem-const-decl "below[length(cons[mf_PVS0Expr[nat]]
                 (ite[nat]
                      (x,
                       recur_function(recursive_call(minus1(x), y),
                                      minus1(x),
                                      y),
                       final_function(y)),
                  append[mf_PVS0Expr[nat]]
                      (map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                           (offset_rec[nat](1))(recur),
                       append[mf_PVS0Expr[nat]]
                           (map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                                (offset_rec[nat]
                                     (1 + length[mf_PVS0Expr[nat]](recur)))
                                (final),
                            map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                                (offset_rec[nat]
                                     (1 + length[mf_PVS0Expr[nat]](final)
                                      +
                                      length[mf_PVS0Expr[nat]](recur)))
                                (sub1`4)))))]" mf_pvs0_Turing_Completeness nil) (final skolem-const-decl "(limited[false_val, lop1, lop2])" mf_pvs0_Turing_Completeness nil) (recur skolem-const-decl "(limited[false_val, lop1, lop2])" mf_pvs0_Turing_Completeness nil) (final_function skolem-const-decl "[mf_PVS0Expr[nat] -> (rec?)]" mf_pvs0_Turing_Completeness nil) (y skolem-const-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (minus1 skolem-const-decl "[mf_PVS0Expr[nat] -> (rec?)]" mf_pvs0_Turing_Completeness nil) (recursive_call skolem-const-decl "[[mf_PVS0Expr[nat], mf_PVS0Expr[nat]] -> (rec?)]" mf_pvs0_Turing_Completeness nil) (recur_function skolem-const-decl "[[mf_PVS0Expr[nat], mf_PVS0Expr[nat], mf_PVS0Expr[nat]] -> (rec?)]" mf_pvs0_Turing_Completeness nil) (x skolem-const-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (nth_append formula-decl nil more_list_props structures)) nil (prim_recurrence subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].ite(mf_pvs0_Turing_Completeness.x, mf_pvs0_Turing_Completeness.recur_function(mf_pvs0_Turing_Completeness.recursive_call(mf_pvs0_Turing_Completeness.minus1(mf_pvs0_Turing_Completeness.x), mf_pvs0_Turing_Completeness.y), mf_pvs0_Turing_Completeness.minus1(mf_pvs0_Turing_Completeness.x), mf_pvs0_Turing_Completeness.y), mf_pvs0_Turing_Completeness.final_function(mf_pvs0_Turing_Completeness.y)), list_props[mf_PVS0Expr[nat]].append(list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_Turing_Completeness.recur), list_props[mf_PVS0Expr[nat]].append(list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec((number_fields.+)(1, list_props[mf_PVS0Expr[nat]].length(mf_pvs0_Turing_Completeness.recur))))(mf_pvs0_Turing_Completeness.final), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec((number_fields.+)((number_fields.+)(1, list_props[mf_PVS0Expr[nat]].length(mf_pvs0_Turing_Completeness.recur)), list_props[mf_PVS0Expr[nat]].length(mf_pvs0_Turing_Completeness.final))))(mf_pvs0_basic_programs.sub1`4)))))" "partial_recursive[false_val, lop1, lop2]"))) (prim_recurrence_is_prim_recurrence_relation 0 (prim_recurrence_is_prim_recurrence_relation-1 nil 3776697612 ("" (measure-induct+ "x" "x") (("" (skeep) (("" (prop) (("1" (expand "prim_recurrence_relation" 1) (("1" (prop) (("1" (expand "semantic_rel" -1) (("1" (expand "prim_recurrence" -1 2) (("1" (expand "nth") (("1" (expand "semantic_rel_expr") (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep -1) (("1" (expand "semantic_rel_expr" -1) (("1" (replaces -1) (("1" (expand "eval_op1") (("1" (expand "prim_recurrence" -1) (("1" (expand "lop1" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "pi1") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -1) (("1" (expand "prim_recurrence" -1 1) (("1" (expand "false_val" -1) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (replaces -1) (("1" (expand "eval_op1" -1) (("1" (expand "prim_recurrence" -1) (("1" (expand "lop1" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (expand "nth" -1) (("1" (expand "nth" -1) (("1" (expand "pi1") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -1) (("1" (expand "prim_recurrence" -1 1) (("1" (expand "length" -1 3) (("1" (rewrite "length_append") (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (expand "prim_recurrence" -2 2) (("1" (expand "nth" -2) (("1" (rewrite "nth_append") (("1" (rewrite "map_length") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "nth_append") (("1" (rewrite "map_length") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "add_rec_list") (("2" (expand "prim_recurrence" -2) (("2" (inst -1 "false_val" "nth(sub1`4,0)" "sub1`4" "cons(ite(op1[nat](1, vr),
                                                 rec[nat]
                                                     (1,
                                                      op2[nat]
                                                      (1,
                                                       rec[nat]
                                                       (0,
                                                        op2[nat]
                                                        (1,
                                                         rec
                                                         (1 + length(final)
                                                          +
                                                          length(recur),
                                                          op1[nat](1, vr)),
                                                         op1[nat](2, vr))),
                                                       op2[nat]
                                                       (1,
                                                        rec
                                                        (1 + length(final) + length(recur),
                                                         op1[nat](1, vr)),
                                                        op1[nat](2, vr)))),
                                                 rec[nat]
                                                     (1 + length(recur), op1[nat](2, vr))),append(map(offset_rec(1))(recur),
                                                    map
                                                     (offset_rec(1 + length(recur)))
                                                     (final) ))" "lop1" "lop2" "x!1" "valarg1!1") (("2" (expand "append" -1 1) (("2" (expand "length" -1 7) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (expand "length" -1 9) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_nth_rw") (("2" (rewrite "append_assoc") (("2" (assert) (("2" (hide -2) (("2" (lemma "sub1_works") (("2" (inst -1 "x!1") (("2" (expand "semantic_rel" -1) (("2" (lemma "deterministic_expr") (("2" (inst -1 "sub1" "x!1" "nth(sub1`4,0)" "sub_function(x!1,1)" "valarg1!1") (("2" (case "(lop1, lop2, false_val, sub1`4) = sub1") (("1" (replaces -1) (("1" (assert) (("1" (hide -2 -3) (("1" (replaces -1 :dir rl) (("1" (expand "semantic_rel_expr" -2) (("1" (skeep) (("1" (expand "semantic_rel_expr" -2) (("1" (replaces -2) (("1" (expand "eval_op1" -2) (("1" (expand "prim_recurrence" -2) (("1" (expand "lop1" -2) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (assert) (("1" (expand "nth" -2) (("1" (expand "nth" -2) (("1" (expand "nth" -2) (("1" (expand "pi2") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -2) (("1" (expand "sub_function") (("1" (assert) (("1" (case "IF x!1 > 1 THEN x!1 - 1 ELSE 0 ENDIF = IF x!1 > 0 THEN x!1 - 1 ELSE 0 ENDIF") (("1" (replaces -1) (("1" (assert) (("1" (expand "eval_op2" -2) (("1" (expand "prim_recurrence" -2) (("1" (expand "lop2" -2) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (assert) (("1" (expand "nth" -2) (("1" (expand "nth" -2) (("1" (replaces -2) (("1" (expand "prim_recurrence" -2 1) (("1" (expand "length" -2 1) (("1" (assert) (("1" (split) (("1" (flatten) (("1" (expand "semantic_rel_expr" -4) (("1" (skeep) (("1" (expand "prim_recurrence" -4) (("1" (expand "semantic_rel_expr" -4) (("1" (skeep) (("1" (split) (("1" (flatten) (("1" (expand "nth" -2) (("1" (rewrite "nth_append") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (hide-all-but -1) (("1" (rewrite "map_length") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "map_length") (("2" (assert) (("2" (rewrite "nth_append") (("1" (rewrite "map_length") (("1" (assert) (("1" (lemma "add_rec_list") (("1" (expand "semantic_rel_expr" -7) (("1" (skeep) (("1" (expand "semantic_rel_expr" -7) (("1" (hide -3) (("1" (replaces -6) (("1" (expand "eval_op1" -6) (("1" (expand "lop1" -6) (("1" (expand "length" -6) (("1" (expand "length" -6) (("1" (expand "nth" -6) (("1" (expand "nth" -6) (("1" (expand "pi1") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -6) (("1" (inst -1 "false_val" "nth(sub1`4,0)" "sub1`4" "cons(ite(op1[nat](1, vr),
                                                               rec[nat]
                                                                   (1,
                                                                    op2[nat]
                                                                    (1,
                                                                     rec[nat]
                                                                     (0,
                                                                      op2[nat]
                                                                      (1,
                                                                       rec
                                                                       (1 + length(final)
                                                                        +
                                                                        length(recur),
                                                                        op1[nat](1, vr)),
                                                                       op1[nat](2, vr))),
                                                                     op2[nat]
                                                                     (1,
                                                                      rec
                                                                      (1 + length(final) + length(recur),
                                                                       op1[nat](1, vr)),
                                                                      op1[nat](2, vr)))),
                                                               rec[nat]
                                                                   (1 + length(recur), op1[nat](2, vr))),append(map(offset_rec(1))(recur),
                                                                  map
                                                                   (offset_rec(1 + length(recur)))
                                                                   (final)))" "lop1" "lop2" "x!1" "valarg1!2") (("1" (expand "append" -1 1) (("1" (expand "length" -1 7) (("1" (expand "length" -1 9) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (rewrite "append_assoc") (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (lemma "sub1_works") (("1" (hide -3) (("1" (inst -1 "x!1") (("1" (case "(lop1, lop2, false_val, sub1`4) = sub1") (("1" (replaces -1) (("1" (expand "semantic_rel" -1) (("1" (lemma "deterministic_expr") (("1" (inst -1 "sub1" "x!1" "nth(sub1`4,0)" "valarg1!2" "sub_function(x!1, 1)") (("1" (assert) (("1" (replaces -1) (("1" (expand "sub_function" -7) (("1" (case "IF x!1 > 1 THEN x!1 - 1 ELSE 0 ENDIF = IF x!1 > 0 THEN x!1 - 1 ELSE 0 ENDIF") (("1" (replaces -1) (("1" (assert) (("1" (expand "semantic_rel_expr" -6) (("1" (skeep) (("1" (expand "semantic_rel_expr" -6) (("1" (replaces -6) (("1" (expand "eval_op1" -6) (("1" (expand "prim_recurrence" -6) (("1" (expand "lop1" -6) (("1" (expand "length" -6) (("1" (expand "length" -6) (("1" (expand "length" -6) (("1" (expand "nth" -6) (("1" (expand "nth" -6) (("1" (expand "nth" -6) (("1" (expand "pi2") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -6) (("1" (expand "eval_op2" -6) (("1" (expand "prim_recurrence" -6) (("1" (expand "lop2" -6) (("1" (expand "length" -6) (("1" (expand "length" -6) (("1" (expand "nth" -6) (("1" (expand "nth" -6) (("1" (replaces -6) (("1" (expand "eval_op2" -6) (("1" (expand "prim_recurrence" -6) (("1" (expand "lop2" -6) (("1" (expand "length" -6) (("1" (expand "length" -6) (("1" (expand "nth" -6) (("1" (expand "nth" -6) (("1" (prop) (("1" (expand "prim_recurrence" -2) (("1" (expand "nth" -2) (("1" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(recur,0)" " append(recur,
                                                                            append
                                                                            (map
                                                                             (offset_rec(length(recur)))
                                                                             (final),
                                                                             map
                                                                             (offset_rec
                                                                              (length(final) + length(recur)))
                                                                             (sub1`4)))" "(: ite(op1[nat](1, vr),
                                                                         rec[nat]
                                                                             (1,
                                                                              op2[nat]
                                                                              (1,
                                                                               rec[nat]
                                                                               (0,
                                                                                op2[nat]
                                                                                (1,
                                                                                 rec
                                                                                 (1 + length(final)
                                                                                  +
                                                                                  length(recur),
                                                                                  op1[nat](1, vr)),
                                                                                 op1[nat](2, vr))),
                                                                               op2[nat]
                                                                               (1,
                                                                                rec
                                                                                (1 + length(final) + length(recur),
                                                                                 op1[nat](1, vr)),
                                                                                op1[nat](2, vr)))),
                                                                         rec[nat]
                                                                             (1 + length(recur), op1[nat](2, vr))) :)" "lop1" "lop2" "valarg!1" "ans") (("1" (expand "append" -1 3) (("1" (expand "append" -1 3) (("1" (expand "length" -1 9) (("1" (expand "length" -1 9) (("1" (expand "length" -1 12) (("1" (expand "length" -1 12) (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (rewrite "map_append") (("1" (rewrite "map_append") (("1" (rewrite "map_list_composition") (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (rewrite "offset_composition2") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(recur,0)" "recur" "append(map
                                                                                (offset_rec(length(recur)))(final),
                                                                                map
                                                                                (offset_rec
                                                                                 (length(final) + length(recur)))
                                                                                (sub1`4))" "lop1" "lop2" "valarg!1" "ans") (("1" (assert) (("1" (inst -12 "x!1-1") (("1" (inst -12 "recur" "final" "y" "valarg1") (("1" (assert) (("1" (expand "semantic_rel" -12) (("1" (inst 5 "valarg1") (("1" (replaces -11) (("1" (expand "semantic_rel" 5) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (hide-all-but 1) (("3" (typepred "recur") (("3" (expand "limited" -3) (("3" (prop) (("3" (inst -3 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 5)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (flatten) (("2" (expand "length" 1 3) (("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length" 1) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (prop) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel" -2) (("2" (expand "prim_recurrence" -2 2) (("2" (expand "nth" -2) (("2" (expand "semantic_rel_expr" -2) (("2" (replaces -1) (("2" (skeep) (("2" (expand "semantic_rel_expr" -1) (("2" (skeep) (("2" (expand "semantic_rel_expr" -1) (("2" (replaces -1) (("2" (expand "eval_op1" -1) (("2" (expand "prim_recurrence" -1) (("2" (expand "lop1" -1) (("2" (expand "length" -1) (("2" (expand "length" -1) (("2" (assert) (("2" (expand "nth" -1) (("2" (expand "nth" -1) (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) (("2" (replaces -1) (("2" (expand "prim_recurrence" -1 1) (("2" (expand "false_val" -1 1) (("2" (expand "prim_recurrence" -1) (("2" (expand "semantic_rel_expr" -1) (("2" (skeep) (("2" (prop) (("1" (expand "nth" -2) (("1" (rewrite "nth_append") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (rewrite "map_length") (("1" (grind) nil nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (assert) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(final,0)" " append
                                                      (final,
                                                       map
                                                       (offset_rec
                                                        ( length(final) ))
                                                       (sub1`4))" "cons(ite(op1[nat](1, vr),
                                                   rec[nat]
                                                       (1,
                                                        op2[nat]
                                                        (1,
                                                         rec[nat]
                                                         (0,
                                                          op2[nat]
                                                          (1,
                                                           rec
                                                           (1 + length(final)
                                                            +
                                                            length(recur),
                                                            op1[nat](1, vr)),
                                                           op1[nat](2, vr))),
                                                         op2[nat]
                                                         (1,
                                                          rec
                                                          (1 + length(final) + length(recur),
                                                           op1[nat](1, vr)),
                                                          op1[nat](2, vr)))),
                                                   rec[nat]
                                                       (1 + length(recur), op1[nat](2, vr))),
                                               map(offset_rec(1))(recur))" "lop1" "lop2" "valarg!1" "ans") (("1" (expand "append" -1 2) (("1" (expand "length" -1 7) (("1" (expand "length" -1 9) (("1" (rewrite "map_length") (("1" (rewrite "map_append") (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(final,0)" "final" "map(offset_rec(length(final)))(sub1`4)" "lop1" "lop2" " valarg!1" "ans") (("1" (assert) (("1" (expand "semantic_rel_expr" -6) (("1" (skeep) (("1" (expand "semantic_rel_expr" -6) (("1" (replaces -6) (("1" (expand "eval_op1" -6) (("1" (expand "lop1" -6) (("1" (expand "length" -6) (("1" (expand "length" -6) (("1" (expand "length" -6) (("1" (assert) (("1" (expand "nth" -6) (("1" (expand "nth" -6) (("1" (expand "nth" -6) (("1" (expand "pi2") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -6) (("1" (expand "semantic_rel" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (hide-all-but 1) (("3" (typepred "final") (("3" (expand "limited") (("3" (prop) (("3" (inst -3 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length" 1 2) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "prim_recurrence_relation" -1) (("2" (prop) (("1" (skeep) (("1" (expand "semantic_rel") (("1" (expand "prim_recurrence" 2 2) (("1" (expand "nth" 2) (("1" (expand "semantic_rel_expr" 2) (("1" (inst 2 "x!1") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "prim_recurrence" 1) (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr" 2) (("2" (inst 2 "tuple2nat(z, tuple2nat(x!1 - 1, y))") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "z" "tuple2nat(x!1 - 1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "tuple2nat(x!1 - 1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "x!1-1" "y") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "x!1") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "prim_recurrence" 1) (("2" (expand "lop1") (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "prim_recurrence" 1 2) (("2" (expand "nth" 1) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (rewrite "map_length") (("2" (grind) nil nil)) nil) ("3" (rewrite "map_length") (("3" (assert) (("3" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_length") (("1" (grind) nil nil)) nil) ("2" (rewrite "map_length") (("2" (assert) (("2" (expand "prim_recurrence" 2) (("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(sub1`4,0)" "sub1`4" "cons(ite(op1[nat](1, vr),
                                                                   rec[nat]
                                                                       (1,
                                                                        op2[nat]
                                                                        (1,
                                                                         rec[nat]
                                                                         (0,
                                                                          op2[nat]
                                                                          (1,
                                                                           rec
                                                                           (1 + length(final)
                                                                            +
                                                                            length(recur),
                                                                            op1[nat](1, vr)),
                                                                           op1[nat](2, vr))),
                                                                         op2[nat]
                                                                         (1,
                                                                          rec
                                                                          (1 + length(final) + length(recur),
                                                                           op1[nat](1, vr)),
                                                                          op1[nat](2, vr)))),
                                                                   rec[nat]
                                                                       (1 + length(recur), op1[nat](2, vr))),
                                                               append(map(offset_rec(1))(recur),
                                                                      map
                                                                       (offset_rec(1 + length(recur)))
                                                                       (final)))" "lop1" "lop2" "x!1" "x!1-1") (("1" (expand "append" -1 1) (("1" (expand "length" -1 7) (("1" (expand "length" -1 9) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (rewrite "append_assoc") (("1" (assert) (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (lemma "sub1_works") (("1" (inst -1 "x!1") (("1" (expand "sub_function") (("1" (case "IF x!1 > 1 THEN x!1 - 1 ELSE 0 ENDIF = IF x!1 > 0 THEN x!1 - 1 ELSE 0 ENDIF") (("1" (replaces -1) (("1" (assert) (("1" (expand "semantic_rel") (("1" (case "(lop1, lop2, false_val, sub1`4) = sub1") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "prim_recurrence" 1) (("3" (expand "length" 1 3) (("3" (rewrite "length_append") (("3" (rewrite "length_append") (("3" (rewrite "map_length") (("3" (rewrite "map_length") (("3" (rewrite "map_length") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr" 1) (("2" (inst 1 "tuple2nat(x!1, y)") (("2" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "prim_recurrence" 1) (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "prim_recurrence" 1) (("3" (expand "lop2" 1) (("3" (expand "length" 1) (("3" (expand "length" 1) (("3" (assert) (("3" (expand "nth" 1) (("3" (expand "nth" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (inst -4 "x!1-1") (("1" (inst -4 "recur" "final" "y" "z") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("3" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (expand "semantic_rel_expr" 1) (("2" (inst 1 "x!1-1" "y") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "x!1") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "prim_recurrence" 1) (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "prim_recurrence" 1 2) (("2" (expand "nth" 1) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (rewrite "map_length") (("2" (grind) nil nil)) nil) ("3" (rewrite "map_length") (("3" (assert) (("3" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_length") (("1" (assert) nil nil)) nil) ("2" (rewrite "map_length") (("2" (assert) (("2" (expand "prim_recurrence" 2) (("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(sub1`4,0)" "sub1`4" "cons(ite(op1[nat](1, vr),
                                                               rec[nat]
                                                                   (1,
                                                                    op2[nat]
                                                                    (1,
                                                                     rec[nat]
                                                                     (0,
                                                                      op2[nat]
                                                                      (1,
                                                                       rec
                                                                       (1 + length(final)
                                                                        +
                                                                        length(recur),
                                                                        op1[nat](1, vr)),
                                                                       op1[nat](2, vr))),
                                                                     op2[nat]
                                                                     (1,
                                                                      rec
                                                                      (1 + length(final) + length(recur),
                                                                       op1[nat](1, vr)),
                                                                      op1[nat](2, vr)))),
                                                               rec[nat]
                                                                   (1 + length(recur), op1[nat](2, vr))),
                                                           append(map(offset_rec(1))(recur),
                                                                  map
                                                                   (offset_rec(1 + length(recur)))
                                                                   (final)))" "lop1" "lop2" "x!1" "x!1-1") (("1" (expand "append" -1 1) (("1" (expand "length" -1 7) (("1" (expand "length" -1 9) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (rewrite "append_assoc") (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (lemma "sub1_works") (("1" (inst -1 "x!1") (("1" (expand "sub_function") (("1" (case "IF x!1 > 1 THEN x!1 - 1 ELSE 0 ENDIF =IF x!1 > 0 THEN x!1 - 1 ELSE 0 ENDIF") (("1" (replaces -1) (("1" (assert) (("1" (expand "semantic_rel" -1) (("1" (case "(lop1, lop2, false_val, sub1`4) = sub1") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (hide-all-but 1) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "prim_recurrence") (("3" (expand "length" 1 3) (("3" (rewrite "length_append") (("3" (rewrite "length_append") (("3" (rewrite "map_length") (("3" (rewrite "map_length") (("3" (rewrite "map_length") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr" 1) (("2" (inst 1 "tuple2nat(x!1, y)") (("2" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "prim_recurrence" 1) (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "prim_recurrence" 1) (("3" (expand "lop2" 1) (("3" (expand "length" 1) (("3" (expand "length" 1) (("3" (assert) (("3" (expand "nth" 1) (("3" (expand "nth" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "prim_recurrence" 1) (("3" (expand "lop2" 1) (("3" (expand "length" 1) (("3" (expand "length" 1) (("3" (assert) (("3" (expand "nth" 1) (("3" (expand "nth" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (expand "prim_recurrence" 1 2) (("2" (expand "nth" 1) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (expand "prim_recurrence" 1) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(recur,0)" " append(recur,
                                                    append
                                                    (map
                                                     (offset_rec( length(recur)))
                                                     (final),
                                                     map
                                                     (offset_rec
                                                      (length(final) + length(recur)))
                                                     (sub1`4)))" "(: ite(op1[nat](1, vr),
                                                 rec[nat]
                                                     (1,
                                                      op2[nat]
                                                      (1,
                                                       rec[nat]
                                                       (0,
                                                        op2[nat]
                                                        (1,
                                                         rec
                                                         (1 + length(final)
                                                          +
                                                          length(recur),
                                                          op1[nat](1, vr)),
                                                         op1[nat](2, vr))),
                                                       op2[nat]
                                                       (1,
                                                        rec
                                                        (1 + length(final) + length(recur),
                                                         op1[nat](1, vr)),
                                                        op1[nat](2, vr)))),
                                                 rec[nat]
                                                     (1 + length(recur), op1[nat](2, vr))) :)" "lop1" "lop2" "tuple2nat(z, tuple2nat(x!1 - 1, y))" "ans") (("1" (expand "append" -1 3) (("1" (expand "append" -1 3) (("1" (expand "length" -1 9) (("1" (expand "length" -1 9) (("1" (expand "length" -1 12) (("1" (expand "length" -1 12) (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (rewrite "map_append") (("1" (rewrite "map_append") (("1" (rewrite "map_list_composition") (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (rewrite "offset_composition2") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(recur,0)" "recur" "append(map
                                                        (offset_rec(length(recur)))(final),
                                                        map
                                                        (offset_rec
                                                         (length(final) + length(recur)))
                                                        (sub1`4))" "lop1" "lop2" "tuple2nat(z, tuple2nat(x!1 - 1, y))" "ans") (("1" (assert) nil nil) ("2" (grind) nil nil) ("3" (hide-all-but 1) (("3" (typepred "recur") (("3" (expand "limited" -3) (("3" (prop) (("3" (inst -3 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (expand "prim_recurrence" -1) (("3" (expand "false_val" -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel" 1) (("2" (expand "prim_recurrence" 1 2) (("2" (expand "nth" 1) (("2" (expand "semantic_rel_expr") (("2" (inst 1 "x!1") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "prim_recurrence" 1) (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "prim_recurrence" 1) (("2" (expand "false_val" 1) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "semantic_rel_expr") (("3" (inst 1 "y") (("3" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "prim_recurrence" 1) (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "prim_recurrence" 1 2) (("2" (expand "nth" 1) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (rewrite "map_length") (("2" (grind) nil nil)) nil) ("3" (rewrite "map_length") (("3" (assert) (("3" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (expand "prim_recurrence" 1) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(final,0)" " append
                                                      (final,
                                                       map
                                                       (offset_rec
                                                        ( length(final) ))
                                                       (sub1`4))" "cons(ite(op1[nat](1, vr),
                                                   rec[nat]
                                                       (1,
                                                        op2[nat]
                                                        (1,
                                                         rec[nat]
                                                         (0,
                                                          op2[nat]
                                                          (1,
                                                           rec
                                                           (1 + length(final)
                                                            +
                                                            length(recur),
                                                            op1[nat](1, vr)),
                                                           op1[nat](2, vr))),
                                                         op2[nat]
                                                         (1,
                                                          rec
                                                          (1 + length(final) + length(recur),
                                                           op1[nat](1, vr)),
                                                          op1[nat](2, vr)))),
                                                   rec[nat]
                                                       (1 + length(recur), op1[nat](2, vr))),
                                               map(offset_rec(1))(recur))" "lop1" "lop2" "y" "ans") (("1" (expand "append" -1 2) (("1" (expand "length" -1 7) (("1" (expand "length" -1 9) (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (rewrite "map_nth_rw") (("1" (rewrite "map_append") (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(final,0)" "final" "map(offset_rec(length(final)))(sub1`4)" "lop1" "lop2" "y" "ans") (("1" (assert) (("1" (expand "semantic_rel" -5) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (hide-all-but 1) (("3" (typepred "final") (("3" (expand "limited") (("3" (prop) (("3" (inst -3 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "prim_recurrence" 1) (("3" (expand "length" 1 2) (("3" (rewrite "length_append") (("3" (rewrite "map_length") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((x!1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (length_singleton formula-decl nil more_list_props structures) (sub1 const-decl "partial_recursive" mf_pvs0_basic_programs nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (nth_append formula-decl nil more_list_props structures) (deterministic_expr formula-decl nil mf_pvs0_expr nil) (map_append formula-decl nil map_append nil) (offset_composition2 formula-decl nil mf_pvs0_lang nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (sub const-decl "partial_recursive" mf_pvs0_basic_programs nil) (add_rec_list2 formula-decl nil mf_pvs0_lang nil) (final skolem-const-decl "(limited)" mf_pvs0_Turing_Completeness nil) (recur skolem-const-decl "(limited)" mf_pvs0_Turing_Completeness nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (sub_function const-decl "nat" mf_pvs0_basic_programs nil) (sub1_works formula-decl nil mf_pvs0_basic_programs nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (eval_op1 const-decl "Val" mf_pvs0_expr nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (prim_recurrence_relation inductive-decl "bool" mf_pvs0_Turing_Completeness nil) (tuple2nat const-decl "nat" tuple2nat numbers) (prim_recurrence const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (well_founded? const-decl "bool" orders nil)) nil)) (prim_recurrence_relation_works_TCC1 0 (prim_recurrence_relation_works_TCC1-1 nil 3776610672 ("" (subtype-tcc) nil nil) nil nil (prim_recurrence_relation_works subtype "(number_fields.-)(list_props[nat].length(mf_pvs0_Turing_Completeness.l), 1)" "below[length[nat](l)]"))) (prim_recurrence_relation_works_TCC2 0 (prim_recurrence_relation_works_TCC2-1 nil 3776610672 ("" (subtype-tcc) nil nil) nil nil (prim_recurrence_relation_works subtype "0" "below[length[nat](l)]"))) (prim_recurrence_relation_works_TCC3 0 (prim_recurrence_relation_works_TCC3-1 nil 3776610672 ("" (subtype-tcc) nil nil) ((pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil)) nil (prim_recurrence_relation_works subtype "(number_fields.-)(list_props[nat].length(mf_pvs0_Turing_Completeness.l), 1)" "nat"))) (prim_recurrence_relation_works_TCC4 0 (prim_recurrence_relation_works_TCC4-1 nil 3776610672 ("" (subtype-tcc) nil nil) ((pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil)) nil (prim_recurrence_relation_works subtype "mf_pvs0_Turing_Completeness.i" "below[length[nat](l)]"))) (prim_recurrence_relation_works_TCC5 0 (prim_recurrence_relation_works_TCC5-1 nil 3776610672 ("" (subtype-tcc) nil nil) ((pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil)) nil (prim_recurrence_relation_works subtype "(number_fields.+)(mf_pvs0_Turing_Completeness.i, 1)" "below[length[nat](l)]"))) (prim_recurrence_relation_works 0 (prim_recurrence_relation_works-1 nil 3776610673 ("" (measure-induct+ "x" "x") (("" (skeep) (("" (expand "prim_recurrence_relation" 1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (prop) (("1" (skeep) (("1" (inst -3 "x!1-1") (("1" (assert) (("1" (inst -3 "recur" "final" "y" "z") (("1" (assert) (("1" (skeep) (("1" (inst 1 "append(l,(: ans :))") (("1" (prop) (("1" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (rewrite "length_append") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (assert) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil) ("3" (rewrite "length_append") (("3" (assert) nil nil)) nil)) nil) ("2" (rewrite "nth_append") nil nil) ("3" (skeep) (("3" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (inst -7 "i") (("1" (assert) nil nil)) nil) ("2" (case "i= length(l)-1") (("1" (replace -1) (("1" (assert) (("1" (expand "nth" 2 2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (typepred "l") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (inst -2 "x!1-1") (("1" (assert) (("1" (skeep) (("1" (typepred "l") (("1" (inst 1 "nth(l,length(l)-2)") (("1" (prop) (("1" (replace -2) (("1" (assert) (("1" (inst -5 "x!1-1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -6 "recur" "final" "y" "nth(l,length(l)-2)") (("2" (assert) (("2" (inst 3 "rdc(l)") (("1" (prop) (("1" (case "length(rdc(l)) = length(cdr(l))") (("1" (replace -1) (("1" (expand "rdc" 1) (("1" (lemma "reverse_def[nat]") (("1" (inst -1 "l" "1
") (("1" (assert) (("1" (replaces -1 :dir rl) (("1" (expand "nth" 1 1) (("1" (lemma "reverse_def[nat]") (("1" (inst -1 "cdr(reverse(l))" "length(cdr(reverse(l))) -1") (("1" (prop) (("1" (assert) (("1" (replaces -1 :dir rl) (("1" (case "length(cdr(reverse(l))) = length(cdr(l))") (("1" (assert) nil nil) ("2" (hide-all-but (-3 1 4)) (("2" (lemma "length_reverse[nat]") (("2" (inst -1 "l") (("2" (expand "length" -1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but (-3 1 4)) (("2" (lemma "length_reverse[nat]") (("2" (inst -1 "l") (("2" (expand "length" -1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 4)) (("2" (expand "rdc") (("2" (rewrite "length_reverse") (("2" (lemma "length_reverse[nat]") (("2" (inst -1 "l") (("2" (expand "length" -1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1 4)) (("3" (grind) nil nil)) nil)) nil) ("2" (case "nth(l, 0) = nth(rdc(l), 0)") (("1" (assert) nil nil) ("2" (hide-all-but (-2 1 4)) (("2" (lemma "rdc_rac[nat]") (("2" (inst -1 "l") (("2" (case "nth(l, 0) = nth(append(rdc(l), (: rac(l) :)), 0)") (("1" (replaces -1) (("1" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (hide -1 2) (("1" (grind) (("1" (rewrite "length_reverse") (("1" (lemma "length_reverse[nat]") (("1" (inst -1 "l") (("1" (expand "length" -1) (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (replace -1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (inst -5 "i") (("1" (typepred "i") (("1" (case "forall(i : below[length(rdc(l))]): nth(rdc(l),i) = nth(l,i)") (("1" (inst-cp -1 "i") (("1" (inst -1 "i+1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-3 1 4)) (("2" (skeep) (("2" (case "nth(append(rdc(l),(:rac(l):)),i!1) = nth(l,i!1)") (("1" (replaces -1 :dir rl) (("1" (rewrite "nth_append") nil nil)) nil) ("2" (rewrite "rdc_rac") nil nil) ("3" (typepred "i!1") (("3" (rewrite "length_append") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -3 4)) (("3" (skeep) (("3" (typepred "i!1") (("3" (expand "rdc" -1) (("3" (rewrite "length_reverse") (("3" (lemma "length_reverse[nat]") (("3" (inst -1 "l") (("3" (expand "length" -1) (("3" (lift-if) (("3" (prop) (("1" (grind) nil nil) ("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 4)) (("2" (typepred "i") (("2" (expand "rdc") (("2" (rewrite "length_reverse") (("2" (lemma "length_reverse[nat]") (("2" (inst -1 "l") (("2" (expand "length" -1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 3)) (("2" (expand "rdc" 1) (("2" (rewrite "length_reverse") (("2" (lemma "length_reverse[nat]") (("2" (inst -1 "l") (("2" (expand "length" -1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -3 2)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (prop) (("1" (inst 1 "(: ans :)") (("1" (prop) (("1" (grind) nil nil) ("2" (expand "nth" 1) (("2" (propax) nil nil)) nil) ("3" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (skeep) (("2" (typepred "l") (("2" (replace -6) (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (l skolem-const-decl "{l: list[nat] | length(l) = 1 + x!1}" mf_pvs0_Turing_Completeness nil) (rdc const-decl "list[T]" more_list_props structures) (i skolem-const-decl "below[length(rdc(l)) - 1]" mf_pvs0_Turing_Completeness nil) (rdc_rac formula-decl nil more_list_props structures) (rac const-decl "T" more_list_props structures) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (reverse_def formula-decl nil more_list_props structures) (l skolem-const-decl "{l: list[nat] | length(l) = x!1}" mf_pvs0_Turing_Completeness nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (ans skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "below[length(append(l, (: ans :))) - 1]" mf_pvs0_Turing_Completeness nil) (nth_append formula-decl nil more_list_props structures) (length_singleton formula-decl nil more_list_props structures) (x!1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (tuple2nat const-decl "nat" tuple2nat numbers) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (prim_recurrence_relation inductive-decl "bool" mf_pvs0_Turing_Completeness nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (well_founded? const-decl "bool" orders nil)) shostak)) (prim_recurrence_correctness 0 (prim_recurrence_correctness-1 nil 3776005982 ("" (skeep) (("" (lemma "prim_recurrence_is_prim_recurrence_relation") (("" (lemma "prim_recurrence_relation_works") (("" (inst?) (("" (inst?) (("" (assert) (("" (replace -1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prim_recurrence_is_prim_recurrence_relation formula-decl nil mf_pvs0_Turing_Completeness nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (limited const-decl "bool" mf_pvs0_computable nil) (prim_recurrence_relation_works formula-decl nil mf_pvs0_Turing_Completeness nil)) shostak)))
