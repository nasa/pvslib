(mf_pvs0_Turing_Completeness (proj_aux_function_TCC1 0 (proj_aux_function_TCC1-1 nil 3768906966 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (proj_aux_function subtype "(number_fields.-)(mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.j)" "naturalnumber"))) (proj_aux_function_TCC2 0 (proj_aux_function_TCC2-1 nil 3768906966 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (proj_aux_function termination "mf_pvs0_Turing_Completeness.proj_aux_function((number_fields.+)(mf_pvs0_Turing_Completeness.j, 1), mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.n, mf_pvs0_basic_programs.pi2(mf_pvs0_Turing_Completeness.x))" "nil"))) (nat2list_TCC1 0 (nat2list_TCC1-1 nil 3776781660 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (nat2list subtype "(number_fields.-)(mf_pvs0_Turing_Completeness.n, 1)" "nat"))) (nat2list_TCC2 0 (nat2list_TCC2-1 nil 3776781660 ("" (termination-tcc) nil nil) nil nil (nat2list termination "mf_pvs0_Turing_Completeness.nat2list((number_fields.-)(mf_pvs0_Turing_Completeness.n, 1), mf_pvs0_basic_programs.pi2(mf_pvs0_Turing_Completeness.x))" "nil"))) (nat2list_length 0 (nat2list_length-1 nil 3777216097 ("" (measure-induct+ "n" "n") (("" (skeep) (("" (expand "nat2list" 1) (("" (lift-if) (("" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (inst?) (("1" (assert) (("1" (expand "length" 2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (x!1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat2list def-decl "list[nat]" mf_pvs0_Turing_Completeness nil) (length def-decl "nat" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (proj_aux_function_not_last 0 (proj_aux_function_not_last-1 nil 3777211983 ("" (measure-induct+ "i-j" ("j" "i")) (("" (skeep) (("" (typepred "x!2") (("" (typepred "n") (("" (expand "proj_aux_function" 1) (("" (typepred "m") (("" (lift-if) (("" (prop) (("" (assert) (("" (inst -5 "1+x!1" "x!2") (("" (inst -5 "pi2(x)" "n" "m") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (proj_aux_function def-decl "nat" mf_pvs0_Turing_Completeness nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (int_minus_int_is_int application-judgement "int" integers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (proj_aux_function_last_TCC1 0 (proj_aux_function_last_TCC1-1 nil 3777214435 ("" (subtype-tcc) nil nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (proj_aux_function_last subtype "(number_fields.-)((number_fields.+)(1, mf_pvs0_Turing_Completeness.n), mf_pvs0_Turing_Completeness.j)" "nat"))) (proj_aux_function_last_TCC2 0 (proj_aux_function_last_TCC2-1 nil 3777214435 ("" (skeep) (("" (rewrite "nat2list_length") (("" (assert) nil nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil)) nil (proj_aux_function_last subtype "(number_fields.-)(mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.j)" "below[length[nat](nat2list(1 + n - j, x))]"))) (proj_aux_function_last 0 (proj_aux_function_last-2 "" 3804629328 ("" (measure-induct+ "i-j" ("j" "i")) (("1" (skeep) (("1" (expand "proj_aux_function" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "nat2list" 1) (("1" (typepred "n") (("1" (assert) (("1" (expand "nth" 1) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (typepred "x!2") (("2" (case "x!1= x!2") (("1" (typepred "n") (("1" (replace -1) (("1" (replace -2) (("1" (assert) (("1" (expand "nat2list" 2) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "y!1") (("2" (typepred "y!2") (("2" (assert) (("2" (typepred "x!2") (("2" (rewrite "nat2list_length") (("2" (typepred "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (rewrite "nat2list_length") (("3" (typepred "n") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (skeep) (("4" (rewrite "nat2list_length") (("4" (typepred "n") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (grind) nil nil) ("6" (rewrite "nat2list_length") (("6" (typepred "n!1") (("6" (assert) nil nil)) nil)) nil) ("7" (assert) nil nil) ("8" (skeep) (("8" (assert) (("8" (typepred "n") (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (typepred "y!1`2") (("9" (assert) nil nil)) nil) ("10" (rewrite "nat2list_length") (("10" (typepred "n!1") (("10" (assert) nil nil)) nil)) nil) ("11" (typepred "n!1") (("11" (assert) nil nil)) nil) ("12" (skeep) (("12" (rewrite "nat2list_length") (("12" (assert) nil nil)) nil)) nil) ("13" (skeep) (("13" (typepred "n") (("13" (assert) nil nil)) nil)) nil) ("14" (rewrite "nat2list_length") (("14" (typepred "n!1") (("14" (assert) nil nil)) nil)) nil)) nil) nil shostak) (proj_aux_function_last-1 nil 3777214435 ("" (measure-induct+ "i-j" ("j" "i")) (("1" (skeep) (("1" (expand "proj_aux_function" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "nat2list" 1) (("1" (typepred "n") (("1" (assert) (("1" (expand "nth" 1) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (typepred "x!2") (("2" (case "x!1= x!2") (("1" (typepred "n") (("1" (replace -1) (("1" (replace -2) (("1" (assert) (("1" (expand "nat2list" 2) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "y!1") (("2" (typepred "y!2") (("2" (assert) (("2" (typepred "x!2") (("2" (rewrite "nat2list_length") (("2" (typepred "n!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (rewrite "nat2list_length") (("3" (typepred "n") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (skeep) (("4" (rewrite "nat2list_length") (("4" (typepred "n1") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (grind) nil nil) ("6" (rewrite "nat2list_length") (("6" (typepred "n!1") (("6" (assert) nil nil)) nil)) nil) ("7" (assert) nil nil) ("8" (skeep) (("8" (assert) (("8" (typepred "n1") (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (typepred "y!1`2") (("9" (assert) nil nil)) nil) ("10" (rewrite "nat2list_length") (("10" (typepred "n!1") (("10" (assert) nil nil)) nil)) nil) ("11" (typepred "n!1") (("11" (assert) nil nil)) nil) ("12" (skeep) (("12" (rewrite "nat2list_length") (("12" (assert) nil nil)) nil)) nil) ("13" (skeep) (("13" (typepred "n") (("13" (assert) nil nil)) nil)) nil) ("14" (rewrite "nat2list_length") (("14" (typepred "n!1") (("14" (assert) nil nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (int_minus_int_is_int application-judgement "int" integers nil) (measure_induction formula-decl nil measure_induction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat2list def-decl "list[nat]" mf_pvs0_Turing_Completeness nil) (length def-decl "nat" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (proj_aux_function def-decl "nat" mf_pvs0_Turing_Completeness nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil)) shostak)) (nat2list_extension_TCC1 0 (nat2list_extension_TCC1-1 nil 3777301829 ("" (skeep) (("" (rewrite "nat2list_length") (("" (assert) nil nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (nat2list_extension subtype "mf_pvs0_Turing_Completeness.i" "below[length[nat](nat2list(1 + n, x))]"))) (nat2list_extension_TCC2 0 (nat2list_extension_TCC2-1 nil 3777301829 ("" (skeep) (("" (rewrite "nat2list_length") (("" (assert) nil nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (nat2list_extension subtype "mf_pvs0_Turing_Completeness.i" "below[length[nat](nat2list(1 + m, x))]"))) (nat2list_extension 0 (nat2list_extension-1 nil 3777301829 ("" (measure-induct+ "n" "n") (("1" (skeep) (("1" (expand "nat2list" 1 1) (("1" (expand "nat2list" 1 2) (("1" (expand "nth" 1) (("1" (lift-if) (("1" (prop) (("1" (inst -1 "x!1-1") (("1" (assert) (("1" (inst -1 "pi2(x)" "i-1" "m-1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nat2list_length") (("2" (assert) nil nil)) nil) ("3" (rewrite "nat2list_length") (("3" (assert) nil nil)) nil) ("4" (rewrite "nat2list_length") (("4" (assert) nil nil)) nil) ("5" (rewrite "nat2list_length") (("5" (assert) nil nil)) nil)) nil) ((nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (int_plus_int_is_int application-judgement "int" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (nat2list def-decl "list[nat]" mf_pvs0_Turing_Completeness nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (proj_aux_function_works_TCC1 0 (proj_aux_function_works_TCC1-1 nil 3776781660 ("" (skeep) (("" (rewrite "nat2list_length") (("" (assert) nil nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (proj_aux_function_works subtype "(number_fields.-)(mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.j)" "below[length[nat](nat2list(1 + n, x))]"))) (proj_aux_function_works 0 (proj_aux_function_works-1 nil 3776781660 ("" (measure-induct+ "i-j" ("j" "i")) (("1" (skeep) (("1" (expand "proj_aux_function" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "nat2list" 1) (("1" (expand "nth" 1) (("1" (assert) (("1" (typepred "n") (("1" (case "n > 1") (("1" (inst -4 "x!1+1" "x!2") (("1" (inst -4 "pi2(x)" "n") (("1" (assert) (("1" (lemma "nat2list_extension") (("1" (inst -1 "pi2(x)" "n-1" "x!2-x!1-1" "n") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x!2") (("2" (case "x!2=x!1") (("1" (typepred "n") (("1" (replace -2) (("1" (assert) (("1" (expand "nat2list" 2) (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nat2list_length") (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (rewrite "nat2list_length") (("3" (assert) nil nil)) nil)) nil) ("4" (skeep) (("4" (rewrite "nat2list_length") (("4" (assert) (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (assert) nil nil) ("6" (rewrite "nat2list_length") (("6" (assert) nil nil)) nil) ("7" (skeep) (("7" (assert) (("7" (rewrite "nat2list_length") (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (rewrite "nat2list_length") (("8" (assert) nil nil)) nil)) nil) ((nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (nat2list_extension formula-decl nil mf_pvs0_Turing_Completeness nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (proj_aux_function def-decl "nat" mf_pvs0_Turing_Completeness nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (nat2list def-decl "list[nat]" mf_pvs0_Turing_Completeness nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (int_minus_int_is_int application-judgement "int" integers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (proj_aux_TCC1 0 (proj_aux_TCC1-1 nil 3768906966 ("" (skeep*) (("" (replaces -1) (("" (replaces -1) (("" (replaces -1) (("" (replaces -1) (("" (replaces -1) (("" (expand "partial_recursive?") (("" (expand "length") (("" (expand "equal") (("" (expand "map") (("" (expand "map") (("" (expand "length") (("" (expand "length") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (skeep) (("" (typepred "i!1") (("" (expand "length") (("" (rewrite "map_length") (("" (expand "equal") (("" (expand "length") (("" (expand "length") (("" (expand "valid_index_rec") (("" (skeep*) (("" (expand "nth") (("" (lift-if) (("" (prop) (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (grind) (("1" (decompose-equality) nil nil) ("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (assert) (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((length def-decl "nat" list_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (below type-eq-decl nil nat_types nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (map_length formula-decl nil more_map_props nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (equal const-decl "partial_recursive" mf_pvs0_basic_programs nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (proj_aux subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].ite(mf_PVS0Expr_adt[nat].op2(0, mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.j), mf_PVS0Expr_adt[nat].rec(0, mf_pvs0_Turing_Completeness.k4(mf_PVS0Expr_adt[nat].op1(0, mf_pvs0_Turing_Completeness.j), mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.n, mf_PVS0Expr_adt[nat].op1(2, mf_pvs0_Turing_Completeness.x))), mf_PVS0Expr_adt[nat].ite(mf_PVS0Expr_adt[nat].rec(1, mf_PVS0Expr_adt[nat].op2(1, mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.n)), mf_pvs0_Turing_Completeness.x, mf_PVS0Expr_adt[nat].op1(1, mf_pvs0_Turing_Completeness.x))), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_basic_programs.equal`4)))" "partial_recursive[false_val, lop1, lop2]"))) (proj_aux_works 0 (proj_aux_works-1 nil 3768921138 ("" (measure-induct+ "if i > j then i -j else 0 endif" ("j" "i")) (("1" (skeep) (("1" (expand "proj_aux" 1) (("1" (expand "semantic_rel" 1) (("1" (expand "nth") (("1" (expand "semantic_rel_expr" 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "eval_op1") (("1" (expand "eval_op2") (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "eval_op1") (("1" (case "x!2 > x!1") (("1" (inst 1 "1") (("1" (prop) (("1" (inst 1 "x!2" "x!1") (("1" (prop) (("1" (expand "lop1") (("1" (expand "length") (("1" (expand "length") (("1" (expand "length") (("1" (assert) (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "pi2") (("1" (expand "o ") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "lop2") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "bigger") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (expand "length") (("2" (assert) (("2" (inst 2 "tuple2nat(x!1+1,tuple2nat(x!2,tuple2nat(n,pi2(x))))") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "x!1+1" "tuple2nat(x!2, tuple2nat(n, pi2(x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "x!1") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (assert) (("2" (assert) (("2" (expand "nth") (("2" (expand "succ") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "x!2" "tuple2nat(n, pi2(x))") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "n" "pi2(x)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(n, x)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "x") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(n, x)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (lift-if) (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (expand "proj_aux_function" 1) (("2" (inst -3 "1+x!1" "x!2") (("2" (inst -3 "n" "pi2(x)") (("2" (assert) (("2" (prop) (("1" (expand "semantic_rel" -1) (("1" (expand "proj_aux") (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "false_val") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (inst 2 "0") (("2" (prop) (("1" (inst 1 "x!2" "x!1") (("1" (prop) (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (expand "lop1") (("1" (expand "length") (("1" (expand "length") (("1" (expand "length") (("1" (lift-if) (("1" (assert) (("1" (expand "length") (("1" (assert) (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "pi2") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "lop2") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "bigger") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "false_val") (("2" (propax) nil nil)) nil) ("3" (expand "proj_aux_function" 1) (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "1") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (expand "nth") (("1" (expand "length") (("1" (inst 1 "tuple2nat(x!2,n)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "x!2" "n") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(n, x)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (lift-if) (("3" (assert) (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(equal`4,0)" "equal`4" "(: ite[nat]
                                               (op2(0,
                                                    op1[nat](1, op1[nat](2, vr)),
                                                    op1[nat](1, vr)),
                                                rec(0,
                                                    op2[nat]
                                                    (1,
                                                     op1(0, op1[nat](1, vr)),
                                                     op2[nat]
                                                     (1,
                                                      op1[nat](1, op1[nat](2, vr)),
                                                      op2[nat]
                                                      (1,
                                                       op1[nat]
                                                       (1, op1[nat](2, op1[nat](2, vr))),
                                                       op1
                                                       (2,
                                                        op1[nat]
                                                        (2,
                                                         op1[nat]
                                                         (2, op1[nat](2, vr)))))))),
                                                ite(rec
                                                    (1,
                                                     op2
                                                     (1,
                                                      op1[nat](1, op1[nat](2, vr)),
                                                      op1[nat]
                                                      (1,
                                                       op1[nat](2, op1[nat](2, vr))))),
                                                    op1[nat]
                                                    (2, op1[nat](2, op1[nat](2, vr))),
                                                    op1
                                                    (1,
                                                     op1[nat]
                                                     (2,
                                                      op1[nat](2, op1[nat](2, vr)))))) :)" "lop1" "lop2" "tuple2nat(x!2, n)" "1") (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (rewrite "map_nth_rw") (("1" (replaces -1 :dir rl) (("1" (lemma "equal_works") (("1" (inst -1 "x!2" "n") (("1" (expand "semantic_rel" -1) (("1" (expand "equal_function") (("1" (assert) (("1" (case "(lop1, lop2, false_val, equal`4) = equal") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (typepred "equal") (("2" (expand "partial_recursive?") (("2" (prop) (("2" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 2 "tuple2nat(n, x)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 " tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "false_val") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 2 "0") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (expand "nth") (("1" (inst 1 "tuple2nat(x!2,n)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "x!2" "n") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(n,x)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 " tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (lift-if) (("2" (assert) (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (lift-if) (("3" (expand "length") (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(equal`4,0)" "equal`4" "(: ite[nat]
                                               (op2(0,
                                                    op1[nat](1, op1[nat](2, vr)),
                                                    op1[nat](1, vr)),
                                                rec(0,
                                                    op2[nat]
                                                    (1,
                                                     op1(0, op1[nat](1, vr)),
                                                     op2[nat]
                                                     (1,
                                                      op1[nat](1, op1[nat](2, vr)),
                                                      op2[nat]
                                                      (1,
                                                       op1[nat]
                                                       (1, op1[nat](2, op1[nat](2, vr))),
                                                       op1
                                                       (2,
                                                        op1[nat]
                                                        (2,
                                                         op1[nat]
                                                         (2, op1[nat](2, vr)))))))),
                                                ite(rec
                                                    (1,
                                                     op2
                                                     (1,
                                                      op1[nat](1, op1[nat](2, vr)),
                                                      op1[nat]
                                                      (1,
                                                       op1[nat](2, op1[nat](2, vr))))),
                                                    op1[nat]
                                                    (2, op1[nat](2, op1[nat](2, vr))),
                                                    op1
                                                    (1,
                                                     op1[nat]
                                                     (2,
                                                      op1[nat](2, op1[nat](2, vr)))))) :)" "lop1" "lop2" "tuple2nat(x!2, n)" "0") (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (rewrite "map_nth_rw") (("1" (replaces -1 :dir rl) (("1" (lemma "equal_works") (("1" (inst -1 "x!2" "n") (("1" (expand "equal_function") (("1" (assert) (("1" (expand "semantic_rel") (("1" (case "(lop1, lop2, false_val, equal`4) = equal") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (typepred "equal") (("2" (expand "partial_recursive?") (("2" (prop) (("2" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "x") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(n, x)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!2, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, tuple2nat(x!2, tuple2nat(n, x)))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (length def-decl "nat" list_props nil) (O const-decl "T3" function_props nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length_singleton formula-decl nil more_list_props structures) (bigger const-decl "nat" mf_pvs0_basic_programs nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (succ const-decl "nat" mf_pvs0_basic_programs nil) (equal const-decl "partial_recursive" mf_pvs0_basic_programs nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (below type-eq-decl nil nat_types nil) (TRUE const-decl "bool" booleans nil) (equal_function const-decl "nat" mf_pvs0_basic_programs nil) (NOT const-decl "[bool -> bool]" booleans nil) (equal_works formula-decl nil mf_pvs0_basic_programs nil) (map_nth_rw formula-decl nil more_map_props nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (below type-eq-decl nil naturalnumbers nil) (append def-decl "list[T]" list_props nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (map adt-def-decl "list[T1]" list_adt_map nil) (eval_op1 const-decl "Val" mf_pvs0_expr nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (proj_aux_function def-decl "nat" mf_pvs0_Turing_Completeness nil) (tuple2nat const-decl "nat" tuple2nat numbers) (proj_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (proj_TCC1 0 (proj_TCC1-1 nil 3768906966 ("" (skeep*) (("" (replaces -1) (("" (replaces -1) (("" (replaces -1) (("" (replaces -1) (("" (expand "partial_recursive?") (("" (skeep) (("" (expand "valid_index_rec") (("" (skeep) (("" (expand "length") (("" (rewrite "map_length") (("" (expand "proj_aux") (("" (expand "length") (("" (rewrite "map_length") (("" (expand "equal") (("" (expand "length") (("" (expand "length") (("" (typepred "i!1") (("" (expand "length") (("" (rewrite "map_length") (("" (expand "proj_aux") (("" (expand "length") (("" (rewrite "map_length") (("" (expand "equal") (("" (expand "length") (("" (expand "length") (("" (expand "map") (("" (expand "map") (("" (expand "map") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "offset_rec") (("" (expand "nth") (("" (lift-if) (("" (prop) (("1" (expand "subterm") (("1" (prop) (("1" (decompose-equality) (("1" (assert) nil nil)) nil) ("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (prop) (("1" (decompose-equality) nil nil) ("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (assert) (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (expand "subterm") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((partial_recursive? const-decl "bool" mf_pvs0_computable nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (length def-decl "nat" list_props nil) (equal const-decl "partial_recursive" mf_pvs0_basic_programs nil) (below type-eq-decl nil nat_types nil) (map adt-def-decl "list[T1]" list_adt_map nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (nth def-decl "T" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (proj_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map_length formula-decl nil more_map_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (proj subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].rec(1, mf_pvs0_Turing_Completeness.k4(mf_PVS0Expr_adt[nat].cnst(0), mf_pvs0_Turing_Completeness.i, mf_pvs0_Turing_Completeness.n, mf_pvs0_Turing_Completeness.x)), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_Turing_Completeness.proj_aux`4)))" "partial_recursive[false_val, lop1, lop2]"))) (proj_works 0 (proj_works-1 nil 3776698817 ("" (skeep) (("" (expand "proj" 1) (("" (expand "semantic_rel" 1) (("" (expand "nth" 1) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "tuple2nat(0,tuple2nat(i,tuple2nat(n,x)))") (("" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "0" "tuple2nat(i, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "i" "tuple2nat(n,x)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(i, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "n" "x") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(n, x)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(i, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(n, x)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(i, tuple2nat(n, x))") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(proj_aux`4,0)" "proj_aux`4" "(: rec(1,
                                 op2[nat]
                                     (1,
                                      cnst(0),
                                      op2[nat]
                                      (1,
                                       op1[nat](1, vr),
                                       op2[nat]
                                       (1,
                                        op1[nat](1, op1[nat](2, vr)),
                                        op1[nat](2, op1[nat](2, vr)))))) :)" "lop1" "lop2" "tuple2nat(0, tuple2nat(i, tuple2nat(n, x)))" "proj_function(i, n, x)") (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (lemma "proj_aux_works") (("1" (inst -1 "0" "i" "n" "x") (("1" (expand "semantic_rel") (("1" (expand "proj_function") (("1" (case "(lop1, lop2, false_val, proj_aux`4) = proj_aux") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((proj const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (nth def-decl "T" list_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (tuple2nat const-decl "nat" tuple2nat numbers) (proj_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (proj_function const-decl "nat" mf_pvs0_Turing_Completeness nil) (below type-eq-decl nil naturalnumbers nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map_nth_rw formula-decl nil more_map_props nil) (proj_aux_works formula-decl nil mf_pvs0_Turing_Completeness nil) (= const-decl "[T, T -> boolean]" equalities nil) (map adt-def-decl "list[T1]" list_adt_map nil) (equal const-decl "partial_recursive" mf_pvs0_basic_programs nil) (append def-decl "list[T]" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (O const-decl "T3" function_props nil) (length_singleton formula-decl nil more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (eval_op1 const-decl "Val" mf_pvs0_expr nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil)) shostak)) (proj_correctness_TCC1 0 (proj_correctness_TCC1-1 nil 3777904173 ("" (skeep) (("" (rewrite "nat2list_length") (("" (assert) nil nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nat2list_length formula-decl nil mf_pvs0_Turing_Completeness nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (proj_correctness subtype "mf_pvs0_Turing_Completeness.i" "below[length[nat](nat2list(1 + n, x))]"))) (proj_correctness 0 (proj_correctness-1 nil 3777904174 ("" (lemma "proj_works") (("" (skeep) (("" (inst?) (("" (expand "proj_function") (("" (rewrite "proj_aux_function_works") (("1" (assert) nil nil) ("2" (typepred "n") (("2" (rewrite "proj_aux_function_last") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((proj_function const-decl "nat" mf_pvs0_Turing_Completeness nil) (NOT const-decl "[bool -> bool]" booleans nil) (proj_aux_function_last formula-decl nil mf_pvs0_Turing_Completeness nil) (= const-decl "[T, T -> boolean]" equalities nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (< const-decl "bool" reals nil) (proj_aux_function_works formula-decl nil mf_pvs0_Turing_Completeness nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (proj_works formula-decl nil mf_pvs0_Turing_Completeness nil)) shostak)) (expr_comp_TCC1 0 (expr_comp_TCC1-1 nil 3768906966 ("" (skeep*) (("" (typepred "l") (("" (grind) nil nil)) nil)) nil) ((limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (expr_comp subtype "list_adt[(mf_pvs0_computable[mf_pvs0_basic_programs.false_val, mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2].limited)].cdr(mf_pvs0_Turing_Completeness.l)" "(list_adt[(mf_pvs0_computable[mf_pvs0_basic_programs.false_val, mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2].limited)].cons?)"))) (expr_comp_TCC2 0 (expr_comp_TCC2-1 nil 3768906966 ("" (termination-tcc) nil nil) ((length def-decl "nat" list_props nil)) nil (expr_comp termination "mf_pvs0_Turing_Completeness.expr_comp((number_fields.+)(mf_pvs0_Turing_Completeness.n, list_props[mf_PVS0Expr[nat]].length(list_adt[(mf_pvs0_computable[mf_pvs0_basic_programs.false_val, mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2].limited)].car(mf_pvs0_Turing_Completeness.l))), list_adt[(mf_pvs0_computable[mf_pvs0_basic_programs.false_val, mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2].limited)].cdr(mf_pvs0_Turing_Completeness.l))" "nil"))) (rec_indices_chain_offset_is_limited 0 (rec_indices_chain_offset_is_limited-1 nil 3771599334 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (expand "chain_offset" 1) (("" (lift-if) (("" (prop) (("1" (typepred "car(x!1)") (("1" (expand "limited") (("1" (inst -3 "i") (("1" (rewrite "map_length") (("1" (rewrite "map_nth_rw") (("1" (use "valid_index_rec_offset") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "chain_offset" -1) (("2" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (lift-if) (("1" (prop) nil nil)) nil)) nil) ("2" (rewrite "map_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (typepred "car(x!1)") (("1" (expand "limited") (("1" (inst -3 "i") (("1" (rewrite "map_nth_rw") (("1" (lemma "valid_index_rec_offset") (("1" (inst -1 "nth(car(x!1),i)" "length(car(x!1))" "n") (("1" (assert) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (hide-all-but (-1 1)) (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") nil nil)) nil)) nil)) nil) ("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "length(car(x!1)) + n" "i - length(map(offset_rec(n))(car(x!1)))") (("1" (prop) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2 3) (("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "chain_offset" -1) (("2" (rewrite "length_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth_append formula-decl nil more_list_props structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (n skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (x!1 skolem-const-decl "(cons?[(limited)])" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "below[length(chain_offset(n, x!1))]" mf_pvs0_Turing_Completeness nil) (below type-eq-decl nil naturalnumbers nil) (map_nth_rw formula-decl nil more_map_props nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (map_length formula-decl nil more_map_props nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (length_append formula-decl nil list_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nth def-decl "T" list_props nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (below type-eq-decl nil nat_types nil) (chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (rec_indices_expr_comp_is_limited 0 (rec_indices_expr_comp_is_limited-1 nil 3771684102 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (expand "expr_comp" 1) (("" (expand "chain_offset" 1) (("" (lift-if) (("" (prop) (("1" (rewrite "map_length") (("1" (typepred "n") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm" -3) (("1" (expand "subterm" -3) (("1" (decompose-equality) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "length(car(x!1))+n") (("2" (prop) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm" -2) (("1" (prop) (("1" (expand "subterm" -1) (("1" (expand "subterm" -1) (("1" (decompose-equality) (("1" (typepred "n") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "i" "expr") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (map_length formula-decl nil more_map_props nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (map adt-def-decl "list[T1]" list_adt_map nil) (length_append formula-decl nil list_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expr_comp def-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (chain_offset_length 0 (chain_offset_length-1 nil 3771694926 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (expand "chain_offset" 1) (("" (expand "chain_of_appends" 1) (("" (lift-if) (("" (prop) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (expand "length" -1) (("1" (case "null?(cdr(x!1))") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "length(car(x!1)) + n") (("2" (prop) (("1" (assert) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map_length formula-decl nil more_map_props nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_append formula-decl nil list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (chain_of_appends def-decl "list[T]" chain_of_appends nil) (chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (comp_TCC1 0 (comp_TCC1-1 nil 3768906966 ("" (skeep) (("" (expand "partial_recursive?") (("" (skeep) (("" (typepred "i") (("" (expand "nth" 1) (("" (lift-if) (("" (prop) (("1" (expand "valid_index_rec" 1) (("1" (skeep) (("1" (expand "subterm") (("1" (prop) (("1" (decompose-equality) (("1" (grind) nil nil)) nil) ("2" (expand "subterm" -1) (("2" (prop) (("1" (grind) nil nil) ("2" (lemma "rec_indices_expr_comp_is_limited") (("2" (inst -1 "l" "1 + length[mf_PVS0Expr[nat]](f)") (("2" (expand "valid_index_rec") (("2" (inst?) (("2" (expand "length" 1) (("2" (expand "chain_offset" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "rec_indices_chain_offset_is_limited") (("2" (expand "length" 2) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((partial_recursive? const-decl "bool" mf_pvs0_computable nil) (below type-eq-decl nil nat_types nil) (chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expr_comp def-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (rec_indices_chain_offset_is_limited formula-decl nil mf_pvs0_Turing_Completeness nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (l skolem-const-decl "(cons?[(limited[false_val, lop1, lop2])])" mf_pvs0_Turing_Completeness nil) (f skolem-const-decl "(limited[false_val, lop1, lop2])" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "below[length(cons[mf_PVS0Expr[nat]]
                 (rec[nat]
                      (1,
                       op2[nat]
                           (1, cnst[nat](length[(limited)](l)),
                            expr_comp(1 + length[mf_PVS0Expr[nat]](f),
                                      l))),
                  chain_offset(1, cons[(limited)](f, l))))]" mf_pvs0_Turing_Completeness nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (rec_indices_expr_comp_is_limited formula-decl nil mf_pvs0_Turing_Completeness nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (length_append formula-decl nil list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (map_length formula-decl nil more_map_props nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (append def-decl "list[T]" list_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (nth def-decl "T" list_props nil)) nil (comp subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].rec(1, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].cnst(list_props[(mf_pvs0_computable[mf_pvs0_basic_programs.false_val, mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2].limited)].length(mf_pvs0_Turing_Completeness.l)), mf_pvs0_Turing_Completeness.expr_comp((number_fields.+)(1, list_props[mf_PVS0Expr[nat]].length(mf_pvs0_Turing_Completeness.f)), mf_pvs0_Turing_Completeness.l))), mf_pvs0_Turing_Completeness.chain_offset(1, list_adt[(mf_pvs0_computable[mf_pvs0_basic_programs.false_val, mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2].limited)].cons(mf_pvs0_Turing_Completeness.f, mf_pvs0_Turing_Completeness.l))))" "partial_recursive[false_val, lop1, lop2]"))) (list2nat_TCC1 0 (list2nat_TCC1-1 nil 3771257008 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (length def-decl "nat" list_props nil)) nil (list2nat subtype "list_adt[nat].cdr(mf_pvs0_Turing_Completeness.l)" "(list_adt[nat].cons?)"))) (list2nat_TCC2 0 (list2nat_TCC2-1 nil 3771257008 ("" (termination-tcc) nil nil) ((length def-decl "nat" list_props nil)) nil (list2nat termination "mf_pvs0_Turing_Completeness.list2nat(list_adt[nat].cdr(mf_pvs0_Turing_Completeness.l))" "nil"))) (offset_rec_chain_offset 0 (offset_rec_chain_offset-1 nil 3772551257 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (expand "chain_offset" 1) (("" (lift-if) (("" (prop) (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") nil nil)) nil) ("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "m" "length(car(x!1))+n") (("2" (prop) (("1" (rewrite "map_append") (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (map_append formula-decl nil map_append nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (map_list_composition formula-decl nil map_props nil) (offset_composition2 formula-decl nil mf_pvs0_lang nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map adt-def-decl "list[T1]" list_adt_map nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (offset_rec_expr_comp 0 (offset_rec_expr_comp-1 nil 3773068625 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (expand "expr_comp" 1) (("" (lift-if) (("" (prop) (("1" (grind) nil nil) ("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "length(car(x!1))+m" "n") (("2" (prop) (("1" (expand "offset_rec" 2) (("1" (replace -1) (("1" (expand "offset_rec" 2) (("1" (expand "offset_rec" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expr_comp def-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (limits_of_chain_offset_TCC1 0 (limits_of_chain_offset_TCC1-1 nil 3772466897 ("" (subtype-tcc) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil) ((subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (append def-decl "list[T]" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (l1!1 skolem-const-decl "(limited[false_val, lop1, lop2])" mf_pvs0_Turing_Completeness nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (limited const-decl "bool" mf_pvs0_computable nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (chain_of_appends def-decl "list[T]" chain_of_appends nil) (take def-decl "list[T]" more_list_props structures) (nth def-decl "T" list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (limits_of_chain_offset subtype "list_props[mf_PVS0Expr[nat]].append(mf_pvs0_Turing_Completeness.l1, mf_pvs0_Turing_Completeness.chain_offset(list_props[mf_PVS0Expr[nat]].length(mf_pvs0_Turing_Completeness.l1), mf_pvs0_Turing_Completeness.l))" "lmf_PVS0Expr[nat]"))) (limits_of_chain_offset_TCC2 0 (limits_of_chain_offset_TCC2-1 nil 3772546375 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (limits_of_chain_offset subtype "(number_fields.-)((number_fields.-)(mf_pvs0_Turing_Completeness.k, list_props[mf_PVS0Expr[nat]].length(mf_pvs0_Turing_Completeness.l1)), list_props[mf_PVS0Expr[nat]].length(chain_of_appends[mf_PVS0Expr[nat]].chain_of_appends(more_list_props[list[mf_PVS0Expr[nat]]].take(mf_pvs0_Turing_Completeness.l, mf_pvs0_Turing_Completeness.i))))" "below[length[mf_PVS0Expr[nat]](nth[(limited)](l, i))]"))) (limits_of_chain_offset 0 (limits_of_chain_offset-1 nil 3772466910 ("" (measure-induct+ "length(l)" "l") (("1" (skeep) (("1" (expand "chain_offset" 1) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (typepred "i") (("1" (case "i=0") (("1" (typepred "k") (("1" (replaces -3) (("1" (expand "take" -1) (("1" (assert) (("1" (rewrite subtype_length) (("1" (expand "chain_of_appends" -1) (("1" (expand "length" -1 2) (("1" (expand "take" -2) (("1" (expand "chain_of_appends" -2) (("1" (expand "length" -2 3) (("1" (expand "semantic_rel_expr" 1 1) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (assert) (("1" (rewrite "subtype_length") (("1" (expand "nth" -2) (("1" (assert) (("1" (rewrite "nth_append") (("1" (prop) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(car(x!1), k-length(l1))" "car(x!1)" "l1" "lop1" "lop2" "valarg" "output") (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (expand "nth" 1 (1 3)) (("1" (assert) (("1" (expand "take" 1) (("1" (expand "chain_of_appends" 1) (("1" (expand "length" 1 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "input") (("2" (expand "semantic_rel_expr" 1 1) (("2" (rewrite "map_nth_rw") (("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(car(x!1), k-length(l1))" "car(x!1)" "l1" "lop1" "lop2" "input" "output") (("2" (assert) (("2" (expand "nth" -1 (1 3)) (("2" (expand "take" -1) (("2" (expand "chain_of_appends" -1) (("2" (expand "length" -1 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -1 "cdr(x!1)") (("2" (expand "nth" 2 (1 3)) (("2" (assert) (("2" (typepred "i") (("2" (lift-if) (("2" (split) (("1" (typepred "k") (("1" (flatten) (("1" (replace -3) (("1" (expand "take" -1) (("1" (assert) (("1" (rewrite "subtype_length") (("1" (expand "take" -2) (("1" (expand "chain_of_appends") (("1" (expand "length" -2 3) (("1" (expand "length" -1 2) (("1" (expand "semantic_rel_expr" 1 1) (("1" (rewrite "length_append") (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "chain_offset_length") (("1" (expand "nth" -2) (("1" (assert) (("1" (prop) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (replaces -1) (("1" (rewrite "nth_append") (("1" (rewrite "nth_append") (("1" (rewrite "map_length") (("1" (assert) (("1" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(car(x!1), k - length(l1))" "append(car(x!1),
                                      chain_offset
                                      (length(car(x!1)),
                                       cdr(x!1)))" "l1" "lop1" "lop2" "input" "output") (("1" (rewrite "map_append") (("1" (rewrite "offset_rec_chain_offset") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(car(x!1), k - length(l1))" "car(x!1)" "chain_offset(length(car(x!1)), cdr(x!1))" "lop1" "lop2" "input" "output") (("1" (assert) (("1" (expand "take" 1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "chain_offset" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (expand "take" 1) (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -7) (("3" (typepred "car(x!1)") (("3" (expand "limited" -3) (("3" (prop) (("3" (inst -3 "k - length[mf_PVS0Expr[nat]](l1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "input") (("2" (expand "semantic_rel_expr" 1 1) (("2" (rewrite "nth_append") (("1" (rewrite "nth_append") (("1" (rewrite "map_length") (("1" (assert) (("1" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(car(x!1),k-length(l1))" "append(car(x!1),
                                      chain_offset
                                      (length(car(x!1)),
                                       cdr(x!1)))" "l1" "lop1" "lop2" "input" "output") (("1" (assert) (("1" (rewrite "map_append") (("1" (rewrite "offset_rec_chain_offset") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(car(x!1), k - length(l1))" "car(x!1)" "chain_offset(length(car(x!1)), cdr(x!1))" "lop1" "lop2" "input" "output") (("1" (assert) (("1" (expand "take" -1) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "chain_offset" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (expand "take") (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "car(x!1)") (("3" (expand "limited" -3) (("3" (prop) (("3" (inst -3 "k - length[mf_PVS0Expr[nat]](l1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -2 "append(l1,map
                                      (offset_rec(length(l1)))(car(x!1)))" "i-1" "input" "output" "k") (("1" (rewrite "append_assoc") (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (assert) (("1" (expand "take" 2) (("1" (assert) (("1" (case "length(x!1) < i") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "subtype_length[list_adt
                                         [mf_PVS0Expr_adt
                                          [naturalnumbers.nat].mf_PVS0Expr].list, (limited)]") (("2" (inst?) (("2" (expand "chain_of_appends" 3) (("2" (rewrite "length_append") (("2" (assert) (("2" (assert) (("2" (replace 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "k") (("2" (hide 3) (("2" (prop) (("1" (rewrite "length_append") (("1" (expand "take" -1) (("1" (lemma "subtype_length[list_adt
                                         [mf_PVS0Expr_adt
                                          [naturalnumbers.nat].mf_PVS0Expr].list, (limited)]") (("1" (inst?) (("1" (assert) (("1" (expand "chain_of_appends" -2) (("1" (rewrite "length_append") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_length") (("1" (expand "chain_of_appends" -3) (("1" (rewrite "length_append") nil nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (expand "chain_of_appends" -2) (("2" (rewrite "length_append") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "take" -2) (("2" (expand "nth" -2) (("2" (assert) (("2" (lemma "subtype_length[list_adt
                                         [mf_PVS0Expr_adt
                                          [naturalnumbers.nat].mf_PVS0Expr].list, (limited)]") (("2" (inst?) (("2" (assert) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (assert) (("2" (expand "chain_of_appends" -2) (("2" (rewrite "length_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (hide 3) (("4" (prop) (("1" (grind) nil nil) ("2" (expand "limited") (("2" (skeep) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (typepred "l1") (("1" (expand "limited" -3) (("1" (inst -3 "i!1") (("1" (rewrite "length_append") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (typepred "car(x!1)") (("2" (expand "limited") (("2" (rewrite "map_length") (("2" (inst -3 "i!1-length(l1)") (("1" (rewrite "map_nth_rw") (("1" (lemma "valid_index_rec_offset") (("1" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "i!1") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (typepred "i!1") (("2" (rewrite "length_append") (("2" (rewrite "map_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ((x!1 skolem-const-decl "(cons?[(limited)])" mf_pvs0_Turing_Completeness nil) (offset_rec_chain_offset formula-decl nil mf_pvs0_Turing_Completeness nil) (add_rec_list2 formula-decl nil mf_pvs0_lang nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (k skolem-const-decl "{k: nat |
   k >= length(chain_of_appends(take(x!1, i))) + length(l1) AND
    k <
     length(chain_of_appends(take(x!1, i))) + length(nth(x!1, i)) +
      length(l1)}" mf_pvs0_Turing_Completeness nil) (l1 skolem-const-decl "(limited)" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "below[length(x!1)]" mf_pvs0_Turing_Completeness nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (map_append formula-decl nil map_append nil) (chain_offset_length formula-decl nil mf_pvs0_Turing_Completeness nil) (append_assoc formula-decl nil list_props nil) (i!1 skolem-const-decl "below[length(append[mf_PVS0Expr[nat]]
                 (l1,
                  map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                      (offset_rec[nat](length[mf_PVS0Expr[nat]](l1)))
                      (car[(limited)](x!1))))]" mf_pvs0_Turing_Completeness nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (TRUE const-decl "bool" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map adt-def-decl "list[T1]" list_adt_map nil) (length_append formula-decl nil list_props nil) (nth_append formula-decl nil more_list_props structures) (add_rec_list formula-decl nil mf_pvs0_lang nil) (below type-eq-decl nil naturalnumbers nil) (map_nth_rw formula-decl nil more_map_props nil) (map_length formula-decl nil more_map_props nil) (subtype_length formula-decl nil subtype_length nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_times_int_is_int application-judgement "int" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (chain_of_appends def-decl "list[T]" chain_of_appends nil) (take def-decl "list[T]" more_list_props structures) (nth def-decl "T" list_props nil) (append def-decl "list[T]" list_props nil) (chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (chain_offset_prop_TCC1 0 (chain_offset_prop_TCC1-1 nil 3771944398 ("" (subtype-tcc) nil nil) nil nil (chain_offset_prop subtype "mf_pvs0_Turing_Completeness.i" "below[length[(limited[false_val, lop1, lop2])](l)]"))) (chain_offset_prop 0 (chain_offset_prop-1 nil 3771944442 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (expand "chain_offset" 1) (("" (expand "expr_comp" 1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (prop) (("1" (inst 1 "(: output :)") (("1" (skeep) (("1" (typepred "i") (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (case "i=0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (expand "list2nat" 1) (("1" (expand "length" 1) (("1" (expand "length" 1) (("1" (expand "semantic_rel" 1) (("1" (expand "semantic_rel" -2) (("1" (expand "nth" -2) (("1" (expand "semantic_rel_expr" -2) (("1" (skeep) (("1" (expand "semantic_rel_expr" -2) (("1" (replaces -2) (("1" (expand "length" -2 2) (("1" (rewrite "map_length") (("1" (rewrite "length_append") (("1" (assert) (("1" (expand "nth" -2) (("1" (rewrite "map_length") (("1" (prop) (("1" (rewrite "map_append") (("1" (rewrite "nth_append") (("1" (rewrite "map_length") (("1" (assert) (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(car(x!1),0)" "car(x!1)" "cons(rec(1 + length(l1), vr),map(offset_rec(1))(l1))" "lop1" "lop2" "input" "output") (("1" (expand "append" -1 1) (("1" (expand "length" 1 2) (("1" (rewrite "map_length") (("1" (expand "length" 1 3) (("1" (rewrite "map_length") (("1" (rewrite "map_nth_rw") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "interm") (("2" (inst -4 "0") (("1" (prop) (("1" (case "interm = (: output :)") (("1" (replaces -1) (("1" (expand "nth" -4 2) (("1" (expand "semantic_rel" 1) (("1" (expand "nth" 1) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "input") (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "length" 1 2) (("1" (rewrite "map_length") (("1" (prop) (("1" (expand "nth" 1) (("1" (rewrite "map_append") (("1" (rewrite "nth_append") (("1" (rewrite "map_length") (("1" (assert) (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (rewrite "map_nth_rw") (("1" (expand "semantic_rel" -5) (("1" (expand "nth" -5 3) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(car(x!1),0)" "nth(x!1,0)" "cons(rec(1 + length(l1), vr),map(offset_rec(1))(l1))" "lop1" "lop2" "input" "output") (("1" (assert) (("1" (expand "append" -1 1) (("1" (expand "length" -1 2) (("1" (rewrite "map_length") (("1" (expand "length" -1 3) (("1" (rewrite "map_length") (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -5 -6 1)) (("2" (grind) (("2" (grind) (("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -1 "cdr(x!1)") (("2" (prop) (("1" (expand "semantic_rel" -1) (("1" (expand "nth" -1) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "eval_op2") (("1" (expand "lop2" -3 1) (("1" (expand "length" -3) (("1" (expand "length" -3) (("1" (assert) (("1" (expand "lop2" -3) (("1" (expand "nth" -3) (("1" (expand "nth" -3) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "rec(length(l1),vr)" "append(l1,
                                        append
                                        (map
                                         (offset_rec(length(l1)))
                                         (car(x!1)),
                                         chain_offset
                                         (length(car(x!1)) + length(l1),
                                          cdr(x!1))))" "(: op2(1, rec(1 + length(l1), vr),
                                 expr_comp(1 + length(car(x!1))
                                           +
                                           length(l1),
                                           cdr(x!1))) :)" "lop1" "lop2" "input" "valarg1") (("1" (expand "append" -1 3) (("1" (expand "append" -1 3) (("1" (expand "length" -1 8) (("1" (expand "length" -1 8) (("1" (expand "length" -1 11) (("1" (expand "length" -1 11) (("1" (expand "offset_rec" -1 4) (("1" (expand "offset_rec" -1 4) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "expr_comp(length(car(x!1)) + length(l1),
                                  cdr(x!1))" "append(l1,
                                        append
                                        (map
                                         (offset_rec(length(l1)))
                                         (car(x!1)),
                                         chain_offset
                                         (length(car(x!1)) + length(l1),
                                          cdr(x!1))))" "(: op2(1, rec(1 + length(l1), vr),
                                 expr_comp(1 + length(car(x!1))
                                           +
                                           length(l1),
                                           cdr(x!1))) :)" "lop1" "lop2" "input" "valarg2") (("1" (expand "append" -1 3) (("1" (expand "append" -1 3) (("1" (expand "length" -1 9) (("1" (expand "length" -1 9) (("1" (expand "length" -1 12) (("1" (expand "length" -1 12) (("1" (rewrite "offset_rec_expr_comp") (("1" (assert) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "expr_comp(length(car(x!1)) + length(l1), cdr(x!1))" "append(l1,
                               append(map
                                      (offset_rec(length(l1)))(car(x!1)),
                                      chain_offset
                                      (length(car(x!1)) + length(l1),
                                       cdr(x!1))))" "(: expr_comp(1 + length(car(x!1))
                                           +
                                           length(l1),
                                           cdr(x!1)) :)" "lop1" "lop2" "input" "valarg2") (("1" (expand "append" -1 3) (("1" (expand "append" -1 1) (("1" (expand "length" -1 3) (("1" (expand "length" -1 3) (("1" (expand "length" -1 6) (("1" (expand "length" -1 6) (("1" (rewrite "offset_rec_expr_comp") (("1" (inst -7 "append(l1,map
                                         (offset_rec(length(l1)))
                                         (car(x!1)))" "input" "valarg2") (("1" (split) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "append_assoc") (("1" (expand "semantic_rel" -1 1) (("1" (expand "nth" -1 1) (("1" (assert) (("1" (skeep) (("1" (inst 1 "cons(valarg1,interm)") (("1" (skeep) (("1" (prop) (("1" (expand "nth" 1) (("1" (lift-if) (("1" (prop) (("1" (lemma "limits_of_chain_offset") (("1" (inst -1 "l1" "x!1" "0" "input" "valarg1" "length(l1)") (("1" (expand "chain_offset" -1 1) (("1" (expand "take" -1) (("1" (assert) (("1" (expand "chain_of_appends" -1) (("1" (expand "length" -1) (("1" (expand "nth" -1 (1 3)) (("1" (expand "semantic_rel" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil) ("2" (inst -1 "i-1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "interm") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (prop) (("1" (grind) nil nil) ("2" (hide-all-but (1 3)) (("2" (typepred "l1") (("2" (typepred "car(x!1)") (("2" (hide-all-but (-3 -6 1 2)) (("2" (expand "limited") (("2" (skeep) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (inst -3 "i") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst -4 "i_1" "expr") (("1" (rewrite "length_append") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_nth_rw") (("1" (inst -1 "i-length(l1)") (("1" (lemma "valid_index_rec_offset") (("1" (inst -1 "nth(car(x!1), i - length(l1))" "length(car(x!1))" "length(l1)") (("1" (assert) (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst -1 "i_1" "expr") (("1" (assert) (("1" (rewrite "length_append") (("1" (rewrite "map_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel" 1) (("2" (expand "nth" 1) (("2" (expand "semantic_rel_expr" 1) (("2" (skeep) (("2" (expand "eval_op2") (("2" (expand "lop2" 1 3) (("2" (expand "length" 1 16) (("2" (expand "length" 1 16) (("2" (assert) (("2" (expand "lop2" 1 3) (("2" (expand "nth" 1 1) (("2" (expand "nth" 1 1) (("2" (inst 1 "car(interm)" "list2nat(cdr(interm))") (("1" (prop) (("1" (lemma "limits_of_chain_offset") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "rec(length(l1),vr)" "append(l1,
                                        append
                                        (map
                                         (offset_rec(length(l1)))
                                         (car(x!1)),
                                         chain_offset
                                         (length(car(x!1)) + length(l1),
                                          cdr(x!1))))" "(: op2(1, rec(1 + length(l1), vr),
                                 expr_comp(1 + length(car(x!1))
                                           +
                                           length(l1),
                                           cdr(x!1))) :) " "lop1" "lop2" "input" "car(interm)") (("1" (expand "append" -1 3) (("1" (expand "append" -1 3) (("1" (expand "length" -1 8) (("1" (expand "length" -1 8) (("1" (expand "length" -1 11) (("1" (expand "length" -1 11) (("1" (expand "offset_rec" -1 4) (("1" (expand "offset_rec" -1 4) (("1" (assert) (("1" (inst -1 "l1" "x!1" "0" "input" "car(interm)" "length(l1)") (("1" (expand "chain_offset" -1) (("1" (expand "take" 2) (("1" (assert) (("1" (typepred "x!1") (("1" (assert) (("1" (expand "chain_of_appends" 2) (("1" (expand "length" 2) (("1" (inst -3 "0") (("1" (hide-all-but (-3 2)) (("1" (prop) (("1" (expand "semantic_rel") (("1" (expand "nth" -1 4) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2)) (("2" (typepred "interm") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "take" 1) (("2" (split) (("1" (assert) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "length" 2 (3 7)) (("2" (typepred "car(x!1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "expr_comp(length(car(x!1)) + length(l1),
                                  cdr(x!1))" "append(l1,
                                        append
                                        (map
                                         (offset_rec(length(l1)))
                                         (car(x!1)),
                                         chain_offset
                                         (length(car(x!1)) + length(l1),
                                          cdr(x!1))))" "(: op2(1, rec(1 + length(l1), vr),
                                 expr_comp(1 + length(car(x!1))
                                           +
                                           length(l1),
                                           cdr(x!1))) :)" "lop1" "lop2" "input" "list2nat(cdr(interm))") (("1" (expand "append" -1 3) (("1" (expand "append" -1 3) (("1" (expand "length" -1 9) (("1" (expand "length" -1 9) (("1" (expand "length" -1 12) (("1" (expand "length" -1 12) (("1" (rewrite "offset_rec_expr_comp") (("1" (assert) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "expr_comp(length(car(x!1)) + length(l1),
                                  cdr(x!1))" "append(l1,
                                        append
                                        (map
                                         (offset_rec(length(l1)))
                                         (car(x!1)),
                                         chain_offset
                                         (length(car(x!1)) + length(l1),
                                          cdr(x!1))))" "(: 
                                 expr_comp(1 + length(car(x!1))
                                           +
                                           length(l1),
                                           cdr(x!1)) :)" "lop1" "lop2" "input" "list2nat(cdr(interm))") (("1" (expand "append" -1 3) (("1" (expand "append" 1 1) (("1" (expand "length" 1 3) (("1" (expand "length" 1 3) (("1" (expand "length" 1 6) (("1" (expand "length" 1 6) (("1" (rewrite "offset_rec_expr_comp") (("1" (inst -2 "append(l1,map
                                         (offset_rec(length(l1)))
                                         (car(x!1)))" "input" "list2nat(cdr(interm))") (("1" (rewrite "append_assoc") (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (split) (("1" (expand "semantic_rel" -1 1) (("1" (expand "nth" -1 1) (("1" (assert) (("1" (inst 1 "cdr(interm)") (("1" (skeep) (("1" (inst -1 "i+1") (("1" (expand "nth" -1) (("1" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "interm") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 5)) (("2" (prop) (("1" (grind) nil nil) ("2" (typepred "l1") (("2" (typepred "car(x!1)") (("2" (expand "limited") (("2" (skeep) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (inst -7 "i") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst? -8) (("1" (assert) (("1" (rewrite "length_append") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_nth_rw") (("1" (rewrite "length_append") (("1" (inst -3 "i-length(l1)") (("1" (rewrite "map_length") (("1" (rewrite "valid_index_rec_offset" :dir rl) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("3" (inst -1 "0") (("1" (prop) (("1" (expand "list2nat" -2) (("1" (expand "length" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "interm") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "interm") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (map_length formula-decl nil more_map_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (map_append formula-decl nil map_append nil) (map_list_composition formula-decl nil map_props nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (map_nth_rw formula-decl nil more_map_props nil) (below type-eq-decl nil naturalnumbers nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (offset_composition2 formula-decl nil mf_pvs0_lang nil) (int_minus_int_is_int application-judgement "int" integers nil) (nth_append formula-decl nil more_list_props structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_append formula-decl nil list_props nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (length_singleton formula-decl nil more_list_props structures) (x!1 skolem-const-decl "(cons?[(limited)])" mf_pvs0_Turing_Completeness nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (list_cons_extensionality formula-decl nil list_adt nil) (interm skolem-const-decl "{interm: (cons?[nat]) | length(interm) = length(x!1)}" mf_pvs0_Turing_Completeness nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (interm skolem-const-decl "{interm: (cons?[nat]) | length(interm) = length(x!1)}" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "below[length(append[mf_PVS0Expr[nat]]
                 (l1,
                  map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                      (offset_rec[nat](length[mf_PVS0Expr[nat]](l1)))
                      (car[(limited)](x!1))))]" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "below[length(cdr(interm))]" mf_pvs0_Turing_Completeness nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (offset_rec_expr_comp formula-decl nil mf_pvs0_Turing_Completeness nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (i skolem-const-decl "below[length(append[mf_PVS0Expr[nat]]
                 (l1,
                  map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                      (offset_rec[nat](length[mf_PVS0Expr[nat]](l1)))
                      (car[(limited)](x!1))))]" mf_pvs0_Turing_Completeness nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (valarg1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (interm skolem-const-decl "{interm: (cons?[nat]) | length(interm) = length(cdr(x!1))}" mf_pvs0_Turing_Completeness nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "below[length(cons(valarg1, interm))]" mf_pvs0_Turing_Completeness nil) (limits_of_chain_offset formula-decl nil mf_pvs0_Turing_Completeness nil) (int_times_int_is_int application-judgement "int" integers nil) (take def-decl "list[T]" more_list_props structures) (chain_of_appends def-decl "list[T]" chain_of_appends nil) (even_times_int_is_even application-judgement "even_int" integers nil) (tuple2nat const-decl "nat" tuple2nat numbers) (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (append_assoc formula-decl nil list_props nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (l1 skolem-const-decl "(limited)" mf_pvs0_Turing_Completeness nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (list2nat def-decl "nat" mf_pvs0_Turing_Completeness nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (append def-decl "list[T]" list_props nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map adt-def-decl "list[T1]" list_adt_map nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (expr_comp def-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (comp_is_composition_TCC1 0 (comp_is_composition_TCC1-1 nil 3771257008 ("" (subtype-tcc) nil nil) ((pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (tuple2nat const-decl "nat" tuple2nat numbers) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (comp_is_composition subtype "mf_pvs0_Turing_Completeness.i" "below[length[nat](interm)]"))) (comp_is_composition 0 (comp_is_composition-1 nil 3771851634 ("" (skeep) (("" (prop) (("1" (expand "comp") (("1" (expand "chain_offset" -1) (("1" (lift-if) (("1" (prop) (("1" (typepred "l") (("1" (grind) nil nil)) nil) ("2" (expand "semantic_rel" -1) (("2" (expand "nth" -1) (("2" (expand "semantic_rel_expr" -1) (("2" (expand "length" -1 4) (("2" (case "1 < 1 + (length(f) + length(chain_offset(1 + length(f), l)))") (("1" (assert) (("1" (skeep) (("1" (expand "nth" -3) (("1" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(f,0)" "append(f,
                                                  chain_offset(length(f), l))" "(: rec(1,
                                               op2(1, cnst(length(l)), expr_comp(1+length(f), l))) :)" "lop1" "lop2" "valarg" "output") (("1" (expand "append" -1 2) (("1" (expand "append" -1 2) (("1" (expand "length" -1 4) (("1" (expand "length" -1 4) (("1" (expand "length" -1 5) (("1" (expand "length" -1 5) (("1" (rewrite "map_append") (("1" (rewrite "offset_rec_chain_offset") (("1" (assert) (("1" (expand "semantic_rel_expr" -6) (("1" (skeep) (("1" (expand "eval_op2" -8) (("1" (expand "lop2" -8) (("1" (expand "length" -8) (("1" (expand "length" -8) (("1" (assert) (("1" (expand "nth" -8) (("1" (expand "nth" -8) (("1" (expand "semantic_rel_expr" -6) (("1" (replaces -6) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "expr_comp(length(f),l)" "append(f,
                                                    chain_offset(length(f), l))" "(: rec(1,
                                                 op2(1, cnst(length(l)), expr_comp(1+length(f), l))) :)" "lop1" "lop2" "input" "valarg2") (("1" (expand "append" -1 2) (("1" (expand "append" -1 2) (("1" (expand "length" -1 5) (("1" (expand "length" -1 5) (("1" (expand "length" -1 6) (("1" (expand "length" -1 6) (("1" (rewrite "map_append") (("1" (rewrite "offset_rec_expr_comp") (("1" (rewrite "offset_rec_chain_offset") (("1" (assert) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "expr_comp(length(f), l)" " append(f, chain_offset(length(f), l))" "(: expr_comp(1+length(f), l) :)" "lop1" "lop2" "input" "valarg2") (("1" (expand "append" -1 2) (("1" (expand "append" -1 1) (("1" (expand "length" -1 2) (("1" (expand "length" -1 2) (("1" (expand "length" -1 3) (("1" (expand "length" -1 3) (("1" (rewrite "offset_rec_expr_comp") (("1" (lemma "chain_offset_prop") (("1" (inst -1 "f" "l" "input" "valarg2") (("1" (expand "semantic_rel" -1 1) (("1" (expand "nth" -1 1) (("1" (assert) (("1" (skeep) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(f,0)" "f" "chain_offset(length(f), l)" "lop1" "lop2" "valarg" "output") (("1" (assert) (("1" (inst 2 "interm") (("1" (prop) (("1" (inst -2 "0") (("1" (prop) (("1" (assert) (("1" (expand "semantic_rel" 1) (("1" (assert) (("1" (typepred "interm") (("1" (replace -3) (("1" (expand "length" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (skeep) (("2" (inst -2 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-7 1 2)) (("2" (expand "length" -1 1) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (typepred "l") (("2" (expand "chain_offset" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "f") (("3" (expand "limited") (("3" (assert) (("3" (prop) (("3" (inst -3 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel" 1) (("2" (expand "comp" 1) (("2" (expand "nth" 1) (("2" (expand "semantic_rel_expr" 1) (("2" (expand "length" 1 5) (("2" (case "1 < 1 + length(chain_offset(1, cons(f, l)))") (("1" (assert) (("1" (expand "nth" 1) (("1" (expand "chain_offset" 1 (2 3)) (("1" (case "length(cons(f, l)) = 1") (("1" (grind) nil nil) ("2" (assert) (("2" (rewrite "nth_append") (("1" (case " 0 < length(map(offset_rec(1))(f))") (("1" (assert) (("1" (rewrite "map_nth_rw") (("1" (skeep) (("1" (inst 2 "tuple2nat(length(interm), list2nat(interm))") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "length(l)" "list2nat(interm)") (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "eval_op2" 1) (("1" (prop) (("1" (expand "chain_offset" 1) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "expr_comp( length(f), l)" "append(f,
                                    chain_offset(length(f), l))" "(: rec(1,
                                 op2(1,
                                     cnst(length(l)),
                                     expr_comp(1 + length(f), l))) :)" "lop1" "lop2" "input" "list2nat(interm)") (("1" (expand "append" -1 2) (("1" (expand "append" -1 2) (("1" (expand "length" -1 5) (("1" (expand "length" -1 5) (("1" (expand "length" -1 6) (("1" (expand "length" -1 6) (("1" (rewrite "map_append") (("1" (rewrite "offset_rec_chain_offset") (("1" (rewrite "offset_rec_expr_comp") (("1" (assert) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "expr_comp( length(f), l)" "append(f,
                                    chain_offset(length(f), l))" "(: 
                                     expr_comp(1 + length(f), l) :)" "lop1" "lop2" "input" "list2nat(interm)") (("1" (expand "append" -1 2) (("1" (expand "append" 1 1) (("1" (expand "length" 1 2) (("1" (expand "length" 1 2) (("1" (expand "length" 1 3) (("1" (expand "length" 1 3) (("1" (rewrite "offset_rec_expr_comp") (("1" (lemma "chain_offset_prop") (("1" (inst -1 "f" "l" "input" "list2nat(interm)") (("1" (expand "semantic_rel" -1 1) (("1" (expand "nth" -1 1) (("1" (assert) (("1" (inst 1 "interm") (("1" (assert) (("1" (skeep) (("1" (inst -4 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "lop2" 1) (("2" (expand "length" 1 2) (("2" (expand "length" 1 2) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (typepred "interm") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(f,0)" "append(f,chain_offset(length(f),l))" "(: rec(1,
                                 op2(1,
                                     cnst(length(l)),
                                     expr_comp(1 + length(f), l))) :)" "lop1" "lop2" "tuple2nat(length(interm), list2nat(interm))" "output") (("1" (expand "append" -1 2) (("1" (expand "append" -1 2) (("1" (expand "length" -1 5) (("1" (expand "length" -1 5) (("1" (expand "length" -1 6) (("1" (expand "length" -1 6) (("1" (rewrite "map_append") (("1" (rewrite "offset_rec_chain_offset") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(f,0)" "f" "chain_offset(length(f), l)" "lop1" "lop2" "tuple2nat(length(interm), list2nat(interm))" "output") (("1" (assert) (("1" (expand "semantic_rel" -3) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "l") (("2" (expand "chain_offset" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "f") (("3" (expand "limited") (("3" (prop) (("3" (inst -3 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((chain_offset def-decl "list[mf_PVS0Expr[nat]]" mf_pvs0_Turing_Completeness nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (limited const-decl "bool" mf_pvs0_computable nil) (nth def-decl "T" list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (tuple2nat const-decl "nat" tuple2nat numbers) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (below type-eq-decl nil naturalnumbers nil) (map_nth_rw formula-decl nil more_map_props nil) (append def-decl "list[T]" list_props nil) (f skolem-const-decl "(limited)" mf_pvs0_Turing_Completeness nil) (l skolem-const-decl "(cons?[(limited)])" mf_pvs0_Turing_Completeness nil) (expr_comp def-decl "mf_PVS0Expr[nat]" mf_pvs0_Turing_Completeness nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (below type-eq-decl nil nat_types nil) (offset_rec_chain_offset formula-decl nil mf_pvs0_Turing_Completeness nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (TRUE const-decl "bool" booleans nil) (offset_rec_expr_comp formula-decl nil mf_pvs0_Turing_Completeness nil) (chain_offset_prop formula-decl nil mf_pvs0_Turing_Completeness nil) (add_rec_list2 formula-decl nil mf_pvs0_lang nil) (length_append formula-decl nil list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (map_length formula-decl nil more_map_props nil) (interm skolem-const-decl "{interm: (cons?[nat]) | length(interm) = length(l)}" mf_pvs0_Turing_Completeness nil) (= const-decl "[T, T -> boolean]" equalities nil) (map_append formula-decl nil map_append nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (nth_append formula-decl nil more_list_props structures) (map adt-def-decl "list[T1]" list_adt_map nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (comp const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (list2nat def-decl "nat" mf_pvs0_Turing_Completeness nil)) shostak)) (min_relation_works 0 (min_relation_works-1 nil 3774364520 ("" (skeep*) (("" (lemma "min_relation_induction") (("" (inst -1 "y" "f" "ans" "lambda(x : nat) : (semantic_rel(lop1, lop2, false_val, f)(tuple2nat(ans, y), 0) AND x <= ans AND
          (FORALL (i: nat | i >= x AND i < ans):
             EXISTS (k: posint):
               semantic_rel(lop1, lop2, false_val, f)(tuple2nat(i, y), k) AND k /= 0)) ") (("" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (inst?) (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (assert) (("3" (inst? -1) (("3" (assert) (("3" (prop) (("3" (inst? -2) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep 2) (("4" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skeep) (("3" (typepred "i") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skeep) (("3" (typepred "i") (("3" (assert) nil nil)) nil)) nil) ("4" (skeep) (("4" (assert) nil nil)) nil) ("5" (assert) (("5" (skeep) (("5" (case "i=x_1") (("1" (replaces -1) (("1" (skeep -1) (("1" (inst 1 "k_1") (("1" (case "k_1=0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (inst? -7) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep 2) (("6" (prop) (("1" (assert) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil) ("3" (skeep) (("3" (case "i=x_1") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("4" (assert) nil nil) ("5" (skeep) (("5" (case "i=x_1") (("1" (replaces -1) (("1" (skeep -1) (("1" (inst 1 "k_1") (("1" (case "k_1=0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (inst -7 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((min_relation_induction formula-decl nil mf_pvs0_Turing_Completeness nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (k_1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (= const-decl "[T, T -> boolean]" equalities nil) (k_1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (x_1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (ans skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "{i: nat | i >= x_1 AND i < ans}" mf_pvs0_Turing_Completeness nil) (/= const-decl "boolean" notequal nil) (posint nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (tuple2nat const-decl "nat" tuple2nat numbers) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (min_relation_leq 0 (min_relation_leq-1 nil 3774793758 ("" (lemma "min_relation_induction") (("" (skeep) (("" (inst -1 "y" "f" "ans" "lambda(n : nat):  n <= ans") (("" (prop) (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (<= const-decl "bool" reals nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (min_relation_induction formula-decl nil mf_pvs0_Turing_Completeness nil)) shostak)) (min_aux_TCC1 0 (min_aux_TCC1-1 nil 3771594815 ("" (skeep) (("" (expand "partial_recursive?") (("" (skeep) (("" (expand "length") (("" (expand "nth") (("" (lift-if) (("" (prop) (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (prop) (("1" (decompose-equality) (("1" (grind) nil nil)) nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "valid_index_rec_offset") (("2" (typepred "f") (("2" (expand "limited") (("2" (rewrite "map_nth_rw") (("1" (inst -3 "i-1") (("1" (inst -4 "nth(f,i-1)" "length(f)" "1") (("1" (assert) (("1" (rewrite "map_length") nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (expand "length" -1) (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((partial_recursive? const-decl "bool" mf_pvs0_computable nil) (length def-decl "nat" list_props nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (f skolem-const-decl "(limited[false_val, lop1, lop2])" mf_pvs0_Turing_Completeness nil) (i skolem-const-decl "below[length(cons[mf_PVS0Expr[nat]]
                 (ite[nat]
                      (rec[nat](1, vr[nat]),
                       rec[nat]
                           (0,
                            op2[nat]
                                (1, op1[nat](0, op1[nat](1, vr[nat])),
                                 op1[nat](2, vr[nat]))),
                       op1[nat](1, vr[nat])),
                  map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                      (offset_rec[nat](1))(f)))]" mf_pvs0_Turing_Completeness nil) (map_length formula-decl nil more_map_props nil) (below type-eq-decl nil nat_types nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map_nth_rw formula-decl nil more_map_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (limited const-decl "bool" mf_pvs0_computable nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (map adt-def-decl "list[T1]" list_adt_map nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (nth def-decl "T" list_props nil)) nil (min_aux subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].ite(mf_PVS0Expr_adt[nat].rec(1, mf_PVS0Expr_adt[nat].vr), mf_PVS0Expr_adt[nat].rec(0, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].op1(0, mf_PVS0Expr_adt[nat].op1(1, mf_PVS0Expr_adt[nat].vr)), mf_PVS0Expr_adt[nat].op1(2, mf_PVS0Expr_adt[nat].vr))), mf_PVS0Expr_adt[nat].op1(1, mf_PVS0Expr_adt[nat].vr)), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_Turing_Completeness.f)))" "partial_recursive[false_val, lop1, lop2]"))) (min_aux_leq_eval_expr_TCC1 0 (min_aux_leq_eval_expr_TCC1-1 nil 3775310495 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (limited const-decl "bool" mf_pvs0_computable nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (map adt-def-decl "list[T1]" list_adt_map nil) (min_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (length def-decl "nat" list_props nil)) nil (min_aux_leq_eval_expr subtype "0" "below[length[mf_PVS0Expr[nat]](min_aux(f)`4)]"))) (min_aux_leq_eval_expr 0 (min_aux_leq_eval_expr-1 nil 3775310495 ("" (measure-induct+ " n " ("n")) (("1" (skeep) (("1" (expand "min_aux" -2) (("1" (expand "nth" -2) (("1" (expand "eval_expr" -2) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (expand "eval_expr" -1) (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (expand "eval_expr" -2 2) (("1" (lift-if) (("1" (prop) (("1" (expand "eval_expr" -3 2) (("1" (lift-if) (("1" (prop) (("1" (expand "eval_expr" -2 2) (("1" (lift-if) (("1" (prop) (("1" (expand "eval_expr" -2 2) (("1" (expand "eval_expr" -2 2) (("1" (expand "eval_expr" -2 2) (("1" (expand "eval_expr" -2 2) (("1" (expand "eval_op1") (("1" (expand "lop1" -2 (3 4)) (("1" (expand "length" -2 (1 2)) (("1" (expand "length" -2 (1 2)) (("1" (assert) (("1" (expand "lop1" -2 5) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (assert) (("1" (expand "lop1" -2 (3 4 5)) (("1" (expand "nth" -2 (2 3 4)) (("1" (expand "nth" -2 (2 3)) (("1" (expand "nth" -2 (2)) (("1" (expand "pi1") (("1" (expand "pi2") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (expand "succ") (("1" (expand "eval_op2") (("1" (expand "lop2" -2 2) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (assert) (("1" (expand "lop2" -2 2) (("1" (expand "nth" -2 2) (("1" (expand "nth" -2 2) (("1" (inst -9 "x!1-1") (("1" (inst -9 "x+1" "y" "f" "ans") (("1" (assert) (("1" (expand "min_aux" 3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_expr" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_expr" 1) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (expand "eval_expr") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_expr" 1) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (expand "eval_expr" 1) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (expand "eval_expr" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_expr" 1) (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (expand "eval_expr" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (expand "eval_expr" -2) (("3" (lift-if) (("3" (prop) (("1" (expand "eval_expr" -2) (("1" (expand "eval_op1") (("1" (expand "lop1" -2) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (assert) (("1" (expand "nth" -2) (("1" (expand "nth" -2) (("1" (expand "pi1") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (decompose-equality -2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_expr" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ((val adt-accessor-decl "[(some?) -> T]" Maybe structures) (map adt-def-decl "list[T1]" list_adt_map nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (succ const-decl "nat" mf_pvs0_basic_programs nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (O const-decl "T3" function_props nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (length_singleton formula-decl nil more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (eval_op1 const-decl "Val" mf_pvs0_expr nil) (eval_expr_semantic_rel_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}" mf_pvs0_computable nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_computable nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (Some adt-constructor-decl "[T -> (some?)]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (tuple2nat const-decl "nat" tuple2nat numbers) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (limited const-decl "bool" mf_pvs0_computable nil) (length def-decl "nat" list_props nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (min_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (min_aux_leq 0 (min_aux_leq-1 nil 3774794347 ("" (skeep) (("" (lemma "semantic_rel_eval") (("" (inst?) (("" (assert) (("" (lemma "min_aux_leq_eval_expr") (("" (skeep) (("" (inst?) (("" (inst -1 "y" "f" "n") (("" (assert) (("" (replace -2) (("" (expand "eval" 1) (("" (assert) (("" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (semantic_rel_eval formula-decl nil mf_pvs0_lang nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (eval_expr def-decl "Maybe[Val]" mf_pvs0_expr nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (Some adt-constructor-decl "[T -> (some?)]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Maybe_Some_extensionality formula-decl nil Maybe structures) (eval const-decl "Maybe[Val]" mf_pvs0_lang nil) (eval_expr_semantic_rel_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}" mf_pvs0_computable nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    i > 0 AND FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env)}" mf_pvs0_computable nil) (min_aux_leq_eval_expr formula-decl nil mf_pvs0_Turing_Completeness nil) (min_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (tuple2nat const-decl "nat" tuple2nat numbers)) shostak)) (min_relation_works2 0 (min_relation_works2-1 nil 3775487172 ("" (measure-induct+ "if ans >= x then ans-x else 0 endif" ("ans" "x")) (("1" (skeep) (("1" (expand "min_relation" 1) (("1" (prop) (("1" (inst -5 "x!2") (("1" (skeep) (("1" (lemma "deterministic") (("1" (inst?) (("1" (inst -1 "k") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (inst -2 "x!1" "1+x!2") (("2" (assert) (("2" (inst -2 "y" "f") (("2" (assert) (("2" (skeep) (("2" (inst -4 "i") nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -4 "x!2") (("1" (skeep) (("1" (inst 1 "k") nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (deterministic formula-decl nil mf_pvs0_lang nil) (x!1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (x!2 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (min_relation inductive-decl "bool" mf_pvs0_Turing_Completeness nil) (/= const-decl "boolean" notequal nil) (<= const-decl "bool" reals nil) (tuple2nat const-decl "nat" tuple2nat numbers) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (min_aux_is_min_relation 0 (min_aux_is_min_relation-1 nil 3774634211 ("" (measure-induct+ "if ans >= x then ans - x else 0 endif" ("x" "ans")) (("1" (skeep) (("1" (prop) (("1" (lemma "min_relation_leq") (("1" (inst?) (("1" (assert) (("1" (assert) (("1" (expand "min_relation" -2) (("1" (prop) (("1" (expand "min_aux" 1) (("1" (expand "semantic_rel" 1) (("1" (expand "nth" 1) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "0") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "nth" 1) (("2" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(f,0)" "f" "(: ite(rec(1, vr),
                                 rec(0,
                                     op2
                                     (1, op1(0, op1(1, vr)), op1(2, vr))),
                                 op1(1, vr)) :)" "lop1" "lop2" "tuple2nat(x!1, y)" "0") (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (expand "semantic_rel" -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "false_val") (("2" (propax) nil nil)) nil) ("3" (expand "semantic_rel_expr" 1) (("3" (inst 1 "tuple2nat(x!1, y)") (("3" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "1+x!1" "x!2") (("2" (lemma "min_relation_leq") (("2" (inst -1 "1+x!1" "y" "f" "x!2") (("2" (assert) (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (expand "semantic_rel" 2) (("2" (expand "min_aux" 2) (("2" (expand "nth" 2) (("2" (expand "semantic_rel_expr" 2) (("2" (skeep) (("2" (inst 2 "k") (("2" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil) ("2" (expand "nth") (("2" (rewrite "map_nth_rw") (("1" (expand "semantic_rel" -3) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(f,0)" "f" "(: ite(rec(1, vr),
                                 rec(0,
                                     op2
                                     (1, op1(0, op1(1, vr)), op1(2, vr))),
                                 op1(1, vr)) :)" "lop1" "lop2" "tuple2nat(x!1, y)" "k") (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr" 2) (("2" (inst 2 "tuple2nat(x!1+1, y)") (("2" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "1+x!1" "y") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "x!1") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "succ") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(x!1, y)") (("2" (expand "semantic_rel_expr" 1) (("2" (expand "eval_op1") (("2" (expand "lop1" 1) (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2" 1) (("3" (expand "length" 1) (("3" (expand "length" 1) (("3" (assert) (("3" (expand "nth" 1) (("3" (expand "nth" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel") (("2" (expand "min_aux" -6) (("2" (assert) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("3" (expand "false_val" -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "min_aux_leq") (("2" (inst?) (("2" (assert) (("2" (assert) (("2" (expand "min_aux" -2) (("2" (expand "semantic_rel" -2) (("2" (expand "nth" -2) (("2" (expand "semantic_rel_expr" -2) (("2" (skeep) (("2" (expand "semantic_rel_expr" -2) (("2" (skeep) (("2" (expand "semantic_rel_expr" -2) (("2" (replaces -2) (("2" (prop) (("1" (expand "nth" -3) (("1" (rewrite "map_nth_rw") (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (replaces -1) (("1" (expand "eval_op1") (("1" (expand "lop1" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (expand "nth" -1 1) (("1" (expand "nth" -1 1) (("1" (expand "pi1") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -1) (("1" (expand "lop1" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (assert) (("1" (expand "nth" -1) (("1" (expand "succ") (("1" (replaces -1) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (replaces -1) (("1" (expand "eval_op1") (("1" (expand "lop1" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (expand "nth" -1) (("1" (expand "nth" -1) (("1" (expand "nth" -1) (("1" (expand "pi2") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -1) (("1" (expand "eval_op2") (("1" (expand "lop2" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (expand "nth" -1) (("1" (expand "nth" -1) (("1" (replaces -1) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(f,0)" "f" "(: ite(rec(1, vr),
                                 rec(0,
                                     op2
                                     (1, op1(0, op1(1, vr)), op1(2, vr))),
                                 op1(1, vr)) :)" "lop1" "lop2" "tuple2nat(x!1,y)" "valarg") (("1" (expand "append" -1 1) (("1" (expand "append" -1 1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (expand "min_relation" 2) (("1" (expand "semantic_rel" 2) (("1" (assert) (("1" (expand "false_val" 1) (("1" (assert) (("1" (prop) (("1" (use "deterministic_expr") (("1" (assert) nil nil)) nil) ("2" (lemma "min_aux_leq") (("2" (inst -1 "1+x!1" "y" "f" "x!2") (("2" (expand "min_aux" -1) (("2" (expand "semantic_rel" -1) (("2" (inst -8 "1+x!1" "x!2") (("2" (assert) (("2" (inst -8 "y" "f") (("2" (assert) (("2" (expand "min_aux" 4) (("2" (expand "semantic_rel" 4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst 1 "valarg") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (expand "nth" -4) (("2" (lemma "add_rec_list") (("2" (rewrite "map_nth_rw") (("1" (inst -1 "false_val" "nth(f,0)" "f" "(: ite(rec(1, vr),
                                 rec(0,
                                     op2
                                     (1, op1(0, op1(1, vr)), op1(2, vr))),
                                 op1(1, vr)) :)" "lop1" "lop2" "tuple2nat(x!1,y)" "valarg") (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (expand "semantic_rel_expr" -3) (("1" (skeep) (("1" (expand "semantic_rel_expr" -3) (("1" (replaces -3) (("1" (expand "eval_op1") (("1" (expand "lop1" -3) (("1" (expand "length" -3) (("1" (expand "length" -3) (("1" (assert) (("1" (expand "nth" -3) (("1" (expand "nth" -3) (("1" (expand "pi1") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (expand "min_relation" 1) (("1" (expand "false_val" -2) (("1" (replaces -2 :dir rl) (("1" (expand "semantic_rel" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (min_aux_leq formula-decl nil mf_pvs0_Turing_Completeness nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (deterministic_expr formula-decl nil mf_pvs0_expr nil) (min_relation_leq formula-decl nil mf_pvs0_Turing_Completeness nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (succ const-decl "nat" mf_pvs0_basic_programs nil) (nth def-decl "T" list_props nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (O const-decl "T3" function_props nil) (length_singleton formula-decl nil more_list_props structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (eval_op1 const-decl "Val" mf_pvs0_expr nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map_nth_rw formula-decl nil more_map_props nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (below type-eq-decl nil nat_types nil) (append def-decl "list[T]" list_props nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (map adt-def-decl "list[T1]" list_adt_map nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (tuple2nat const-decl "nat" tuple2nat numbers) (min_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (min_relation inductive-decl "bool" mf_pvs0_Turing_Completeness nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (min_aux_correctness 0 (min_aux_correctness-1 nil 3775573925 ("" (skeep) (("" (split) (("1" (flatten) (("1" (rewrite "min_aux_is_min_relation" :dir rl) (("1" (rewrite "min_relation_works") nil nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "min_aux_is_min_relation" :dir rl) (("2" (rewrite "min_relation_works2") (("2" (skeep) (("2" (inst? -3) (("2" (skeep) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((min_aux_is_min_relation formula-decl nil mf_pvs0_Turing_Completeness nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (limited const-decl "bool" mf_pvs0_computable nil) (min_relation_works formula-decl nil mf_pvs0_Turing_Completeness nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posint nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (min_relation_works2 formula-decl nil mf_pvs0_Turing_Completeness nil)) shostak)) (min_TCC1 0 (min_TCC1-1 nil 3768906966 ("" (skeep) (("" (typepred "f") (("" (expand "partial_recursive?") (("" (prop) (("1" (inst 1 "1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ("2" (skeep) (("2" (typepred "i") (("2" (expand "length") (("2" (rewrite "map_length") (("2" (expand "valid_index_rec") (("2" (skeep) (("2" (expand "nth") (("2" (lift-if) (("2" (prop) (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (prop) (("1" (decompose-equality) (("1" (replaces -1) (("1" (grind) nil nil)) nil)) nil) ("2" (decompose-equality) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "limited") (("2" (expand "valid_index_rec") (("2" (inst -5 "i-1") (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (length def-decl "nat" list_props nil)) nil (min subtype "mf_PVS0Expr_adt[real].rec(1, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].cnst(0), mf_PVS0Expr_adt[nat].vr))" "mf_PVS0Expr[nat]"))) (min_TCC2 0 (min_TCC2-1 nil 3771594815 ("" (skeep) (("" (expand "partial_recursive?") (("" (skeep) (("" (expand "length") (("" (rewrite "map_length") (("" (expand "nth") (("" (lift-if) (("" (prop) (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "min_aux(f)") (("2" (expand "partial_recursive?") (("2" (prop) (("2" (rewrite "map_nth_rw") (("1" (rewrite "valid_index_rec_offset" :dir rl) (("1" (assert) (("1" (typepred "i") (("1" (expand "length" -1) (("1" (rewrite "map_length") (("1" (assert) (("1" (inst -5 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((partial_recursive? const-decl "bool" mf_pvs0_computable nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (map adt-def-decl "list[T1]" list_adt_map nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (int_minus_int_is_int application-judgement "int" integers nil) (map_nth_rw formula-decl nil more_map_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (below type-eq-decl nil nat_types nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (min_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map_length formula-decl nil more_map_props nil)) nil (min subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[real].rec(1, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].cnst(0), mf_PVS0Expr_adt[nat].vr)), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_Turing_Completeness.min_aux(mf_pvs0_Turing_Completeness.f)`4)))" "partial_recursive[false_val, lop1, lop2]"))) (min_correctness 0 (min_correctness-1 nil 3775575565 ("" (skeep) (("" (lemma "min_aux_correctness") (("" (inst -1 "0" "y" "f" "ans") (("" (replaces -1 :dir rl) (("" (split) (("1" (flatten) (("1" (assert) (("1" (replace 1) (("1" (hide 1) (("1" (expand "min" -1) (("1" (expand "semantic_rel" -1) (("1" (expand "nth") (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (prop) (("1" (expand "semantic_rel_expr" -3) (("1" (skeep) (("1" (expand "semantic_rel_expr" -3) (("1" (replaces -3) (("1" (expand "semantic_rel_expr" -3) (("1" (replaces -3) (("1" (expand "eval_op2") (("1" (expand "lop2" -3) (("1" (expand "length" -3) (("1" (expand "length" -3) (("1" (assert) (("1" (expand "nth" -3) (("1" (expand "nth" -3) (("1" (replaces -3) (("1" (expand "nth") (("1" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(min_aux(f)`4,0)" "min_aux(f)`4" "(: rec(1, op2(1, cnst(0), vr)) :)" "lop1" "lop2" "tuple2nat(0,y)" "ans") (("1" (expand "append") (("1" (expand "append") (("1" (expand "length") (("1" (expand "length") (("1" (assert) (("1" (expand "semantic_rel") (("1" (case "(lop1, lop2, false_val, min_aux(f)`4) = min_aux(f)") (("1" (assert) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (replace -2) (("2" (hide -1 -2) (("2" (expand "min") (("2" (expand "semantic_rel" 1) (("2" (expand "nth") (("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(0,y)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "0" "y") (("1" (expand "semantic_rel_expr") (("1" (expand "eval_op2") (("1" (expand "lop2") (("1" (expand "length" 1) (("1" (expand "length" 1) (("1" (assert) (("1" (expand "nth") (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(min_aux(f)`4,0)" "min_aux(f)`4" "(: rec(1, op2(1, cnst(0), vr)) :)" "lop1" "lop2" "tuple2nat(0,y)" "ans") (("1" (expand "append") (("1" (expand "append") (("1" (expand "length") (("1" (expand "length") (("1" (assert) (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (hide-all-but (1 -2)) (("1" (expand "semantic_rel") (("1" (case "(lop1, lop2, false_val, min_aux(f)`4) = min_aux(f)") (("1" (replace -1) (("1" (propax) nil nil)) nil) ("2" (hide -1 2) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((min_aux_correctness formula-decl nil mf_pvs0_Turing_Completeness nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (TRUE const-decl "bool" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (min_aux const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map_nth_rw formula-decl nil more_map_props nil) (tuple2nat const-decl "nat" tuple2nat numbers) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (below type-eq-decl nil nat_types nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (map adt-def-decl "list[T1]" list_adt_map nil) (= const-decl "[T, T -> boolean]" equalities nil) (append def-decl "list[T]" list_props nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (nth def-decl "T" list_props nil) (min const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (f skolem-const-decl "(limited)" mf_pvs0_Turing_Completeness nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (prim_recurrence_relation_TCC1 0 (prim_recurrence_relation_TCC1-1 nil 3777215445 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (limited const-decl "bool" mf_pvs0_computable nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil (prim_recurrence_relation subtype "(number_fields.-)(mf_pvs0_Turing_Completeness.x, 1)" "nat"))) (prim_recurrence_TCC1 0 (prim_recurrence_TCC1-1 nil 3768906966 ("" (skeep) (("" (expand "partial_recursive?") (("" (skeep*) (("" (expand "nth" 1) (("" (lift-if) (("" (prop) (("1" (grind) (("1" (decompose-equality -4) nil nil) ("2" (decompose-equality -4) nil nil) ("3" (decompose-equality -4) (("3" (rewrite "length_append") (("3" (rewrite "length_append") (("3" (rewrite "map_length") (("3" (rewrite "map_length") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (decompose-equality -4) (("4" (rewrite "length_append") (("4" (rewrite "length_append") (("4" (rewrite "map_length") (("4" (rewrite "map_length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (expand "length" 1 1) (("1" (rewrite "length_append") (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (typepred "recur") (("1" (expand "limited" -3) (("1" (rewrite "map_nth_rw") (("1" (inst -3 "i-1") (("1" (lemma "valid_index_rec_offset") (("1" (inst -1 "nth(recur, i - 1)" "length(recur)" "1") (("1" (assert) (("1" (hide-all-but (-1 1 2)) (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (expand "length" 1 3) (("1" (rewrite "length_append") (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (typepred "final") (("1" (expand "limited" -3) (("1" (inst -3 "-1 - length(recur) + i") (("1" (lemma "valid_index_rec_offset") (("1" (inst -1 "nth(final, -1 - length(recur) + i)" "length(final)" "1 + length[mf_PVS0Expr[nat]](recur)") (("1" (assert) (("1" (hide-all-but (-1 1 2 3)) (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") nil nil)) nil) ("2" (rewrite "map_length") (("2" (expand "length" 2 5) (("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (typepred "sub1") (("2" (expand "partial_recursive?") (("2" (prop) (("2" (rewrite "map_nth_rw") (("1" (inst -4 "-1 - length(final) - length(recur) + i") (("1" (lemma "valid_index_rec_offset") (("1" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1 1) (("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "length" -1 1) (("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (typepred "i") (("2" (expand "length" -1 1) (("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (typepred "i") (("2" (expand "length" -1 1) (("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (nth def-decl "T" list_props nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (map_length formula-decl nil more_map_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_append formula-decl nil list_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (limited const-decl "bool" mf_pvs0_computable nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (append def-decl "list[T]" list_props nil) (sub1 const-decl "partial_recursive" mf_pvs0_basic_programs nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sub const-decl "partial_recursive" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (length def-decl "nat" list_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (below type-eq-decl nil naturalnumbers nil) (map_nth_rw formula-decl nil more_map_props nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (i skolem-const-decl "below[length(cons[mf_PVS0Expr[nat]]
                 (ite[nat]
                      (x,
                       recur_function(recursive_call(minus1(x), y),
                                      minus1(x),
                                      y),
                       final_function(y)),
                  append[mf_PVS0Expr[nat]]
                      (map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                           (offset_rec[nat](1))(recur),
                       append[mf_PVS0Expr[nat]]
                           (map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                                (offset_rec[nat]
                                     (1 + length[mf_PVS0Expr[nat]](recur)))
                                (final),
                            map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                                (offset_rec[nat]
                                     (1 + length[mf_PVS0Expr[nat]](final)
                                      +
                                      length[mf_PVS0Expr[nat]](recur)))
                                (sub1`4)))))]" mf_pvs0_Turing_Completeness nil) (final skolem-const-decl "(limited[false_val, lop1, lop2])" mf_pvs0_Turing_Completeness nil) (recur skolem-const-decl "(limited[false_val, lop1, lop2])" mf_pvs0_Turing_Completeness nil) (final_function skolem-const-decl "[mf_PVS0Expr[nat] -> (rec?)]" mf_pvs0_Turing_Completeness nil) (y skolem-const-decl "(op1?[nat])" mf_pvs0_Turing_Completeness nil) (minus1 skolem-const-decl "[mf_PVS0Expr[nat] -> (rec?)]" mf_pvs0_Turing_Completeness nil) (recursive_call skolem-const-decl "[[mf_PVS0Expr[nat], mf_PVS0Expr[nat]] -> (rec?)]" mf_pvs0_Turing_Completeness nil) (recur_function skolem-const-decl "[[mf_PVS0Expr[nat], mf_PVS0Expr[nat], mf_PVS0Expr[nat]] -> (rec?)]" mf_pvs0_Turing_Completeness nil) (x skolem-const-decl "(op1?[nat])" mf_pvs0_Turing_Completeness nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (nth_append formula-decl nil more_list_props structures) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (prim_recurrence subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].ite(mf_pvs0_Turing_Completeness.x, mf_pvs0_Turing_Completeness.recur_function(mf_pvs0_Turing_Completeness.recursive_call(mf_pvs0_Turing_Completeness.minus1(mf_pvs0_Turing_Completeness.x), mf_pvs0_Turing_Completeness.y), mf_pvs0_Turing_Completeness.minus1(mf_pvs0_Turing_Completeness.x), mf_pvs0_Turing_Completeness.y), mf_pvs0_Turing_Completeness.final_function(mf_pvs0_Turing_Completeness.y)), list_props[mf_PVS0Expr[nat]].append(list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_Turing_Completeness.recur), list_props[mf_PVS0Expr[nat]].append(list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec((number_fields.+)(1, list_props[mf_PVS0Expr[nat]].length(mf_pvs0_Turing_Completeness.recur))))(mf_pvs0_Turing_Completeness.final), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec((number_fields.+)((number_fields.+)(1, list_props[mf_PVS0Expr[nat]].length(mf_pvs0_Turing_Completeness.recur)), list_props[mf_PVS0Expr[nat]].length(mf_pvs0_Turing_Completeness.final))))(mf_pvs0_basic_programs.sub1`4)))))" "partial_recursive[false_val, lop1, lop2]"))) (prim_recurrence_is_prim_recurrence_relation 0 (prim_recurrence_is_prim_recurrence_relation-1 nil 3776697612 ("" (measure-induct+ "x" "x") (("" (skeep) (("" (prop) (("1" (expand "prim_recurrence_relation" 1) (("1" (prop) (("1" (expand "semantic_rel" -1) (("1" (expand "prim_recurrence" -1 2) (("1" (expand "nth") (("1" (expand "semantic_rel_expr") (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep -1) (("1" (expand "semantic_rel_expr" -1) (("1" (replaces -1) (("1" (expand "eval_op1") (("1" (expand "prim_recurrence" -1) (("1" (expand "lop1" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "pi1") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -1) (("1" (expand "prim_recurrence" -1 1) (("1" (expand "false_val" -1) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (replaces -1) (("1" (expand "eval_op1" -1) (("1" (expand "prim_recurrence" -1) (("1" (expand "lop1" -1) (("1" (expand "length" -1) (("1" (expand "length" -1) (("1" (expand "nth" -1) (("1" (expand "nth" -1) (("1" (expand "pi1") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -1) (("1" (expand "prim_recurrence" -1 1) (("1" (expand "length" -1 3) (("1" (rewrite "length_append") (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (expand "prim_recurrence" -2 2) (("1" (expand "nth" -2) (("1" (rewrite "nth_append") (("1" (rewrite "map_length") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "nth_append") (("1" (rewrite "map_length") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lemma "add_rec_list") (("2" (expand "prim_recurrence" -2) (("2" (inst -1 "false_val" "nth(sub1`4,0)" "sub1`4" "cons(ite(op1[nat](1, vr),
                                                 rec[nat]
                                                     (1,
                                                      op2[nat]
                                                      (1,
                                                       rec[nat]
                                                       (0,
                                                        op2[nat]
                                                        (1,
                                                         rec
                                                         (1 + length(final)
                                                          +
                                                          length(recur),
                                                          op1[nat](1, vr)),
                                                         op1[nat](2, vr))),
                                                       op2[nat]
                                                       (1,
                                                        rec
                                                        (1 + length(final) + length(recur),
                                                         op1[nat](1, vr)),
                                                        op1[nat](2, vr)))),
                                                 rec[nat]
                                                     (1 + length(recur), op1[nat](2, vr))),append(map(offset_rec(1))(recur),
                                                    map
                                                     (offset_rec(1 + length(recur)))
                                                     (final) ))" "lop1" "lop2" "x!1" "valarg1!1") (("2" (expand "append" -1 1) (("2" (expand "length" -1 7) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (expand "length" -1 9) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_nth_rw") (("2" (rewrite "append_assoc") (("2" (assert) (("2" (hide -2) (("2" (lemma "sub1_works") (("2" (inst -1 "x!1") (("2" (expand "semantic_rel" -1) (("2" (lemma "deterministic_expr") (("2" (inst -1 "sub1" "x!1" "nth(sub1`4,0)" "sub_function(x!1,1)" "valarg1!1") (("2" (case "(lop1, lop2, false_val, sub1`4) = sub1") (("1" (replaces -1) (("1" (assert) (("1" (hide -2 -3) (("1" (replaces -1 :dir rl) (("1" (expand "semantic_rel_expr" -2) (("1" (skeep) (("1" (expand "semantic_rel_expr" -2) (("1" (replaces -2) (("1" (expand "eval_op1" -2) (("1" (expand "prim_recurrence" -2) (("1" (expand "lop1" -2) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (assert) (("1" (expand "nth" -2) (("1" (expand "nth" -2) (("1" (expand "nth" -2) (("1" (expand "pi2") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -2) (("1" (expand "sub_function") (("1" (assert) (("1" (case "IF x!1 > 1 THEN x!1 - 1 ELSE 0 ENDIF = IF x!1 > 0 THEN x!1 - 1 ELSE 0 ENDIF") (("1" (replaces -1) (("1" (assert) (("1" (expand "eval_op2" -2) (("1" (expand "prim_recurrence" -2) (("1" (expand "lop2" -2) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (assert) (("1" (expand "nth" -2) (("1" (expand "nth" -2) (("1" (replaces -2) (("1" (expand "prim_recurrence" -2 1) (("1" (expand "length" -2 1) (("1" (assert) (("1" (split) (("1" (flatten) (("1" (expand "semantic_rel_expr" -4) (("1" (skeep) (("1" (expand "prim_recurrence" -4) (("1" (expand "semantic_rel_expr" -4) (("1" (skeep) (("1" (split) (("1" (flatten) (("1" (expand "nth" -2) (("1" (rewrite "nth_append") (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (hide-all-but -1) (("1" (rewrite "map_length") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (rewrite "map_length") (("2" (assert) (("2" (rewrite "nth_append") (("1" (rewrite "map_length") (("1" (assert) (("1" (lemma "add_rec_list") (("1" (expand "semantic_rel_expr" -7) (("1" (skeep) (("1" (expand "semantic_rel_expr" -7) (("1" (hide -3) (("1" (replaces -6) (("1" (expand "eval_op1" -6) (("1" (expand "lop1" -6) (("1" (expand "length" -6) (("1" (expand "length" -6) (("1" (expand "nth" -6) (("1" (expand "nth" -6) (("1" (expand "pi1") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -6) (("1" (inst -1 "false_val" "nth(sub1`4,0)" "sub1`4" "cons(ite(op1[nat](1, vr),
                                                               rec[nat]
                                                                   (1,
                                                                    op2[nat]
                                                                    (1,
                                                                     rec[nat]
                                                                     (0,
                                                                      op2[nat]
                                                                      (1,
                                                                       rec
                                                                       (1 + length(final)
                                                                        +
                                                                        length(recur),
                                                                        op1[nat](1, vr)),
                                                                       op1[nat](2, vr))),
                                                                     op2[nat]
                                                                     (1,
                                                                      rec
                                                                      (1 + length(final) + length(recur),
                                                                       op1[nat](1, vr)),
                                                                      op1[nat](2, vr)))),
                                                               rec[nat]
                                                                   (1 + length(recur), op1[nat](2, vr))),append(map(offset_rec(1))(recur),
                                                                  map
                                                                   (offset_rec(1 + length(recur)))
                                                                   (final)))" "lop1" "lop2" "x!1" "valarg1!2") (("1" (expand "append" -1 1) (("1" (expand "length" -1 7) (("1" (expand "length" -1 9) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (rewrite "append_assoc") (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (lemma "sub1_works") (("1" (hide -3) (("1" (inst -1 "x!1") (("1" (case "(lop1, lop2, false_val, sub1`4) = sub1") (("1" (replaces -1) (("1" (expand "semantic_rel" -1) (("1" (lemma "deterministic_expr") (("1" (inst -1 "sub1" "x!1" "nth(sub1`4,0)" "valarg1!2" "sub_function(x!1, 1)") (("1" (assert) (("1" (replaces -1) (("1" (expand "sub_function" -7) (("1" (case "IF x!1 > 1 THEN x!1 - 1 ELSE 0 ENDIF = IF x!1 > 0 THEN x!1 - 1 ELSE 0 ENDIF") (("1" (replaces -1) (("1" (assert) (("1" (expand "semantic_rel_expr" -6) (("1" (skeep) (("1" (expand "semantic_rel_expr" -6) (("1" (replaces -6) (("1" (expand "eval_op1" -6) (("1" (expand "prim_recurrence" -6) (("1" (expand "lop1" -6) (("1" (expand "length" -6) (("1" (expand "length" -6) (("1" (expand "length" -6) (("1" (expand "nth" -6) (("1" (expand "nth" -6) (("1" (expand "nth" -6) (("1" (expand "pi2") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -6) (("1" (expand "eval_op2" -6) (("1" (expand "prim_recurrence" -6) (("1" (expand "lop2" -6) (("1" (expand "length" -6) (("1" (expand "length" -6) (("1" (expand "nth" -6) (("1" (expand "nth" -6) (("1" (replaces -6) (("1" (expand "eval_op2" -6) (("1" (expand "prim_recurrence" -6) (("1" (expand "lop2" -6) (("1" (expand "length" -6) (("1" (expand "length" -6) (("1" (expand "nth" -6) (("1" (expand "nth" -6) (("1" (prop) (("1" (expand "prim_recurrence" -2) (("1" (expand "nth" -2) (("1" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(recur,0)" " append(recur,
                                                                            append
                                                                            (map
                                                                             (offset_rec(length(recur)))
                                                                             (final),
                                                                             map
                                                                             (offset_rec
                                                                              (length(final) + length(recur)))
                                                                             (sub1`4)))" "(: ite(op1[nat](1, vr),
                                                                         rec[nat]
                                                                             (1,
                                                                              op2[nat]
                                                                              (1,
                                                                               rec[nat]
                                                                               (0,
                                                                                op2[nat]
                                                                                (1,
                                                                                 rec
                                                                                 (1 + length(final)
                                                                                  +
                                                                                  length(recur),
                                                                                  op1[nat](1, vr)),
                                                                                 op1[nat](2, vr))),
                                                                               op2[nat]
                                                                               (1,
                                                                                rec
                                                                                (1 + length(final) + length(recur),
                                                                                 op1[nat](1, vr)),
                                                                                op1[nat](2, vr)))),
                                                                         rec[nat]
                                                                             (1 + length(recur), op1[nat](2, vr))) :)" "lop1" "lop2" "valarg!1" "ans") (("1" (expand "append" -1 3) (("1" (expand "append" -1 3) (("1" (expand "length" -1 9) (("1" (expand "length" -1 9) (("1" (expand "length" -1 12) (("1" (expand "length" -1 12) (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (rewrite "map_append") (("1" (rewrite "map_append") (("1" (rewrite "map_list_composition") (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (rewrite "offset_composition2") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(recur,0)" "recur" "append(map
                                                                                (offset_rec(length(recur)))(final),
                                                                                map
                                                                                (offset_rec
                                                                                 (length(final) + length(recur)))
                                                                                (sub1`4))" "lop1" "lop2" "valarg!1" "ans") (("1" (assert) (("1" (inst -12 "x!1-1") (("1" (inst -12 "recur" "final" "y" "valarg1") (("1" (assert) (("1" (expand "semantic_rel" -12) (("1" (inst 5 "valarg1") (("1" (replaces -11) (("1" (expand "semantic_rel" 5) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (hide-all-but 1) (("3" (typepred "recur") (("3" (expand "limited" -3) (("3" (prop) (("3" (inst -3 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 5)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (flatten) (("2" (expand "length" 1 3) (("2" (rewrite "length_append") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length" 1) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (prop) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel" -2) (("2" (expand "prim_recurrence" -2 2) (("2" (expand "nth" -2) (("2" (expand "semantic_rel_expr" -2) (("2" (replaces -1) (("2" (skeep) (("2" (expand "semantic_rel_expr" -1) (("2" (skeep) (("2" (expand "semantic_rel_expr" -1) (("2" (replaces -1) (("2" (expand "eval_op1" -1) (("2" (expand "prim_recurrence" -1) (("2" (expand "lop1" -1) (("2" (expand "length" -1) (("2" (expand "length" -1) (("2" (assert) (("2" (expand "nth" -1) (("2" (expand "nth" -1) (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) (("2" (replaces -1) (("2" (expand "prim_recurrence" -1 1) (("2" (expand "false_val" -1 1) (("2" (expand "prim_recurrence" -1) (("2" (expand "semantic_rel_expr" -1) (("2" (skeep) (("2" (prop) (("1" (expand "nth" -2) (("1" (rewrite "nth_append") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (rewrite "map_length") (("1" (grind) nil nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (assert) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(final,0)" " append
                                                      (final,
                                                       map
                                                       (offset_rec
                                                        ( length(final) ))
                                                       (sub1`4))" "cons(ite(op1[nat](1, vr),
                                                   rec[nat]
                                                       (1,
                                                        op2[nat]
                                                        (1,
                                                         rec[nat]
                                                         (0,
                                                          op2[nat]
                                                          (1,
                                                           rec
                                                           (1 + length(final)
                                                            +
                                                            length(recur),
                                                            op1[nat](1, vr)),
                                                           op1[nat](2, vr))),
                                                         op2[nat]
                                                         (1,
                                                          rec
                                                          (1 + length(final) + length(recur),
                                                           op1[nat](1, vr)),
                                                          op1[nat](2, vr)))),
                                                   rec[nat]
                                                       (1 + length(recur), op1[nat](2, vr))),
                                               map(offset_rec(1))(recur))" "lop1" "lop2" "valarg!1" "ans") (("1" (expand "append" -1 2) (("1" (expand "length" -1 7) (("1" (expand "length" -1 9) (("1" (rewrite "map_length") (("1" (rewrite "map_append") (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(final,0)" "final" "map(offset_rec(length(final)))(sub1`4)" "lop1" "lop2" " valarg!1" "ans") (("1" (assert) (("1" (expand "semantic_rel_expr" -6) (("1" (skeep) (("1" (expand "semantic_rel_expr" -6) (("1" (replaces -6) (("1" (expand "eval_op1" -6) (("1" (expand "lop1" -6) (("1" (expand "length" -6) (("1" (expand "length" -6) (("1" (expand "length" -6) (("1" (assert) (("1" (expand "nth" -6) (("1" (expand "nth" -6) (("1" (expand "nth" -6) (("1" (expand "pi2") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -6) (("1" (expand "semantic_rel" 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (hide-all-but 1) (("3" (typepred "final") (("3" (expand "limited") (("3" (prop) (("3" (inst -3 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length" 1 2) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "prim_recurrence_relation" -1) (("2" (prop) (("1" (skeep) (("1" (expand "semantic_rel") (("1" (expand "prim_recurrence" 2 2) (("1" (expand "nth" 2) (("1" (expand "semantic_rel_expr" 2) (("1" (inst 2 "x!1") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "prim_recurrence" 1) (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr" 2) (("2" (inst 2 "tuple2nat(z, tuple2nat(x!1 - 1, y))") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "z" "tuple2nat(x!1 - 1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "tuple2nat(x!1 - 1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "x!1-1" "y") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "x!1") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "prim_recurrence" 1) (("2" (expand "lop1") (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "prim_recurrence" 1 2) (("2" (expand "nth" 1) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (rewrite "map_length") (("2" (grind) nil nil)) nil) ("3" (rewrite "map_length") (("3" (assert) (("3" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_length") (("1" (grind) nil nil)) nil) ("2" (rewrite "map_length") (("2" (assert) (("2" (expand "prim_recurrence" 2) (("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(sub1`4,0)" "sub1`4" "cons(ite(op1[nat](1, vr),
                                                                   rec[nat]
                                                                       (1,
                                                                        op2[nat]
                                                                        (1,
                                                                         rec[nat]
                                                                         (0,
                                                                          op2[nat]
                                                                          (1,
                                                                           rec
                                                                           (1 + length(final)
                                                                            +
                                                                            length(recur),
                                                                            op1[nat](1, vr)),
                                                                           op1[nat](2, vr))),
                                                                         op2[nat]
                                                                         (1,
                                                                          rec
                                                                          (1 + length(final) + length(recur),
                                                                           op1[nat](1, vr)),
                                                                          op1[nat](2, vr)))),
                                                                   rec[nat]
                                                                       (1 + length(recur), op1[nat](2, vr))),
                                                               append(map(offset_rec(1))(recur),
                                                                      map
                                                                       (offset_rec(1 + length(recur)))
                                                                       (final)))" "lop1" "lop2" "x!1" "x!1-1") (("1" (expand "append" -1 1) (("1" (expand "length" -1 7) (("1" (expand "length" -1 9) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (rewrite "append_assoc") (("1" (assert) (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (lemma "sub1_works") (("1" (inst -1 "x!1") (("1" (expand "sub_function") (("1" (case "IF x!1 > 1 THEN x!1 - 1 ELSE 0 ENDIF = IF x!1 > 0 THEN x!1 - 1 ELSE 0 ENDIF") (("1" (replaces -1) (("1" (assert) (("1" (expand "semantic_rel") (("1" (case "(lop1, lop2, false_val, sub1`4) = sub1") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "prim_recurrence" 1) (("3" (expand "length" 1 3) (("3" (rewrite "length_append") (("3" (rewrite "length_append") (("3" (rewrite "map_length") (("3" (rewrite "map_length") (("3" (rewrite "map_length") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr" 1) (("2" (inst 1 "tuple2nat(x!1, y)") (("2" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "prim_recurrence" 1) (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "prim_recurrence" 1) (("3" (expand "lop2" 1) (("3" (expand "length" 1) (("3" (expand "length" 1) (("3" (assert) (("3" (expand "nth" 1) (("3" (expand "nth" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (inst -4 "x!1-1") (("1" (inst -4 "recur" "final" "y" "z") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("3" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (expand "semantic_rel_expr" 1) (("2" (inst 1 "x!1-1" "y") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "x!1") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "prim_recurrence" 1) (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "prim_recurrence" 1 2) (("2" (expand "nth" 1) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (rewrite "map_length") (("2" (grind) nil nil)) nil) ("3" (rewrite "map_length") (("3" (assert) (("3" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_length") (("1" (assert) nil nil)) nil) ("2" (rewrite "map_length") (("2" (assert) (("2" (expand "prim_recurrence" 2) (("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(sub1`4,0)" "sub1`4" "cons(ite(op1[nat](1, vr),
                                                               rec[nat]
                                                                   (1,
                                                                    op2[nat]
                                                                    (1,
                                                                     rec[nat]
                                                                     (0,
                                                                      op2[nat]
                                                                      (1,
                                                                       rec
                                                                       (1 + length(final)
                                                                        +
                                                                        length(recur),
                                                                        op1[nat](1, vr)),
                                                                       op1[nat](2, vr))),
                                                                     op2[nat]
                                                                     (1,
                                                                      rec
                                                                      (1 + length(final) + length(recur),
                                                                       op1[nat](1, vr)),
                                                                      op1[nat](2, vr)))),
                                                               rec[nat]
                                                                   (1 + length(recur), op1[nat](2, vr))),
                                                           append(map(offset_rec(1))(recur),
                                                                  map
                                                                   (offset_rec(1 + length(recur)))
                                                                   (final)))" "lop1" "lop2" "x!1" "x!1-1") (("1" (expand "append" -1 1) (("1" (expand "length" -1 7) (("1" (expand "length" -1 9) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (rewrite "append_assoc") (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (lemma "sub1_works") (("1" (inst -1 "x!1") (("1" (expand "sub_function") (("1" (case "IF x!1 > 1 THEN x!1 - 1 ELSE 0 ENDIF =IF x!1 > 0 THEN x!1 - 1 ELSE 0 ENDIF") (("1" (replaces -1) (("1" (assert) (("1" (expand "semantic_rel" -1) (("1" (case "(lop1, lop2, false_val, sub1`4) = sub1") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 8)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (hide-all-but 1) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "prim_recurrence") (("3" (expand "length" 1 3) (("3" (rewrite "length_append") (("3" (rewrite "length_append") (("3" (rewrite "map_length") (("3" (rewrite "map_length") (("3" (rewrite "map_length") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr" 1) (("2" (inst 1 "tuple2nat(x!1, y)") (("2" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "prim_recurrence" 1) (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "prim_recurrence" 1) (("3" (expand "lop2" 1) (("3" (expand "length" 1) (("3" (expand "length" 1) (("3" (assert) (("3" (expand "nth" 1) (("3" (expand "nth" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "prim_recurrence" 1) (("3" (expand "lop2" 1) (("3" (expand "length" 1) (("3" (expand "length" 1) (("3" (assert) (("3" (expand "nth" 1) (("3" (expand "nth" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (expand "prim_recurrence" 1 2) (("2" (expand "nth" 1) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (expand "prim_recurrence" 1) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(recur,0)" " append(recur,
                                                    append
                                                    (map
                                                     (offset_rec( length(recur)))
                                                     (final),
                                                     map
                                                     (offset_rec
                                                      (length(final) + length(recur)))
                                                     (sub1`4)))" "(: ite(op1[nat](1, vr),
                                                 rec[nat]
                                                     (1,
                                                      op2[nat]
                                                      (1,
                                                       rec[nat]
                                                       (0,
                                                        op2[nat]
                                                        (1,
                                                         rec
                                                         (1 + length(final)
                                                          +
                                                          length(recur),
                                                          op1[nat](1, vr)),
                                                         op1[nat](2, vr))),
                                                       op2[nat]
                                                       (1,
                                                        rec
                                                        (1 + length(final) + length(recur),
                                                         op1[nat](1, vr)),
                                                        op1[nat](2, vr)))),
                                                 rec[nat]
                                                     (1 + length(recur), op1[nat](2, vr))) :)" "lop1" "lop2" "tuple2nat(z, tuple2nat(x!1 - 1, y))" "ans") (("1" (expand "append" -1 3) (("1" (expand "append" -1 3) (("1" (expand "length" -1 9) (("1" (expand "length" -1 9) (("1" (expand "length" -1 12) (("1" (expand "length" -1 12) (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (rewrite "map_append") (("1" (rewrite "map_append") (("1" (rewrite "map_list_composition") (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (rewrite "offset_composition2") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(recur,0)" "recur" "append(map
                                                        (offset_rec(length(recur)))(final),
                                                        map
                                                        (offset_rec
                                                         (length(final) + length(recur)))
                                                        (sub1`4))" "lop1" "lop2" "tuple2nat(z, tuple2nat(x!1 - 1, y))" "ans") (("1" (assert) nil nil) ("2" (grind) nil nil) ("3" (hide-all-but 1) (("3" (typepred "recur") (("3" (expand "limited" -3) (("3" (prop) (("3" (inst -3 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (expand "prim_recurrence" -1) (("3" (expand "false_val" -1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel" 1) (("2" (expand "prim_recurrence" 1 2) (("2" (expand "nth" 1) (("2" (expand "semantic_rel_expr") (("2" (inst 1 "x!1") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "prim_recurrence" 1) (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "prim_recurrence" 1) (("2" (expand "false_val" 1) (("2" (assert) nil nil)) nil)) nil) ("3" (expand "semantic_rel_expr") (("3" (inst 1 "y") (("3" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "prim_recurrence" 1) (("2" (expand "lop1" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (assert) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "nth" 1) (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "prim_recurrence" 1 2) (("2" (expand "nth" 1) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (rewrite "map_length") (("2" (grind) nil nil)) nil) ("3" (rewrite "map_length") (("3" (assert) (("3" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (expand "prim_recurrence" 1) (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(final,0)" " append
                                                      (final,
                                                       map
                                                       (offset_rec
                                                        ( length(final) ))
                                                       (sub1`4))" "cons(ite(op1[nat](1, vr),
                                                   rec[nat]
                                                       (1,
                                                        op2[nat]
                                                        (1,
                                                         rec[nat]
                                                         (0,
                                                          op2[nat]
                                                          (1,
                                                           rec
                                                           (1 + length(final)
                                                            +
                                                            length(recur),
                                                            op1[nat](1, vr)),
                                                           op1[nat](2, vr))),
                                                         op2[nat]
                                                         (1,
                                                          rec
                                                          (1 + length(final) + length(recur),
                                                           op1[nat](1, vr)),
                                                          op1[nat](2, vr)))),
                                                   rec[nat]
                                                       (1 + length(recur), op1[nat](2, vr))),
                                               map(offset_rec(1))(recur))" "lop1" "lop2" "y" "ans") (("1" (expand "append" -1 2) (("1" (expand "length" -1 7) (("1" (expand "length" -1 9) (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (rewrite "map_nth_rw") (("1" (rewrite "map_append") (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(final,0)" "final" "map(offset_rec(length(final)))(sub1`4)" "lop1" "lop2" "y" "ans") (("1" (assert) (("1" (expand "semantic_rel" -5) (("1" (propax) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (hide-all-but 1) (("3" (typepred "final") (("3" (expand "limited") (("3" (prop) (("3" (inst -3 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand "prim_recurrence" 1) (("3" (expand "length" 1 2) (("3" (rewrite "length_append") (("3" (rewrite "map_length") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((x!1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (nth def-decl "T" list_props nil) (TRUE const-decl "bool" booleans nil) (length def-decl "nat" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length_singleton formula-decl nil more_list_props structures) (O const-decl "T3" function_props nil) (sub1 const-decl "partial_recursive" mf_pvs0_basic_programs nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (append def-decl "list[T]" list_props nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map adt-def-decl "list[T1]" list_adt_map nil) (length_append formula-decl nil list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (map_length formula-decl nil more_map_props nil) (nth_append formula-decl nil more_list_props structures) (append_assoc formula-decl nil list_props nil) (deterministic_expr formula-decl nil mf_pvs0_expr nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (> const-decl "bool" reals nil) (map_append formula-decl nil map_append nil) (map_list_composition formula-decl nil map_props nil) (offset_composition2 formula-decl nil mf_pvs0_lang nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (sub const-decl "partial_recursive" mf_pvs0_basic_programs nil) (NOT const-decl "[bool -> bool]" booleans nil) (add_rec_list2 formula-decl nil mf_pvs0_lang nil) (final skolem-const-decl "(limited)" mf_pvs0_Turing_Completeness nil) (recur skolem-const-decl "(limited)" mf_pvs0_Turing_Completeness nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (sub_function const-decl "nat" mf_pvs0_basic_programs nil) (sub1_works formula-decl nil mf_pvs0_basic_programs nil) (map_nth_rw formula-decl nil more_map_props nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (eval_op1 const-decl "Val" mf_pvs0_expr nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (prim_recurrence_relation inductive-decl "bool" mf_pvs0_Turing_Completeness nil) (tuple2nat const-decl "nat" tuple2nat numbers) (prim_recurrence const-decl "partial_recursive" mf_pvs0_Turing_Completeness nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil)) (prim_recurrence_relation_works_TCC1 0 (prim_recurrence_relation_works_TCC1-1 nil 3776610672 ("" (subtype-tcc) nil nil) nil nil (prim_recurrence_relation_works subtype "(number_fields.-)(list_props[nat].length(mf_pvs0_Turing_Completeness.l), 1)" "below[length[nat](l)]"))) (prim_recurrence_relation_works_TCC2 0 (prim_recurrence_relation_works_TCC2-1 nil 3776610672 ("" (subtype-tcc) nil nil) nil nil (prim_recurrence_relation_works subtype "0" "below[length[nat](l)]"))) (prim_recurrence_relation_works_TCC3 0 (prim_recurrence_relation_works_TCC3-1 nil 3776610672 ("" (subtype-tcc) nil nil) ((pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil)) nil (prim_recurrence_relation_works subtype "(number_fields.-)(list_props[nat].length(mf_pvs0_Turing_Completeness.l), 1)" "nat"))) (prim_recurrence_relation_works_TCC4 0 (prim_recurrence_relation_works_TCC4-1 nil 3776610672 ("" (subtype-tcc) nil nil) ((pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil)) nil (prim_recurrence_relation_works subtype "mf_pvs0_Turing_Completeness.i" "below[length[nat](l)]"))) (prim_recurrence_relation_works_TCC5 0 (prim_recurrence_relation_works_TCC5-1 nil 3776610672 ("" (subtype-tcc) nil nil) ((pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil)) nil (prim_recurrence_relation_works subtype "(number_fields.+)(mf_pvs0_Turing_Completeness.i, 1)" "below[length[nat](l)]"))) (prim_recurrence_relation_works 0 (prim_recurrence_relation_works-1 nil 3776610673 ("" (measure-induct+ "x" "x") (("" (skeep) (("" (expand "prim_recurrence_relation" 1) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (prop) (("1" (skeep) (("1" (inst -3 "x!1-1") (("1" (assert) (("1" (inst -3 "recur" "final" "y" "z") (("1" (assert) (("1" (skeep) (("1" (inst 1 "append(l,(: ans :))") (("1" (prop) (("1" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (rewrite "length_append") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (assert) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (assert) nil nil)) nil) ("3" (rewrite "length_append") (("3" (assert) nil nil)) nil)) nil) ("2" (rewrite "nth_append") nil nil) ("3" (skeep) (("3" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (inst -7 "i") (("1" (assert) nil nil)) nil) ("2" (case "i= length(l)-1") (("1" (replace -1) (("1" (assert) (("1" (expand "nth" 2 2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_append") (("2" (typepred "l") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (inst -2 "x!1-1") (("1" (assert) (("1" (skeep) (("1" (typepred "l") (("1" (inst 1 "nth(l,length(l)-2)") (("1" (prop) (("1" (replace -2) (("1" (assert) (("1" (inst -5 "x!1-1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -6 "recur" "final" "y" "nth(l,length(l)-2)") (("2" (assert) (("2" (inst 3 "rdc(l)") (("1" (prop) (("1" (case "length(rdc(l)) = length(cdr(l))") (("1" (replace -1) (("1" (expand "rdc" 1) (("1" (lemma "reverse_def[nat]") (("1" (inst -1 "l" "1
") (("1" (assert) (("1" (replaces -1 :dir rl) (("1" (expand "nth" 1 1) (("1" (lemma "reverse_def[nat]") (("1" (inst -1 "cdr(reverse(l))" "length(cdr(reverse(l))) -1") (("1" (prop) (("1" (assert) (("1" (replaces -1 :dir rl) (("1" (case "length(cdr(reverse(l))) = length(cdr(l))") (("1" (assert) nil nil) ("2" (hide-all-but (-3 1 4)) (("2" (lemma "length_reverse[nat]") (("2" (inst -1 "l") (("2" (expand "length" -1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but (-3 1 4)) (("2" (lemma "length_reverse[nat]") (("2" (inst -1 "l") (("2" (expand "length" -1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 4)) (("2" (expand "rdc") (("2" (rewrite "length_reverse") (("2" (lemma "length_reverse[nat]") (("2" (inst -1 "l") (("2" (expand "length" -1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1 4)) (("3" (grind) nil nil)) nil)) nil) ("2" (case "nth(l, 0) = nth(rdc(l), 0)") (("1" (assert) nil nil) ("2" (hide-all-but (-2 1 4)) (("2" (lemma "rdc_rac[nat]") (("2" (inst -1 "l") (("2" (case "nth(l, 0) = nth(append(rdc(l), (: rac(l) :)), 0)") (("1" (replaces -1) (("1" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (hide -1 2) (("1" (grind) (("1" (rewrite "length_reverse") (("1" (lemma "length_reverse[nat]") (("1" (inst -1 "l") (("1" (expand "length" -1) (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (replace -1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (inst -5 "i") (("1" (typepred "i") (("1" (case "forall(i : below[length(rdc(l))]): nth(rdc(l),i) = nth(l,i)") (("1" (inst-cp -1 "i") (("1" (inst -1 "i+1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-3 1 4)) (("2" (skeep) (("2" (case "nth(append(rdc(l),(:rac(l):)),i!1) = nth(l,i!1)") (("1" (replaces -1 :dir rl) (("1" (rewrite "nth_append") nil nil)) nil) ("2" (rewrite "rdc_rac") nil nil) ("3" (typepred "i!1") (("3" (rewrite "length_append") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 -3 4)) (("3" (skeep) (("3" (typepred "i!1") (("3" (expand "rdc" -1) (("3" (rewrite "length_reverse") (("3" (lemma "length_reverse[nat]") (("3" (inst -1 "l") (("3" (expand "length" -1) (("3" (lift-if) (("3" (prop) (("1" (grind) nil nil) ("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 4)) (("2" (typepred "i") (("2" (expand "rdc") (("2" (rewrite "length_reverse") (("2" (lemma "length_reverse[nat]") (("2" (inst -1 "l") (("2" (expand "length" -1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1 3)) (("2" (expand "rdc" 1) (("2" (rewrite "length_reverse") (("2" (lemma "length_reverse[nat]") (("2" (inst -1 "l") (("2" (expand "length" -1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -3 2)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (prop) (("1" (inst 1 "(: ans :)") (("1" (prop) (("1" (grind) nil nil) ("2" (expand "nth" 1) (("2" (propax) nil nil)) nil) ("3" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (skeep) (("2" (typepred "l") (("2" (replace -6) (("2" (replace -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((odd_minus_odd_is_even application-judgement "even_int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (l skolem-const-decl "{l: list[nat] | length(l) = 1 + x!1}" mf_pvs0_Turing_Completeness nil) (rdc const-decl "list[T]" more_list_props structures) (i skolem-const-decl "below[length(rdc(l)) - 1]" mf_pvs0_Turing_Completeness nil) (rdc_rac formula-decl nil more_list_props structures) (rac const-decl "T" more_list_props structures) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (TRUE const-decl "bool" booleans nil) (length_reverse formula-decl nil list_props nil) (reverse def-decl "list[T]" list_props nil) (reverse_def formula-decl nil more_list_props structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (append def-decl "list[T]" list_props nil) (l skolem-const-decl "{l: list[nat] | length(l) = x!1}" mf_pvs0_Turing_Completeness nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (ans skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (NOT const-decl "[bool -> bool]" booleans nil) (i skolem-const-decl "below[length(append(l, (: ans :))) - 1]" mf_pvs0_Turing_Completeness nil) (int_plus_int_is_int application-judgement "int" integers nil) (nth_append formula-decl nil more_list_props structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length_singleton formula-decl nil more_list_props structures) (length_append formula-decl nil list_props nil) (x!1 skolem-const-decl "nat" mf_pvs0_Turing_Completeness nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (tuple2nat const-decl "nat" tuple2nat numbers) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (prim_recurrence_relation inductive-decl "bool" mf_pvs0_Turing_Completeness nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (limited const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (prim_recurrence_correctness 0 (prim_recurrence_correctness-1 nil 3776005982 ("" (skeep) (("" (lemma "prim_recurrence_is_prim_recurrence_relation") (("" (lemma "prim_recurrence_relation_works") (("" (inst?) (("" (inst?) (("" (assert) (("" (replace -1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prim_recurrence_is_prim_recurrence_relation formula-decl nil mf_pvs0_Turing_Completeness nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (limited const-decl "bool" mf_pvs0_computable nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (prim_recurrence_relation_works formula-decl nil mf_pvs0_Turing_Completeness nil)) shostak)))
