(pvs0_expr (semantic_rel_expr_TCC1 0 (semantic_rel_expr_TCC1-1 nil 3603051502 ("" (subtype-tcc) nil nil) nil nil (semantic_rel_expr subtype "pvs0_expr.expr" "{x: PVS0Expr_adt[pvs0_expr.Val].PVS0Expr | booleans.OR(PVS0Expr_adt[pvs0_expr.Val].op1?(x), PVS0Expr_adt[pvs0_expr.Val].rec?(x))}"))) (semantic_rel_expr_TCC2 0 (semantic_rel_expr_TCC2-1 nil 3603051502 ("" (subtype-tcc) nil nil) nil nil (semantic_rel_expr subtype "pvs0_expr.expr" "{x: PVS0Expr_adt[pvs0_expr.Val].PVS0Expr | booleans.OR(PVS0Expr_adt[pvs0_expr.Val].op1?(x), PVS0Expr_adt[pvs0_expr.Val].op2?(x))}"))) (semantic_rel_expr_TCC3 0 (semantic_rel_expr_TCC3-1 nil 3603051502 ("" (subtype-tcc) nil nil) nil nil (semantic_rel_expr subtype "pvs0_expr.expr" "{x: PVS0Expr_adt[pvs0_expr.Val].PVS0Expr | booleans.OR(PVS0Expr_adt[pvs0_expr.Val].op1?(x), PVS0Expr_adt[pvs0_expr.Val].op2?(x))}"))) (semantic_rel_expr_TCC4 0 (semantic_rel_expr_TCC4-1 nil 3603051502 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (semantic_rel_expr subtype "pvs0_expr.expr" "{x: PVS0Expr_adt[pvs0_expr.Val].PVS0Expr | booleans.OR(PVS0Expr_adt[pvs0_expr.Val].op1?(x), PVS0Expr_adt[pvs0_expr.Val].rec?(x))}"))) (eval_expr_TCC1 0 (eval_expr_TCC1-1 nil 3602330945 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (eval_expr subtype "pvs0_expr.expr" "{x: PVS0Expr_adt[pvs0_expr.Val].PVS0Expr | booleans.OR(PVS0Expr_adt[pvs0_expr.Val].op1?(x), PVS0Expr_adt[pvs0_expr.Val].op2?(x))}"))) (eval_expr_TCC2 0 (eval_expr_TCC2-1 nil 3602330945 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("" (assert) (("" (hide 3) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "pvs0_expr.eval_expr(pvs0_expr.pvs0)(pvs0_expr.i, pvs0_expr.arg, pvs0_expr.env)" "nil"))) (eval_expr_TCC3 0 (eval_expr_TCC3-1 nil 3602330945 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("" (assert) (("" (hide 3) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "pvs0_expr.eval_expr(pvs0_expr.pvs0)(pvs0_expr.i, pvs0_expr.arg2, pvs0_expr.env)" "nil"))) (eval_expr_TCC4 0 (eval_expr_TCC4-1 nil 3602330945 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (eval_expr subtype "pvs0_expr.expr" "{x: PVS0Expr_adt[pvs0_expr.Val].PVS0Expr | booleans.OR(PVS0Expr_adt[pvs0_expr.Val].op1?(x), PVS0Expr_adt[pvs0_expr.Val].op2?(x))}"))) (eval_expr_TCC5 0 (eval_expr_TCC5-1 nil 3602330945 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("" (assert) (("" (hide 3) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "pvs0_expr.eval_expr(pvs0_expr.pvs0)(pvs0_expr.i, pvs0_expr.arg1, pvs0_expr.env)" "nil"))) (eval_expr_TCC6 0 (eval_expr_TCC6-1 nil 3602330945 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("" (assert) (("" (hide 4) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "pvs0_expr.eval_expr(pvs0_expr.pvs0)(pvs0_expr.i, pvs0_expr.arg1, pvs0_expr.env)" "nil"))) (eval_expr_TCC7 0 (eval_expr_TCC7-1 nil 3602330945 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("" (assert) (("" (hide 3) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "pvs0_expr.eval_expr(pvs0_expr.pvs0)(pvs0_expr.i, pvs0_expr.arg2, pvs0_expr.env)" "nil"))) (eval_expr_TCC8 0 (eval_expr_TCC8-1 nil 3602330945 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("" (assert) (("" (hide 3) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "pvs0_expr.eval_expr(pvs0_expr.pvs0)(pvs0_expr.i, pvs0_expr.cnd, pvs0_expr.env)" "nil"))) (eval_expr_TCC9 0 (eval_expr_TCC9-1 nil 3602330945 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (eval_expr subtype "(number_fields.-)(pvs0_expr.i, 1)" "nat"))) (eval_expr_TCC10 0 (eval_expr_TCC10-1 nil 3709912304 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("1" (assert) nil nil) ("2" (hide 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (PVS0 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (i skolem-const-decl "nat" pvs0_expr nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "pvs0_expr.eval_expr(pvs0_expr.pvs0)((number_fields.-)(pvs0_expr.i, 1), pvs0_expr.pvs0`4, Maybe[pvs0_expr.Val].val(pvs0_expr.v))" "nil"))) (eval_expr_TCC11 0 (eval_expr_TCC11-1 nil 3709912304 ("" (skeep*) (("" (lemma "lex2_lt") (("" (inst?) (("" (assert) (("" (hide 3) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lex2_lt formula-decl nil lex2 nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil) (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr termination "pvs0_expr.eval_expr(pvs0_expr.pvs0)(pvs0_expr.i, pvs0_expr.arg, pvs0_expr.env)" "nil"))) (eval_expr_ge_n_j_TCC1 0 (eval_expr_ge_n_j_TCC1-1 nil 3603101849 ("" (skeep) (("" (assert) nil nil)) nil) nil nil (eval_expr_ge_n_j_ subtype "Maybe[pvs0_expr.Val].None" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC2 0 (eval_expr_ge_n_j_TCC2-1 nil 3603101849 ("" (skeep*) (("" (assert) (("" (skeep) (("" (expand "eval_expr" +) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_expr def-decl "Maybe[Val]" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[pvs0_expr.Val].Some(pvs0_expr.v)" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC3 0 (eval_expr_ge_n_j_TCC3-1 nil 3603101849 ("" (skeep*) (("" (assert) (("" (skeep 2) (("" (replaces -1) (("" (expand "eval_expr") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_expr def-decl "Maybe[Val]" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[pvs0_expr.Val].Some(pvs0_expr.env)" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC4 0 (eval_expr_ge_n_j_TCC4-1 nil 3603101849 ("" (skeep*) (("" (assert) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "pvs0_expr.expr" "{x: PVS0Expr_adt[pvs0_expr.Val].PVS0Expr | booleans.OR(PVS0Expr_adt[pvs0_expr.Val].op1?(x), PVS0Expr_adt[pvs0_expr.Val].op2?(x))}"))) (eval_expr_ge_n_j_TCC5 0 (eval_expr_ge_n_j_TCC5-2 nil 3603102572 ("" (skeep* :preds? t) (("" (assert) (("" (skeep) (("" (insteep) (("" (replaces -5) (("" (expand "eval_expr" 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (upfrom nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (eval_expr def-decl "Maybe[Val]" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[pvs0_expr.Val].Some(pvs0_expr.eval_op1(pvs0_expr.pvs0)(PVS0Expr_adt[pvs0_expr.Val].get_op(pvs0_expr.expr), Maybe[pvs0_expr.Val].val(pvs0_expr.v)))" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}")) (eval_expr_ge_n_j_TCC5-1 nil 3603101849 ("" (recursive-judgement-tcc) nil nil) nil nil (eval_expr_ge_n_j_ subtype "Maybe[pvs0_expr.Val].Some(pvs0_expr.eval_op1(pvs0_expr.pvs0)(PVS0Expr_adt[pvs0_expr.Val].get_op(pvs0_expr.expr), Maybe[pvs0_expr.Val].val(pvs0_expr.v)))" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC6 0 (eval_expr_ge_n_j_TCC6-2 nil 3603102676 ("" (skeep*) (("" (assert) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[pvs0_expr.Val].None" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}")) (eval_expr_ge_n_j_TCC6-1 nil 3603101849 ("" (recursive-judgement-tcc) nil nil) nil nil (eval_expr_ge_n_j_ subtype "Maybe[pvs0_expr.Val].None" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC7 0 (eval_expr_ge_n_j_TCC7-1 nil 3603101849 ("" (skeep*) (("" (assert) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "pvs0_expr.expr" "{x: PVS0Expr_adt[pvs0_expr.Val].PVS0Expr | booleans.OR(PVS0Expr_adt[pvs0_expr.Val].op1?(x), PVS0Expr_adt[pvs0_expr.Val].op2?(x))}"))) (eval_expr_ge_n_j_TCC8 0 (eval_expr_ge_n_j_TCC8-2 nil 3603103146 ("" (skeep*) (("" (replace -1 :hide? t) (("" (beta) (("" (assert) (("" (skeep 2) (("" (typepred "v1") (("" (typepred "v2") (("" (assert) (("" (insteep -) (("" (insteep -) (("" (replaces -3 2) (("" (expand "eval_expr" 2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_expr def-decl "Maybe[Val]" pvs0_expr nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (upfrom nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil pvs0_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[pvs0_expr.Val].Some(pvs0_expr.eval_op2(pvs0_expr.pvs0)(PVS0Expr_adt[pvs0_expr.Val].get_op(pvs0_expr.expr), Maybe[pvs0_expr.Val].val(pvs0_expr.v1), Maybe[pvs0_expr.Val].val(pvs0_expr.v2)))" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}")) (eval_expr_ge_n_j_TCC8-1 nil 3603101849 ("" (recursive-judgement-tcc) nil nil) nil nil (eval_expr_ge_n_j_ subtype "Maybe[pvs0_expr.Val].Some(pvs0_expr.eval_op2(pvs0_expr.pvs0)(PVS0Expr_adt[pvs0_expr.Val].get_op(pvs0_expr.expr), Maybe[pvs0_expr.Val].val(pvs0_expr.v1), Maybe[pvs0_expr.Val].val(pvs0_expr.v2)))" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC9 0 (eval_expr_ge_n_j_TCC9-2 nil 3603103387 ("" (skeep*) (("" (assert) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[pvs0_expr.Val].None" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC10 0 (eval_expr_ge_n_j_TCC10-1 nil 3603101849 ("" (skeep*) (("" (hide -1) (("" (assert) (("" (skeep 3) (("" (typepred "vc") (("" (assert) (("" (insteep -) (("" (replaces -2 3) (("" (expand "eval_expr" 3) (("" (assert) (("" (typepred "v3(pvs0)(n, arg1, env)") (("" (assert) (("" (insteep -) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (eval_expr def-decl "Maybe[Val]" pvs0_expr nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "pvs0_expr.v3(pvs0_expr.pvs0)(pvs0_expr.n, pvs0_expr.arg1, pvs0_expr.env)" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC11 0 (eval_expr_ge_n_j_TCC11-1 nil 3603101849 ("" (skeep*) (("" (hide -1) (("" (assert) (("" (skeep) (("" (typepred "vc") (("" (assert) (("" (insteep -) (("" (replaces -2 2) (("" (expand "eval_expr" 2) (("" (assert) (("" (typepred "v3(pvs0)(n, arg2, env)") (("" (assert) (("" (insteep -) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (eval_expr def-decl "Maybe[Val]" pvs0_expr nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "pvs0_expr.v3(pvs0_expr.pvs0)(pvs0_expr.n, pvs0_expr.arg2, pvs0_expr.env)" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC12 0 (eval_expr_ge_n_j_TCC12-2 nil 3603103536 ("" (skeep*) (("" (assert) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[pvs0_expr.Val].None" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}")) (eval_expr_ge_n_j_TCC12-1 nil 3603101849 ("" (recursive-judgement-tcc) nil nil) nil nil (eval_expr_ge_n_j_ subtype "Maybe[pvs0_expr.Val].None" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC13 0 (eval_expr_ge_n_j_TCC13-1 nil 3603101849 ("" (skeep*) (("" (assert) nil nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "(number_fields.-)(pvs0_expr.n, 1)" "nat"))) (eval_expr_ge_n_j_TCC14 0 (eval_expr_ge_n_j_TCC14-1 nil 3709912304 ("" (skeep*) (("" (hide -1) (("" (assert) (("" (skeep) (("" (typepred "v") (("" (assert) (("" (insteep -) (("" (replaces -2 2) (("" (expand "eval_expr" 2) (("" (assert) (("" (typepred "v3(pvs0)(n - 1, pvs0`4, val[Val](v))") (("" (assert) (("" (flatten) (("" (inst -2 "m-1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (eval_expr def-decl "Maybe[Val]" pvs0_expr nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "pvs0_expr.v3(pvs0_expr.pvs0)((number_fields.-)(pvs0_expr.n, 1), pvs0_expr.pvs0`4, Maybe[pvs0_expr.Val].val(pvs0_expr.v))" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}"))) (eval_expr_ge_n_j_TCC15 0 (eval_expr_ge_n_j_TCC15-1 nil 3709912304 ("" (skeep*) (("" (assert) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_ge_n_j_ subtype "Maybe[pvs0_expr.Val].None" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), booleans.AND(reals.>(pvs0_expr.n, 0), FORALL (m: integers.upfrom(pvs0_expr.n)): myv = pvs0_expr.eval_expr(pvs0_expr.pvs0)(m, pvs0_expr.expr, pvs0_expr.env)))}"))) (eval_expr_gt_0 0 (eval_expr_gt_0-1 nil 3665383025 ("" (skeep) (("" (assert) (("" (flatten) (("" (lemma "eval_expr_ge_n_j") (("" (insteep -) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    n > 0 AND FORALL (m: upfrom(n)): myv = eval_expr(pvs0)(m, expr, env)}" pvs0_expr nil) (eval_expr_ge_n_j recursive-judgement-axiom nil pvs0_expr nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0 type-eq-decl nil pvs0_expr nil)) shostak)) (eval_expr_ge_n 0 (eval_expr_ge_n-1 nil 3603061172 ("" (skeep*) (("" (skoletin 1) (("" (flatten) (("" (lemma "eval_expr_ge_n_j") (("" (insteep -) (("" (assert) (("" (flatten) (("" (insteep -) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (eval_expr def-decl "Maybe[Val]" pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil pvs0_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    n > 0 AND FORALL (m: upfrom(n)): myv = eval_expr(pvs0)(m, expr, env)}" pvs0_expr nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eval_expr_ge_n_j recursive-judgement-axiom nil pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (semantic_rel_eval_expr 0 (semantic_rel_eval_expr-3 nil 3665233766 ("" (skeep*) (("" (lemma "semantic_rel_expr_induction") (("" (inst -1 "pvs0" _) (("" (inst -1 "LAMBDA(x:PVS0Expr,e:Val,v:Val):EXISTS (n:posnat): LET myv = eval_expr(pvs0)(n,x,e) IN
                                              some?(myv) AND v=val(myv)") (("" (split -) (("1" (inst -1 "expr" "env" "val") (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (skosimp*) (("2" (split -) (("1" (flatten) (("1" (inst 1 "1") (("1" (expand "eval_expr") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst 1 "1") (("2" (expand "eval_expr") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skeep -2) (("3" (skeep -3) (("3" (insteep 1) (("3" (beta) (("3" (flatten) (("3" (expand "eval_expr" +) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (skeep -2) (("4" (skolem -3 "n1") (("4" (skoletin -3 :postfix "1") (("4" (skolem -6 "n2") (("4" (skoletin -6 :postfix "2") (("4" (flatten) (("4" (inst 1 "max(n1,n2)") (("4" (skoletin 1) (("4" (lemma "eval_expr_ge_n") (("4" (copy -1) (("4" (insteep -1 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_arg1(expr!1)") ("env" "env!1"))) (("1" (replace -9 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -2 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_arg2(expr!1)") ("env" "env!1"))) (("1" (replace -6 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -3) (("1" (replaces -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (flatten) (("5" (skeep -2) (("5" (skolem -3 "n1") (("5" (skoletin -3 :postfix "1") (("5" (lemma "eval_expr_ge_n") (("5" (copy -1) (("5" (split -7) (("1" (flatten) (("1" (skolem -2 "n2") (("1" (skoletin -2 :postfix "1") (("1" (flatten) (("1" (inst 2 "max(n1,n2)") (("1" (skoletin 2) (("1" (insteep -7 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_cond(expr!1)") ("env" "env!1"))) (("1" (replace -10 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -6 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_if(expr!1)") ("env" "env!1"))) (("1" (replace -4 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -1) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skolem -3 "n2") (("2" (skoletin -3 :postfix "2") (("2" (flatten) (("2" (inst 1 "max(n1,n2)") (("2" (skoletin 1) (("2" (insteep -7 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_cond(expr!1)") ("env" "env!1"))) (("1" (replace -11 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -8 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_else(expr!1)") ("env" "env!1"))) (("1" (replace -4 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (flatten) (("6" (skeep -2) (("6" (skolem -3 "n1") (("6" (skoletin -3 :postfix "1") (("6" (flatten) (("6" (skolem -7 "n2") (("6" (skoletin -7 :postfix "2") (("6" (flatten) (("6" (inst 1 "n1+n2+1") (("6" (skoletin 1) (("6" (lemma "eval_expr_ge_n") (("6" (copy -1) (("6" (insteep -1 :but (("n" "n1") ("m" "n1+n2+1") ("expr" "get_arg(expr!1)") ("env" "env!1"))) (("6" (replace -9 :dir rl) (("6" (assert) (("6" (assert) (("6" (insteep -2 :but (("n" "n2") ("m" "n1+n2") ("expr" "pvs0`4") ("env" "valarg"))) (("6" (replace -6 :dir rl) (("6" (assert) (("6" (expand "eval_expr" -3) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((semantic_rel_expr_induction formula-decl nil pvs0_expr nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    n > 0 AND FORALL (m: upfrom(n)): myv = eval_expr(pvs0)(m, expr, env)}" pvs0_expr nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (Maybe type-decl nil Maybe structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (AND const-decl "[bool, bool -> bool]" booleans nil) (upfrom nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (eval_expr def-decl "Maybe[Val]" pvs0_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (op2? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (get_arg1 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (get_arg2 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil) (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}" real_defs nil) (posint_max application-judgement "{k: posint | i <= k AND j <= k}" real_defs nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (eval_expr_ge_n formula-decl nil pvs0_expr nil) (n2 skolem-const-decl "posnat" pvs0_expr nil) (n1 skolem-const-decl "posnat" pvs0_expr nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (max_ge formula-decl nil real_defs nil) (ite? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (get_cond adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (get_else adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (n2 skolem-const-decl "posnat" pvs0_expr nil) (get_if adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (n2 skolem-const-decl "posnat" pvs0_expr nil) (n1 skolem-const-decl "posnat" pvs0_expr nil) (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil) (semantic_rel_eval_expr-2 nil 3603111426 ("" (skeep*) (("" (lemma "semantic_rel_expr_induction") (("" (insteep -1 :but "P") (("" (inst -1 "LAMBDA(x:PVS0Expr,e:Val,v:Val):EXISTS (n:posnat): LET myv = eval_expr(false_val,eval_op1,eval_op2)(n,x,body,e) IN
                                    some?(myv) AND v=val(myv)") (("" (split -) (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (skosimp*) (("2" (split -) (("1" (flatten) (("1" (inst 1 "1") (("1" (expand "eval_expr") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst 1 "1") (("2" (expand "eval_expr") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skeep -2) (("3" (skeep -3) (("3" (insteep 1) (("3" (beta) (("3" (flatten) (("3" (expand "eval_expr" +) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (skeep -2) (("4" (skolem -3 "n1") (("4" (skoletin -3 :postfix "1") (("4" (skolem -6 "n2") (("4" (skoletin -6 :postfix "2") (("4" (flatten) (("4" (inst 1 "max(n1,n2)") (("4" (skoletin 1) (("4" (lemma "eval_expr_ge_n") (("4" (copy -1) (("4" (insteep -1 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_arg1(expr!1)") ("env" "env!1"))) (("1" (replace -9 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -2 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_arg2(expr!1)") ("env" "env!1"))) (("1" (replace -6 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -3) (("1" (assert) (("1" (replaces -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (flatten) (("5" (skeep -2) (("5" (skolem -3 "n1") (("5" (skoletin -3 :postfix "1") (("5" (lemma "eval_expr_ge_n") (("5" (copy -1) (("5" (split -7) (("1" (flatten) (("1" (skolem -3 "n2") (("1" (skoletin -3 :postfix "2") (("1" (flatten) (("1" (inst 1 "max(n1,n2)") (("1" (skoletin 1) (("1" (insteep -7 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_cond(expr!1)") ("env" "env!1"))) (("1" (replace -11 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -8 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_if(expr!1)") ("env" "env!1"))) (("1" (replace -4 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -1) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skolem -2 "n2") (("2" (skoletin -2 :postfix "2") (("2" (flatten) (("2" (inst 2 "max(n1,n2)") (("2" (skoletin 2) (("2" (insteep -6 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_cond(expr!1)") ("env" "env!1"))) (("1" (replace -10 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -7 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_else(expr!1)") ("env" "env!1"))) (("1" (replace -4 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (flatten) (("6" (skeep -2) (("6" (skolem -3 "n1") (("6" (skoletin -3 :postfix "1") (("6" (flatten) (("6" (skolem -7 "n2") (("6" (skoletin -7 :postfix "2") (("6" (flatten) (("6" (inst 1 "n1+n2+1") (("6" (skoletin 1) (("6" (lemma "eval_expr_ge_n") (("6" (copy -1) (("6" (insteep -1 :but (("n" "n1") ("m" "n1+n2+1") ("expr" "get_arg(expr!1)") ("env" "env!1"))) (("6" (replace -9 :dir rl) (("6" (assert) (("6" (assert) (("6" (insteep -2 :but (("n" "n2") ("m" "n1+n2") ("expr" "body") ("env" "LAMBDA(v:(vr?)):valarg"))) (("6" (replace -6 :dir rl) (("6" (assert) (("6" (expand "eval_expr" -3) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (get_arg1 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil) (get_arg2 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil) (get_cond adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (get_else adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (get_if adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (vr? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (op2? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (ite? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)) nil) (semantic_rel_eval_expr-1 nil 3603110753 ("" (skeep*) (("" (lemma "semantic_rel_expr_induction") (("" (insteep -1 :but "P") (("" (inst -1 "LAMBDA(x:PVS0Expr,e:Val,v:Val):EXISTS (n:posnat): LET myv = eval_expr(false_val,eval_op1,eval_op2)(n,x,body,e) IN
                            some?(myv) AND v=val(myv) AND semantic_rel_expr(false_val,eval_op1,eval_op2)(x,body,e,v)") (("" (split -) (("1" (inst?) (("1" (assert) (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (skosimp*) (("2" (split -) (("1" (flatten) (("1" (inst 1 "1") (("1" (expand "eval_expr") (("1" (assert) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst 1 "1") (("2" (expand "eval_expr") (("2" (assert) (("2" (expand "semantic_rel_expr") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (skeep -2) (("3" (skeep -3) (("3" (insteep 1) (("3" (beta) (("3" (flatten) (("3" (expand "eval_expr" +) (("3" (assert) (("3" (expand "semantic_rel_expr" 1) (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (skeep -2) (("4" (skolem -3 "n1") (("4" (skoletin -3 :postfix "1") (("4" (skolem -6 "n2") (("4" (skoletin -6 :postfix "2") (("4" (flatten) (("4" (inst 1 "max(n1,n2)") (("4" (skoletin 1) (("4" (lemma "eval_expr_ge_n") (("4" (copy -1) (("4" (insteep -1 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_arg1(expr!1)") ("env" "env!1"))) (("1" (replace -11 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -2 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_arg2(expr!1)") ("env" "env!1"))) (("1" (replace -7 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -3) (("1" (assert) (("1" (replaces -3) (("1" (assert) (("1" (expand "semantic_rel_expr" 1) (("1" (insteep 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (flatten) (("5" (skeep -2) (("5" (skolem -3 "n1") (("5" (skoletin -3 :postfix "1") (("5" (lemma "eval_expr_ge_n") (("5" (copy -1) (("5" (split -7) (("1" (flatten) (("1" (skolem -3 "n2") (("1" (skoletin -3 :postfix "2") (("1" (flatten) (("1" (inst 1 "max(n1,n2)") (("1" (skoletin 1) (("1" (insteep -8 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_cond(expr!1)") ("env" "env!1"))) (("1" (replace -13 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -9 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_if(expr!1)") ("env" "env!1"))) (("1" (replace -5 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -1) (("1" (replaces -1) (("1" (assert) (("1" (expand "semantic_rel_expr" 1) (("1" (insteep 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skolem -2 "n2") (("2" (skoletin -2 :postfix "2") (("2" (flatten) (("2" (inst 2 "max(n1,n2)") (("2" (skoletin 2) (("2" (insteep -7 :but (("n" "n1") ("m" "max(n1,n2)") ("expr" "get_cond(expr!1)") ("env" "env!1"))) (("1" (replace -12 :dir rl) (("1" (assert) (("1" (assert) (("1" (insteep -8 :but (("n" "n2") ("m" "max(n1,n2)") ("expr" "get_else(expr!1)") ("env" "env!1"))) (("1" (replace -5 :dir rl) (("1" (assert) (("1" (expand "eval_expr" -1) (("1" (assert) (("1" (expand "semantic_rel_expr" 1) (("1" (insteep 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (flatten) (("6" (skeep -2) (("6" (skolem -3 "n1") (("6" (skoletin -3 :postfix "1") (("6" (flatten) (("6" (skolem -8 "n2") (("6" (skoletin -8 :postfix "2") (("6" (flatten) (("6" (inst 1 "n1+n2+1") (("6" (skoletin 1) (("6" (lemma "eval_expr_ge_n") (("6" (copy -1) (("6" (insteep -1 :but (("n" "n1") ("m" "n1+n2+1") ("expr" "get_arg(expr!1)") ("env" "env!1"))) (("6" (replace -11 :dir rl) (("6" (assert) (("6" (assert) (("6" (insteep -2 :but (("n" "n2") ("m" "n1+n2") ("expr" "body") ("env" "valarg"))) (("6" (replace -7 :dir rl) (("6" (assert) (("6" (expand "eval_expr" -3) (("6" (assert) (("6" (expand "semantic_rel_expr" 1) (("6" (insteep 1) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((get_arg1 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil) (get_arg2 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt nil) (get_cond adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (get_else adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (get_if adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (vr? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (op2? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (ite? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)) nil)) (eval_expr_n_pos 0 (eval_expr_n_pos-1 nil 3642524186 ("" (skeep*) (("" (typepred "eval_expr(pvs0)(n, expr, env)") (("" (assert) nil nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (eval_expr def-decl "Maybe[Val]" pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil pvs0_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    n > 0 AND FORALL (m: upfrom(n)): myv = eval_expr(pvs0)(m, expr, env)}" pvs0_expr nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (deterministic_expr 0 (deterministic_expr-1 nil 3603044754 ("" (skeep*) (("" (lemma "semantic_rel_eval_expr") (("" (copy -1) (("" (insteep -1 :but (("val" "val1"))) (("" (assert) (("" (insteep -2 :but (("val" "val2"))) (("" (assert) (("" (skolem -1 "n1") (("" (skolem -2 "n2") (("" (flatten) (("" (lemma "eval_expr_ge_n") (("" (copy -1) (("" (insteep -2 :but (("n" "n1") ("m" "max(n1,n2)"))) (("1" (insteep -1 :but (("n" "n2") ("m" "max(n1,n2)"))) (("1" (assert) (("1" (ground) nil nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil) ("2" (rewrite "max_ge") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((semantic_rel_eval_expr formula-decl nil pvs0_expr nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (max_ge formula-decl nil real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (n2 skolem-const-decl "nat" pvs0_expr nil) (n1 skolem-const-decl "nat" pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (upfrom nonempty-type-eq-decl nil integers nil) (eval_expr_ge_n formula-decl nil pvs0_expr nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    n > 0 AND FORALL (m: upfrom(n)): myv = eval_expr(pvs0)(m, expr, env)}" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (eval_expr_semantic_rel_j_TCC1 0 (eval_expr_semantic_rel_j_TCC1-1 nil 3642104985 ("" (skeep) (("" (assert) nil nil)) nil) ((eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    n > 0 AND FORALL (m: upfrom(n)): myv = eval_expr(pvs0)(m, expr, env)}" pvs0_expr nil)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[pvs0_expr.Val].None" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), pvs0_expr.semantic_rel_expr(pvs0_expr.pvs0)(pvs0_expr.expr, pvs0_expr.env, Maybe[pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC2 0 (eval_expr_semantic_rel_j_TCC2-1 nil 3642104985 ("" (skeep*) (("" (hide -1) (("" (replaces -1) (("" (expand "semantic_rel_expr") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[pvs0_expr.Val].Some(pvs0_expr.v)" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), pvs0_expr.semantic_rel_expr(pvs0_expr.pvs0)(pvs0_expr.expr, pvs0_expr.env, Maybe[pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC3 0 (eval_expr_semantic_rel_j_TCC3-2 "" 3804629205 ("" (skeep*) (("" (replaces -2) (("" (expand "semantic_rel_expr") (("" (propax) nil nil)) nil)) nil)) nil) nil shostak (eval_expr_semantic_rel_j_ subtype "Maybe[pvs0_expr.Val].Some(pvs0_expr.env)" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), pvs0_expr.semantic_rel_expr(pvs0_expr.pvs0)(pvs0_expr.expr, pvs0_expr.env, Maybe[pvs0_expr.Val].val(myv)))}")) (eval_expr_semantic_rel_j_TCC3-1 nil 3642104985 ("" (skeep*) (("" (replaces -1) (("" (expand "semantic_rel_expr") (("" (propax) nil nil)) nil)) nil)) nil) ((semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[pvs0_expr.Val].Some(pvs0_expr.env)" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), pvs0_expr.semantic_rel_expr(pvs0_expr.pvs0)(pvs0_expr.expr, pvs0_expr.env, Maybe[pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC4 0 (eval_expr_semantic_rel_j_TCC4-1 nil 3642104985 ("" (skeep*) (("" (assert) nil nil)) nil) ((eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    n > 0 AND FORALL (m: upfrom(n)): myv = eval_expr(pvs0)(m, expr, env)}" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "pvs0_expr.expr" "{x: PVS0Expr_adt[pvs0_expr.Val].PVS0Expr | booleans.OR(PVS0Expr_adt[pvs0_expr.Val].op1?(x), PVS0Expr_adt[pvs0_expr.Val].op2?(x))}"))) (eval_expr_semantic_rel_j_TCC5 0 (eval_expr_semantic_rel_j_TCC5-1 nil 3642104985 ("" (skeep*) (("" (hide -1) (("" (replace -1) (("" (expand "semantic_rel_expr" 2) (("" (inst 2 "val(v)") (("" (typepred "v") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (NOT const-decl "[bool -> bool]" booleans nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[pvs0_expr.Val].Some(pvs0_expr.eval_op1(pvs0_expr.pvs0)(PVS0Expr_adt[pvs0_expr.Val].get_op(pvs0_expr.expr), Maybe[pvs0_expr.Val].val(pvs0_expr.v)))" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), pvs0_expr.semantic_rel_expr(pvs0_expr.pvs0)(pvs0_expr.expr, pvs0_expr.env, Maybe[pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC6 0 (eval_expr_semantic_rel_j_TCC6-1 nil 3642104985 ("" (assert) nil nil) nil nil (eval_expr_semantic_rel_j_ subtype "Maybe[pvs0_expr.Val].None" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), pvs0_expr.semantic_rel_expr(pvs0_expr.pvs0)(pvs0_expr.expr, pvs0_expr.env, Maybe[pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC7 0 (eval_expr_semantic_rel_j_TCC7-1 nil 3642104985 ("" (skeep*) (("" (assert) nil nil)) nil) ((eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    n > 0 AND FORALL (m: upfrom(n)): myv = eval_expr(pvs0)(m, expr, env)}" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "pvs0_expr.expr" "{x: PVS0Expr_adt[pvs0_expr.Val].PVS0Expr | booleans.OR(PVS0Expr_adt[pvs0_expr.Val].op1?(x), PVS0Expr_adt[pvs0_expr.Val].op2?(x))}"))) (eval_expr_semantic_rel_j_TCC8 0 (eval_expr_semantic_rel_j_TCC8-1 nil 3642104985 ("" (skeep*) (("" (hide -1) (("" (replace -1) (("" (expand "semantic_rel_expr" 2) (("" (inst 2 "val(v1)" "val(v2)") (("" (typepred "v1" "v2") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (NOT const-decl "[bool -> bool]" booleans nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[pvs0_expr.Val].Some(pvs0_expr.eval_op2(pvs0_expr.pvs0)(PVS0Expr_adt[pvs0_expr.Val].get_op(pvs0_expr.expr), Maybe[pvs0_expr.Val].val(pvs0_expr.v1), Maybe[pvs0_expr.Val].val(pvs0_expr.v2)))" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), pvs0_expr.semantic_rel_expr(pvs0_expr.pvs0)(pvs0_expr.expr, pvs0_expr.env, Maybe[pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC9 0 (eval_expr_semantic_rel_j_TCC9-1 nil 3642104985 ("" (assert) nil nil) nil nil (eval_expr_semantic_rel_j_ subtype "Maybe[pvs0_expr.Val].None" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), pvs0_expr.semantic_rel_expr(pvs0_expr.pvs0)(pvs0_expr.expr, pvs0_expr.env, Maybe[pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC10 0 (eval_expr_semantic_rel_j_TCC10-1 nil 3642104985 ("" (skeep*) (("" (hide -1) (("" (replace -1) (("" (expand "semantic_rel_expr") (("" (inst 3 "val(vc)") (("" (typepred "vc") (("" (assert) (("" (typepred "v3(pvs0)(n, arg1, env)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "pvs0_expr.v3(pvs0_expr.pvs0)(pvs0_expr.n, pvs0_expr.arg1, pvs0_expr.env)" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), pvs0_expr.semantic_rel_expr(pvs0_expr.pvs0)(pvs0_expr.expr, pvs0_expr.env, Maybe[pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC11 0 (eval_expr_semantic_rel_j_TCC11-1 nil 3642104985 ("" (skeep*) (("" (hide -1) (("" (assert) (("" (expand "semantic_rel_expr") (("" (inst 2 "val(vc)") (("" (replace -1) (("" (typepred "vc") (("" (assert) (("" (typepred "v3(pvs0)(n, arg2, env)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "pvs0_expr.v3(pvs0_expr.pvs0)(pvs0_expr.n, pvs0_expr.arg2, pvs0_expr.env)" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), pvs0_expr.semantic_rel_expr(pvs0_expr.pvs0)(pvs0_expr.expr, pvs0_expr.env, Maybe[pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC12 0 (eval_expr_semantic_rel_j_TCC12-2 nil 3665232854 ("" (skeep*) (("" (assert) nil nil)) nil) ((eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    n > 0 AND FORALL (m: upfrom(n)): myv = eval_expr(pvs0)(m, expr, env)}" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[pvs0_expr.Val].None" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), pvs0_expr.semantic_rel_expr(pvs0_expr.pvs0)(pvs0_expr.expr, pvs0_expr.env, Maybe[pvs0_expr.Val].val(myv)))}")) (eval_expr_semantic_rel_j_TCC12-1 nil 3642104985 ("" (skeep*) (("" (typepred "v3(false_val, eval_op1, eval_op2)(n, arg, body, env)") (("" (typepred "v3(false_val, eval_op1, eval_op2)
                               (n - 1, body, body,
                                LAMBDA (v_1: (vr?[Val])): val[T](v))") (("1" (replaces -5 :dir rl) (("1" (name-replace "REC" "v3(false_val, eval_op1, eval_op2)
              (n - 1, body, body, LAMBDA (v_1: (vr?[Val])): val[T](v))") (("1" (assert) (("1" (replaces -3) (("1" (expand "semantic_rel_expr" 2) (("1" (inst? +) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil) ((val adt-accessor-decl "[(some?) -> T]" Maybe structures) (ite? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (op2? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (vr? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures)) nil (eval_expr_semantic_rel_j_ subtype "Maybe[pvs0_expr.Val].None" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), pvs0_expr.semantic_rel_expr(pvs0_expr.pvs0)(pvs0_expr.expr, pvs0_expr.env, Maybe[pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC13 0 (eval_expr_semantic_rel_j_TCC13-1 nil 3642104985 ("" (skeep*) (("" (assert) nil nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    n > 0 AND FORALL (m: upfrom(n)): myv = eval_expr(pvs0)(m, expr, env)}" pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "(number_fields.-)(pvs0_expr.n, 1)" "nat"))) (eval_expr_semantic_rel_j_TCC14 0 (eval_expr_semantic_rel_j_TCC14-1 nil 3709912304 ("" (skeep*) (("" (hide -1) (("" (replace -1) (("" (expand "semantic_rel_expr") (("" (inst 2 "val(v)") (("" (typepred "v") (("" (assert) (("" (typepred "v3(pvs0)(n - 1, get_body(pvs0), val[Val](v))") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (NOT const-decl "[bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil pvs0_expr nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (eval_expr_semantic_rel_j_ subtype "pvs0_expr.v3(pvs0_expr.pvs0)((number_fields.-)(pvs0_expr.n, 1), pvs0_expr.pvs0`4, Maybe[pvs0_expr.Val].val(pvs0_expr.v))" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), pvs0_expr.semantic_rel_expr(pvs0_expr.pvs0)(pvs0_expr.expr, pvs0_expr.env, Maybe[pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel_j_TCC15 0 (eval_expr_semantic_rel_j_TCC15-1 nil 3709912304 ("" (assert) nil nil) nil nil (eval_expr_semantic_rel_j_ subtype "Maybe[pvs0_expr.Val].None" "{myv: Maybe[pvs0_expr.Val].Maybe | booleans.IMPLIES(Maybe[pvs0_expr.Val].some?(myv), pvs0_expr.semantic_rel_expr(pvs0_expr.pvs0)(pvs0_expr.expr, pvs0_expr.env, Maybe[pvs0_expr.Val].val(myv)))}"))) (eval_expr_semantic_rel 0 (eval_expr_semantic_rel-1 nil 3642104637 ("" (skeep*) (("" (skoletin 1) (("" (typepred "eval_expr(pvs0)(n, expr, env)") (("" (hide -2) (("" (flatten) (("" (replaces -4 :dir rl) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((val adt-accessor-decl "[(some?) -> T]" Maybe structures) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (eval_expr def-decl "Maybe[Val]" pvs0_expr nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (PVS0 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (Val formal-nonempty-type-decl nil pvs0_expr nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    n > 0 AND FORALL (m: upfrom(n)): myv = eval_expr(pvs0)(m, expr, env)}" pvs0_expr nil) (eval_expr_semantic_rel_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}" pvs0_expr nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (upfrom nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (eval_expr_terminates 0 (eval_expr_terminates-1 nil 3603051644 ("" (skeep) (("" (split) (("1" (flatten) (("1" (expand "eval_expr_termination") (("1" (expand "terminates_expr") (("1" (skeep) (("1" (insteep -1) (("1" (skeep) (("1" (inst 1 "val(eval_expr(pvs0)(n, expr , env))") (("1" (lemma "eval_expr_semantic_rel") (("1" (beta) (("1" (insteep :but "val") (("1" (inst -1 "val(eval_expr(pvs0)(n, expr, env))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "terminates_expr") (("2" (expand "eval_expr_termination") (("2" (skeep*) (("2" (insteep*) (("2" (skeep) (("2" (lemma "semantic_rel_eval_expr") (("2" (insteep -1) (("2" (assert) (("2" (skeep) (("2" (insteep 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_expr_semantic_rel_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}" pvs0_expr nil) (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
   some?(myv) IMPLIES
    n > 0 AND FORALL (m: upfrom(n)): myv = eval_expr(pvs0)(m, expr, env)}" pvs0_expr nil) (eval_expr_termination const-decl "bool" pvs0_expr nil) (eval_expr_semantic_rel formula-decl nil pvs0_expr nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (Maybe type-decl nil Maybe structures) (boolean nonempty-type-decl nil booleans nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (eval_expr def-decl "Maybe[Val]" pvs0_expr nil) (pvs0 skolem-const-decl "PVS0" pvs0_expr nil) (n skolem-const-decl "nat" pvs0_expr nil) (expr skolem-const-decl "PVS0Expr[Val]" pvs0_expr nil) (env skolem-const-decl "Val" pvs0_expr nil) (Val formal-nonempty-type-decl nil pvs0_expr nil) (terminates_expr const-decl "bool" pvs0_expr nil) (TRUE const-decl "bool" booleans nil) (semantic_rel_eval_expr formula-decl nil pvs0_expr nil)) shostak)))
