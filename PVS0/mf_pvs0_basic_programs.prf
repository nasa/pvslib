(mf_pvs0_basic_programs (equal_TCC1 0 (equal_TCC1-2 nil 3797606001 ("" (skeep*) (("" (expand "every") (("" (expand "every") (("" (replace -1) (("" (replace -2) (("" (expand "every") (("" (expand "every") (("" (expand "every") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (list type-decl nil list_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (length def-decl "nat" list_props nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (equal subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, (: mf_PVS0Expr_adt[nat].ite(mf_PVS0Expr_adt[nat].op2(0, mf_pvs0_basic_programs.i, mf_pvs0_basic_programs.j), mf_PVS0Expr_adt[nat].cnst(mf_pvs0_basic_programs.false_val), mf_PVS0Expr_adt[nat].ite(mf_PVS0Expr_adt[nat].op2(0, mf_pvs0_basic_programs.j, mf_pvs0_basic_programs.i), mf_PVS0Expr_adt[nat].cnst(mf_pvs0_basic_programs.false_val), mf_PVS0Expr_adt[nat].cnst(1))) :))" "partial_recursive[false_val, lop1, lop2]")) (equal_TCC1-1 nil 3797605854 ("" (subtype-tcc) nil nil) nil nil (equal subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, (: mf_PVS0Expr_adt[nat].ite(mf_PVS0Expr_adt[nat].op2(0, mf_pvs0_basic_programs.i, mf_pvs0_basic_programs.j), mf_PVS0Expr_adt[nat].cnst(mf_pvs0_basic_programs.false_val), mf_PVS0Expr_adt[nat].ite(mf_PVS0Expr_adt[nat].op2(0, mf_pvs0_basic_programs.j, mf_pvs0_basic_programs.i), mf_PVS0Expr_adt[nat].cnst(mf_pvs0_basic_programs.false_val), mf_PVS0Expr_adt[nat].cnst(1))) :))" "partial_recursive[false_val, lop1, lop2]"))) (equal_works 0 (equal_works-1 nil 3797606518 ("" (skeep) (("" (expand "semantic_rel") (("" (expand "equal") (("" (expand "semantic_rel_expr") (("" (assert) (("" (expand "nth") (("" (case "EXISTS (valarg: nat):
               semantic_rel_expr(lop1, lop2, false_val,
                                 (: ite(op2(0, op1[nat](1, vr), op1[nat](2, vr)),
                                        cnst(false_val),
                                        ite(op2
                                            (0, op1[nat](2, vr), op1[nat](1, vr)),
                                            cnst(false_val),
                                            cnst(1))) :))
                                (op2(0, op1[nat](1, vr), op1[nat](2, vr)),
                                 tuple2nat(i, j), valarg)") (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (skeep) (("1" (expand "semantic_rel_expr" -1) (("1" (replaces -1) (("1" (expand "eval_op1") (("1" (expand "lop1" -1 1) (("1" (expand "length" -1) (("1" (assert) (("1" (expand "length" -1) (("1" (assert) (("1" (expand "lop1" -1) (("1" (expand "nth" -1) (("1" (expand "nth" -1) (("1" (expand "semantic_rel_expr" -2) (("1" (skeep) (("1" (expand "semantic_rel_expr" -2) (("1" (replaces -2) (("1" (expand "eval_op1") (("1" (expand "lop1" -2) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (expand "length" -2) (("1" (assert) (("1" (expand "nth" -2) (("1" (expand "nth" -2) (("1" (expand "nth" -2) (("1" (expand "pi1") (("1" (expand "pi2") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (replaces -1) (("1" (replaces -1) (("1" (expand "eval_op2") (("1" (expand "lop2" -1) (("1" (expand "length" -1) (("1" (assert) (("1" (expand "nth") (("1" (inst 1 "greater(i,j)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "i" "j") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(i,j)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(i,j)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (expand "equal_function") (("2" (expand "b2n") (("2" (expand "greater") (("2" (expand "b2n") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "semantic_rel_expr") (("3" (inst 1 "greater(j,i)") (("3" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "j" "i") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(i,j)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(i,j)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (grind) nil nil)) nil) ("3" (expand "semantic_rel_expr") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (inst 1 "greater(i,j)") (("2" (expand "semantic_rel_expr") (("2" (inst 1 "i" "j") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(i,j)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(i,j)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil) ("4" (hide 2) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((semantic_rel const-decl "bool" mf_pvs0_lang nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (nth def-decl "T" list_props nil) (TRUE const-decl "bool" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (equal_function const-decl "nat" mf_pvs0_basic_programs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (greater const-decl "nat" mf_pvs0_basic_programs nil) (O const-decl "T3" function_props nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (length def-decl "nat" list_props nil) (eval_op1 const-decl "Val" mf_pvs0_expr nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (tuple2nat const-decl "nat" tuple2nat numbers) (length_singleton formula-decl nil more_list_props structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (equal const-decl "partial_recursive" mf_pvs0_basic_programs nil)) nil)) (sub_function_TCC1 0 (sub_function_TCC1-1 nil 3797606696 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (sub_function subtype "(number_fields.-)(mf_pvs0_basic_programs.x, mf_pvs0_basic_programs.y)" "nat"))) (sub_TCC1 0 (sub_TCC1-2 nil 3797607058 ("" (skeep*) (("" (replaces -1) (("" (replaces -1) (("" (replaces -1) (("" (replaces -1) (("" (grind) (("" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (length def-decl "nat" list_props nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (list type-decl nil list_adt nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (below type-eq-decl nil nat_types nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (nth def-decl "T" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (sub subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, (: mf_PVS0Expr_adt[nat].ite(mf_pvs0_basic_programs.bt(mf_pvs0_basic_programs.x, mf_pvs0_basic_programs.y), mf_PVS0Expr_adt[nat].op1(0, mf_PVS0Expr_adt[nat].rec(0, mf_pvs0_basic_programs.k2(mf_pvs0_basic_programs.x, mf_PVS0Expr_adt[nat].op1(0, mf_pvs0_basic_programs.y)))), mf_PVS0Expr_adt[nat].cnst(0)) :))" "partial_recursive[false_val, lop1, lop2]")) (sub_TCC1-1 nil 3797606696 ("" (subtype-tcc) nil nil) nil nil (sub subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, (: mf_PVS0Expr_adt[nat].ite(mf_pvs0_basic_programs.bt(mf_pvs0_basic_programs.x, mf_pvs0_basic_programs.y), mf_PVS0Expr_adt[nat].op1(0, mf_PVS0Expr_adt[nat].rec(0, mf_pvs0_basic_programs.k2(mf_pvs0_basic_programs.x, mf_PVS0Expr_adt[nat].op1(0, mf_pvs0_basic_programs.y)))), mf_PVS0Expr_adt[nat].cnst(0)) :))" "partial_recursive[false_val, lop1, lop2]"))) (sub_works 0 (sub_works-1 nil 3797607672 ("" (measure-induct+ "IF x > y THEN x-y ELSE 0 ENDIF" ("x" "y")) (("1" (expand "sub_function" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "sub" 1) (("1" (expand "semantic_rel" 1) (("1" (expand "nth") (("1" (expand "semantic_rel_expr" 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "semantic_rel_expr" 1 1) (("1" (expand "eval_op1") (("1" (expand "lop1" 1 (1 2 3 4)) (("1" (expand "length" 1) (("1" (expand "length" 1) (("1" (expand "length" 1) (("1" (assert) (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "eval_op2") (("1" (expand "lop2" 1 (1 2)) (("1" (expand "length") (("1" (assert) (("1" (expand "nth") (("1" (inst 1 "greater(x!1,x!2)") (("1" (prop) (("1" (inst 1 "x!1" "x!2") (("1" (prop) (("1" (inst 1 "tuple2nat(x!1, x!2)") (("1" (expand "pi1") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "tuple2nat(x!1, x!2)") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "greater") (("2" (expand "b2n") (("2" (expand "semantic_rel_expr" 2) (("2" (expand "eval_op1") (("2" (expand "lop1" 2 (2 3)) (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (assert) (("2" (inst 2 "x!1-x!2-1") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1,x!2+1)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "x!1" "1+x!2") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1,x!2)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "x!2") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(x!1, x!2)") (("1" (expand "semantic_rel_expr") (("1" (expand "eval_op1") (("1" (expand "lop1") (("1" (expand "length") (("1" (expand "length") (("1" (expand "length") (("1" (assert) (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "pi2") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "nth") (("2" (expand "succ") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "x!1" "x!2+1") (("2" (case "x!1 > x!2 + 1") (("1" (assert) (("1" (expand "sub_function") (("1" (expand "sub") (("1" (expand "semantic_rel") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "sub_function") (("2" (case "x!1 = x!2+1") (("1" (replaces -1) (("1" (assert) (("1" (expand "sub") (("1" (expand "semantic_rel") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "length" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "succ") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "greater") (("3" (expand "b2n") (("3" (expand "false_val") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sub" 2) (("2" (expand "semantic_rel" 2) (("2" (expand "nth") (("2" (expand "semantic_rel_expr") (("2" (inst 2 "greater(x!1,x!2)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "x!1" "x!2") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 " tuple2nat(x!1, x!2)") (("1" (expand "semantic_rel_expr") (("1" (expand "eval_op1") (("1" (expand "lop1") (("1" (expand "length") (("1" (expand "length") (("1" (assert) (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "pi1") (("1" (expand "o ") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(x!1, x!2)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "greater") (("2" (expand "b2n") (("2" (assert) (("2" (expand "false_val") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "semantic_rel_expr") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ((semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (eval_op1 const-decl "Val" mf_pvs0_expr nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (length def-decl "nat" list_props nil) (length_singleton formula-decl nil more_list_props structures) (greater const-decl "nat" mf_pvs0_basic_programs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (succ const-decl "nat" mf_pvs0_basic_programs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (O const-decl "T3" function_props nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (sub_function const-decl "nat" mf_pvs0_basic_programs nil) (tuple2nat const-decl "nat" tuple2nat numbers) (sub const-decl "partial_recursive" mf_pvs0_basic_programs nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (numfield nonempty-type-eq-decl nil number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil)) (sub1_TCC1 0 (sub1_TCC1-2 nil 3797607977 ("" (expand "partial_recursive?") (("" (skeep) (("" (typepred "sub") (("" (expand "nth") (("" (lift-if) (("" (prop) (("1" (expand "length") (("1" (rewrite "map_length") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (decompose-equality) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_nth_rw") (("1" (expand "length") (("1" (rewrite "map_length") (("1" (expand "partial_recursive?") (("1" (prop) (("1" (inst -4 "i-1") (("1" (rewrite "valid_index_rec_offset" :dir rl) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "length" -1) (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth def-decl "T" list_props nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map_length formula-decl nil more_map_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (length def-decl "nat" list_props nil) (i skolem-const-decl "below[length(cons[mf_PVS0Expr[nat]]
                 (rec[nat](1, op2[nat](1, vr[nat], cnst[nat](1))),
                  map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                      (offset_rec[nat](1))(sub`4)))]" mf_pvs0_basic_programs nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (below type-eq-decl nil nat_types nil) (map adt-def-decl "list[T1]" list_adt_map nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (map_nth_rw formula-decl nil more_map_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (sub const-decl "partial_recursive" mf_pvs0_basic_programs nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil)) nil (sub1 subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].rec(1, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].vr, mf_PVS0Expr_adt[nat].cnst(1))), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_basic_programs.sub`4)))" "partial_recursive[false_val, lop1, lop2]")) (sub1_TCC1-1 nil 3797607841 ("" (subtype-tcc) nil nil) nil nil (sub1 subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].rec(1, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].vr, mf_PVS0Expr_adt[nat].cnst(1))), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_basic_programs.sub`4)))" "partial_recursive[false_val, lop1, lop2]"))) (sub1_works 0 (sub1_works-1 nil 3797608428 ("" (skeep) (("" (lemma "sub_works") (("" (inst -1 "x" "1") (("" (expand "sub1") (("" (expand "semantic_rel") (("" (expand "nth" 1) (("" (expand "semantic_rel_expr" 1) (("" (inst 1 "tuple2nat(x,1)") (("" (prop) (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "x" "1") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (propax) nil nil)) nil) ("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 1) (("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(sub`4,0)" "sub`4" "(: rec(1, op2(1, vr, cnst(1))) :)" "lop1" "lop2" "tuple2nat(x,1)" "sub_function(x,1)") (("1" (expand "append") (("1" (expand "append") (("1" (expand "length") (("1" (expand "length") (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (case "(lop1, lop2, false_val, sub`4) = sub") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sub_works formula-decl nil mf_pvs0_basic_programs nil) (sub1 const-decl "partial_recursive" mf_pvs0_basic_programs nil) (nth def-decl "T" list_props nil) (tuple2nat const-decl "nat" tuple2nat numbers) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (map adt-def-decl "list[T1]" list_adt_map nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (sub const-decl "partial_recursive" mf_pvs0_basic_programs nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (sub_function const-decl "nat" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (= const-decl "[T, T -> boolean]" equalities nil) (map_nth_rw formula-decl nil more_map_props nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (below type-eq-decl nil naturalnumbers nil) (append def-decl "list[T]" list_props nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (sum_function_TCC1 0 (sum_function_TCC1-1 nil 3797698962 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil (sum_function subtype "(number_fields.-)(mf_pvs0_basic_programs.x, 1)" "nat"))) (sum_function_TCC2 0 (sum_function_TCC2-1 nil 3797698962 ("" (termination-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (sum_function termination "mf_pvs0_basic_programs.sum_function((number_fields.-)(mf_pvs0_basic_programs.x, 1), mf_pvs0_basic_programs.y)" "nil"))) (sum_TCC1 0 (sum_TCC1-2 nil 3797699165 ("" (skeep*) (("" (replaces -1) (("" (replaces -1) (("" (expand "partial_recursive?") (("" (skeep) (("" (expand "nth" 1) (("" (lift-if) (("" (prop) (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (prop) (("1" (decompose-equality) (("1" (grind) nil nil)) nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "sub1") (("2" (expand "partial_recursive?") (("2" (prop) (("2" (inst -4 "i-1") (("1" (use "valid_index_rec_offset") (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (expand "length" 2) (("1" (rewrite "map_length") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (hide-all-but 1) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((partial_recursive? const-decl "bool" mf_pvs0_computable nil) (nth def-decl "T" list_props nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (sub const-decl "partial_recursive" mf_pvs0_basic_programs nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map adt-def-decl "list[T1]" list_adt_map nil) (sub1 const-decl "partial_recursive" mf_pvs0_basic_programs nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (i skolem-const-decl "below[length(cons[mf_PVS0Expr[nat]]
                 (ite[nat]
                      (op1[nat](1, vr),
                       op1[nat]
                           (0,
                            rec[nat]
                                (0,
                                 op2[nat]
                                     (1,
                                      rec[nat](1, op1[nat](1, vr)),
                                      op1[nat](2, vr)))),
                       op1[nat](2, vr)),
                  map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                      (offset_rec[nat](1))(sub1`4)))]" mf_pvs0_basic_programs nil) (below type-eq-decl nil nat_types nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (< const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil naturalnumbers nil) (map_nth_rw formula-decl nil more_map_props nil) (map_length formula-decl nil more_map_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (NOT const-decl "[bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (every adt-def-decl "boolean" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (sum subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].ite(mf_pvs0_basic_programs.x, mf_PVS0Expr_adt[nat].op1(0, mf_PVS0Expr_adt[nat].rec(0, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].rec(1, mf_pvs0_basic_programs.x), mf_pvs0_basic_programs.y))), mf_pvs0_basic_programs.y), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_basic_programs.sub1`4)))" "partial_recursive[false_val, lop1, lop2]")) (sum_TCC1-1 nil 3797698962 ("" (subtype-tcc) nil nil) nil nil (sum subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].ite(mf_pvs0_basic_programs.x, mf_PVS0Expr_adt[nat].op1(0, mf_PVS0Expr_adt[nat].rec(0, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].rec(1, mf_pvs0_basic_programs.x), mf_pvs0_basic_programs.y))), mf_pvs0_basic_programs.y), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_basic_programs.sub1`4)))" "partial_recursive[false_val, lop1, lop2]"))) (sum_works 0 (sum_works-1 nil 3797699374 ("" (induct "x") (("1" (skeep) (("1" (expand "semantic_rel" 1) (("1" (expand "sum" 1 2) (("1" (expand "nth") (("1" (expand "semantic_rel_expr" 1) (("1" (inst 1 "0") (("1" (prop) (("1" (expand "semantic_rel_expr" 1 1) (("1" (inst 1 "tuple2nat(0,y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "sum") (("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sum") (("2" (expand "false_val") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "semantic_rel_expr") (("3" (inst 1 "tuple2nat(0,y)") (("3" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "sum") (("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) (("2" (expand "sum_function") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "semantic_rel" 1) (("2" (expand "sum" 1 2) (("2" (expand "nth") (("2" (expand "semantic_rel_expr") (("2" (inst 1 "1+j") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(1+j,y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "sum") (("2" (expand "eval_op1") (("2" (expand "lop1" 1) (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (expand "sum" 1) (("2" (expand "false_val") (("2" (inst 2 "sum_function(j,y)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(j,y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "j" "y") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "1+j") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(1+j,y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "eval_op1") (("2" (expand "sum" 1) (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "sum" 1 2) (("2" (expand "nth") (("2" (expand "sum") (("2" (lemma "add_rec_list") (("2" (inst -1 "false_val" "nth(sub1`4,0)" "sub1`4" "(: ite(op1[nat](1, vr),
                                               op1(0,
                                                   rec
                                                   (0,
                                                    op2
                                                    (1,
                                                     rec(1, op1[nat](1, vr)),
                                                     op1[nat](2, vr)))),
                                               op1[nat](2, vr)) :)" "lop1" "lop2" "1+j" "j") (("1" (expand "length") (("1" (expand "length" -1) (("1" (expand "append") (("1" (expand "append") (("1" (rewrite "map_nth_rw") (("1" (assert) (("1" (lemma "sub1_works") (("1" (inst -1 "1+j") (("1" (expand "semantic_rel" -1) (("1" (expand "sub_function") (("1" (assert) (("1" (lift-if) (("1" (case "(lop1, lop2, false_val, sub1`4) = sub1") (("1" (replaces -1) (("1" (case "j=0") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(1+j,y)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "sum" 1) (("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "sum" 1) (("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst?) (("2" (expand "semantic_rel") (("2" (propax) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "sum" 1) (("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (assert) (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "succ") (("2" (expand "sum_function" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (sub1 const-decl "partial_recursive" mf_pvs0_basic_programs nil) (below type-eq-decl nil nat_types nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (sub_function const-decl "nat" mf_pvs0_basic_programs nil) (sub const-decl "partial_recursive" mf_pvs0_basic_programs nil) (map adt-def-decl "list[T1]" list_adt_map nil) (TRUE const-decl "bool" booleans nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sub1_works formula-decl nil mf_pvs0_basic_programs nil) (map_nth_rw formula-decl nil more_map_props nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (below type-eq-decl nil naturalnumbers nil) (append def-decl "list[T]" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (succ const-decl "nat" mf_pvs0_basic_programs nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (O const-decl "T3" function_props nil) (length_singleton formula-decl nil more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (eval_op1 const-decl "Val" mf_pvs0_expr nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (nth def-decl "T" list_props nil) (nat_induction formula-decl nil naturalnumbers nil) (sum_function def-decl "nat" mf_pvs0_basic_programs nil) (tuple2nat const-decl "nat" tuple2nat numbers) (sum const-decl "partial_recursive" mf_pvs0_basic_programs nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (sum_function_correctness 0 (sum_function_correctness-2 nil 3797699582 ("" (induct "x") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (/= const-decl "boolean" notequal nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (sum_function def-decl "nat" mf_pvs0_basic_programs nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil) (sum_function_correctness-1 nil 3797699509 ("" (induct "x") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (sum_function def-decl "nat" mf_pvs0_basic_programs nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat_induction formula-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil)) (sum_correctness 0 (sum_correctness-1 nil 3797699835 ("" (lemma "sum_function_correctness") (("" (lemma "sum_works") (("" (skeep) (("" (inst?) (("" (inst?) (("" (replaces -2) nil nil)) nil)) nil)) nil)) nil)) nil) ((sum_works formula-decl nil mf_pvs0_basic_programs nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (sum_function_correctness formula-decl nil mf_pvs0_basic_programs nil)) nil)) (mult_TCC1 0 (mult_TCC1-2 nil 3797700234 ("" (skeep*) (("" (replaces -1) (("" (replaces -1) (("" (expand "partial_recursive?") (("" (skeep) (("" (expand "nth" 1) (("" (lift-if) (("" (prop) (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (expand "subterm") (("1" (prop) (("1" (decompose-equality) (("1" (grind) nil nil)) nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil) ("3" (decompose-equality) (("3" (expand "length" 1 1) (("3" (rewrite "length_append" 1) (("3" (rewrite "map_length") (("3" (rewrite "map_length") (("3" (assert) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (typepred "sum") (("1" (expand "partial_recursive?") (("1" (prop) (("1" (inst -4 "i-1") (("1" (lemma "valid_index_rec_offset") (("1" (inst?) (("1" (inst -1 "1") (("1" (assert) (("1" (rewrite "map_nth_rw") (("1" (expand "length" 1 1) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (expand "valid_index_rec") (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (1 -4)) (("2" (rewrite "map_length") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "map_length") (("2" (typepred "sub1") (("2" (expand "partial_recursive?") (("2" (prop) (("2" (inst -4 "-1 - length(sum`4) + i") (("1" (lemma "valid_index_rec_offset") (("1" (inst?) (("1" (inst -1 "1 + length[mf_PVS0Expr[nat]](sum`4)") (("1" (assert) (("1" (rewrite "map_nth_rw") (("1" (expand "length" 2 3) (("1" (rewrite "length_append") (("1" (rewrite "map_length") (("1" (rewrite "map_length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (1 2 4)) (("2" (typepred "i") (("2" (expand "length" -1 1) (("2" (rewrite "length_append") (("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (typepred "i") (("2" (expand "length" -1 1) (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (nth def-decl "T" list_props nil) (length_append formula-decl nil list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (map_length formula-decl nil more_map_props nil) (get_arg shared-adt-accessor-decl "[{x: mf_PVS0Expr | op1?(x) OR rec?(x)} -> mf_PVS0Expr]" mf_PVS0Expr_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (sum const-decl "partial_recursive" mf_pvs0_basic_programs nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (length def-decl "nat" list_props nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (get_from_list adt-accessor-decl "[(rec?) -> nat]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (append def-decl "list[T]" list_props nil) (sub1 const-decl "partial_recursive" mf_pvs0_basic_programs nil) (map adt-def-decl "list[T1]" list_adt_map nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (sub const-decl "partial_recursive" mf_pvs0_basic_programs nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (subterm adt-def-decl "boolean" mf_PVS0Expr_adt nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (int_plus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (valid_index_rec_offset formula-decl nil mf_pvs0_lang nil) (below type-eq-decl nil naturalnumbers nil) (map_nth_rw formula-decl nil more_map_props nil) (i skolem-const-decl "below[length(cons[mf_PVS0Expr[nat]]
                 (ite[nat]
                      (op1[nat](1, vr),
                       rec[nat]
                           (1,
                            op2[nat]
                                (1, op1[nat](2, vr),
                                 rec[nat]
                                     (0,
                                      op2[nat]
                                      (1,
                                       rec[nat]
                                       (1
                                        +
                                        length[mf_PVS0Expr[nat]](sum`4),
                                        op1[nat](1, vr)),
                                       op1[nat](2, vr))))),
                       cnst[nat](0)),
                  append[mf_PVS0Expr[nat]]
                      (map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                           (offset_rec[nat](1))(sum`4),
                       map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]]
                           (offset_rec[nat]
                                (1 + length[mf_PVS0Expr[nat]](sum`4)))
                           (sub1`4))))]" mf_pvs0_basic_programs nil) (below type-eq-decl nil nat_types nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (< const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nth_append formula-decl nil more_list_props structures) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (mult subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].ite(mf_pvs0_basic_programs.x, mf_PVS0Expr_adt[nat].rec(1, mf_PVS0Expr_adt[nat].op2(1, mf_pvs0_basic_programs.y, mf_PVS0Expr_adt[nat].rec(0, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].rec((number_fields.+)(1, list_props[mf_PVS0Expr[nat]].length(mf_pvs0_basic_programs.sum`4)), mf_pvs0_basic_programs.x), mf_pvs0_basic_programs.y)))), mf_PVS0Expr_adt[nat].cnst(0)), list_props[mf_PVS0Expr[nat]].append(list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_basic_programs.sum`4), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec((number_fields.+)(1, list_props[mf_PVS0Expr[nat]].length(mf_pvs0_basic_programs.sum`4))))(mf_pvs0_basic_programs.sub1`4))))" "partial_recursive[false_val, lop1, lop2]")) (mult_TCC1-1 nil 3797699955 ("" (subtype-tcc) nil nil) nil nil (mult subtype "(mf_pvs0_basic_programs.lop1, mf_pvs0_basic_programs.lop2, mf_pvs0_basic_programs.false_val, list_adt[mf_PVS0Expr[nat]].cons(mf_PVS0Expr_adt[nat].ite(mf_pvs0_basic_programs.x, mf_PVS0Expr_adt[nat].rec(1, mf_PVS0Expr_adt[nat].op2(1, mf_pvs0_basic_programs.y, mf_PVS0Expr_adt[nat].rec(0, mf_PVS0Expr_adt[nat].op2(1, mf_PVS0Expr_adt[nat].rec((number_fields.+)(1, list_props[mf_PVS0Expr[nat]].length(mf_pvs0_basic_programs.sum`4)), mf_pvs0_basic_programs.x), mf_pvs0_basic_programs.y)))), mf_PVS0Expr_adt[nat].cnst(0)), list_props[mf_PVS0Expr[nat]].append(list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec(1))(mf_pvs0_basic_programs.sum`4), list_adt_map[mf_PVS0Expr[nat], mf_PVS0Expr[nat]].map(mf_pvs0_lang[nat].offset_rec((number_fields.+)(1, list_props[mf_PVS0Expr[nat]].length(mf_pvs0_basic_programs.sum`4))))(mf_pvs0_basic_programs.sub1`4))))" "partial_recursive[false_val, lop1, lop2]"))) (mult_works 0 (mult_works-2 nil 3797700699 ("" (induct "x") (("1" (skeep) (("1" (expand "semantic_rel") (("1" (expand "mult" 1 2) (("1" (expand "nth") (("1" (expand "mult_function") (("1" (expand "semantic_rel_expr") (("1" (inst 1 "0") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(0,y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "mult") (("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand "semantic_rel_expr") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (expand "semantic_rel" 1) (("2" (expand "mult" 1 2) (("2" (expand "nth" 1) (("2" (expand "semantic_rel_expr") (("2" (inst 1 "1+j") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(1+j,y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "mult" 1) (("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 2 "tuple2nat(y,mult_function(j,y))") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "y" "mult_function(j,y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(1+j,y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "mult" 1) (("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(j,y)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "j" "y") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "1+j") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(1+j,y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "mult" 1) (("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mult" 1) (("2" (expand "nth" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil nil) ("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_length") (("1" (assert) nil nil)) nil) ("2" (rewrite "map_length") (("2" (assert) (("2" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(sub1`4,0)" "sub1`4" "cons(ite(op1[nat](1, vr),
                                                                                 rec(1,
                                                                                     op2
                                                                                     (1,
                                                                                      op1[nat](2, vr),
                                                                                      rec
                                                                                      (0,
                                                                                       op2
                                                                                       (1,
                                                                                        rec
                                                                                        (1 + length(sum`4),
                                                                                         op1[nat](1, vr)),
                                                                                        op1[nat](2, vr))))),
                                                                                 cnst(0)),map(offset_rec(1))(sum`4))" "lop1" "lop2" "1+j" "j") (("1" (expand "append" -1) (("1" (expand "length" -1 2) (("1" (expand "length" -1 3) (("1" (rewrite "map_length") (("1" (assert) (("1" (hide-all-but 1) (("1" (lemma "sub1_works") (("1" (inst -1 "1+j") (("1" (case "(lop1, lop2, false_val, sub1`4) = sub1") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (hide -1 2) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(1+j,y)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil nil)) nil) ("2" (expand "mult" 1) (("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "mult" 1) (("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst?) (("2" (expand "semantic_rel") (("2" (propax) nil nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("3" (expand "mult" 1) (("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mult" 1) (("2" (expand "nth") (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(sum`4,0)" "append[mf_PVS0Expr[nat]]
                                                             (sum`4,
                                                              map(offset_rec( length(sum`4)))
                                                                 (sub1`4))" "(: ite(op1[nat](1, vr),
                                                             rec(1,
                                                                 op2
                                                                 (1,
                                                                  op1[nat](2, vr),
                                                                  rec
                                                                  (0,
                                                                   op2
                                                                   (1,
                                                                    rec
                                                                    (1 + length(sum`4),
                                                                     op1[nat](1, vr)),
                                                                    op1[nat](2, vr))))),
                                                             cnst(0)) :)" "lop1" "lop2" "tuple2nat(y, mult_function(j, y))" "mult_function(1 + j, y)") (("1" (expand "append" -1 2) (("1" (expand "append" -1 2) (("1" (expand "length" -1 3) (("1" (expand "length" -1 3) (("1" (expand "length" -1 4) (("1" (expand "length" -1 4) (("1" (rewrite "map_append") (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(sum`4,0)" "sum`4" "map(offset_rec(length(sum`4)))(sub1`4)" "lop1" "lop2" "tuple2nat(y, mult_function(j, y))" "mult_function(1 + j, y)") (("1" (assert) (("1" (hide-all-but 1) (("1" (lemma "sum_correctness") (("1" (inst?) (("1" (expand "semantic_rel") (("1" (expand "mult_function" 1 2) (("1" (case "(lop1, lop2, false_val, sum`4) = sum") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (hide-all-but 1) (("3" (typepred "sum") (("3" (expand "partial_recursive?") (("3" (prop) (("3" (inst -4 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (map_append formula-decl nil map_append nil) (offset_composition2 formula-decl nil mf_pvs0_lang nil) (add_rec_list2 formula-decl nil mf_pvs0_lang nil) (NOT const-decl "[bool -> bool]" booleans nil) (sum_correctness formula-decl nil mf_pvs0_basic_programs nil) (valid_index_rec const-decl "bool" mf_pvs0_lang nil) (map_list_composition formula-decl nil map_props nil) (nth_append formula-decl nil more_list_props structures) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (map_length formula-decl nil more_map_props nil) (add_rec_list formula-decl nil mf_pvs0_lang nil) (cnst adt-constructor-decl "[T -> (cnst?)]" mf_PVS0Expr_adt nil) (cnst? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op2 adt-constructor-decl "[[nat, mf_PVS0Expr, mf_PVS0Expr] -> (op2?)]" mf_PVS0Expr_adt nil) (op2? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (rec adt-constructor-decl "[[nat, mf_PVS0Expr] -> (rec?)]" mf_PVS0Expr_adt nil) (rec? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" mf_PVS0Expr_adt nil) (vr? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (op1 adt-constructor-decl "[[nat, mf_PVS0Expr] -> (op1?)]" mf_PVS0Expr_adt nil) (op1? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (ite adt-constructor-decl "[[mf_PVS0Expr, mf_PVS0Expr, mf_PVS0Expr] -> (ite?)]" mf_PVS0Expr_adt nil) (ite? adt-recognizer-decl "[mf_PVS0Expr -> boolean]" mf_PVS0Expr_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (below type-eq-decl nil nat_types nil) (sub_function const-decl "nat" mf_pvs0_basic_programs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (sub1_works formula-decl nil mf_pvs0_basic_programs nil) (map_nth_rw formula-decl nil more_map_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (eval_op2 const-decl "Val" mf_pvs0_expr nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (pi2 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (sub const-decl "partial_recursive" mf_pvs0_basic_programs nil) (offset_rec def-decl "mf_PVS0Expr" mf_pvs0_lang nil) (map adt-def-decl "list[T1]" list_adt_map nil) (sub1 const-decl "partial_recursive" mf_pvs0_basic_programs nil) (sum const-decl "partial_recursive" mf_pvs0_basic_programs nil) (append def-decl "list[T]" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (eval_op1 const-decl "Val" mf_pvs0_expr nil) (length def-decl "nat" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length_singleton formula-decl nil more_list_props structures) (O const-decl "T3" function_props nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (pi1 const-decl "[nat -> nat]" mf_pvs0_basic_programs nil) (semantic_rel_expr inductive-decl "bool" mf_pvs0_expr nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nth def-decl "T" list_props nil) (nat_induction formula-decl nil naturalnumbers nil) (mult_function def-decl "nat" mf_pvs0_basic_programs nil) (tuple2nat const-decl "nat" tuple2nat numbers) (mult const-decl "partial_recursive" mf_pvs0_basic_programs nil) (partial_recursive type-eq-decl nil mf_pvs0_computable nil) (partial_recursive? const-decl "bool" mf_pvs0_computable nil) (lop2 const-decl "list[[[nat, nat] -> nat]]" mf_pvs0_basic_programs nil) (lop1 const-decl "list[[nat -> nat]]" mf_pvs0_basic_programs nil) (false_val const-decl "nat" mf_pvs0_basic_programs nil) (semantic_rel const-decl "bool" mf_pvs0_lang nil) (PVS0 type-eq-decl nil mf_pvs0_expr nil) (lmf_PVS0Expr type-eq-decl nil mf_pvs0_expr nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" mf_PVS0Expr_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (mf_PVS0Expr type-decl nil mf_PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil mf_pvs0_expr nil) (EvalOp1 type-eq-decl nil mf_pvs0_expr nil) (list type-decl nil list_adt nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil) (mult_works-1 nil 3797700523 ("" (induct "x") (("1" (skeep) (("1" (expand "semantic_rel") (("1" (expand "mult" 1 2) (("1" (expand "nth") (("1" (expand "mult_function") (("1" (expand "semantic_rel_expr") (("1" (inst 1 "0") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(0,y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil))) ("2" (expand "mult") (("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil))))))))))))))))))))))))))))) ("2" (grind) nil) ("3" (expand "semantic_rel_expr") (("3" (propax) nil))))))))))))))))))) ("2" (skeep*) (("2" (expand "semantic_rel" 1) (("2" (expand "mult" 1 2) (("2" (expand "nth" 1) (("2" (expand "semantic_rel_expr") (("2" (inst 1 "1+j") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(1+j,y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil))) ("2" (expand "mult" 1) (("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil))))))))))))))))))))))))))))) ("2" (expand "semantic_rel_expr") (("2" (inst 2 "tuple2nat(y,mult_function(j,y))") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "y" "mult_function(j,y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(1+j,y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil))) ("2" (expand "mult" 1) (("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil))))))))))))))))))))))))))))))))) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(j,y)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "j" "y") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "1+j") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (inst 1 "tuple2nat(1+j,y)") (("1" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil))) ("2" (expand "mult" 1) (("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi1") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil))))))))))))))))))))))))))))) ("2" (expand "mult" 1) (("2" (expand "nth" 1) (("2" (lift-if) (("2" (prop) (("1" (grind) nil) ("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_length") (("1" (assert) nil))) ("2" (rewrite "map_length") (("2" (assert) (("2" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(sub1`4,0)" "sub1`4" "cons(ite(op1[nat](1, vr),
                                                         rec(1,
                                                             op2
                                                             (1,
                                                              op1[nat](2, vr),
                                                              rec
                                                              (0,
                                                               op2
                                                               (1,
                                                                rec
                                                                (1 + length(sum`4),
                                                                 op1[nat](1, vr)),
                                                                op1[nat](2, vr))))),
                                                         cnst(0)),map(offset_rec(1))(sum`4))" "lop1" "lop2" "1+j" "j") (("1" (expand "append" -1) (("1" (expand "length" -1 2) (("1" (expand "length" -1 3) (("1" (rewrite "map_length") (("1" (assert) (("1" (hide-all-but 1) (("1" (lemma "sub1_works") (("1" (inst -1 "1+j") (("1" (case "(lop1, lop2, false_val, sub1`4) = sub1") (("1" (replaces -1) (("1" (grind) nil))) ("2" (hide -1 2) (("2" (decompose-equality) (("1" (grind) nil) ("2" (grind) nil) ("3" (grind) nil))))))))))))))))))))))))))))) ("2" (grind) nil))))))))))) ("2" (rewrite "map_length") (("2" (rewrite "map_length") (("2" (grind) nil))))))))))))))) ("3" (grind) nil))))))) ("2" (expand "semantic_rel_expr") (("2" (inst 1 "tuple2nat(1+j,y)") (("2" (prop) (("1" (expand "semantic_rel_expr") (("1" (propax) nil))) ("2" (expand "mult" 1) (("2" (expand "eval_op1") (("2" (expand "lop1") (("2" (expand "length") (("2" (expand "length") (("2" (expand "length") (("2" (assert) (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "nth") (("2" (expand "pi2") (("2" (expand "o ") (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) nil))))))))))))))))))))))))))))))))) ("3" (expand "mult" 1) (("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil))))))))))))))))))))))) ("2" (inst?) (("2" (expand "semantic_rel") (("2" (propax) nil))))) ("3" (grind) nil))))))) ("3" (expand "mult" 1) (("3" (expand "eval_op2") (("3" (expand "lop2") (("3" (expand "length") (("3" (expand "length") (("3" (assert) (("3" (expand "nth") (("3" (expand "nth") (("3" (propax) nil))))))))))))))))))))))) ("2" (expand "mult" 1) (("2" (expand "nth") (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (rewrite "map_nth_rw") (("1" (lemma "add_rec_list") (("1" (inst -1 "false_val" "nth(sum`4,0)" "append[mf_PVS0Expr[nat]]
                                               (sum`4,
                                                map(offset_rec( length(sum`4)))
                                                   (sub1`4))" "(: ite(op1[nat](1, vr),
                                               rec(1,
                                                   op2
                                                   (1,
                                                    op1[nat](2, vr),
                                                    rec
                                                    (0,
                                                     op2
                                                     (1,
                                                      rec
                                                      (1 + length(sum`4),
                                                       op1[nat](1, vr)),
                                                      op1[nat](2, vr))))),
                                               cnst(0)) :)" "lop1" "lop2" "tuple2nat(y, mult_function(j, y))" "mult_function(1 + j, y)") (("1" (expand "append" -1 2) (("1" (expand "append" -1 2) (("1" (expand "length" -1 3) (("1" (expand "length" -1 3) (("1" (expand "length" -1 4) (("1" (expand "length" -1 4) (("1" (rewrite "map_append") (("1" (rewrite "map_list_composition") (("1" (rewrite "offset_composition2") (("1" (assert) (("1" (lemma "add_rec_list2") (("1" (inst -1 "false_val" "nth(sum`4,0)" "sum`4" "map(offset_rec(length(sum`4)))(sub1`4)" "lop1" "lop2" "tuple2nat(y, mult_function(j, y))" "mult_function(1 + j, y)") (("1" (assert) (("1" (hide-all-but 1) (("1" (lemma "sum_correctness") (("1" (inst?) (("1" (expand "semantic_rel") (("1" (expand "mult_function" 1 2) (("1" (case "(lop1, lop2, false_val, sum`4) = sum") (("1" (replaces -1) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil) ("2" (grind) nil) ("3" (grind) nil))))))))))))))))))) ("2" (grind) nil) ("3" (hide-all-but 1) (("3" (typepred "sum") (("3" (expand "partial_recursive?") (("3" (prop) (("3" (inst -4 "0") nil))))))))))))))))))))))))))))))))) ("2" (grind) nil) ("3" (grind) nil))))) ("2" (grind) nil))) ("2" (grind) nil))))) ("2" (grind) nil))))))) ("3" (grind) nil))))))) ("3" (grind) nil)))))))))))))))) nil) nil nil)) (mult_function_correctness 0 (mult_function_correctness-1 nil 3797775313 ("" (induct "x") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil) ((nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (/= const-decl "boolean" notequal nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat_induction formula-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (mult_function def-decl "nat" mf_pvs0_basic_programs nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil)) (mult_correctness 0 (mult_correctness-1 nil 3797775524 ("" (lemma "mult_works") (("" (lemma "mult_function_correctness") (("" (skeep) (("" (inst?) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((mult_function_correctness formula-decl nil mf_pvs0_basic_programs nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (mult_works formula-decl nil mf_pvs0_basic_programs nil)) nil)))
