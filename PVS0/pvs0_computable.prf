(pvs0_computable (pvs0_level_TCC1 0 (pvs0_level_TCC1-1 nil 3790336036 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (pvs0_level subtype "(number_fields.-)(pvs0_computable.n, 1)" "nat"))) (level_surjective 0 (level_surjective-2 "" 3881375801 ("" (measure-induct+ "n" "n") (("" (case "x!1=0") (("1" (inst 1 "lambda(n: nat): (lop1, lop2,false_val, nat2PVS0(n))") (("1" (expand "surjective?") (("1" (skeep) (("1" (inst 1 "PVS02nat(y`4)") (("1" (rewrite "nat2PVS0_inverse") (("1" (typepred "y") (("1" (replace -2) (("1" (expand "pvs0_level") (("1" (prop) (("1" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (replace -1) (("2" (expand "pvs0_level") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "x!1-1") (("1" (assert) (("1" (case "let t = (lambda(pvs0: PVS0): pvs0_level(x!1-1)(pvs0) and terminating?(pvs0)) in exists(f: [nat -> (t)]): surjective?(f)") (("1" (hide -2) (("1" (beta) (("1" (skeep) (("1" (inst 2 "lambda(n : nat): let p1= nat2tuple(nat2tuple(n)`1)`1, p2 = nat2tuple(nat2tuple(n)`1)`2 , p3 = nat2tuple(n)`2 in ( append(f(p1)`1,(:lambda(x: nat): choose({r :nat | semantic_rel(f(p1))(x,r)}):)), append(f(p2)`2, (:lambda(x : [nat,nat]): choose({r:nat | semantic_rel(f(p2))(tuple2nat(x),r)}):)),false_val, nat2PVS0(p3))") (("1" (expand "surjective?") (("1" (skeep) (("1" (typepred "y") (("1" (expand "pvs0_level") (("1" (prop) (("1" (skeep) (("1" (skeep) (("1" (inst-cp -6 "p") (("1" (inst -6 "p!1") (("1" (skeep) (("1" (skeep) (("1" (inst 2 "tuple2nat(tuple2nat(x!2,x),PVS02nat(y`4))") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (rewrite "nat2PVS0_inverse") (("1" (decompose-equality 2) (("1" (rewrite "list_extensionality" 1) (("1" (prop) (("1" (rewrite "length_append") (("1" (replace -7) (("1" (propax) nil nil)) nil)) nil) ("2" (skeep) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (inst -4 "n") (("1" (assert) nil nil)) nil) ("2" (case "n=length(f(x!2)`1)") (("1" (replace -1) (("1" (assert) (("1" (expand "nth" 2 1) (("1" (inst -4 "n") (("1" (assert) (("1" (decompose-equality 2) (("1" (inst -4 "x!3") (("1" (typepred " choose({r: nat | semantic_rel(f(x!2))(x!3, r)})") (("1" (lemma "deterministic") (("1" (inst?) (("1" (inst -1 "nth(y`1, n)(x!3)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x!2)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "x!3") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x!2)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "x!3") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x!2)") (("2" (hide -1) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "x_2") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (rewrite "length_append") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "list_extensionality" 1) (("2" (rewrite "length_append") (("2" (assert) (("2" (skeep) (("2" (typepred "n") (("2" (rewrite "length_append") (("2" (rewrite "nth_append") (("2" (lift-if) (("2" (prop) (("1" (inst -7 "n") (("1" (assert) nil nil)) nil) ("2" (case "n=length(f(x)`2)") (("1" (replace -1) (("1" (assert) (("1" (expand "nth" 2 1) (("1" (inst -7 "n") (("1" (assert) (("1" (hide-all-but (-1 -7 -8 2)) (("1" (expand "semantic_rel") (("1" (decompose-equality 1) (("1" (inst -2 "x!3" "x!4") (("1" (typepred "choose({r: nat |
                                                                                                                                        semantic_rel_expr(f(x))
                                                                                                                                                         (get_body(f(x)), tuple2nat(x!3, x!4), r)})") (("1" (lemma "deterministic") (("1" (inst?) (("1" (inst -1 "tuple2nat(x!3, x!4)" "f(x)") (("1" (expand "semantic_rel") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(x!3,x!4)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(x!3,x!4)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "member") (("2" (inst -3 "x_2`1" "x_2`2") (("2" (case-replace "(x_2`1, x_2`2) = x_2") (("1" (replace -5) (("1" (inst?) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -5 "length(p!1`2)") (("1" (assert) (("1" (hide-all-but (-5 1)) (("1" (expand "terminating?") (("1" (expand "terminates_expr") (("1" (skeep) (("1" (inst -1 "nat2tuple(env)`1" "nat2tuple(env)`2") (("1" (assert) (("1" (case "(nat2tuple(env)`1, nat2tuple(env)`2) = nat2tuple(env)") (("1" (replaces -1) (("1" (rewrite "tuple2nat_nat2tuple") (("1" (inst 1 "nth(y`2, length(p!1`2))(nat2tuple(env))") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (inst -3 "length(p`1)") (("1" (assert) (("1" (hide-all-but (-3 1)) (("1" (expand "terminating?") (("1" (expand "terminates_expr") (("1" (skeep) (("1" (inst -1 "env") (("1" (inst 1 "nth(y`1, length(p`1))(env)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (replace -1) (("2" (replace -2) (("2" (replace -3) (("2" (expand "pvs0_level" 1) (("2" (prop) (("1" (inst 1 "f(nat2tuple(nat2tuple(n)`1)`1)") (("1" (prop) (("1" (rewrite "length_append") nil nil) ("2" (skeep) (("2" (prop) (("1" (rewrite "nth_append") (("1" (assert) nil nil)) nil) ("2" (case "i=length(f(nat2tuple(nat2tuple(n)`1)`1)`1)") (("1" (replace -1) (("1" (rewrite "nth_append") (("1" (expand "nth" 2) (("1" (skeep) (("1" (typepred "choose[nat]
                                                                                                         ({r: nat |
                                                                                                             semantic_rel[nat]
                                                                                                                 (f(nat2tuple(nat2tuple(n)`1)`1))(env, r)})") (("1" (propax) nil nil) ("2" (hide-all-but 1) (("2" (typepred "f(nat2tuple(nat2tuple(n)`1)`1)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "env") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "f(nat2tuple(nat2tuple(n)`1)`2)") (("2" (prop) (("1" (rewrite "length_append") nil nil) ("2" (skeep) (("2" (prop) (("1" (rewrite "nth_append") (("1" (assert) nil nil)) nil) ("2" (case "i=length(f(nat2tuple(nat2tuple(n)`1)`2)`2)") (("1" (skeep) (("1" (replaces -1) (("1" (rewrite "nth_append") (("1" (expand "nth") (("1" (typepred " choose[nat]
                                                                                                       ({r: nat |
                                                                                                           semantic_rel[nat]
                                                                                                               (f(nat2tuple(nat2tuple(n)`1)`2))
                                                                                                               (tuple2nat(env1, env2), r)})") (("1" (propax) nil nil) ("2" (hide-all-but 1) (("2" (typepred "f(nat2tuple(nat2tuple(n)`1)`2)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(env1, env2)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (beta) (("2" (skeep) (("2" (case "injective?(inverse(f))") (("1" (case "EXISTS (f:
                                                                                           [
                                                                                              (LAMBDA (pvs0: PVS0):
                                                                                                 pvs0_level(x!1 - 1)(pvs0) AND terminating?(pvs0))->nat]):
                                                                                   injective?(f)") (("1" (skeep) (("1" (inst 1 "inverse(f!1)") (("1" (rewrite "surj_inv") (("1" (expand "surjective?" 2) (("1" (skeep) (("1" (inst 1 "y") nil nil)) nil)) nil)) nil) ("2" (case "forall(n : nat): exists(x : (LAMBDA (pvs0: PVS0[nat]):
                                                                                                                  pvs0_level(n)(pvs0) AND terminating?[nat](pvs0))): true") (("1" (inst -1 "x!1-1") nil nil) ("2" (hide-all-but 1) (("2" (measure-induct+ "n" "n") (("2" (case "x!2=0") (("1" (hide -2) (("1" (inst 1 "(lop1,lop2,false_val,vr)") (("1" (expand "pvs0_level") (("1" (assert) (("1" (grind) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "x!2-1") (("1" (assert) (("1" (skeep) (("1" (typepred "x") (("1" (inst 2 "(append (x`1, (:lambda(n: nat): choose({r: nat | semantic_rel(x)(n,r)}):)),append (x`2, (:lambda(n: [nat,nat]): choose({r: nat | semantic_rel(x)(tuple2nat(n),r)}):)),false_val,vr)") (("1" (prop) (("1" (expand "pvs0_level" 1) (("1" (prop) (("1" (inst 1 "x") (("1" (assert) (("1" (prop) (("1" (rewrite "length_append") nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (rewrite "length_append") (("2" (prop) (("1" (rewrite "nth_append") (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (rewrite "nth_append") (("2" (case "i = length(x`1)") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (typepred "choose[nat]({r: nat | semantic_rel[nat](x)(env, r)})") (("1" (propax) nil nil) ("2" (hide-all-but (-3 1)) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "env") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x") (("2" (prop) (("1" (rewrite "length_append") nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (rewrite "length_append") (("2" (prop) (("1" (rewrite "nth_append") (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (rewrite "nth_append") (("2" (case "i = length(x`2)") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (typepred "choose[nat]({r: nat | semantic_rel[nat](x)(tuple2nat(env1,env2), r)})") (("1" (propax) nil nil) ("2" (hide-all-but (-3 1)) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(env1,env2)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) (("2" (expand "semantic_rel_expr") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (inst 1 "inverse(f)") (("2" (expand "injective?") (("2" (skeep) (("2" (inst -2 "x1" "x2") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "inj_inv") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) nil shostak) (level_surjective-1 "" 3759047686 ("" (measure-induct+ "n" "n") (("" (case "x!1=0") (("1" (inst 1 "lambda(n: nat): (lop1, lop2,false_val, nat2PVS0(n))") (("1" (expand "surjective?") (("1" (skeep) (("1" (inst 1 "PVS02nat(y`4)") (("1" (rewrite "nat2PVS0_inverse") (("1" (typepred "y") (("1" (replace -2) (("1" (expand "pvs0_level") (("1" (prop) (("1" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (replace -1) (("2" (expand "pvs0_level") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "x!1-1") (("1" (assert) (("1" (case "let t = (lambda(pvs0: PVS0): pvs0_level(x!1-1)(pvs0) and terminating?(pvs0)) in exists(f: [nat -> (t)]): surjective?(f)") (("1" (hide -2) (("1" (beta) (("1" (skeep) (("1" (inst 2 "lambda(n : nat): let p1= nat2tuple(nat2tuple(n)`1)`1, p2 = nat2tuple(nat2tuple(n)`1)`2 , p3 = nat2tuple(n)`2 in ( append(f(p1)`1,(:lambda(x: nat): choose({r :nat | semantic_rel(f(p1))(x,r)}):)), append(f(p2)`2, (:lambda(x : [nat,nat]): choose({r:nat | semantic_rel(f(p2))(tuple2nat(x),r)}):)),false_val, nat2PVS0(p3))") (("1" (expand "surjective?") (("1" (skeep) (("1" (typepred "y") (("1" (expand "pvs0_level") (("1" (prop) (("1" (skeep) (("1" (skeep) (("1" (inst-cp -6 "p") (("1" (inst -6 "p!1") (("1" (skeep) (("1" (skeep) (("1" (inst 2 "tuple2nat(tuple2nat(x!2,x),PVS02nat(y`4))") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (rewrite "nat2PVS0_inverse") (("1" (decompose-equality 2) (("1" (rewrite "list_extensionality" 1) (("1" (prop) (("1" (rewrite "length_append") (("1" (replace -7) (("1" (propax) nil nil)) nil)) nil) ("2" (skeep) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (inst -4 "n") (("1" (assert) nil nil)) nil) ("2" (case "n=length(f(x!2)`1)") (("1" (replace -1) (("1" (assert) (("1" (expand "nth" 2 1) (("1" (inst -4 "n") (("1" (assert) (("1" (decompose-equality 2) (("1" (inst -4 "x!3") (("1" (typepred " choose({r: nat | semantic_rel(f(x!2))(x!3, r)})") (("1" (lemma "deterministic") (("1" (inst?) (("1" (inst -1 "nth(y`1, n)(x!3)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x!2)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "x!3") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x!2)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "x!3") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) (("2" (inst -4 "x1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (rewrite "nat2tuple_tuple2nat") (("3" (assert) (("3" (rewrite "nat2tuple_tuple2nat") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (typepred "f(x!2)") (("4" (hide -1) (("4" (skeep) (("4" (expand "terminating?") (("4" (expand "terminates_expr") (("4" (inst -1 "x_2") (("4" (skeep) (("4" (expand "nonempty?") (("4" (expand "empty?") (("4" (inst -2 "val") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (rewrite "length_append") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "list_extensionality" 1) (("2" (rewrite "length_append") (("2" (assert) (("2" (skeep) (("2" (typepred "n") (("2" (rewrite "length_append") (("2" (rewrite "nth_append") (("2" (lift-if) (("2" (prop) (("1" (inst -7 "n") (("1" (assert) nil nil)) nil) ("2" (case "n=length(f(x)`2)") (("1" (replace -1) (("1" (assert) (("1" (expand "nth" 2 1) (("1" (inst -7 "n") (("1" (assert) (("1" (hide-all-but (-1 -7 -8 2)) (("1" (expand "semantic_rel") (("1" (decompose-equality 1) (("1" (inst -2 "x!3" "x!4") (("1" (typepred "choose({r: nat |
                                                                                                                                        semantic_rel_expr(f(x))
                                                                                                                                                         (get_body(f(x)), tuple2nat(x!3, x!4), r)})") (("1" (lemma "deterministic") (("1" (inst?) (("1" (inst -1 "tuple2nat(x!3, x!4)" "f(x)") (("1" (expand "semantic_rel") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(x!3,x!4)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(x!3,x!4)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (typepred "f(x)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (reveal -3) (("2" (reveal -4) (("2" (replace -1) (("2" (inst -2 "x1`1" "x1`2") (("2" (case-replace "(x1`1, x1`2) = x1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (expand "nonempty?") (("3" (expand "empty?") (("3" (expand "member") (("3" (inst -3 "x_2`1" "x_2`2") (("3" (case-replace "(x_2`1, x_2`2) = x_2") (("1" (replace -5) (("1" (inst?) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -5 "length(p!1`2)") (("1" (assert) (("1" (hide-all-but (-5 1)) (("1" (expand "terminating?") (("1" (expand "terminates_expr") (("1" (skeep) (("1" (inst -1 "nat2tuple(env)`1" "nat2tuple(env)`2") (("1" (assert) (("1" (case "(nat2tuple(env)`1, nat2tuple(env)`2) = nat2tuple(env)") (("1" (replaces -1) (("1" (rewrite "tuple2nat_nat2tuple") (("1" (inst 1 "nth(y`2, length(p!1`2))(nat2tuple(env))") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (inst -3 "length(p`1)") (("1" (assert) (("1" (hide-all-but (-3 1)) (("1" (expand "terminating?") (("1" (expand "terminates_expr") (("1" (skeep) (("1" (inst -1 "env") (("1" (inst 1 "nth(y`1, length(p`1))(env)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (skeep) (("2" (replace -1) (("2" (replace -2) (("2" (replace -3) (("2" (expand "pvs0_level" 1) (("2" (prop) (("1" (inst 1 "f(nat2tuple(nat2tuple(n)`1)`1)") (("1" (prop) (("1" (rewrite "length_append") nil nil) ("2" (skeep) (("2" (prop) (("1" (rewrite "nth_append") (("1" (assert) nil nil)) nil) ("2" (case "i=length(f(nat2tuple(nat2tuple(n)`1)`1)`1)") (("1" (replace -1) (("1" (rewrite "nth_append") (("1" (expand "nth" 2) (("1" (skeep) (("1" (typepred "choose[nat]
                                                                                                         ({r: nat |
                                                                                                             semantic_rel[nat]
                                                                                                                 (f(nat2tuple(nat2tuple(n)`1)`1))(env, r)})") (("1" (propax) nil nil) ("2" (hide-all-but 1) (("2" (typepred "f(nat2tuple(nat2tuple(n)`1)`1)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "env") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "f(nat2tuple(nat2tuple(n)`1)`2)") (("2" (prop) (("1" (rewrite "length_append") nil nil) ("2" (skeep) (("2" (prop) (("1" (rewrite "nth_append") (("1" (assert) nil nil)) nil) ("2" (case "i=length(f(nat2tuple(nat2tuple(n)`1)`2)`2)") (("1" (skeep) (("1" (replaces -1) (("1" (rewrite "nth_append") (("1" (expand "nth") (("1" (typepred " choose[nat]
                                                                                                       ({r: nat |
                                                                                                           semantic_rel[nat]
                                                                                                               (f(nat2tuple(nat2tuple(n)`1)`2))
                                                                                                               (tuple2nat(env1, env2), r)})") (("1" (propax) nil nil) ("2" (hide-all-but 1) (("2" (typepred "f(nat2tuple(nat2tuple(n)`1)`2)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(env1, env2)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (beta) (("2" (skeep) (("2" (case "injective?(inverse(f))") (("1" (case "EXISTS (f:
                                                                                           [
                                                                                              (LAMBDA (pvs0: PVS0):
                                                                                                 pvs0_level(x!1 - 1)(pvs0) AND terminating?(pvs0))->nat]):
                                                                                   injective?(f)") (("1" (skeep) (("1" (inst 1 "inverse(f!1)") (("1" (rewrite "surj_inv") (("1" (expand "surjective?" 2) (("1" (skeep) (("1" (inst 1 "y") nil nil)) nil)) nil)) nil) ("2" (case "forall(n : nat): exists(x : (LAMBDA (pvs0: PVS0[nat]):
                                                                                                                  pvs0_level(n)(pvs0) AND terminating?[nat](pvs0))): true") (("1" (inst -1 "x!1-1") nil nil) ("2" (hide-all-but 1) (("2" (measure-induct+ "n" "n") (("2" (case "x!2=0") (("1" (hide -2) (("1" (inst 1 "(lop1,lop2,false_val,vr)") (("1" (expand "pvs0_level") (("1" (assert) (("1" (grind) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "x!2-1") (("1" (assert) (("1" (skeep) (("1" (typepred "x") (("1" (inst 2 "(append (x`1, (:lambda(n: nat): choose({r: nat | semantic_rel(x)(n,r)}):)),append (x`2, (:lambda(n: [nat,nat]): choose({r: nat | semantic_rel(x)(tuple2nat(n),r)}):)),false_val,vr)") (("1" (prop) (("1" (expand "pvs0_level" 1) (("1" (prop) (("1" (inst 1 "x") (("1" (assert) (("1" (prop) (("1" (rewrite "length_append") nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (rewrite "length_append") (("2" (prop) (("1" (rewrite "nth_append") (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (rewrite "nth_append") (("2" (case "i = length(x`1)") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (typepred "choose[nat]({r: nat | semantic_rel[nat](x)(env, r)})") (("1" (propax) nil nil) ("2" (hide-all-but (-3 1)) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "env") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x") (("2" (prop) (("1" (rewrite "length_append") nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (rewrite "length_append") (("2" (prop) (("1" (rewrite "nth_append") (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (rewrite "nth_append") (("2" (case "i = length(x`2)") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (typepred "choose[nat]({r: nat | semantic_rel[nat](x)(tuple2nat(env1,env2), r)})") (("1" (propax) nil nil) ("2" (hide-all-but (-3 1)) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(env1,env2)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) (("2" (expand "semantic_rel_expr") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (inst 1 "inverse(f)") (("2" (expand "injective?") (("2" (skeep) (("2" (inst -2 "x1" "x2") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "inj_inv") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (PVS02nat def-decl "nat" pvs0_to_nat nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat2PVS0_inverse formula-decl nil pvs0_to_nat nil) (nat2PVS0 def-decl "PVS0Expr" pvs0_to_nat nil) (false_val formal-const-decl "nat" pvs0_computable nil) (lop2 formal-const-decl "list[[[nat, nat] -> nat]]" pvs0_computable nil) (lop1 formal-const-decl "list[[nat -> nat]]" pvs0_computable nil) nil (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (injective? const-decl "bool" functions nil) (inverse const-decl "D" function_inverse nil) (restrict const-decl "R" restrict nil) nil nil (vr? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (vr adt-constructor-decl "(vr?)" PVS0Expr_adt nil) (surj_inv formula-decl nil function_inverse nil) (inj_inv formula-decl nil function_inverse nil) nil (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) nil nil (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (list_extensionality formula-decl nil more_list_props structures) nil nil nil (below type-eq-decl nil nat_types nil) nil (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (terminates_expr const-decl "bool" pvs0_expr nil) (deterministic formula-decl nil pvs0_lang nil) (nth def-decl "T" list_props nil) (nth_append formula-decl nil more_list_props structures) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (length_append formula-decl nil list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_singleton formula-decl nil more_list_props structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (tuple2nat_nat2tuple formula-decl nil tuple2nat numbers) nil (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (append def-decl "list[T]" list_props nil) nil (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (semantic_rel const-decl "bool" pvs0_lang nil) (tuple2nat const-decl "nat" tuple2nat numbers) (terminating? const-decl "bool" pvs0_lang nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (surjective? const-decl "bool" functions nil) (pvs0_level inductive-decl "bool" pvs0_computable nil) (PVS0 type-eq-decl nil pvs0_expr nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (list type-decl nil list_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak) (level_surjective-8 "new definition for pvs0_level" 3743076113 ("" (measure-induct+ "n" "n") (("" (case "x!1=0") (("1" (inst 1 "lambda(n: nat): (lop1, lop2,false_val, nat2PVS0(n))") (("1" (expand "surjective?") (("1" (skeep) (("1" (inst 1 "PVS02nat(y`4)") (("1" (rewrite "nat2PVS0_inverse") (("1" (typepred "y") (("1" (replace -2) (("1" (expand "pvs0_level") (("1" (prop) (("1" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (replace -1) (("2" (expand "pvs0_level") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "x!1-1") (("1" (assert) (("1" (case "let t = (lambda(pvs0: PVS0): pvs0_level(x!1-1)(pvs0) and terminating?(pvs0)) in exists(f: [nat -> (t)]): surjective?(f)") (("1" (hide -2) (("1" (beta) (("1" (skeep) (("1" (inst 2 "lambda(n : nat): let p1= nat2tuple(nat2tuple(n)`1)`1, p2 = nat2tuple(nat2tuple(n)`1)`2 , p3 = nat2tuple(n)`2 in ( append(f(p1)`1,(:lambda(x: nat): choose({r :nat | semantic_rel(f(p1))(x,r)}):)), append(f(p2)`2, (:lambda(x : [nat,nat]): choose({r:nat | semantic_rel(f(p2))(tuple2nat(x),r)}):)),false_val, nat2PVS0(p3))") (("1" (expand "surjective?") (("1" (skeep) (("1" (typepred "y") (("1" (expand "pvs0_level") (("1" (prop) (("1" (skeep) (("1" (skeep) (("1" (inst-cp -6 "p") (("1" (inst -6 "p!1") (("1" (skeep) (("1" (skeep) (("1" (inst 2 "tuple2nat(tuple2nat(x!2,x),PVS02nat(y`4))") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (rewrite "nat2PVS0_inverse") (("1" (decompose-equality 2) (("1" (rewrite "list_extensionality" 1) (("1" (prop) (("1" (rewrite "length_append") (("1" (replace -7) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (typepred "f(x!2)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "x_2") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (inst -4 "n") (("1" (assert) nil nil)) nil) ("2" (case "n=length(f(x!2)`1)") (("1" (replace -1) (("1" (assert) (("1" (expand "nth" 2 1) (("1" (inst -4 "n") (("1" (assert) (("1" (decompose-equality 2) (("1" (inst -4 "x!3") (("1" (typepred " choose({r: nat | semantic_rel(f(x!2))(x!3, r)})") (("1" (lemma "deterministic") (("1" (inst?) (("1" (inst -1 "nth(y`1, n)(x!3)") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x!2)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "x!3") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x!2)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "x!3") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) (("2" (rewrite "nat2tuple_tuple2nat") (("2" (assert) (("2" (inst -4 "x1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (rewrite "nat2tuple_tuple2nat") (("3" (assert) (("3" (rewrite "nat2tuple_tuple2nat") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (typepred "f(x!2)") (("4" (hide -1) (("4" (skeep) (("4" (expand "terminating?") (("4" (expand "terminates_expr") (("4" (inst -1 "x_2") (("4" (skeep) (("4" (expand "nonempty?") (("4" (expand "empty?") (("4" (inst -2 "val") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (rewrite "length_append") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "f(x!2)") (("2" (hide -1) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "x_2") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (rewrite "length_append") (("2" (hide-all-but 1) (("2" (typepred "f(x!2)") (("2" (hide -1) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "x_2") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "f(x!2)") (("3" (hide -1) (("3" (skeep) (("3" (expand "terminating?") (("3" (expand "terminates_expr") (("3" (inst -1 "x_2") (("3" (skeep) (("3" (expand "nonempty?") (("3" (expand "empty?") (("3" (inst -2 "val") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x!2)") (("2" (hide -1) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "x_2") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "list_extensionality" 1) (("1" (rewrite "length_append") (("1" (assert) (("1" (skeep) (("1" (typepred "n") (("1" (rewrite "length_append") (("1" (rewrite "nth_append") (("1" (lift-if) (("1" (prop) (("1" (inst -7 "n") (("1" (assert) nil nil)) nil) ("2" (case "n=length(f(x)`2)") (("1" (replace -1) (("1" (assert) (("1" (expand "nth" 2 1) (("1" (inst -7 "n") (("1" (assert) (("1" (hide-all-but (-1 -7 -8 2)) (("1" (expand "semantic_rel") (("1" (decompose-equality 1) (("1" (inst -2 "x!3" "x!4") (("1" (typepred "choose({r: nat |
                                                                                                                                        semantic_rel_expr(f(x))
                                                                                                                                                         (get_body(f(x)), tuple2nat(x!3, x!4), r)})") (("1" (lemma "deterministic") (("1" (inst?) (("1" (inst -1 "tuple2nat(x!3, x!4)" "f(x)") (("1" (expand "semantic_rel") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(x!3,x!4)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(x!3,x!4)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (typepred "f(x)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(x_2)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x)") (("2" (hide -1) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(x_2)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (skeep) (("2" (inst -1 "tuple2nat(x_2)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x)") (("2" (hide -1) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(x_2)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(x)") (("2" (hide -1) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(x_2)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "f(x)") (("3" (hide -1) (("3" (skeep) (("3" (expand "terminating?") (("3" (expand "terminates_expr") (("3" (inst -1 "tuple2nat(x_2)") (("3" (skeep) (("3" (expand "nonempty?") (("3" (expand "empty?") (("3" (inst -2 "val") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but 1) (("4" (typepred "f(x!2)") (("4" (hide -1) (("4" (expand "terminating?") (("4" (expand "terminates_expr") (("4" (skeep) (("4" (inst -1 "x_2") (("4" (skeep) (("4" (expand "nonempty?") (("4" (expand "empty?") (("4" (inst -2 "val") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -5 "length(p!1`2)") (("1" (assert) (("1" (hide-all-but (-5 1)) (("1" (expand "terminating?") (("1" (expand "terminates_expr") (("1" (skeep) (("1" (inst -1 "nat2tuple(env)`1" "nat2tuple(env)`2") (("1" (assert) (("1" (case "(nat2tuple(env)`1, nat2tuple(env)`2) = nat2tuple(env)") (("1" (replaces -1) (("1" (rewrite "tuple2nat_nat2tuple") (("1" (inst 1 "nth(y`2, length(p!1`2))(nat2tuple(env))") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (inst -3 "length(p`1)") (("1" (assert) (("1" (hide-all-but (-3 1)) (("1" (expand "terminating?") (("1" (expand "terminates_expr") (("1" (skeep) (("1" (inst -1 "env") (("1" (inst 1 "nth(y`1, length(p`1))(env)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (skeep) (("2" (replace -1) (("2" (replace -2) (("2" (replace -3) (("2" (expand "pvs0_level" 1) (("2" (prop) (("1" (inst 1 "f(nat2tuple(nat2tuple(n)`1)`1)") (("1" (prop) (("1" (rewrite "length_append") (("1" (hide-all-but 1) (("1" (typepred "f(nat2tuple(nat2tuple(n)`1)`1)") (("1" (hide -1) (("1" (skeep) (("1" (expand "terminating?") (("1" (expand "terminates_expr") (("1" (inst -1 "x") (("1" (skeep) (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (inst -2 "val") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (prop) (("1" (rewrite "nth_append") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "f(nat2tuple(nat2tuple(n)`1)`1)") (("2" (hide -1) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "x") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i=length(f(nat2tuple(nat2tuple(n)`1)`1)`1)") (("1" (replace -1) (("1" (rewrite "nth_append") (("1" (expand "nth" 2) (("1" (skeep) (("1" (typepred "choose[nat]
                                                                                                         ({r: nat |
                                                                                                             semantic_rel[nat]
                                                                                                                 (f(nat2tuple(nat2tuple(n)`1)`1))(env, r)})") (("1" (propax) nil nil) ("2" (hide-all-but 1) (("2" (typepred "f(nat2tuple(nat2tuple(n)`1)`1)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "env") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (typepred "f(nat2tuple(nat2tuple(n)`1)`1)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "x") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (typepred "f(nat2tuple(nat2tuple(n)`1)`1)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "x") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "f(nat2tuple(nat2tuple(n)`1)`2)") (("2" (prop) (("1" (rewrite "length_append") (("1" (hide-all-but 1) (("1" (skeep) (("1" (typepred "f(nat2tuple(nat2tuple(n)`1)`2)") (("1" (hide -1) (("1" (expand "terminating?") (("1" (expand "terminates_expr") (("1" (inst -1 "tuple2nat(x)") (("1" (skeep) (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (inst -2 "val") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (prop) (("1" (rewrite "nth_append") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (typepred "f(nat2tuple(nat2tuple(n)`1)`2)") (("2" (hide -1) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(x)") (("2" (skeep) (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i=length(f(nat2tuple(nat2tuple(n)`1)`2)`2)") (("1" (skeep) (("1" (replaces -1) (("1" (rewrite "nth_append") (("1" (expand "nth") (("1" (typepred " choose[nat]
                                                                                                       ({r: nat |
                                                                                                           semantic_rel[nat]
                                                                                                               (f(nat2tuple(nat2tuple(n)`1)`2))
                                                                                                               (tuple2nat(env1, env2), r)})") (("1" (propax) nil nil) ("2" (hide-all-but 1) (("2" (typepred "f(nat2tuple(nat2tuple(n)`1)`2)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(env1, env2)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "f(nat2tuple(nat2tuple(n)`1)`2)") (("2" (hide -1) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(x)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (rewrite "length_append") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "f(nat2tuple(nat2tuple(n)`1)`2)") (("2" (hide -1) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (skeep) (("2" (inst -1 "tuple2nat(x)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -2 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (hide-all-but 1) (("3" (typepred "f(p2)") (("3" (hide -1) (("3" (expand "terminating?") (("3" (expand "terminates_expr") (("3" (inst -1 "tuple2nat(x)") (("3" (skeep) (("3" (expand "nonempty?") (("3" (expand "empty?") (("3" (inst -2 "val") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep*) (("4" (hide-all-but 1) (("4" (typepred "f(p1)") (("4" (hide -1) (("4" (expand "terminating?") (("4" (expand "terminates_expr") (("4" (inst -1 "x") (("4" (skeep) (("4" (expand "nonempty?") (("4" (expand "empty?") (("4" (inst -2 "val") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (beta) (("2" (skeep) (("2" (case "injective?(inverse(f))") (("1" (case "EXISTS (f:
                                                                                           [
                                                                                              (LAMBDA (pvs0: PVS0):
                                                                                                 pvs0_level(x!1 - 1)(pvs0) AND terminating?(pvs0))->nat]):
                                                                                   injective?(f)") (("1" (skeep) (("1" (inst 1 "inverse(f!1)") (("1" (rewrite "surj_inv") (("1" (expand "surjective?" 2) (("1" (skeep) (("1" (inst 1 "y") nil nil)) nil)) nil)) nil) ("2" (case "forall(n : nat): exists(x : (LAMBDA (pvs0: PVS0[nat]):
                                                                                                                  pvs0_level(n)(pvs0) AND terminating?[nat](pvs0))): true") (("1" (inst -1 "x!1-1") nil nil) ("2" (hide-all-but 1) (("2" (measure-induct+ "n" "n") (("2" (case "x!2=0") (("1" (hide -2) (("1" (inst 1 "(lop1,lop2,false_val,vr)") (("1" (expand "pvs0_level") (("1" (assert) (("1" (grind) (("1" (expand "semantic_rel_expr" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "x!2-1") (("1" (assert) (("1" (skeep) (("1" (typepred "x") (("1" (inst 2 "(append (x`1, (:lambda(n: nat): choose({r: nat | semantic_rel(x)(n,r)}):)),append (x`2, (:lambda(n: [nat,nat]): choose({r: nat | semantic_rel(x)(tuple2nat(n),r)}):)),false_val,vr)") (("1" (prop) (("1" (expand "pvs0_level" 1) (("1" (prop) (("1" (inst 1 "x") (("1" (assert) (("1" (prop) (("1" (rewrite "length_append") (("1" (hide-all-but (-2 1)) (("1" (skeep) (("1" (expand "terminating?") (("1" (expand "terminates_expr") (("1" (inst -1 "n") (("1" (skeep) (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (inst -1 "val") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "i") (("2" (rewrite "length_append") (("1" (prop) (("1" (rewrite "nth_append") (("1" (assert) nil nil) ("2" (hide-all-but (-4 1)) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "n") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (rewrite "nth_append") (("1" (case "i = length(x`1)") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (typepred "choose[nat]({r: nat | semantic_rel[nat](x)(env, r)})") (("1" (propax) nil nil) ("2" (hide-all-but (-3 1)) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "env") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "n") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "n") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "x") (("2" (prop) (("1" (rewrite "length_append") (("1" (hide-all-but (-2 1)) (("1" (skeep) (("1" (expand "terminating?") (("1" (expand "terminates_expr") (("1" (expand "nonempty?") (("1" (expand "empty?") (("1" (inst -2 "tuple2nat(n)") (("1" (skeep) (("1" (inst -1 "val") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "i") (("2" (rewrite "length_append") (("1" (prop) (("1" (rewrite "nth_append") (("1" (assert) nil nil) ("2" (hide-all-but (-4 1)) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(n)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (rewrite "nth_append") (("1" (case "i = length(x`2)") (("1" (replaces -1) (("1" (assert) (("1" (expand "nth") (("1" (typepred "choose[nat]({r: nat | semantic_rel[nat](x)(tuple2nat(env1,env2), r)})") (("1" (propax) nil nil) ("2" (hide-all-but (-3 1)) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(env1,env2)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(n)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(n)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) (("2" (expand "semantic_rel_expr") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (skeep) (("2" (expand "terminating?") (("2" (expand "terminates_expr") (("2" (inst -1 "tuple2nat(n)") (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst -1 "val") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (skeep) (("3" (expand "terminating?") (("3" (expand "terminates_expr") (("3" (inst -1 "n") (("3" (skeep) (("3" (expand "nonempty?") (("3" (expand "empty?") (("3" (inst -1 "val") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (inst 1 "inverse(f)") (("2" (expand "injective?") (("2" (skeep) (("2" (inst -2 "x1" "x2") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "inj_inv") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((well_founded? const-decl "bool" orders nil) (list type-decl nil list_adt nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PVS0 type-eq-decl nil pvs0_expr nil) (terminating? const-decl "bool" pvs0_lang nil) (tuple2nat const-decl "nat" tuple2nat numbers) (semantic_rel const-decl "bool" pvs0_lang nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (tuple2nat_nat2tuple formula-decl nil tuple2nat numbers) (length_singleton formula-decl nil more_list_props structures) (nth_append formula-decl nil more_list_props structures) (deterministic formula-decl nil pvs0_lang nil) (terminates_expr const-decl "bool" pvs0_expr nil) (list_extensionality formula-decl nil more_list_props structures) (semantic_rel_expr inductive-decl "bool" pvs0_expr nil) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (vr adt-constructor-decl "(vr?)" PVS0Expr_adt nil) (vr? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil) (nat2PVS0 def-decl "PVS0Expr" pvs0_to_nat nil) (nat2PVS0_inverse formula-decl nil pvs0_to_nat nil) (PVS02nat def-decl "nat" pvs0_to_nat nil)) nil)) (level_surjection_TCC1 0 (level_surjection_TCC1-1 nil 3717850024 ("" (skeep) (("" (lemma "level_surjective") (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil) ((level_surjective formula-decl nil pvs0_computable nil) (surjective? const-decl "bool" functions nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PVS0 type-eq-decl nil pvs0_expr nil) (pvs0_level inductive-decl "bool" pvs0_computable nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (level_surjection subtype "{f: [naturalnumbers.nat -> (pvs0_computable.pvs0_level(pvs0_computable.n))] | functions[nat, (pvs0_computable.pvs0_level(pvs0_computable.n))].surjective?(f)}" "(sets[[nat -> (pvs0_computable.pvs0_level(pvs0_computable.n))]].nonempty?)"))) (representantion 0 (representantion-1 nil 3715513884 ("" (expand "surjective?") (("" (inst 1 "lambda(k: nat): level_surjection(nat2tuple(k)`1)(nat2tuple(k)`2)") (("1" (skeep) (("1" (typepred "y") (("1" (skeep) (("1" (typepred "choose({f: [nat -> (pvs0_level(n))] | surjective?(f)})") (("1" (expand "surjective?" -1 1) (("1" (inst -1 "y") (("1" (skeep) (("1" (inst 1 "tuple2nat(n,x)") (("1" (rewrite "nat2tuple_tuple2nat") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "level_surjective") (("2" (inst?) (("2" (skeep) (("2" (expand "nonempty?") (("2" (expand "empty?") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst 1 "nat2tuple(k)`1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((nat2tuple def-decl "[nat, nat]" tuple2nat numbers) (level_surjection const-decl "[nat -> (pvs0_level(n))]" pvs0_computable nil) (pvs0_level inductive-decl "bool" pvs0_computable nil) (PVS0 type-eq-decl nil pvs0_expr nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (PVS0_partial_recursive type-eq-decl nil pvs0_computable nil) (NOT const-decl "[bool -> bool]" booleans nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (n skolem-const-decl "nat" pvs0_computable nil) (y skolem-const-decl "PVS0_partial_recursive" pvs0_computable nil) (tuple2nat const-decl "nat" tuple2nat numbers) (nat2tuple_tuple2nat formula-decl nil tuple2nat numbers) (level_surjective formula-decl nil pvs0_computable nil) (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (surjective? const-decl "bool" functions nil)) shostak)) (pvs0_level_computable_TCC1 0 (pvs0_level_computable_TCC1-1 nil 3718657985 ("" (skeep*) (("" (typepred "p") (("" (expand "pvs0_level_computable") (("" (flatten) nil nil)) nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pvs0_level_computable inductive-decl "bool" pvs0_computable nil) (PVS0 type-eq-decl nil pvs0_expr nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (pvs0_level_computable subtype "pvs0_computable.p" "(pvs0_lang[nat].terminating?)"))) (pvs0_level_computable_TCC2 0 (pvs0_level_computable_TCC2-2 "" 3804626752 ("" (skeep) (("" (skeep :preds? t) (("" (expand "pvs0_level_computable") (("" (flatten) nil nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (pvs0_level_computable inductive-decl "bool" pvs0_computable nil)) shostak (pvs0_level_computable subtype "pvs0_computable.p" "(pvs0_lang[nat].terminating?)")) (pvs0_level_computable_TCC2-1 nil 3718657985 ("" (skeep*) (("" (typepred "p1") (("" (expand "pvs0_level_computable") (("" (flatten) nil nil)) nil)) nil)) nil) ((pvs0_level_computable inductive-decl "bool" pvs0_computable nil)) nil (pvs0_level_computable subtype "pvs0_computable.p" "(pvs0_lang[nat].terminating?)"))) (pvs0_level_computable_terminating 0 (pvs0_level_computable_terminating-1 nil 3718659451 ("" (skeep :preds? t) (("" (expand "pvs0_level_computable") (("" (flatten) nil nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (pvs0_level_computable inductive-decl "bool" pvs0_computable nil)) nil (pvs0_level_computable_terminating subtype "pvs0_computable.x" "(pvs0_lang[nat].terminating?)"))) (pvs0_level_computable_n 0 (pvs0_level_computable_n-1 nil 3718659636 ("" (induct "n") (("1" (skeep :preds? t) (("1" (expand "pvs0_level_computable") (("1" (expand "pvs0_level") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep :preds? t) (("2" (expand "pvs0_level" 1) (("2" (expand "pvs0_level_computable" -1) (("2" (flatten) (("2" (assert) (("2" (split) (("1" (hide -4) (("1" (skeep -3 :preds? t) (("1" (inst -6 "p") (("1" (inst 1 "p") (("1" (assert) (("1" (skeep) (("1" (insteep) (("1" (ground) (("1" (skeep) (("1" (insteep) (("1" (lemma "pvs0_eval_correct") (("1" (inst? -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (skeep) (("2" (inst -5 "p") (("2" (insteep) (("2" (assert) (("2" (skeep) (("2" (insteep) (("2" (ground) (("2" (skeep) (("2" (insteep) (("2" (lemma "pvs0_eval_correct") (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (j skolem-const-decl "nat" pvs0_computable nil) (p skolem-const-decl "(pvs0_level_computable(1 + j - 1))" pvs0_computable nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (terminating? const-decl "bool" pvs0_lang nil) (pvs0_eval_correct formula-decl nil pvs0_eval nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (p skolem-const-decl "(pvs0_level_computable(1 + j - 1))" pvs0_computable nil) (tuple2nat const-decl "nat" tuple2nat numbers) (nat_induction formula-decl nil naturalnumbers nil) (pvs0_level inductive-decl "bool" pvs0_computable nil) (pvs0_level_computable inductive-decl "bool" pvs0_computable nil) (PVS0 type-eq-decl nil pvs0_expr nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (pvs0_level_computable_n subtype "pvs0_computable.x" "(pvs0_computable.pvs0_level(pvs0_computable.n))"))) (PVS0_computable_is_terminating 0 (PVS0_computable_is_terminating-1 nil 3718660496 ("" (skeep :preds? t) (("" (skeep) (("" (lemma "pvs0_level_computable_terminating") (("" (insteep) nil nil)) nil)) nil)) nil) ((n skolem-const-decl "nat" pvs0_computable nil) (x skolem-const-decl "PVS0_computable" pvs0_computable nil) (PVS0_computable type-eq-decl nil pvs0_computable nil) (pvs0_level_computable inductive-decl "bool" pvs0_computable nil) (PVS0 type-eq-decl nil pvs0_expr nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (pvs0_level_computable_terminating judgement-tcc nil pvs0_computable nil)) nil (PVS0_computable_is_terminating subtype "pvs0_computable.x" "(pvs0_lang[nat].terminating?)"))) (PVS0_computable_is_partial_recursive 0 (PVS0_computable_is_partial_recursive-1 nil 3718660998 ("" (skeep :preds? t) (("" (skeep) (("" (insteep) (("" (lemma "pvs0_level_computable_n") (("" (insteep) nil nil)) nil)) nil)) nil)) nil) ((pvs0_level_computable_n judgement-tcc nil pvs0_computable nil) (list type-decl nil list_adt nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" PVS0Expr_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PVS0 type-eq-decl nil pvs0_expr nil) (pvs0_level_computable inductive-decl "bool" pvs0_computable nil) (PVS0_computable type-eq-decl nil pvs0_computable nil) (x skolem-const-decl "PVS0_computable" pvs0_computable nil) (n skolem-const-decl "nat" pvs0_computable nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (PVS0_computable_is_partial_recursive subtype "pvs0_computable.x" "PVS0_partial_recursive"))) (pvs0_level1_is_2 0 (pvs0_level1_is_2-1 nil 3719069925 ("" (measure-induct+ "n" "n") (("" (skeep) (("" (typepred "pvs0") (("" (expand "pvs0_level" -1) (("" (prop) (("1" (inst 1 "0") (("1" (expand "pvs0_level2" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep*) (("2" (inst -6 "x!1-1") (("1" (assert) (("1" (inst-cp -6 "p") (("1" (inst -6 "p!1") (("1" (skeep*) (("1" (inst 2 "m+m!1+1") (("1" (expand "pvs0_level2" 2) (("1" (prop) (("1" (inst 1 "m!1" "p") (("1" (assert) nil nil)) nil) ("2" (inst 1 "m" "p!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (TRUE const-decl "bool" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (p skolem-const-decl "(pvs0_level(x!1 - 1))" pvs0_computable nil) (m!1 skolem-const-decl "nat" pvs0_computable nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (p!1 skolem-const-decl "(pvs0_level(x!1 - 1))" pvs0_computable nil) (m skolem-const-decl "nat" pvs0_computable nil) (x!1 skolem-const-decl "nat" pvs0_computable nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pvs0_level2 inductive-decl "bool" pvs0_computable nil) (pvs0_level inductive-decl "bool" pvs0_computable nil) (PVS0 type-eq-decl nil pvs0_expr nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" PVS0Expr_adt nil) (PRED type-eq-decl nil defined_types nil) (PVS0Expr type-decl nil PVS0Expr_adt nil) (EvalOp2 type-eq-decl nil pvs0_expr nil) (EvalOp1 type-eq-decl nil pvs0_expr nil) (list type-decl nil list_adt nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)))
