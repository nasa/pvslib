(polar (argrng_TCC1 0 (argrng_TCC1-1 nil 3297457117 ("" (assert) (("" (typepred "pi") (("" (assert) nil nil)) nil)) nil) ((pi_ub_new const-decl "posreal" pi_def trig_fnd) (pi_lb_new const-decl "posreal" pi_def trig_fnd) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (cos const-decl "real" sincos_def trig_fnd) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd)) shostak (argrng subtype "0" "argrng"))) (abs_TCC1 0 (abs_TCC1-2 "" 3790100306 ("" (skosimp) (("" (lemma "complex_is_Re_Im" ("z" "z!1")) (("" (expand "conjugate") (("" (name-replace "R" "Re(z!1)") (("" (name-replace "II" "Im(z!1)") (("" (replace -1) (("" (hide -1) (("" (assert) (("" (rewrite "sq.sq_rew") (("" (rewrite "sq.sq_rew") (("" (lemma "i_axiom") (("" (rewrite "associative_mult" :dir rl) (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (complex_is_Re_Im formula-decl nil arithmetic nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (real_times_real_is_real application-judgement "real" reals nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (sq const-decl "nonneg_real" sq reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (associative_mult formula-decl nil number_fields nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (nil application-judgement "above(n)" exp2 nil) (i_axiom formula-decl nil complex_types nil) (sq_rew formula-decl nil sq reals) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (Re_is_real application-judgement "real" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Im_is_real application-judgement "real" complex_types nil)) shostak (abs subtype "number_fields.*(polar.z, arithmetic.conjugate(polar.z))" "nonneg_real")) (abs_TCC1-1 nil 3294310508 ("" (skosimp) (("" (lemma "complex_is_Re_Im" ("z" "z!1")) (("" (expand "conjugate") (("" (name-replace "R" "Re(z!1)") (("" (name-replace "II" "Im(z!1)") (("" (replace -1) (("" (hide -1) (("" (assert) (("" (rewrite "sq.sq_rew") (("" (rewrite "sq.sq_rew") (("" (lemma "i_axiom") (("" (rewrite "associative_mult" :dir rl) (("" (expand "sq" -1) (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex_is_Re_Im formula-decl nil arithmetic nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (sq const-decl "nonneg_real" sq reals) (i_axiom formula-decl nil complex_types nil) (sq_rew formula-decl nil sq reals) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (Re_is_real application-judgement "real" complex_types nil) (Im_is_real application-judgement "real" complex_types nil)) shostak (abs subtype "number_fields.*(polar.z, arithmetic.conjugate(polar.z))" "nonneg_real"))) (abs_def 0 (abs_def-1 nil 3385303712 ("" (skosimp) (("" (expand "abs") (("" (lemma "complex_is_Re_Im" ("z" "z!1")) (("" (name-replace "DRL100" "conjugate(z!1)") (("" (name-replace "DRL101" "sqrt(sq.sq(Im(z!1)) + sq.sq(Re(z!1)))") (("" (replace -1) (("" (hide -1) (("" (expand "DRL100") (("" (expand "conjugate") (("" (rewrite "associative_mult" 1 :dir rl) (("" (rewrite "associative_mult" 1 :dir rl) (("" (rewrite "associative_mult" 1 :dir rl) (("" (rewrite "i_axiom") (("" (expand "DRL101") (("" (expand "sq") (("" (rewrite "associative_mult") (("" (rewrite "minus_add") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((abs const-decl "nnreal" polar nil) (conjugate const-decl "complex" arithmetic nil) (= const-decl "[T, T -> boolean]" equalities nil) (DRL100 skolem-const-decl "complex" polar nil) (associative_mult formula-decl nil number_fields nil) (DRL101 skolem-const-decl "{nnz: nnreal | nnz * nnz = sq.sq(Im(z!1)) + sq.sq(Re(z!1))}" polar nil) (nil application-judgement "above(n)" exp2 nil) (i_axiom formula-decl nil complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (sq const-decl "nonneg_real" sq reals) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (complex_is_Re_Im formula-decl nil arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (abs_real_rew 0 (abs_real_rew-1 nil 3385304274 ("" (skosimp) (("" (rewrite "abs_def") (("" (rewrite "Im_real") (("" (rewrite "Re_real") (("" (expand "sq" 1 1) (("" (rewrite "sqrt_sq_abs") nil nil)) nil)) nil)) nil)) nil)) nil) ((complex_times_complex_is_complex application-judgement "complex" complex_types nil) (abs_def formula-decl nil polar nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (Re_real formula-decl nil arithmetic nil) (sqrt_sq_abs formula-decl nil sqrt reals) (sq const-decl "nonneg_real" sq reals) (Im_real formula-decl nil arithmetic nil)) shostak)) (abs_imag_rew 0 (abs_imag_rew-1 nil 3596359128 ("" (skeep) (("" (rewrite "abs_def") (("" (rewrite "Re_imag") (("" (rewrite "Im_imag") (("" (case "sq.sq(0) = 0") (("1" (replaces -1) (("1" (assert) (("1" (lemma "sqrt_sq") (("1" (inst - "real_defs.abs(r)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex_times_complex_is_complex application-judgement "complex" complex_types nil) (abs_def formula-decl nil polar nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (i const-decl "complex" complex_types nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (Im_imag formula-decl nil arithmetic nil) (TRUE const-decl "bool" booleans nil) (sqrt_sq formula-decl nil sqrt reals) (sq_abs formula-decl nil sq reals) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sq const-decl "nonneg_real" sq reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Re_imag formula-decl nil arithmetic nil)) shostak)) (abs_nzcomplex 0 (abs_nzcomplex-1 nil 3294771107 ("" (skosimp) (("" (expand "abs") (("" (lemma "nz_sq_abs_pos" ("n0z" "n0z!1")) (("" (lemma "sqrt_pos" ("px" "n0z!1 * conjugate(n0z!1)")) (("1" (propax) nil nil) ("2" (expand "conjugate") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((abs const-decl "nnreal" polar nil) (conjugate const-decl "complex" arithmetic nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (sqrt_pos judgement-tcc nil sqrt reals) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (Re_is_real application-judgement "real" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Im_is_real application-judgement "real" complex_types nil) (nz_sq_abs_pos formula-decl nil arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil)) shostak)) (abs_nz_iff_nz 0 (abs_nz_iff_nz-1 nil 3294771228 ("" (skosimp) (("" (prop) (("1" (replace -2) (("1" (grind) nil nil)) nil) ("2" (lemma "abs_nzcomplex" ("n0z" "z!1")) (("1" (propax) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((conjugate const-decl "complex" arithmetic nil) (sqrt_0 formula-decl nil sqrt reals) (abs const-decl "nnreal" polar nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs_nzcomplex formula-decl nil polar nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil)) shostak)) (abs_is_0 0 (abs_is_0-1 nil 3295007153 ("" (skosimp) (("" (prop) (("1" (typepred "abs(z!1)") (("1" (expand ">=") (("1" (expand "<=") (("1" (split) (("1" (lemma "abs_nz_iff_nz" ("z" "z!1")) (("1" (assert) nil nil)) nil) ("2" (hide -1) (("2" (expand "abs") (("2" (rewrite "sq_abs_def") (("2" (rewrite "sq.sq_rew") (("2" (rewrite "sq.sq_rew") (("2" (rewrite "complex_is_0_Re_Im" 1) (("2" (typepred "sq.sq(Im(z!1))") (("2" (typepred "sq.sq(Re(z!1))") (("2" (lemma "sqrt_eq" ("nny" "sq.sq(Im(z!1)) + sq.sq(Re(z!1))" "nnz" "0")) (("2" (rewrite "sqrt_0") (("2" (replace -1 -4) (("2" (hide -1) (("2" (lemma "sq.sq_nz_pos") (("2" (case-replace "Re(z!1) = 0") (("1" (inst - "Im(z!1)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (inst - "Re(z!1)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (expand "abs") (("2" (rewrite "zero_times1") (("2" (rewrite "sqrt_0") nil nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs_nz_iff_nz formula-decl nil polar nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (sq_rew formula-decl nil sq reals) (complex_is_0_Re_Im formula-decl nil arithmetic nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sqrt_0 formula-decl nil sqrt reals) (sq_0 formula-decl nil sq reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal nonempty-type-eq-decl nil reals nil) (z!1 skolem-const-decl "complex" polar nil) (/= const-decl "boolean" notequal nil) (sq_nz_pos judgement-tcc nil sq reals) (sqrt_eq formula-decl nil sqrt reals) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sq const-decl "nonneg_real" sq reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (sq_abs_def formula-decl nil arithmetic nil) (<= const-decl "bool" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (nnreal type-eq-decl nil real_types nil) (abs const-decl "nnreal" polar nil) (conjugate const-decl "complex" arithmetic nil) (zero_times1 formula-decl nil number_fields_bis nil)) shostak)) (abs_neg 0 (abs_neg-1 nil 3294998991 ("" (skosimp) (("" (expand "abs") (("" (rewrite "conjugate_neg") (("" (rewrite "neg_times_neg") nil nil)) nil)) nil)) nil) ((minus_complex_is_complex application-judgement "complex" complex_types nil) (abs const-decl "nnreal" polar nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (neg_times_neg formula-decl nil number_fields_bis nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (conjugate_neg formula-decl nil arithmetic nil)) shostak)) (abs_mult 0 (abs_mult-2 "" 3790100308 ("" (expand "abs") (("" (skolem 1 ("a" "b")) (("" (lemma "sq_abs_nonneg" ("z" "a")) (("" (lemma "sq_abs_nonneg" ("z" "b")) (("" (lemma "sq_abs_nonneg" ("z" "a*b")) (("" (rewrite "sqrt_times" :dir rl) (("" (assert) (("" (rewrite "conjugate_times") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sq_abs_realpred formula-decl nil arithmetic nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sqrt_times formula-decl nil sqrt reals) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (conjugate const-decl "complex" arithmetic nil) (conjugate_times formula-decl nil arithmetic nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sq_abs_nonneg formula-decl nil arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (abs const-decl "nnreal" polar nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak) (abs_mult-1 nil 3294697248 ("" (expand "abs") (("" (skolem 1 ("a" "b")) (("" (lemma "sq_abs_nonneg" ("z" "a")) (("" (lemma "sq_abs_nonneg" ("z" "b")) (("" (lemma "sq_abs_nonneg" ("z" "a*b")) (("" (rewrite "sqrt_times" :dir rl) (("1" (assert) (("1" (rewrite "conjugate_times") nil nil)) nil) ("2" (assert) (("2" (expand "conjugate") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "conjugate") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sq_abs_realpred formula-decl nil arithmetic nil) (sqrt_times formula-decl nil sqrt reals) (conjugate const-decl "complex" arithmetic nil) (conjugate_times formula-decl nil arithmetic nil) (sq_abs_nonneg formula-decl nil arithmetic nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (abs_inv_TCC1 0 (abs_inv_TCC1-1 nil 3294998917 ("" (skosimp) (("" (rewrite "abs_is_0") nil nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (abs_is_0 formula-decl nil polar nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil)) shostak (abs_inv subtype "polar.abs(polar.n0z)" "nznum"))) (abs_inv 0 (abs_inv-2 "" 3790100308 ("" (skosimp) (("" (expand "abs") (("" (rewrite "conjugate_inv") (("" (lemma "conjugate_nz" ("n0z" "n0z!1")) (("" (rewrite "div_times") (("" (lemma "nz_sq_abs_pos" ("n0z" "n0z!1")) (("" (rewrite "sqrt_div") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (abs const-decl "nnreal" polar nil) (conjugate_nz formula-decl nil arithmetic nil) (nz_sq_abs_pos formula-decl nil arithmetic nil) (sqrt_div formula-decl nil sqrt reals) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (sqrt_pos application-judgement "posreal" sqrt reals) (sqrt_1 formula-decl nil sqrt reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sq_abs_realpred formula-decl nil arithmetic nil) (odd_times_odd_is_odd application-judgement "odd_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (div_times formula-decl nil number_fields_bis nil) (nznum nonempty-type-eq-decl nil number_fields nil) (conjugate const-decl "complex" arithmetic nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (conjugate_inv formula-decl nil arithmetic nil)) shostak) (abs_inv-1 nil 3294999199 ("" (skosimp) (("" (expand "abs") (("" (rewrite "conjugate_inv") (("" (lemma "conjugate_nz" ("n0z" "n0z!1")) (("" (rewrite "div_times") (("" (lemma "nz_sq_abs_pos" ("n0z" "n0z!1")) (("" (rewrite "sqrt_div") (("" (expand "conjugate") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (conjugate_nz formula-decl nil arithmetic nil) (nz_sq_abs_pos formula-decl nil arithmetic nil) (sqrt_div formula-decl nil sqrt reals) (sqrt_pos application-judgement "posreal" sqrt reals) (sqrt_1 formula-decl nil sqrt reals) (sq_abs_realpred formula-decl nil arithmetic nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (div_times formula-decl nil number_fields_bis nil) (conjugate const-decl "complex" arithmetic nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (conjugate_inv formula-decl nil arithmetic nil)) shostak)) (abs_div 0 (abs_div-2 "" 3790100308 ("" (skosimp) (("" (lemma "div_def" ("y" "z!1" "n0x" "n0z!1")) (("" (lemma "abs_mult" ("z1" "z!1" "z2" "1/n0z!1")) (("" (rewrite "abs_inv" -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((numfield nonempty-type-eq-decl nil number_fields nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (div_def formula-decl nil number_fields nil) (abs_inv formula-decl nil polar nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (real_times_real_is_real application-judgement "real" reals nil) (complex_div_nzcomplex_is_complex application-judgement "complex" complex_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (abs_mult formula-decl nil polar nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)) shostak) (abs_div-1 nil 3294999065 ("" (skosimp) (("" (lemma "div_def" ("y" "z!1" "n0x" "n0z!1")) (("" (lemma "abs_mult" ("z1" "z!1" "z2" "1/n0z!1")) (("1" (rewrite "abs_inv" -1) (("1" (assert) nil nil)) nil) ("2" (lemma "real_is_complex" ("x" "1")) (("2" (rewrite "closed_divides") nil nil)) nil)) nil)) nil)) nil) ((nzcomplex nonempty-type-eq-decl nil complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (complex_div_nzcomplex_is_complex application-judgement "complex" complex_types nil) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil)) shostak)) (abs_triangle 0 (abs_triangle-2 nil 3307889278 ("" (skolem 1 ("a" "b")) (("" (expand "abs") (("" (lemma "sq_abs_nonneg" ("z" "a")) (("" (lemma "sq_abs_nonneg" ("z" "b")) (("" (lemma "sq_abs_nonneg" ("z" "a+b")) (("" (case "real_pred(a * conjugate(a))") (("1" (case "real_pred(b * conjugate(b))") (("1" (case "real_pred((a+b) * conjugate(a+b))") (("1" (name "A2" "a * conjugate(a)") (("1" (replace -1) (("1" (name "B2" "b * conjugate(b)") (("1" (replace -1) (("1" (name "AB2" "(a+b) * conjugate(a+b)") (("1" (replace -1) (("1" (case-replace "conjugate(a + b) * a + conjugate(a + b) * b = AB2") (("1" (rewrite "sq_le" 1 :dir rl) (("1" (rewrite "sqrt.sq_sqrt") (("1" (rewrite "sq.sq_plus") (("1" (rewrite "sqrt.sq_sqrt") (("1" (rewrite "sqrt.sq_sqrt") (("1" (rewrite "sqrt.sqrt_times" 1 :dir rl) (("1" (rewrite "conjugate_plus") (("1" (rewrite "distributive" -2) (("1" (lemma "commutative_mult") (("1" (inst-cp - "a" "conjugate(a)") (("1" (inst-cp - "b" "conjugate(b)") (("1" (replace -2 * rl) (("1" (replace -3 * rl) (("1" (replace -6) (("1" (replace -7) (("1" (hide -4) (("1" (name "DRL" "conjugate(a) * b + conjugate(b) * a") (("1" (case-replace "A2 + conjugate(a) * b + conjugate(b) * a + B2 = A2+B2+DRL") (("1" (case "real_pred(DRL)") (("1" (hide -2) (("1" (replace -6 1 rl) (("1" (assert) (("1" (case "A2*B2>=0") (("1" (lemma "both_sides_plus_le2" ("z" "A2+B2" "x" "DRL" "y" "2*sqrt(A2 * B2)")) (("1" (case "DRL<=2 * sqrt(A2 * B2)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (name-replace "CA" "conjugate(a)") (("2" (name-replace "CB" "conjugate(b)") (("2" (lemma "complex_is_Re_Im" ("z" "a")) (("2" (lemma "complex_is_Re_Im" ("z" "b")) (("2" (replace -1 -5) (("2" (replace -2 -5) (("2" (expand "CA") (("2" (expand "CB") (("2" (expand "conjugate") (("2" (case-replace "DRL = 2*(Re(a)*Re(b)+Im(a)*Im(b))") (("1" (lemma "both_sides_times_pos_le1" ("pz" "2" "x" "Re(a) * Re(b) + Im(a) * Im(b)" "y" "sqrt(A2 * B2)")) (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "reals.closed_divides" ("x" "2 * (Re(a) * Re(b) + Im(a) * Im(b))" "n0z" "2")) (("1" (rewrite "times_div1" -1 :dir rl) (("1" (rewrite "div_cancel1" 1) (("1" (case "Im(a) * Im(b) + Re(a) * Re(b) < 0") (("1" (assert) nil nil) ("2" (rewrite "sq_le" 2 :dir rl) (("2" (rewrite "sq_sqrt") (("2" (expand "B2" 2) (("2" (rewrite "sq_abs_def" 2) (("2" (name-replace "DRL_B" "(Im(b) * Im(b) + Re(b) * Re(b))") (("2" (expand "A2") (("2" (lemma "sq_abs_def" ("z" "a")) (("2" (inst-cp -9 "conjugate(a)" "DRL_B") (("2" (replace -10 2) (("2" (rewrite "associative_mult" 2 :dir rl) (("2" (inst-cp -9 "conjugate(a)" "a") (("2" (replace -10 2) (("2" (replace -1 2) (("2" (expand "DRL_B") (("2" (expand "sq") (("2" (assert) (("2" (name "IA" "Im(a)") (("2" (replace -1) (("2" (name "IB" "Im(b)") (("2" (replace -1) (("2" (name "RB" "Re(b)") (("2" (replace -1) (("2" (name "RA" "Re(a)") (("2" (replace -1) (("2" (name-replace "DRL10" "IA * IA * IB * IB ") (("2" (name-replace "DRL11" "RA * RA * RB * RB ") (("2" (assert) (("2" (lemma "both_sides_plus_le2" ("z" "DRL10 + DRL11" "x" "2 * (IA * IB * RA * RB)" "y" "IA * IA * RB * RB + IB * IB * RA * RA")) (("2" (replace -1 2) (("2" (hide-all-but (1 2)) (("2" (case "IA*IB >= -(RA*RB)") (("1" (hide 1) (("1" (lemma "trichotomy" ("x" "IA*RB-RA*IB")) (("1" (split) (("1" (lemma "sq_lt" ("nna" "0" "nnb" "IA * RB - RA * IB")) (("1" (assert) (("1" (expand "sq") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "sq_eq" ("nna" "IA * RB - RA * IB" "nnb" "0")) (("1" (assert) (("1" (expand "sq") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (lemma "sq_lt" ("nna" "0" "nnb" "-(IA * RB - RA * IB)")) (("1" (assert) (("1" (rewrite "sq.sq_neg") (("1" (expand "sq") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 1 rl) (("2" (hide-all-but 1) (("2" (rewrite "associative_mult" :dir rl) (("2" (rewrite "associative_mult" :dir rl) (("2" (rewrite "associative_mult" :dir rl) (("2" (lemma "i_axiom") (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "reals.closed_plus" ("x" "A2" "y" "B2")) (("2" (propax) nil nil)) nil)) nil) ("3" (lemma "reals.closed_times" ("x" "A2" "y" "B2")) (("3" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 -13 -14 -10 -11)) (("2" (expand ">=") (("2" (expand "<=" -3) (("2" (split) (("1" (lemma "both_sides_times_pos_le1" ("pz" "B2" "x" "0" "y" "A2")) (("1" (assert) (("1" (rewrite "zero_times1") nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (replace -1 * rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "reals.closed_times" ("x" "A2" "y" "B2")) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "DRL") (("2" (case-replace "conjugate(a) * b + conjugate(b) * a = AB2 - A2 - B2") (("1" (assert) (("1" (hide-all-but (-8 -9 -10 1)) (("1" (lemma "reals.closed_minus") (("1" (inst?) (("1" (lemma "reals.closed_minus") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-6 1)) (("2" (lemma "both_sides_minus1") (("2" (inst - "A2 + conjugate(a) * b + conjugate(b) * a + B2" "AB2" "A2+B2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "DRL") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "AB2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name-replace "APB" "a + b") (("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex_times_complex_is_complex application-judgement "complex" complex_types nil) (abs const-decl "nnreal" polar nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (conjugate const-decl "complex" arithmetic nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sq_le formula-decl nil sq reals) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (nnreal type-eq-decl nil real_types nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sq_plus formula-decl nil sq reals) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (conjugate_plus formula-decl nil arithmetic nil) (commutative_mult formula-decl nil number_fields nil) (closed_times formula-decl nil reals nil) (closed_plus formula-decl nil reals nil) (<= const-decl "bool" reals nil) (complex_is_Re_Im formula-decl nil arithmetic nil) (CA skolem-const-decl "complex" polar nil) (real_times_real_is_real application-judgement "real" reals nil) (i_axiom formula-decl nil complex_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (nznum nonempty-type-eq-decl nil number_fields nil) (times_div1 formula-decl nil number_fields_bis nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (< const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sq_abs_def formula-decl nil arithmetic nil) (A2 skolem-const-decl "complex" polar nil) (associative_mult formula-decl nil number_fields nil) (DRL_B skolem-const-decl "real" polar nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sq_0 formula-decl nil sq reals) (sq_lt formula-decl nil sq reals) (sq_eq formula-decl nil sq reals) (sq_neg formula-decl nil sq reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (trichotomy formula-decl nil real_axioms nil) (real_minus_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_real_is_real application-judgement "real" reals nil) (nil application-judgement "above(n)" exp2 nil) (sq const-decl "nonneg_real" sq reals) (B2 skolem-const-decl "complex" polar nil) (div_cancel1 formula-decl nil number_fields_bis nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (closed_divides formula-decl nil reals nil) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (CB skolem-const-decl "complex" polar nil) (Re_is_real application-judgement "real" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (both_sides_plus_le2 formula-decl nil real_props nil) (zero_times1 formula-decl nil number_fields_bis nil) (AB2 skolem-const-decl "complex" polar nil) (closed_minus formula-decl nil reals nil) (both_sides_minus1 formula-decl nil number_fields_bis nil) (DRL skolem-const-decl "complex" polar nil) (distributive formula-decl nil number_fields nil) (sqrt_times formula-decl nil sqrt reals) (sq_sqrt formula-decl nil sqrt reals) (= const-decl "[T, T -> boolean]" equalities nil) (sq_abs_realpred formula-decl nil arithmetic nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (sq_abs_nonneg formula-decl nil arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil)) nil) (abs_triangle-1 nil 3294999713 ("" (skolem 1 ("a" "b")) (("" (expand "abs") (("" (lemma "sq_abs_nonneg" ("z" "a")) (("" (lemma "sq_abs_nonneg" ("z" "b")) (("" (lemma "sq_abs_nonneg" ("z" "a+b")) (("" (case "real_pred(a * conjugate(a))") (("1" (case "real_pred(b * conjugate(b))") (("1" (case "real_pred((a+b) * conjugate(a+b))") (("1" (name "A2" "a * conjugate(a)") (("1" (replace -1) (("1" (name "B2" "b * conjugate(b)") (("1" (replace -1) (("1" (name "AB2" "(a+b) * conjugate(a+b)") (("1" (replace -1) (("1" (case-replace "conjugate(a + b) * a + conjugate(a + b) * b = AB2") (("1" (rewrite "sq_le" 1 :dir rl) (("1" (rewrite "sq_sqrt") (("1" (rewrite "sq.sq_plus") (("1" (rewrite "sq_sqrt") (("1" (rewrite "sq_sqrt") (("1" (rewrite "sqrt_times" 1 :dir rl) (("1" (rewrite "conjugate_plus") (("1" (rewrite "distributive" -2) (("1" (lemma "commutative_mult") (("1" (inst-cp - "a" "conjugate(a)") (("1" (inst-cp - "b" "conjugate(b)") (("1" (replace -2 * rl) (("1" (replace -3 * rl) (("1" (replace -6) (("1" (replace -7) (("1" (hide -4) (("1" (name "DRL" "conjugate(a) * b + conjugate(b) * a") (("1" (case-replace "A2 + conjugate(a) * b + conjugate(b) * a + B2 = A2+B2+DRL") (("1" (case "real_pred(DRL)") (("1" (hide -2) (("1" (replace -6 1 rl) (("1" (assert) (("1" (case "A2*B2>=0") (("1" (lemma "both_sides_plus_le2" ("z" "A2+B2" "x" "DRL" "y" "2*sqrt(A2 * B2)")) (("1" (case "DRL<=2 * sqrt(A2 * B2)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (name-replace "CA" "conjugate(a)") (("2" (name-replace "CB" "conjugate(b)") (("2" (lemma "complex_is_Re_Im" ("z" "a")) (("2" (lemma "complex_is_Re_Im" ("z" "b")) (("2" (replace -1 -5) (("2" (replace -2 -5) (("2" (expand "CA") (("2" (expand "CB") (("2" (expand "conjugate") (("2" (case-replace "DRL = 2*(Re(a)*Re(b)+Im(a)*Im(b))") (("1" (lemma "both_sides_times_pos_le1" ("pz" "2" "x" "Re(a) * Re(b) + Im(a) * Im(b)" "y" "sqrt(A2 * B2)")) (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "reals.closed_divides" ("x" "2 * (Re(a) * Re(b) + Im(a) * Im(b))" "n0z" "2")) (("1" (rewrite "times_div1" -1 :dir rl) (("1" (rewrite "div_cancel1" 1) (("1" (case "Im(a) * Im(b) + Re(a) * Re(b) < 0") (("1" (assert) nil nil) ("2" (rewrite "sq_le" 2 :dir rl) (("2" (rewrite "sq_sqrt") (("2" (expand "B2" 2) (("2" (rewrite "sq_abs_def" 2) (("2" (name-replace "DRL_B" "(Im(b) * Im(b) + Re(b) * Re(b))") (("2" (expand "A2") (("2" (lemma "sq_abs_def" ("z" "a")) (("2" (inst-cp -9 "conjugate(a)" "DRL_B") (("2" (replace -10 2) (("2" (rewrite "associative_mult" 2 :dir rl) (("2" (inst-cp -9 "conjugate(a)" "a") (("2" (replace -10 2) (("2" (replace -1 2) (("2" (expand "DRL_B") (("2" (expand "sq") (("2" (assert) (("2" (name "IA" "Im(a)") (("2" (replace -1) (("2" (name "IB" "Im(b)") (("2" (replace -1) (("2" (name "RB" "Re(b)") (("2" (replace -1) (("2" (name "RA" "Re(a)") (("2" (replace -1) (("2" (name-replace "DRL10" "IA * IA * IB * IB ") (("2" (name-replace "DRL11" "RA * RA * RB * RB ") (("2" (assert) (("2" (lemma "both_sides_plus_le2" ("z" "DRL10 + DRL11" "x" "2 * (IA * IB * RA * RB)" "y" "IA * IA * RB * RB + IB * IB * RA * RA")) (("2" (replace -1 2) (("2" (hide-all-but (1 2)) (("2" (case "IA*IB >= -(RA*RB)") (("1" (hide 1) (("1" (lemma "trichotomy" ("x" "IA*RB-RA*IB")) (("1" (split) (("1" (lemma "sq_lt" ("nna" "0" "nnb" "IA * RB - RA * IB")) (("1" (assert) (("1" (expand "sq") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "sq_eq" ("nna" "IA * RB - RA * IB" "nnb" "0")) (("1" (assert) (("1" (expand "sq") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (lemma "sq_lt" ("nna" "0" "nnb" "-(IA * RB - RA * IB)")) (("1" (assert) (("1" (rewrite "sq.sq_neg") (("1" (expand "sq") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -5 1 rl) (("2" (hide-all-but 1) (("2" (rewrite "associative_mult" :dir rl) (("2" (rewrite "associative_mult" :dir rl) (("2" (rewrite "associative_mult" :dir rl) (("2" (lemma "i_axiom") (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "reals.closed_plus" ("x" "A2" "y" "B2")) (("2" (propax) nil nil)) nil)) nil) ("3" (lemma "reals.closed_times" ("x" "A2" "y" "B2")) (("3" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 -13 -14 -10 -11)) (("2" (expand ">=") (("2" (expand "<=" -3) (("2" (split) (("1" (lemma "both_sides_times_pos_le1" ("pz" "B2" "x" "0" "y" "A2")) (("1" (assert) (("1" (rewrite "zero_times1") nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (replace -1 * rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "reals.closed_times" ("x" "A2" "y" "B2")) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "DRL") (("2" (case-replace "conjugate(a) * b + conjugate(b) * a = AB2 - A2 - B2") (("1" (assert) (("1" (hide-all-but (-8 -9 -10 1)) (("1" (postpone) nil nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but (-6 1)) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "DRL") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "AB2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name-replace "APB" "a + b") (("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((conjugate const-decl "complex" arithmetic nil) (sq_le formula-decl nil sq reals) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (sq_plus formula-decl nil sq reals) (conjugate_plus formula-decl nil arithmetic nil) (complex_is_Re_Im formula-decl nil arithmetic nil) (i_axiom formula-decl nil complex_types nil) (times_div1 formula-decl nil number_fields_bis nil) (sq_abs_def formula-decl nil arithmetic nil) (sq_0 formula-decl nil sq reals) (sq_lt formula-decl nil sq reals) (sq_eq formula-decl nil sq reals) (sq_neg formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (div_cancel1 formula-decl nil number_fields_bis nil) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (sqrt_times formula-decl nil sqrt reals) (sq_sqrt formula-decl nil sqrt reals) (sq_abs_nonneg formula-decl nil arithmetic nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil)) shostak)) (abs_triangle_minus 0 (abs_triangle_minus-1 nil 3596297605 ("" (skeep) (("" (lemma "abs_triangle") (("" (inst - "z2" "z1-z2") (("" (assert) nil nil)) nil)) nil)) nil) ((abs_triangle formula-decl nil polar nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (abs_abs 0 (abs_abs-2 nil 3307886891 ("" (skosimp) (("" (typepred "abs(z!1)") (("" (expand "abs") (("" (expand "conjugate") (("" (lemma "complex_is_Re_Im" ("z" "z!1")) (("" (name-replace "X" "Re(z!1)") (("" (name-replace "Y" "Im(z!1)") (("" (replace -1) (("" (hide -1) (("" (name "DRL1" "X * (X + Y * i) - Y * i * (X + Y * i)") (("" (replace -1) (("" (rewrite "Re_real" 1) (("1" (rewrite "Im_real" 1) (("1" (rewrite "zero_times1" 1) (("1" (rewrite "zero_times1" 1) (("1" (rewrite "sq.sq_rew" 1) (("1" (rewrite "sqrt.sq_sqrt") nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (rewrite "sq.sq_rew") (("2" (rewrite "sq.sq_rew") (("2" (rewrite "associative_mult" -1 :dir rl) (("2" (rewrite "i_axiom") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((abs const-decl "nnreal" polar nil) (nnreal type-eq-decl nil real_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Re_is_real application-judgement "real" complex_types nil) (real_times_real_is_real application-judgement "real" reals nil) (conjugate const-decl "complex" arithmetic nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (Re_real formula-decl nil arithmetic nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (sqrt_square formula-decl nil sqrt reals) (sq_rew formula-decl nil sq reals) (real_minus_real_is_real application-judgement "real" reals nil) (sq_sqrt formula-decl nil sqrt reals) (sqrt_sq formula-decl nil sqrt reals) (Im_real formula-decl nil arithmetic nil) (sq const-decl "nonneg_real" sq reals) (associative_mult formula-decl nil number_fields nil) (nil application-judgement "above(n)" exp2 nil) (i_axiom formula-decl nil complex_types nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (complex_is_Re_Im formula-decl nil arithmetic nil)) nil) (abs_abs-1 nil 3297714813 ("" (skosimp) (("" (typepred "abs(z!1)") (("" (expand "abs") (("" (expand "conjugate") (("" (lemma "complex_is_Re_Im" ("z" "z!1")) (("" (name-replace "X" "Re(z!1)") (("" (name-replace "Y" "Im(z!1)") (("" (replace -1) (("" (hide -1) (("" (name "DRL1" "X * (X + Y * i) - Y * i * (X + Y * i)") (("" (replace -1) (("" (rewrite "Re_real" 1) (("1" (rewrite "Im_real" 1) (("1" (rewrite "zero_times1" 1) (("1" (rewrite "zero_times1" 1) (("1" (rewrite "sq_rew" 1) (("1" (rewrite "sq_sqrt" 1) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (rewrite "sq_rew") (("2" (rewrite "sq_rew") (("2" (rewrite "associative_mult" -1 :dir rl) (("2" (rewrite "i_axiom") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (Re_real formula-decl nil arithmetic nil) (zero_times1 formula-decl nil number_fields_bis nil) (sqrt_square formula-decl nil sqrt reals) (sq_rew formula-decl nil sq reals) (sq_sqrt formula-decl nil sqrt reals) (sqrt_sq formula-decl nil sqrt reals) (Im_real formula-decl nil arithmetic nil) (sq const-decl "nonneg_real" sq reals) (i_axiom formula-decl nil complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (complex_is_Re_Im formula-decl nil arithmetic nil)) shostak)) (abs_i 0 (abs_i-1 nil 3385194591 ("" (expand "abs") (("" (expand "conjugate") (("" (lemma "Re_imag" ("x" "1")) (("" (lemma "Im_imag" ("x" "1")) (("" (rewrite "identity_mult") (("" (replace -1) (("" (replace -2) (("" (rewrite "zero_times1") (("" (rewrite "identity_mult") (("" (rewrite "i_axiom") (("" (rewrite "sqrt_1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex_times_complex_is_complex application-judgement "complex" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Re_is_real application-judgement "real" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (Im_imag formula-decl nil arithmetic nil) (zero_times1 formula-decl nil number_fields_bis nil) (i_axiom formula-decl nil complex_types nil) (nil application-judgement "above(n)" exp2 nil) (sqrt_1 formula-decl nil sqrt reals) (identity_mult formula-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (i const-decl "complex" complex_types nil) (Re_imag formula-decl nil arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (abs const-decl "nnreal" polar nil)) shostak)) (arg_TCC1 0 (arg_TCC1-1 nil 3294311190 ("" (skosimp) (("" (assert) nil nil)) nil) ((Re_is_real application-judgement "real" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak (arg subtype "complex_types.Im(polar.z)" "{z_1: reals.real | booleans.=>(complex_types.Re(polar.z) = 0, z_1 /= 0)}"))) (arg_TCC2 0 (arg_TCC2-1 nil 3294311658 ("" (skosimp*) (("" (lemma "atan2_ge_0_lt_2pi" ("x" "Re(z!1)" "y" "Im(z!1)")) (("" (split -1) (("1" (flatten) (("1" (assert) (("1" (lemma "trichotomy" ("x" "Re(z!1)")) (("1" (split -1) (("1" (lemma "atan2_quad4" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (assert) nil nil)) nil) ("2" (lemma "atan2_is_3pi2" ("x" "Re(z!1)" "y" "Im(z!1)")) (("2" (assert) nil nil)) nil) ("3" (lemma "atan2_quad3" ("x" "Re(z!1)" "y" "Im(z!1)")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (complex nonempty-type-from-decl nil complex_types nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (atan2_ge_0_lt_2pi formula-decl nil atan2 trig_fnd) (trichotomy formula-decl nil real_axioms nil) (atan2_quad3 formula-decl nil atan2_props trig_fnd) (atan2_is_3pi2 formula-decl nil atan2_props trig_fnd) (atan2_quad4 formula-decl nil atan2_props trig_fnd) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak (arg subtype "(number_fields.-)(atan2.atan2(complex_types.Re(polar.z), complex_types.Im(polar.z)), number_fields.*(2, pi_def.pi))" "argrng"))) (arg_TCC3 0 (arg_TCC3-2 "" 3790100317 ("" (skosimp) (("" (lemma "atan2_ge_0_lt_2pi" ("x" "Re(z!1)" "y" "Im(z!1)")) (("" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("" (assert) nil nil)) nil)) nil)) nil) ((Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (complex nonempty-type-from-decl nil complex_types nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (atan2_ge_0_lt_2pi formula-decl nil atan2 trig_fnd) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Re_is_real application-judgement "real" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak (arg subtype "complex_types.Im(polar.z)" "{z_1: reals.real | booleans.=>(complex_types.Re(polar.z) = 0, z_1 /= 0)}")) (arg_TCC3-1 nil 3294839112 ("" (skosimp) (("" (lemma "atan2_ge_0_lt_2pi" ("x" "Re(z!1)" "y" "Im(z!1)")) (("" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("" (assert) (("" (replace -1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (atan2_ge_0_lt_2pi formula-decl nil atan2 trig_fnd) (Re_is_real application-judgement "real" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak (arg subtype "complex_types.Im(polar.z)" "{z_1: reals.real | booleans.=>(complex_types.Re(polar.z) = 0, z_1 /= 0)}"))) (arg_TCC4 0 (arg_TCC4-2 "" 3790100317 ("" (skosimp) (("" (lemma "atan2_is_0" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (lemma "atan2_is_pi2" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (lemma "atan2_is_pi" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (lemma "atan2_quad1" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (lemma "atan2_quad2" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (assert) (("1" (case-replace "Im(z!1)=0") (("1" (assert) (("1" (lemma "trichotomy" ("x" "Re(z!1)")) (("1" (split -1) (("1" (propax) nil nil) ("2" (replace -1) (("2" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("2" (assert) (("2" (split -1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (/= const-decl "boolean" notequal nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (complex nonempty-type-from-decl nil complex_types nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (atan2_is_0 formula-decl nil atan2_props trig_fnd) (Im_is_real application-judgement "real" complex_types nil) (Re_is_real application-judgement "real" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (atan2_is_pi formula-decl nil atan2_props trig_fnd) (atan2_quad2 formula-decl nil atan2_props trig_fnd) (trichotomy formula-decl nil real_axioms nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (atan2_quad1 formula-decl nil atan2_props trig_fnd) (atan2_is_pi2 formula-decl nil atan2_props trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak (arg subtype "atan2.atan2(complex_types.Re(polar.z), complex_types.Im(polar.z))" "argrng")) (arg_TCC4-1 nil 3297458289 ("" (skosimp) (("" (lemma "atan2_is_0" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (lemma "atan2_is_pi2" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (lemma "atan2_is_pi" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (lemma "atan2_quad1" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (lemma "atan2_quad2" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (assert) (("1" (case-replace "Im(z!1)=0") (("1" (assert) (("1" (lemma "trichotomy" ("x" "Re(z!1)")) (("1" (split -1) (("1" (assert) nil nil) ("2" (assert) (("2" (replace -1) (("2" (assert) (("2" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "trichotomy" ("x" "Re(z!1)")) (("2" (split -1) (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("2" (assert) (("2" (split -1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (atan2_is_0 formula-decl nil atan2_props trig_fnd) (Im_is_real application-judgement "real" complex_types nil) (Re_is_real application-judgement "real" complex_types nil) (atan2_is_pi formula-decl nil atan2_props trig_fnd) (atan2_quad2 formula-decl nil atan2_props trig_fnd) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (atan2_quad1 formula-decl nil atan2_props trig_fnd) (atan2_is_pi2 formula-decl nil atan2_props trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak (arg subtype "atan2.atan2(complex_types.Re(polar.z), complex_types.Im(polar.z))" "argrng"))) (arg_is_0_nz 0 (arg_is_0_nz-1 nil 3295019855 ("" (skosimp*) (("" (typepred "arg(n0z!1)") (("" (lemma "complex_is_ne_0_Re_Im" ("z" "n0z!1")) (("" (assert) (("" (lemma "atan2_is_0" ("x" "Re(n0z!1)" "y" "Im(n0z!1)")) (("1" (case-replace "Re(n0z!1) > 0 AND Im(n0z!1) = 0") (("1" (flatten) (("1" (replace -2) (("1" (expand "arg") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (split 3) (("1" (expand "arg") (("1" (case-replace "Im(n0z!1) < 0") (("1" (lemma "atan2_ge_0_lt_2pi" ("x" "Re(n0z!1)" "y" "Im(n0z!1)")) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzcomplex nonempty-type-eq-decl nil complex_types nil) (arg const-decl "argrng" polar nil) (argrng nonempty-type-eq-decl nil polar nil) (<= const-decl "bool" reals nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (cos const-decl "real" sincos_def trig_fnd) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Im_is_real application-judgement "real" complex_types nil) (Re_is_real application-judgement "real" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (atan2_ge_0_lt_2pi formula-decl nil atan2 trig_fnd) (real_minus_real_is_real application-judgement "real" reals nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (atan2_is_0 formula-decl nil atan2_props trig_fnd) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (arg_is_0 0 (arg_is_0-1 nil 3295013793 ("" (skosimp) (("" (case-replace "z!1=0") (("1" (expand "arg") (("1" (rewrite "Re_real") (("1" (rewrite "Im_real") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "arg_is_0_nz" ("n0z" "z!1")) (("1" (case-replace "arg(z!1) = 0") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (replace 1) (("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (expand ">=") (("2" (expand "<=") (("2" (split -1) (("1" (assert) nil nil) ("2" (replace -1 * rl) (("2" (lemma "complex_is_Re_Im" ("z" "z!1")) (("2" (replace -2 * rl) (("2" (replace -3) (("2" (assert) (("2" (rewrite "zero_times1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Re_real formula-decl nil arithmetic nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Im_real formula-decl nil arithmetic nil) (arg const-decl "argrng" polar nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (cos const-decl "real" sincos_def trig_fnd) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (Im_is_real application-judgement "real" complex_types nil) (Re_is_real application-judgement "real" complex_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (i const-decl "complex" complex_types nil) (complex_is_Re_Im formula-decl nil arithmetic nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (>= const-decl "bool" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (arg_is_0_nz formula-decl nil polar nil) (/= const-decl "boolean" notequal nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (arg_is_pi2 0 (arg_is_pi2-2 "" 3790100320 ("" (skosimp) (("" (typepred "arg(z!1)") (("" (expand "arg") (("" (case-replace "z!1=0") (("1" (rewrite "Im_real") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case-replace "Im(z!1) < 0") (("1" (lemma "atan2_ge_0_lt_2pi" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (lemma "atan2_is_pi2" ("x" "Re(z!1)" "y" "Im(z!1)")) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((arg const-decl "argrng" polar nil) (argrng nonempty-type-eq-decl nil polar nil) (<= const-decl "bool" reals nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (cos const-decl "real" sincos_def trig_fnd) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Re_is_real application-judgement "real" complex_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Im_real formula-decl nil arithmetic nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (real_minus_real_is_real application-judgement "real" reals nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (atan2_ge_0_lt_2pi formula-decl nil atan2 trig_fnd) (atan2_is_pi2 formula-decl nil atan2_props trig_fnd) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak) (arg_is_pi2-1 nil 3295019935 ("" (skosimp) (("" (typepred "arg(z!1)") (("" (expand "arg") (("" (case-replace "z!1=0") (("1" (rewrite "Im_real") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case-replace "Im(z!1) < 0") (("1" (lemma "atan2_ge_0_lt_2pi" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (lemma "atan2_is_pi2" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (propax) nil nil) ("2" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("2" (assert) (("2" (split -1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (cos const-decl "real" sincos_def trig_fnd) (Re_is_real application-judgement "real" complex_types nil) (Im_real formula-decl nil arithmetic nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (atan2_ge_0_lt_2pi formula-decl nil atan2 trig_fnd) (atan2_is_pi2 formula-decl nil atan2_props trig_fnd) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (arg_is_pi 0 (arg_is_pi-1 nil 3295019473 ("" (skosimp) (("" (case-replace "z!1=0") (("1" (expand "arg") (("1" (rewrite "Re_real") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("2" (assert) (("2" (typepred "arg(z!1)") (("2" (lemma "atan2_is_pi" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (lemma "atan2_ge_0_lt_2pi" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (replace -5 -1) (("1" (flatten -1) (("1" (expand "arg") (("1" (case-replace "Im(z!1) < 0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -3) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Re_real formula-decl nil arithmetic nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Im_is_real application-judgement "real" complex_types nil) (arg const-decl "argrng" polar nil) (Re_is_real application-judgement "real" complex_types nil) (atan2_is_pi formula-decl nil atan2_props trig_fnd) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (atan2_ge_0_lt_2pi formula-decl nil atan2 trig_fnd) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (cos const-decl "real" sincos_def trig_fnd) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (arg_is_mpi2 0 (arg_is_mpi2-2 "" 3790100321 ("" (skosimp) (("" (case-replace "z!1=0") (("1" (expand "arg") (("1" (rewrite "Im_real") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "arg(z!1)") (("2" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("2" (assert) (("2" (lemma "atan2_ge_0_lt_2pi" ("x" "Re(z!1)" "y" "Im(z!1)")) (("2" (replace -2 -1) (("2" (flatten -1) (("2" (expand "arg") (("2" (lemma "atan2_is_3pi2" ("x" "Re(z!1)" "y" "Im(z!1)")) (("2" (case-replace "Im(z!1) < 0") (("1" (case-replace "Re(z!1)=0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Im_real formula-decl nil arithmetic nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (Re_is_real application-judgement "real" complex_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (arg const-decl "argrng" polar nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (atan2_ge_0_lt_2pi formula-decl nil atan2 trig_fnd) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (atan2_is_3pi2 formula-decl nil atan2_props trig_fnd) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Im_is_real application-judgement "real" complex_types nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (cos const-decl "real" sincos_def trig_fnd) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak) (arg_is_mpi2-1 nil 3297511933 ("" (skosimp) (("" (case-replace "z!1=0") (("1" (expand "arg") (("1" (rewrite "Im_real") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "arg(z!1)") (("2" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("2" (assert) (("2" (lemma "atan2_ge_0_lt_2pi" ("x" "Re(z!1)" "y" "Im(z!1)")) (("2" (replace -2 -1) (("2" (flatten -1) (("2" (expand "arg") (("2" (lemma "atan2_is_3pi2" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (case-replace "Im(z!1) < 0") (("1" (case-replace "Re(z!1)=0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (split -3) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (Im_real formula-decl nil arithmetic nil) (Re_is_real application-judgement "real" complex_types nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (atan2_ge_0_lt_2pi formula-decl nil atan2 trig_fnd) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (atan2_is_3pi2 formula-decl nil atan2_props trig_fnd) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (Im_is_real application-judgement "real" complex_types nil) (cos const-decl "real" sincos_def trig_fnd) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (arg_lt_0 0 (arg_lt_0-2 "" 3790100321 ("" (skosimp) (("" (typepred "arg(z!1)") (("" (expand "arg") (("" (case-replace "z!1=0") (("1" (rewrite "Im_real") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (lemma "atan2_is_3pi2" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (lemma "atan2_quad3" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (lemma "atan2_quad4" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (case-replace "Im(z!1) < 0") (("1" (lemma "trichotomy" ("x" "Re(z!1)")) (("1" (split -1) (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("2" (assert) (("2" (split -1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((arg const-decl "argrng" polar nil) (argrng nonempty-type-eq-decl nil polar nil) (<= const-decl "bool" reals nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (cos const-decl "real" sincos_def trig_fnd) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Im_real formula-decl nil arithmetic nil) (atan2_is_3pi2 formula-decl nil atan2_props trig_fnd) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (atan2_quad4 formula-decl nil atan2_props trig_fnd) (trichotomy formula-decl nil real_axioms nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (real_minus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (atan2_quad3 formula-decl nil atan2_props trig_fnd) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak) (arg_lt_0-1 nil 3297512359 ("" (skosimp) (("" (typepred "arg(z!1)") (("" (expand "arg") (("" (case-replace "z!1=0") (("1" (rewrite "Im_real") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (lemma "atan2_is_3pi2" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (lemma "atan2_quad3" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (lemma "atan2_quad4" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (case-replace "Im(z!1) < 0") (("1" (lemma "trichotomy" ("x" "Re(z!1)")) (("1" (split -1) (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (replace -1) (("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (hide 2 3 4) (("2" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("2" (assert) (("2" (lemma "atan2_ge_0_lt_2pi" ("x" "Re(z!1)" "y" "Im(z!1)")) (("2" (replace -2 -1) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("2" (assert) (("2" (split -1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (cos const-decl "real" sincos_def trig_fnd) (Im_real formula-decl nil arithmetic nil) (atan2_is_3pi2 formula-decl nil atan2_props trig_fnd) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (atan2_quad4 formula-decl nil atan2_props trig_fnd) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (atan2_quad3 formula-decl nil atan2_props trig_fnd) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (arg_p_lt_pi 0 (arg_p_lt_pi-1 nil 3297607614 ("" (skosimp*) (("" (case-replace "z!1=0") (("1" (expand "arg") (("1" (rewrite "Im_real") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "arg(z!1)") (("2" (expand "<=") (("2" (split -2) (("1" (replace -1) (("1" (lemma "trichotomy" ("x" "arg(z!1)")) (("1" (split -1) (("1" (hide -3) (("1" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("1" (assert) (("1" (expand "arg") (("1" (lemma "atan2_ge_0_lt_2pi" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (replace -2) (("1" (flatten) (("1" (lemma "trichotomy" ("x" "Im(z!1)")) (("1" (split -1) (("1" (propax) nil nil) ("2" (assert) (("2" (replace -1) (("2" (expand "atan2") (("2" (rewrite "atan_0") (("2" (case "Re(z!1)>0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "arg_is_0_nz" ("n0z" "z!1")) (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("3" (lemma "arg_lt_0" ("z" "z!1")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (lemma "arg_is_pi" ("z" "z!1")) (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Im_real formula-decl nil arithmetic nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (arg const-decl "argrng" polar nil) (arg_is_pi formula-decl nil polar nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (real_minus_real_is_real application-judgement "real" reals nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (atan2 const-decl "real" atan2 trig_fnd) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (atan_0 formula-decl nil atan trig_fnd) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (atan2_ge_0_lt_2pi formula-decl nil atan2 trig_fnd) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Re_is_real application-judgement "real" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (arg_is_0_nz formula-decl nil polar nil) (arg_lt_0 formula-decl nil polar nil) (trichotomy formula-decl nil real_axioms nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (cos const-decl "real" sincos_def trig_fnd) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (arg_gt_0 0 (arg_gt_0-1 nil 3297512850 ("" (skosimp*) (("" (typepred "arg(z!1)") (("" (expand "<=") (("" (lemma "arg_p_lt_pi" ("z" "z!1")) (("" (lemma "arg_is_pi" ("z" "z!1")) (("" (split 1) (("1" (flatten 1) (("1" (split -5) (("1" (assert) nil nil) ("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (split -1) (("1" (assert) nil nil) ("2" (flatten -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((arg const-decl "argrng" polar nil) (argrng nonempty-type-eq-decl nil polar nil) (<= const-decl "bool" reals nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (cos const-decl "real" sincos_def trig_fnd) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (arg_p_lt_pi formula-decl nil polar nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Im_is_real application-judgement "real" complex_types nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Re_is_real application-judgement "real" complex_types nil) (arg_is_pi formula-decl nil polar nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (arg_div_abs 0 (arg_div_abs-2 "" 3790100323 ("" (skosimp) (("" (lemma "abs_nz_iff_nz" ("z" "n0x!1")) (("" (assert) (("" (expand "arg") (("" (lemma "Im_div" ("z" "n0x!1" "n0z" "abs(n0x!1)")) (("" (typepred "abs(n0x!1)") (("" (lemma "Re_real" ("x" "abs(n0x!1)")) (("" (lemma "Im_real" ("x" "abs(n0x!1)")) (("" (replace -1) (("" (expand "conjugate") (("" (replace -1) (("" (replace -2) (("" (rewrite "zero_times1" -4) (("" (rewrite "zero_times1" -4) (("" (lemma "div_times" ("x" "Im(n0x!1)" "y" "abs(n0x!1)" "n0x" "abs(n0x!1)" "n0y" "abs(n0x!1)")) (("" (rewrite "div_simp" -1) (("" (replace -1 -5 rl) (("" (hide -1) (("" (rewrite "number_fields_right_identity_mult") (("" (replace -4) (("" (lemma "Re_div" ("z" "n0x!1" "n0z" "abs(n0x!1)")) (("" (expand "conjugate") (("" (replace -2) (("" (replace -3) (("" (assert) (("" (lemma "div_times" ("x" "Re(n0x!1)" "y" "abs(n0x!1)" "n0x" "abs(n0x!1)" "n0y" "abs(n0x!1)")) (("" (rewrite "div_simp") (("" (rewrite "number_fields_right_identity_mult") (("" (replace -1) (("" (lemma "complex_is_ne_0_Re_Im" ("z" "n0x!1")) (("" (lemma "atan2_cancel_pos" ("x" "Re(n0x!1)" "y" "Im(n0x!1)" "pz" "1/abs(n0x!1)")) (("1" (simplify -2) (("1" (replace -2 -1) (("1" (replace -1 1) (("1" (rewrite "div_mult_pos_lt1" 1) (("1" (case-replace "Im(n0x!1) < 0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "posreal_div_posreal_is_posreal" ("px" "1" "py" "abs(n0x!1)")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzcomplex nonempty-type-eq-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (abs_nz_iff_nz formula-decl nil polar nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (arg const-decl "argrng" polar nil) (NOT const-decl "[bool -> bool]" booleans nil) (Im_real formula-decl nil arithmetic nil) (conjugate const-decl "complex" arithmetic nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (i const-decl "complex" complex_types nil) (div_simp formula-decl nil number_fields_bis nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (posreal_div_posreal_is_posreal judgement-tcc nil real_types nil) (< const-decl "bool" reals nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (atan2_cancel_pos formula-decl nil atan2 trig_fnd) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (complex_div_nzcomplex_is_complex application-judgement "complex" complex_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (Re_div formula-decl nil arithmetic nil) (number_fields_right_identity_mult formula-decl nil number_fields_bis nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (nznum nonempty-type-eq-decl nil number_fields nil) (div_times formula-decl nil number_fields_bis nil) (zero_times1 formula-decl nil number_fields_bis nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (Re_is_real application-judgement "real" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (Re_real formula-decl nil arithmetic nil) (Im_div formula-decl nil arithmetic nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (abs const-decl "nnreal" polar nil) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak) (arg_div_abs-1 nil 3297701781 ("" (skosimp) (("" (lemma "abs_nz_iff_nz" ("z" "n0x!1")) (("" (assert) (("" (expand "arg") (("" (lemma "Im_div" ("z" "n0x!1" "n0z" "abs(n0x!1)")) (("1" (typepred "abs(n0x!1)") (("1" (lemma "Re_real" ("x" "abs(n0x!1)")) (("1" (lemma "Im_real" ("x" "abs(n0x!1)")) (("1" (replace -1) (("1" (expand "conjugate") (("1" (replace -1) (("1" (replace -2) (("1" (rewrite "zero_times1" -4) (("1" (rewrite "zero_times1" -4) (("1" (lemma "div_times" ("x" "Im(n0x!1)" "y" "abs(n0x!1)" "n0x" "abs(n0x!1)" "n0y" "abs(n0x!1)")) (("1" (rewrite "div_simp" -1) (("1" (replace -1 -5 rl) (("1" (hide -1) (("1" (rewrite "number_fields_right_identity_mult") (("1" (replace -4) (("1" (lemma "Re_div" ("z" "n0x!1" "n0z" "abs(n0x!1)")) (("1" (expand "conjugate") (("1" (replace -2) (("1" (replace -3) (("1" (assert) (("1" (lemma "div_times" ("x" "Re(n0x!1)" "y" "abs(n0x!1)" "n0x" "abs(n0x!1)" "n0y" "abs(n0x!1)")) (("1" (rewrite "div_simp") (("1" (rewrite "number_fields_right_identity_mult") (("1" (replace -1) (("1" (lemma "complex_is_ne_0_Re_Im" ("z" "n0x!1")) (("1" (lemma "atan2_cancel_pos" ("x" "Re(n0x!1)" "y" "Im(n0x!1)" "pz" "1/abs(n0x!1)")) (("1" (simplify -2) (("1" (replace -2 -1) (("1" (replace -1 1) (("1" (rewrite "div_mult_pos_lt1" 1) (("1" (case-replace "Im(n0x!1) < 0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "posreal_div_posreal_is_posreal" ("px" "1" "py" "abs(n0x!1)")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "real_is_complex" ("x" "abs(n0x!1)")) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzcomplex nonempty-type-eq-decl nil complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (Im_real formula-decl nil arithmetic nil) (conjugate const-decl "complex" arithmetic nil) (i const-decl "complex" complex_types nil) (div_simp formula-decl nil number_fields_bis nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (atan2_cancel_pos formula-decl nil atan2 trig_fnd) (complex_div_nzcomplex_is_complex application-judgement "complex" complex_types nil) (Re_div formula-decl nil arithmetic nil) (number_fields_right_identity_mult formula-decl nil number_fields_bis nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (div_times formula-decl nil number_fields_bis nil) (zero_times1 formula-decl nil number_fields_bis nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (Re_is_real application-judgement "real" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (Re_real formula-decl nil arithmetic nil) (Im_div formula-decl nil arithmetic nil) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd)) shostak)) (Re_cos_abs1 0 (Re_cos_abs1-2 nil 3307887108 ("" (skosimp*) (("" (expand "arg") (("" (expand "abs") (("" (expand "conjugate") (("" (lemma "complex_is_Re_Im" ("z" "n0x!1")) (("" (lemma "complex_is_ne_0_Re_Im" ("z" "n0x!1")) (("" (simplify -1) (("" (name-replace "X" "Re(n0x!1)") (("" (name-replace "Y" "Im(n0x!1)") (("" (replace -2) (("" (simplify -3) (("" (rewrite "sq.sq_rew") (("" (rewrite "sq.sq_rew") (("" (rewrite "associative_mult" -3 :dir rl) (("" (rewrite "i_axiom") (("" (simplify -3) (("" (lemma "cos_period" ("a" "atan2(X,Y)" "j" "-1")) (("1" (replace -1 1 rl) (("1" (lemma "cos_atan2" ("x" "X" "y" "Y")) (("1" (replace -3 -1) (("1" (case-replace "X=0") (("1" (replace -2) (("1" (case-replace "Y<0") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (replace -1 2) (("2" (case-replace "1 + sq.sq(Y / X) = 1/sq.sq(X)") (("1" (hide -1) (("1" (hide -1) (("1" (case "sq.sq(X)>0") (("1" (rewrite "sqrt_div") (("1" (case-replace "X>0") (("1" (rewrite "sqrt.sqrt_sq") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (lemma "sq.sq_nz_pos" ("nz" "X")) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sq.sq_div" 1) (("2" (lemma "add_div" ("x" "1" "n0x" "1" "y" "sq.sq(Y)" "n0y" "sq.sq(X)")) (("2" (replace -1 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "sq.sq_eq_0" ("a" "X")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (arg const-decl "argrng" polar nil) (Im_is_real application-judgement "real" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Re_is_real application-judgement "real" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (sq_rew formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (associative_mult formula-decl nil number_fields nil) (real_minus_real_is_real application-judgement "real" reals nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (npreal_div_posreal_is_npreal application-judgement "npreal" real_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (sqrt_pos application-judgement "posreal" sqrt reals) (sq_nz_pos judgement-tcc nil sq reals) (nzreal nonempty-type-eq-decl nil reals nil) (sqrt_div formula-decl nil sqrt reals) (sqrt_1 formula-decl nil sqrt reals) (sqrt_sq_neg formula-decl nil sqrt reals) (minus_real_is_real application-judgement "real" reals nil) (> const-decl "bool" reals nil) (add_div formula-decl nil number_fields_bis nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (sq_div formula-decl nil sq reals) (sq_eq_0 formula-decl nil sq reals) (sq_0 formula-decl nil sq reals) (sqrt_sq formula-decl nil sqrt reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (cos_atan2 formula-decl nil atan2 trig_fnd) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (atan2 const-decl "real" atan2 trig_fnd) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (cos_period formula-decl nil sincos trig_fnd) (nil application-judgement "above(n)" exp2 nil) (i_axiom formula-decl nil complex_types nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (complex_is_Re_Im formula-decl nil arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (abs const-decl "nnreal" polar nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) nil) (Re_cos_abs1-1 nil 3297716468 ("" (skosimp*) (("" (expand "arg") (("" (expand "abs") (("" (expand "conjugate") (("" (lemma "complex_is_Re_Im" ("z" "n0x!1")) (("" (lemma "complex_is_ne_0_Re_Im" ("z" "n0x!1")) (("" (simplify -1) (("" (name-replace "X" "Re(n0x!1)") (("" (name-replace "Y" "Im(n0x!1)") (("" (replace -2) (("" (simplify -3) (("" (rewrite "sq_rew") (("" (rewrite "sq_rew") (("" (rewrite "associative_mult" -3 :dir rl) (("" (rewrite "i_axiom") (("" (simplify -3) (("" (lemma "cos_period" ("a" "atan2(X,Y)" "j" "-1")) (("1" (replace -1 1 rl) (("1" (lemma "cos_atan2" ("x" "X" "y" "Y")) (("1" (replace -3 -1) (("1" (case-replace "X=0") (("1" (replace -2) (("1" (case-replace "Y<0") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (replace -1 2) (("2" (lemma "sq_eq" ("nna" "sqrt(sq(X)+sq(Y))" "nnb" "1")) (("2" (rewrite "sq_1") (("2" (rewrite "sq_sqrt") (("2" (replace -5 -1) (("2" (flatten -1) (("2" (case-replace "1 + sq(Y / X) = 1/sq(X)") (("1" (hide -1) (("1" (case "sq(X)>0") (("1" (rewrite "sqrt_div") (("1" (case-replace "X>0") (("1" (rewrite "sqrt_sq") nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (lemma "sq_nz_pos" ("nz" "X")) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (rewrite "sq_div" 1) (("2" (lemma "add_div" ("x" "1" "n0x" "1" "y" "sq(Y)" "n0y" "sq(X)")) (("1" (replace -2 -1) (("1" (replace -1 1) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "sq_eq_0" ("a" "X")) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "sq") (("3" (lemma "sq_eq_0" ("a" "X")) (("3" (expand "sq") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((conjugate const-decl "complex" arithmetic nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (sq_rew formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (sq_eq formula-decl nil sq reals) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (sq_sqrt formula-decl nil sqrt reals) (sq_div formula-decl nil sq reals) (sq_eq_0 formula-decl nil sq reals) (add_div formula-decl nil number_fields_bis nil) (sq_nz_pos judgement-tcc nil sq reals) (sqrt_div formula-decl nil sqrt reals) (sqrt_1 formula-decl nil sqrt reals) (sqrt_sq_neg formula-decl nil sqrt reals) (sqrt_sq formula-decl nil sqrt reals) (sq_1 formula-decl nil sq reals) (sq_0 formula-decl nil sq reals) (cos_atan2 formula-decl nil atan2 trig_fnd) (atan2 const-decl "real" atan2 trig_fnd) (i_axiom formula-decl nil complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (complex_is_Re_Im formula-decl nil arithmetic nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil)) shostak)) (Im_sin_abs1 0 (Im_sin_abs1-2 nil 3307887538 ("" (skosimp) (("" (expand "arg") (("" (expand "abs") (("" (expand "conjugate") (("" (lemma "complex_is_Re_Im" ("z" "n0x!1")) (("" (lemma "complex_is_ne_0_Re_Im" ("z" "n0x!1")) (("" (simplify -1) (("" (name-replace "X" "Re(n0x!1)") (("" (name-replace "Y" "Im(n0x!1)") (("" (replace -2) (("" (simplify -3) (("" (rewrite "sq.sq_rew") (("" (rewrite "sq.sq_rew") (("" (rewrite "associative_mult" -3 :dir rl) (("" (rewrite "i_axiom") (("" (simplify -3) (("" (lemma "sin_period" ("a" "atan2(X,Y)" "j" "-1")) (("1" (replace -1 1 rl) (("1" (lemma "sin_atan2" ("x" "X" "y" "Y")) (("1" (replace -3 -1) (("1" (case-replace "X=0") (("1" (replace -2) (("1" (case-replace "Y<0") (("1" (assert) (("1" (lemma "sq.sq_neg") (("1" (inst - "Y") (("1" (replace -1 -8 rl) (("1" (rewrite "sqrt.sqrt_sq" -8) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "sqrt.sqrt_sq") (("2" (inst - "Y") (("2" (split -1) (("1" (replace -1 -7) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -1 2) (("2" (hide -1) (("2" (lemma "sq.sq_eq" ("nna" "sqrt(sq.sq(X)+sq.sq(Y))" "nnb" "1")) (("2" (rewrite "sq.sq_1") (("2" (rewrite "sqrt.sq_sqrt") (("2" (replace -4 -1) (("2" (flatten -1) (("2" (lemma "sq.sq_nz_pos" ("nz" "X")) (("2" (case-replace "1 + sq.sq(Y / X) = 1/sq.sq(X)") (("1" (case-replace "X>0") (("1" (rewrite "sqrt.sqrt_div" 2) (("1" (rewrite "sqrt.sqrt_sq") (("1" (rewrite "div_div2") nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "sq.sq_neg") (("2" (inst - "X") (("2" (replace -1 3 rl) (("2" (rewrite "sqrt.sqrt_div" 3) (("2" (rewrite "div_div1" 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "add_div" ("x" "1" "n0x" "1" "y" "sq.sq(X)" "n0y" "sq.sq(Y)")) (("1" (replace -3) (("1" (rewrite "sq.sq_div" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "/=" 1) (("2" (lemma "sq.sq_eq_0" ("a" "Y")) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (arg const-decl "argrng" polar nil) (Im_is_real application-judgement "real" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Re_is_real application-judgement "real" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (sq_rew formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (associative_mult formula-decl nil number_fields nil) (real_minus_real_is_real application-judgement "real" reals nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (sqrt_pos application-judgement "posreal" sqrt reals) (real_div_nzreal_is_real application-judgement "real" reals nil) (sq_1 formula-decl nil sq reals) (sq_nz_pos judgement-tcc nil sq reals) (nzreal nonempty-type-eq-decl nil reals nil) (add_div formula-decl nil number_fields_bis nil) (sq_div formula-decl nil sq reals) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (sq_eq_0 formula-decl nil sq reals) (> const-decl "bool" reals nil) (div_div2 formula-decl nil number_fields_bis nil) (sqrt_1 formula-decl nil sqrt reals) (sqrt_div formula-decl nil sqrt reals) (sq_neg formula-decl nil sq reals) (div_div1 formula-decl nil number_fields_bis nil) (- const-decl "[numfield -> numfield]" number_fields nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (sq_sqrt formula-decl nil sqrt reals) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (nnreal type-eq-decl nil real_types nil) (sq_eq formula-decl nil sq reals) (sqrt_sq formula-decl nil sqrt reals) (sq_0 formula-decl nil sq reals) (sqrt_sq_neg formula-decl nil sqrt reals) (real_plus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (minus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (sin_atan2 formula-decl nil atan2 trig_fnd) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (atan2 const-decl "real" atan2 trig_fnd) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (sin_period formula-decl nil sincos trig_fnd) (nil application-judgement "above(n)" exp2 nil) (i_axiom formula-decl nil complex_types nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (complex_is_Re_Im formula-decl nil arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (abs const-decl "nnreal" polar nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) nil) (Im_sin_abs1-1 nil 3297722477 ("" (skosimp) (("" (expand "arg") (("" (expand "abs") (("" (expand "conjugate") (("" (lemma "complex_is_Re_Im" ("z" "n0x!1")) (("" (lemma "complex_is_ne_0_Re_Im" ("z" "n0x!1")) (("" (simplify -1) (("" (name-replace "X" "Re(n0x!1)") (("" (name-replace "Y" "Im(n0x!1)") (("" (replace -2) (("" (simplify -3) (("" (rewrite "sq_rew") (("" (rewrite "sq_rew") (("" (rewrite "associative_mult" -3 :dir rl) (("" (rewrite "i_axiom") (("" (simplify -3) (("" (lemma "sin_period" ("a" "atan2(X,Y)" "j" "-1")) (("1" (replace -1 1 rl) (("1" (lemma "sin_atan2" ("x" "X" "y" "Y")) (("1" (replace -3 -1) (("1" (case-replace "X=0") (("1" (replace -2) (("1" (case-replace "Y<0") (("1" (assert) (("1" (lemma "sq_neg") (("1" (inst - "Y") (("1" (replace -1 -8 rl) (("1" (rewrite "sqrt_sq" -8) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "sqrt_sq") (("2" (inst - "Y") (("2" (split -1) (("1" (replace -1 -7) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -1 2) (("2" (hide -1) (("2" (lemma "sq_eq" ("nna" "sqrt(sq(X)+sq(Y))" "nnb" "1")) (("2" (rewrite "sq_1") (("2" (rewrite "sq_sqrt") (("2" (replace -4 -1) (("2" (flatten -1) (("2" (lemma "sq_nz_pos" ("nz" "X")) (("2" (case-replace "1 + sq(Y / X) = 1/sq(X)") (("1" (case-replace "X>0") (("1" (rewrite "sqrt_div" 2) (("1" (rewrite "sqrt_sq") (("1" (rewrite "div_div2") nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "sq_neg") (("2" (inst - "X") (("2" (replace -1 3 rl) (("2" (rewrite "sqrt_div" 3) (("2" (rewrite "div_div1" 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "add_div" ("x" "1" "n0x" "1" "y" "sq(X)" "n0y" "sq(Y)")) (("1" (replace -3) (("1" (rewrite "sq_div" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "/=" 1) (("2" (lemma "sq_eq_0" ("a" "Y")) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((conjugate const-decl "complex" arithmetic nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (sq_rew formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (sq_1 formula-decl nil sq reals) (sq_nz_pos judgement-tcc nil sq reals) (add_div formula-decl nil number_fields_bis nil) (sq_div formula-decl nil sq reals) (sq_eq_0 formula-decl nil sq reals) (div_div2 formula-decl nil number_fields_bis nil) (sqrt_1 formula-decl nil sqrt reals) (sqrt_div formula-decl nil sqrt reals) (div_div1 formula-decl nil number_fields_bis nil) (sq_sqrt formula-decl nil sqrt reals) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (sq_eq formula-decl nil sq reals) (sq_0 formula-decl nil sq reals) (sqrt_sq formula-decl nil sqrt reals) (sq_neg formula-decl nil sq reals) (sin_atan2 formula-decl nil atan2 trig_fnd) (atan2 const-decl "real" atan2 trig_fnd) (i_axiom formula-decl nil complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (complex_is_Re_Im formula-decl nil arithmetic nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil)) shostak)) (arg_nnreal 0 (arg_nnreal-1 nil 3385304736 ("" (skosimp) (("" (typepred "nnx!1") (("" (expand "arg") (("" (expand ">=") (("" (expand "<=") (("" (split -1) (("1" (assert) (("1" (rewrite "Im_real") (("1" (rewrite "Re_real") (("1" (assert) (("1" (expand "atan2") (("1" (rewrite "atan_0") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Im_real formula-decl nil arithmetic nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (atan_0 formula-decl nil atan trig_fnd) (atan2 const-decl "real" atan2 trig_fnd) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (Re_real formula-decl nil arithmetic nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (<= const-decl "bool" reals nil) (arg const-decl "argrng" polar nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (arg_nreal 0 (arg_nreal-1 nil 3385304815 ("" (skosimp) (("" (typepred "nx!1") (("" (hide -1) (("" (expand "arg") (("" (rewrite "Im_real") (("" (rewrite "Re_real") (("" (assert) (("" (expand "atan2") (("" (rewrite "atan_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (arg const-decl "argrng" polar nil) (Re_real formula-decl nil arithmetic nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (atan2 const-decl "real" atan2 trig_fnd) (atan_0 formula-decl nil atan trig_fnd) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (Im_real formula-decl nil arithmetic nil)) shostak)) (arg_i 0 (arg_i-1 nil 3385194777 ("" (lemma "arg_is_pi2" ("z" "i")) (("" (lemma "Re_imag" ("x" "1")) (("" (lemma "Im_imag" ("x" "1")) (("" (rewrite "identity_mult") (("" (replace -1) (("" (replace -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Re_imag formula-decl nil arithmetic nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (identity_mult formula-decl nil number_fields nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (Im_is_real application-judgement "real" complex_types nil) (Re_is_real application-judgement "real" complex_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Im_imag formula-decl nil arithmetic nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (arg_is_pi2 formula-decl nil polar nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (i const-decl "complex" complex_types nil)) shostak)) (arg_neg 0 (arg_neg-1 nil 3297516982 ("" (skolem 1 ("a")) (("" (name "AA" "arg(a)") (("" (replace -1) (("" (case-replace "a=0") (("1" (assert) nil nil) ("2" (lemma "complex_is_ne_0_Re_Im" ("z" "a")) (("2" (assert) (("2" (typepred "arg(a)") (("2" (lemma "arg_gt_0" ("z" "a")) (("2" (lemma "arg_lt_0" ("z" "a")) (("2" (lemma "arg_is_0_nz" ("n0z" "a")) (("2" (replace -7) (("2" (case-replace "0<AA") (("1" (assert) (("1" (expand "arg") (("1" (rewrite "Im_neg") (("1" (rewrite "Re_neg") (("1" (lemma "atan2_cancel_neg" ("x" "-Re(a)" "y" "-Im(a)" "nz" "-1")) (("1" (split -1) (("1" (assert) (("1" (split -3) (("1" (assert) nil nil) ("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split -2) (("1" (assert) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "arg") (("2" (case-replace "AA=0") (("1" (assert) (("1" (rewrite "Re_neg") (("1" (rewrite "Im_neg") (("1" (lemma "atan2_cancel_neg" ("x" "-Re(a)" "y" "-Im(a)" "nz" "-1")) (("1" (assert) (("1" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (split -5) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "atan2_cancel_neg" ("x" "-Re(a)" "y" "-Im(a)" "nz" "-1")) (("2" (rewrite "Im_neg") (("2" (rewrite "Re_neg") (("2" (split -1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzcomplex nonempty-type-eq-decl nil complex_types nil) (arg const-decl "argrng" polar nil) (argrng nonempty-type-eq-decl nil polar nil) (<= const-decl "bool" reals nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (cos const-decl "real" sincos_def trig_fnd) (> const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (Re_is_real application-judgement "real" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (arg_gt_0 formula-decl nil polar nil) (arg_is_0_nz formula-decl nil polar nil) (Re_neg formula-decl nil arithmetic nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (nil application-judgement "above(n)" exp2 nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (negreal nonempty-type-eq-decl nil real_types nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (atan2_cancel_neg formula-decl nil atan2 trig_fnd) (minus_real_is_real application-judgement "real" reals nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (Im_neg formula-decl nil arithmetic nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (arg_lt_0 formula-decl nil polar nil) (NOT const-decl "[bool -> bool]" booleans nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd)) shostak)) (arg_mult 0 (arg_mult-2 "" 3790100331 ("" (skosimp*) (("" (rewrite "arg_div_abs") (("" (lemma "arg_div_abs" ("n0x" "n0x!1")) (("" (lemma "arg_div_abs" ("n0x" "n0y!1")) (("" (replace -1) (("" (replace -2) (("" (hide -1 -2) (("" (rewrite "abs_mult") (("" (rewrite "div_times" 1 :dir rl) (("" (name "X" "n0x!1 / abs(n0x!1)") (("" (replace -1) (("" (name "Y" "n0y!1 / abs(n0y!1)") (("" (replace -1) (("" (lemma "Re_cos_abs1" ("n0x" "X")) (("" (lemma "Re_cos_abs1" ("n0x" "Y")) (("" (lemma "Im_sin_abs1" ("n0x" "X")) (("" (lemma "Im_sin_abs1" ("n0x" "Y")) (("" (case-replace "abs(X)=1") (("1" (case-replace "abs(Y)=1") (("1" (lemma "abs_mult" ("z1" "X" "z2" "Y")) (("1" (replace -2) (("1" (replace -3) (("1" (lemma "Re_cos_abs1" ("n0x" "X*Y")) (("1" (lemma "Im_sin_abs1" ("n0x" "X*Y")) (("1" (replace -3) (("1" (case "X/=0") (("1" (case "Y/=0") (("1" (case "X*Y/=0") (("1" (name "TH1" "arg(X)") (("1" (name "TH2" "arg(Y)") (("1" (typepred "arg(X)") (("1" (typepred "arg(Y)") (("1" (replace -5) (("1" (replace -6) (("1" (lemma "Re_times" ("z1" "X" "z2" "Y")) (("1" (lemma "Im_times" ("z1" "X" "z2" "Y")) (("1" (replace -17 (-1 -2)) (("1" (replace -18 (-1 -2)) (("1" (replace -19 (-1 -2)) (("1" (replace -20 (-1 -2)) (("1" (lemma "sin_plus" ("a" "TH1" "b" "TH2")) (("1" (replace -1 -2 rl) (("1" (lemma "cos_plus" ("a" "TH1" "b" "TH2")) (("1" (replace -1 -4 rl) (("1" (hide -1 -2) (("1" (expand "arg" 1) (("1" (replace -1 1) (("1" (replace -2 1) (("1" (case-replace "TH1 + TH2 > pi") (("1" (case-replace "TH1+TH2=2*pi") (("1" (rewrite "sin_2pi") (("1" (rewrite "cos_2pi") (("1" (expand "atan2") (("1" (rewrite "atan_0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "sin_lt_0" ("a" "TH1+TH2")) (("2" (assert) (("2" (rewrite "atan2_cos_sin") nil nil)) nil)) nil)) nil) ("2" (case-replace "TH1 + TH2 <= -pi") (("1" (assert) (("1" (case-replace "TH1 + TH2 = -pi") (("1" (rewrite "sin_neg" 2) (("1" (rewrite "cos_neg" 2) (("1" (rewrite "sin_pi") (("1" (rewrite "cos_pi") (("1" (expand "atan2") (("1" (rewrite "atan_0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sin_gt_0" ("a" "TH1+TH2+2*pi")) (("2" (assert) (("2" (lemma "sin_period" ("a" "TH1+TH2" "j" "1")) (("2" (lemma "cos_period" ("a" "TH1+TH2" "j" "1")) (("2" (assert) (("2" (lemma "atan2_cos_sin" ("a" "TH1 + TH2 + 2 * pi")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "trichotomy" ("x" "TH1+TH2")) (("2" (split -1) (("1" (lemma "sin_gt_0" ("a" "TH1+TH2")) (("1" (assert) (("1" (case-replace "TH1+TH2=pi") (("1" (rewrite "sin_pi") (("1" (rewrite "cos_pi") (("1" (expand "atan2") (("1" (rewrite "atan_0") nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "atan2_cos_sin") nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (rewrite "sin_0") (("2" (rewrite "cos_0") (("2" (expand "atan2") (("2" (rewrite "atan_0") nil nil)) nil)) nil)) nil)) nil) ("3" (lemma "sin_lt_0" ("a" "TH1+TH2+2*pi")) (("3" (assert) (("3" (lemma "sin_period" ("a" "TH1+TH2" "j" "1")) (("3" (lemma "cos_period" ("a" "TH1+TH2" "j" "1")) (("3" (assert) (("3" (lemma "atan2_cos_sin" ("a" "TH1 + TH2 + 2 * pi")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "abs_nz_iff_nz" ("z" "X*Y")) (("2" (assert) nil nil)) nil)) nil) ("2" (lemma "abs_nz_iff_nz" ("z" "Y")) (("2" (assert) nil nil)) nil)) nil) ("2" (lemma "abs_nz_iff_nz" ("z" "X")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (replace -1 1 rl) (("2" (rewrite "abs_div") (("2" (rewrite "abs_abs") (("2" (rewrite "div_simp") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -6 1 rl) (("2" (hide-all-but 1) (("2" (rewrite "abs_div") (("2" (rewrite "abs_abs") (("2" (rewrite "div_simp") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzcomplex_times_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (arg_div_abs formula-decl nil polar nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (abs_mult formula-decl nil polar nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (Re_cos_abs1 formula-decl nil polar nil) (Im_sin_abs1 formula-decl nil polar nil) (abs_div formula-decl nil polar nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (div_simp formula-decl nil number_fields_bis nil) (abs_abs formula-decl nil polar nil) (Im_times formula-decl nil arithmetic nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (cos_neg formula-decl nil sincos_def trig_fnd) (cos_pi formula-decl nil sincos trig_fnd) (nil application-judgement "above(n)" exp2 nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (sin_pi formula-decl nil sincos trig_fnd) (minus_real_is_real application-judgement "real" reals nil) (sin_neg formula-decl nil sincos_def trig_fnd) (cos_period formula-decl nil sincos trig_fnd) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (sin_period formula-decl nil sincos trig_fnd) (sin_gt_0 formula-decl nil trig_ineq trig_fnd) (trichotomy formula-decl nil real_axioms nil) (cos_0 formula-decl nil sincos_def trig_fnd) (sin_0 formula-decl nil sincos_def trig_fnd) (cos_2pi formula-decl nil sincos trig_fnd) (atan_0 formula-decl nil atan trig_fnd) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (atan2 const-decl "real" atan2 trig_fnd) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (sin_2pi formula-decl nil sincos trig_fnd) (real_minus_real_is_real application-judgement "real" reals nil) (atan2_cos_sin formula-decl nil atan2 trig_fnd) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sin_lt_0 formula-decl nil trig_ineq trig_fnd) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_plus_real_is_real application-judgement "real" reals nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (cos_plus formula-decl nil sincos trig_fnd) (sin_plus formula-decl nil sincos trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (Re_is_real application-judgement "real" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (Re_times formula-decl nil arithmetic nil) (NOT const-decl "[bool -> bool]" booleans nil) (arg const-decl "argrng" polar nil) (argrng nonempty-type-eq-decl nil polar nil) (<= const-decl "bool" reals nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (cos const-decl "real" sincos_def trig_fnd) (> const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (abs_nz_iff_nz formula-decl nil polar nil) (div_times formula-decl nil number_fields_bis nil) (nznum nonempty-type-eq-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (abs const-decl "nnreal" polar nil)) shostak) (arg_mult-1 nil 3294697583 ("" (skosimp*) (("" (rewrite "arg_div_abs") (("" (lemma "arg_div_abs" ("n0x" "n0x!1")) (("" (lemma "arg_div_abs" ("n0x" "n0y!1")) (("" (replace -1) (("" (replace -2) (("" (hide -1 -2) (("" (rewrite "abs_mult") (("" (rewrite "div_times" 1 :dir rl) (("" (name "X" "n0x!1 / abs(n0x!1)") (("" (replace -1) (("" (name "Y" "n0y!1 / abs(n0y!1)") (("" (replace -1) (("" (lemma "Re_cos_abs1" ("n0x" "X")) (("1" (lemma "Re_cos_abs1" ("n0x" "Y")) (("1" (lemma "Im_sin_abs1" ("n0x" "X")) (("1" (lemma "Im_sin_abs1" ("n0x" "Y")) (("1" (case-replace "abs(X)=1") (("1" (case-replace "abs(Y)=1") (("1" (lemma "abs_mult" ("z1" "X" "z2" "Y")) (("1" (replace -2) (("1" (replace -3) (("1" (lemma "Re_cos_abs1" ("n0x" "X*Y")) (("1" (lemma "Im_sin_abs1" ("n0x" "X*Y")) (("1" (replace -3) (("1" (case "X/=0") (("1" (case "Y/=0") (("1" (case "X*Y/=0") (("1" (name "TH1" "arg(X)") (("1" (name "TH2" "arg(Y)") (("1" (typepred "arg(X)") (("1" (typepred "arg(Y)") (("1" (replace -5) (("1" (replace -6) (("1" (lemma "Re_times" ("z1" "X" "z2" "Y")) (("1" (lemma "Im_times" ("z1" "X" "z2" "Y")) (("1" (replace -17 (-1 -2)) (("1" (replace -18 (-1 -2)) (("1" (replace -19 (-1 -2)) (("1" (replace -20 (-1 -2)) (("1" (lemma "sin_plus" ("a" "TH1" "b" "TH2")) (("1" (replace -1 -2 rl) (("1" (lemma "cos_plus" ("a" "TH1" "b" "TH2")) (("1" (replace -1 -4 rl) (("1" (hide -1 -2) (("1" (expand "arg" 1) (("1" (replace -1 1) (("1" (replace -2 1) (("1" (case-replace "TH1 + TH2 > pi") (("1" (case-replace "TH1+TH2=2*pi") (("1" (rewrite "sin_2pi") (("1" (rewrite "cos_2pi") (("1" (expand "atan2") (("1" (rewrite "atan_0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "sin_lt_0" ("a" "TH1+TH2")) (("2" (assert) (("2" (rewrite "atan2_cos_sin") nil nil)) nil)) nil)) nil) ("2" (case-replace "TH1 + TH2 <= -pi") (("1" (assert) (("1" (case-replace "TH1 + TH2 = -pi") (("1" (rewrite "sin_neg" 2) (("1" (rewrite "cos_neg" 2) (("1" (rewrite "sin_pi") (("1" (rewrite "cos_pi") (("1" (expand "atan2") (("1" (rewrite "atan_0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "sin_gt_0" ("a" "TH1+TH2+2*pi")) (("2" (assert) (("2" (lemma "sin_period" ("a" "TH1+TH2" "j" "1")) (("2" (lemma "cos_period" ("a" "TH1+TH2" "j" "1")) (("2" (assert) (("2" (lemma "atan2_cos_sin" ("a" "TH1 + TH2 + 2 * pi")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "trichotomy" ("x" "TH1+TH2")) (("2" (split -1) (("1" (lemma "sin_gt_0" ("a" "TH1+TH2")) (("1" (assert) (("1" (case-replace "TH1+TH2=pi") (("1" (rewrite "sin_pi") (("1" (rewrite "cos_pi") (("1" (expand "atan2") (("1" (rewrite "atan_0") nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "atan2_cos_sin") nil nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (rewrite "sin_0") (("2" (rewrite "cos_0") (("2" (expand "atan2") (("2" (rewrite "atan_0") nil nil)) nil)) nil)) nil)) nil) ("3" (lemma "sin_lt_0" ("a" "TH1+TH2+2*pi")) (("3" (assert) (("3" (lemma "sin_period" ("a" "TH1+TH2" "j" "1")) (("3" (lemma "cos_period" ("a" "TH1+TH2" "j" "1")) (("3" (assert) (("3" (lemma "atan2_cos_sin" ("a" "TH1 + TH2 + 2 * pi")) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "abs_nz_iff_nz" ("z" "X*Y")) (("2" (assert) nil nil)) nil)) nil) ("2" (lemma "abs_nz_iff_nz" ("z" "Y")) (("2" (assert) nil nil)) nil)) nil) ("2" (lemma "abs_nz_iff_nz" ("z" "X")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "abs_nz_iff_nz" ("z" "X*Y")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (replace -1 1 rl) (("2" (rewrite "abs_div") (("1" (rewrite "abs_abs") (("1" (rewrite "div_simp") nil nil)) nil) ("2" (rewrite "real_is_complex" 1) nil nil)) nil)) nil)) nil)) nil) ("2" (replace -6 1 rl) (("2" (hide-all-but 1) (("2" (rewrite "abs_div") (("1" (rewrite "abs_abs") (("1" (rewrite "div_simp") nil nil)) nil) ("2" (rewrite "real_is_complex" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "abs_nzcomplex" ("n0z" "n0y!1")) (("2" (lemma "real_is_complex" ("x" "abs(n0y!1)")) (("2" (lemma "nznum_div_nznum_is_nznum" ("nzx" "n0y!1" "nzy" "abs(n0y!1)")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "abs_nzcomplex" ("n0z" "n0x!1")) (("2" (lemma "nznum_div_nznum_is_nznum" ("nzx" "n0x!1" "nzy" "abs(n0x!1)")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzcomplex_times_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (div_simp formula-decl nil number_fields_bis nil) (Im_times formula-decl nil arithmetic nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (cos_neg formula-decl nil sincos_def trig_fnd) (cos_pi formula-decl nil sincos trig_fnd) (sin_pi formula-decl nil sincos trig_fnd) (sin_neg formula-decl nil sincos_def trig_fnd) (cos_period formula-decl nil sincos trig_fnd) (sin_period formula-decl nil sincos trig_fnd) (sin_gt_0 formula-decl nil trig_ineq trig_fnd) (cos_0 formula-decl nil sincos_def trig_fnd) (sin_0 formula-decl nil sincos_def trig_fnd) (cos_2pi formula-decl nil sincos trig_fnd) (atan_0 formula-decl nil atan trig_fnd) (atan2 const-decl "real" atan2 trig_fnd) (sin_2pi formula-decl nil sincos trig_fnd) (atan2_cos_sin formula-decl nil atan2 trig_fnd) (sin_lt_0 formula-decl nil trig_ineq trig_fnd) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (cos_plus formula-decl nil sincos trig_fnd) (sin_plus formula-decl nil sincos trig_fnd) (Re_is_real application-judgement "real" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (Re_times formula-decl nil arithmetic nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (cos const-decl "real" sincos_def trig_fnd) (div_times formula-decl nil number_fields_bis nil)) shostak)) (arg_inv 0 (arg_inv-2 "" 3790100332 ("" (skolem 1 ("a")) (("" (typepred "a") (("" (hide -1 -2) (("" (lemma "arg_mult" ("n0x" "a" "n0y" "1/a")) (("" (rewrite "times_div1" -1) (("" (rewrite "div_simp" -1) (("" (lemma "arg_is_0_nz" ("n0z" "1")) (("" (rewrite "Re_real") (("" (rewrite "Im_real") (("" (assert) (("" (replace -1) (("" (typepred "arg(a)") (("" (typepred "arg(1/a)") (("" (case-replace "arg(1 / a) + arg(a) > pi") (("1" (assert) nil nil) ("2" (case-replace "arg(1 / a) + arg(a) <= -pi") (("1" (assert) nil nil) ("2" (assert) (("2" (case-replace "arg(a)=0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzcomplex nonempty-type-eq-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (arg_mult formula-decl nil polar nil) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (div_simp formula-decl nil number_fields_bis nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Re_real formula-decl nil arithmetic nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (< const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (cos const-decl "real" sincos_def trig_fnd) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (arg const-decl "argrng" polar nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (Im_real formula-decl nil arithmetic nil) (arg_is_0_nz formula-decl nil polar nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (nzcomplex_times_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (times_div1 formula-decl nil number_fields_bis nil)) shostak) (arg_inv-1 nil 3295020761 ("" (skolem 1 ("a")) (("" (typepred "a") (("" (hide -1 -2) (("" (lemma "arg_mult" ("n0x" "a" "n0y" "1/a")) (("1" (rewrite "times_div1" -1) (("1" (rewrite "div_simp" -1) (("1" (lemma "arg_is_0_nz" ("n0z" "1")) (("1" (rewrite "Re_real") (("1" (rewrite "Im_real") (("1" (assert) (("1" (replace -1) (("1" (typepred "arg(a)") (("1" (typepred "arg(1/a)") (("1" (case-replace "arg(1 / a) + arg(a) > pi") (("1" (assert) nil nil) ("2" (case-replace "arg(1 / a) + arg(a) <= -pi") (("1" (assert) nil nil) ("2" (assert) (("2" (case-replace "arg(a)=0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "inv_ne_0" ("n0x" "a")) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((nzcomplex nonempty-type-eq-decl nil complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (div_simp formula-decl nil number_fields_bis nil) (Re_real formula-decl nil arithmetic nil) (cos const-decl "real" sincos_def trig_fnd) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (Im_real formula-decl nil arithmetic nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (nzcomplex_times_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (times_div1 formula-decl nil number_fields_bis nil)) shostak)) (arg_div 0 (arg_div-2 "" 3790100333 ("" (skolem 1 ("a" "b")) (("" (rewrite "div_def") (("" (lemma "arg_mult" ("n0x" "a" "n0y" "1/b")) (("" (lemma "arg_inv" ("n0z" "b")) (("" (typepred "arg(a)") (("" (case-replace "arg(b)=0") (("1" (assert) nil nil) ("2" (replace 1) (("2" (case-replace "arg(b)=pi") (("1" (assert) (("1" (replace -4) (("1" (case-replace "arg(a) > 0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -3) (("2" (case-replace "arg(a) - arg(b) > pi") (("1" (assert) nil nil) ("2" (case-replace "arg(a) - arg(b) <= -pi") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((div_def formula-decl nil number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (nzcomplex_times_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (arg_inv formula-decl nil polar nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_real_is_real application-judgement "real" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (cos const-decl "real" sincos_def trig_fnd) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (arg const-decl "argrng" polar nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (arg_mult formula-decl nil polar nil)) shostak) (arg_div-1 nil 3295021146 ("" (skolem 1 ("a" "b")) (("" (rewrite "div_def") (("" (lemma "arg_mult" ("n0x" "a" "n0y" "1/b")) (("1" (lemma "arg_inv" ("n0z" "b")) (("1" (typepred "arg(a)") (("1" (case-replace "arg(b)=0") (("1" (assert) nil nil) ("2" (replace 1) (("2" (case-replace "arg(b)=pi") (("1" (assert) (("1" (replace -4) (("1" (case-replace "arg(a) > 0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -3) (("2" (case-replace "arg(a) - arg(b) > pi") (("1" (assert) nil nil) ("2" (case-replace "arg(a) - arg(b) <= -pi") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "real_is_complex" ("x" "1")) (("2" (lemma "closed_divides" ("z" "1" "n0z" "b")) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (nzcomplex_times_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (cos const-decl "real" sincos_def trig_fnd) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd)) shostak)) (arg_from_polar 0 (arg_from_polar-1 nil 3596190942 ("" (skeep) (("" (expand "from_polar") (("" (case "NOT (Re(sin(theta) * i * r + r * cos(theta)) = r*cos(theta) AND Im(sin(theta) * i * r + r * cos(theta)) = r*sin(theta))") (("1" (hide 2) (("1" (split) (("1" (rewrite "Re_plus") (("1" (lemma "Re_imag") (("1" (inst - "sin(theta)*r") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (hide -1) (("1" (rewrite "Re_real") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "Im_plus") (("2" (assert) (("2" (lemma "Im_real") (("2" (inst - "r*cos(theta)") (("2" (replaces -1) (("2" (assert) (("2" (lemma "Im_imag") (("2" (inst - "sin(theta)*r") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "arg") (("2" (replace -1) (("2" (replace -2) (("2" (lift-if) (("2" (ground) (("1" (rewrite "complex_is_0_Re_Im" -1) (("1" (flatten) (("1" (replace -3) (("1" (replace -4) (("1" (assert) (("1" (lemma "sin_eq_0") (("1" (inst - "theta") (("1" (ground) (("1" (skosimp*) (("1" (case "i!1 >=2") (("1" (mult-by -1 "pi") (("1" (assert) nil nil)) nil) ("2" (case "i!1 <= -1") (("1" (mult-by -1 "pi") (("1" (assert) nil nil)) nil) ("2" (case "i!1 = 1") (("1" (replaces -1) (("1" (assert) (("1" (replace -2) (("1" (lemma "cos_pi") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i!1 = 0") (("1" (replaces -1) (("1" (replaces -2) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (mult-by 2 "r") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "atan2") (("2" (lift-if) (("2" (ground) (("1" (lemma "atan_tan") (("1" (inst - "theta") (("1" (expand "tan") (("1" (assert) (("1" (case "r*sin(theta)/(r*cos(theta)) = atan(theta)") (("1" (assert) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide (2 3)) (("2" (case "NOT (cos(theta)>0 AND sin(theta)<0)") (("1" (split) (("1" (mult-by 1 "r") (("1" (assert) nil nil)) nil) ("2" (mult-by 1 "r") (("2" (assert) nil nil)) nil)) nil) ("2" (hide (-2 -3)) (("2" (flatten) (("2" (lemma "cos_le_0") (("2" (inst - "theta") (("2" (lemma "sin_ge_0") (("2" (inst - "theta") (("2" (assert) (("2" (lemma "cos_neg") (("2" (inst - "theta") (("2" (ground) (("2" (lemma "cos_le_0") (("2" (inst - "-theta") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "cos_eq_0") (("2" (inst - "theta") (("2" (assert) (("2" (ground) (("1" (skosimp*) (("1" (lemma "sin_ge_0") (("1" (inst - "theta") (("1" (assert) (("1" (split -) (("1" (mult-by -1 "r") (("1" (assert) nil nil)) nil) ("2" (case "NOT sin(theta)<0") (("1" (mult-by 1 "r") (("1" (assert) nil nil)) nil) ("2" (case "i!1>=0") (("1" (mult-by -1 "pi") (("1" (assert) nil nil)) nil) ("2" (case "i!1 <= -2") (("1" (mult-by -1 "pi") (("1" (assert) nil nil)) nil) ("2" (case "i!1 = -1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (mult-by 2 "r") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "NOT (cos(theta) < 0 AND sin(theta) < 0)") (("1" (split) (("1" (mult-by 1 "r") (("1" (assert) nil nil)) nil) ("2" (mult-by 1 "r") (("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (hide (-3 1 3)) (("2" (lemma "atan_tan") (("2" (inst - "theta+pi") (("1" (case "tan(theta+pi) = tan(theta)") (("1" (replaces -1) (("1" (expand "tan") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "tan" 1) (("2" (rewrite "sin_plus" 1) (("2" (rewrite "cos_plus" 1) (("2" (rewrite "cos_pi") (("2" (rewrite "sin_pi") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "Tan?") (("3" (assert) nil nil)) nil)) nil) ("2" (lemma "cos_ge_0") (("2" (inst - "theta") (("2" (assert) (("2" (lemma "sin_ge_0") (("2" (inst - "theta") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "NOT sin(theta)>=0") (("1" (mult-by 1 "r") (("1" (assert) nil nil)) nil) ("2" (hide 1) (("2" (case "theta < 0") (("1" (lemma "sin_lt_0") (("1" (inst - "theta + 2*pi") (("1" (assert) (("1" (rewrite "sin_plus") (("1" (rewrite "cos_2pi") (("1" (rewrite "sin_2pi") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "NOT theta>=0") (("1" (assert) nil nil) ("2" (hide 1) (("2" (expand "atan2") (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (case "NOT cos(theta)>0") (("1" (mult-by 1 "r") (("1" (assert) nil nil)) nil) ("2" (hide -2) (("2" (lemma "atan_tan") (("2" (inst - "theta") (("1" (expand "tan") (("1" (assert) (("1" (replaces -1) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "cos_le_0") (("2" (inst - "theta") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "cos_eq_0") (("2" (inst - "theta") (("2" (ground) (("1" (skosimp*) (("1" (case "i!1 = 0") (("1" (assert) nil nil) ("2" (case "i!1>=1") (("1" (mult-by -1 "pi") (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (case "i!1<=-1") (("1" (mult-by -1 "pi") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (mult-by 2 "r") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (lemma "cos_eq_0") (("3" (inst?) (("3" (assert) (("3" (ground) (("1" (skosimp*) (("1" (case "i!1 = 0") (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (replaces -2) (("1" (rewrite "sin_pi2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i!1>=1") (("1" (mult-by -1 "pi") (("1" (assert) nil nil)) nil) ("2" (case "i!1<=-1") (("1" (mult-by -1 "pi") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (mult-by 2 "r") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (case "NOT cos(theta)<0") (("1" (mult-by 1 "r") (("1" (assert) nil nil)) nil) ("2" (hide (1 3)) (("2" (case "NOT theta > pi/2") (("1" (lemma "cos_ge_0") (("1" (inst - "theta") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "atan_tan") (("2" (inst - "theta-pi") (("2" (expand "tan" -1) (("2" (rewrite "sin_minus") (("2" (rewrite "cos_minus") (("2" (rewrite "sin_pi") (("2" (rewrite "cos_pi") (("2" (assert) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sin_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (from_polar const-decl "complex" polar nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (sin_2pi formula-decl nil sincos trig_fnd) (cos_2pi formula-decl nil sincos trig_fnd) (sin_lt_0 formula-decl nil trig_ineq trig_fnd) (cos_minus formula-decl nil sincos trig_fnd) (sin_minus formula-decl nil sincos trig_fnd) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (sin_pi2 formula-decl nil sincos trig_fnd) (atan2 const-decl "real" atan2 trig_fnd) (real_div_nzreal_is_real application-judgement "real" reals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (theta skolem-const-decl "argrng" polar nil) (real_abs_lt_pi2 nonempty-type-eq-decl nil trig_types trig_fnd) (atan const-decl "{x: real_abs_lt_pi2 | y = tan_restrict(x)}" atan trig_fnd) (tan_restrict const-decl "real" trig_basic trig_fnd) (tan const-decl "real" trig_basic trig_fnd) (cos_le_0 formula-decl nil trig_ineq trig_fnd) (sin_ge_0 formula-decl nil trig_ineq trig_fnd) (minus_real_is_real application-judgement "real" reals nil) (cos_neg formula-decl nil sincos_def trig_fnd) (atan_tan formula-decl nil trig_inverses trig_fnd) (cos_eq_0 formula-decl nil sincos trig_fnd) (cos_ge_0 formula-decl nil trig_ineq trig_fnd) (Tan? const-decl "bool" trig_basic trig_fnd) (sin_plus formula-decl nil sincos trig_fnd) (sin_pi formula-decl nil sincos trig_fnd) (cos_plus formula-decl nil sincos trig_fnd) (complex_is_0_Re_Im formula-decl nil arithmetic nil) (both_sides_times1 formula-decl nil number_fields_bis nil) (nil application-judgement "above(n)" exp2 nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (cos_pi formula-decl nil sincos trig_fnd) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (sin_eq_0 formula-decl nil sincos trig_fnd) (real_minus_real_is_real application-judgement "real" reals nil) (arg const-decl "argrng" polar nil) (Im_plus formula-decl nil arithmetic nil) (Im_real formula-decl nil arithmetic nil) (TRUE const-decl "bool" booleans nil) (Im_imag formula-decl nil arithmetic nil) (Re_plus formula-decl nil arithmetic nil) (real_plus_real_is_real application-judgement "real" reals nil) (Re_real formula-decl nil arithmetic nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Re_imag formula-decl nil arithmetic nil) (Re_is_real application-judgement "real" complex_types nil) (real_times_real_is_real application-judgement "real" reals nil) (Im_is_real application-judgement "real" complex_types nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (complex nonempty-type-from-decl nil complex_types nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (sin const-decl "real" sincos_def trig_fnd) (< const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (cos const-decl "real" sincos_def trig_fnd) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd)) shostak)) (idempotent_rectangular 0 (idempotent_rectangular-1 nil 3294313266 ("" (skosimp) (("" (expand "rectangular") (("" (expand "from_rectangular") (("" (lemma "complex_is_Re_Im" ("z" "z!1")) (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((complex_times_complex_is_complex application-judgement "complex" complex_types nil) (rectangular const-decl "[real, real]" polar nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (complex_is_Re_Im formula-decl nil arithmetic nil) (from_rectangular const-decl "complex" polar nil) (Im_is_real application-judgement "real" complex_types nil)) shostak)) (idempotent_polar 0 (idempotent_polar-3 "" 3884620822 ("" (expand "polar") (("" (expand "from_polar") (("" (skosimp) (("" (lemma "complex_is_ne_0_Re_Im" ("z" "n0z!1")) (("" (assert) (("" (lemma "unique_characterization" ("x0" "Re(n0z!1)" "y0" "Im(n0z!1)" "y1" "abs(n0z!1) * sin(arg(n0z!1))" "x1" "abs(n0z!1) * cos(arg(n0z!1))")) (("" (lemma "complex_is_Re_Im" ("z" "n0z!1")) (("" (replace -1 -2 rl) (("" (replace -2 1) (("" (hide -2) (("" (expand "arg") (("" (case-replace "IF Im(n0z!1) < 0 THEN cos(atan2(Re(n0z!1), Im(n0z!1)) - 2 * pi)
          ELSE cos(atan2(Re(n0z!1), Im(n0z!1)))
          ENDIF = cos(atan2(Re(n0z!1), Im(n0z!1)))") (("1" (case-replace "IF Im(n0z!1) < 0 THEN sin(atan2(Re(n0z!1), Im(n0z!1)) - 2 * pi)
            ELSE sin(atan2(Re(n0z!1), Im(n0z!1)))
            ENDIF = sin(atan2(Re(n0z!1), Im(n0z!1)))") (("1" (hide -1 -2) (("1" (lemma "sin_atan2" ("x" "Re(n0z!1)" "y" "Im(n0z!1)")) (("1" (lemma "cos_atan2" ("x" "Re(n0z!1)" "y" "Im(n0z!1)")) (("1" (replace -4) (("1" (case-replace "Re(n0z!1)=0") (("1" (replace -2) (("1" (assert) (("1" (expand "atan2") (("1" (rewrite "sin_pi2") (("1" (rewrite "sin_3pi2") (("1" (expand "abs") (("1" (expand "conjugate") (("1" (rewrite -1) (("1" (assert) (("1" (name-replace "DRL1" "Im(n0z!1)") (("1" (replace -2 1) (("1" (assert) (("1" (rewrite "sq.sq_rew") (("1" (rewrite "associative_mult" 1) (("1" (rewrite "associative_mult" 1) (("1" (rewrite "associative_mult" 1) (("1" (rewrite "associative_mult" 1 :dir rl) (("1" (rewrite "i_axiom") (("1" (rewrite "commutative_mult" 1) (("1" (rewrite "associative_mult" 1) (("1" (case-replace "DRL1>0") (("1" (rewrite "number_fields_right_identity_mult") (("1" (rewrite "number_fields_left_identity_mult") (("1" (rewrite "sqrt.sqrt_sq") nil nil)) nil)) nil) ("2" (lemma "sq.sq_neg") (("2" (inst - "DRL1") (("2" (replace -1 2 rl) (("2" (rewrite "sqrt.sqrt_sq") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (name "DRL1" "Im(n0z!1) / Re(n0z!1)") (("2" (replace -1) (("2" (assert) (("2" (name "X" "Re(n0z!1)") (("2" (replace -1) (("2" (name "Y" "Im(n0z!1)") (("2" (replace -1) (("2" (case-replace "abs(n0z!1) = sqrt(sq.sq(X)+sq.sq(Y))") (("1" (case-replace "sqrt(1 + sq.sq(DRL1)) = sqrt(sq.sq(X) + sq.sq(Y))/IF X>0 THEN X ELSE -X ENDIF") (("1" (case-replace "X>0") (("1" (rewrite "div_div1") (("1" (rewrite "div_div1") (("1" (replace -7) (("1" (replace -8) (("1" (name-replace "DRL3" "sqrt(sq.sq(X) + sq.sq(Y))") (("1" (lemma "div_cancel1" ("n0z" "DRL3" "x" "1*X")) (("1" (lemma "div_cancel1" ("n0z" "DRL3" "x" "DRL1*X")) (("1" (replace -2) (("1" (replace -1) (("1" (replace -8 2 rl) (("1" (rewrite "div_cancel2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) (("2" (hide -5 -6 3) (("2" (replace -4 1 rl) (("2" (rewrite "sq.sq_div") (("2" (case-replace "X>0") (("1" (lemma "sqrt.sqrt_sq") (("1" (inst - "X") (("1" (split -1) (("1" (lemma "sqrt.sqrt_div") (("1" (inst - "sq.sq(X) + sq.sq(Y)" "sq.sq(X)") (("1" (split -1) (("1" (assert) nil nil) ("2" (expand "sq") (("2" (lemma "posreal_times_posreal_is_posreal" ("px" "X" "py" "X")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "sq.sq_neg") (("2" (inst - "X") (("2" (lemma "sqrt.sqrt_sq" ("x" "-X")) (("2" (split -1) (("1" (lemma "sqrt.sqrt_div") (("1" (inst - "sq.sq(X)+sq.sq(Y)" "sq.sq(-X)") (("1" (split -1) (("1" (assert) (("1" (assert) nil nil)) nil) ("2" (expand "sq") (("2" (assert) (("2" (lemma "posreal_times_posreal_is_posreal" ("px" "-X" "py" "-X")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (hide -4 -5 3) (("2" (expand "abs") (("2" (expand "conjugate") (("2" (replace -1) (("2" (replace -2) (("2" (replace -4 1) (("2" (assert) (("2" (rewrite "sq.sq_rew") (("2" (rewrite "sq.sq_rew") (("2" (rewrite "associative_mult" 1 :dir rl) (("2" (lemma "i_axiom") (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -3)) (("2" (case-replace "Im(n0z!1) < 0") (("1" (lemma "sin_minus" ("a" "atan2(Re(n0z!1), Im(n0z!1))" "b" "2 * pi")) (("1" (rewrite "sin_2pi") (("1" (rewrite "cos_2pi") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case-replace "Im(n0z!1) < 0") (("1" (lemma "cos_minus" ("a" "atan2(Re(n0z!1), Im(n0z!1))" "b" "2 * pi")) (("1" (rewrite "sin_2pi") (("1" (rewrite "cos_2pi") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (split -2) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("4" (split -2) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("5" (flatten) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (idempotent_polar-2 nil 3307887703 ("" (expand "polar") (("" (expand "from_polar") (("" (skosimp) (("" (lemma "complex_is_ne_0_Re_Im" ("z" "n0z!1")) (("" (assert) (("" (lemma "unique_characterization" ("x0" "Re(n0z!1)" "y0" "Im(n0z!1)" "y1" "abs(n0z!1) * sin(arg(n0z!1))" "x1" "abs(n0z!1) * cos(arg(n0z!1))")) (("" (lemma "complex_is_Re_Im" ("z" "n0z!1")) (("" (replace -1 -2 rl) (("" (replace -2 1) (("" (hide -2) (("" (expand "arg") (("" (case-replace "IF Im(n0z!1) < 0 THEN cos(atan2(Re(n0z!1), Im(n0z!1)) - 2 * pi)
          ELSE cos(atan2(Re(n0z!1), Im(n0z!1)))
          ENDIF = cos(atan2(Re(n0z!1), Im(n0z!1)))") (("1" (case-replace "IF Im(n0z!1) < 0 THEN sin(atan2(Re(n0z!1), Im(n0z!1)) - 2 * pi)
            ELSE sin(atan2(Re(n0z!1), Im(n0z!1)))
            ENDIF = sin(atan2(Re(n0z!1), Im(n0z!1)))") (("1" (hide -1 -2) (("1" (lemma "sin_atan2" ("x" "Re(n0z!1)" "y" "Im(n0z!1)")) (("1" (lemma "cos_atan2" ("x" "Re(n0z!1)" "y" "Im(n0z!1)")) (("1" (replace -4) (("1" (case-replace "Re(n0z!1)=0") (("1" (replace -2) (("1" (assert) (("1" (expand "atan2") (("1" (rewrite "sin_pi2") (("1" (rewrite "sin_3pi2") (("1" (expand "abs") (("1" (expand "conjugate") (("1" (rewrite -1) (("1" (assert) (("1" (name-replace "DRL1" "Im(n0z!1)") (("1" (replace -2 1) (("1" (assert) (("1" (rewrite "sq.sq_rew") (("1" (rewrite "associative_mult" 1) (("1" (rewrite "associative_mult" 1) (("1" (rewrite "associative_mult" 1) (("1" (rewrite "associative_mult" 1 :dir rl) (("1" (rewrite "i_axiom") (("1" (rewrite "commutative_mult" 1) (("1" (rewrite "associative_mult" 1) (("1" (case-replace "DRL1>0") (("1" (rewrite "sqrt.sqrt_sq") nil nil) ("2" (lemma "sq.sq_neg") (("2" (inst - "DRL1") (("2" (replace -1 2 rl) (("2" (rewrite "sqrt.sqrt_sq") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (name "DRL1" "Im(n0z!1) / Re(n0z!1)") (("2" (replace -1) (("2" (assert) (("2" (name "X" "Re(n0z!1)") (("2" (replace -1) (("2" (name "Y" "Im(n0z!1)") (("2" (replace -1) (("2" (case-replace "abs(n0z!1) = sqrt(sq.sq(X)+sq.sq(Y))") (("1" (case-replace "sqrt(1 + sq.sq(DRL1)) = sqrt(sq.sq(X) + sq.sq(Y))/IF X>0 THEN X ELSE -X ENDIF") (("1" (case-replace "X>0") (("1" (rewrite "div_div1") (("1" (rewrite "div_div1") (("1" (replace -7) (("1" (replace -8) (("1" (name-replace "DRL3" "sqrt(sq.sq(X) + sq.sq(Y))") (("1" (lemma "div_cancel1" ("n0z" "DRL3" "x" "1*X")) (("1" (lemma "div_cancel1" ("n0z" "DRL3" "x" "DRL1*X")) (("1" (replace -2) (("1" (replace -1) (("1" (replace -8 2 rl) (("1" (rewrite "div_cancel2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) (("2" (hide -5 -6 3) (("2" (replace -4 1 rl) (("2" (rewrite "sq.sq_div") (("2" (case-replace "X>0") (("1" (lemma "sqrt.sqrt_sq") (("1" (inst - "X") (("1" (split -1) (("1" (lemma "sqrt.sqrt_div") (("1" (inst - "sq.sq(X) + sq.sq(Y)" "sq.sq(X)") (("1" (split -1) (("1" (assert) nil nil) ("2" (expand "sq") (("2" (lemma "posreal_times_posreal_is_posreal" ("px" "X" "py" "X")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "sq.sq_neg") (("2" (inst - "X") (("2" (lemma "sqrt.sqrt_sq" ("x" "-X")) (("2" (split -1) (("1" (lemma "sqrt.sqrt_div") (("1" (inst - "sq.sq(X)+sq.sq(Y)" "sq.sq(-X)") (("1" (split -1) (("1" (assert) (("1" (assert) nil nil)) nil) ("2" (expand "sq") (("2" (assert) (("2" (lemma "posreal_times_posreal_is_posreal" ("px" "-X" "py" "-X")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (hide -4 -5 3) (("2" (expand "abs") (("2" (expand "conjugate") (("2" (replace -1) (("2" (replace -2) (("2" (replace -4 1) (("2" (assert) (("2" (rewrite "sq.sq_rew") (("2" (rewrite "sq.sq_rew") (("2" (rewrite "associative_mult" 1 :dir rl) (("2" (lemma "i_axiom") (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -3)) (("2" (case-replace "Im(n0z!1) < 0") (("1" (lemma "sin_minus" ("a" "atan2(Re(n0z!1), Im(n0z!1))" "b" "2 * pi")) (("1" (rewrite "sin_2pi") (("1" (rewrite "cos_2pi") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case-replace "Im(n0z!1) < 0") (("1" (lemma "cos_minus" ("a" "atan2(Re(n0z!1), Im(n0z!1))" "b" "2 * pi")) (("1" (rewrite "sin_2pi") (("1" (rewrite "cos_2pi") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (split -2) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("4" (split -2) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("5" (flatten) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sin_range application-judgement "real_abs_le1" sincos trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (from_polar const-decl "complex" polar nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (sin const-decl "real" sincos_def trig_fnd) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (arg const-decl "argrng" polar nil) (argrng nonempty-type-eq-decl nil polar nil) (<= const-decl "bool" reals nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (cos const-decl "real" sincos_def trig_fnd) (abs const-decl "nnreal" polar nil) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (unique_characterization formula-decl nil complex_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (atan2 const-decl "real" atan2 trig_fnd) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (real_abs_le1 nonempty-type-eq-decl nil trig_types trig_fnd) (real_minus_real_is_real application-judgement "real" reals nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (sin_minus formula-decl nil sincos trig_fnd) (cos_2pi formula-decl nil sincos trig_fnd) (sin_2pi formula-decl nil sincos trig_fnd) (cos_atan2 formula-decl nil atan2 trig_fnd) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sin_pi2 formula-decl nil sincos trig_fnd) (sq const-decl "nonneg_real" sq reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (associative_mult formula-decl nil number_fields nil) (i_axiom formula-decl nil complex_types nil) (negint_times_negint_is_posint application-judgement "posint" integers nil) (odd_times_odd_is_odd application-judgement "odd_int" integers nil) (sq_neg formula-decl nil sq reals) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (minus_real_is_real application-judgement "real" reals nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (number_fields_right_identity_mult formula-decl nil number_fields_bis nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sqrt_sq formula-decl nil sqrt reals) (number_fields_left_identity_mult formula-decl nil number_fields_bis nil) (commutative_mult formula-decl nil number_fields nil) (sq_rew formula-decl nil sq reals) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (nil application-judgement "above(n)" exp2 nil) (sin_3pi2 formula-decl nil sincos trig_fnd) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (posreal_plus_nnreal_is_posreal application-judgement "posreal" real_types nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (div_div1 formula-decl nil number_fields_bis nil) (div_cancel2 formula-decl nil number_fields_bis nil) (div_cancel1 formula-decl nil number_fields_bis nil) (sq_div formula-decl nil sq reals) (sqrt_square formula-decl nil sqrt reals) (posreal nonempty-type-eq-decl nil real_types nil) (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (sqrt_div formula-decl nil sqrt reals) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sqrt_pos application-judgement "posreal" sqrt reals) (sin_atan2 formula-decl nil atan2 trig_fnd) (cos_minus formula-decl nil sincos trig_fnd) (complex_is_Re_Im formula-decl nil arithmetic nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Re_is_real application-judgement "real" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (polar const-decl "[nnreal, argrng]" polar nil)) nil) (idempotent_polar-1 nil 3294313327 ("" (expand "polar") (("" (expand "from_polar") (("" (skosimp) (("" (lemma "complex_is_ne_0_Re_Im" ("z" "n0z!1")) (("" (assert) (("" (lemma "unique_characterization" ("x0" "Re(n0z!1)" "y0" "Im(n0z!1)" "y1" "abs(n0z!1) * sin(arg(n0z!1))" "x1" "abs(n0z!1) * cos(arg(n0z!1))")) (("" (lemma "complex_is_Re_Im" ("z" "n0z!1")) (("" (replace -1 -2 rl) (("" (replace -2 1) (("" (hide -2) (("" (expand "arg") (("" (case-replace "IF Im(n0z!1) < 0 THEN cos(atan2(Re(n0z!1), Im(n0z!1)) - 2 * pi)
        ELSE cos(atan2(Re(n0z!1), Im(n0z!1)))
        ENDIF = cos(atan2(Re(n0z!1), Im(n0z!1)))") (("1" (case-replace "IF Im(n0z!1) < 0 THEN sin(atan2(Re(n0z!1), Im(n0z!1)) - 2 * pi)
        ELSE sin(atan2(Re(n0z!1), Im(n0z!1)))
        ENDIF = sin(atan2(Re(n0z!1), Im(n0z!1)))") (("1" (hide -1 -2) (("1" (lemma "sin_atan2" ("x" "Re(n0z!1)" "y" "Im(n0z!1)")) (("1" (lemma "cos_atan2" ("x" "Re(n0z!1)" "y" "Im(n0z!1)")) (("1" (replace -4) (("1" (case-replace "Re(n0z!1)=0") (("1" (replace -2) (("1" (assert) (("1" (expand "atan2") (("1" (rewrite "sin_pi2") (("1" (rewrite "sin_3pi2") (("1" (expand "abs") (("1" (expand "conjugate") (("1" (rewrite -1) (("1" (assert) (("1" (name-replace "DRL1" "Im(n0z!1)") (("1" (replace -2 1) (("1" (assert) (("1" (rewrite "sq_rew") (("1" (rewrite "associative_mult" 1) (("1" (rewrite "associative_mult" 1) (("1" (rewrite "associative_mult" 1) (("1" (rewrite "associative_mult" 1 :dir rl) (("1" (rewrite "i_axiom") (("1" (rewrite "commutative_mult" 1) (("1" (rewrite "associative_mult" 1) (("1" (case-replace "DRL1>0") (("1" (rewrite "sqrt_sq") nil nil) ("2" (lemma "sq_neg") (("2" (inst - "DRL1") (("2" (replace -1 2 rl) (("2" (rewrite "sqrt_sq") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (name "DRL1" "Im(n0z!1) / Re(n0z!1)") (("1" (replace -1) (("1" (assert) (("1" (name "X" "Re(n0z!1)") (("1" (replace -1) (("1" (name "Y" "Im(n0z!1)") (("1" (replace -1) (("1" (case-replace "abs(n0z!1) = sqrt(sq(X)+sq(Y))") (("1" (case-replace "sqrt(1 + sq(DRL1)) = sqrt(sq(X) + sq(Y))/IF X>0 THEN X ELSE -X ENDIF") (("1" (case-replace "X>0") (("1" (rewrite "div_div1") (("1" (rewrite "div_div1") (("1" (replace -7) (("1" (replace -8) (("1" (name-replace "DRL3" "sqrt(sq(X) + sq(Y))") (("1" (lemma "div_cancel1" ("n0z" "DRL3" "x" "1*X")) (("1" (lemma "div_cancel1" ("n0z" "DRL3" "x" "DRL1*X")) (("1" (replace -2) (("1" (replace -1) (("1" (replace -8 2 rl) (("1" (rewrite "div_cancel2") nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "abs_nz_iff_nz" ("z" "n0z!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide -5 -6 3) (("2" (replace -4 1 rl) (("2" (rewrite "sq_div") (("2" (case-replace "X>0") (("1" (lemma "sqrt_sq") (("1" (inst - "X") (("1" (split -1) (("1" (lemma "sqrt_div") (("1" (inst - "sq(X) + sq(Y)" "sq(X)") (("1" (split -1) (("1" (assert) nil nil) ("2" (expand "sq") (("2" (lemma "posreal_times_posreal_is_posreal" ("px" "X" "py" "X")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "sq_neg") (("2" (inst - "X") (("2" (lemma "sqrt_sq" ("x" "-X")) (("2" (split -1) (("1" (lemma "sqrt_div") (("1" (inst - "sq(X)+sq(Y)" "sq(-X)") (("1" (split -1) (("1" (assert) nil nil) ("2" (expand "sq") (("2" (lemma "posreal_times_posreal_is_posreal" ("px" "-X" "py" "-X")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (flatten) nil nil)) nil) ("2" (hide -4 -5 3) (("2" (expand "abs") (("2" (expand "conjugate") (("2" (replace -1) (("2" (replace -2) (("2" (replace -4 1) (("2" (assert) (("2" (rewrite "sq_rew") (("2" (rewrite "sq_rew") (("2" (rewrite "associative_mult" 1 :dir rl) (("2" (lemma "i_axiom") (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -3)) (("2" (case-replace "Im(n0z!1) < 0") (("1" (lemma "sin_minus" ("a" "atan2(Re(n0z!1), Im(n0z!1))" "b" "2 * pi")) (("1" (rewrite "sin_2pi") (("1" (rewrite "cos_2pi") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (split -3) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("4" (split -3) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("5" (flatten 1) (("5" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (case-replace "Im(n0z!1) < 0") (("1" (lemma "cos_minus" ("a" "atan2(Re(n0z!1), Im(n0z!1))" "b" "2 * pi")) (("1" (rewrite "sin_2pi") (("1" (rewrite "cos_2pi") (("1" (assert) nil nil)) nil)) nil) ("2" (split -3) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (split -2) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("4" (split -2) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("5" (flatten) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzcomplex nonempty-type-eq-decl nil complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (unique_characterization formula-decl nil complex_types nil) (atan2 const-decl "real" atan2 trig_fnd) (cos_atan2 formula-decl nil atan2 trig_fnd) (sq const-decl "nonneg_real" sq reals) (i_axiom formula-decl nil complex_types nil) (sq_neg formula-decl nil sq reals) (sqrt_sq formula-decl nil sqrt reals) (sq_rew formula-decl nil sq reals) (conjugate const-decl "complex" arithmetic nil) (div_div1 formula-decl nil number_fields_bis nil) (div_cancel2 formula-decl nil number_fields_bis nil) (div_cancel1 formula-decl nil number_fields_bis nil) (sqrt_div formula-decl nil sqrt reals) (sq_div formula-decl nil sq reals) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (sin_atan2 formula-decl nil atan2 trig_fnd) (complex_is_Re_Im formula-decl nil arithmetic nil)) shostak)))
