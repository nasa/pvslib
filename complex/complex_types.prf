(complex_types (real_complex 0 (real_complex-1 nil 3280216396 ("" (skosimp*) (("" (typepred "x!1") (("" (lemma "complex_characterization" ("nf" "x!1")) (("" (replace -1 1) (("" (inst + "x!1" "0") (("" (rewrite "zero_times1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (i const-decl "complex" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (complex_characterization formula-decl nil complex_types nil) (numfield nonempty-type-eq-decl nil number_fields nil)) shostak)) (i_not_real 0 (i_not_real-1 nil 3280216458 ("" (skosimp) (("" (case "FORALL (x:real): x*x >= 0") (("1" (inst - "r!1") (("1" (lemma "i_axiom") (("1" (replace -3) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (skosimp) (("2" (lemma "trichotomy" ("x" "x!1")) (("2" (split) (("1" (lemma "posreal_times_posreal_is_posreal" ("px" "x!1" "py" "x!1")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (lemma "negreal_times_negreal_is_posreal" ("nx" "x!1" "ny" "x!1")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (i_axiom formula-decl nil complex_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (negreal nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (negreal_times_negreal_is_posreal judgement-tcc nil real_types nil) (trichotomy formula-decl nil real_axioms nil)) shostak)) (unique_characterization 0 (unique_characterization-1 nil 3280217956 ("" (skosimp*) (("" (split) (("1" (flatten) (("1" (lemma "both_sides_minus1" ("x" "x0!1 + y0!1 * i" "y" "x1!1 + y1!1 * i" "z" "x1!1+y0!1*i")) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (case-replace "x0!1 + y0!1 * i - (x1!1 + y0!1 * i) = x0!1-x1!1") (("1" (case-replace "x1!1 + y1!1 * i - (x1!1 + y0!1 * i) = (y1!1-y0!1)*i") (("1" (hide -1 -2) (("1" (case "FORALL (x, y: nzreal): x /= y * i") (("1" (case-replace "y0!1 =y1!1") (("1" (rewrite "zero_times1" -3) (("1" (assert) nil nil)) nil) ("2" (lemma "div_cancel3" ("x" "x0!1-x1!1" "y" "i" "n0z" "y1!1-y0!1")) (("1" (rewrite "commutative_mult" -3) (("1" (lemma "i_not_real" ("r" "(x0!1 - x1!1) / (y1!1 - y0!1)")) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (lemma "div_cancel3" ("x" "x!1" "y" "i" "n0z" "y!1")) (("2" (rewrite "commutative_mult" -2) (("2" (replace -2 -1 rl) (("2" (lemma "i_not_real" ("r" "x!1/y!1")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) (("2" (rewrite "commutative_mult") (("2" (assert) (("2" (rewrite "commutative_mult") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((i const-decl "complex" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (both_sides_minus1 formula-decl nil number_fields_bis nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (div_cancel3 formula-decl nil number_fields_bis nil) (nznum nonempty-type-eq-decl nil number_fields nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (i_not_real formula-decl nil complex_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (commutative_mult formula-decl nil number_fields nil) (zero_times1 formula-decl nil number_fields_bis nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_minus_real_is_real application-judgement "real" reals nil)) shostak)) (real_is_complex 0 (real_is_complex-1 nil 3280044189 ("" (skosimp*) (("" (lemma "real_complex" ("x" "x!1")) (("" (propax) nil nil)) nil)) nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_complex formula-decl nil complex_types nil)) shostak (real_is_complex subtype "complex_types.x" "complex"))) (Re_TCC1 0 (Re_TCC1-1 nil 3280223572 ("" (inst + "lambda z: choose({x | EXISTS (y:real): z = x + y*i})") (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (skosimp*) (("" (typepred "z!1") (("" (lemma "complex_characterization" ("nf" "z!1")) (("" (assert) (("" (skosimp*) (("" (inst - "x!1") (("" (inst + "y!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (complex_characterization formula-decl nil complex_types nil) (empty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (complex nonempty-type-from-decl nil complex_types nil)) shostak (Re existence "" "[z: complex -> {x | EXISTS y: z = (number_fields.+)(complex_types.x, number_fields.*(complex_types.y, complex_types.i))}]"))) (Im_TCC1 0 (Im_TCC1-1 nil 3280223572 ("" (inst + "lambda z: choose({y | EXISTS (x:real): z = x + y*i})") (("" (expand "nonempty?") (("" (expand "empty?") (("" (expand "member") (("" (skosimp*) (("" (typepred "z!1") (("" (lemma "complex_characterization" ("nf" "z!1")) (("" (assert) (("" (skosimp*) (("" (inst - "y!1") (("" (inst + "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member const-decl "bool" sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (complex_characterization formula-decl nil complex_types nil) (empty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (complex nonempty-type-from-decl nil complex_types nil)) shostak (Im existence "" "[z: complex -> {y | EXISTS x: z = (number_fields.+)(complex_types.x, number_fields.*(complex_types.y, complex_types.i))}]"))) (Re_def 0 (Re_def-1 nil 3280223923 ("" (skosimp*) (("" (split) (("1" (skosimp*) (("1" (typepred "Re(z!1)") (("1" (skosimp*) (("1" (lemma "unique_characterization" ("x1" "Re(z!1)" "x0" "x!1" "y1" "y!2" "y0" "y!1")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "Re(z!1)") (("2" (skosimp*) (("2" (inst + "y!1") (("2" (replace -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unique_characterization formula-decl nil complex_types nil)) shostak)) (Im_def 0 (Im_def-1 nil 3280293826 ("" (skosimp*) (("" (typepred "Im(z!1)") (("" (skosimp*) (("" (split 1) (("1" (skosimp*) (("1" (lemma "unique_characterization" ("x0" "x!1" "x1" "x!2" "y0" "Im(z!1)" "y1" "y!1")) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (inst + "x!1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (unique_characterization formula-decl nil complex_types nil)) shostak)) (closed_plus 0 (closed_plus-1 nil 3280156141 ("" (skosimp*) (("" (typepred "z1!1") (("" (typepred "z2!1") (("" (rewrite "complex_characterization") (("" (rewrite "complex_characterization") (("" (rewrite "complex_characterization") (("" (skosimp*) (("" (inst + "x!1+x!2" "y!1+y!2") (("" (grind) (("" (rewrite "commutative_mult" 1) (("" (assert) (("" (rewrite "commutative_mult" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (complex_characterization formula-decl nil complex_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_plus_real_is_real application-judgement "real" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (i const-decl "complex" complex_types nil) (commutative_mult formula-decl nil number_fields nil)) shostak)) (closed_neg 0 (closed_neg-2 "" 3884621023 ("" (skosimp*) (("" (typepred "z!1") (("" (rewrite "complex_characterization") (("" (rewrite "complex_characterization") (("" (skosimp*) (("" (replace -1 1) (("" (inst + "-x!1" "-y!1") (("" (case-replace "-(x!1 + y!1 * i) = -x!1 + -(y!1*i)") (("1" (assert) (("1" (hide-all-but 1) (("1" (lemma "both_sides_plus2" ("z" "y!1*i" "x" "-(y!1 * i)" "y" "-y!1 * i")) (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (rewrite "inverse_add" 1) (("1" (lemma "distributive" ("x" "i" "y" "y!1" "z" "-y!1")) (("1" (rewrite "inverse_add" -1) (("1" (rewrite "zero_times2" -1) (("1" (rewrite "commutative_mult" 1) (("1" (replace -1 1) (("1" (hide -1) (("1" (assert) (("1" (rewrite "commutative_mult" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "both_sides_plus2" ("z" "x!1 + y!1 * i" "x" "-(x!1 + y!1 * i)" "y" "-x!1 + -(y!1 * i)")) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (rewrite "inverse_add" 1) (("2" (lemma "inverse_add" ("x" "x!1")) (("2" (lemma "inverse_add" ("x" "y!1*i")) (("2" (assert) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (closed_neg-1 nil 3280217166 ("" (skosimp*) (("" (typepred "z!1") (("" (rewrite "complex_characterization") (("" (rewrite "complex_characterization") (("" (skosimp*) (("" (replace -2 1) (("" (inst + "-x!1" "-y!1") (("" (case-replace "-(x!1 + y!1 * i) = -x!1 + -(y!1*i)") (("1" (assert) (("1" (hide-all-but 1) (("1" (lemma "both_sides_plus2" ("z" "y!1*i" "x" "-(y!1 * i)" "y" "-y!1 * i")) (("1" (replace -1 1 rl) (("1" (hide -1) (("1" (rewrite "inverse_add" 1) (("1" (lemma "distributive" ("x" "i" "y" "y!1" "z" "-y!1")) (("1" (rewrite "inverse_add" -1) (("1" (rewrite "zero_times2" -1) (("1" (rewrite "commutative_mult" 1) (("1" (replace -1 1) (("1" (hide -1) (("1" (assert) (("1" (rewrite "commutative_mult" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "both_sides_plus2" ("z" "x!1 + y!1 * i" "x" "-(x!1 + y!1 * i)" "y" "-x!1 + -(y!1 * i)")) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (rewrite "inverse_add" 1) (("2" (lemma "inverse_add" ("x" "x!1")) (("2" (lemma "inverse_add" ("x" "y!1*i")) (("2" (assert) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i const-decl "complex" complex_types nil) (inverse_add formula-decl nil number_fields nil) (commutative_mult formula-decl nil number_fields nil) (zero_times2 formula-decl nil number_fields_bis nil) (distributive formula-decl nil number_fields nil) (both_sides_plus2 formula-decl nil number_fields_bis nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (minus_real_is_real application-judgement "real" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (complex_characterization formula-decl nil complex_types nil)) shostak)) (closed_minus 0 (closed_minus-1 nil 3280155561 ("" (skosimp*) (("" (rewrite "minus_add") (("" (lemma "closed_neg" ("z" "z2!1")) (("" (lemma "closed_plus" ("z1" "-z2!1" "z2" "z1!1")) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ((minus_add formula-decl nil number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (- const-decl "[numfield -> numfield]" number_fields nil) (closed_plus formula-decl nil complex_types nil) (closed_neg formula-decl nil complex_types nil)) shostak)) (closed_times 0 (closed_times-3 "" 3884621201 ("" (skosimp*) (("" (typepred "z1!1") (("" (typepred "z2!1") (("" (rewrite "complex_characterization") (("" (rewrite "complex_characterization") (("" (rewrite "complex_characterization") (("" (skosimp*) (("" (inst + "x!1*x!2-y!1*y!2" "x!2*y!1+x!1*y!2") (("" (replace -1) (("" (rewrite "distributive" 1) (("" (replace -2) (("" (hide-all-but 1) (("" (lemma "commutative_mult") (("" (inst-cp - "x!2 + y!2 * i" "y!1 * i") (("" (rewrite "distributive" -2) (("" (replace -2) (("" (hide -2) (("" (inst-cp - "x!2 + y!2 * i" "x!1") (("" (rewrite "distributive" -2) (("" (replace -2) (("" (hide -2) (("" (inst-cp - "x!2 * y!1 + x!1 * y!2" "i") (("" (rewrite "distributive" -2) (("" (replace -2) (("" (hide -2) (("" (assert) (("" (lemma "i_axiom") (("" (replace -1) (("" (inst - "x!1*y!2" "i") (("" (lemma "associative_mult") (("" (inst-cp - "x!1" "y!2" "i") (("" (replace -2) (("" (replace -4) (("" (hide -2 -4 -3) (("" (assert) (("" (inst - "i" "x!2" "y!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (closed_times-2 "" 3790100292 ("" (skosimp*) (("" (typepred "z1!1") (("" (typepred "z2!1") (("" (rewrite "complex_characterization") (("" (rewrite "complex_characterization") (("" (rewrite "complex_characterization") (("" (skosimp*) (("" (inst + "x!1*x!2-y!1*y!2" "x!2*y!1+x!1*y!2") (("" (replace -2) (("" (rewrite "distributive" 1) (("" (replace -4) (("" (hide-all-but 1) (("" (lemma "commutative_mult") (("" (inst-cp - "x!2 + y!2 * i" "y!1 * i") (("" (rewrite "distributive" -2) (("" (replace -2) (("" (hide -2) (("" (inst-cp - "x!2 + y!2 * i" "x!1") (("" (rewrite "distributive" -2) (("" (replace -2) (("" (hide -2) (("" (inst-cp - "x!2 * y!1 + x!1 * y!2" "i") (("" (rewrite "distributive" -2) (("" (replace -2) (("" (hide -2) (("" (assert) (("" (lemma "i_axiom") (("" (replace -1) (("" (inst - "x!1*y!2" "i") (("" (lemma "associative_mult") (("" (inst-cp - "x!1" "y!2" "i") (("" (replace -2) (("" (replace -4) (("" (hide -2 -4 -3) (("" (assert) (("" (inst - "i" "x!2" "y!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (complex_characterization formula-decl nil complex_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (i const-decl "complex" complex_types nil) (distributive formula-decl nil number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (associative_mult formula-decl nil number_fields nil) (nil application-judgement "above(n)" exp2 nil) (i_axiom formula-decl nil complex_types nil) (commutative_mult formula-decl nil number_fields nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak) (closed_times-1 nil 3280219956 ("" (skosimp*) (("" (typepred "z1!1") (("" (typepred "z2!1") (("" (rewrite "complex_characterization") (("" (rewrite "complex_characterization") (("" (rewrite "complex_characterization") (("" (skosimp*) (("" (inst + "x!1*x!2-y!1*y!2" "x!2*y!1+x!1*y!2") (("" (replace -2) (("" (rewrite "distributive" 1) (("" (replace -4) (("" (hide-all-but 1) (("" (lemma "commutative_mult") (("" (inst-cp - "x!2 + y!2 * i" "y!1 * i") (("" (rewrite "distributive" -2) (("" (replace -2) (("" (hide -2) (("" (inst-cp - "x!2 + y!2 * i" "x!1") (("" (rewrite "distributive" -2) (("" (replace -2) (("" (hide -2) (("" (inst-cp - "x!2 * y!1 + x!1 * y!2" "i") (("" (rewrite "distributive" -2) (("" (replace -2) (("" (hide -2) (("" (assert) (("" (lemma "i_axiom") (("" (expand "sq") (("" (replace -1) (("" (inst - "x!1*y!2" "i") (("" (lemma "associative_mult") (("" (inst-cp - "x!1" "y!2" "i") (("" (replace -2) (("" (replace -4) (("" (hide -2 -4 -3) (("" (assert) (("" (inst - "i" "x!2" "y!1") (("" (assert) (("" (replace -1 1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (closed_divides 0 (closed_divides-3 "" 3884621581 ("" (skosimp) (("" (case "complex_pred(1/n0z!1)") (("1" (rewrite "div_def" 1) (("1" (lemma "closed_times" ("z1" "z!1" "z2" "1/n0z!1")) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "n0z!1") (("2" (rewrite "complex_characterization") (("2" (rewrite "complex_characterization") (("2" (skosimp) (("2" (case "FORALL (x:real): x*x >= 0") (("1" (case "FORALL (nzx:nzreal): nzx*nzx > 0") (("1" (name "D" "x!1*x!1+y!1*y!1") (("1" (case "D>0") (("1" (inst + "x!1/D" "-y!1/D") (("1" (lemma "div_distributes" ("x" "x!1" "y" "-y!1*i" "n0z" "D")) (("1" (rewrite "times_div2" 2) (("1" (replace -1 2) (("1" (rewrite "cross_mult" 2) (("1" (replace -6 2) (("1" (expand "D" 2) (("1" (lemma "i_axiom") (("1" (assert) (("1" (hide-all-but (-1 2)) (("1" (rewrite "associative_mult" :dir rl) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "commutative_mult") (("1" (inst-cp - "-y!1" "i") (("1" (replace -2) (("1" (lemma "distributive" ("x" "i" "y" "-y!1*x!1" "z" "x!1*y!1")) (("1" (rewrite "associative_mult" 1 :dir rl) (("1" (rewrite "associative_mult" 1 :dir rl) (("1" (replace -1 1 :dir rl) (("1" (hide -1 -3) (("1" (inst-cp - "-y!1" "x!1") (("1" (replace -2) (("1" (lemma "distributive" ("x" "x!1" "y" "-y!1" "z" "y!1")) (("1" (replace -1 1 rl) (("1" (lemma "inverse_add" ("x" "y!1")) (("1" (rewrite "commutative_add" -1) (("1" (replace -1 1) (("1" (rewrite "zero_times2") (("1" (rewrite "minus_add" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case-replace "x!1=0") (("1" (case-replace "y!1=0") (("1" (rewrite "zero_times1" -6) nil nil) ("2" (inst -3 "y!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (inst -2 "x!1") (("1" (inst -3 "y!1") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp) (("2" (lemma "trichotomy" ("x" "nzx!1")) (("2" (split) (("1" (lemma "posreal_times_posreal_is_posreal" ("px" "nzx!1" "py" "nzx!1")) (("1" (propax) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (lemma "negreal_times_negreal_is_posreal" ("nx" "nzx!1" "ny" "nzx!1")) (("1" (propax) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp) (("2" (lemma "trichotomy" ("x" "x!2")) (("2" (split) (("1" (lemma "posreal_times_posreal_is_posreal" ("px" "x!2" "py" "x!2")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (lemma "negreal_times_negreal_is_posreal" ("nx" "x!2" "ny" "x!2")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (closed_divides-2 "" 3790100293 ("" (skosimp) (("" (case "complex_pred(1/n0z!1)") (("1" (rewrite "div_def" 1) (("1" (lemma "closed_times" ("z1" "z!1" "z2" "1/n0z!1")) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "n0z!1") (("2" (rewrite "complex_characterization") (("2" (rewrite "complex_characterization") (("2" (skosimp) (("2" (case "FORALL (x:real): x*x >= 0") (("1" (case "FORALL (nzx:nzreal): nzx*nzx > 0") (("1" (name "D" "x!1*x!1+y!1*y!1") (("1" (case "D>0") (("1" (inst + "x!1/D" "-y!1/D") (("1" (lemma "div_distributes" ("x" "x!1" "y" "-y!1*i" "n0z" "D")) (("1" (rewrite "times_div2" 2) (("1" (replace -1 2) (("1" (rewrite "cross_mult" 2) (("1" (replace -7 2) (("1" (expand "D" 2) (("1" (lemma "i_axiom") (("1" (assert) (("1" (hide-all-but (-1 2)) (("1" (rewrite "associative_mult" :dir rl) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "commutative_mult") (("1" (inst-cp - "-y!1" "i") (("1" (replace -2) (("1" (lemma "distributive" ("x" "i" "y" "-y!1*x!1" "z" "x!1*y!1")) (("1" (rewrite "associative_mult" 1 :dir rl) (("1" (rewrite "associative_mult" 1 :dir rl) (("1" (replace -1 1 :dir rl) (("1" (hide -1 -3) (("1" (inst-cp - "-y!1" "x!1") (("1" (replace -2) (("1" (lemma "distributive" ("x" "x!1" "y" "-y!1" "z" "y!1")) (("1" (replace -1 1 rl) (("1" (lemma "inverse_add" ("x" "y!1")) (("1" (rewrite "commutative_add" -1) (("1" (replace -1 1) (("1" (rewrite "zero_times2") (("1" (rewrite "minus_add" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case-replace "x!1=0") (("1" (case-replace "y!1=0") (("1" (rewrite "zero_times1" -7) nil nil) ("2" (inst -3 "y!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (inst -2 "x!1") (("1" (inst -3 "y!1") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp) (("2" (lemma "trichotomy" ("x" "nzx!1")) (("2" (split) (("1" (lemma "posreal_times_posreal_is_posreal" ("px" "nzx!1" "py" "nzx!1")) (("1" (propax) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (lemma "negreal_times_negreal_is_posreal" ("nx" "nzx!1" "ny" "nzx!1")) (("1" (propax) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp) (("2" (lemma "trichotomy" ("x" "x!2")) (("2" (split) (("1" (lemma "posreal_times_posreal_is_posreal" ("px" "x!2" "py" "x!2")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (lemma "negreal_times_negreal_is_posreal" ("nx" "x!2" "ny" "x!2")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzcomplex nonempty-type-eq-decl nil complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (closed_times formula-decl nil complex_types nil) (nznum_div_nznum_is_nznum application-judgement "nznum" number_fields_bis nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (div_def formula-decl nil number_fields nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (trichotomy formula-decl nil real_axioms nil) (negreal_times_negreal_is_posreal judgement-tcc nil real_types nil) (<= const-decl "bool" reals nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (negreal nonempty-type-eq-decl nil real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (y!1 skolem-const-decl "real" complex_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (int_times_even_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (x!1 skolem-const-decl "real" complex_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (D skolem-const-decl "real" complex_types nil) (- const-decl "[numfield -> numfield]" number_fields nil) (times_div2 formula-decl nil number_fields_bis nil) (minus_real_is_real application-judgement "real" reals nil) (cross_mult formula-decl nil number_fields_bis nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nil application-judgement "above(n)" exp2 nil) (associative_mult formula-decl nil number_fields nil) (commutative_mult formula-decl nil number_fields nil) (inverse_add formula-decl nil number_fields nil) (minus_add formula-decl nil number_fields nil) (zero_times2 formula-decl nil number_fields_bis nil) (commutative_add formula-decl nil number_fields nil) (distributive formula-decl nil number_fields nil) (i_axiom formula-decl nil complex_types nil) (i const-decl "complex" complex_types nil) (div_distributes formula-decl nil number_fields_bis nil) (> const-decl "bool" reals nil) (nzreal nonempty-type-eq-decl nil reals nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (complex_characterization formula-decl nil complex_types nil)) shostak) (closed_divides-1 nil 3280157418 ("" (skosimp) (("" (case "complex_pred(1/n0z!1)") (("1" (rewrite "div_def" 1) (("1" (lemma "closed_times" ("z1" "z!1" "z2" "1/n0z!1")) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "n0z!1") (("2" (rewrite "complex_characterization") (("2" (rewrite "complex_characterization") (("2" (skosimp) (("2" (case "FORALL (x:real): x*x >= 0") (("1" (case "FORALL (nzx:nzreal): nzx*nzx > 0") (("1" (name "D" "x!1*x!1+y!1*y!1") (("1" (case "D>0") (("1" (inst + "x!1/D" "-y!1/D") (("1" (lemma "div_distributes" ("x" "x!1" "y" "-y!1*i" "n0z" "D")) (("1" (rewrite "times_div2" 2) (("1" (replace -1 2) (("1" (rewrite "cross_mult" 2) (("1" (replace -7 2) (("1" (expand "D" 2) (("1" (lemma "i_axiom") (("1" (assert) (("1" (hide-all-but (-1 2)) (("1" (rewrite "associative_mult" :dir rl) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "commutative_mult") (("1" (inst-cp - "-y!1" "i") (("1" (replace -2) (("1" (lemma "distributive" ("x" "i" "y" "-y!1*x!1" "z" "x!1*y!1")) (("1" (rewrite "associative_mult" 1 :dir rl) (("1" (rewrite "associative_mult" 1 :dir rl) (("1" (replace -1 1 :dir rl) (("1" (hide -1 -3) (("1" (inst-cp - "-y!1" "x!1") (("1" (replace -2) (("1" (lemma "distributive" ("x" "x!1" "y" "-y!1" "z" "y!1")) (("1" (replace -1 1 rl) (("1" (lemma "inverse_add" ("x" "y!1")) (("1" (rewrite "commutative_add" -1) (("1" (replace -1 1) (("1" (rewrite "zero_times2") (("1" (rewrite "minus_add" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case-replace "x!1=0") (("1" (case-replace "y!1=0") (("1" (rewrite "zero_times1" -7) nil nil) ("2" (inst -3 "y!1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (inst -2 "x!1") (("1" (inst -3 "y!1") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp) (("2" (lemma "trichotomy" ("x" "nzx!1")) (("2" (split) (("1" (lemma "posreal_times_posreal_is_posreal" ("px" "nzx!1" "py" "nzx!1")) (("1" (propax) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (lemma "negreal_times_negreal_is_posreal" ("nx" "nzx!1" "ny" "nzx!1")) (("1" (propax) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp) (("2" (lemma "trichotomy" ("x" "x!2")) (("2" (split) (("1" (lemma "posreal_times_posreal_is_posreal" ("px" "x!2" "py" "x!2")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (lemma "negreal_times_negreal_is_posreal" ("nx" "x!2" "ny" "x!2")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nznum_div_nznum_is_nznum application-judgement "nznum" number_fields_bis nil) (zero_times1 formula-decl nil number_fields_bis nil) (times_div2 formula-decl nil number_fields_bis nil) (cross_mult formula-decl nil number_fields_bis nil) (zero_times2 formula-decl nil number_fields_bis nil) (div_distributes formula-decl nil number_fields_bis nil)) shostak)) (complex_plus_complex_is_complex 0 (complex_plus_complex_is_complex-1 nil 3280294602 ("" (lemma "closed_plus") (("" (propax) nil nil)) nil) ((closed_plus formula-decl nil complex_types nil)) shostak (complex_plus_complex_is_complex subtype "(number_fields.+)(complex_types.z1, complex_types.z2)" "complex"))) (complex_minus_complex_is_complex 0 (complex_minus_complex_is_complex-1 nil 3280294602 ("" (lemma "closed_minus") (("" (propax) nil nil)) nil) ((closed_minus formula-decl nil complex_types nil)) shostak (complex_minus_complex_is_complex subtype "(number_fields.-)(complex_types.z1, complex_types.z2)" "complex"))) (complex_times_complex_is_complex 0 (complex_times_complex_is_complex-1 nil 3280294603 ("" (lemma "closed_times") (("" (propax) nil nil)) nil) ((closed_times formula-decl nil complex_types nil)) shostak (complex_times_complex_is_complex subtype "number_fields.*(complex_types.z1, complex_types.z2)" "complex"))) (complex_div_nzcomplex_is_complex 0 (complex_div_nzcomplex_is_complex-1 nil 3280294603 ("" (lemma "closed_divides") (("" (propax) nil nil)) nil) ((closed_divides formula-decl nil complex_types nil)) shostak (complex_div_nzcomplex_is_complex subtype "number_fields./(complex_types.z, complex_types.n0z)" "complex"))) (minus_complex_is_complex 0 (minus_complex_is_complex-1 nil 3280294603 ("" (lemma "closed_neg") (("" (propax) nil nil)) nil) ((closed_neg formula-decl nil complex_types nil)) shostak (minus_complex_is_complex subtype "(number_fields.-)(complex_types.z)" "complex"))) (nzcomplex_times_nzcomplex_is_nzcomplex 0 (nzcomplex_times_nzcomplex_is_nzcomplex-1 nil 3280294968 ("" (skosimp*) (("" (typepred "nzx!1") (("" (typepred "nzy!1") (("" (lemma "zero_times3" ("x" "nzx!1" "y" "nzy!1")) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((nzcomplex nonempty-type-eq-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (zero_times3 formula-decl nil number_fields_bis nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (nznum_times_nznum_is_nznum application-judgement "nznum" number_fields_bis nil)) shostak (nzcomplex_times_nzcomplex_is_nzcomplex subtype "number_fields.*(complex_types.nzx, complex_types.nzy)" "nzcomplex"))) (nzcomplex_div_nzcomplex_is_nzcomplex 0 (nzcomplex_div_nzcomplex_is_nzcomplex-1 nil 3280294968 ("" (skosimp*) (("" (rewrite "div_def") (("" (lemma "inv_ne_0" ("n0x" "nzy!1")) (("" (lemma "nzcomplex_times_nzcomplex_is_nzcomplex" ("nzx" "nzx!1" "nzy" "1/nzy!1")) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((div_def formula-decl nil number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nznum_div_nznum_is_nznum application-judgement "nznum" number_fields_bis nil) (complex_div_nzcomplex_is_complex application-judgement "complex" complex_types nil) (nzcomplex_times_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (nzcomplex_times_nzcomplex_is_nzcomplex judgement-tcc nil complex_types nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (inv_ne_0 formula-decl nil number_fields_bis nil)) shostak (nzcomplex_div_nzcomplex_is_nzcomplex subtype "number_fields./(complex_types.nzx, complex_types.nzy)" "nzcomplex"))) (minus_nzcomplex_is_nzcomplex 0 (minus_nzcomplex_is_nzcomplex-1 nil 3280294968 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (/= const-decl "boolean" notequal nil) (minus_complex_is_complex application-judgement "complex" complex_types nil) (minus_nznum_is_nznum application-judgement "nznum" number_fields_bis nil)) shostak (minus_nzcomplex_is_nzcomplex subtype "(number_fields.-)(complex_types.nzx)" "nzcomplex"))))
