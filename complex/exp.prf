(exp (exp_TCC1 0 (exp_TCC1-1 nil 3294275262 ("" (skosimp) (("" (typepred "exp(Re(z!1))") (("" (lemma "both_sides_times1" ("n0z" "exp(Re(z!1))" "x" "cos(Im(z!1)) + i * sin(Im(z!1))" "y" "0")) (("" (assert) (("" (hide-all-but -1) (("" (lemma "unique_characterization" ("x0" "cos(Im(z!1))" "x1" "0" "y0" "sin(Im(z!1))" "y1" "0")) (("" (rewrite "zero_times1" -1) (("" (assert) (("" (lemma "sin_cos_eq_0" ("a" "Im(z!1)")) (("" (flatten -1) (("" (hide -2) (("" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (rewrite "commutative_mult") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (ln const-decl "real" ln_exp lnexp) (= const-decl "[T, T -> boolean]" equalities nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Re_is_real application-judgement "real" complex_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (unique_characterization formula-decl nil complex_types nil) (commutative_mult formula-decl nil number_fields nil) (sin_cos_eq_0 formula-decl nil trig_basic trig_fnd) (zero_times1 formula-decl nil number_fields_bis nil) (both_sides_times1 formula-decl nil number_fields_bis nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (cos const-decl "real" sincos_def trig_fnd) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (sin const-decl "real" sincos_def trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak (exp subtype "number_fields.*(ln_exp.exp(complex_types.Re(exp.z)), ((number_fields.+)(sincos_def.cos(complex_types.Im(exp.z)), number_fields.*(complex_types.i, sincos_def.sin(complex_types.Im(exp.z))))))" "nzcomplex"))) (exp_real 0 (exp_real-1 nil 3294334350 ("" (skosimp) (("" (expand "exp" 1 1) (("" (rewrite "Re_real" 1) (("" (rewrite "Im_real" 1) (("" (rewrite "sin_0") (("" (rewrite "cos_0") (("" (rewrite "zero_times2") (("" (rewrite "zero_times1") (("" (rewrite "identity_mult" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex_times_complex_is_complex application-judgement "complex" complex_types nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (exp const-decl "nzcomplex" exp nil) (Im_real formula-decl nil arithmetic nil) (cos_0 formula-decl nil sincos_def trig_fnd) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (i const-decl "complex" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (identity_mult formula-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (zero_times2 formula-decl nil number_fields_bis nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (ln const-decl "real" ln_exp lnexp) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (sin_0 formula-decl nil sincos_def trig_fnd) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Re_real formula-decl nil arithmetic nil)) shostak)) (exp_imag 0 (exp_imag-1 nil 3294844116 ("" (skosimp) (("" (expand "exp") (("" (lemma "Re_imag" ("x" "r!1")) (("" (lemma "Im_imag" ("x" "r!1")) (("" (replace -1) (("" (replace -2) (("" (rewrite "exp_0") (("" (rewrite "identity_mult") (("" (lemma "commutative_mult" ("x" "sin(r!1)" "y" "i")) (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex_times_complex_is_complex application-judgement "complex" complex_types nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (exp const-decl "nzcomplex" exp nil) (Im_imag formula-decl nil arithmetic nil) (sin const-decl "real" sincos_def trig_fnd) (numfield nonempty-type-eq-decl nil number_fields nil) (identity_mult formula-decl nil number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Re_is_real application-judgement "real" complex_types nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (i const-decl "complex" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (commutative_mult formula-decl nil number_fields nil) (exp_0 formula-decl nil ln_exp lnexp) (Re_imag formula-decl nil arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) shostak)) (abs_exp_imag 0 (abs_exp_imag-2 "" 3790100358 ("" (skosimp) (("" (rewrite "exp_imag") (("" (expand "abs") (("" (expand "conjugate") (("" (rewrite "Im_plus") (("" (rewrite "Re_plus") (("" (assert) (("" (lemma "Re_imag" ("x" "sin(r!1)")) (("" (rewrite "commutative_mult" -1) (("" (replace -1) (("" (rewrite "Im_real" 1) (("" (rewrite "zero_times1") (("" (rewrite "zero_times1") (("" (rewrite "zero_times1") (("" (rewrite "zero_times2") (("" (assert) (("" (lemma "Im_imag" ("x" "sin(r!1)")) (("" (rewrite "commutative_mult" -1) (("" (replace -1) (("" (rewrite "sq.sq_rew") (("" (rewrite "Re_real" 1) (("" (rewrite "sq.sq_rew") (("" (assert) (("" (rewrite "associative_mult" 1 :dir rl) (("" (rewrite "i_axiom") (("" (assert) (("" (rewrite "minus_add") (("" (rewrite "number_fields_times_negative" 1) (("" (rewrite "number_fields_negate_negate") (("" (lemma "sin2_cos2" ("a" "r!1")) (("" (assert) (("" (replace -1 1) (("" (rewrite "sqrt_1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((exp_imag formula-decl nil exp nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Re_is_real application-judgement "real" complex_types nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (Re_plus formula-decl nil arithmetic nil) (Re_imag formula-decl nil arithmetic nil) (zero_times1 formula-decl nil number_fields_bis nil) (sq_rew formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (associative_mult formula-decl nil number_fields nil) (real_minus_real_is_real application-judgement "real" reals nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sqrt_1 formula-decl nil sqrt reals) (sin2_cos2 formula-decl nil sincos_def trig_fnd) (i_axiom formula-decl nil complex_types nil) (Re_real formula-decl nil arithmetic nil) (Im_imag formula-decl nil arithmetic nil) (int_times_even_is_even application-judgement "even_int" integers nil) (zero_times2 formula-decl nil number_fields_bis nil) (Im_real formula-decl nil arithmetic nil) (commutative_mult formula-decl nil number_fields nil) (nil application-judgement "above(n)" exp2 nil) (real_plus_real_is_real application-judgement "real" reals nil) (Im_plus formula-decl nil arithmetic nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (cos const-decl "real" sincos_def trig_fnd) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i const-decl "complex" complex_types nil) (sin const-decl "real" sincos_def trig_fnd) (abs const-decl "nnreal" polar nil)) shostak) (abs_exp_imag-1 nil 3294844749 ("" (skosimp) (("" (rewrite "exp_imag") (("" (expand "abs") (("" (expand "conjugate") (("" (rewrite "Im_plus") (("1" (rewrite "Re_plus") (("1" (assert) (("1" (lemma "Re_imag" ("x" "sin(r!1)")) (("1" (rewrite "commutative_mult" -1) (("1" (replace -1) (("1" (rewrite "Im_real" 1) (("1" (rewrite "zero_times1") (("1" (rewrite "zero_times1") (("1" (rewrite "zero_times1") (("1" (rewrite "zero_times2") (("1" (assert) (("1" (lemma "Im_imag" ("x" "sin(r!1)")) (("1" (rewrite "commutative_mult" -1) (("1" (replace -1) (("1" (rewrite "sq.sq_rew") (("1" (rewrite "Re_real" 1) (("1" (rewrite "sq.sq_rew") (("1" (assert) (("1" (rewrite "associative_mult" 1 :dir rl) (("1" (rewrite "i_axiom") (("1" (assert) (("1" (rewrite "minus_add") (("1" (rewrite "number_fields_times_negative" 1) (("1" (rewrite "number_fields_negate_negate") (("1" (lemma "sin2_cos2" ("a" "r!1")) (("1" (assert) (("1" (replace -1 1) (("1" (rewrite "sqrt_1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "closed_times") (("2" (rewrite "real_is_complex") nil nil)) nil) ("3" (rewrite "real_is_complex") nil nil)) nil)) nil)) nil)) nil)) nil) ((sin_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (Re_is_real application-judgement "real" complex_types nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (Re_plus formula-decl nil arithmetic nil) (Re_imag formula-decl nil arithmetic nil) (zero_times1 formula-decl nil number_fields_bis nil) (sq_rew formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (number_fields_times_negative formula-decl nil number_fields_bis nil) (sin2_cos2 formula-decl nil sincos_def trig_fnd) (sqrt_1 formula-decl nil sqrt reals) (number_fields_negate_negate formula-decl nil number_fields_bis nil) (i_axiom formula-decl nil complex_types nil) (Re_real formula-decl nil arithmetic nil) (Im_imag formula-decl nil arithmetic nil) (zero_times2 formula-decl nil number_fields_bis nil) (Im_real formula-decl nil arithmetic nil) (Im_plus formula-decl nil arithmetic nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (cos const-decl "real" sincos_def trig_fnd) (i const-decl "complex" complex_types nil) (sin const-decl "real" sincos_def trig_fnd) (abs const-decl "nnreal" polar nil)) shostak)) (arg_exp_real 0 (arg_exp_real-1 nil 3294848302 ("" (skosimp) (("" (rewrite "exp_real") (("" (typepred "ln_exp.exp(r!1)") (("" (rewrite "arg_is_0" 1) (("" (rewrite "Re_real") (("" (rewrite "Im_real") nil nil)) nil)) nil)) nil)) nil)) nil) ((exp_real formula-decl nil exp nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (arg_is_0 formula-decl nil polar nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Im_is_real application-judgement "real" complex_types nil) (Re_is_real application-judgement "real" complex_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Im_real formula-decl nil arithmetic nil) (Re_real formula-decl nil arithmetic nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (ln const-decl "real" ln_exp lnexp) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp)) shostak)) (arg_exp_imag 0 (arg_exp_imag-2 "" 3790100360 ("" (skosimp) (("" (rewrite "exp_imag") (("" (typepred "theta!1") (("" (expand "arg") (("" (rewrite "Im_plus") (("" (rewrite "Im_real") (("" (rewrite "Re_plus") (("" (lemma "Re_imag" ("x" "sin(theta!1)")) (("" (assert) (("" (lemma "Im_imag" ("x" "sin(theta!1)")) (("" (rewrite "commutative_mult") (("" (replace -1) (("" (replace -2) (("" (hide -1 -2) (("" (assert) (("" (rewrite "Re_real") (("" (lift-if) (("" (prop) (("1" (lemma "unique_characterization" ("x0" "cos(theta!1)" "x1" "0" "y0" "sin(theta!1)" "y1" "0")) (("1" (rewrite "zero_times1" -1) (("1" (rewrite "commutative_mult" -1) (("1" (replace -2) (("1" (flatten -1) (("1" (hide -3) (("1" (lemma "sin_cos_eq_0" ("a" "theta!1")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "0<=theta!1") (("1" (hide -3 1 2) (("1" (lemma "sin_ge_0" ("a" "theta!1")) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "atan2_cos_sin" ("a" "-theta!1")) (("1" (rewrite "cos_neg") (("1" (rewrite "sin_neg") (("1" (expand "atan2") (("1" (case-replace "cos(theta!1) > 0") (("1" (assert) (("1" (lemma "atan_neg") (("1" (inst - "sin(theta!1) / cos(theta!1)") (("1" (replace -1 -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "cos(theta!1)=0") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "atan_neg" ("x" "sin(theta!1) / cos(theta!1)")) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case-replace "0<=theta!1") (("1" (rewrite "atan2_cos_sin") nil nil) ("2" (hide 3 4) (("2" (lemma "sin_gt_0" ("a" "-theta!1")) (("2" (rewrite "sin_neg") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((exp_imag formula-decl nil exp nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (cos const-decl "real" sincos_def trig_fnd) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (arg const-decl "argrng" polar nil) (Im_real formula-decl nil arithmetic nil) (Re_imag formula-decl nil arithmetic nil) (Im_imag formula-decl nil arithmetic nil) (Re_real formula-decl nil arithmetic nil) (zero_times1 formula-decl nil number_fields_bis nil) (sin_cos_eq_0 formula-decl nil trig_basic trig_fnd) (unique_characterization formula-decl nil complex_types nil) (minus_real_is_real application-judgement "real" reals nil) (atan2_cos_sin formula-decl nil atan2 trig_fnd) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sin_neg formula-decl nil sincos_def trig_fnd) (atan_neg formula-decl nil atan trig_fnd) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (atan2 const-decl "real" atan2 trig_fnd) (cos_neg formula-decl nil sincos_def trig_fnd) (sin_ge_0 formula-decl nil trig_ineq trig_fnd) (sin_gt_0 formula-decl nil trig_ineq trig_fnd) (commutative_mult formula-decl nil number_fields nil) (Re_is_real application-judgement "real" complex_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Re_plus formula-decl nil arithmetic nil) (real_plus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (Im_plus formula-decl nil arithmetic nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i const-decl "complex" complex_types nil) (sin const-decl "real" sincos_def trig_fnd) (NOT const-decl "[bool -> bool]" booleans nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd)) shostak) (arg_exp_imag-1 nil 3294848362 ("" (skosimp) (("" (rewrite "exp_imag") (("" (typepred "theta!1") (("" (expand "arg") (("" (rewrite "Im_plus") (("1" (rewrite "Im_real") (("1" (rewrite "Re_plus") (("1" (lemma "Re_imag" ("x" "sin(theta!1)")) (("1" (assert) (("1" (lemma "Im_imag" ("x" "sin(theta!1)")) (("1" (rewrite "commutative_mult") (("1" (replace -1) (("1" (replace -2) (("1" (hide -1 -2) (("1" (assert) (("1" (rewrite "Re_real") (("1" (lift-if) (("1" (prop) (("1" (lemma "unique_characterization" ("x0" "cos(theta!1)" "x1" "0" "y0" "sin(theta!1)" "y1" "0")) (("1" (rewrite "zero_times1" -1) (("1" (rewrite "commutative_mult" -1) (("1" (replace -2) (("1" (flatten -1) (("1" (hide -3) (("1" (lemma "sin_cos_eq_0" ("a" "theta!1")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "0<=theta!1") (("1" (hide -3 1 2) (("1" (lemma "sin_ge_0" ("a" "theta!1")) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "atan2_cos_sin" ("a" "-theta!1")) (("1" (rewrite "cos_neg") (("1" (rewrite "sin_neg") (("1" (expand "atan2") (("1" (case-replace "cos(theta!1) > 0") (("1" (assert) (("1" (lemma "atan_neg") (("1" (inst - "sin(theta!1) / cos(theta!1)") (("1" (replace -1 -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "cos(theta!1)=0") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "atan_neg" ("x" "sin(theta!1) / cos(theta!1)")) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (case-replace "0<=theta!1") (("1" (rewrite "atan2_cos_sin") nil nil) ("2" (hide 3 4) (("2" (lemma "sin_gt_0" ("a" "-theta!1")) (("2" (rewrite "sin_neg") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "closed_times") (("2" (rewrite "real_is_complex") nil nil)) nil) ("3" (rewrite "real_is_complex") nil nil)) nil)) nil) ("2" (rewrite "closed_times") (("2" (rewrite "real_is_complex") nil nil)) nil) ("3" (rewrite "real_is_complex") nil nil)) nil)) nil)) nil)) nil)) nil) ((cos const-decl "real" sincos_def trig_fnd) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (argrng nonempty-type-eq-decl nil polar nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (arg const-decl "argrng" polar nil) (Im_real formula-decl nil arithmetic nil) (Re_imag formula-decl nil arithmetic nil) (Im_imag formula-decl nil arithmetic nil) (Re_real formula-decl nil arithmetic nil) (zero_times1 formula-decl nil number_fields_bis nil) (sin_cos_eq_0 formula-decl nil trig_basic trig_fnd) (unique_characterization formula-decl nil complex_types nil) (atan2_cos_sin formula-decl nil atan2 trig_fnd) (sin_neg formula-decl nil sincos_def trig_fnd) (atan_neg formula-decl nil atan trig_fnd) (atan2 const-decl "real" atan2 trig_fnd) (cos_neg formula-decl nil sincos_def trig_fnd) (sin_ge_0 formula-decl nil trig_ineq trig_fnd) (sin_gt_0 formula-decl nil trig_ineq trig_fnd) (Re_is_real application-judgement "real" complex_types nil) (Re_plus formula-decl nil arithmetic nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (Im_plus formula-decl nil arithmetic nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (i const-decl "complex" complex_types nil) (sin const-decl "real" sincos_def trig_fnd) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd)) shostak)) (exp_0 0 (exp_0-1 nil 3294273290 ("" (expand "exp") (("" (rewrite "Re_real") (("" (rewrite "Im_real") (("" (rewrite "exp_0") (("" (rewrite "sin_0") (("" (rewrite "cos_0") (("" (rewrite "zero_times1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Re_real formula-decl nil arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (exp_0 formula-decl nil ln_exp lnexp) (cos_0 formula-decl nil sincos_def trig_fnd) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (zero_times1 formula-decl nil number_fields_bis nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (i const-decl "complex" complex_types nil) (sin_0 formula-decl nil sincos_def trig_fnd) (Im_real formula-decl nil arithmetic nil) (exp const-decl "nzcomplex" exp nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (exp_1 0 (exp_1-1 nil 3294274905 ("" (expand "exp") (("" (expand "e") (("" (rewrite "Re_real") (("" (rewrite "Im_real") (("" (rewrite "sin_0") (("" (rewrite "cos_0") (("" (rewrite "zero_times2") (("" (rewrite "zero_times1") (("" (rewrite "identity_mult") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((e const-decl "posreal" ln_exp lnexp) (Im_real formula-decl nil arithmetic nil) (cos_0 formula-decl nil sincos_def trig_fnd) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (i const-decl "complex" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (identity_mult formula-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (exp_1 formula-decl nil ln_exp lnexp) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (zero_times2 formula-decl nil number_fields_bis nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (ln const-decl "real" ln_exp lnexp) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (sin_0 formula-decl nil sincos_def trig_fnd) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Re_real formula-decl nil arithmetic nil) (exp const-decl "nzcomplex" exp nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (exp_i_pi 0 (exp_i_pi-2 "" 3790100360 ("" (lemma "exp_imag" ("r" "pi")) (("" (rewrite "cos_pi") (("" (rewrite "sin_pi") (("" (rewrite "zero_times2") (("" (assert) (("" (rewrite "commutative_mult") nil nil)) nil)) nil)) nil)) nil)) nil) ((cos_pi formula-decl nil sincos trig_fnd) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (nil application-judgement "above(n)" exp2 nil) (i const-decl "complex" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (zero_times2 formula-decl nil number_fields_bis nil) (commutative_mult formula-decl nil number_fields nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sin_pi formula-decl nil sincos trig_fnd) (exp_imag formula-decl nil exp nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (cos const-decl "real" sincos_def trig_fnd) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd)) shostak) (exp_i_pi-1 nil 3294274991 ("" (lemma "exp_imag" ("r" "pi")) (("" (rewrite "cos_pi") (("" (rewrite "sin_pi") (("" (rewrite "zero_times2") (("" (assert) (("" (rewrite "commutative_mult") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cos_pi formula-decl nil sincos trig_fnd) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (i const-decl "complex" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (zero_times2 formula-decl nil number_fields_bis nil) (sin_pi formula-decl nil sincos trig_fnd) (cos const-decl "real" sincos_def trig_fnd) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd)) shostak)) (exp_plus 0 (exp_plus-1 nil 3294335316 ("" (skosimp) (("" (expand "exp") (("" (rewrite "Re_plus") (("" (rewrite "Im_plus") (("" (rewrite "sin_plus") (("" (rewrite "cos_plus") (("" (rewrite "exp_sum" 1) (("" (assert) (("" (name-replace "DRL101" "ln_exp.exp(Re(x!1)) * ln_exp.exp(Re(y!1)) * sin(Im(x!1)) * sin(Im(y!1))") (("" (rewrite "associative_mult" 1 :dir rl) (("" (rewrite "i_axiom") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex_times_complex_is_complex application-judgement "complex" complex_types nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (exp const-decl "nzcomplex" exp nil) (Im_plus formula-decl nil arithmetic nil) (cos_plus formula-decl nil sincos trig_fnd) (real_minus_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (associative_mult formula-decl nil number_fields nil) (nil application-judgement "above(n)" exp2 nil) (i_axiom formula-decl nil complex_types nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (ln const-decl "real" ln_exp lnexp) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (sin const-decl "real" sincos_def trig_fnd) (exp_sum formula-decl nil ln_exp lnexp) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (sin_plus formula-decl nil sincos trig_fnd) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i const-decl "complex" complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Re_plus formula-decl nil arithmetic nil)) shostak)) (exp_negate 0 (exp_negate-2 "" 3790100362 ("" (skosimp) (("" (expand "exp") (("" (rewrite "Re_neg") (("" (rewrite "Im_neg") (("" (rewrite "sin_neg") (("" (rewrite "cos_neg") (("" (rewrite "exp_neg") (("" (assert) (("" (typepred "ln_exp.exp(Re(x!1))") (("" (hide -1 -3) (("" (name-replace "R" "ln_exp.exp(Re(x!1))") (("" (rewrite "div_cancel4" 1) (("" (assert) (("" (lemma "number_fields_negative_times" ("x" "1" "y" "sin(Im(x!1))")) (("" (rewrite "identity_mult") (("" (replace -1 * rl) (("" (hide -1) (("" (assert) (("" (assert) (("" (rewrite "commutative_mult" 1 :dir rl) (("" (rewrite "commutative_mult" 1 :dir rl) (("" (rewrite "sq.sq_rew") (("" (rewrite "sq.sq_rew") (("" (rewrite "associative_mult" 1 :dir rl) (("" (rewrite "i_axiom") (("" (assert) (("" (rewrite "minus_add" 1) (("" (rewrite "number_fields_times_negative" 1 :dir rl) (("" (rewrite "number_fields_negate_negate" 1) (("" (rewrite "commutative_mult" 1 :dir rl) (("" (rewrite "identity_mult") (("" (lemma "sin2_cos2" ("a" "Im(x!1)")) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex_times_complex_is_complex application-judgement "complex" complex_types nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (exp const-decl "nzcomplex" exp nil) (Im_neg formula-decl nil arithmetic nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cos_neg formula-decl nil sincos_def trig_fnd) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (- const-decl "[numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (cos const-decl "real" sincos_def trig_fnd) (sin const-decl "real" sincos_def trig_fnd) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (div_cancel4 formula-decl nil number_fields_bis nil) (number_fields_negative_times formula-decl nil number_fields_bis nil) (nil application-judgement "above(n)" exp2 nil) (commutative_mult formula-decl nil number_fields nil) (sq_rew formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (associative_mult formula-decl nil number_fields nil) (real_minus_real_is_real application-judgement "real" reals nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (sin2_cos2 formula-decl nil sincos_def trig_fnd) (i_axiom formula-decl nil complex_types nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (identity_mult formula-decl nil number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (ln const-decl "real" ln_exp lnexp) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (exp_neg formula-decl nil ln_exp lnexp) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (sin_neg formula-decl nil sincos_def trig_fnd) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i const-decl "complex" complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (minus_real_is_real application-judgement "real" reals nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Re_neg formula-decl nil arithmetic nil)) shostak) (exp_negate-1 nil 3294275508 ("" (skosimp) (("" (expand "exp") (("" (rewrite "Re_neg") (("" (rewrite "Im_neg") (("" (rewrite "sin_neg") (("" (rewrite "cos_neg") (("" (rewrite "exp_neg") (("" (assert) (("" (typepred "ln_exp.exp(Re(x!1))") (("" (hide -1 -3) (("" (name-replace "R" "ln_exp.exp(Re(x!1))") (("" (rewrite "div_cancel4" 1) (("" (assert) (("" (lemma "number_fields_negative_times" ("x" "1" "y" "sin(Im(x!1))")) (("" (rewrite "identity_mult") (("" (replace -1 * rl) (("" (hide -1) (("" (assert) (("" (assert) (("" (rewrite "commutative_mult" 1 :dir rl) (("" (rewrite "commutative_mult" 1 :dir rl) (("" (assert) (("" (rewrite "sq.sq_rew") (("" (rewrite "sq.sq_rew") (("" (rewrite "associative_mult" 1 :dir rl) (("" (rewrite "i_axiom") (("" (assert) (("" (rewrite "minus_add" 1) (("" (rewrite "number_fields_times_negative" 1 :dir rl) (("" (assert) (("" (rewrite "number_fields_negate_negate" 1) (("" (rewrite "commutative_mult" 1 :dir rl) (("" (rewrite "identity_mult") (("" (lemma "sin2_cos2" ("a" "Im(x!1)")) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex_times_complex_is_complex application-judgement "complex" complex_types nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (Im_neg formula-decl nil arithmetic nil) (cos_neg formula-decl nil sincos_def trig_fnd) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (cos const-decl "real" sincos_def trig_fnd) (sin const-decl "real" sincos_def trig_fnd) (div_cancel4 formula-decl nil number_fields_bis nil) (number_fields_negative_times formula-decl nil number_fields_bis nil) (sq_rew formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (number_fields_times_negative formula-decl nil number_fields_bis nil) (sin2_cos2 formula-decl nil sincos_def trig_fnd) (number_fields_negate_negate formula-decl nil number_fields_bis nil) (i_axiom formula-decl nil complex_types nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (ln const-decl "real" ln_exp lnexp) (exp_neg formula-decl nil ln_exp lnexp) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (i const-decl "complex" complex_types nil) (sin_neg formula-decl nil sincos_def trig_fnd) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (Re_neg formula-decl nil arithmetic nil)) shostak)) (exp_minus 0 (exp_minus-1 nil 3294334655 ("" (skosimp) (("" (rewrite "minus_add") (("" (rewrite "exp_plus") (("" (rewrite "exp_negate") (("" (rewrite "commutative_mult") (("" (rewrite "div_def" 1 :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil) ((minus_add formula-decl nil number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (minus_complex_is_complex application-judgement "complex" complex_types nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (exp_negate formula-decl nil exp nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (div_def formula-decl nil number_fields nil) (commutative_mult formula-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (exp const-decl "nzcomplex" exp nil) (nzcomplex_times_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (exp_plus formula-decl nil exp nil) (- const-decl "[numfield -> numfield]" number_fields nil)) shostak)) (exp_periodicity 0 (exp_periodicity-1 nil 3295026159 ("" (skosimp) (("" (expand "exp") (("" (lemma "Re_imag" ("x" "2 * j!1 * pi")) (("" (assert) (("" (lemma "Im_imag" ("x" "2 * j!1 * pi")) (("" (assert) (("" (rewrite "Re_plus") (("" (rewrite "Im_plus") (("" (replace -1) (("" (replace -2) (("" (assert) (("" (lemma "sin_period" ("a" "Im(x!1)" "j" "j!1")) (("" (replace -1 1 rl) (("" (lemma "cos_period" ("a" "Im(x!1)" "j" "j!1")) (("" (replace -1 1 rl) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (exp const-decl "nzcomplex" exp nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (even_times_int_is_even application-judgement "even_int" integers nil) (Re_is_real application-judgement "real" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (Im_plus formula-decl nil arithmetic nil) (real_plus_real_is_real application-judgement "real" reals nil) (sin_period formula-decl nil sincos trig_fnd) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (integer nonempty-type-from-decl nil integers nil) (cos_period formula-decl nil sincos trig_fnd) (Re_plus formula-decl nil arithmetic nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (i const-decl "complex" complex_types nil) (Im_imag formula-decl nil arithmetic nil) (Re_imag formula-decl nil arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (cos const-decl "real" sincos_def trig_fnd) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd)) shostak)) (abs_exp 0 (abs_exp-2 "" 3790100364 ("" (skosimp) (("" (expand "exp") (("" (lemma "abs_mult" ("z1" "ln_exp.exp(Re(z!1))" "z2" "sin(Im(z!1)) * i + cos(Im(z!1))")) (("" (typepred "ln_exp.exp(Re(z!1))") (("" (expand "abs" -4 2) (("" (expand "conjugate") (("" (lemma "Im_real" ("x" "ln_exp.exp(Re(z!1))")) (("" (replace -1) (("" (rewrite "zero_times1") (("" (rewrite "zero_times1") (("" (lemma "Re_real" ("x" "ln_exp.exp(Re(z!1))")) (("" (replace -1) (("" (lemma "sq.sq_rew" ("a" "ln_exp.exp(Re(z!1))")) (("" (replace -1) (("" (rewrite "sqrt_sq") (("" (replace -7 1) (("" (hide -7 -1) (("" (lemma "abs_exp_imag" ("r" "Im(z!1)")) (("" (rewrite "exp_imag" -1) (("" (rewrite "commutative_mult" -1) (("" (replace -1) (("" (rewrite "commutative_mult" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sin_range application-judgement "real_abs_le1" sincos trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (exp const-decl "nzcomplex" exp nil) (NOT const-decl "[bool -> bool]" booleans nil) (Im_is_real application-judgement "real" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Re_is_real application-judgement "real" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (abs_exp_imag formula-decl nil exp nil) (commutative_mult formula-decl nil number_fields nil) (exp_imag formula-decl nil exp nil) (sqrt_pos application-judgement "posreal" sqrt reals) (sqrt_sq formula-decl nil sqrt reals) (sq_rew formula-decl nil sq reals) (Re_real formula-decl nil arithmetic nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (Im_real formula-decl nil arithmetic nil) (abs const-decl "nnreal" polar nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (abs_mult formula-decl nil polar nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (ln const-decl "real" ln_exp lnexp) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (sin const-decl "real" sincos_def trig_fnd) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (cos const-decl "real" sincos_def trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak) (abs_exp-1 nil 3294844650 ("" (skosimp) (("" (expand "exp") (("" (lemma "abs_mult" ("z1" "ln_exp.exp(Re(z!1))" "z2" "sin(Im(z!1)) * i + cos(Im(z!1))")) (("1" (typepred "ln_exp.exp(Re(z!1))") (("1" (expand "abs" -4 2) (("1" (expand "conjugate") (("1" (lemma "Im_real" ("x" "ln_exp.exp(Re(z!1))")) (("1" (replace -1) (("1" (rewrite "zero_times1") (("1" (rewrite "zero_times1") (("1" (lemma "Re_real" ("x" "ln_exp.exp(Re(z!1))")) (("1" (replace -1) (("1" (lemma "sq.sq_rew" ("a" "ln_exp.exp(Re(z!1))")) (("1" (replace -1) (("1" (rewrite "sqrt_sq") (("1" (replace -7 1) (("1" (hide -7 -1) (("1" (lemma "abs_exp_imag" ("r" "Im(z!1)")) (("1" (rewrite "exp_imag" -1) (("1" (rewrite "commutative_mult" -1) (("1" (replace -1) (("1" (rewrite "commutative_mult" 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "closed_plus") (("1" (rewrite "closed_times") (("1" (rewrite "real_is_complex") nil nil)) nil) ("2" (rewrite "real_is_complex") nil nil)) nil) ("3" (rewrite "real_is_complex") nil nil)) nil)) nil)) nil) ((sin_range application-judgement "real_abs_le1" sincos trig_fnd) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (Im_is_real application-judgement "real" complex_types nil) (Re_is_real application-judgement "real" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (sqrt_pos application-judgement "posreal" sqrt reals) (sqrt_sq formula-decl nil sqrt reals) (sq_rew formula-decl nil sq reals) (Re_real formula-decl nil arithmetic nil) (zero_times1 formula-decl nil number_fields_bis nil) (Im_real formula-decl nil arithmetic nil) (abs const-decl "nnreal" polar nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (abs_mult formula-decl nil polar nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (ln const-decl "real" ln_exp lnexp) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (sin const-decl "real" sincos_def trig_fnd) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (cos const-decl "real" sincos_def trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (ln_TCC1 0 (ln_TCC1-1 nil 3294846787 ("" (skosimp) (("" (rewrite "abs_nzcomplex") nil nil)) nil) ((abs_nzcomplex formula-decl nil polar nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil)) shostak (ln subtype "polar.abs(exp.n0z)" "posreal"))) (ln_1 0 (ln_1-1 nil 3294846944 ("" (expand "ln") (("" (expand "abs") (("" (expand "conjugate") (("" (expand "arg") (("" (rewrite "Re_real") (("" (rewrite "Im_real") (("" (rewrite "zero_times1") (("" (assert) (("" (expand "atan2") (("" (rewrite "atan_0") (("" (rewrite "zero_times1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (abs const-decl "nnreal" polar nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (arg const-decl "argrng" polar nil) (Im_real formula-decl nil arithmetic nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (odd_minus_even_is_odd application-judgement "odd_int" integers nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (sqrt_1 formula-decl nil sqrt reals) (ln_1 formula-decl nil ln_exp lnexp) (atan_0 formula-decl nil atan trig_fnd) (atan2 const-decl "real" atan2 trig_fnd) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (i const-decl "complex" complex_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (Re_real formula-decl nil arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (conjugate const-decl "complex" arithmetic nil) (Re_is_real application-judgement "real" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (ln const-decl "complex" exp nil)) shostak)) (ln_e 0 (ln_e-1 nil 3294847041 ("" (expand "ln") (("" (expand "abs") (("" (expand "conjugate") (("" (expand "arg") (("" (typepred "e") (("" (rewrite "Re_real") (("" (rewrite "Im_real") (("" (assert) (("" (expand "atan2") (("" (rewrite "atan_0") (("" (rewrite "zero_times1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((abs const-decl "nnreal" polar nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (arg const-decl "argrng" polar nil) (Re_real formula-decl nil arithmetic nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sqrt_square formula-decl nil sqrt reals) (ln_e formula-decl nil ln_exp lnexp) (atan_0 formula-decl nil atan trig_fnd) (zero_times1 formula-decl nil number_fields_bis nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (i const-decl "complex" complex_types nil) (atan2 const-decl "real" atan2 trig_fnd) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (Im_real formula-decl nil arithmetic nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (e const-decl "posreal" ln_exp lnexp) (conjugate const-decl "complex" arithmetic nil) (Re_is_real application-judgement "real" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (Im_is_real application-judgement "real" complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (ln const-decl "complex" exp nil)) shostak)) (ln_exp 0 (ln_exp-3 "" 3884617805 ("" (skosimp) (("" (expand "ln" 1) (("" (rewrite "abs_exp" 1) (("" (rewrite "ln_exp" 1) (("" (lemma "exp_plus" ("x" "Re(z!1)" "y" "Im(z!1)*i")) (("" (lemma "complex_is_Re_Im" ("z" "z!1")) (("" (replace -1 -2 rl) (("" (typepred "exp(Re(z!1))") (("" (typepred "exp(Im(z!1) * i)") (("" (hide -1 -3) (("" (lemma "arg_mult" ("n0x" "exp(Re(z!1))" "n0y" "exp((Im(z!1)-2*j!1*pi)*i)")) (("" (lemma "arg_exp_imag" ("theta" "Im(z!1)-2*j!1*pi")) (("1" (replace -1) (("1" (lemma "arg_exp_real" ("r" "Re(z!1)")) (("1" (replace -1) (("1" (lemma "exp_periodicity" ("x" "Im(z!1)*i" "j" "(-1)*j!1")) (("1" (assert) (("1" (replace -1 * LR) (("1" (assert) (("1" (replace -8 -4 rl) (("1" (replace -4 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (ln_exp-2 "" 3790100366 ("" (skosimp) (("" (expand "ln" 1) (("" (rewrite "abs_exp" 1) (("" (rewrite "ln_exp" 1) (("" (lemma "exp_plus" ("x" "Re(z!1)" "y" "Im(z!1)*i")) (("" (lemma "complex_is_Re_Im" ("z" "z!1")) (("" (replace -1 -2 rl) (("" (typepred "exp(Re(z!1))") (("" (typepred "exp(Im(z!1) * i)") (("" (hide -1 -2 -4 -5) (("" (lemma "arg_mult" ("n0x" "exp(Re(z!1))" "n0y" "exp((Im(z!1)-2*j!1*pi)*i)")) (("" (lemma "arg_exp_imag" ("theta" "Im(z!1)-2*j!1*pi")) (("1" (replace -1) (("1" (lemma "arg_exp_real" ("r" "Re(z!1)")) (("1" (replace -1) (("1" (lemma "exp_periodicity" ("x" "Im(z!1)*i" "j" "(-1)*j!1")) (("1" (assert) (("1" (replace -1 * LR) (("1" (assert) (("1" (replace -8 -4 rl) (("1" (replace -4 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (ln const-decl "complex" exp nil) (ln_exp formula-decl nil ln_exp lnexp) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (complex_is_Re_Im formula-decl nil arithmetic nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (exp const-decl "nzcomplex" exp nil) (real_minus_real_is_real application-judgement "real" reals nil) (arg_exp_imag formula-decl nil exp nil) (- const-decl "[numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (arg_exp_real formula-decl nil exp nil) (int_times_int_is_int application-judgement "int" integers nil) (exp_periodicity formula-decl nil exp nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (nil application-judgement "above(n)" exp2 nil) (nzcomplex_times_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (cos const-decl "real" sincos_def trig_fnd) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (arg_mult formula-decl nil polar nil) (real_times_real_is_real application-judgement "real" reals nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (exp_plus formula-decl nil exp nil) (Re_is_real application-judgement "real" complex_types nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (abs_exp formula-decl nil exp nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak) (ln_exp-1 nil 3294847345 ("" (skosimp) (("" (expand "ln" 1) (("" (rewrite "abs_exp" 1) (("" (rewrite "ln_exp" 1) (("" (lemma "exp_plus" ("x" "Re(z!1)" "y" "Im(z!1)*i")) (("1" (lemma "complex_is_Re_Im" ("z" "z!1")) (("1" (replace -1 -2 rl) (("1" (typepred "exp(Re(z!1))") (("1" (typepred "exp(Im(z!1) * i)") (("1" (hide -1 -2 -4 -5) (("1" (lemma "arg_mult" ("n0x" "exp(Re(z!1))" "n0y" "exp((Im(z!1)-2*j!1*pi)*i)")) (("1" (lemma "arg_exp_imag" ("theta" "Im(z!1)-2*j!1*pi")) (("1" (replace -1) (("1" (lemma "arg_exp_real" ("r" "Re(z!1)")) (("1" (replace -1) (("1" (lemma "exp_periodicity" ("x" "Im(z!1)*i" "j" "(-1)*j!1")) (("1" (assert) (("1" (replace -1 * LR) (("1" (assert) (("1" (replace -8 -4 rl) (("1" (replace -4 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) (("2" (rewrite "closed_minus") (("2" (rewrite "closed_times") (("1" (rewrite "closed_times") (("1" (rewrite "real_is_complex") nil nil) ("2" (rewrite "closed_times") (("2" (rewrite "real_is_complex") nil nil)) nil)) nil) ("2" (rewrite "real_is_complex") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "closed_times") (("2" (rewrite "real_is_complex") nil nil)) nil) ("3" (rewrite "real_is_complex") nil nil)) nil)) nil)) nil)) nil)) nil) ((pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (ln_exp formula-decl nil ln_exp lnexp) (i const-decl "complex" complex_types nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (complex_is_Re_Im formula-decl nil arithmetic nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (argrng nonempty-type-eq-decl nil polar nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (nzcomplex_times_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (arg_mult formula-decl nil polar nil) (cos const-decl "real" sincos_def trig_fnd) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (Re_is_real application-judgement "real" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) shostak)) (exp_ln 0 (exp_ln-2 "" 3790100366 ("" (skosimp) (("" (typepred "n0z!1") (("" (expand "ln") (("" (rewrite "exp_plus") (("" (rewrite "exp_real") (("" (lemma "abs_nzcomplex" ("n0z" "n0z!1")) (("" (rewrite "exp_ln" 1) (("" (rewrite "exp_imag") (("" (lemma "idempotent_polar" ("n0z" "n0z!1")) (("" (expand "polar") (("" (expand "from_polar") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzcomplex nonempty-type-eq-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (exp_plus formula-decl nil exp nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (ln const-decl "real" ln_exp lnexp) (nnreal type-eq-decl nil real_types nil) (abs const-decl "nnreal" polar nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (cos const-decl "real" sincos_def trig_fnd) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (arg const-decl "argrng" polar nil) (i const-decl "complex" complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (nzcomplex_times_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (abs_nzcomplex formula-decl nil polar nil) (exp_imag formula-decl nil exp nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (polar const-decl "[nnreal, argrng]" polar nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (from_polar const-decl "complex" polar nil) (real_times_real_is_real application-judgement "real" reals nil) (idempotent_polar formula-decl nil polar nil) (exp_ln formula-decl nil ln_exp lnexp) (exp_real formula-decl nil exp nil) (ln const-decl "complex" exp nil)) shostak) (exp_ln-1 nil 3294854711 ("" (skosimp) (("" (typepred "n0z!1") (("" (expand "ln") (("" (rewrite "exp_plus") (("1" (rewrite "exp_real") (("1" (lemma "abs_nzcomplex" ("n0z" "n0z!1")) (("1" (rewrite "exp_ln" 1) (("1" (rewrite "exp_imag") (("1" (lemma "idempotent_polar" ("n0z" "n0z!1")) (("1" (expand "polar") (("1" (expand "from_polar") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "closed_times") (("2" (rewrite "real_is_complex") nil nil)) nil) ("3" (rewrite "real_is_complex") nil nil)) nil)) nil)) nil)) nil) ((nzcomplex nonempty-type-eq-decl nil complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (ln const-decl "real" ln_exp lnexp) (abs const-decl "nnreal" polar nil) (cos const-decl "real" sincos_def trig_fnd) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (argrng nonempty-type-eq-decl nil polar nil) (arg const-decl "argrng" polar nil) (i const-decl "complex" complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (nzcomplex_times_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (abs_nzcomplex formula-decl nil polar nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (polar const-decl "[nnreal, argrng]" polar nil) (from_polar const-decl "complex" polar nil) (idempotent_polar formula-decl nil polar nil) (exp_ln formula-decl nil ln_exp lnexp)) shostak)) (ln_mult 0 (ln_mult-1 nil 3294856600 ("" (skosimp*) (("" (expand "ln") (("" (rewrite "abs_mult") (("" (rewrite "arg_mult") (("" (lemma "abs_nz_iff_nz" ("z" "n0x!1")) (("" (lemma "abs_nz_iff_nz" ("z" "n0y!1")) (("" (assert) (("" (rewrite "ln_mult") (("" (case-replace "arg(n0x!1) + arg(n0y!1) > pi") (("1" (assert) nil nil) ("2" (case-replace "arg(n0x!1) + arg(n0y!1) <= -pi") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (ln const-decl "complex" exp nil) (arg_mult formula-decl nil polar nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (abs const-decl "nnreal" polar nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (ln_mult formula-decl nil ln_exp lnexp) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (cos const-decl "real" sincos_def trig_fnd) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (arg const-decl "argrng" polar nil) (abs_nz_iff_nz formula-decl nil polar nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (abs_mult formula-decl nil polar nil)) shostak)) (ln_inv 0 (ln_inv-2 "" 3790100368 ("" (skosimp) (("" (expand "ln") (("" (rewrite "abs_inv") (("" (rewrite "arg_inv") (("" (lemma "ln_div") (("" (lemma "abs_nz_iff_nz" ("z" "n0x!1")) (("" (assert) (("" (inst - "1" "abs(n0x!1)") (("" (replace -2) (("" (case-replace "arg(n0x!1) = 0") (("1" (assert) (("1" (rewrite "zero_times1") nil nil)) nil) ("2" (assert) (("2" (case-replace "arg(n0x!1) = pi") (("1" (case-replace "2 * pi * i - pi * i = i*(2*pi-pi)") (("1" (assert) (("1" (rewrite "commutative_mult" 2) nil nil)) nil) ("2" (hide 3) (("2" (lemma "minus_add" ("x" "2*pi" "y" "pi")) (("2" (name "DRL1" "2 * pi * i - pi * i") (("2" (replace -1) (("2" (replace -2 1) (("2" (rewrite "distributive" 1) (("2" (rewrite "minus_add" -1) (("2" (replace -1 1 rl) (("2" (rewrite "commutative_mult" 1) (("2" (assert) (("2" (rewrite "number_fields_times_negative") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (assert) (("2" (rewrite "associative_mult" 3) (("2" (lemma "associative_mult" ("x" "-1" "y" "arg(n0x!1)" "z" "i")) (("2" (replace -1 3) (("2" (lemma "both_sides_times1" ("x" "-arg(n0x!1)" "n0z" "i" "y" "-1 * arg(n0x!1)")) (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "i_not_real" ("r" "0")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (ln const-decl "complex" exp nil) (arg_inv formula-decl nil polar nil) (abs_nz_iff_nz formula-decl nil polar nil) (abs const-decl "nnreal" polar nil) (nnreal type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (arg const-decl "argrng" polar nil) (argrng nonempty-type-eq-decl nil polar nil) (<= const-decl "bool" reals nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (cos const-decl "real" sincos_def trig_fnd) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (i const-decl "complex" complex_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (ln_1 formula-decl nil ln_exp lnexp) (real_minus_real_is_real application-judgement "real" reals nil) (minus_complex_is_complex application-judgement "complex" complex_types nil) (number_fields_times_negative formula-decl nil number_fields_bis nil) (real_plus_real_is_real application-judgement "real" reals nil) (distributive formula-decl nil number_fields nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_add formula-decl nil number_fields nil) (nil application-judgement "above(n)" exp2 nil) (real_times_real_is_real application-judgement "real" reals nil) (commutative_mult formula-decl nil number_fields nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (both_sides_times1 formula-decl nil number_fields_bis nil) (i_not_real formula-decl nil complex_types nil) (associative_mult formula-decl nil number_fields nil) (minus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (ln_div formula-decl nil ln_exp lnexp) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (abs_inv formula-decl nil polar nil)) shostak) (ln_inv-1 nil 3294948253 ("" (skosimp) (("" (expand "ln") (("" (rewrite "abs_inv") (("" (rewrite "arg_inv") (("" (lemma "ln_div") (("" (lemma "abs_nz_iff_nz" ("z" "n0x!1")) (("" (assert) (("" (inst - "1" "abs(n0x!1)") (("" (rewrite "ln_exp_ax.ln_1") (("" (replace -2) (("" (case-replace "arg(n0x!1) = 0") (("1" (assert) (("1" (rewrite "zero_times1") nil nil)) nil) ("2" (assert) (("2" (case-replace "arg(n0x!1) = pi") (("1" (case-replace "2 * pi * i - pi * i = i*(2*pi-pi)") (("1" (assert) (("1" (rewrite "commutative_mult" 2) nil nil)) nil) ("2" (hide 3) (("2" (lemma "minus_add" ("x" "2*pi" "y" "pi")) (("2" (name "DRL1" "2 * pi * i - pi * i") (("2" (replace -1) (("2" (replace -2 1) (("2" (rewrite "distributive" 1) (("2" (rewrite "minus_add" -1) (("2" (replace -1 1 rl) (("2" (rewrite "commutative_mult" 1) (("2" (assert) (("2" (rewrite "number_fields_times_negative") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (assert) (("2" (rewrite "associative_mult" 3) (("2" (lemma "associative_mult" ("x" "-1" "y" "arg(n0x!1)" "z" "i")) (("2" (replace -1 3) (("2" (lemma "both_sides_times1" ("x" "-arg(n0x!1)" "n0z" "i" "y" "-1 * arg(n0x!1)")) (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "i_not_real" ("r" "0")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((arg_inv formula-decl nil polar nil) (abs_nz_iff_nz formula-decl nil polar nil) (abs const-decl "nnreal" polar nil) (arg const-decl "argrng" polar nil) (argrng nonempty-type-eq-decl nil polar nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (cos const-decl "real" sincos_def trig_fnd) (i const-decl "complex" complex_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (ln_1 formula-decl nil ln_exp lnexp) (minus_complex_is_complex application-judgement "complex" complex_types nil) (number_fields_times_negative formula-decl nil number_fields_bis nil) (both_sides_times1 formula-decl nil number_fields_bis nil) (i_not_real formula-decl nil complex_types nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (ln_div formula-decl nil ln_exp lnexp) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (abs_inv formula-decl nil polar nil)) shostak)) (ln_div 0 (ln_div-2 "" 3790100368 ("" (skosimp) (("" (lemma "div_def" ("y" "n0x!1" "n0x" "n0y!1")) (("" (replace -1) (("" (lemma "inv_ne_0" ("n0x" "n0y!1")) (("" (lemma "ln_inv" ("n0x" "n0y!1")) (("" (lemma "ln_mult" ("n0x" "n0x!1" "n0y" "1/n0y!1")) (("" (replace -1) (("" (replace -2) (("" (hide-all-but (1 -3)) (("" (assert) (("" (rewrite "arg_inv") (("" (assert) (("" (case-replace "arg(n0y!1) = pi") (("1" (assert) (("1" (case "arg(n0x!1)>0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case-replace "arg(n0y!1) = 0") (("1" (assert) nil nil) ("2" (assert) (("2" (rewrite "minus_add" 3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((numfield nonempty-type-eq-decl nil number_fields nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (div_def formula-decl nil number_fields nil) (inv_ne_0 formula-decl nil number_fields_bis nil) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (ln_mult formula-decl nil exp nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (nil application-judgement "above(n)" exp2 nil) (minus_real_is_real application-judgement "real" reals nil) (minus_add formula-decl nil number_fields nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (cos const-decl "real" sincos_def trig_fnd) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (arg const-decl "argrng" polar nil) (arg_inv formula-decl nil polar nil) (ln_inv formula-decl nil exp nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil)) shostak) (ln_div-1 nil 3295030968 ("" (skosimp) (("" (lemma "div_def" ("y" "n0x!1" "n0x" "n0y!1")) (("" (replace -1) (("" (lemma "inv_ne_0" ("n0x" "n0y!1")) (("" (lemma "ln_inv" ("n0x" "n0y!1")) (("" (lemma "ln_mult" ("n0x" "n0x!1" "n0y" "1/n0y!1")) (("" (replace -1) (("" (replace -2) (("" (hide-all-but (1 -3)) (("" (assert) (("" (rewrite "arg_inv") (("" (assert) (("" (case-replace "arg(n0y!1) = pi") (("1" (assert) (("1" (case "arg(n0x!1)>0") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "number_fields_negative_times" ("x" "1" "y" "-2*i*pi")) (("2" (rewrite "identity_mult" -1) (("2" (rewrite "number_fields_negative_times" -1 :dir rl) (("2" (rewrite "number_fields_negate_negate") (("2" (replace -1 2 rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "arg(n0y!1) = 0") (("1" (assert) nil nil) ("2" (assert) (("2" (assert) (("2" (rewrite "minus_add" 3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzcomplex nonempty-type-eq-decl nil complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (inv_ne_0 formula-decl nil number_fields_bis nil) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (cos const-decl "real" sincos_def trig_fnd) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (argrng nonempty-type-eq-decl nil polar nil) (arg const-decl "argrng" polar nil) (arg_inv formula-decl nil polar nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil)) shostak)))
