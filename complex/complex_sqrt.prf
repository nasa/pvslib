(complex_sqrt (sqrt_TCC1 0 (sqrt_TCC1-1 nil 3385156197 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (sqrt subtype "number_fields./(polar.arg(complex_sqrt.z), 2)" "argrng"))) (sqrt_nz_is_nz 0 (sqrt_nz_is_nz-1 nil 3385156197 ("" (skosimp) (("" (expand "sqrt") (("" (expand "from_polar") (("" (lemma "unique_characterization" ("y0" "sin(arg(n0z!1) / 2) * sqrt.sqrt(abs(n0z!1))" "x0" "sqrt.sqrt(abs(n0z!1)) * cos(arg(n0z!1) / 2)" "x1" "0" "y1" "0")) (("" (rewrite "zero_times1") (("" (replace -1 -2) (("" (flatten) (("" (hide -1 -2) (("" (lemma "abs_nzcomplex" ("n0z" "n0z!1")) (("" (lemma "sqrt_pos" ("px" "abs(n0z!1)")) (("1" (name-replace "R" "sqrt.sqrt(abs(n0z!1))") (("1" (rewrite "zero_times3" -3) (("1" (assert) (("1" (rewrite "cos_eq_0" -3) (("1" (skosimp) (("1" (replace -3) (("1" (hide -3) (("1" (rewrite "sin_k_pi2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sqrt const-decl "complex" complex_sqrt nil) (sin const-decl "real" sincos_def trig_fnd) (arg const-decl "argrng" polar nil) (argrng nonempty-type-eq-decl nil polar nil) (<= const-decl "bool" reals nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (> const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (cos const-decl "real" sincos_def trig_fnd) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (abs const-decl "nnreal" polar nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (= const-decl "[T, T -> boolean]" equalities nil) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (unique_characterization formula-decl nil complex_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (sqrt_pos judgement-tcc nil sqrt reals) (posreal nonempty-type-eq-decl nil real_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (zero_times3 formula-decl nil number_fields_bis nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (cos_eq_0 formula-decl nil sincos trig_fnd) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (int nonempty-type-eq-decl nil integers nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (sin_k_pi2 formula-decl nil sincos trig_fnd) (nil application-judgement "above(n)" exp2 nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (rat_exp application-judgement "rat" exponentiation nil) (abs_nzcomplex formula-decl nil polar nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (i const-decl "complex" complex_types nil) (from_polar const-decl "complex" polar nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (sqrt_nz_is_nz subtype "complex_sqrt.sqrt(complex_sqrt.n0z)" "nzcomplex"))) (sqrt_nnz 0 (sqrt_nnz-2 "" 3790100370 ("" (skosimp) (("" (expand "sqrt") (("" (expand "abs") (("" (expand "conjugate") (("" (expand "arg") (("" (rewrite "Re_real") (("" (rewrite "Im_real") (("" (rewrite "zero_times1") (("" (rewrite "zero_times1") (("" (expand "atan2") (("" (assert) (("" (expand "from_polar") (("" (rewrite "sin_0") (("" (rewrite "cos_0") (("" (rewrite "zero_times1") (("" (rewrite "zero_times1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sqrt const-decl "complex" complex_sqrt nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Re_is_real application-judgement "real" complex_types nil) (real_times_real_is_real application-judgement "real" reals nil) (conjugate const-decl "complex" arithmetic nil) (Re_real formula-decl nil arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (i const-decl "complex" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (atan2 const-decl "real" atan2 trig_fnd) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (from_polar const-decl "complex" polar nil) (cos_0 formula-decl nil sincos_def trig_fnd) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (sin_0 formula-decl nil sincos_def trig_fnd) (atan_0 formula-decl nil atan trig_fnd) (sqrt_square formula-decl nil sqrt reals) (real_div_nzreal_is_real application-judgement "real" reals nil) (Im_real formula-decl nil arithmetic nil) (arg const-decl "argrng" polar nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (abs const-decl "nnreal" polar nil)) shostak) (sqrt_nnz-1 nil 3385196945 ("" (skosimp) (("" (expand "sqrt") (("" (expand "abs") (("" (expand "conjugate") (("" (expand "arg") (("" (rewrite "Re_real") (("" (rewrite "Im_real") (("" (rewrite "zero_times1") (("" (rewrite "zero_times1") (("" (expand "atan2") (("" (assert) (("" (rewrite "atan_0") (("" (lift-if) (("" (expand "from_polar") (("" (rewrite "sin_0") (("" (rewrite "cos_0") (("" (rewrite "zero_times1") (("" (rewrite "zero_times1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex_times_complex_is_complex application-judgement "complex" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (Re_is_real application-judgement "real" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (Re_real formula-decl nil arithmetic nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (i const-decl "complex" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (atan2 const-decl "real" atan2 trig_fnd) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (from_polar const-decl "complex" polar nil) (cos_0 formula-decl nil sincos_def trig_fnd) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (sin_0 formula-decl nil sincos_def trig_fnd) (atan_0 formula-decl nil atan trig_fnd) (sqrt_square formula-decl nil sqrt reals) (Im_real formula-decl nil arithmetic nil) (arg const-decl "argrng" polar nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (abs const-decl "nnreal" polar nil)) shostak)) (sqrt_npz_TCC1 0 (sqrt_npz_TCC1-1 nil 3385196849 ("" (skosimp) (("" (typepred "npx!1") (("" (assert) nil nil)) nil)) nil) ((npreal type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil)) nil (sqrt_npz subtype "(number_fields.-)(complex_sqrt.npx)" "nonneg_real"))) (sqrt_npz 0 (sqrt_npz-1 nil 3385197188 ("" (skosimp) (("" (expand "sqrt") (("" (expand "abs") (("" (expand "conjugate") (("" (expand "arg") (("" (rewrite "Re_real") (("" (rewrite "Im_real") (("" (rewrite "zero_times1") (("" (rewrite "zero_times1") (("" (assert) (("" (lift-if) (("" (assert) (("" (expand "from_polar") (("" (prop) (("1" (assert) (("1" (rewrite "sin_0") (("1" (rewrite "cos_0") (("1" (rewrite "zero_times1") (("1" (rewrite "zero_times1") (("1" (replace -1) (("1" (rewrite "sqrt.sqrt_0") (("1" (rewrite "zero_times2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "atan2") (("2" (rewrite "atan_0") (("2" (rewrite "sin_pi2") (("2" (rewrite "cos_pi2") (("2" (rewrite "identity_mult") (("2" (rewrite "zero_times2") (("2" (lemma "sqrt_sq_neg" ("x" "npx!1")) (("2" (split -1) (("1" (expand "sq") (("1" (replace -1) (("1" (assert) (("1" (rewrite "commutative_mult" 2) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sqrt const-decl "complex" complex_sqrt nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Re_is_real application-judgement "real" complex_types nil) (real_times_real_is_real application-judgement "real" reals nil) (conjugate const-decl "complex" arithmetic nil) (Re_real formula-decl nil arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (<= const-decl "bool" reals nil) (npreal type-eq-decl nil real_types nil) (npreal_times_npreal_is_nnreal application-judgement "nnreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (i const-decl "complex" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (minus_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (sqrt_square formula-decl nil sqrt reals) (sin_0 formula-decl nil sincos_def trig_fnd) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (zero_times2 formula-decl nil number_fields_bis nil) (sqrt_0 formula-decl nil sqrt reals) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (cos_0 formula-decl nil sincos_def trig_fnd) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (atan2 const-decl "real" atan2 trig_fnd) (sin_pi2 formula-decl nil sincos trig_fnd) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (identity_mult formula-decl nil number_fields nil) (sqrt_sq_neg formula-decl nil sqrt reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sq const-decl "nonneg_real" sq reals) (commutative_mult formula-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (cos_pi2 formula-decl nil sincos trig_fnd) (atan_0 formula-decl nil atan trig_fnd) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (from_polar const-decl "complex" polar nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (Im_real formula-decl nil arithmetic nil) (arg const-decl "argrng" polar nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (abs const-decl "nnreal" polar nil)) shostak)) (sqrt_0 0 (sqrt_0-1 nil 3385156772 ("" (expand "sqrt") (("" (expand "abs") (("" (expand "arg") (("" (expand "conjugate") (("" (rewrite "sqrt_0") (("" (rewrite "sqrt_0") (("" (expand "from_polar") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (abs const-decl "nnreal" polar nil) (Im_is_real application-judgement "real" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (from_polar const-decl "complex" polar nil) (sqrt_0 formula-decl nil sqrt reals) (arg const-decl "argrng" polar nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (sqrt const-decl "complex" complex_sqrt nil)) shostak)) (sqrt_1 0 (sqrt_1-1 nil 3385156811 ("" (expand "sqrt") (("" (expand "abs") (("" (expand "conjugate") (("" (expand "arg") (("" (rewrite "Re_real") (("" (rewrite "Im_real") (("" (rewrite "zero_times1") (("" (assert) (("" (expand "atan2") (("" (rewrite "atan_0") (("" (expand "from_polar") (("" (rewrite "cos_0") (("" (rewrite "sin_0") (("" (rewrite "zero_times1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (abs const-decl "nnreal" polar nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (arg const-decl "argrng" polar nil) (Im_real formula-decl nil arithmetic nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (odd_minus_even_is_odd application-judgement "odd_int" integers nil) (sqrt_1 formula-decl nil sqrt reals) (atan_0 formula-decl nil atan trig_fnd) (cos_0 formula-decl nil sincos_def trig_fnd) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (sin_0 formula-decl nil sincos_def trig_fnd) (from_polar const-decl "complex" polar nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (atan2 const-decl "real" atan2 trig_fnd) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (zero_times1 formula-decl nil number_fields_bis nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (i const-decl "complex" complex_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (Re_real formula-decl nil arithmetic nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (conjugate const-decl "complex" arithmetic nil) (Re_is_real application-judgement "real" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (sqrt const-decl "complex" complex_sqrt nil)) shostak)) (sqrt_neg1 0 (sqrt_neg1-1 nil 3385197557 ("" (lemma "sqrt_npz" ("npx" "-1")) (("" (assert) nil nil)) nil) ((sqrt_1 formula-decl nil sqrt reals) (nil application-judgement "above(n)" exp2 nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (sqrt_nz_is_nz application-judgement "nzcomplex" complex_sqrt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sqrt_npz formula-decl nil complex_sqrt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (<= const-decl "bool" reals nil) (npreal type-eq-decl nil real_types nil)) shostak)) (sqrt_eq_0 0 (sqrt_eq_0-1 nil 3385156991 ("" (skosimp) (("" (split) (("1" (flatten) (("1" (lemma "sqrt_nz_is_nz" ("n0z" "z!1")) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (replace -1) (("2" (rewrite "sqrt_0") nil nil)) nil)) nil)) nil)) nil) ((nzcomplex nonempty-type-eq-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (sqrt_nz_is_nz judgement-tcc nil complex_sqrt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sqrt_0 formula-decl nil complex_sqrt nil)) shostak)) (sqrt_sq_TCC1 0 (sqrt_sq_TCC1-1 nil 3385192826 ("" (subtype-tcc) nil nil) ((sq const-decl "numfield" number_fields_sq nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil)) nil (sqrt_sq subtype "number_fields_sq.sq(complex_sqrt.z)" "complex"))) (sqrt_sq 0 (sqrt_sq-1 nil 3385193372 ("" (skosimp) (("" (lift-if) (("" (expand "sqrt") (("" (expand "sq") (("" (rewrite "abs_mult") (("" (rewrite "sq.sq_rew") (("" (rewrite "sqrt_sq") (("" (case-replace "z!1=0") (("1" (expand "arg") (("1" (assert) (("1" (expand "abs") (("1" (expand "conjugate") (("1" (rewrite "sqrt.sqrt_0") (("1" (expand "from_polar") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "arg_mult" ("n0x" "z!1" "n0y" "z!1")) (("1" (assert) (("1" (prop) (("1" (assert) (("1" (replace -3) (("1" (lemma "div_cancel1" ("x" "arg(z!1)" "n0z" "2")) (("1" (assert) (("1" (replace -1 1) (("1" (lemma "idempotent_polar" ("n0z" "z!1")) (("1" (expand "polar") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -1) (("2" (lemma "div_cancel1" ("x" "arg(z!1)+pi" "n0z" "2")) (("2" (replace -1 2) (("2" (lemma "minus_nznum_is_nznum" ("nzx" "z!1")) (("2" (lemma "idempotent_polar" ("n0z" "-z!1")) (("1" (expand "polar") (("1" (rewrite "arg_neg") (("1" (rewrite "abs_neg") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "minus_nznum_is_nznum" ("nzx" "z!1")) (("3" (lemma "idempotent_polar" ("n0z" "-z!1")) (("1" (expand "polar") (("1" (rewrite "abs_neg") (("1" (rewrite "arg_neg") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sq const-decl "numfield" number_fields_sq nil) (sq_rew formula-decl nil sq reals) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (abs const-decl "nnreal" polar nil) (= const-decl "[T, T -> boolean]" equalities nil) (Im_is_real application-judgement "real" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (from_polar const-decl "complex" polar nil) (sqrt_0 formula-decl nil sqrt reals) (arg const-decl "argrng" polar nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_complex_is_complex application-judgement "complex" complex_types nil) (real_times_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_nznum_is_nznum judgement-tcc nil number_fields_bis nil) (abs_neg formula-decl nil polar nil) (arg_neg formula-decl nil polar nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (div_cancel1 formula-decl nil number_fields_bis nil) (nznum nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (cos const-decl "real" sincos_def trig_fnd) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (polar const-decl "[nnreal, argrng]" polar nil) (idempotent_polar formula-decl nil polar nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (arg_mult formula-decl nil polar nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sqrt_sq formula-decl nil sqrt reals) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (abs_mult formula-decl nil polar nil) (sqrt const-decl "complex" complex_sqrt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd)) shostak)) (sq_sqrt 0 (sq_sqrt-1 nil 3385159230 ("" (skosimp) (("" (expand "sqrt") (("" (case-replace "z!1=0") (("1" (expand "sq") (("1" (expand "abs") (("1" (expand "conjugate") (("1" (expand "arg") (("1" (rewrite "sqrt.sqrt_0") (("1" (rewrite "sqrt.sqrt_0") (("1" (expand "from_polar") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "abs_nzcomplex" ("n0z" "z!1")) (("2" (expand "arg") (("2" (expand "from_polar") (("2" (expand "sq") (("2" (case-replace "Im(z!1) < 0") (("1" (rewrite "sq.sq_rew" 2) (("1" (assert) (("1" (assert) (("1" (case-replace "cos((atan2(Re(z!1), Im(z!1)) - 2 * pi) / 2) *
               sin((atan2(Re(z!1), Im(z!1)) - 2 * pi) / 2) = sin(atan2(Re(z!1), Im(z!1)) - 2 * pi)/2") (("1" (hide -1) (("1" (case-replace "sin((atan2(Re(z!1), Im(z!1)) - 2 * pi) / 2) *
                sin((atan2(Re(z!1), Im(z!1)) - 2 * pi) / 2)= (1-cos(atan2(Re(z!1), Im(z!1)) - 2 * pi))/2") (("1" (hide -1) (("1" (lemma "idempotent_polar" ("n0z" "z!1")) (("1" (expand "polar") (("1" (expand "from_polar") (("1" (expand "arg") (("1" (name-replace "TH" "atan2(Re(z!1), Im(z!1)) - 2 * pi") (("1" (assert) (("1" (expand "sq" 2) (("1" (case-replace "cos(TH / 2) * cos(TH / 2)=(cos(TH)+1)/2") (("1" (assert) (("1" (rewrite "sq.sq_rew" 2) (("1" (rewrite "times_div1" 2) (("1" (rewrite "times_div2" 2) (("1" (rewrite "div_cancel1" 2) (("1" (name-replace "DRL1" "abs(z!1) * sin(TH) * i") (("1" (rewrite "minus_div2" 2 :dir rl) (("1" (rewrite "div_distributes" 2 :dir rl) (("1" (hide -1) (("1" (lemma "both_sides_times2" ("n0z" "abs(z!1)" "x" "cos(TH)" "y" "(1 / 2 - cos(TH) / 2) * i * i+((1 / 2) + (cos(TH) / 2))")) (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (replace -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide 3 -1) (("2" (assert) (("2" (lemma "associative_mult" ("y" "i" "z" "i")) (("2" (inst-cp - "1/2") (("2" (inst - "cos(TH)/2") (("2" (lemma "i_axiom") (("2" (replace -1) (("2" (replace -2 1 rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "cos_2a_cos" ("a" "TH/2")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (name-replace "TH" "atan2(Re(z!1), Im(z!1)) - 2 * pi") (("2" (lemma "cos_2a_sin" ("a" "TH/2")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (name-replace "TH" "atan2(Re(z!1), Im(z!1)) - 2 * pi") (("2" (lemma "sin_2a" ("a" "TH/2")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "cos(atan2(Re(z!1), Im(z!1)) / 2) * sin(atan2(Re(z!1), Im(z!1)) / 2) = sin(atan2(Re(z!1), Im(z!1)))/2") (("1" (hide -1) (("1" (case-replace "sin(atan2(Re(z!1), Im(z!1)) / 2) * sin(atan2(Re(z!1), Im(z!1)) / 2) = (1-cos(atan2(Re(z!1), Im(z!1))))/2") (("1" (hide -1) (("1" (case-replace "cos(atan2(Re(z!1), Im(z!1)) / 2) * cos(atan2(Re(z!1), Im(z!1)) / 2) = (cos(atan2(Re(z!1), Im(z!1)))+1)/2") (("1" (hide -1) (("1" (assert) (("1" (rewrite "sq.sq_rew") (("1" (lemma "complex_is_ne_0_Re_Im" ("z" "z!1")) (("1" (assert) (("1" (lemma "sin_atan2" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (lemma "cos_atan2" ("x" "Re(z!1)" "y" "Im(z!1)")) (("1" (assert) (("1" (replace -3) (("1" (case-replace "2 * (abs(z!1) * (sin(atan2(Re(z!1), Im(z!1))) / 2) * i) +
                   abs(z!1) * ((1 - cos(atan2(Re(z!1), Im(z!1)))) / 2) * i * i
                   + abs(z!1) * ((1 + cos(atan2(Re(z!1), Im(z!1)))) / 2) = abs(z!1)*(sin(atan2(Re(z!1), Im(z!1)))*i + cos(atan2(Re(z!1), Im(z!1))))") (("1" (hide -1) (("1" (case-replace "Re(z!1)=0") (("1" (replace -2) (("1" (assert) (("1" (lemma "complex_is_Re_Im" ("z" "z!1")) (("1" (replace -2) (("1" (assert) (("1" (replace -4) (("1" (assert) (("1" (case-replace "abs(z!1)=Im(z!1)") (("1" (assert) nil nil) ("2" (expand "abs") (("2" (expand "conjugate") (("2" (replace -2) (("2" (rewrite "zero_times1") (("2" (case-replace "0 - Im(z!1) * i * z!1 = sq(Im(z!1))") (("1" (lemma "sqrt.sqrt_sq") (("1" (inst - "Im(z!1)") (("1" (split -1) (("1" (expand "sq") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "sq") (("2" (name-replace "IMMM" "Im(z!1)") (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (rewrite "sq_rew") (("2" (rewrite "sq_times") (("2" (rewrite "sq_rew") (("2" (case-replace "sq(i)=-1") (("1" (assert) (("1" (expand "sq") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "sq") (("2" (lemma "i_axiom") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "idempotent_polar" ("n0z" "z!1")) (("2" (expand "from_polar") (("2" (expand "polar") (("2" (expand "arg") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (name-replace "ATT" "atan2(Re(z!1), Im(z!1))") (("2" (name-replace "ABS" "abs(z!1)") (("2" (name-replace "S" "sin(ATT)") (("2" (name-replace "COSATT" "cos(ATT)") (("2" (assert) (("2" (rewrite "times_div1") (("2" (rewrite "times_div2") (("2" (rewrite "div_cancel1") (("2" (rewrite "minus_div2" 1 :dir rl) (("2" (rewrite "div_distributes" 1 :dir rl) (("2" (rewrite "distributive") (("2" (rewrite "associative_mult" 1 :dir rl) (("2" (assert) (("2" (lemma "i_axiom") (("2" (lemma "associative_mult") (("2" (inst-cp - "ABS" "i" "i") (("2" (replace -3) (("2" (replace -2 1 rl) (("2" (inst - "(ABS*(COSATT/2))" "i" "i") (("2" (replace -3) (("2" (replace -1 * rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (name-replace "TH" "atan2(Re(z!1), Im(z!1))") (("2" (lemma "cos_2a_cos" ("a" "TH/2")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (name-replace "TH" "atan2(Re(z!1), Im(z!1))") (("2" (lemma "cos_2a_sin" ("a" "TH/2")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (name-replace "TH" "atan2(Re(z!1), Im(z!1))") (("2" (lemma "sin_2a" ("a" "TH/2")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sqrt const-decl "complex" complex_sqrt nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (real_div_nzreal_is_real application-judgement "real" reals nil) (cos_atan2 formula-decl nil atan2 trig_fnd) (distributive formula-decl nil number_fields nil) (<= const-decl "bool" reals nil) (real_abs_le1 nonempty-type-eq-decl nil trig_types trig_fnd) (nnreal_lt_2pi nonempty-type-eq-decl nil trig_types trig_fnd) (complex_is_Re_Im formula-decl nil arithmetic nil) (sqrt_sq formula-decl nil sqrt reals) (sq_times formula-decl nil number_fields_sq nil) (sq_rew formula-decl nil number_fields_sq nil) (zero_times1 formula-decl nil number_fields_bis nil) (sqrt_pos application-judgement "posreal" sqrt reals) (sin_atan2 formula-decl nil atan2 trig_fnd) (complex_is_ne_0_Re_Im formula-decl nil arithmetic nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Re const-decl "{x | EXISTS y: z = x + y * i}" complex_types nil) (atan2 const-decl "real" atan2 trig_fnd) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (cos const-decl "real" sincos_def trig_fnd) (sq_rew formula-decl nil sq reals) (real_times_real_is_real application-judgement "real" reals nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (real_minus_real_is_real application-judgement "real" reals nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (sin_2a formula-decl nil trig_basic trig_fnd) (cos_2a_sin formula-decl nil trig_basic trig_fnd) (polar const-decl "[nnreal, argrng]" polar nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (sq_sqrt formula-decl nil sqrt reals) (times_div2 formula-decl nil number_fields_bis nil) (complex_div_nzcomplex_is_complex application-judgement "complex" complex_types nil) (div_distributes formula-decl nil number_fields_bis nil) (both_sides_times2 formula-decl nil number_fields_bis nil) (associative_mult formula-decl nil number_fields nil) (nil application-judgement "above(n)" exp2 nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (i_axiom formula-decl nil complex_types nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (minus_div2 formula-decl nil number_fields_bis nil) (div_cancel1 formula-decl nil number_fields_bis nil) (times_div1 formula-decl nil number_fields_bis nil) (real_plus_real_is_real application-judgement "real" reals nil) (cos_2a_cos formula-decl nil trig_basic trig_fnd) (sq const-decl "nonneg_real" sq reals) (idempotent_polar formula-decl nil polar nil) (sin const-decl "real" sincos_def trig_fnd) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (i const-decl "complex" complex_types nil) (Im const-decl "{y | EXISTS x: z = x + y * i}" complex_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (abs_nzcomplex formula-decl nil polar nil) (sq const-decl "numfield" number_fields_sq nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (Im_is_real application-judgement "real" complex_types nil) (conjugate const-decl "complex" arithmetic nil) (sqrt_0 formula-decl nil sqrt reals) (from_polar const-decl "complex" polar nil) (arg const-decl "argrng" polar nil) (abs const-decl "nnreal" polar nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (sqrt_times 0 (sqrt_times-2 "" 3790100383 ("" (skosimp) (("" (case-replace "x!1=0") (("1" (rewrite "zero_times1") (("1" (rewrite "sqrt_0") (("1" (rewrite "zero_times1") (("1" (lift-if) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (case-replace "y!1=0") (("1" (rewrite "zero_times2") (("1" (rewrite "sqrt_0") (("1" (rewrite "zero_times2") (("1" (rewrite "zero_times2") (("1" (lift-if) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "arg_mult" ("n0x" "x!1" "n0y" "y!1")) (("1" (assert) (("1" (expand "sqrt") (("1" (rewrite "abs_mult") (("1" (rewrite "sqrt_times") (("1" (name-replace "RX" "sqrt.sqrt(abs(x!1))") (("1" (name-replace "RY" "sqrt.sqrt(abs(y!1))") (("1" (name-replace "TX" "arg(x!1)") (("1" (name-replace "TY" "arg(y!1)") (("1" (case-replace "TX + TY > pi") (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (hide -2) (("1" (case-replace "(TX - 2 * pi + TY) / 2 = TX/2+TY/2-pi") (("1" (hide -1) (("1" (expand "from_polar") (("1" (rewrite "sin_minus") (("1" (rewrite "cos_minus") (("1" (rewrite "cos_pi") (("1" (rewrite "sin_pi") (("1" (rewrite "zero_times1") (("1" (assert) (("1" (rewrite "cos_plus") (("1" (rewrite "sin_plus") (("1" (lemma "number_fields_negative_times" ("x" "1" "y" "sin(TX / 2) * RX * i + RX * cos(TX / 2)")) (("1" (rewrite "identity_mult" -1) (("1" (replace -1 3 rl) (("1" (hide -1) (("1" (assert) (("1" (name-replace "DRL1" "sin(TX / 2) * sin(TY / 2) * RX * RY") (("1" (rewrite "associative_mult" 3 :dir rl) (("1" (rewrite "i_axiom") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "TX + TY <= -pi") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (case-replace "(TX + TY + 2 * pi) / 2 = TX/2+TY/2+pi") (("1" (hide -1) (("1" (expand "from_polar") (("1" (rewrite "sin_plus") (("1" (rewrite "sin_plus") (("1" (rewrite "cos_plus") (("1" (rewrite "cos_plus") (("1" (rewrite "cos_pi") (("1" (rewrite "sin_pi") (("1" (rewrite "zero_times2") (("1" (assert) (("1" (rewrite "cos_plus") (("1" (lemma "number_fields_negative_times" ("x" "1" "y" "sin(TX / 2) * RX * i + RX * cos(TX / 2)")) (("1" (rewrite "identity_mult" -1) (("1" (replace -1 4 rl) (("1" (assert) (("1" (name-replace "DRL1" "sin(TX / 2) * sin(TY / 2) * RX * RY") (("1" (rewrite "associative_mult" 4 :dir rl) (("1" (rewrite "i_axiom") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (rewrite "div_distributes" 5 :dir rl) (("2" (expand "from_polar") (("2" (rewrite "sin_plus") (("2" (rewrite "cos_plus") (("2" (assert) (("2" (name-replace "DRL101" "sin((TX / 2)) * sin((TY / 2)) * RX * RY") (("2" (rewrite "associative_mult" 5 :dir rl) (("2" (rewrite "i_axiom") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (minus_complex_is_complex application-judgement "complex" complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (sqrt_0 formula-decl nil complex_sqrt nil) (sqrt const-decl "complex" complex_sqrt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (zero_times1 formula-decl nil number_fields_bis nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (arg_mult formula-decl nil polar nil) (abs const-decl "nnreal" polar nil) (nnreal type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (sqrt_times formula-decl nil sqrt reals) (div_distributes formula-decl nil number_fields_bis nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (from_polar const-decl "complex" polar nil) (cos_minus formula-decl nil sincos trig_fnd) (sin_pi formula-decl nil sincos trig_fnd) (sin_plus formula-decl nil sincos trig_fnd) (identity_mult formula-decl nil number_fields nil) (i_axiom formula-decl nil complex_types nil) (associative_mult formula-decl nil number_fields nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (i const-decl "complex" complex_types nil) (sin const-decl "real" sincos_def trig_fnd) (number_fields_negative_times formula-decl nil number_fields_bis nil) (cos_plus formula-decl nil sincos trig_fnd) (nil application-judgement "above(n)" exp2 nil) (cos_pi formula-decl nil sincos trig_fnd) (sin_minus formula-decl nil sincos trig_fnd) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (cos const-decl "real" sincos_def trig_fnd) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (arg const-decl "argrng" polar nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (abs_mult formula-decl nil polar nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (zero_times2 formula-decl nil number_fields_bis nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil)) shostak) (sqrt_times-1 nil 3385198032 ("" (skosimp) (("" (case-replace "x!1=0") (("1" (rewrite "zero_times1") (("1" (rewrite "sqrt_0") (("1" (rewrite "zero_times1") (("1" (lift-if) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (case-replace "y!1=0") (("1" (rewrite "zero_times2") (("1" (rewrite "sqrt_0") (("1" (rewrite "zero_times2") (("1" (rewrite "zero_times2") (("1" (lift-if) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "arg_mult" ("n0x" "x!1" "n0y" "y!1")) (("1" (assert) (("1" (expand "sqrt") (("1" (rewrite "abs_mult") (("1" (rewrite "sqrt_times") (("1" (name-replace "RX" "sqrt.sqrt(abs(x!1))") (("1" (name-replace "RY" "sqrt.sqrt(abs(y!1))") (("1" (name-replace "TX" "arg(x!1)") (("1" (name-replace "TY" "arg(y!1)") (("1" (case-replace "TX + TY > pi") (("1" (assert) (("1" (replace -2) (("1" (assert) (("1" (hide -2) (("1" (case-replace "(TX - 2 * pi + TY) / 2 = TX/2+TY/2-pi") (("1" (hide -1) (("1" (expand "from_polar") (("1" (rewrite "sin_minus") (("1" (rewrite "cos_minus") (("1" (rewrite "cos_pi") (("1" (rewrite "sin_pi") (("1" (rewrite "zero_times1") (("1" (assert) (("1" (rewrite "cos_plus") (("1" (rewrite "sin_plus") (("1" (lemma "number_fields_negative_times" ("x" "1" "y" "sin(TX / 2) * RX * i + RX * cos(TX / 2)")) (("1" (rewrite "identity_mult" -1) (("1" (replace -1 3 rl) (("1" (hide -1) (("1" (assert) (("1" (name-replace "DRL1" "sin(TX / 2) * sin(TY / 2) * RX * RY") (("1" (rewrite "associative_mult" 3 :dir rl) (("1" (rewrite "i_axiom") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "TX + TY <= -pi") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (case-replace "(TX + TY + 2 * pi) / 2 = TX/2+TY/2+pi") (("1" (hide -1) (("1" (expand "from_polar") (("1" (rewrite "sin_plus") (("1" (rewrite "sin_plus") (("1" (rewrite "cos_plus") (("1" (rewrite "cos_plus") (("1" (rewrite "cos_pi") (("1" (rewrite "sin_pi") (("1" (rewrite "zero_times2") (("1" (assert) (("1" (rewrite "cos_plus") (("1" (lemma "number_fields_negative_times" ("x" "1" "y" "sin(TX / 2) * RX * i + RX * cos(TX / 2)")) (("1" (rewrite "identity_mult" -1) (("1" (replace -1 4 rl) (("1" (assert) (("1" (name-replace "DRL1" "sin(TX / 2) * sin(TY / 2) * RX * RY") (("1" (rewrite "associative_mult" 4 :dir rl) (("1" (rewrite "i_axiom") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (assert) (("2" (rewrite "div_distributes" 5 :dir rl) (("2" (expand "from_polar") (("2" (rewrite "sin_plus") (("2" (rewrite "cos_plus") (("2" (assert) (("2" (name-replace "DRL101" "sin((TX / 2)) * sin((TY / 2)) * RX * RY") (("2" (rewrite "associative_mult" 5 :dir rl) (("2" (rewrite "i_axiom") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (minus_complex_is_complex application-judgement "complex" complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (zero_times1 formula-decl nil number_fields_bis nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (arg_mult formula-decl nil polar nil) (abs const-decl "nnreal" polar nil) (sqrt_times formula-decl nil sqrt reals) (div_distributes formula-decl nil number_fields_bis nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (from_polar const-decl "complex" polar nil) (cos_minus formula-decl nil sincos trig_fnd) (sin_pi formula-decl nil sincos trig_fnd) (sin_plus formula-decl nil sincos trig_fnd) (i_axiom formula-decl nil complex_types nil) (complex_minus_complex_is_complex application-judgement "complex" complex_types nil) (i const-decl "complex" complex_types nil) (sin const-decl "real" sincos_def trig_fnd) (number_fields_negative_times formula-decl nil number_fields_bis nil) (cos_plus formula-decl nil sincos trig_fnd) (cos_pi formula-decl nil sincos trig_fnd) (sin_minus formula-decl nil sincos trig_fnd) (cos const-decl "real" sincos_def trig_fnd) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (argrng nonempty-type-eq-decl nil polar nil) (arg const-decl "argrng" polar nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (abs_mult formula-decl nil polar nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (zero_times2 formula-decl nil number_fields_bis nil)) shostak)) (sqrt_neg 0 (sqrt_neg-2 "" 3790100384 ("" (skosimp) (("" (lemma "sqrt_times" ("x" "-1" "y" "z!1")) (("" (rewrite "sqrt_neg1") (("" (rewrite "number_fields_negative_times" -1) (("" (rewrite "identity_mult" -1) (("" (expand "arg" -1 1) (("" (expand "arg" -1 2) (("" (rewrite "Re_real") (("" (rewrite "Im_real") (("" (assert) (("" (expand "atan2") (("" (rewrite "atan_0") (("" (assert) (("" (case-replace "arg(z!1) <= 0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (sqrt_times formula-decl nil complex_sqrt nil) (number_fields_negative_times formula-decl nil number_fields_bis nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (arg const-decl "argrng" polar nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Re_real formula-decl nil arithmetic nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (atan_0 formula-decl nil atan trig_fnd) (argrng nonempty-type-eq-decl nil polar nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (cos const-decl "real" sincos_def trig_fnd) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (atan2 const-decl "real" atan2 trig_fnd) (Im_real formula-decl nil arithmetic nil) (identity_mult formula-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (minus_complex_is_complex application-judgement "complex" complex_types nil) (minus_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (sqrt_nz_is_nz application-judgement "nzcomplex" complex_sqrt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (sqrt_neg1 formula-decl nil complex_sqrt nil)) shostak) (sqrt_neg-1 nil 3385196467 ("" (skosimp) (("" (lemma "sqrt_times" ("x" "-1" "y" "z!1")) (("1" (rewrite "sqrt_neg1") (("1" (rewrite "number_fields_negative_times" -1) (("1" (rewrite "identity_mult" -1) (("1" (expand "arg" -1 1) (("1" (expand "arg" -1 2) (("1" (rewrite "Re_real") (("1" (rewrite "Im_real") (("1" (assert) (("1" (expand "atan2") (("1" (rewrite "atan_0") (("1" (assert) (("1" (assert) (("1" (case-replace "arg(z!1) <= 0") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "real_is_complex") nil nil)) nil)) nil) ((complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_fields_negative_times formula-decl nil number_fields_bis nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (arg const-decl "argrng" polar nil) (Re_real formula-decl nil arithmetic nil) (nil application-judgement "nnreal_lt_2pi" atan2 trig_fnd) (atan_0 formula-decl nil atan trig_fnd) (argrng nonempty-type-eq-decl nil polar nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (cos const-decl "real" sincos_def trig_fnd) (atan2 const-decl "real" atan2 trig_fnd) (Im_real formula-decl nil arithmetic nil) (minus_complex_is_complex application-judgement "complex" complex_types nil) (minus_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd)) shostak)) (sqrt_inv 0 (sqrt_inv-3 "" 3884587553 ("" (skosimp) (("" (expand "sqrt") (("" (rewrite "abs_inv") (("" (lemma "sqrt_div" ("nny" "1" "nnz" "abs(n0z!1)")) (("" (lemma "abs_nzcomplex" ("n0z" "n0z!1")) (("" (assert) (("" (replace -2) (("" (lemma "sqrt_pos" ("px" "abs(n0z!1)")) (("" (name-replace "R" "sqrt.sqrt(abs(n0z!1))") (("" (hide -2 -3) (("" (lemma "arg_inv" ("n0z" "n0z!1")) (("" (expand "from_polar") (("" (replace -1 1) (("" (hide -1) (("" (case-replace "arg(n0z!1) = 0") (("1" (rewrite "sin_0") (("1" (rewrite "cos_0") (("1" (rewrite "zero_times1") (("1" (rewrite "zero_times1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case-replace "arg(n0z!1) = pi") (("1" (assert) (("1" (rewrite "sin_pi2") (("1" (rewrite "cos_pi2") (("1" (rewrite "identity_mult") (("1" (rewrite "identity_mult") (("1" (rewrite "zero_times2") (("1" (assert) (("1" (rewrite "div_cancel4" 2) (("1" (rewrite "associative_mult" 2 :dir rl) (("1" (rewrite "associative_mult" 2 :dir rl) (("1" (rewrite "associative_mult" 2 :dir rl) (("1" (rewrite "i_axiom") (("1" (rewrite "associative_mult") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "sin_neg" ("a" "arg(n0z!1) / 2")) (("2" (replace -1) (("2" (lemma "cos_neg" ("a" "arg(n0z!1) / 2")) (("2" (replace -1) (("2" (hide -1 -2) (("2" (name-replace "TH" "arg(n0z!1) / 2") (("2" (rewrite "div_cancel4" 3) (("2" (lemma "number_fields_negative_times" ("x" "1" "y" "sin(TH)")) (("2" (rewrite "identity_mult") (("2" (replace -1 * rl) (("2" (hide -1) (("2" (assert) (("2" (rewrite "sq.sq_rew") (("2" (rewrite "sq.sq_rew") (("2" (rewrite "associative_mult" 3 :dir rl) (("2" (rewrite "i_axiom") (("2" (assert) (("2" (lemma "sin2_cos2" ("a" "TH")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (sqrt_inv-2 "" 3790100386 ("" (skosimp) (("" (expand "sqrt") (("" (rewrite "abs_inv") (("" (lemma "sqrt_div" ("nny" "1" "nnz" "abs(n0z!1)")) (("" (lemma "abs_nzcomplex" ("n0z" "n0z!1")) (("" (assert) (("" (replace -2) (("" (lemma "sqrt_pos" ("px" "abs(n0z!1)")) (("" (name-replace "R" "sqrt.sqrt(abs(n0z!1))") (("" (hide -2 -3) (("" (lemma "arg_inv" ("n0z" "n0z!1")) (("" (expand "from_polar") (("" (replace -1 1) (("" (hide -1) (("" (case-replace "arg(n0z!1) = 0") (("1" (rewrite "sin_0") (("1" (rewrite "cos_0") (("1" (rewrite "zero_times1") (("1" (rewrite "zero_times1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case-replace "arg(n0z!1) = pi") (("1" (assert) (("1" (rewrite "sin_pi2") (("1" (rewrite "cos_pi2") (("1" (rewrite "identity_mult") (("1" (rewrite "identity_mult") (("1" (rewrite "zero_times2") (("1" (assert) (("1" (rewrite "div_cancel4" 2) (("1" (rewrite "associative_mult" 2 :dir rl) (("1" (rewrite "associative_mult" 2 :dir rl) (("1" (rewrite "associative_mult" 2 :dir rl) (("1" (rewrite "i_axiom") (("1" (rewrite "associative_mult") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "sin_neg" ("a" "arg(n0z!1) / 2")) (("2" (replace -1) (("2" (lemma "cos_neg" ("a" "arg(n0z!1) / 2")) (("2" (replace -1) (("2" (hide -1 -2) (("2" (name-replace "TH" "arg(n0z!1) / 2") (("2" (rewrite "div_cancel4" 3) (("2" (lemma "number_fields_negative_times" ("x" "1" "y" "sin(TH)")) (("2" (rewrite "identity_mult") (("2" (replace -1 * rl) (("2" (hide -1) (("2" (assert) (("2" (rewrite "sq.sq_rew") (("2" (rewrite "sq.sq_rew") (("2" (rewrite "associative_mult" 3 :dir rl) (("2" (rewrite "i_axiom") (("2" (assert) (("2" (lemma "sin2_cos2" ("a" "TH")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sqrt const-decl "complex" complex_sqrt nil) (abs const-decl "nnreal" polar nil) (nnreal type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (sqrt_div formula-decl nil sqrt reals) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sqrt_1 formula-decl nil sqrt reals) (sqrt_pos judgement-tcc nil sqrt reals) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (real_times_real_is_real application-judgement "real" reals nil) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (from_polar const-decl "complex" polar nil) (sin_pi2 formula-decl nil sincos trig_fnd) (identity_mult formula-decl nil number_fields nil) (zero_times2 formula-decl nil number_fields_bis nil) (div_cancel4 formula-decl nil number_fields_bis nil) (i_axiom formula-decl nil complex_types nil) (associative_mult formula-decl nil number_fields nil) (cos_pi2 formula-decl nil sincos trig_fnd) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nil application-judgement "above(n)" exp2 nil) (sin_neg formula-decl nil sincos_def trig_fnd) (cos_neg formula-decl nil sincos_def trig_fnd) (sin const-decl "real" sincos_def trig_fnd) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sq_rew formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (real_minus_real_is_real application-judgement "real" reals nil) (sin2_cos2 formula-decl nil sincos_def trig_fnd) (number_fields_negative_times formula-decl nil number_fields_bis nil) (minus_real_is_real application-judgement "real" reals nil) (sin_0 formula-decl nil sincos_def trig_fnd) (zero_times1 formula-decl nil number_fields_bis nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (i const-decl "complex" complex_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (cos_0 formula-decl nil sincos_def trig_fnd) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (cos const-decl "real" sincos_def trig_fnd) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (<= const-decl "bool" reals nil) (argrng nonempty-type-eq-decl nil polar nil) (arg const-decl "argrng" polar nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (arg_inv formula-decl nil polar nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (abs_nzcomplex formula-decl nil polar nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (/= const-decl "boolean" notequal nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (abs_inv formula-decl nil polar nil)) shostak) (sqrt_inv-1 nil 3385200646 ("" (skosimp) (("" (expand "sqrt") (("" (rewrite "abs_inv") (("" (lemma "sqrt_div" ("nny" "1" "nnz" "abs(n0z!1)")) (("" (lemma "abs_nzcomplex" ("n0z" "n0z!1")) (("" (assert) (("" (replace -2) (("" (lemma "sqrt_pos" ("px" "abs(n0z!1)")) (("" (name-replace "R" "sqrt.sqrt(abs(n0z!1))") (("" (hide -2 -3) (("" (lemma "arg_inv" ("n0z" "n0z!1")) (("" (expand "from_polar") (("" (replace -1 1) (("" (hide -1) (("" (case-replace "arg(n0z!1) = 0") (("1" (rewrite "sin_0") (("1" (rewrite "cos_0") (("1" (rewrite "zero_times1") (("1" (rewrite "zero_times1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case-replace "arg(n0z!1) = pi") (("1" (assert) (("1" (rewrite "sin_pi2") (("1" (rewrite "cos_pi2") (("1" (rewrite "identity_mult") (("1" (rewrite "identity_mult") (("1" (rewrite "zero_times2") (("1" (assert) (("1" (rewrite "div_cancel4" 2) (("1" (rewrite "associative_mult" 2 :dir rl) (("1" (rewrite "associative_mult" 2 :dir rl) (("1" (rewrite "associative_mult" 2 :dir rl) (("1" (rewrite "i_axiom") (("1" (rewrite "associative_mult") (("1" (rewrite "div_cancel2") (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "sin_neg" ("a" "arg(n0z!1) / 2")) (("2" (replace -1) (("2" (lemma "cos_neg" ("a" "arg(n0z!1) / 2")) (("2" (replace -1) (("2" (hide -1 -2) (("2" (name-replace "TH" "arg(n0z!1) / 2") (("2" (rewrite "div_cancel4" 3) (("2" (lemma "number_fields_negative_times" ("x" "1" "y" "sin(TH)")) (("2" (rewrite "identity_mult") (("2" (replace -1 * rl) (("2" (hide -1) (("2" (assert) (("2" (rewrite "sq.sq_rew") (("2" (rewrite "sq.sq_rew") (("2" (rewrite "associative_mult" 3 :dir rl) (("2" (rewrite "i_axiom") (("2" (assert) (("2" (lemma "sin2_cos2" ("a" "TH")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((abs const-decl "nnreal" polar nil) (sqrt_div formula-decl nil sqrt reals) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (sqrt_1 formula-decl nil sqrt reals) (sqrt_pos judgement-tcc nil sqrt reals) (sin_range application-judgement "real_abs_le1" sincos trig_fnd) (cos_range application-judgement "real_abs_le1" sincos trig_fnd) (from_polar const-decl "complex" polar nil) (sin_pi2 formula-decl nil sincos trig_fnd) (zero_times2 formula-decl nil number_fields_bis nil) (div_cancel4 formula-decl nil number_fields_bis nil) (i_axiom formula-decl nil complex_types nil) (cos_pi2 formula-decl nil sincos trig_fnd) (sin_neg formula-decl nil sincos_def trig_fnd) (cos_neg formula-decl nil sincos_def trig_fnd) (sin const-decl "real" sincos_def trig_fnd) (sq_rew formula-decl nil sq reals) (sq const-decl "nonneg_real" sq reals) (sin2_cos2 formula-decl nil sincos_def trig_fnd) (number_fields_negative_times formula-decl nil number_fields_bis nil) (sin_0 formula-decl nil sincos_def trig_fnd) (zero_times1 formula-decl nil number_fields_bis nil) (i const-decl "complex" complex_types nil) (cos_0 formula-decl nil sincos_def trig_fnd) (cos const-decl "real" sincos_def trig_fnd) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (argrng nonempty-type-eq-decl nil polar nil) (arg const-decl "argrng" polar nil) (complex_plus_complex_is_complex application-judgement "complex" complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (arg_inv formula-decl nil polar nil) (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals) (abs_nzcomplex formula-decl nil polar nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (abs_inv formula-decl nil polar nil)) shostak)) (sqrt_div 0 (sqrt_div-3 "" 3884616975 ("" (skosimp) (("" (rewrite "div_def" 1) (("" (rewrite "sqrt_times") (("" (rewrite "sqrt_inv") (("" (rewrite "arg_inv") (("" (case-replace "arg(n0y!1)=pi") (("1" (assert) (("1" (case-replace "arg(x!1)>0") (("1" (assert) (("1" (rewrite "times_div1" 1) (("1" (rewrite "neg_times_neg") (("1" (rewrite "number_fields_left_identity_mult") nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "times_div1" 2) (("2" (assert) (("2" (rewrite "commutative_mult" 2) (("2" (rewrite "number_fields_negative_times" 2) (("2" (rewrite "identity_mult") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "arg(n0y!1)=0") (("1" (assert) (("1" (rewrite "div_def" 2 :dir rl) nil nil)) nil) ("2" (assert) (("2" (case-replace "arg(x!1) - arg(n0y!1) <= -pi") (("1" (assert) (("1" (rewrite "times_div1" 3) nil nil)) nil) ("2" (assert) (("2" (rewrite "minus_add" 4 :dir rl) (("2" (lift-if 4) (("2" (rewrite "times_div1" 4) (("2" (rewrite "times_div1" 4) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (sqrt_div-2 "" 3790100387 ("" (skosimp) (("" (rewrite "div_def" 1) (("" (rewrite "sqrt_times") (("" (rewrite "sqrt_inv") (("" (rewrite "arg_inv") (("" (case-replace "arg(n0y!1)=pi") (("1" (assert) (("1" (case-replace "arg(x!1)>0") (("1" (assert) (("1" (rewrite "times_div1" 1) (("1" (rewrite "neg_times_neg") nil nil)) nil)) nil) ("2" (assert) (("2" (rewrite "times_div1" 2) (("2" (assert) (("2" (rewrite "commutative_mult" 2) (("2" (rewrite "number_fields_negative_times" 2) (("2" (rewrite "identity_mult") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "arg(n0y!1)=0") (("1" (assert) (("1" (rewrite "div_def" 2 :dir rl) nil nil)) nil) ("2" (assert) (("2" (case-replace "arg(x!1) - arg(n0y!1) <= -pi") (("1" (assert) (("1" (rewrite "times_div1" 3) nil nil)) nil) ("2" (assert) (("2" (rewrite "minus_add" 4 :dir rl) (("2" (lift-if 4) (("2" (rewrite "times_div1" 4) (("2" (rewrite "times_div1" 4) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((div_def formula-decl nil number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (minus_complex_is_complex application-judgement "complex" complex_types nil) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (sqrt_inv formula-decl nil complex_sqrt nil) (arg const-decl "argrng" polar nil) (argrng nonempty-type-eq-decl nil polar nil) (<= const-decl "bool" reals nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (cos const-decl "real" sincos_def trig_fnd) (> const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (sqrt const-decl "complex" complex_sqrt nil) (times_div1 formula-decl nil number_fields_bis nil) (number_fields_left_identity_mult formula-decl nil number_fields_bis nil) (neg_times_neg formula-decl nil number_fields_bis nil) (nil application-judgement "above(n)" exp2 nil) (commutative_mult formula-decl nil number_fields nil) (identity_mult formula-decl nil number_fields nil) (number_fields_negative_times formula-decl nil number_fields_bis nil) (complex_div_nzcomplex_is_complex application-judgement "complex" complex_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_add formula-decl nil number_fields nil) (minus_real_is_real application-judgement "real" reals nil) (sqrt_nz_is_nz application-judgement "nzcomplex" complex_sqrt nil) (arg_inv formula-decl nil polar nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (sqrt_times formula-decl nil complex_sqrt nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)) shostak) (sqrt_div-1 nil 3385202953 ("" (skosimp) (("" (rewrite "div_def" 1) (("" (rewrite "sqrt_times") (("1" (rewrite "sqrt_inv") (("1" (rewrite "arg_inv") (("1" (case-replace "arg(n0y!1)=pi") (("1" (assert) (("1" (case-replace "arg(x!1)>0") (("1" (assert) (("1" (rewrite "times_div1" 1) (("1" (rewrite "neg_times_neg") nil nil)) nil)) nil) ("2" (assert) (("2" (rewrite "times_div1" 2) (("2" (assert) (("2" (rewrite "commutative_mult" 2) (("2" (rewrite "number_fields_negative_times" 2) (("2" (rewrite "identity_mult") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "arg(n0y!1)=0") (("1" (assert) (("1" (rewrite "div_def" 2 :dir rl) nil nil)) nil) ("2" (assert) (("2" (case-replace "arg(x!1) - arg(n0y!1) <= -pi") (("1" (assert) (("1" (rewrite "times_div1" 3) nil nil)) nil) ("2" (assert) (("2" (assert) (("2" (rewrite "minus_add" 4 :dir rl) (("2" (assert) (("2" (lift-if 4) (("2" (rewrite "times_div1" 4) (("2" (rewrite "times_div1" 4) (("2" (prop) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "real_is_complex" ("x" "1")) (("2" (rewrite "closed_divides") nil nil)) nil)) nil)) nil)) nil) ((complex_pred const-decl "[number_field -> boolean]" complex_types nil) (complex nonempty-type-from-decl nil complex_types nil) (nzcomplex nonempty-type-eq-decl nil complex_types nil) (pi_bound name-judgement "{r: posreal | pi_lb_new <= r AND r <= pi_ub_new}" pi_def trig_fnd) (minus_complex_is_complex application-judgement "complex" complex_types nil) (nzcomplex_div_nzcomplex_is_nzcomplex application-judgement "nzcomplex" complex_types nil) (complex_times_complex_is_complex application-judgement "complex" complex_types nil) (arg const-decl "argrng" polar nil) (argrng nonempty-type-eq-decl nil polar nil) (pi const-decl "{x: real | x > 2 AND x < 4 AND cos(x / 2) = 0}" pi_def trig_fnd) (cos const-decl "real" sincos_def trig_fnd) (times_div1 formula-decl nil number_fields_bis nil) (neg_times_neg formula-decl nil number_fields_bis nil) (number_fields_negative_times formula-decl nil number_fields_bis nil) (complex_div_nzcomplex_is_complex application-judgement "complex" complex_types nil) (arg_inv formula-decl nil polar nil)) shostak)))
