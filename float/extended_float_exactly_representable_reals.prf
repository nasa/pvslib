(extended_float_exactly_representable_reals
 (er_rat_to_er_int__exponent__le_max_exp 0
  (er_rat_to_er_int__exponent__le_max_exp-2 "" 3790103802
   ("" (skeep :preds? t)
    (("" (expand "er_rat_to_er_int__exponent")
      (("" (expand "max_exp")
        (("" (assert) (("" (expand "emin") (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (emax const-decl "above(1)" extended_float nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (max_exp const-decl "posint" extended_float nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil))
   shostak)
  (er_rat_to_er_int__exponent__le_max_exp-1 nil 3763920022
   ("" (skeep :preds? t)
    (("" (expand "er_rat_to_er_int__exponent")
      (("" (expand "max_exp")
        (("" (assert)
          (("" (expand "emin")
            (("" (expand "min_exp") (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((emax const-decl "above(1)" extended_float nil)
    (emin const-decl "negint" ieee754_domain nil)
    (max_exp const-decl "posint" extended_float nil))
   shostak))
 (er_rat_to_er_int__exponent__ge_min_exp 0
  (er_rat_to_er_int__exponent__ge_min_exp-1 nil 3763920022
   ("" (expand "er_rat_to_er_int__exponent")
    (("" (skeep :preds? t)
      (("" (expand "min_exp") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (max_exp const-decl "posint" extended_float nil)
    (emax const-decl "above(1)" extended_float nil)
    (emin const-decl "negint" ieee754_domain nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (min_exp const-decl "negint" extended_float nil)
    (er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   shostak))
 (sigma_on_nat_TCC1 0
  (sigma_on_nat_TCC1-1 nil 3790102174 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   nil
   (sigma_on_nat assuming "sigma[nat].sigma"
    "connected_domain: ASSUMPTION (FORALL (x, y: sigma.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), sigma.T_pred(z)))")))
 (er_rat_to_er_int__significand_TCC1 0
  (er_rat_to_er_int__significand_TCC2-1 nil 3763919900
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (max_exp const-decl "posint" extended_float nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (/= const-decl "boolean" notequal nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil))
   shostak
   (er_rat_to_er_int__significand subtype
    "((number_fields.-)((number_fields.-)(extended_float_exactly_representable_reals.precision, 1), extended_float_exactly_representable_reals.i))"
    "{i: integers.int | booleans.OR(extended_float_exactly_representable_reals.radix /= 0, reals.>=(i, 0))}")))
 (er_rat_to_er_int__significand_TCC2 0
  (er_rat_to_er_int__significand_TCC1-1 nil 3763919900
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (nzreal_expt application-judgement "nzreal" exponentiation nil)
    (int_expt application-judgement "int" exponentiation nil)
    (int_exp application-judgement "int" exponentiation nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (max_exp const-decl "posint" extended_float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (^ const-decl "real" exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (rat_exp application-judgement "rat" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (sigma_nat application-judgement "nat" sigma_nat reals)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil))
   shostak
   (er_rat_to_er_int__significand subtype
    "number_fields.*(exponentiation.^(((number_fields.-)(1)), extended_float_exactly_representable_reals.s), sigma[nat].sigma(0, (number_fields.-)(extended_float_exactly_representable_reals.precision, 1), LAMBDA (i: naturalnumbers.nat): IF reals.<(i, extended_float_exactly_representable_reals.precision) THEN number_fields.*(extended_float_exactly_representable_reals.m(i), exponentiation.^(extended_float_exactly_representable_reals.radix, ((number_fields.-)((number_fields.-)(extended_float_exactly_representable_reals.precision, 1), i)))) ELSE 0 ENDIF))"
    "int")))
 (er_rat_to_er_int__significand__abs_lt_radix_pow_prec_TCC1 0
  (er_rat_to_er_int__significand__abs_lt_radix_pow_prec_TCC1-1 nil 3765203177
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (max_exp const-decl "posint" extended_float nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (/= const-decl "boolean" notequal nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil))
   shostak
   (er_rat_to_er_int__significand__abs_lt_radix_pow_prec subtype
    "extended_float_exactly_representable_reals.precision"
    "{i: integers.int | booleans.OR(extended_float_exactly_representable_reals.radix /= 0, reals.>=(i, 0))}")))
 (er_rat_to_er_int__significand__abs_lt_radix_pow_prec 0
  (er_rat_to_er_int__significand__abs_lt_radix_pow_prec-2 "" 3765353041
   ("" (skeep :preds? t)
    (("" (expand "er_rat_to_er_int__significand")
      (("" (invoke (name-replace "significand_value" "%1") (! 1 1 1 2))
        (("1" (case "0 <= significand_value")
          (("1" (case "abs((-1) ^ s * significand_value) = significand_value")
            (("1" (replace -1 :hide? t)
              (("1" (expand "significand_value")
                (("1" (hide -1)
                  (("1"
                    (case "FORALL (j: nat): j < precision IMPLIES -1 - j + precision >= 0")
                    (("1" (assert)
                      (("1" (hide -1)
                        (("1"
                          (case "sigma[nat]
                                                                    (0, precision - 1,
                                                                     LAMBDA (i: nat):
                                                                       IF i < precision THEN m(i) * radix ^ (-1 - i + precision)
                                                                       ELSE 0
                                                                       ENDIF) = sigma[nat]
                                                                    (0, precision - 1,
                                                                     LAMBDA (j: nat):
                                                                       IF j < precision THEN m(precision-1-j) * radix ^ j
                                                                       ELSE 0
                                                                       ENDIF)")
                          (("1" (replace -1 :hide? t)
                            (("1" (lemma "sigma_le[nat]")
                              (("1"
                                (inst -1
                                 "LAMBDA(j:nat): IF j < precision THEN m(precision - 1 - j) * radix ^ j
                                                           ELSE 0
                                                           ENDIF"
                                 "LAMBDA(j:nat): (radix-1) * radix ^ j"
                                 "precision-1" "0")
                                (("1" (split -1)
                                  (("1" (use "sigma_scal[nat]")
                                    (("1" (replace -1 :hide? t)
                                      (("1"
                                        (use "sigma_nat.sigma_geometric")
                                        (("1"
                                          (split -1)
                                          (("1"
                                            (replace -1 :hide? t)
                                            (("1"
                                              (invoke
                                               (case "%1 < %2")
                                               (! -1 2)
                                               (! 1 2))
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (hide-all-but 1)
                                                (("2"
                                                  (case
                                                   "(radix - 1) *
                                                         ((radix ^ 0 - radix ^ (precision - 1 + 1)) / (1 - radix)) = ((radix - 1)/ (1 - radix)) *
                                                         (radix ^ 0 - radix ^ (precision - 1 + 1))")
                                                  (("1"
                                                    (replace -1 :hide? t)
                                                    (("1"
                                                      (case
                                                       "((radix - 1) / (1 - radix)) *
                                                             (radix ^ 0 - radix ^ (precision - 1 + 1)) = radix ^ precision - 1")
                                                      (("1"
                                                        (replace -1 :hide? t)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (hide 2)
                                                        (("2"
                                                          (grind-reals)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (assert) nil nil)
                                           ("3" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (hide-all-but 1)
                                    (("2" (skeep :preds? t)
                                      (("2"
                                        (lift-if 1)
                                        (("2"
                                          (split 1)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (typepred "m(precision -1 - n)")
                                              (("1"
                                                (case
                                                 "m(precision - 1 - n) <= radix-1")
                                                (("1"
                                                  (hide -2)
                                                  (("1"
                                                    (mult-by -1 "radix^n")
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but 1)
                            (("2" (lemma "sigma_downwards[nat]")
                              (("2"
                                (inst -1 "LAMBDA (j: nat):
              IF j < precision THEN m(precision - 1 - j) * radix ^ j
              ELSE 0
              ENDIF" "precision-1" "0" "precision-1")
                                (("1" (assert)
                                  (("1" (replace -1 :hide? t)
                                    (("1" (use "sigma_eq[nat]")
                                      (("1"
                                        (split -1)
                                        (("1" (propax) nil nil)
                                         ("2" (assert) nil nil))
                                        nil)
                                       ("2"
                                        (hide 2)
                                        (("2"
                                          (skeep)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (skeep)
                                  (("2" (hide 2) (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (assert) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (hide 2)
                        (("2" (skeep) (("2" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but (-1 1 -2))
              (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil))
            nil)
           ("2" (hide-all-but 1)
            (("2" (expand "significand_value")
              (("2" (use "sigma_nonneg[nat]")
                (("1" (expand ">=")
                  (("1" (assert)
                    (("1" (hide 2)
                      (("1" (skeep)
                        (("1" (lift-if 1)
                          (("1" (split 1)
                            (("1" (flatten) (("1" (assert) nil nil)) nil)
                             ("2" (flatten) (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skeep) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((rat_exp application-judgement "rat" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (sigma_rat application-judgement "rational" sigma_nat reals)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (er_rat_to_er_int__significand const-decl "int"
     extended_float_exactly_representable_reals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals)
    (T_low type-eq-decl nil sigma reals) (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (rat_abs_is_nonneg application-judgement "{r: nonneg_rat | r >= q}"
     real_defs nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (significand_value skolem-const-decl "rational"
     extended_float_exactly_representable_reals nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (sigma_eq formula-decl nil sigma reals)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (sigma_downwards formula-decl nil sigma reals)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil)
    (sigma_scal formula-decl nil sigma reals)
    (sigma_geometric formula-decl nil sigma_nat reals)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (div_cancel3 formula-decl nil real_props nil)
    (div_distributes_minus formula-decl nil real_props nil)
    (times_div1 formula-decl nil real_props nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (sigma_le formula-decl nil sigma reals)
    (sigma_nat application-judgement "nat" sigma_nat reals)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (int_exp application-judgement "int" exponentiation nil)
    (neg_times_lt formula-decl nil real_props nil)
    (minus_rat_is_rat application-judgement "rat" rationals nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (sigma_nonneg formula-decl nil sigma reals))
   shostak)
  (er_rat_to_er_int__significand__abs_lt_radix_pow_prec-1 nil 3763919910
   ("" (skeep :preds? t)
    (("" (expand "er_rat_to_er_int__significand")
      ((""
        (case "sigma[below(53)] (0, 52, LAMBDA (i: below(53)): m(i) * 2 ^ (52 - i)) = sigma[below(53)] (0, 52, LAMBDA (i: below(53)): m(52 - i) * 2 ^ i)")
        (("1" (replace -1 :hide? t)
          (("1"
            (case "sigma[below(53)] (0, 52, LAMBDA (i: below(53)): m(52-i) * 2 ^ i) = sigma[nat] (0, 52, LAMBDA (i: nat): IF 52-i >= 0 AND 52-i < 53 THEN m(52-i) * 2 ^ i ELSE 0 ENDIF)")
            (("1" (replace -1 :hide? t)
              (("1"
                (name-replace "significand_value"
                 "sigma[nat] (0, 52, LAMBDA (i: nat): IF 52-i >= 0 AND 52-i < 53 THEN m(52-i) * 2 ^ i ELSE 0 ENDIF)")
                (("1" (case "0 <= significand_value")
                  (("1"
                    (case "abs((-1) ^ s * significand_value) = significand_value")
                    (("1" (replace -1 :hide? t)
                      (("1" (case "significand_value <= 2^53 - 1")
                        (("1" (assert) nil nil)
                         ("2" (hide 2)
                          (("2" (expand "significand_value")
                            (("2"
                              (case "sigma[nat](0, 52,  LAMBDA (i: nat): IF 52-i >= 0 THEN m(52-i) * 2 ^ i ELSE 0 ENDIF) <= sigma[nat](0, 52, LAMBDA (i: nat): 2 ^ i)")
                              (("1" (use "sigma_nat.sigma_geometric")
                                (("1" (assert) nil nil)) nil)
                               ("2" (hide 2)
                                (("2" (use "sigma_le[nat]")
                                  (("2" (assert)
                                    (("2" (hide 2)
                                      (("2"
                                        (skeep :preds? t)
                                        (("2"
                                          (typepred "m(52-n)")
                                          (("2" (grind-reals) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but (-1 1 -2))
                      (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (hide-all-but 1)
                    (("2" (expand "significand_value")
                      (("2" (use "sigma_nonneg[nat]")
                        (("2" (expand ">=") (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but 1) (("2" (for 54 (expand "sigma")) nil nil))
              nil))
            nil))
          nil)
         ("2" (hide-all-but 1)
          (("2"
            (for 52
             (then (rewrite "sigma_first_ge")
              (rewrite "sigma_last_ge" 1
               ("F" "LAMBDA (i: below(53)): m(52 - i) * 2 ^ i"))
              (assert)))
            (("2" (expand "sigma")
              (("2" (expand "sigma") (("2" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((significand type-eq-decl nil ieee754_domain nil)
    (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals)
    (T_low type-eq-decl nil sigma reals)
    (sigma_nonneg formula-decl nil sigma reals)
    (sign type-eq-decl nil ieee754_domain nil)
    (sigma_le formula-decl nil sigma reals)
    (sigma_geometric formula-decl nil sigma_nat reals)
    (sigma_first_ge formula-decl nil sigma_below reals)
    (int_below type-eq-decl nil sigma_below reals)
    (sigma_last_ge formula-decl nil sigma_below reals))
   shostak))
 (er_rat_to_er_int_value_TCC1 0
  (er_rat_to_er_int_value_TCC1-1 nil 3765203177 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (max_exp const-decl "posint" extended_float nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (er_rat_to_er_int__significand const-decl "int"
     extended_float_exactly_representable_reals nil)
    (^ const-decl "real" exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (rat_exp application-judgement "rat" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (sigma_nat application-judgement "nat" sigma_nat reals)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil))
   shostak
   (er_rat_to_er_int_value subtype
    "extended_float_exactly_representable_reals.exponent"
    "{i: integers.int | booleans.OR(extended_float_exactly_representable_reals.radix /= 0, reals.>=(i, 0))}")))
 (er_rat_to_er_int_value 0
  (er_rat_to_er_int_value-1 nil 3763919910
   ("" (skeep :preds? t)
    (("" (beta)
      (("" (expand "er_rat_to_er_int__significand")
        (("" (expand "er_rat_to_er_int__exponent")
          (("" (expand "value")
            ((""
              (case "(radix ^ (e!1 - (precision-1))) * (-1) ^ s * sigma(0, (precision-1), LAMBDA (i: nat): IF i < precision THEN m(i) * radix ^ (-1 - i + precision)
               ELSE 0
               ENDIF) = radix ^ e!1 * (-1) ^ s * radix ^(-(precision-1)) * sigma(0, (precision-1), LAMBDA (i: nat): IF i < precision THEN  m(i) * radix ^ (precision-1) * radix ^(- i)ELSE 0
               ENDIF)")
              (("1" (replace -1 :hide? t)
                (("1"
                  (case "radix ^ (-(precision-1)) * sigma (0, (precision-1), LAMBDA (i: nat):
                IF i < precision
                  THEN m(i) * radix ^ (precision - 1) * radix ^ (-i)
                ELSE 0
                ENDIF) = sigma(0, (precision-1), LAMBDA (i: nat): IF i < precision
                  THEN m(i) * radix ^ (-i)ELSE 0
                ENDIF)")
                  (("1" (assert) nil nil)
                   ("2" (hide 2)
                    (("2" (lemma "sigma[nat].sigma_scal")
                      (("2" (inst? -1)
                        (("1" (replace -1 :hide? t :dir rl)
                          (("1" (rewrite "sigma[nat].sigma_eq")
                            (("1" (hide-all-but 1)
                              (("1" (skeep :preds? t)
                                (("1"
                                  (swap "m(n)" "*"
                                   "radix ^ (precision-1) * radix ^ (-n)")
                                  (("1"
                                    (case "radix ^ (-(precision-1)) * ((radix ^ (precision-1) * radix ^ (-n)) * (m(n))) = (radix ^ (-(precision-1)) * radix ^ (precision-1)) * radix ^ (-n) * (m(n))")
                                    (("1" (replace -1 :hide? t)
                                      (("1"
                                        (rewrite "expt_plus" :dir rl)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skeep) (("2" (assert) nil nil)) nil)
                         ("3" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2"
                  (case "(radix ^ (e!1 - (precision-1))) = radix ^ e!1 * radix ^ (- (precision-1))")
                  (("1" (replace -1 :hide? t)
                    (("1" (lemma "sigma[nat].sigma_eq")
                      (("1" (inst? -1 :where 1)
                        (("1"
                          (inst -1
                           "LAMBDA (i: nat): IF i < precision THEN m(i) * radix ^ (precision-1) * radix ^ (-i) ELSE 0 ENDIF")
                          (("1" (split -1)
                            (("1" (assert) nil nil)
                             ("2" (hide 2)
                              (("2" (skeep :preds? t)
                                (("2" (lift-if 1)
                                  (("2" (split 1)
                                    (("1" (flatten)
                                      (("1"
                                        (case
                                         "(precision-1) - n = (precision-1) + -n")
                                        (("1"
                                          (replace -1 :hide? t)
                                          (("1"
                                            (rewrite "expt_plus")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil) ("3" (assert) nil nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (case "e!1 - (precision-1) = e!1 + -(precision-1)")
                      (("1" (replace -1 :hide? t)
                        (("1" (rewrite "expt_plus") nil nil)) nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (assert) nil nil) ("4" (assert) nil nil)
               ("5" (assert) nil nil) ("6" (assert) nil nil)
               ("7" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (rat_exp application-judgement "rat" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (sigma_rat application-judgement "rational" sigma_nat reals)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_scal formula-decl nil sigma reals)
    (sigma_eq formula-decl nil sigma reals)
    (expt_x0 formula-decl nil exponentiation nil)
    (expt_plus formula-decl nil exponentiation nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (subrange type-eq-decl nil integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil)
    (^ const-decl "real" exponentiation nil) (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (emin const-decl "negint" ieee754_domain nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals)
    (sigma def-decl "real" sigma reals)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (below type-eq-decl nil naturalnumbers nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (value const-decl "real" ieee754_domain nil)
    (er_rat_to_er_int__significand const-decl "int"
     extended_float_exactly_representable_reals nil))
   shostak))
 (er_ub_correspondent 0
  (er_ub_correspondent-1 nil 3763920022
   ("" (expand "max_pos_value")
    (("" (expand "er_ub")
      (("" (expand "value")
        (("" (expand "emax")
          (("" (expand "smax" :assert? none)
            ((""
              (case "((-1) ^ 0 * radix ^ (max_exp - 1 + precision)) *
              sigma(0, precision - 1,
                    LAMBDA (i: nat):
                      IF i < precision THEN (radix - 1) * radix ^ (-i)
                      ELSE 0
                      ENDIF) = radix ^ max_exp * (radix-1) * sigma(0, precision - 1,
                    LAMBDA (j: nat):
                      radix ^ j)")
              (("1" (replace -1 :hide? t)
                (("1" (use "sigma_nat.sigma_geometric")
                  (("1" (split -1)
                    (("1" (replace -1 :hide? t) (("1" (grind-reals) nil nil))
                      nil)
                     ("2" (assert) nil nil) ("3" (assert) nil nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (lemma "sigma[nat].sigma_eq")
                  (("2"
                    (inst -1 "LAMBDA (i: nat):
                   IF i < precision THEN (radix - 1) * radix ^ (-i)
                   ELSE 0
                   ENDIF" "LAMBDA (i: nat): (radix - 1) * radix ^ (-i)"
                     "precision-1" "0")
                    (("1" (split -1)
                      (("1" (replace -1 :hide? t)
                        (("1" (lemma "sigma[nat].sigma_scal")
                          (("1"
                            (inst -1 "LAMBDA (i: nat):radix ^ (-i)"
                             "(radix-1)" "precision-1" "0")
                            (("1" (replace -1 :hide? t)
                              (("1"
                                (case "radix ^ (max_exp - 1 + precision) = radix ^ max_exp * radix ^ ( - 1 + precision)")
                                (("1" (replace -1 :hide? t)
                                  (("1"
                                    (case "((-1) ^ 0 * (radix ^ max_exp * radix ^ (-1 + precision))) *
                        ((radix - 1) *
                          sigma(0, precision - 1, LAMBDA (i: nat): radix ^ (-i))) = (-1) ^ 0 * radix ^ max_exp  *
                        (radix - 1) * (radix ^ (-1 + precision) *
                          sigma(0, precision - 1, LAMBDA (i: nat): radix ^ (-i)))")
                                    (("1" (replace -1 :hide? t)
                                      (("1"
                                        (lemma "sigma[nat].sigma_scal")
                                        (("1"
                                          (inst
                                           -1
                                           "LAMBDA (i: nat): radix ^ (-i)"
                                           "radix ^ (-1 + precision)"
                                           "precision-1"
                                           "0")
                                          (("1"
                                            (replace -1 :hide? rl :dir rl)
                                            (("1"
                                              (lemma "sigma[nat].sigma_eq")
                                              (("1"
                                                (inst
                                                 -1
                                                 "LAMBDA (i_1: nat): radix ^ (-1 + precision) * radix ^ (-i_1)"
                                                 "LAMBDA (i_1: nat): radix ^ (-1 + precision -i_1)"
                                                 "precision-1"
                                                 "0")
                                                (("1"
                                                  (split -1)
                                                  (("1"
                                                    (replace -1 :hide? t)
                                                    (("1"
                                                      (invoke
                                                       (case "%1 = %2")
                                                       (! 1 1 4)
                                                       (! 1 2 3))
                                                      (("1" (assert) nil nil)
                                                       ("2"
                                                        (hide 2)
                                                        (("2"
                                                          (lemma
                                                           "sigma_downwards")
                                                          (("2"
                                                            (inst
                                                             -1
                                                             "LAMBDA (j: nat): radix ^ j"
                                                             "precision-1"
                                                             "0"
                                                             "precision-1")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (replace
                                                                 -1
                                                                 :hide?
                                                                 t)
                                                                (("1"
                                                                  (lemma
                                                                   "sigma[nat].sigma_eq")
                                                                  (("1"
                                                                    (inst? -1)
                                                                    (("1"
                                                                      (split
                                                                       -1)
                                                                      (("1"
                                                                        (propax)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (hide
                                                                         2)
                                                                        (("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (hide 2)
                                                                      (("2"
                                                                        (skeep)
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("3"
                                                                      (hide 2)
                                                                      (("3"
                                                                        (skeep)
                                                                        (("3"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("3"
                                                        (hide 2)
                                                        (("3"
                                                          (skeep)
                                                          (("3"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide-all-but 1)
                                                    (("2"
                                                      (skeep :preds? t)
                                                      (("2"
                                                        (lemma "expt_plus")
                                                        (("2"
                                                          (inst
                                                           -1
                                                           "-1+precision"
                                                           "-n"
                                                           "radix")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (assert) nil nil)
                                                 ("3" (assert) nil nil)
                                                 ("4" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (hide-all-but 1)
                                      (("2" (assert) nil nil)) nil)
                                     ("3" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("2" (hide-all-but 1)
                                  (("2" (lemma "expt_plus")
                                    (("2"
                                      (inst
                                       -1
                                       "max_exp"
                                       "-1+precision"
                                       "radix")
                                      (("2" (assert) nil nil)) nil))
                                    nil))
                                  nil)
                                 ("3" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil)
                     ("2" (assert) nil nil) ("3" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("3" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_ub const-decl "er_real" ieee754_domain nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (emax const-decl "above(1)" extended_float nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (expt_plus formula-decl nil exponentiation nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (sigma_downwards formula-decl nil sigma reals)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (sigma_nnreal application-judgement "nnreal" sigma_nat reals)
    (sigma_scal formula-decl nil sigma reals)
    (sigma_eq formula-decl nil sigma reals)
    (int_exp application-judgement "int" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (sigma_rat application-judgement "rational" sigma_nat reals)
    (sigma_geometric formula-decl nil sigma_nat reals)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (times_div1 formula-decl nil real_props nil)
    (times_div2 formula-decl nil real_props nil)
    (div_distributes_minus formula-decl nil real_props nil)
    (div_cancel3 formula-decl nil real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (sigma_nat application-judgement "nat" sigma_nat reals)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil)
    (^ const-decl "real" exponentiation nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (max_exp const-decl "posint" extended_float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma reals)
    (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (smax const-decl "significand" ieee754_domain nil)
    (value const-decl "real" ieee754_domain nil)
    (max_pos_value const-decl "posreal" extended_float nil)
    (posint_exp application-judgement "posint" exponentiation nil))
   shostak))
 (er_lb_correspondent 0
  (er_lb_correspondent-1 nil 3763920022
   ("" (expand "er_lb")
    (("" (use "er_ub_correspondent")
      (("" (expand "er_ub")
        (("" (replace -1 :hide? t :dir rl)
          (("" (expand "value") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (minus_rat_is_rat application-judgement "rat" rationals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (sigma_rat application-judgement "rational" sigma_nat reals)
    (posint_exp application-judgement "posint" exponentiation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (int_exp application-judgement "int" exponentiation nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (value const-decl "real" ieee754_domain nil)
    (er_ub const-decl "er_real" ieee754_domain nil)
    (er_lb const-decl "er_real" ieee754_domain nil))
   shostak))
 (er_min_pos_correspondent 0
  (er_min_pos_correspondent-1 nil 3763920022
   ("" (expand "er_min_pos")
    (("" (expand "min_pos_value")
      (("" (case "emin = min_exp + precision - 1")
        (("1" (replace -1 :hide? t)
          (("1" (expand "smin")
            (("1" (expand "value")
              (("1"
                (case "sigma(0, precision - 1,
                    LAMBDA (i_1: nat):
                      IF i_1 < precision
                        THEN IF i_1 = precision - 1 THEN 1 ELSE 0 ENDIF *
                              radix ^ (-i_1)
                      ELSE 0
                      ENDIF) = radix ^ (-precision+1)")
                (("1" (replace -1 :hide? t)
                  (("1" (assert)
                    (("1" (lemma "expt_plus")
                      (("1"
                        (inst -1 "(1 + -precision)"
                         "(min_exp - 1 + precision)" "radix")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide-all-but 1)
                  (("2" (lemma "sigma_with")
                    (("2"
                      (inst -1 "LAMBDA (i_1: nat):
                  IF i_1 < precision
                    THEN IF i_1 = precision - 1 THEN 1 ELSE 0 ENDIF *
                          radix ^ (-i_1)
                  ELSE 0
                  ENDIF" "LAMBDA(i:nat):0" "radix^(1-precision)" "precision-1"
                       "precision-1" "0")
                      (("1" (split -1)
                        (("1" (replace -1 :hide? t)
                          (("1" (rewrite "sigma_zero")
                            (("1" (assert) nil nil)) nil))
                          nil)
                         ("2" (assert) nil nil) ("3" (assert) nil nil)
                         ("4" (hide-all-but 1)
                          (("4" (apply-extensionality)
                            (("4" (hide 2) (("4" (grind) nil nil)) nil)) nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil) ("3" (assert) nil nil)
                       ("4" (assert) nil nil))
                      nil))
                    nil))
                  nil)
                 ("3" (assert) nil nil) ("4" (assert) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (expand "emin")
            (("2" (expand "emax")
              (("2" (expand "min_exp")
                (("2" (expand "max_exp") (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((min_pos_value const-decl "posreal" extended_float nil)
    (min_exp const-decl "negint" extended_float nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (emin const-decl "negint" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (smin const-decl "significand" ieee754_domain nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (expt def-decl "real" exponentiation nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnrat_plus_posrat_is_posrat application-judgement "posrat" rationals nil)
    (sigma_nat application-judgement "nat" sigma_nat reals)
    (sigma_zero formula-decl nil sigma reals)
    (sigma_with formula-decl nil sigma reals)
    (int_exp application-judgement "int" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (expt_plus formula-decl nil exponentiation nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat" rationals
     nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals)
    (T_low type-eq-decl nil sigma reals)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (sigma_rat application-judgement "rational" sigma_nat reals)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals
     nil)
    (value const-decl "real" ieee754_domain nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil)
    (max_exp const-decl "posint" extended_float nil)
    (er_min_pos const-decl "er_real" ieee754_domain nil))
   shostak))
 (er_max_neg_correspondent 0
  (er_max_neg_correspondent-1 nil 3763920022
   ("" (expand "er_max_neg")
    (("" (use "er_min_pos_correspondent")
      (("" (expand "er_min_pos")
        (("" (expand "value") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((er_min_pos_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (value const-decl "real" ieee754_domain nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (int_exp application-judgement "int" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (sigma_rat application-judgement "rational" sigma_nat reals)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (er_min_pos const-decl "er_real" ieee754_domain nil)
    (er_max_neg const-decl "er_real" ieee754_domain nil))
   shostak))
 (min_pos_value_is_er 0
  (min_pos_value_is_er-1 nil 3764927692
   ("" (rewrite "er_min_pos_correspondent" :dir rl) (("" (assert) nil nil))
    nil)
   ((er_min_pos_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil))
   shostak))
 (er_rat_er_int 0
  (er_rat_er_int-1 nil 3763919911
   ("" (skeep :preds? t)
    (("" (expand "exactly_representable?")
      (("" (skeep :preds? t)
        (("" (expand "exactly_representable_as_pair_of_integers?")
          (("" (use "er_rat_to_er_int_value")
            (("" (skoletin* -1)
              (("" (inst 1 "float_pair(signific,exponent)")
                (("1" (split 1)
                  (("1" (expand "FtoR")
                    (("1" (expand "float_pair") (("1" (assert) nil nil)) nil))
                    nil)
                   ("2" (use "er_rat_to_er_int__exponent__le_max_exp")
                    (("2" (assert)
                      (("2" (expand "float_pair") (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "Fbounded?")
                  (("2" (expand "float_pair")
                    (("2" (expand "given_format")
                      (("2" (expand "vNum")
                        (("2" (split 1)
                          (("1"
                            (use "er_rat_to_er_int__significand__abs_lt_radix_pow_prec")
                            (("1" (assert) nil nil)) nil)
                           ("2" (use "er_rat_to_er_int__exponent__ge_min_exp")
                            (("2" (assert)
                              (("2" (expand "min_exp")
                                (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((exactly_representable? const-decl "bool" ieee754_domain nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float_exactly_representable_reals nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (/= const-decl "boolean" notequal nil)
    (er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (er_rat_to_er_int__significand const-decl "int"
     extended_float_exactly_representable_reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (value const-decl "real" ieee754_domain nil)
    (^ const-decl "real" exponentiation nil)
    (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil)
    (given_format const-decl "Format" extended_float nil)
    (float_pair const-decl "float" float nil)
    (signific skolem-const-decl "int"
     extended_float_exactly_representable_reals nil)
    (exponent skolem-const-decl "int"
     extended_float_exactly_representable_reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (FtoR const-decl "real" float nil)
    (er_rat_to_er_int__exponent__le_max_exp formula-decl nil
     extended_float_exactly_representable_reals nil)
    (vNum const-decl "posnat" float nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (er_rat_to_er_int__significand__abs_lt_radix_pow_prec formula-decl nil
     extended_float_exactly_representable_reals nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (min_exp const-decl "negint" extended_float nil)
    (er_rat_to_er_int__exponent__ge_min_exp formula-decl nil
     extended_float_exactly_representable_reals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain nil)
    (exponent type-eq-decl nil ieee754_domain nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (significand type-eq-decl nil ieee754_domain nil)
    (er_rat_to_er_int_value formula-decl nil
     extended_float_exactly_representable_reals nil))
   shostak))
 (er_bounded 0
  (er_bounded-2 "" 3790103824
   ("" (use "er_rat_er_int")
    (("" (expand "exactly_representable_as_pair_of_integers?")
      (("" (skeep)
        (("" (inst?) (("" (skeep) (("" (inst?) nil nil)) nil)) nil)) nil))
      nil))
    nil)
   ((exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float_exactly_representable_reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (f skolem-const-decl "(Fbounded?(given_format))"
     extended_float_exactly_representable_reals nil)
    (max_exp const-decl "posint" extended_float nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (given_format const-decl "Format" extended_float nil)
    (Fbounded? const-decl "bool" float nil)
    (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (er_rat_er_int formula-decl nil extended_float_exactly_representable_reals
     nil))
   shostak)
  (er_bounded-1 nil 3763919911
   (""
    (then (use "er_rat_er_int")
     (expand "exactly_representable_as_pair_of_integers?") (skeep) (inst?)
     (skeep) (inst?))
    nil nil)
   ((float type-eq-decl nil float nil) (Format type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil)
    (given_format const-decl "Format" extended_float nil)
    (max_exp const-decl "posint" extended_float nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil))
   shostak))
 (er_canonic 0
  (er_canonic-1 nil 3764685365
   ("" (skeep)
    (("" (use "er_bounded")
      (("" (skeep)
        (("" (inst 1 "Fnormalize(given_format)(f)")
          (("1" (typepred "Fnormalize(given_format)(f)")
            (("1" (assert) nil nil)) nil)
           ("2" (typepred "Fnormalize(given_format)(f)")
            (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((er_bounded formula-decl nil extended_float_exactly_representable_reals
     nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (unb_canonic_float type-eq-decl nil extended_float nil)
    (<= const-decl "bool" reals nil) (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil)
    (Fcanonic? const-decl "bool" float nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (FtoR const-decl "real" float nil)
    (Fnormalize def-decl
     "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}"
     float nil)
    (given_format const-decl "Format" extended_float nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (max_exp const-decl "posint" extended_float nil)
    (f skolem-const-decl "{f: (Fbounded?(given_format)) | Fexp(f) <= max_exp}"
     extended_float_exactly_representable_reals nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   shostak))
 (dtor_rtod_on_er 0
  (dtor_rtod_on_er-1 nil 3763919911
   ("" (skeep :preds? t)
    (("" (typepred "rnd_ucf(x)")
      (("" (expand "currified_closest?_ucf")
        (("" (expand "closest?_ucf")
          (("" (expand "EvenClosest?")
            (("" (flatten)
              (("" (expand "Closest?" -2)
                (("" (use "er_bounded")
                  (("" (skeep -1 :preds? t)
                    (("" (inst -5 "f")
                      (("" (replace -3 :hide? t)
                        (("" (assert)
                          (("" (eval-expr "abs(0)")
                            (("" (replace -1 :hide? t)
                              (("" (case "FtoR(rnd_ucf(x)) - x = 0")
                                (("1" (expand "prj_ucf")
                                  (("1" (assert) nil nil)) nil)
                                 ("2" (expand "abs")
                                  (("2" (grind-reals) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}" extended_float
     nil)
    (currified_closest?_ucf const-decl "bool" extended_float nil)
    (Fbounded? const-decl "bool" float nil)
    (unb_canonic_float type-eq-decl nil extended_float nil)
    (given_format const-decl "Format" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (Fcanonic? const-decl "bool" float nil) (float type-eq-decl nil float nil)
    (Format type-eq-decl nil float nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (closest?_ucf const-decl "bool" extended_float nil)
    (er_bounded formula-decl nil extended_float_exactly_representable_reals
     nil)
    (max_exp const-decl "posint" extended_float nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (FtoR const-decl "real" float nil)
    (prj_ucf const-decl "real" extended_float nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (Closest? const-decl "bool" float nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (EvenClosest? const-decl "bool" float nil))
   shostak))
 (bound_on_exp_of_rounded_erreal 0
  (bound_on_exp_of_rounded_erreal-1 nil 3763919911
   ("" (skeep :preds? t)
    (("" (use "er_bounded")
      (("" (skeep :preds? t)
        (("" (lemma "CanonicLeastExp")
          (("" (inst -1 "given_format" "rnd_ucf(x)" "f")
            (("" (split -1)
              (("1" (assert) nil nil)
               ("2" (use "dtor_rtod_on_er")
                (("2" (expand "prj_ucf") (("2" (assert) nil nil)) nil)) nil)
               ("3" (propax) nil nil) ("4" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_bounded formula-decl nil extended_float_exactly_representable_reals
     nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (even_times_int_is_even application-judgement "even_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (CanonicLeastExp formula-decl nil float nil)
    (dtor_rtod_on_er formula-decl nil
     extended_float_exactly_representable_reals nil)
    (prj_ucf const-decl "real" extended_float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (max_exp const-decl "posint" extended_float nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}" extended_float
     nil)
    (currified_closest?_ucf const-decl "bool" extended_float nil)
    (Fbounded? const-decl "bool" float nil)
    (unb_canonic_float type-eq-decl nil extended_float nil)
    (Fcanonic? const-decl "bool" float nil) (float type-eq-decl nil float nil)
    (given_format const-decl "Format" extended_float nil)
    (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   shostak)))

