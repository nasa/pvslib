(accum_err_mul
 (mul_accum_err 0
  (mul_accum_err-4 nil 3682175561
   ("" (expand "mul_aerr_bound")
    (("" (skeep)
      ((""
        (case "EXISTS(ep1:real): -e1 <= ep1 AND ep1 <= e1 AND FtoR(f1) = r1 + ep1")
        (("1" (hide -2)
          (("1"
            (case "EXISTS(ep2:real): -e2 <= ep2 AND ep2 <= e2 AND FtoR(f2) = r2 + ep2")
            (("1" (hide -3)
              (("1" (skeep -1)
                (("1" (skeep -4)
                  (("1" (replace -3 :hide? t)
                    (("1" (replace -5 :hide? t)
                      (("1"
                        (case "NOT (r1 + ep1) * (r2 + ep2) = r1*r2 + r1 * ep2 + ep1*r2 + ep1*ep2")
                        (("1" (assert) nil nil)
                         ("2" (replace -1 :hide? t)
                          (("2" (assert)
                            (("2"
                              (case "NOT abs(ep1 * ep2 + ep1 * r2 + r1 * ep2) <= abs(ep1 * ep2) + abs(ep1 * r2) + abs(r1 * ep2)")
                              (("1" (hide 2) (("1" (grind) nil nil)) nil)
                               ("2"
                                (case "NOT abs(ep1 * ep2) = abs(ep1) * abs(ep2)")
                                (("1" (assert)
                                  (("1" (use "abs_mult") nil nil)) nil)
                                 ("2" (replace -1 :hide? t)
                                  (("2" (use "abs_mult")
                                    (("2" (replace -1 :hide? t)
                                      (("2"
                                        (use "abs_mult")
                                        (("2"
                                          (replace -1 :hide? t)
                                          (("2"
                                            (case
                                             "abs(ep1) * abs(ep2) + abs(ep1) * abs(r2) + abs(r1) * abs(ep2) <= abs(r1) * e2 + abs(r2) * e1 + e1 * e2")
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (hide (-1 2))
                                              (("2"
                                                (case
                                                 "NOT abs(r1) * e2 + abs(r2) * e1 + e1 * e2 = e1*e2 + e1*abs(r2) + abs(r1) * e2")
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (replace -1 :hide? t)
                                                  (("2"
                                                    (lemma "le_plus_le")
                                                    (("2"
                                                      (inst
                                                       -1
                                                       " e1 * abs(r2) + abs(r1) * e2"
                                                       "abs(ep1) * abs(ep2)"
                                                       "e1 * e2"
                                                       " abs(ep1) * abs(r2) + abs(r1) * abs(ep2)")
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (hide 2)
                                                          (("2"
                                                            (split 1)
                                                            (("1"
                                                              (expand "abs")
                                                              (("1"
                                                                (lift-if 1)
                                                                (("1"
                                                                  (split 1)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (lift-if
                                                                       1)
                                                                      (("1"
                                                                        (split
                                                                         1)
                                                                        (("1"
                                                                          (flatten)
                                                                          (("1"
                                                                            (assert)
                                                                            (("1"
                                                                              (grind)
                                                                              (("1"
                                                                                (use
                                                                                 "le_times_le_pos")
                                                                                (("1"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (flatten)
                                                                          (("2"
                                                                            (use
                                                                             "le_times_le_pos")
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("2"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("3"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (lift-if)
                                                                      (("2"
                                                                        (split
                                                                         2)
                                                                        (("1"
                                                                          (flatten)
                                                                          (("1"
                                                                            (use
                                                                             "le_times_le_pos")
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("2"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("3"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (flatten)
                                                                          (("2"
                                                                            (use
                                                                             "le_times_le_pos")
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("2"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("3"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (lemma
                                                               "le_plus_le")
                                                              (("2"
                                                                (inst
                                                                 -1
                                                                 "abs(r1) * e2"
                                                                 "abs(ep1) * abs(r2)"
                                                                 "e1 * abs(r2)"
                                                                 "abs(r1) * abs(ep2)")
                                                                (("2"
                                                                  (assert)
                                                                  (("2"
                                                                    (hide 2)
                                                                    (("2"
                                                                      (split
                                                                       1)
                                                                      (("1"
                                                                        (grind)
                                                                        (("1"
                                                                          (use
                                                                           "le_times_le_pos")
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (use
                                                                           "le_times_le_pos")
                                                                          (("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("3"
                                                                          (use
                                                                           "le_times_le_pos")
                                                                          (("3"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("4"
                                                                          (use
                                                                           "le_times_le_pos")
                                                                          (("4"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (grind)
                                                                        (("1"
                                                                          (use
                                                                           "le_times_le_pos")
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (use
                                                                           "le_times_le_pos")
                                                                          (("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("3"
                                                                          (use
                                                                           "le_times_le_pos")
                                                                          (("3"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("4"
                                                                          (use
                                                                           "le_times_le_pos")
                                                                          (("4"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (inst 1 "(FtoR(f2) - r2)") (("2" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (inst 1 "(FtoR(f1) - r1)") (("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (b formal-const-decl "Format" accum_err_mul nil)
    (Fbounded? const-decl "bool" float nil)
    (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FtoR const-decl "real" float nil) (float type-eq-decl nil float nil)
    (radix formal-const-decl "above(1)" accum_err_mul nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs_mult formula-decl nil real_props nil)
    (le_plus_le formula-decl nil real_props nil)
    (ep2 skolem-const-decl "real" accum_err_mul nil)
    (ep1 skolem-const-decl "real" accum_err_mul nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (le_times_le_pos formula-decl nil real_props nil)
    (mul_aerr_bound const-decl "nonneg_real" accum_err_mul nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil)
  (mul_accum_err-3 nil 3682175413
   ("" (skeep)
    (("" (use "interval_as_absdif")
      (("" (replace -1 :hide? t)
        (("" (use "interval_as_absdif")
          (("" (replace -1 :hide? t)
            (("" (lemma "interval_as_absdif")
              (("" (inst? -1 :where 1)
                (("" (replace -1 :hide? t)
                  (("" (use "Mult_inclusion_mps")
                    (("1" (assert)
                      (("1" (expand "Mult_mps")
                        (("1" (assert)
                          (("1" (use "mps_rew")
                            (("1" (replace -1 :hide? t)
                              (("1" (use "mps_rew")
                                (("1" (replace -1 :hide? t)
                                  (("1" (assert)
                                    (("1" (use "Fmul_error")
                                      (("1"
                                        (use "interval_as_absdif")
                                        (("1"
                                          (replace -1 :hide? t)
                                          (("1"
                                            (expand "mps")
                                            (("1"
                                              (hide-all-but (-1 -2 1))
                                              (("1"
                                                (lemma "midinterval")
                                                (("1"
                                                  (inst
                                                   -1
                                                   "[|FtoR(f1) * FtoR(f2) -
              (2 * (abs(FtoR(f1)) * (2 * e2 / 2)) +
                2 * (abs(FtoR(f2)) * (2 * e1 / 2))
                + 2 * (2 * e1 / 2 * (2 * e2 / 2)))
               / 2,
             (2 * (abs(FtoR(f1)) * (2 * e2 / 2)) +
               2 * (abs(FtoR(f2)) * (2 * e1 / 2))
               + 2 * (2 * e1 / 2 * (2 * e2 / 2)))
              / 2
              + FtoR(f1) * FtoR(f2)|]"
                                                   " [|FtoR(Fmul(b)(f1, f2)) - Fulp(b)(Fmul(b)(f1, f2)) / 2,
             FtoR(Fmul(b)(f1, f2)) + Fulp(b)(Fmul(b)(f1, f2)) / 2|]"
                                                   "r1 * r2")
                                                  (("1"
                                                    (split -1)
                                                    (("1"
                                                      (hide-all-but (-1 1))
                                                      (("1"
                                                        (use "mps_rew")
                                                        (("1"
                                                          (replace
                                                           -1
                                                           :hide?
                                                           t)
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (expand "size")
                                                              (("1"
                                                                (expand
                                                                 "[||]"
                                                                 -1)
                                                                (("1"
                                                                  (expand
                                                                   "mps")
                                                                  (("1"
                                                                    (assert)
                                                                    nil)))))))))))))))
                                                     ("2" (propax) nil)
                                                     ("3"
                                                      (hide-all-but (-1 1))
                                                      (("3"
                                                        (use "mps_rew")
                                                        (("3"
                                                          (replace
                                                           -1
                                                           :hide?
                                                           t)
                                                          (("3"
                                                            (assert)
                                                            nil)))))))))
                                                   ("2"
                                                    (hide-all-but 1)
                                                    (("2"
                                                      (use "mps_rew")
                                                      (("2"
                                                        (replace -1 :hide? t)
                                                        (("2"
                                                          (assert)
                                                          nil)))))))
                                                   ("3"
                                                    (hide-all-but 1)
                                                    (("3"
                                                      (use "mps_rew")
                                                      (("3"
                                                        (replace -1 :hide? t)
                                                        (("3"
                                                          (assert)
                                                          nil)))))))))))))))))))))))))))))))))))))
                     ("2" (hide-all-but 1)
                      (("2" (use "mps_rew")
                        (("2" (replace -1 :hide? t) (("2" (assert) nil)))))))
                     ("3" (hide-all-but 1)
                      (("3" (use "mps_rew")
                        (("3" (replace -1 :hide? t)
                          (("3" (assert) nil))))))))))))))))))))))))
    nil)
   nil nil)
  (mul_accum_err-2 nil 3682021395
   ("" (skeep)
    (("" (use "interval_as_absdif")
      (("" (replace -1 :hide? t)
        (("" (use "interval_as_absdif")
          (("" (replace -1 :hide? t)
            (("" (lemma "interval_as_absdif")
              (("" (inst? -1 :where 1)
                (("1" (replace -1 :hide? t)
                  (("1" (lemma "Mul_inclusion")
                    (("1"
                      (inst -1 "[|FtoR(f1) - e1, FtoR(f1) + e1|]"
                       "[|FtoR(f2) - e2, FtoR(f2) + e2|]" "r1" "r2")
                      (("1" (assert)
                        (("1" (expand "Mul")
                          (("1" (expand "[||]")
                            (("1" (expand "mul_aerr_bound")
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "mul_aerr_bound") (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((interval_as_absdif formula-decl nil interval interval_arith)
    (Fbounded? const-decl "bool" float nil)
    (Format type-eq-decl nil float nil) (FtoR const-decl "real" float nil)
    (float type-eq-decl nil float nil)
    (Interval type-eq-decl nil interval interval_arith))
   nil)
  (mul_accum_err-1 nil 3682020767
   ("" (skeep)
    (("" (expand "mul_aerr_bound")
      (("" (use "abs_dist")
        (("" (assert) (("" (hide -2) (("" (postpone) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   nil shostak))
 (Fmul_accum_err_bound 0
  (Fmul_accum_err_bound-1 nil 3682020622
   ("" (skeep)
    (("" (expand "mul_ulp_bound")
      (("" (name-replace "A___" "FtoR(f1)")
        (("" (name-replace "B___" "FtoR(f2)")
          (("" (use "abs_mult")
            (("" (replace -1 :hide? t)
              (("" (use "abs_dist")
                (("" (assert)
                  (("" (hide -2)
                    (("" (lemma "abs_dist")
                      (("" (inst? -1 :where -3)
                        (("" (assert)
                          (("" (hide -3)
                            ((""
                              (invoke (case "%1 <= (%2) * (%3)") (! 1 1)
                               (! -1 2) (! -2 2))
                              (("1" (grind-reals) nil nil)
                               ("2" (hide-all-but (-1 -2 1))
                                (("2" (lemma "le_times_le_pos")
                                  (("2"
                                    (inst -1 "abs(A___)" "abs(B___)"
                                     "abs(r2) + e2" "abs(r1) + e1")
                                    (("2" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((mul_ulp_bound const-decl "real" accum_err_mul nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (le_times_le_pos formula-decl nil real_props nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (abs_dist formula-decl nil abs_lems reals)
    (abs_mult formula-decl nil real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (b formal-const-decl "Format" accum_err_mul nil)
    (Fbounded? const-decl "bool" float nil)
    (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FtoR const-decl "real" float nil) (float type-eq-decl nil float nil)
    (radix formal-const-decl "above(1)" accum_err_mul nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (int nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil))
 (aelemmath_mul_TCC1 0
  (aelemmath_mul_TCC1-2 nil 3682021510
   ("" (skeep)
    (("" (use "ulp_abs")
      (("" (skeep)
        (("" (use "round_even_closest") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((ulp_abs formula-decl nil float nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" accum_err_mul nil)
    (RtoF formal-const-decl "CanonicRoundingFun(b, round)" accum_err_mul nil)
    (CanonicRoundingFun type-eq-decl nil float nil)
    (Fcanonic? const-decl "bool" float nil) (RNDF type-eq-decl nil float nil)
    (round formal-const-decl "ClosestRoundingPred(b)" accum_err_mul nil)
    (ClosestRoundingPred type-eq-decl nil float nil)
    (Closest? const-decl "bool" float nil)
    (RestrictedRounding type-eq-decl nil float nil)
    (EvenClosest? const-decl "bool" float nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Rounding type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil) (float type-eq-decl nil float nil)
    (b formal-const-decl "Format" accum_err_mul nil)
    (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (round_even_closest formula-decl nil accum_err_mul nil))
   nil
   (aelemmath_mul assuming
    "accum_err_op2sch[(float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), restrict[float[radix], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), real].restrict(float[accum_err_mul.radix].FtoR), accum_err_mul.RtoF, float[accum_err_mul.radix].ulp(accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF), LAMBDA (f1, f2): booleans.TRUE, restrict[[float[radix], float[radix]], [f1: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), {f2: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)) | booleans.TRUE}], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b))].restrict(std_mul[accum_err_mul.radix, accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF].Fmul), LAMBDA (r1, r2): booleans.TRUE, restrict[[numfield, numfield], [r1: reals.real, {r2: reals.real | booleans.TRUE}], numfield].restrict(number_fields.*), LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_ulp_bound].accum_err_op2sch"
    "ulp_abs: ASSUMPTION accum_err_op2sch.ulp(real_defs.abs(accum_err_op2sch.r1)) = accum_err_op2sch.ulp(accum_err_op2sch.r1)"))
  (aelemmath_mul_TCC1-1 nil 3682019115 ("" (assuming-tcc) nil nil) nil nil
   (aelemmath_mul assuming
    "accum_err_op2sch[(float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), restrict[float[radix], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), real].restrict(float[accum_err_mul.radix].FtoR), accum_err_mul.RtoF, float[accum_err_mul.radix].ulp(accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF), LAMBDA (f1, f2): booleans.TRUE, restrict[[float[radix], float[radix]], [f1: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), {f2: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)) | booleans.TRUE}], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b))].restrict(std_mul[accum_err_mul.radix, accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF].Fmul), LAMBDA (r1, r2): booleans.TRUE, restrict[[numfield, numfield], [r1: reals.real, {r2: reals.real | booleans.TRUE}], numfield].restrict(number_fields.*), LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_ulp_bound].accum_err_op2sch"
    "ulp_abs: ASSUMPTION accum_err_op2sch.ulp(real_defs.abs(accum_err_op2sch.r1)) = accum_err_op2sch.ulp(accum_err_op2sch.r1)")))
 (aelemmath_mul_TCC2 0
  (aelemmath_mul_TCC2-2 nil 3682021565
   ("" (skeep)
    (("" (use "ulp_monotone")
      (("1" (assert) nil nil) ("2" (use "round_rounded_mode") nil nil)) nil))
    nil)
   ((round_rounded_mode formula-decl nil accum_err_mul nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (round formal-const-decl "ClosestRoundingPred(b)" accum_err_mul nil)
    (ClosestRoundingPred type-eq-decl nil float nil)
    (Closest? const-decl "bool" float nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (b formal-const-decl "Format" accum_err_mul nil)
    (rounded_mode? const-decl "bool" float nil)
    (Rounding type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float nil) (Format type-eq-decl nil float nil)
    (RNDF type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil)
    (CanonicRoundingFun type-eq-decl nil float nil)
    (RtoF formal-const-decl "CanonicRoundingFun(b, round)" accum_err_mul nil)
    (radix formal-const-decl "above(1)" accum_err_mul nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (ulp_monotone formula-decl nil float nil))
   nil
   (aelemmath_mul assuming
    "accum_err_op2sch[(float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), restrict[float[radix], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), real].restrict(float[accum_err_mul.radix].FtoR), accum_err_mul.RtoF, float[accum_err_mul.radix].ulp(accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF), LAMBDA (f1, f2): booleans.TRUE, restrict[[float[radix], float[radix]], [f1: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), {f2: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)) | booleans.TRUE}], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b))].restrict(std_mul[accum_err_mul.radix, accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF].Fmul), LAMBDA (r1, r2): booleans.TRUE, restrict[[numfield, numfield], [r1: reals.real, {r2: reals.real | booleans.TRUE}], numfield].restrict(number_fields.*), LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_ulp_bound].accum_err_op2sch"
    "ulp_monotone: ASSUMPTION booleans.IMPLIES(booleans.AND(reals.<=(0, accum_err_op2sch.r1), reals.<=(accum_err_op2sch.r1, accum_err_op2sch.r2)), reals.<=(accum_err_op2sch.ulp(accum_err_op2sch.r1), accum_err_op2sch.ulp(accum_err_op2sch.r2)))"))
  (aelemmath_mul_TCC2-1 nil 3682019115 ("" (assuming-tcc) nil nil) nil nil
   (aelemmath_mul assuming
    "accum_err_op2sch[(float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), restrict[float[radix], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), real].restrict(float[accum_err_mul.radix].FtoR), accum_err_mul.RtoF, float[accum_err_mul.radix].ulp(accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF), LAMBDA (f1, f2): booleans.TRUE, restrict[[float[radix], float[radix]], [f1: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), {f2: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)) | booleans.TRUE}], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b))].restrict(std_mul[accum_err_mul.radix, accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF].Fmul), LAMBDA (r1, r2): booleans.TRUE, restrict[[numfield, numfield], [r1: reals.real, {r2: reals.real | booleans.TRUE}], numfield].restrict(number_fields.*), LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_ulp_bound].accum_err_op2sch"
    "ulp_monotone: ASSUMPTION booleans.IMPLIES(booleans.AND(reals.<=(0, accum_err_op2sch.r1), reals.<=(accum_err_op2sch.r1, accum_err_op2sch.r2)), reals.<=(accum_err_op2sch.ulp(accum_err_op2sch.r1), accum_err_op2sch.ulp(accum_err_op2sch.r2)))")))
 (aelemmath_mul_TCC3 0
  (aelemmath_mul_TCC3-2 nil 3682021582
   ("" (skeep) (("" (use "mul_accum_err") (("" (assert) nil nil)) nil)) nil)
   ((mul_accum_err formula-decl nil accum_err_mul nil)
    (b formal-const-decl "Format" accum_err_mul nil)
    (Fbounded? const-decl "bool" float nil)
    (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float nil)
    (radix formal-const-decl "above(1)" accum_err_mul nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil
   (aelemmath_mul assuming
    "accum_err_op2sch[(float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), restrict[float[radix], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), real].restrict(float[accum_err_mul.radix].FtoR), accum_err_mul.RtoF, float[accum_err_mul.radix].ulp(accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF), LAMBDA (f1, f2): booleans.TRUE, restrict[[float[radix], float[radix]], [f1: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), {f2: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)) | booleans.TRUE}], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b))].restrict(std_mul[accum_err_mul.radix, accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF].Fmul), LAMBDA (r1, r2): booleans.TRUE, restrict[[numfield, numfield], [r1: reals.real, {r2: reals.real | booleans.TRUE}], numfield].restrict(number_fields.*), LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_ulp_bound].accum_err_op2sch"
    "fR_err: ASSUMPTION booleans.IMPLIES(     (reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.r1)), accum_err_op2sch.e1)) AND (reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f2), accum_err_op2sch.r2)), accum_err_op2sch.e2)) AND accum_err_op2sch.fR_pre?(accum_err_op2sch.r1, accum_err_op2sch.r2) AND accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)) AND accum_err_op2sch.fun_bound_pre(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2), reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.fR(accum_err_op2sch.r1, accum_err_op2sch.r2))), accum_err_op2sch.fun_bound(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2)))"))
  (aelemmath_mul_TCC3-1 nil 3682019115 ("" (assuming-tcc) nil nil) nil nil
   (aelemmath_mul assuming
    "accum_err_op2sch[(float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), restrict[float[radix], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), real].restrict(float[accum_err_mul.radix].FtoR), accum_err_mul.RtoF, float[accum_err_mul.radix].ulp(accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF), LAMBDA (f1, f2): booleans.TRUE, restrict[[float[radix], float[radix]], [f1: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), {f2: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)) | booleans.TRUE}], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b))].restrict(std_mul[accum_err_mul.radix, accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF].Fmul), LAMBDA (r1, r2): booleans.TRUE, restrict[[numfield, numfield], [r1: reals.real, {r2: reals.real | booleans.TRUE}], numfield].restrict(number_fields.*), LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_ulp_bound].accum_err_op2sch"
    "fR_err: ASSUMPTION booleans.IMPLIES(     (reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.r1)), accum_err_op2sch.e1)) AND (reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f2), accum_err_op2sch.r2)), accum_err_op2sch.e2)) AND accum_err_op2sch.fR_pre?(accum_err_op2sch.r1, accum_err_op2sch.r2) AND accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)) AND accum_err_op2sch.fun_bound_pre(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2), reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.fR(accum_err_op2sch.r1, accum_err_op2sch.r2))), accum_err_op2sch.fun_bound(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2)))")))
 (aelemmath_mul_TCC4 0
  (aelemmath_mul_TCC4-3 "" 3790103314
   ("" (skeep) (("" (use "Fmul_error_ulp") nil nil)) nil)
   ((Fmul_error_ulp formula-decl nil std_mul nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" accum_err_mul nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float nil)
    (b formal-const-decl "Format" accum_err_mul nil)
    (float type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil)
    (Rounding type-eq-decl nil float nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Closest? const-decl "bool" float nil)
    (ClosestRoundingPred type-eq-decl nil float nil)
    (round formal-const-decl "ClosestRoundingPred(b)" accum_err_mul nil)
    (RNDF type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil)
    (CanonicRoundingFun type-eq-decl nil float nil)
    (RtoF formal-const-decl "CanonicRoundingFun(b, round)" accum_err_mul nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak
   (aelemmath_mul assuming
    "accum_err_op2sch[(float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), restrict[float[radix], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), real].restrict(float[accum_err_mul.radix].FtoR), accum_err_mul.RtoF, float[accum_err_mul.radix].ulp(accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF), LAMBDA (f1, f2): booleans.TRUE, restrict[[float[radix], float[radix]], [f1: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), {f2: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)) | booleans.TRUE}], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b))].restrict(std_mul[accum_err_mul.radix, accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF].Fmul), LAMBDA (r1, r2): booleans.TRUE, restrict[[numfield, numfield], [r1: reals.real, {r2: reals.real | booleans.TRUE}], numfield].restrict(number_fields.*), LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_ulp_bound].accum_err_op2sch"
    "fF_correctly_rounded: ASSUMPTION booleans.IMPLIES(booleans.AND(accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.fF_pre?(accum_err_op2sch.f1, accum_err_op2sch.f2)), reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.fF(accum_err_op2sch.f1, accum_err_op2sch.f2)), accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)))), number_fields./(accum_err_op2sch.ulp(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2))), 2)))"))
  (aelemmath_mul_TCC4-2 nil 3682021809
   ("" (skeep)
    (("" (use "Fmul_error_ulp")
      (("" (typepred "round")
        (("" (skeep)
          (("" (inst?)
            (("" (assert)
              (("" (expand "EvenClosest?") (("" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Fmul_error_ulp formula-decl nil std_mul nil)
    (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil)
    (Rounding type-eq-decl nil float nil)
    (Closest? const-decl "bool" float nil)
    (ClosestRoundingPred type-eq-decl nil float nil)
    (RNDF type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil)
    (CanonicRoundingFun type-eq-decl nil float nil))
   nil
   (aelemmath_mul assuming
    "accum_err_op2sch[(float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), restrict[float[radix], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), real].restrict(float[accum_err_mul.radix].FtoR), accum_err_mul.RtoF, float[accum_err_mul.radix].ulp(accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF), LAMBDA (f1, f2): booleans.TRUE, restrict[[float[radix], float[radix]], [f1: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), {f2: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)) | booleans.TRUE}], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b))].restrict(std_mul[accum_err_mul.radix, accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF].Fmul), LAMBDA (r1, r2): booleans.TRUE, restrict[[numfield, numfield], [r1: reals.real, {r2: reals.real | booleans.TRUE}], numfield].restrict(number_fields.*), LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_ulp_bound].accum_err_op2sch"
    "fF_correctly_rounded: ASSUMPTION booleans.IMPLIES(booleans.AND(accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.fF_pre?(accum_err_op2sch.f1, accum_err_op2sch.f2)), reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.fF(accum_err_op2sch.f1, accum_err_op2sch.f2)), accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)))), number_fields./(accum_err_op2sch.ulp(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2))), 2)))"))
  (aelemmath_mul_TCC4-1 nil 3682019115 ("" (assuming-tcc) nil nil) nil nil
   (aelemmath_mul assuming
    "accum_err_op2sch[(float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), restrict[float[radix], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), real].restrict(float[accum_err_mul.radix].FtoR), accum_err_mul.RtoF, float[accum_err_mul.radix].ulp(accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF), LAMBDA (f1, f2): booleans.TRUE, restrict[[float[radix], float[radix]], [f1: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), {f2: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)) | booleans.TRUE}], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b))].restrict(std_mul[accum_err_mul.radix, accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF].Fmul), LAMBDA (r1, r2): booleans.TRUE, restrict[[numfield, numfield], [r1: reals.real, {r2: reals.real | booleans.TRUE}], numfield].restrict(number_fields.*), LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_ulp_bound].accum_err_op2sch"
    "fF_correctly_rounded: ASSUMPTION booleans.IMPLIES(booleans.AND(accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.fF_pre?(accum_err_op2sch.f1, accum_err_op2sch.f2)), reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.fF(accum_err_op2sch.f1, accum_err_op2sch.f2)), accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)))), number_fields./(accum_err_op2sch.ulp(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2))), 2)))")))
 (aelemmath_mul_TCC5 0
  (aelemmath_mul_TCC5-2 nil 3682021597
   ("" (skeep) (("" (use "Fmul_accum_err_bound") (("" (assert) nil nil)) nil))
    nil)
   ((Fmul_accum_err_bound formula-decl nil accum_err_mul nil)
    (b formal-const-decl "Format" accum_err_mul nil)
    (Fbounded? const-decl "bool" float nil)
    (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float nil)
    (radix formal-const-decl "above(1)" accum_err_mul nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil
   (aelemmath_mul assuming
    "accum_err_op2sch[(float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), restrict[float[radix], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), real].restrict(float[accum_err_mul.radix].FtoR), accum_err_mul.RtoF, float[accum_err_mul.radix].ulp(accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF), LAMBDA (f1, f2): booleans.TRUE, restrict[[float[radix], float[radix]], [f1: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), {f2: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)) | booleans.TRUE}], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b))].restrict(std_mul[accum_err_mul.radix, accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF].Fmul), LAMBDA (r1, r2): booleans.TRUE, restrict[[numfield, numfield], [r1: reals.real, {r2: reals.real | booleans.TRUE}], numfield].restrict(number_fields.*), LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_ulp_bound].accum_err_op2sch"
    "f_ulp_bound: ASSUMPTION booleans.IMPLIES(booleans.AND(reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.r1)), accum_err_op2sch.e1), booleans.AND(reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f2), accum_err_op2sch.r2)), accum_err_op2sch.e2), booleans.AND(accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.ulp_bound_pre(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2)))), reals.<=(real_defs.abs(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2))), accum_err_op2sch.ulp_bound(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2)))"))
  (aelemmath_mul_TCC5-1 nil 3682019115 ("" (assuming-tcc) nil nil) nil nil
   (aelemmath_mul assuming
    "accum_err_op2sch[(float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), restrict[float[radix], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), real].restrict(float[accum_err_mul.radix].FtoR), accum_err_mul.RtoF, float[accum_err_mul.radix].ulp(accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF), LAMBDA (f1, f2): booleans.TRUE, restrict[[float[radix], float[radix]], [f1: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)), {f2: (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b)) | booleans.TRUE}], (float[accum_err_mul.radix].Fbounded?(accum_err_mul.b))].restrict(std_mul[accum_err_mul.radix, accum_err_mul.b, accum_err_mul.round, accum_err_mul.RtoF].Fmul), LAMBDA (r1, r2): booleans.TRUE, restrict[[numfield, numfield], [r1: reals.real, {r2: reals.real | booleans.TRUE}], numfield].restrict(number_fields.*), LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.TRUE, accum_err_mul.mul_ulp_bound].accum_err_op2sch"
    "f_ulp_bound: ASSUMPTION booleans.IMPLIES(booleans.AND(reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.r1)), accum_err_op2sch.e1), booleans.AND(reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f2), accum_err_op2sch.r2)), accum_err_op2sch.e2), booleans.AND(accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.ulp_bound_pre(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2)))), reals.<=(real_defs.abs(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2))), accum_err_op2sch.ulp_bound(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2)))")))
 (accum_err_bound 0
  (accum_err_bound-2 "" 3790103315
   ("" (skeep)
    (("" (use "aelemmath_mul.accumulated_error") (("" (assert) nil nil)) nil))
    nil)
   ((accumulated_error formula-decl nil accum_err_op2sch nil)
    (int nonempty-type-eq-decl nil integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" accum_err_mul nil)
    (float type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil)
    (b formal-const-decl "Format" accum_err_mul nil)
    (restrict const-decl "R" restrict nil) (FtoR const-decl "real" float nil)
    (Rounding type-eq-decl nil float nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Closest? const-decl "bool" float nil)
    (ClosestRoundingPred type-eq-decl nil float nil)
    (round formal-const-decl "ClosestRoundingPred(b)" accum_err_mul nil)
    (RNDF type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil)
    (CanonicRoundingFun type-eq-decl nil float nil)
    (RtoF formal-const-decl "CanonicRoundingFun(b, round)" accum_err_mul nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (ulp const-decl "posreal" float nil) (TRUE const-decl "bool" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Fmul const-decl
     "{f3: (Fcanonic?(b)) | Closest?(b)(FtoR(f1) * FtoR(f2), f3)}" std_mul
     nil)
    (mul_aerr_bound const-decl "nonneg_real" accum_err_mul nil)
    (mul_ulp_bound const-decl "real" accum_err_mul nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   shostak)
  (accum_err_bound-1 nil 3682019118
   ("" (skeep)
    (("" (use "aelemmath_mul.accumulated_error")
      (("" (assert)
        (("" (expand "mul_ulp_bound") (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((accumulated_error formula-decl nil accum_err_op2sch nil)
    (float type-eq-decl nil float nil) (Format type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil) (FtoR const-decl "real" float nil)
    (Rounding type-eq-decl nil float nil)
    (Closest? const-decl "bool" float nil)
    (ClosestRoundingPred type-eq-decl nil float nil)
    (RNDF type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil)
    (CanonicRoundingFun type-eq-decl nil float nil)
    (ulp const-decl "posreal" float nil)
    (Fmul const-decl
     "{f3: (Fcanonic?(b)) | Closest?(b)(FtoR(f1) * FtoR(f2), f3)}" std_mul
     nil))
   shostak)))

