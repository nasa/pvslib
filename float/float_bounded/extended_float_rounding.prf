(extended_float_rounding
 (radix__TCC1 0
  (radix__TCC1-1 nil 3765633954 ("" (judgement-tcc) nil nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (radix__ subtype
    "extended_float_rounding.radix_"
    "integers.above(1)")))
 (precision__TCC1 0
  (precision__TCC1-1 nil 3765633954
   ("" (typepred "radix_")
    (("" (typepred "precision_") (("" (assert) nil nil)) nil)) nil)
   ((precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil))
   nil
   (precision__ subtype
    "extended_float_rounding.precision_"
    "integers.above(1)")))
 (dExp__TCC1 0
  (dExp__TCC1-1 nil 3765633954
   ("" (typepred "precision_")
    (("" (typepred "radix_")
      (("" (typepred "dExp_") (("" (ground) nil nil)) nil)) nil))
    nil)
   ((nil name-judgement "above(1)"
     extended_float_rounding nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil))
   nil
   (dExp__ subtype
    "extended_float_rounding.dExp_"
    "{d: integers.posnat | reals.>(d, (number_fields.-)(number_fields.*(2, extended_float_rounding.precision_), 3))}")))
 (round_er_eq_unb_TCC1 0
  (round_er_eq_unb_TCC1-1 nil 3765734810
   ("" (skeep :preds? t)
    (("" (split 2)
      (("1" (rewrite "bound_on_exp_of_rounded_erreal") nil nil)
       ("2" (use "er_canonic")
        (("2" (skeep :preds? t)
          (("2" (replace -3 :dir rl :hide? y)
            (("2" (lemma "rnd_prj_ucf")
              (("2" (inst -1 "f")
                (("2" (expand "prj_ucf")
                  (("2" (replace -1 :hide? t)
                    (("2" (expand "FtoR") (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (above nonempty-type-eq-decl nil integers nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (bound_on_exp_of_rounded_erreal formula-decl nil
     extended_float_rounding__nearest_even nil)
    (rnd_prj_ucf formula-decl nil float_props_rounding nil)
    (prj_ucf const-decl "real" float_props_rounding nil)
    (FtoR const-decl "real" float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (float type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float nil)
    (Fcanonic? const-decl "bool" float nil)
    (given_format const-decl "Format" float_props_rounding nil)
    (unb_canonic_float type-eq-decl nil float_props_rounding nil)
    (<= const-decl "bool" reals nil)
    (max_exp const-decl "posint" extended_float nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding nil)
    (nil name-judgement "{d: posnat | d > 2 * (precision_ - 1) - 1}"
     extended_float_rounding nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (er_canonic formula-decl nil
     extended_float_exactly_representable_reals nil))
   nil
   (round_er_eq_unb subtype
    "float_props_rounding[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].rnd_ucf(extended_float_rounding.x)"
    "{v: float_props_rounding[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].unb_canonic_float | booleans.AND(reals.<=(Fexp(v), extended_float[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].max_exp), Fnum(v) /= 0)}")))
 (round_er_eq_unb 0
  (round_er_eq_unb-1 nil 3765734822
   ("" (skeep :preds? t)
    (("" (expand "round")
      (("" (use "er_lower_bound")
        (("" (use "er_upper_bound")
          (("" (rewrite "er_ub_correspondent")
            (("" (rewrite "er_lb_correspondent")
              (("" (assert)
                (("" (lift-if 2)
                  (("" (split 2)
                    (("1" (flatten)
                      (("1" (lemma "er_max_neg_prop")
                        (("1" (inst -1 "x")
                          (("1" (rewrite "er_max_neg_correspondent")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split 2)
                        (("1" (flatten)
                          (("1" (use "er_min_pos_prop")
                            (("1" (rewrite "er_min_pos_correspondent")
                              (("1" (assert) nil nil)) nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (split 2)
                            (("1" (flatten)
                              (("1"
                                (use "er_upper_bound")
                                (("1"
                                  (use "er_ub_correspondent")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding nil)
    (min_pos_value_xef_real name-judgement
     "xef_real[radix_, precision_, dExp_]"
     extended_float_rounding nil)
    (round const-decl "efloat" extended_float_rounding__nearest_even
     nil)
    (er_upper_bound formula-decl nil ieee754_domain nil)
    (er_lb const-decl "er_real" ieee754_domain nil)
    (er_lb_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (er_min_pos_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_min_pos_prop formula-decl nil ieee754_domain nil)
    (zero_is_er formula-decl nil ieee754_domain nil)
    (< const-decl "bool" reals nil)
    (x skolem-const-decl "{x: er_real | NOT x = 0}"
     extended_float_rounding nil)
    (er_max_neg_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_max_neg_prop formula-decl nil ieee754_domain nil)
    (posinf const-decl "efloat" extended_float nil)
    (poszero const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (nil name-judgement "{d: posnat | d > 2 * (precision_ - 1) - 1}"
     extended_float_rounding nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (er_lower_bound formula-decl nil ieee754_domain nil))
   nil))
 (proj_round_er_eq_unb_TCC1 0
  (proj_round_er_eq_unb_TCC1-1 nil 3765734566
   ("" (skeep :preds? t) (("" (use "rtoed_er_is_finite") nil nil)) nil)
   ((er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (above nonempty-type-eq-decl nil integers nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (rtoed_er_is_finite formula-decl nil
     extended_float_rounding__nearest_even nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil))
   nil
   (proj_round_er_eq_unb subtype
    "extended_float_rounding__nearest_even[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].round(extended_float_rounding.x)"
    "(extended_float[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].is_finite?)")))
 (proj_round_er_eq_unb 0
  (proj_round_er_eq_unb-1 nil 3765734582
   ("" (skeep :preds? t)
    (("" (use "er_lower_bound")
      (("" (use "er_upper_bound")
        (("" (rewrite "er_ub_correspondent")
          (("" (rewrite "er_lb_correspondent")
            (("" (expand "round")
              (("" (assert)
                (("" (lift-if 1)
                  (("" (split 1)
                    (("1" (flatten)
                      (("1" (expand "prj_ef")
                        (("1" (lemma "er_max_neg_prop")
                          (("1" (inst -1 "x")
                            (("1" (rewrite "er_max_neg_correspondent")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split 2)
                        (("1" (flatten)
                          (("1" (case "x=0")
                            (("1" (expand "prj_ef")
                              (("1"
                                (replace -1 :hide? t)
                                (("1"
                                  (rewrite "dtor_rtod_on_er")
                                  nil
                                  nil))
                                nil))
                              nil)
                             ("2" (lemma "er_min_pos_prop")
                              (("2"
                                (inst -1 "x")
                                (("1"
                                  (rewrite "er_min_pos_correspondent")
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (expand "prj_ef")
                            (("2" (split 2)
                              (("1"
                                (flatten)
                                (("1"
                                  (use "er_upper_bound")
                                  (("1"
                                    (use "er_ub_correspondent")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_lower_bound formula-decl nil ieee754_domain nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (above nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil)
    (emax const-decl "above(1)" extended_float nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (nil name-judgement "{d: posnat | d > 2 * (precision_ - 1) - 1}"
     extended_float_rounding nil)
    (er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding nil)
    (min_pos_value_xef_real name-judgement
     "xef_real[radix_, precision_, dExp_]"
     extended_float_rounding nil)
    (round const-decl "efloat" extended_float_rounding__nearest_even
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (er_min_pos_prop formula-decl nil ieee754_domain nil)
    (er_min_pos_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (dtor_rtod_on_er formula-decl nil
     extended_float_rounding__nearest_even nil)
    (er_max_neg_prop formula-decl nil ieee754_domain nil)
    (er_max_neg_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (x skolem-const-decl "er_real[radix_, precision_, emax]"
     extended_float_rounding nil)
    (< const-decl "bool" reals nil)
    (prj_ef const-decl "real" extended_float nil)
    (posinf const-decl "efloat" extended_float nil)
    (poszero const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (er_lb_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_lb const-decl "er_real" ieee754_domain nil)
    (er_upper_bound formula-decl nil ieee754_domain nil))
   nil))
 (proj_round_on_er 0
  (proj_round_on_er-1 nil 3765734102
   ("" (skeep :preds? t)
    (("" (use "er_lower_bound")
      (("" (use "er_upper_bound")
        (("" (rewrite "er_ub_correspondent")
          (("" (rewrite "er_lb_correspondent")
            (("" (expand "round")
              (("" (assert)
                (("" (lift-if 1)
                  (("" (split 1)
                    (("1" (flatten)
                      (("1" (expand "prj_ef")
                        (("1" (lemma "er_max_neg_prop")
                          (("1" (inst -1 "x")
                            (("1" (rewrite "er_max_neg_correspondent")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split 2)
                        (("1" (flatten)
                          (("1" (case "x=0")
                            (("1" (expand "prj_ef")
                              (("1" (propax) nil nil)) nil)
                             ("2" (lemma "er_min_pos_prop")
                              (("2"
                                (inst -1 "x")
                                (("1"
                                  (rewrite "er_min_pos_correspondent")
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (split 2)
                            (("1" (flatten)
                              (("1"
                                (use "er_upper_bound")
                                (("1"
                                  (use "er_ub_correspondent")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (expand "prj_ef")
                                (("2" (use "dtor_rtod_on_er") nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_lower_bound formula-decl nil ieee754_domain nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (above nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil)
    (emax const-decl "above(1)" extended_float nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (nil name-judgement "{d: posnat | d > 2 * (precision_ - 1) - 1}"
     extended_float_rounding nil)
    (er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding nil)
    (min_pos_value_xef_real name-judgement
     "xef_real[radix_, precision_, dExp_]"
     extended_float_rounding nil)
    (round const-decl "efloat" extended_float_rounding__nearest_even
     nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (dtor_rtod_on_er formula-decl nil
     extended_float_rounding__nearest_even nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (er_min_pos_prop formula-decl nil ieee754_domain nil)
    (er_min_pos_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_max_neg_prop formula-decl nil ieee754_domain nil)
    (er_max_neg_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (x skolem-const-decl "er_real[radix_, precision_, emax]"
     extended_float_rounding nil)
    (< const-decl "bool" reals nil)
    (prj_ef const-decl "real" extended_float nil)
    (posinf const-decl "efloat" extended_float nil)
    (poszero const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (er_lb_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_lb const-decl "er_real" ieee754_domain nil)
    (er_upper_bound formula-decl nil ieee754_domain nil))
   nil))
 (round_is_injective_on_er 0
  (round_is_injective_on_er-1 nil 3765734011
   ("" (skeep :preds? t)
    (("" (case "x=0")
      (("1" (rewrite -1)
        (("1" (rewrite "round_zero")
          (("1" (expand "round")
            (("1" (lift-if -3)
              (("1" (hide -1)
                (("1" (use "er_lower_bound")
                  (("1" (use "er_upper_bound")
                    (("1" (assert)
                      (("1" (split -4)
                        (("1" (propax) nil nil)
                         ("2" (flatten)
                          (("2" (split -1)
                            (("1" (propax) nil nil)
                             ("2" (flatten)
                              (("2"
                                (split -1)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (split 1)
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (use "er_min_pos_prop")
                                      (("1"
                                        (rewrite
                                         "er_min_pos_correspondent")
                                        (("1" (assert) nil nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (case "y= 0")
        (("1" (rewrite -1)
          (("1" (hide 2)
            (("1" (rewrite "round_zero")
              (("1" (expand "round")
                (("1" (lift-if -3)
                  (("1" (hide -2)
                    (("1" (use "er_lower_bound")
                      (("1" (use "er_upper_bound")
                        (("1" (assert)
                          (("1" (split -4)
                            (("1" (propax) nil nil)
                             ("2" (flatten)
                              (("2"
                                (split -1)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (decompose-equality -3)
                                    nil
                                    nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (split -1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (split 1)
                                        (("1" (assert) nil nil)
                                         ("2"
                                          (use "er_min_pos_prop")
                                          (("1"
                                            (rewrite
                                             "er_min_pos_correspondent")
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (case "rnd_ucf(x) = rnd_ucf(y)")
          (("1" (hide -4)
            (("1" (typepred "rnd_ucf(x)")
              (("1" (expand "currified_closest?_ucf")
                (("1" (expand "closest?_ucf")
                  (("1" (use "EvenClosest_Unique")
                    (("1" (expand "Unique?")
                      (("1" (inst -1 "x" "rnd_ucf(x)" "rnd_ucf(y)")
                        (("1" (split -1)
                          (("1" (lemma "proj_round_on_er")
                            (("1" (inst -1 "x")
                              (("1"
                                (lemma "proj_round_on_er")
                                (("1"
                                  (inst -1 "y")
                                  (("1"
                                    (rewrite "proj_round_er_eq_unb")
                                    (("1"
                                      (rewrite "proj_round_er_eq_unb")
                                      (("1"
                                        (expand "prj_ucf")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil)
                           ("3" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (lemma "round_er_eq_unb")
            (("2" (inst -1 "x")
              (("2" (rewrite -1)
                (("2" (lemma "round_er_eq_unb")
                  (("2" (inst -1 "y")
                    (("2" (rewrite -1)
                      (("2" (decompose-equality -3) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (round_zero formula-decl nil extended_float_rounding__nearest_even
     nil)
    (poszero const-decl "efloat" extended_float nil)
    (er_lower_bound formula-decl nil ieee754_domain nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (nil name-judgement "{d: posnat | d > 2 * (precision_ - 1) - 1}"
     extended_float_rounding nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (neginf const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (zero_exclusive formula-decl nil extended_float nil)
    (posinf const-decl "efloat" extended_float nil)
    (er_min_pos_prop formula-decl nil ieee754_domain nil)
    (y skolem-const-decl "er_real[radix_, precision_, emax]"
     extended_float_rounding nil)
    (< const-decl "bool" reals nil)
    (er_min_pos_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_lb const-decl "er_real" ieee754_domain nil)
    (er_upper_bound formula-decl nil ieee754_domain nil)
    (round const-decl "efloat" extended_float_rounding__nearest_even
     nil)
    (min_pos_value_xef_real name-judgement
     "xef_real[radix_, precision_, dExp_]"
     extended_float_rounding nil)
    (max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding nil)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     float_props_rounding nil)
    (currified_closest?_ucf const-decl "bool" float_props_rounding nil)
    (Fbounded? const-decl "bool" float nil)
    (unb_canonic_float type-eq-decl nil float_props_rounding nil)
    (given_format const-decl "Format" float_props_rounding nil)
    (Fcanonic? const-decl "bool" float nil)
    (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (closest?_ucf const-decl "bool" float_props_rounding nil)
    (Unique? const-decl "bool" float nil)
    (prj_ucf const-decl "real" float_props_rounding nil)
    (proj_round_er_eq_unb formula-decl nil
     extended_float_rounding nil)
    (proj_round_on_er formula-decl nil
     extended_float_rounding nil)
    (EvenClosest_Unique formula-decl nil float nil)
    (nzfinite adt-constructor-decl
     "[{v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0} ->
   (nzfinite?)]" extended_float nil)
    (val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]"
     extended_float nil)
    (/= const-decl "boolean" notequal nil)
    (max_exp const-decl "posint" extended_float nil)
    (<= const-decl "bool" reals nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (round_er_eq_unb formula-decl nil
     extended_float_rounding nil)
    (x skolem-const-decl "er_real[radix_, precision_, emax]"
     extended_float_rounding nil)
    (TRUE const-decl "bool" booleans nil)
    (FALSE const-decl "bool" booleans nil)
    (zero adt-constructor-decl "[bool -> (zero?)]" extended_float nil)
    (positive? shared-adt-accessor-decl
     "[{x: efloat | infinite?(x) OR zero?(x)} -> bool]" extended_float
     nil)
    (zero? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (infinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (efloat type-decl nil extended_float nil))
   nil))
 (ieee754_semantics_round_proj_interpretation_obligation_1_TCC1 0
  (ieee754_semantics_round_proj_interpretation_obligation_1_TCC1-1 nil
   3765735133 ("" (subtype-tcc) nil nil)
   ((dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (is_finite? const-decl "bool" extended_float nil))
   nil
   (ieee754_semantics_round_proj_interpretation_obligation_1 subtype
    "extended_float_rounding.f"
    "(extended_float[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].is_finite?)")))
 (ieee754_semantics_round_proj_interpretation_obligation_1 0
  (ieee754_semantics_round_proj_interpretation_obligation_1-1 nil
   3765735141
   ("" (skeep)
    (("" (use "round_inverse_of_projection_on_nzfinite")
      (("" (assert) nil nil)) nil))
    nil)
   ((round_inverse_of_projection_on_nzfinite formula-decl nil
     extended_float_rounding__nearest_even nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil)
    (efloat type-decl nil extended_float nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (nil name-judgement "{d: posnat | d > 2 * (precision_ - 1) - 1}"
     extended_float_rounding nil))
   nil))
 (ieee754_semantics_nzfinite?_def_interpretation_obligation_1 0
  (ieee754_semantics_nzfinite?_def_interpretation_obligation_1-2 ""
   3790103861
   ("" (skeep)
    (("" (mapped-axiom-tcc) (("" (grind-reals) nil nil)) nil)) nil)
   ((nil name-judgement "above(1)"
     extended_float_rounding nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (prj_ef const-decl "real" extended_float nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (zero_inclusive formula-decl nil extended_float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (/= const-decl "boolean" notequal nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding nil)
    (FtoR const-decl "real" float nil)
    (prj_ucf const-decl "real" float_props_rounding nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonzero_times3 formula-decl nil real_props nil))
   shostak)
  (ieee754_semantics_nzfinite?_def_interpretation_obligation_1-1 nil
   3765633636
   ("" (then (skeep) (mapped-axiom-tcc) (grind-reals)) nil nil)
   ((FtoR const-decl "real" float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (zero_inclusive formula-decl nil extended_float nil))
   shostak))
 (ieee754_semantics_pfinite?_def_interpretation_obligation_1 0
  (ieee754_semantics_pfinite?_def_interpretation_obligation_1-1 nil
   3765633683
   ("" (skeep)
    (("" (mapped-axiom-tcc)
      (("1" (grind-reals) nil nil) ("2" (grind-reals) nil nil)) nil))
    nil)
   ((nil name-judgement "above(1)"
     extended_float_rounding nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nzpfinite? const-decl "bool" extended_float nil)
    (zero_inclusive formula-decl nil extended_float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding nil)
    (prj_ef const-decl "real" extended_float nil)
    (prj_ucf const-decl "real" float_props_rounding nil)
    (FtoR const-decl "real" float nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pos_times_gt formula-decl nil real_props nil))
   shostak))
 (ieee754_semantics_nfinite?_def_interpretation_obligation_1 0
  (ieee754_semantics_nfinite?_def_interpretation_obligation_1-1 nil
   3765633683
   ("" (skeep)
    (("" (mapped-axiom-tcc)
      (("1" (grind-reals) nil nil) ("2" (grind-reals) nil nil)) nil))
    nil)
   ((nil name-judgement "above(1)"
     extended_float_rounding nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nznfinite? const-decl "bool" extended_float nil)
    (zero_inclusive formula-decl nil extended_float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding nil)
    (prj_ef const-decl "real" extended_float nil)
    (prj_ucf const-decl "real" float_props_rounding nil)
    (FtoR const-decl "real" float nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (neg_times_lt formula-decl nil real_props nil))
   shostak))
 (ieee754_semantics_add_inv_def_interpretation_obligation_1_TCC1 0
  (ieee754_semantics_add_inv_def_interpretation_obligation_1_TCC1-1 nil
   3765633590 ("" (subtype-tcc) nil nil)
   ((radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Fopp const-decl "float" float nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (flip_sign const-decl "efloat" extended_float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (int_times_int_is_int application-judgement "int" integers nil))
   nil
   (ieee754_semantics_add_inv_def_interpretation_obligation_1 subtype
    "extended_float[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].flip_sign(extended_float_rounding.f)"
    "(extended_float[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].is_finite?)")))
 (ieee754_semantics_add_inv_def_interpretation_obligation_1 0
  (ieee754_semantics_add_inv_def_interpretation_obligation_1-2 ""
   3790103865
   ("" (skeep :preds? t)
    (("" (expand "flip_sign")
      (("" (expand "prj_ef")
        (("" (expand "prj_ucf") (("" (use "FoppCorrect") nil nil))
          nil))
        nil))
      nil))
    nil)
   ((flip_sign const-decl "efloat" extended_float nil)
    (prj_ucf const-decl "real" float_props_rounding nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (FoppCorrect formula-decl nil float nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (nil name-judgement "{d: posnat | d > 2 * (precision_ - 1) - 1}"
     extended_float_rounding nil)
    (float type-eq-decl nil float nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil)
    (efloat type-decl nil extended_float nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (Format type-eq-decl nil float nil)
    (Fcanonic? const-decl "bool" float nil)
    (given_format const-decl "Format" float_props_rounding nil)
    (unb_canonic_float type-eq-decl nil float_props_rounding nil)
    (<= const-decl "bool" reals nil)
    (max_exp const-decl "posint" extended_float nil)
    (/= const-decl "boolean" notequal nil)
    (val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]"
     extended_float nil)
    (prj_ef const-decl "real" extended_float nil))
   shostak)
  (ieee754_semantics_add_inv_def_interpretation_obligation_1-1 nil
   3765633600
   (""
    (then (skeep :preds? t) (expand "flip_sign") (expand "prj_ef")
     (expand "prj_ucf") (use "FoppCorrect"))
    nil nil)
   ((val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]"
     extended_float nil)
    (max_exp const-decl "posint" extended_float nil)
    (Fcanonic? const-decl "bool" float nil)
    (Format type-eq-decl nil float nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (efloat type-decl nil extended_float nil)
    (float type-eq-decl nil float nil)
    (FoppCorrect formula-decl nil float nil))
   shostak))
 (proj_round_is_monotone_on_er_TCC1 0
  (proj_round_is_monotone_on_er_TCC1-1 nil 3799155549
   ("" (skeep) (("" (use "rtoed_er_is_finite") nil nil)) nil)
   ((er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (emax const-decl "above(1)" extended_float nil)
    (above nonempty-type-eq-decl nil integers nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (rtoed_er_is_finite formula-decl nil
     extended_float_rounding__nearest_even nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil))
   nil
   (proj_round_is_monotone_on_er subtype
    "extended_float_rounding__nearest_even[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].round(extended_float_rounding.y)"
    "(extended_float[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].is_finite?)")))
 (proj_round_is_monotone_on_er 0
  (proj_round_is_monotone_on_er-1 nil 3799155570
   ("" (skeep :preds? t)
    (("" (rewrite "proj_round_er_eq_unb")
      (("" (rewrite "proj_round_er_eq_unb")
        (("" (typepred "rnd_ucf(x)")
          (("" (expand "currified_closest?_ucf")
            (("" (use "closest?_ucf__j")
              (("" (flatten)
                (("" (expand "rounded_mode?")
                  (("" (flatten)
                    (("" (expand "monotone?")
                      (("" (inst -5 "x" "y" "rnd_ucf(x)" "rnd_ucf(y)")
                        (("" (split -5)
                          (("1" (expand "prj_ucf")
                            (("1" (propax) nil nil)) nil)
                           ("2" (case "x=y")
                            (("1" (assert) nil nil)
                             ("2" (assert) nil nil))
                            nil)
                           ("3" (propax) nil nil)
                           ("4" (typepred "rnd_ucf(y)")
                            (("4" (expand "currified_closest?_ucf")
                              (("4" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((proj_round_er_eq_unb formula-decl nil
     extended_float_rounding nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (above nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}"
     extended_float_rounding nil)
    (emax const-decl "above(1)" extended_float nil)
    (exactly_representable? const-decl "bool" ieee754_domain nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain nil)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     float_props_rounding nil)
    (currified_closest?_ucf const-decl "bool" float_props_rounding nil)
    (Fbounded? const-decl "bool" float nil)
    (unb_canonic_float type-eq-decl nil float_props_rounding nil)
    (given_format const-decl "Format" float_props_rounding nil)
    (Fcanonic? const-decl "bool" float nil)
    (float type-eq-decl nil float nil)
    (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nil name-judgement "{d: posnat | d > 2 * (precision_ - 1) - 1}"
     extended_float_rounding nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nil name-judgement "above(1)"
     extended_float_rounding nil)
    (closest?_ucf__j judgement-tcc nil float_props_rounding nil)
    (closest?_ucf__j name-judgement
     "{round: RestrictedRounding[radix_](given_format, EvenClosest?) |
   rounded_mode?(given_format)(round)}"
     extended_float_rounding nil)
    (rounded_mode? const-decl "bool" float nil)
    (monotone? const-decl "bool" float nil)
    (prj_ucf const-decl "real" float_props_rounding nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak)))

