(accum_err_div
 (div_aerr_bound_TCC1 0
  (div_aerr_bound_TCC1-2 nil 3682071131
   ("" (skeep :preds? t)
    (("" (case "0 < r2 - e2")
      (("1" (assert)
        (("1" (hide -4)
          (("1" (lemma "both_sides_times_pos_gt1")
            (("1" (inst -1 "abs(r2)" "r2-e2" "0")
              (("1" (assert)
                (("1" (case "abs(r2)*r2=r2*r2")
                  (("1" (replace -1) (("1" (assert) nil nil)) nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert)
        (("2" (lemma "both_sides_times_neg_gt1")
          (("2" (inst -1 "-abs(r2)" "r2+e2" "0")
            (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (negreal nonempty-type-eq-decl nil real_types nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (both_sides_times_neg_gt1 formula-decl nil real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (both_sides_times_pos_gt1 formula-decl nil real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil))
   nil
   (div_aerr_bound subtype
    "((number_fields.-)(number_fields.*(accum_err_div.r2, accum_err_div.r2), number_fields.*(accum_err_div.e2, real_defs.abs(accum_err_div.r2))))"
    "nznum"))
  (div_aerr_bound_TCC1-1 nil 3682070876 ("" (subtype-tcc) nil nil) nil nil
   (div_aerr_bound subtype
    "((number_fields.-)(number_fields.*(accum_err_div.r2, accum_err_div.r2), number_fields.*(accum_err_div.e2, real_defs.abs(accum_err_div.r2))))"
    "nznum")))
 (div_aerr_bound_TCC2 0
  (div_aerr_bound_TCC2-1 nil 3682355354
   ("" (skeep)
    (("" (use "pos_div_le")
      (("" (expand ">=")
        (("" (replace -1 :hide? t)
          (("" (flatten)
            (("" (assert)
              (("" (typepred "e2")
                (("" (grind-reals)
                  (("1" (lemma "both_sides_times_pos_gt1")
                    (("1" (inst -1 "abs(r2)" "r2-e2" "0")
                      (("1" (assert)
                        (("1" (case "abs(r2)*r2=r2*r2")
                          (("1" (replace -1) (("1" (assert) nil nil)) nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (lemma "both_sides_times_neg_gt1")
                    (("2" (inst -1 "-abs(r2)" "r2+e2" "0")
                      (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pos_div_le formula-decl nil real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (both_sides_times_neg_gt1 formula-decl nil real_props nil)
    (<= const-decl "bool" reals nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (negreal nonempty-type-eq-decl nil real_types nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (both_sides_times_pos_gt1 formula-decl nil real_props nil)
    (zero_times1 formula-decl nil real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (both_sides_times1 formula-decl nil real_props nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil))
   nil
   (div_aerr_bound subtype
    "number_fields./(((number_fields.+)(number_fields.*(real_defs.abs(accum_err_div.r2), accum_err_div.e1), number_fields.*(real_defs.abs(accum_err_div.r1), accum_err_div.e2))), ((number_fields.-)(number_fields.*(accum_err_div.r2, accum_err_div.r2), number_fields.*(accum_err_div.e2, real_defs.abs(accum_err_div.r2)))))"
    "nonneg_real")))
 (div_accum_err_TCC1 0
  (div_accum_err_TCC1-1 nil 3682070876
   ("" (skeep) (("" (grind-reals) nil nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (div_accum_err subtype "float[accum_err_div.radix].FtoR(accum_err_div.f2)"
    "nznum")))
 (div_accum_err_TCC2 0
  (div_accum_err_TCC2-1 nil 3682070876 ("" (subtype-tcc) nil nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil)
    (b formal-const-decl "Format" accum_err_div nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (rat_abs_is_nonneg application-judgement "{r: nonneg_rat | r >= q}"
     real_defs nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (^ const-decl "real" exponentiation nil)
    (vNum const-decl "posnat" float nil)
    (radix formal-const-decl "above(1)" accum_err_div nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (FtoR const-decl "real" float nil) (/= const-decl "boolean" notequal nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil))
   nil (div_accum_err subtype "accum_err_div.r2" "nznum")))
 (div_accum_err_TCC3 0
  (div_accum_err_TCC3-1 nil 3682070876 ("" (subtype-tcc) nil nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil)
    (b formal-const-decl "Format" accum_err_div nil)
    (radix formal-const-decl "above(1)" accum_err_div nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (FtoR const-decl "real" float nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil))
   nil
   (div_accum_err subtype "accum_err_div.e2"
    "{e2 | booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0))}")))
 (div_accum_err 0
  (div_accum_err-1 nil 3682070910
   ("" (expand "div_aerr_bound")
    (("" (skeep)
      ((""
        (case "EXISTS(ep1:real): -e1 <= ep1 AND ep1 <= e1 AND FtoR(f1) = r1 + ep1")
        (("1" (hide -2)
          (("1"
            (case "EXISTS(ep2:real): -e2 <= ep2 AND ep2 <= e2 AND FtoR(f2) = r2 + ep2")
            (("1" (hide -3)
              (("1" (skeep -1)
                (("1" (skeep -4)
                  (("1" (replace -3 :hide? t)
                    (("1" (replace -5 :hide? t)
                      (("1" (use "minus_div1")
                        (("1" (replace -1 :hide? t)
                          (("1" (case "NOT (r2 + ep2) * r2 = r2*r2 + ep2*r2")
                            (("1" (assert) nil nil)
                             ("2" (replace -1 :hide? t)
                              (("2"
                                (case "NOT (r1 + ep1) * r2 - r1 * (r2 + ep2) = ep1*r2 - r1*ep2 ")
                                (("1" (assert) nil nil)
                                 ("2" (replace -1 :hide? t)
                                  (("2" (use "abs_div")
                                    (("2" (replace -1 :hide? t)
                                      (("2"
                                        (invoke
                                         (case "%1 <= %2")
                                         (! 1 1 1)
                                         (! 1 2 1))
                                        (("1"
                                          (invoke
                                           (case "%1 <= %2")
                                           (! 1 2 2)
                                           (! 1 1 2))
                                          (("1"
                                            (invoke
                                             (name-replace "a1" "%1")
                                             (! -1 1))
                                            (("1"
                                              (invoke
                                               (name-replace "a2" "%1")
                                               (! -1 2))
                                              (("1"
                                                (invoke
                                                 (name-replace "b1" "%1")
                                                 (! -2 1))
                                                (("1"
                                                  (invoke
                                                   (name-replace "b2" "%1")
                                                   (! -2 2))
                                                  (("1"
                                                    (with-labels
                                                     (case "a1>0")
                                                     "a1 gt 0")
                                                    (("1"
                                                      (hide "a1 gt 0")
                                                      (("1"
                                                        (lemma
                                                         "both_sides_div_pos_le1")
                                                        (("1"
                                                          (inst? -1 :where -3)
                                                          (("1"
                                                            (inst -1 "a1")
                                                            (("1"
                                                              (replace
                                                               -1
                                                               :hide?
                                                               t
                                                               :dir
                                                               rl)
                                                              (("1"
                                                                (lemma
                                                                 "both_sides_div_pos_le2")
                                                                (("1"
                                                                  (inst?
                                                                   -1
                                                                   :where
                                                                   -2)
                                                                  (("1"
                                                                    (inst
                                                                     -1
                                                                     "b1")
                                                                    (("1"
                                                                      (replace
                                                                       -1
                                                                       :hide?
                                                                       t
                                                                       :dir
                                                                       rl)
                                                                      (("1"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (reveal
                                                                     "a1 gt 0")
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil)
                                                                   ("3"
                                                                    (reveal
                                                                     "a1 gt 0")
                                                                    (("3"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (reveal
                                                               "a1 gt 0")
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (expand "a1")
                                                      (("2"
                                                        (case
                                                         "NOT  (r2 * r2 - e2 * abs(r2)) > 0 = (r2 * r2 > e2 * abs(r2))")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (replace
                                                           -1
                                                           :hide?
                                                           t)
                                                          (("2"
                                                            (expand ">")
                                                            (("2"
                                                              (expand "abs")
                                                              (("2"
                                                                (lift-if 1)
                                                                (("2"
                                                                  (split 1)
                                                                  (("1"
                                                                    (flatten)
                                                                    (("1"
                                                                      (assert)
                                                                      (("1"
                                                                        (case
                                                                         "NOT e2 * -r2 = -e2 * r2")
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil)
                                                                         ("2"
                                                                          (replace
                                                                           -1
                                                                           :hide?
                                                                           t)
                                                                          (("2"
                                                                            (use
                                                                             "both_sides_times_neg_lt1")
                                                                            (("2"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (use
                                                                         "both_sides_times_pos_lt1")
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (hide (-1 2))
                                            (("2"
                                              (case "ep2 * r2 <= 0")
                                              (("1"
                                                (case
                                                 "NOT r2 * r2 + ep2 * r2 = r2 * r2 - -(ep2 * r2)")
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (replace -1 :hide? t)
                                                  (("2"
                                                    (case
                                                     "NOT r2 * r2 >= -(ep2 * r2)")
                                                    (("1"
                                                      (case
                                                       "NOT -(ep2 * r2) = -ep2 * r2")
                                                      (("1" (assert) nil nil)
                                                       ("2"
                                                        (replace -1 :hide? t)
                                                        (("2"
                                                          (hide 2)
                                                          (("2"
                                                            (case "r2 > 0")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (use
                                                                 "both_sides_times_pos_ge1")
                                                                (("1"
                                                                  (replace
                                                                   -1
                                                                   :hide?
                                                                   t)
                                                                  (("1"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (case "r2 < 0")
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (hide 1)
                                                                  (("1"
                                                                    (use
                                                                     "both_sides_times_neg_ge1")
                                                                    (("1"
                                                                      (replace
                                                                       -1
                                                                       :hide?
                                                                       t)
                                                                      (("1"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (case
                                                       "NOT abs(r2 * r2 - -(ep2 * r2)) = abs(r2 * r2) - abs(-(ep2 * r2))")
                                                      (("1" (grind) nil nil)
                                                       ("2"
                                                        (replace -1 :hide? t)
                                                        (("2"
                                                          (case
                                                           "NOT abs(r2 * r2) = r2*r2")
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (replace
                                                             -1
                                                             :hide?
                                                             t)
                                                            (("2"
                                                              (case
                                                               "NOT abs(-(ep2 * r2)) = abs(ep2) * abs(r2)")
                                                              (("1"
                                                                (case
                                                                 "NOT abs(-(ep2 * r2)) = abs(ep2 * r2)")
                                                                (("1"
                                                                  (assert)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (replace
                                                                   -1
                                                                   :hide?
                                                                   t)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (use
                                                                       "abs_mult")
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (replace
                                                                 -1
                                                                 :hide?
                                                                 t)
                                                                (("2"
                                                                  (assert)
                                                                  (("2"
                                                                    (lemma
                                                                     "both_sides_minus_le2")
                                                                    (("2"
                                                                      (inst?
                                                                       -1
                                                                       :where
                                                                       1)
                                                                      (("2"
                                                                        (replace
                                                                         -1
                                                                         :hide?
                                                                         t)
                                                                        (("2"
                                                                          (use
                                                                           "both_sides_times_pos_le1")
                                                                          (("2"
                                                                            (replace
                                                                             -1
                                                                             :hide?
                                                                             t)
                                                                            (("2"
                                                                              (grind)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (case " NOT ep2 * r2 > 0")
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (hide 1)
                                                  (("2"
                                                    (case
                                                     "NOT  abs(r2 * r2 + ep2 * r2) =  r2 * r2 + ep2 * r2")
                                                    (("1" (assert) nil nil)
                                                     ("2"
                                                      (replace -1 :hide? t)
                                                      (("2" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide 2)
                                          (("2"
                                            (case
                                             "NOT abs(ep1 * r2 - r1 * ep2) <= abs(ep1 * r2) + abs(r1 * ep2)")
                                            (("1" (grind) nil nil)
                                             ("2"
                                              (use "abs_mult")
                                              (("2"
                                                (replace -1 :hide? t)
                                                (("2"
                                                  (use "abs_mult")
                                                  (("2"
                                                    (replace -1 :hide? t)
                                                    (("2"
                                                      (case
                                                       "abs(ep1) * abs(r2) + abs(r1) * abs(ep2) <= e1 * abs(r2) + abs(r1) * e2")
                                                      (("1" (assert) nil nil)
                                                       ("2"
                                                        (hide 2)
                                                        (("2"
                                                          (hide -1)
                                                          (("2"
                                                            (invoke
                                                             (case
                                                              "%1 <= %2 AND %3 <= %4")
                                                             (! 1 1 1)
                                                             (! 1 2 1)
                                                             (! 1 1 2)
                                                             (! 1 2 2))
                                                            (("1"
                                                              (flatten)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (hide 2)
                                                              (("2"
                                                                (split 1)
                                                                (("1"
                                                                  (use
                                                                   "both_sides_times_pos_le1")
                                                                  (("1"
                                                                    (replace
                                                                     -1
                                                                     :hide?
                                                                     t)
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (use
                                                                   "both_sides_times_pos_le2")
                                                                  (("1"
                                                                    (replace
                                                                     -1
                                                                     :hide?
                                                                     t)
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but (-2 1))
              (("2" (expand "abs")
                (("2" (lift-if -1)
                  (("2" (split -1)
                    (("1" (flatten)
                      (("1" (inst 1 "(FtoR(f2) - r2)")
                        (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (inst 1 "(FtoR(f2) - r2)")
                      (("2" (assert)
                        (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (inst 1 "(FtoR(f1) - r1)") (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (b formal-const-decl "Format" accum_err_div nil)
    (Fbounded? const-decl "bool" float nil)
    (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FtoR const-decl "real" float nil) (float type-eq-decl nil float nil)
    (radix formal-const-decl "above(1)" accum_err_div nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (nnreal type-eq-decl nil real_types nil)
    (both_sides_div_pos_le1 formula-decl nil real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (b1 skolem-const-decl
     "{n: nonneg_real | n >= ep1 * r2 - r1 * ep2 AND n >= -(ep1 * r2 - r1 * ep2)}"
     accum_err_div nil)
    (r1 skolem-const-decl "real" accum_err_div nil)
    (ep1 skolem-const-decl "real" accum_err_div nil)
    (a2 skolem-const-decl
     "{n: nonneg_real | n >= ep2 * r2 + r2 * r2 AND n >= -(ep2 * r2 + r2 * r2)}"
     accum_err_div nil)
    (r2 skolem-const-decl "real" accum_err_div nil)
    (ep2 skolem-const-decl "real" accum_err_div nil)
    (both_sides_div_pos_le2 formula-decl nil real_props nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (a1 skolem-const-decl "real" accum_err_div nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (both_sides_times_pos_lt1 formula-decl nil real_props nil)
    (negreal nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil)
    (nonpos_real nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_neg_lt1 formula-decl nil real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (both_sides_times_pos_ge1 formula-decl nil real_props nil)
    (both_sides_times_neg_ge1 formula-decl nil real_props nil)
    (abs_mult formula-decl nil real_props nil)
    (both_sides_times_pos_le1 formula-decl nil real_props nil)
    (both_sides_minus_le2 formula-decl nil real_props nil)
    (both_sides_times_pos_le2 formula-decl nil real_props nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (abs_div formula-decl nil real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (minus_div1 formula-decl nil real_props nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (div_aerr_bound const-decl "nonneg_real" accum_err_div nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil))
   nil))
 (div_ulp_bound_TCC1 0
  (div_ulp_bound_TCC1-1 nil 3682070876 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (/= const-decl "boolean" notequal nil))
   nil
   (div_ulp_bound subtype
    "((number_fields.-)(real_defs.abs(accum_err_div.r2), accum_err_div.e2))"
    "nznum")))
 (Fdiv_accum_err_bound 0
  (Fdiv_accum_err_bound-1 nil 3682159767
   ("" (skeep)
    (("" (expand "div_ulp_bound")
      (("" (use "abs_div")
        (("" (replace -1 :hide? t)
          (("" (use "le_div_le_pos")
            (("1" (assert)
              (("1" (split 1)
                (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)
                 ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil))
                nil))
              nil)
             ("2" (grind-reals) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((div_ulp_bound const-decl "real" accum_err_div nil)
    (le_div_le_pos formula-decl nil real_props nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (e2 skolem-const-decl "nonneg_real" accum_err_div nil)
    (r2 skolem-const-decl "real" accum_err_div nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)
    (posint_times_posint_is_posint application-judgement "posint" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (minus_rat_is_rat application-judgement "rat" rationals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (/= const-decl "boolean" notequal nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" accum_err_div nil)
    (float type-eq-decl nil float nil) (FtoR const-decl "real" float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil)
    (b formal-const-decl "Format" accum_err_div nil)
    (abs_div formula-decl nil real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil))
   shostak))
 (IMP_accum_err_op2sch_TCC1 0
  (IMP_accum_err_op2sch_TCC1-2 nil 3682158425
   ("" (skeep)
    (("" (use "ulp_abs")
      (("" (hide 2)
        (("" (skeep)
          (("" (use "round_even_closest") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((ulp_abs formula-decl nil float nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" accum_err_div nil)
    (RtoF formal-const-decl "CanonicRoundingFun(b, round)" accum_err_div nil)
    (CanonicRoundingFun type-eq-decl nil float nil)
    (Fcanonic? const-decl "bool" float nil) (RNDF type-eq-decl nil float nil)
    (round formal-const-decl "ClosestRoundingPred(b)" accum_err_div nil)
    (ClosestRoundingPred type-eq-decl nil float nil)
    (Closest? const-decl "bool" float nil)
    (RestrictedRounding type-eq-decl nil float nil)
    (EvenClosest? const-decl "bool" float nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Rounding type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil) (float type-eq-decl nil float nil)
    (b formal-const-decl "Format" accum_err_div nil)
    (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (round_even_closest formula-decl nil accum_err_div nil))
   nil
   (IMP_accum_err_op2sch assuming
    "accum_err_op2sch[(float[accum_err_div.radix].Fbounded?(accum_err_div.b)), restrict[float[radix], (float[accum_err_div.radix].Fbounded?(accum_err_div.b)), real].restrict(float[accum_err_div.radix].FtoR), accum_err_div.RtoF, float[accum_err_div.radix].ulp(accum_err_div.b, accum_err_div.round, accum_err_div.RtoF), LAMBDA (f1, f2): float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0, LAMBDA (f1, (f2: (float[accum_err_div.radix].Fbounded?(accum_err_div.b)) | float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0)) -> (Fbounded?(b)): cr_div[accum_err_div.radix, accum_err_div.b, accum_err_div.round, accum_err_div.RtoF].Fdiv(accum_err_div.f1, f2), LAMBDA (r1, r2): accum_err_div.r2 /= 0, restrict[[numfield, nznum], [r1: reals.real, {r2: reals.real | r2 /= 0}], numfield].restrict(number_fields./), LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_ulp_bound].accum_err_op2sch"
    "ulp_abs: ASSUMPTION accum_err_op2sch.ulp(real_defs.abs(accum_err_op2sch.r1)) = accum_err_op2sch.ulp(accum_err_op2sch.r1)"))
  (IMP_accum_err_op2sch_TCC1-1 nil 3682158219 ("" (assuming-tcc) nil nil) nil
   nil
   (IMP_accum_err_op2sch assuming
    "accum_err_op2sch[(float[accum_err_div.radix].Fbounded?(accum_err_div.b)), restrict[float[radix], (float[accum_err_div.radix].Fbounded?(accum_err_div.b)), real].restrict(float[accum_err_div.radix].FtoR), accum_err_div.RtoF, float[accum_err_div.radix].ulp(accum_err_div.b, accum_err_div.round, accum_err_div.RtoF), LAMBDA (f1, f2): float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0, LAMBDA (f1, (f2: (float[accum_err_div.radix].Fbounded?(accum_err_div.b)) | float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0)) -> (Fbounded?(b)): cr_div[accum_err_div.radix, accum_err_div.b, accum_err_div.round, accum_err_div.RtoF].Fdiv(accum_err_div.f1, f2), LAMBDA (r1, r2): accum_err_div.r2 /= 0, restrict[[numfield, nznum], [r1: reals.real, {r2: reals.real | r2 /= 0}], numfield].restrict(number_fields./), LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_ulp_bound].accum_err_op2sch"
    "ulp_abs: ASSUMPTION accum_err_op2sch.ulp(real_defs.abs(accum_err_op2sch.r1)) = accum_err_op2sch.ulp(accum_err_op2sch.r1)")))
 (IMP_accum_err_op2sch_TCC2 0
  (IMP_accum_err_op2sch_TCC2-2 nil 3682158452
   ("" (skeep)
    (("" (use "ulp_monotone")
      (("1" (assert) nil nil) ("2" (use "round_rounded_mode") nil nil)) nil))
    nil)
   ((round_rounded_mode formula-decl nil accum_err_div nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (round formal-const-decl "ClosestRoundingPred(b)" accum_err_div nil)
    (ClosestRoundingPred type-eq-decl nil float nil)
    (Closest? const-decl "bool" float nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (b formal-const-decl "Format" accum_err_div nil)
    (rounded_mode? const-decl "bool" float nil)
    (Rounding type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float nil) (Format type-eq-decl nil float nil)
    (RNDF type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil)
    (CanonicRoundingFun type-eq-decl nil float nil)
    (RtoF formal-const-decl "CanonicRoundingFun(b, round)" accum_err_div nil)
    (radix formal-const-decl "above(1)" accum_err_div nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (ulp_monotone formula-decl nil float nil))
   nil
   (IMP_accum_err_op2sch assuming
    "accum_err_op2sch[(float[accum_err_div.radix].Fbounded?(accum_err_div.b)), restrict[float[radix], (float[accum_err_div.radix].Fbounded?(accum_err_div.b)), real].restrict(float[accum_err_div.radix].FtoR), accum_err_div.RtoF, float[accum_err_div.radix].ulp(accum_err_div.b, accum_err_div.round, accum_err_div.RtoF), LAMBDA (f1, f2): float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0, LAMBDA (f1, (f2: (float[accum_err_div.radix].Fbounded?(accum_err_div.b)) | float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0)) -> (Fbounded?(b)): cr_div[accum_err_div.radix, accum_err_div.b, accum_err_div.round, accum_err_div.RtoF].Fdiv(accum_err_div.f1, f2), LAMBDA (r1, r2): accum_err_div.r2 /= 0, restrict[[numfield, nznum], [r1: reals.real, {r2: reals.real | r2 /= 0}], numfield].restrict(number_fields./), LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_ulp_bound].accum_err_op2sch"
    "ulp_monotone: ASSUMPTION booleans.IMPLIES(booleans.AND(reals.<=(0, accum_err_op2sch.r1), reals.<=(accum_err_op2sch.r1, accum_err_op2sch.r2)), reals.<=(accum_err_op2sch.ulp(accum_err_op2sch.r1), accum_err_op2sch.ulp(accum_err_op2sch.r2)))"))
  (IMP_accum_err_op2sch_TCC2-1 nil 3682158219 ("" (assuming-tcc) nil nil) nil
   nil
   (IMP_accum_err_op2sch assuming
    "accum_err_op2sch[(float[accum_err_div.radix].Fbounded?(accum_err_div.b)), restrict[float[radix], (float[accum_err_div.radix].Fbounded?(accum_err_div.b)), real].restrict(float[accum_err_div.radix].FtoR), accum_err_div.RtoF, float[accum_err_div.radix].ulp(accum_err_div.b, accum_err_div.round, accum_err_div.RtoF), LAMBDA (f1, f2): float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0, LAMBDA (f1, (f2: (float[accum_err_div.radix].Fbounded?(accum_err_div.b)) | float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0)) -> (Fbounded?(b)): cr_div[accum_err_div.radix, accum_err_div.b, accum_err_div.round, accum_err_div.RtoF].Fdiv(accum_err_div.f1, f2), LAMBDA (r1, r2): accum_err_div.r2 /= 0, restrict[[numfield, nznum], [r1: reals.real, {r2: reals.real | r2 /= 0}], numfield].restrict(number_fields./), LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_ulp_bound].accum_err_op2sch"
    "ulp_monotone: ASSUMPTION booleans.IMPLIES(booleans.AND(reals.<=(0, accum_err_op2sch.r1), reals.<=(accum_err_op2sch.r1, accum_err_op2sch.r2)), reals.<=(accum_err_op2sch.ulp(accum_err_op2sch.r1), accum_err_op2sch.ulp(accum_err_op2sch.r2)))")))
 (IMP_accum_err_op2sch_TCC3 0
  (IMP_accum_err_op2sch_TCC3-3 "" 3790103338
   ("" (skeep) (("" (use "div_accum_err") (("" (assert) nil nil)) nil)) nil)
   ((div_accum_err formula-decl nil accum_err_div nil)
    (b formal-const-decl "Format" accum_err_div nil)
    (Fbounded? const-decl "bool" float nil)
    (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float nil)
    (radix formal-const-decl "above(1)" accum_err_div nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil))
   shostak
   (IMP_accum_err_op2sch assuming
    "accum_err_op2sch[(float[accum_err_div.radix].Fbounded?(accum_err_div.b)), restrict[float[radix], (float[accum_err_div.radix].Fbounded?(accum_err_div.b)), real].restrict(float[accum_err_div.radix].FtoR), accum_err_div.RtoF, float[accum_err_div.radix].ulp(accum_err_div.b, accum_err_div.round, accum_err_div.RtoF), LAMBDA (f1, f2): float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0, LAMBDA (f1, (f2: (float[accum_err_div.radix].Fbounded?(accum_err_div.b)) | float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0)) -> (Fbounded?(b)): cr_div[accum_err_div.radix, accum_err_div.b, accum_err_div.round, accum_err_div.RtoF].Fdiv(accum_err_div.f1, f2), LAMBDA (r1, r2): accum_err_div.r2 /= 0, restrict[[numfield, nznum], [r1: reals.real, {r2: reals.real | r2 /= 0}], numfield].restrict(number_fields./), LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_ulp_bound].accum_err_op2sch"
    "fR_err: ASSUMPTION booleans.IMPLIES(     (reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.r1)), accum_err_op2sch.e1)) AND (reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f2), accum_err_op2sch.r2)), accum_err_op2sch.e2)) AND accum_err_op2sch.fR_pre?(accum_err_op2sch.r1, accum_err_op2sch.r2) AND accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)) AND accum_err_op2sch.fun_bound_pre(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2), reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.fR(accum_err_op2sch.r1, accum_err_op2sch.r2))), accum_err_op2sch.fun_bound(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2)))"))
  (IMP_accum_err_op2sch_TCC3-2 nil 3682158510
   ("" (skeep)
    (("" (use "div_accum_err") (("" (assert) (("" (postpone) nil nil)) nil))
      nil))
    nil)
   ((Fbounded? const-decl "bool" float nil)
    (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil))
   nil
   (IMP_accum_err_op2sch assuming
    "accum_err_op2sch[(float[accum_err_div.radix].Fbounded?(accum_err_div.b)), restrict[float[radix], (float[accum_err_div.radix].Fbounded?(accum_err_div.b)), real].restrict(float[accum_err_div.radix].FtoR), accum_err_div.RtoF, float[accum_err_div.radix].ulp(accum_err_div.b, accum_err_div.round, accum_err_div.RtoF), LAMBDA (f1, f2): float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0, LAMBDA (f1, (f2: (float[accum_err_div.radix].Fbounded?(accum_err_div.b)) | float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0)) -> (Fbounded?(b)): cr_div[accum_err_div.radix, accum_err_div.b, accum_err_div.round, accum_err_div.RtoF].Fdiv(accum_err_div.f1, f2), LAMBDA (r1, r2): accum_err_div.r2 /= 0, restrict[[numfield, nznum], [r1: reals.real, {r2: reals.real | r2 /= 0}], numfield].restrict(number_fields./), LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_ulp_bound].accum_err_op2sch"
    "fR_err: ASSUMPTION booleans.IMPLIES(     (reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.r1)), accum_err_op2sch.e1)) AND (reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f2), accum_err_op2sch.r2)), accum_err_op2sch.e2)) AND accum_err_op2sch.fR_pre?(accum_err_op2sch.r1, accum_err_op2sch.r2) AND accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)) AND accum_err_op2sch.fun_bound_pre(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2), reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.fR(accum_err_op2sch.r1, accum_err_op2sch.r2))), accum_err_op2sch.fun_bound(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2)))"))
  (IMP_accum_err_op2sch_TCC3-1 nil 3682158219 ("" (assuming-tcc) nil nil) nil
   nil
   (IMP_accum_err_op2sch assuming
    "accum_err_op2sch[(float[accum_err_div.radix].Fbounded?(accum_err_div.b)), restrict[float[radix], (float[accum_err_div.radix].Fbounded?(accum_err_div.b)), real].restrict(float[accum_err_div.radix].FtoR), accum_err_div.RtoF, float[accum_err_div.radix].ulp(accum_err_div.b, accum_err_div.round, accum_err_div.RtoF), LAMBDA (f1, f2): float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0, LAMBDA (f1, (f2: (float[accum_err_div.radix].Fbounded?(accum_err_div.b)) | float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0)) -> (Fbounded?(b)): cr_div[accum_err_div.radix, accum_err_div.b, accum_err_div.round, accum_err_div.RtoF].Fdiv(accum_err_div.f1, f2), LAMBDA (r1, r2): accum_err_div.r2 /= 0, restrict[[numfield, nznum], [r1: reals.real, {r2: reals.real | r2 /= 0}], numfield].restrict(number_fields./), LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_ulp_bound].accum_err_op2sch"
    "fR_err: ASSUMPTION booleans.IMPLIES(     (reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.r1)), accum_err_op2sch.e1)) AND (reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f2), accum_err_op2sch.r2)), accum_err_op2sch.e2)) AND accum_err_op2sch.fR_pre?(accum_err_op2sch.r1, accum_err_op2sch.r2) AND accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)) AND accum_err_op2sch.fun_bound_pre(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2), reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.fR(accum_err_op2sch.r1, accum_err_op2sch.r2))), accum_err_op2sch.fun_bound(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2)))")))
 (IMP_accum_err_op2sch_TCC4 0
  (IMP_accum_err_op2sch_TCC4-3 "" 3790103339
   ("" (skeep)
    (("" (use "Fdiv_error_ulp")
      (("" (typepred "round")
        (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil))
      nil))
    nil)
   ((Fdiv_error_ulp formula-decl nil cr_div nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" accum_err_div nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float nil)
    (b formal-const-decl "Format" accum_err_div nil)
    (float type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil)
    (Rounding type-eq-decl nil float nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Closest? const-decl "bool" float nil)
    (ClosestRoundingPred type-eq-decl nil float nil)
    (round formal-const-decl "ClosestRoundingPred(b)" accum_err_div nil)
    (RNDF type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil)
    (CanonicRoundingFun type-eq-decl nil float nil)
    (RtoF formal-const-decl "CanonicRoundingFun(b, round)" accum_err_div nil)
    (/= const-decl "boolean" notequal nil) (FtoR const-decl "real" float nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak
   (IMP_accum_err_op2sch assuming
    "accum_err_op2sch[(float[accum_err_div.radix].Fbounded?(accum_err_div.b)), restrict[float[radix], (float[accum_err_div.radix].Fbounded?(accum_err_div.b)), real].restrict(float[accum_err_div.radix].FtoR), accum_err_div.RtoF, float[accum_err_div.radix].ulp(accum_err_div.b, accum_err_div.round, accum_err_div.RtoF), LAMBDA (f1, f2): float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0, LAMBDA (f1, (f2: (float[accum_err_div.radix].Fbounded?(accum_err_div.b)) | float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0)) -> (Fbounded?(b)): cr_div[accum_err_div.radix, accum_err_div.b, accum_err_div.round, accum_err_div.RtoF].Fdiv(accum_err_div.f1, f2), LAMBDA (r1, r2): accum_err_div.r2 /= 0, restrict[[numfield, nznum], [r1: reals.real, {r2: reals.real | r2 /= 0}], numfield].restrict(number_fields./), LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_ulp_bound].accum_err_op2sch"
    "fF_correctly_rounded: ASSUMPTION booleans.IMPLIES(booleans.AND(accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.fF_pre?(accum_err_op2sch.f1, accum_err_op2sch.f2)), reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.fF(accum_err_op2sch.f1, accum_err_op2sch.f2)), accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)))), number_fields./(accum_err_op2sch.ulp(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2))), 2)))"))
  (IMP_accum_err_op2sch_TCC4-2 nil 3682158887
   ("" (skeep)
    (("" (use "Fdiv_error_ulp")
      (("" (typepred "round")
        (("" (skeep)
          (("" (inst?)
            (("" (assert)
              (("" (expand "EvenClosest?") (("" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Fdiv_error_ulp formula-decl nil cr_div nil)
    (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil)
    (Rounding type-eq-decl nil float nil)
    (Closest? const-decl "bool" float nil)
    (ClosestRoundingPred type-eq-decl nil float nil)
    (RNDF type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil)
    (CanonicRoundingFun type-eq-decl nil float nil)
    (FtoR const-decl "real" float nil))
   nil
   (IMP_accum_err_op2sch assuming
    "accum_err_op2sch[(float[accum_err_div.radix].Fbounded?(accum_err_div.b)), restrict[float[radix], (float[accum_err_div.radix].Fbounded?(accum_err_div.b)), real].restrict(float[accum_err_div.radix].FtoR), accum_err_div.RtoF, float[accum_err_div.radix].ulp(accum_err_div.b, accum_err_div.round, accum_err_div.RtoF), LAMBDA (f1, f2): float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0, LAMBDA (f1, (f2: (float[accum_err_div.radix].Fbounded?(accum_err_div.b)) | float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0)) -> (Fbounded?(b)): cr_div[accum_err_div.radix, accum_err_div.b, accum_err_div.round, accum_err_div.RtoF].Fdiv(accum_err_div.f1, f2), LAMBDA (r1, r2): accum_err_div.r2 /= 0, restrict[[numfield, nznum], [r1: reals.real, {r2: reals.real | r2 /= 0}], numfield].restrict(number_fields./), LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_ulp_bound].accum_err_op2sch"
    "fF_correctly_rounded: ASSUMPTION booleans.IMPLIES(booleans.AND(accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.fF_pre?(accum_err_op2sch.f1, accum_err_op2sch.f2)), reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.fF(accum_err_op2sch.f1, accum_err_op2sch.f2)), accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)))), number_fields./(accum_err_op2sch.ulp(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2))), 2)))"))
  (IMP_accum_err_op2sch_TCC4-1 nil 3682158219 ("" (assuming-tcc) nil nil) nil
   nil
   (IMP_accum_err_op2sch assuming
    "accum_err_op2sch[(float[accum_err_div.radix].Fbounded?(accum_err_div.b)), restrict[float[radix], (float[accum_err_div.radix].Fbounded?(accum_err_div.b)), real].restrict(float[accum_err_div.radix].FtoR), accum_err_div.RtoF, float[accum_err_div.radix].ulp(accum_err_div.b, accum_err_div.round, accum_err_div.RtoF), LAMBDA (f1, f2): float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0, LAMBDA (f1, (f2: (float[accum_err_div.radix].Fbounded?(accum_err_div.b)) | float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0)) -> (Fbounded?(b)): cr_div[accum_err_div.radix, accum_err_div.b, accum_err_div.round, accum_err_div.RtoF].Fdiv(accum_err_div.f1, f2), LAMBDA (r1, r2): accum_err_div.r2 /= 0, restrict[[numfield, nznum], [r1: reals.real, {r2: reals.real | r2 /= 0}], numfield].restrict(number_fields./), LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_ulp_bound].accum_err_op2sch"
    "fF_correctly_rounded: ASSUMPTION booleans.IMPLIES(booleans.AND(accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.fF_pre?(accum_err_op2sch.f1, accum_err_op2sch.f2)), reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.fF(accum_err_op2sch.f1, accum_err_op2sch.f2)), accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)))), number_fields./(accum_err_op2sch.ulp(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2))), 2)))")))
 (IMP_accum_err_op2sch_TCC5 0
  (IMP_accum_err_op2sch_TCC5-2 nil 3682159293
   ("" (skeep) (("" (use "Fdiv_accum_err_bound") (("" (assert) nil nil)) nil))
    nil)
   ((Fdiv_accum_err_bound formula-decl nil accum_err_div nil)
    (b formal-const-decl "Format" accum_err_div nil)
    (Fbounded? const-decl "bool" float nil)
    (Format type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float nil)
    (radix formal-const-decl "above(1)" accum_err_div nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil))
   nil
   (IMP_accum_err_op2sch assuming
    "accum_err_op2sch[(float[accum_err_div.radix].Fbounded?(accum_err_div.b)), restrict[float[radix], (float[accum_err_div.radix].Fbounded?(accum_err_div.b)), real].restrict(float[accum_err_div.radix].FtoR), accum_err_div.RtoF, float[accum_err_div.radix].ulp(accum_err_div.b, accum_err_div.round, accum_err_div.RtoF), LAMBDA (f1, f2): float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0, LAMBDA (f1, (f2: (float[accum_err_div.radix].Fbounded?(accum_err_div.b)) | float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0)) -> (Fbounded?(b)): cr_div[accum_err_div.radix, accum_err_div.b, accum_err_div.round, accum_err_div.RtoF].Fdiv(accum_err_div.f1, f2), LAMBDA (r1, r2): accum_err_div.r2 /= 0, restrict[[numfield, nznum], [r1: reals.real, {r2: reals.real | r2 /= 0}], numfield].restrict(number_fields./), LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_ulp_bound].accum_err_op2sch"
    "f_ulp_bound: ASSUMPTION booleans.IMPLIES(booleans.AND(reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.r1)), accum_err_op2sch.e1), booleans.AND(reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f2), accum_err_op2sch.r2)), accum_err_op2sch.e2), booleans.AND(accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.ulp_bound_pre(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2)))), reals.<=(real_defs.abs(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2))), accum_err_op2sch.ulp_bound(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2)))"))
  (IMP_accum_err_op2sch_TCC5-1 nil 3682158219 ("" (assuming-tcc) nil nil) nil
   nil
   (IMP_accum_err_op2sch assuming
    "accum_err_op2sch[(float[accum_err_div.radix].Fbounded?(accum_err_div.b)), restrict[float[radix], (float[accum_err_div.radix].Fbounded?(accum_err_div.b)), real].restrict(float[accum_err_div.radix].FtoR), accum_err_div.RtoF, float[accum_err_div.radix].ulp(accum_err_div.b, accum_err_div.round, accum_err_div.RtoF), LAMBDA (f1, f2): float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0, LAMBDA (f1, (f2: (float[accum_err_div.radix].Fbounded?(accum_err_div.b)) | float[accum_err_div.radix].FtoR(accum_err_div.f2) /= 0)) -> (Fbounded?(b)): cr_div[accum_err_div.radix, accum_err_div.b, accum_err_div.round, accum_err_div.RtoF].Fdiv(accum_err_div.f1, f2), LAMBDA (r1, r2): accum_err_div.r2 /= 0, restrict[[numfield, nznum], [r1: reals.real, {r2: reals.real | r2 /= 0}], numfield].restrict(number_fields./), LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_aerr_bound, LAMBDA (r1, e1, r2, e2): booleans.OR(reals.<(0, (number_fields.-)(accum_err_div.r2, accum_err_div.e2)), reals.<((number_fields.+)(accum_err_div.e2, accum_err_div.r2), 0)), accum_err_div.div_ulp_bound].accum_err_op2sch"
    "f_ulp_bound: ASSUMPTION booleans.IMPLIES(booleans.AND(reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.r1)), accum_err_op2sch.e1), booleans.AND(reals.<=(real_defs.abs((number_fields.-)(accum_err_op2sch.F2R(accum_err_op2sch.f2), accum_err_op2sch.r2)), accum_err_op2sch.e2), booleans.AND(accum_err_op2sch.fR_pre?(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2)), accum_err_op2sch.ulp_bound_pre(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2)))), reals.<=(real_defs.abs(accum_err_op2sch.fR(accum_err_op2sch.F2R(accum_err_op2sch.f1), accum_err_op2sch.F2R(accum_err_op2sch.f2))), accum_err_op2sch.ulp_bound(accum_err_op2sch.r1, accum_err_op2sch.e1, accum_err_op2sch.r2, accum_err_op2sch.e2)))")))
 (accum_err_bound 0
  (accum_err_bound-1 nil 3682019118
   ("" (skeep)
    ((""
      (use " accum_err_op2sch
             [(Fbounded?(b)),
              restrict[float[radix], (Fbounded?[radix](b)), real](FtoR),
              RtoF, ulp(b, round, RtoF), LAMBDA (f1, f2): FtoR(f2) /= 0,
              LAMBDA (f1, (f2: (Fbounded?(b)) | FtoR(f2) /= 0)):
                Fdiv(f1, f2),
              LAMBDA (r1, r2): r2 /= 0,
              restrict
                  [[numfield, nznum], [r1: real, {r2: real | r2 /= 0}],
                   numfield]
                  (/),
              LAMBDA (r1, e1, r2, e2): 0 < r2 - e2 OR e2 + r2 < 0,
              div_aerr_bound,
              LAMBDA (r1, e1, r2, e2): 0 < r2 - e2 OR e2 + r2 < 0,
              div_ulp_bound].accumulated_error")
      (("" (assert)
        (("" (expand "div_ulp_bound") (("" (grind-reals) nil nil)) nil)) nil))
      nil))
    nil)
   ((accumulated_error formula-decl nil accum_err_op2sch nil)
    (int nonempty-type-eq-decl nil integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" accum_err_div nil)
    (float type-eq-decl nil float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float nil)
    (Fbounded? const-decl "bool" float nil)
    (b formal-const-decl "Format" accum_err_div nil)
    (restrict const-decl "R" restrict nil) (FtoR const-decl "real" float nil)
    (Rounding type-eq-decl nil float nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Closest? const-decl "bool" float nil)
    (ClosestRoundingPred type-eq-decl nil float nil)
    (round formal-const-decl "ClosestRoundingPred(b)" accum_err_div nil)
    (RNDF type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil)
    (CanonicRoundingFun type-eq-decl nil float nil)
    (RtoF formal-const-decl "CanonicRoundingFun(b, round)" accum_err_div nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (ulp const-decl "posreal" float nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (Fdiv const-decl
     "{f3: (Fcanonic?(b)) | Closest?(b)(FtoR(f1) / FtoR(f2), f3)}" cr_div nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (div_aerr_bound const-decl "nonneg_real" accum_err_div nil)
    (div_ulp_bound const-decl "real" accum_err_div nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil))
   shostak)))

