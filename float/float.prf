(float (vNum_TCC1 0 (vNum_TCC1-1 nil 3321636413 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (vNum subtype "Prec(float.b)" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (radix_div_vNum 0 (radix_div_vNum-1 nil 3319366647 ("" (judgement-tcc) (("" (case-replace "expt(radix, Prec(b!1)) / radix=expt(radix, Prec(b!1)-1)") (("1" (grind-reals) nil nil) ("2" (hide 2) (("2" (rewrite "expt_minus_aux") (("2" (rewrite "expt_x1_aux") nil nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (expt def-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (Format type-eq-decl nil float nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_minus_aux formula-decl nil exponentiation nil) (expt_x1_aux formula-decl nil exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (^ const-decl "real" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (vNum const-decl "posnat" float nil)) nil)) (radix_less_vNum 0 (radix_less_vNum-1 nil 3319366647 ("" (judgement-tcc) (("" (lemma "both_sides_expt_gt1_ge_aux") (("" (inst -1 "radix" "Prec(b!1)-1" "0") (("" (grind-reals) (("" (rewrite "expt_x1_aux" -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((both_sides_expt_gt1_ge_aux formula-decl nil exponentiation nil) (TRUE const-decl "bool" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (expt_x1_aux formula-decl nil exponentiation nil) (Format type-eq-decl nil float nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (^ const-decl "real" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (vNum const-decl "posnat" float nil)) nil)) (FtoR_TCC1 0 (FtoR_TCC1-1 nil 3318615387 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (FtoR subtype "(Fexp(float.f))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (ftor_zero_fnum 0 (ftor_zero_fnum-1 nil 3681143479 ("" (skeep) (("" (expand "FtoR") (("" (use "zero_times3") (("" (replace -1 :hide? t) (("" (split -1) (("1" (propax) nil nil) ("2" (use "expt_nonzero") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FtoR const-decl "real" float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (expt_nonzero formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (zero_times3 formula-decl nil real_props nil)) shostak)) (float_int_def 0 (float_int_def-1 nil 3544780855 ("" (grind) nil nil) ((float_int const-decl "float" float nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (FtoR const-decl "real" float nil)) shostak)) (Fplus_TCC1 0 (Fplus_TCC1-1 nil 3319889173 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil)) nil (Fplus subtype "((number_fields.-)(Fexp(float.f), real_defs.min(Fexp(float.f), Fexp(float.g))))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (Fplus_TCC2 0 (Fplus_TCC2-1 nil 3319889173 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil)) nil (Fplus subtype "((number_fields.-)(Fexp(float.g), real_defs.min(Fexp(float.f), Fexp(float.g))))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (Fplus_TCC3 0 (Fplus_TCC3-1 nil 3319889173 ("" (subtype-tcc) nil nil) ((^ const-decl "real" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil)) nil (Fplus subtype "(number_fields.+)(number_fields.*(Fnum(float.f), exponentiation.^(float.radix, ((number_fields.-)(Fexp(float.f), real_defs.min(Fexp(float.f), Fexp(float.g)))))), number_fields.*(Fnum(float.g), exponentiation.^(float.radix, ((number_fields.-)(Fexp(float.g), real_defs.min(Fexp(float.f), Fexp(float.g)))))))" "int"))) (Fminus_TCC1 0 (Fminus_TCC1-1 nil 3319889173 ("" (subtype-tcc) nil nil) ((^ const-decl "real" exponentiation nil) (int_times_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil)) nil (Fminus subtype "(number_fields.-)(number_fields.*(Fnum(float.f), exponentiation.^(float.radix, ((number_fields.-)(Fexp(float.f), real_defs.min(Fexp(float.f), Fexp(float.g)))))), number_fields.*(Fnum(float.g), exponentiation.^(float.radix, ((number_fields.-)(Fexp(float.g), real_defs.min(Fexp(float.f), Fexp(float.g)))))))" "int"))) (sum_float_commutes 0 (sum_float_commutes-1 nil 3545039871 ("" (grind) nil nil) ((int_times_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (expt def-decl "real" exponentiation nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "real" exponentiation nil) (Fplus const-decl "float" float nil) (+ const-decl "float" float nil)) shostak)) (mult_float_commutes 0 (mult_float_commutes-1 nil 3545039902 ("" (grind) nil nil) ((Fmult const-decl "float" float nil) (* const-decl "float" float nil)) shostak)) (FexptCorrect_TCC1 0 (FexptCorrect_TCC1-1 nil 3545396627 ("" (subtype-tcc) nil nil) ((FtoR const-decl "real" float nil) (posrat_exp application-judgement "posrat" exponentiation nil)) nil (FexptCorrect subtype "float.n" "{i: integers.int | booleans.OR(float.FtoR(float.f) /= 0, reals.>=(i, 0))}"))) (FexptCorrect 0 (FexptCorrect-1 nil 3545396632 ("" (skeep) (("" (expand "^") (("" (expand "Fexpt") (("" (expand "FtoR") (("" (lemma "mult_expt") (("" (case "n = 0") (("1" (replace -1) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil) ("2" (inst - "n" _ _) (("2" (expand "^" - 1) (("2" (rewrite -1) (("1" (lemma "expt_times") (("1" (inst - "Fexp(f)" "n" "radix") (("1" (replace -1 :dir rl) (("1" (hide -) (("1" (expand "^" + 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (^ const-decl "float" float nil) (FtoR const-decl "real" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (even_times_int_is_even application-judgement "even_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (rat_expt application-judgement "rat" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (expt def-decl "real" exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nat_expt application-judgement "nat" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (expt_times formula-decl nil exponentiation nil) (int_times_int_is_int application-judgement "int" integers nil) (nzreal nonempty-type-eq-decl nil reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (f skolem-const-decl "float" float nil) (float type-eq-decl nil float nil) (/= const-decl "boolean" notequal nil) (int_exp application-judgement "int" exponentiation nil) (mult_expt formula-decl nil exponentiation nil) (Fexpt const-decl "float" float nil)) nil)) (sigma_TCC1 0 (sigma_TCC1-1 nil 3544869888 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (sigma subtype "(number_fields.-)(float.jj, 1)" "nat"))) (sigma_TCC2 0 (sigma_TCC2-1 nil 3544869888 ("" (termination-tcc) nil nil) nil nil (sigma termination "float.sigma(float.ii, (number_fields.-)(float.jj, 1), float.FF)" "nil"))) (FDivInt_TCC1 0 (FDivInt_TCC1-2 "" 3790102628 ("" (skeep) (("" (typepred "i") (("" (case "radix = mod(radix,i) + i * floor(radix / i)") (("1" (replace -3) (("1" (assert) (("1" (replace -1) (("1" (case "FORALL (ii,jj:int): integer_pred(ii*jj)") (("1" (inst - "Fnum(f)" "floor(radix/i)") (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "floor") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mod") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ((radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nzint nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_times_int_is_int application-judgement "int" integers nil) (float type-eq-decl nil float nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (integer nonempty-type-from-decl nil integers nil) (<= const-decl "bool" reals nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)) shostak (FDivInt subtype "number_fields.*(Fnum(float.f), (number_fields./(float.radix, float.i)))" "int")) (FDivInt_TCC1-1 nil 3544783712 ("" (skeep) (("" (typepred "i") (("" (case "radix = mod(radix,i) + i * floor(radix / i)") (("1" (replace -3) (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (case "FORALL (ii,jj:int): integer_pred(ii*jj)") (("1" (inst - "Fnum(f)" "floor(radix/i)") (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (grind :exclude "floor") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mod") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) nil nil (FDivInt subtype "number_fields.*(Fnum(float.f), (number_fields./(float.radix, float.i)))" "int"))) (FDivInt_def 0 (FDivInt_def-2 "" 3790102629 ("" (skeep) (("" (expand "mod") (("" (name "k" "floor(radix/i)") (("" (case "k = radix/i") (("1" (expand "FDivInt") (("1" (replace -1 :dir rl) (("1" (expand "FtoR") (("1" (lemma "expt_plus") (("1" (inst - "Fexp(f)-1" "1" "radix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_times_int_is_int application-judgement "int" integers nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (expt_plus formula-decl nil exponentiation nil) (expt_x1 formula-decl nil exponentiation nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (float type-eq-decl nil float nil) (nzreal nonempty-type-eq-decl nil reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (FtoR const-decl "real" float nil) (FDivInt const-decl "float" float nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (nzint nonempty-type-eq-decl nil integers nil)) shostak) (FDivInt_def-1 nil 3544783715 ("" (skeep) (("" (expand "mod") (("" (name "k" "floor(radix/i)") (("" (case "k = radix/i") (("1" (expand "FDivInt") (("1" (replace -1 :dir rl) (("1" (expand "FtoR") (("1" (lemma "expt_plus") (("1" (inst - "Fexp(f)-1" "1" "radix") (("1" (assert) (("1" (replace -2 1) (("1" (assert) (("1" (case "radix ^ (Fexp(f) - 1) = (radix ^ Fexp(f))/radix") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "expt_plus") (("2" (inst -1 "Fexp(f)" "-1" "radix") (("2" (assert) (("2" (replace -1 :hide? t) (("2" (use "expt_inverse") (("2" (assert) (("2" (use "expt_x1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (minimum_positive_bounded_value_TCC1 0 (minimum_positive_bounded_value_TCC1-1 nil 3764683373 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (minimum_positive_bounded_value subtype "(number_fields.-)(dExp(float.b))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (positive_minumum_bounded_closest_to_zero 0 (positive_minumum_bounded_closest_to_zero-1 nil 3764956638 ("" (skeep :preds? t) (("" (expand "minimum_positive_bounded_value") (("" (expand "FtoR") (("" (expand "Fbounded?") (("" (flatten) (("" (lemma "both_sides_expt_gt1_ge") (("" (inst -1 "radix" "Fexp(bf)" "-dExp(b)") (("1" (expand ">=") (("1" (replace -1 :hide? t :dir rl) (("1" (expand "abs") (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (case "Fnum(bf) <= - 1") (("1" (expand "vNum") (("1" (mult-by -4 "-1" "-") (("1" (assert) (("1" (mult-by -2 "radix ^ Fexp(bf)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (case "1<=Fnum(bf)") (("1" (lemma "le_times_le_pos") (("1" (inst -1 "1" "radix ^ -dExp(b)" "radix ^ (Fexp(bf))" "Fnum(bf)") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minimum_positive_bounded_value const-decl "posreal" float nil) (Fbounded? const-decl "bool" float nil) (both_sides_expt_gt1_ge formula-decl nil exponentiation nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (<= const-decl "bool" reals nil) (both_sides_times_pos_neg_le1_imp formula-decl nil extra_real_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (vNum const-decl "posnat" float nil) (le_times_le_pos formula-decl nil real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (FtoR const-decl "real" float nil)) shostak)) (representability_limits_for_bounded_floats_TCC1 0 (representability_limits_for_bounded_floats_TCC1-1 nil 3764683373 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (<= const-decl "bool" reals nil) (vNum const-decl "posnat" float nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil (representability_limits_for_bounded_floats subtype "float.E" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (representability_limits_for_bounded_floats_TCC2 0 (representability_limits_for_bounded_floats_TCC2-1 nil 3764683373 ("" (skeep :preds? t) (("" (case "(vNum(b) - 1) * radix ^ E > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "vNum(b) - 1 > 0") (("1" (use "posreal_mult_closed") (("1" (assert) nil nil)) nil) ("2" (expand "vNum") (("2" (hide 2) (("2" (typepred "Prec(b)") (("2" (typepred "radix") (("2" (use "pos_expt_gt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (typepred "radix") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((radix formal-const-decl "above(1)" float nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vNum const-decl "posnat" float nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_mult_closed formula-decl nil real_axioms nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pos_expt_gt formula-decl nil exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_exp application-judgement "posint" exponentiation nil)) nil (representability_limits_for_bounded_floats subtype "number_fields.*(((number_fields.-)(float.vNum(float.b), 1)), exponentiation.^(float.radix, float.E))" "posreal"))) (representability_limits_for_bounded_floats 0 (representability_limits_for_bounded_floats-1 nil 3764955422 ("" (skeep :preds? t) (("" (skoletin) (("" (use "positive_minumum_bounded_closest_to_zero") (("" (flatten) (("" (split -1) (("1" (replace -2 :hide? t) (("1" (split 1) (("1" (expand "FtoR" :assert? none) (("1" (expand "Fbounded?") (("1" (flatten) (("1" (expand "abs") (("1" (lift-if -3) (("1" (split -3) (("1" (flatten) (("1" (case "radix ^ Fexp(bf) <= radix ^ E") (("1" (mult-by -1 "-(vNum(b) - 1)" "-") (("1" (assert) (("1" (case "-(vNum(b) - 1) <= Fnum(bf)") (("1" (mult-by -1 "radix ^ Fexp(bf)") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "both_sides_expt_gt1_le") nil nil)) nil)) nil) ("2" (flatten) (("2" (case "Fnum(bf) * radix ^ (Fexp(bf)) < 0") (("1" (rewrite "neg_times_lt") (("1" (split -1) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (assert) (("3" (replace -2 :hide? t) (("3" (expand "FtoR" :assert? none) (("3" (expand "Fbounded?") (("3" (flatten) (("3" (expand "abs") (("3" (lift-if -3) (("3" (split -3) (("1" (flatten) (("1" (case "0<Fnum(bf) * radix ^ (Fexp(bf))") (("1" (rewrite "pos_times_lt") (("1" (split -1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (case "Fnum(bf) <= vNum(b) - 1") (("1" (case "radix ^ Fexp(bf) <= radix ^ E") (("1" (lemma "le_times_le_pos") (("1" (inst -1 "Fnum(bf)" "radix ^ Fexp(bf)" "radix ^ E" "vNum(b) - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (rewrite "both_sides_expt_gt1_le") nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (vNum const-decl "posnat" float nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (minus_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat nonempty-type-eq-decl nil rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (float type-eq-decl nil float nil) (FtoR const-decl "real" float nil) (Fbounded? const-decl "bool" float nil) (minimum_positive_bounded_value const-decl "posreal" float nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_rat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (b skolem-const-decl "Format" float nil) (E skolem-const-decl "int" float nil) (bf skolem-const-decl "{bf: (Fbounded?(b)) | Fexp(bf) <= E}" float nil) (le_times_le_pos formula-decl nil real_props nil) (pos_times_lt formula-decl nil real_props nil) (neg_times_lt formula-decl nil real_props nil) (< const-decl "bool" reals nil) (both_sides_expt_gt1_le formula-decl nil exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (both_sides_times_pos_neg_le1_imp formula-decl nil extra_real_props nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (positive_minumum_bounded_closest_to_zero formula-decl nil float nil)) shostak)) (hathatln_TCC1 0 (hathatln_TCC1-2 "" 3790102633 ("" (grind-reals) (("" (both-sides-f -1 "exp") (("" (rewrite "exp_ln" -1) (("" (grind-reals) nil nil)) nil)) nil)) nil) ((id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (ln const-decl "real" ln_exp lnexp) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (exp_0 formula-decl nil ln_exp lnexp) (exp_ln formula-decl nil ln_exp lnexp) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (hathatln subtype "ln_exp.ln(float.radix)" "nznum")) (hathatln_TCC1-1 nil 3318954543 ("" (grind-reals) (("" (wrap-formula -1 "exp") (("1" (rewrite "exp_ln" -1) (("1" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil) ((ln const-decl "real" ln_exp lnexp) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (exp_0 formula-decl nil ln_exp lnexp) (exp_ln formula-decl nil ln_exp lnexp)) nil (hathatln subtype "ln_exp.ln(float.radix)" "nznum"))) (hathatln_TCC2 0 (hathatln_TCC2-1 nil 3318954543 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (ln const-decl "real" ln_exp lnexp) (real_div_nzreal_is_real application-judgement "real" reals nil)) nil (hathatln subtype "((number_fields.-)((number_fields./(ln_exp.ln(float.r), ln_exp.ln(float.radix)))))" "{r: reals.real | booleans.OR(float.radix /= 0, r /= 0)}"))) (hathatln 0 (hathatln-1 nil 3318954554 ("" (skeep) (("" (expand "^^") (("" (case "radix=0") (("1" (assert) nil nil) ("2" (assert) (("2" (case-replace "-(ln(r) / ln(radix)) * ln(radix) = -ln(r)") (("1" (hide -1) (("1" (rewrite "exp_neg") (("1" (rewrite "exp_ln") nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (^^ const-decl "nnreal" expt lnexp) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_times_real_is_real application-judgement "real" reals nil) (exp_ln formula-decl nil ln_exp lnexp) (exp_neg formula-decl nil ln_exp lnexp) (ln const-decl "real" ln_exp lnexp) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil)) shostak)) (hathat_int_TCC1 0 (hathat_int_TCC1-1 nil 3319195930 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil)) nil (hathat_int subtype "float.e1" "{r: reals.real | booleans.OR(float.radix /= 0, r /= 0)}"))) (hathat_int_TCC2 0 (hathat_int_TCC2-1 nil 3545651010 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil)) nil (hathat_int subtype "float.e1" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (hathat_int 0 (hathat_int-1 nil 3319197088 ("" (skeep) (("" (expand "^") (("" (case "e1 >= 0") (("1" (grind-reals) (("1" (rewrite "hathat_nat") (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind-reals) (("2" (lemma "hathat_diff") (("2" (inst -1 "radix" "-e1" "0") (("2" (case-replace "0--e1=e1") (("1" (rewrite -2) (("1" (rewrite "hathat_nat") (("1" (expand "^") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (hide -1 2 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "real" exponentiation nil) (div_cancel4 formula-decl nil real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (minus_int_is_int application-judgement "int" integers nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (hathat_to_0 formula-decl nil expt lnexp) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (div_cancel2 formula-decl nil real_props nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (int_minus_int_is_int application-judgement "int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (hathat_diff formula-decl nil expt lnexp) (TRUE const-decl "bool" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (hathat_nat formula-decl nil expt lnexp) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil)) shostak)) (Fsucc_TCC1 0 (Fsucc_TCC1-1 nil 3321636413 ("" (skeep) (("" (lemma "radix_div_vNum") (("" (inst?) nil nil)) nil)) nil) ((radix_div_vNum formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil)) nil (Fsucc subtype "number_fields./(float.vNum(float.b), float.radix)" "int"))) (Fpred_TCC1 0 (Fpred_TCC1-1 nil 3319211903 ("" (skeep) (("" (case-replace "-vNum(b) / radix = -(vNum(b)/radix)") (("1" (hide -1) (("1" (lemma "integers.closed_neg") (("1" (inst?) (("1" (hide 2) (("1" (lemma "radix_div_vNum") (("1" (inst -1 "b") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil) ((nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (radix formal-const-decl "above(1)" float nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (closed_neg formula-decl nil integers nil) (radix_div_vNum formula-decl nil float nil) (b skolem-const-decl "Format" float nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil)) nil (Fpred subtype "number_fields./((number_fields.-)(float.vNum(float.b)), float.radix)" "int"))) (Fnormalize_TCC1 0 (Fnormalize_TCC1-1 nil 3318871237 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (^ const-decl "real" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (vNum const-decl "posnat" float nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (posint_exp application-judgement "posint" exponentiation nil)) nil (Fnormalize subtype "(number_fields.-)(float.vNum(float.b), real_defs.abs(Fnum(float.f)))" "naturalnumber"))) (Fnormalize_TCC2 0 (Fnormalize_TCC2-1 nil 3318871237 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (^ const-decl "real" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (vNum const-decl "posnat" float nil) (Fbounded? const-decl "bool" float nil) (Fnormal? const-decl "bool" float nil) (Fsubnormal? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil) (FtoR const-decl "real" float nil) (posrat_exp application-judgement "posrat" exponentiation nil)) nil (Fnormalize subtype "(# Fnum := 0, Fexp := (number_fields.-)(dExp(float.b)) #)" "{x: (float.Fcanonic?(float.b)) | booleans.AND(float.FtoR(x) = float.FtoR(float.f), reals.<=(Fexp(x), Fexp(float.f)))}"))) (Fnormalize_TCC3 0 (Fnormalize_TCC3-1 nil 3318871237 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vNum const-decl "posnat" float nil) (Fnormal? const-decl "bool" float nil) (Fsubnormal? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil)) nil (Fnormalize subtype "float.f" "{x: (float.Fcanonic?(float.b)) | booleans.AND(float.FtoR(x) = float.FtoR(float.f), reals.<=(Fexp(x), Fexp(float.f)))}"))) (Fnormalize_TCC4 0 (Fnormalize_TCC4-1 nil 3318871237 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (posnat_expt application-judgement "posnat" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (^ const-decl "real" exponentiation nil) (vNum const-decl "posnat" float nil) (Fbounded? const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil)) nil (Fnormalize subtype "(# Fnum := number_fields.*(float.radix, Fnum(float.f)), Fexp := (number_fields.-)(Fexp(float.f), 1) #)" "(float.Fbounded?(float.b))"))) (Fnormalize_TCC5 0 (Fnormalize_TCC5-3 "" 3804620616 ("" (skosimp) (("" (grind-reals) (("" (expand "abs" 4 2) (("" (both-sides-f 3 "abs") (("" (expand "abs" 1 2) (("" (cancel-by 4 "abs(Fnum(f!1))") nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak (Fnormalize termination "float.Fnormalize(float.b)((# Fnum := number_fields.*(float.radix, Fnum(float.f)), Fexp := (number_fields.-)(Fexp(float.f), 1) #))" "nil")) (Fnormalize_TCC5-2 "" 3790102642 ("" (skosimp) (("" (grind-reals) (("" (expand "abs" 4 2) (("" (both-sides-f 2 "abs") (("" (expand "abs" 1 2) (("" (cancel-by 4 "abs(Fnum(f!1))") nil nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (both_sides_minus_lt2 formula-decl nil real_props nil) (abs_mult formula-decl nil real_props nil) (minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (float type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Format type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (abs_abs formula-decl nil real_props nil) (div_cancel1 formula-decl nil real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (< const-decl "bool" reals nil) (pos_div_ge formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (b!1 skolem-const-decl "Format" float nil) (f!1 skolem-const-decl "(Fbounded?(b!1))" float nil) (div_307 skolem-const-decl "{n: nonneg_real | n >= Fnum(f!1) AND n >= -Fnum(f!1)}" float nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak (Fnormalize termination "float.Fnormalize(float.b)((# Fnum := number_fields.*(float.radix, Fnum(float.f)), Fexp := (number_fields.-)(Fexp(float.f), 1) #))" "nil")) (Fnormalize_TCC5-1 nil 3318871660 ("" (skosimp) (("" (grind-reals) (("" (expand "abs" 4 2) (("" (wrap-formula 2 "abs") (("" (expand "abs" 1 2) (("" (cancel-by 4 "abs(Fnum(f!1))") (("" (hide-all-but (-1 3)) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (Fnormalize termination "float.Fnormalize(float.b)((# Fnum := number_fields.*(float.radix, Fnum(float.f)), Fexp := (number_fields.-)(Fexp(float.f), 1) #))" "nil"))) (Fnormalize_TCC6 0 (Fnormalize_TCC6-2 "" 3790102643 ("" (skosimp) (("" (split) (("1" (typepred "v!1(b!1)((# Fnum := radix * Fnum(f!1), Fexp := Fexp(f!1) - 1 #))") (("1" (replaces -2) (("1" (expand "FtoR") (("1" (rewrite "expt_div" :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "v!1(b!1)((# Fnum := radix * Fnum(f!1), Fexp := Fexp(f!1) - 1 #))") (("2" (assert) nil nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (expt_div formula-decl nil exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (expt_x1 formula-decl nil exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (= const-decl "[T, T -> boolean]" equalities nil) (FtoR const-decl "real" float nil) (<= const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (radix formal-const-decl "above(1)" float nil) (int_times_int_is_int application-judgement "int" integers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil)) shostak (Fnormalize subtype "float.Fnormalize(float.b)((# Fnum := number_fields.*(float.radix, Fnum(float.f)), Fexp := (number_fields.-)(Fexp(float.f), 1) #))" "{x: (float.Fcanonic?(float.b)) | booleans.AND(float.FtoR(x) = float.FtoR(float.f), reals.<=(Fexp(x), Fexp(float.f)))}")) (Fnormalize_TCC6-1 nil 3319287157 ("" (skosimp) (("" (split) (("1" (typepred "v!1(b!1)((# Fnum := radix * Fnum(f!1), Fexp := Fexp(f!1) - 1 #))") (("1" (replaces -2) (("1" (expand "FtoR") (("1" (rewrite "expt_div" :dir rl) (("1" (rewrite "expt_x1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "v!1(b!1)((# Fnum := radix * Fnum(f!1), Fexp := Fexp(f!1) - 1 #))") (("2" (assert) nil nil)) nil)) nil)) nil) nil nil (Fnormalize subtype "float.Fnormalize(float.b)((# Fnum := number_fields.*(float.radix, Fnum(float.f)), Fexp := (number_fields.-)(Fexp(float.f), 1) #))" "{x: (float.Fcanonic?(float.b)) | booleans.AND(float.FtoR(x) = float.FtoR(float.f), reals.<=(Fexp(x), Fexp(float.f)))}"))) (Fulp_TCC1 0 (Fulp_TCC1-1 nil 3318887371 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (vNum const-decl "posnat" float nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil (Fulp subtype "(Fexp(float.Fnormalize(float.b)(float.f)))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (Fulp_posreal_j 0 (Fulp_posreal_j-1 nil 3670176754 ("" (judgement-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (^ const-decl "real" exponentiation nil) (vNum const-decl "posnat" float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (Fulp const-decl "real" float nil)) nil (Fulp_posreal_j subtype "float.Fulp(float.b)(float.f)" "posreal"))) (exact_rep_conservation_TCC1 0 (exact_rep_conservation_TCC1-1 nil 3698090985 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (exact_rep_conservation subtype "float.n" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (FcanonicOpp 0 (FcanonicOpp-2 "" 3790102647 ("" (skeep) (("" (split) (("1" (skosimp*) (("1" (expand "Fcanonic?") (("1" (split) (("1" (case "Fnormal?(b)(Fopp(f))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fnormal?" "Fbounded?" "Fopp") (("2" (flatten) (("2" (split) (("1" (case-replace "abs(-(Fnum(f)))=abs(Fnum(f))") (("1" (hide -1 -2 -3 2) (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (case-replace "abs(radix * -(Fnum(f)))=abs(radix * Fnum(f))") (("3" (hide -1 -2 -3 2) (("3" (expand "abs") (("3" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "Fsubnormal?(b)(Fopp(f))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fopp" "Fsubnormal?" "Fbounded?") (("2" (flatten) (("2" (split) (("1" (case-replace "abs(-(Fnum(f)))=abs(Fnum(f))") (("1" (hide -1 -2 -3 -4 2) (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (case-replace "abs(radix * -(Fnum(f)))=abs(radix * Fnum(f))") (("4" (hide -1 -2 -3 -4 2) (("4" (expand "abs") (("4" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "Fcanonic?") (("2" (split) (("1" (case "Fnormal?(b)(f)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fnormal?" "Fopp" "Fbounded?") (("2" (flatten) (("2" (split) (("1" (case-replace "abs(Fnum(f))=abs(-(Fnum(f)))") (("1" (hide -1 -2 -3 2) (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (case-replace "abs(radix * (Fnum(f)))=abs(radix * -(Fnum(f)))") (("3" (hide -1 -2 -3 2) (("3" (expand "abs") (("3" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case " Fsubnormal?(b)(f)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fsubnormal?" "Fopp" "Fbounded?") (("2" (flatten) (("2" (split) (("1" (case-replace "abs(Fnum(f))=abs(-(Fnum(f)))") (("1" (hide -1 -2 -3 -4 2) (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (case-replace "abs(radix * (Fnum(f)))=abs(radix * -(Fnum(f)))") (("4" (hide -1 -2 -3 -4 2) (("4" (expand "abs") (("4" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Fcanonic? const-decl "bool" float nil) (Fsubnormal? const-decl "bool" float nil) (Fopp const-decl "float" float nil) (Fnormal? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Fbounded? const-decl "bool" float nil) (minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (real nonempty-type-from-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (neg_times_lt formula-decl nil real_props nil) (neg_lt formula-decl nil real_props nil) (radix formal-const-decl "above(1)" float nil) (> const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak) (FcanonicOpp-1 nil 3319221457 ("" (skeep) (("" (split) (("1" (skosimp*) (("1" (expand "Fcanonic?") (("1" (split) (("1" (case "Fnormal?(b)(Fopp(f))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fnormal?" "Fbounded?" "Fopp") (("2" (flatten) (("2" (split) (("1" (case-replace "abs(-(Fnum(f)))=abs(Fnum(f))") (("1" (hide -1 -2 -3 2) (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (case-replace "abs(radix * -(Fnum(f)))=abs(radix * Fnum(f))") (("3" (hide -1 -2 -3 2) (("3" (expand "abs") (("3" (grind-reals) (("1" (case "-(radix * (Fnum(f))) > 0") (("1" (grind-reals) nil nil) ("2" (hide -1) (("2" (cancel-by 1 "radix") nil nil)) nil)) nil) ("2" (flip-ineq 2) (("2" (hide 2) (("2" (cancel-by 1 "radix") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "Fsubnormal?(b)(Fopp(f))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fopp" "Fsubnormal?" "Fbounded?") (("2" (flatten) (("2" (split) (("1" (case-replace "abs(-(Fnum(f)))=abs(Fnum(f))") (("1" (hide -1 -2 -3 -4 2) (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (case-replace "abs(radix * -(Fnum(f)))=abs(radix * Fnum(f))") (("4" (hide -1 -2 -3 -4 2) (("4" (expand "abs") (("4" (grind-reals) (("1" (flip-ineq -1) (("1" (cancel-by 1 "radix") nil nil)) nil) ("2" (flip-ineq 2) (("2" (hide 2) (("2" (cancel-by 1 "radix") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "Fcanonic?") (("2" (split) (("1" (case "Fnormal?(b)(f)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fnormal?" "Fopp" "Fbounded?") (("2" (flatten) (("2" (split) (("1" (case-replace "abs(Fnum(f))=abs(-(Fnum(f)))") (("1" (hide -1 -2 -3 2) (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (case-replace "abs(radix * (Fnum(f)))=abs(radix * -(Fnum(f)))") (("3" (hide -1 -2 -3 2) (("3" (expand "abs") (("3" (grind-reals) (("1" (flip-ineq -2) (("1" (cancel-by 1 "radix") nil nil)) nil) ("2" (flip-ineq 1) (("2" (cancel-by 1 "radix") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case " Fsubnormal?(b)(f)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fsubnormal?" "Fopp" "Fbounded?") (("2" (flatten) (("2" (split) (("1" (case-replace "abs(Fnum(f))=abs(-(Fnum(f)))") (("1" (hide -1 -2 -3 -4 2) (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (case-replace "abs(radix * (Fnum(f)))=abs(radix * -(Fnum(f)))") (("4" (hide -1 -2 -3 -4 2) (("4" (expand "abs") (("4" (grind-reals) (("1" (flip-ineq -2) (("1" (cancel-by 1 "radix") nil nil)) nil) ("2" (flip-ineq 1) (("2" (cancel-by 1 "radix") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (FcanonicBounded 0 (FcanonicBounded-1 nil 3319221336 ("" (skeep) (("" (expand* "Fcanonic?" "Fnormal?" "Fsubnormal?") (("" (split) (("1" (flatten) nil nil) ("2" (flatten) nil nil)) nil)) nil)) nil) ((Fnormal? const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil) (Fsubnormal? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil)) shostak)) (canonic_bounded_j 0 (canonic_bounded_j-1 nil 3681643759 ("" (skeep) (("" (use "FcanonicBounded") (("" (assert) nil nil)) nil)) nil) ((FcanonicBounded formula-decl nil float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (canonic_bounded_j subtype "float.x" "(float.Fbounded?(float.b))"))) (FpredCanonic 0 (FpredCanonic-1 nil 3319212045 ("" (skeep) (("" (expand "Fpred") (("" (grind-reals) (("1" (expand "Fcanonic?" 1 1) (("1" (case "Fnormal?(b)((# Fnum := -(vNum(b) / radix), Fexp := 1 + Fexp(f) #))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fnormal?" "Fbounded?") (("2" (split) (("1" (expand "abs" 1 1) (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (real-props :simple? t) (("1" (cancel-by 1 "vNum(b)") nil nil)) nil)) nil) ("2" (flatten) (("2" (field 2) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -1 -2 2) (("3" (rewrite "integers.closed_neg") (("3" (rewrite "radix_div_vNum") nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 1) (("2" (case "Fnormal?(b)((# Fnum := vNum(b) - 1, Fexp := Fexp(f) - 1 #))") (("1" (expand "Fcanonic?") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (expand* "Fnormal?" "Fbounded?") (("2" (split) (("1" (expand "abs" 1 1) (("1" (grind-reals) nil nil)) nil) ("2" (case "vNum(b) * radix - radix >=0") (("1" (expand "abs" 1 1) (("1" (grind-reals) (("1" (isolate 1 r 1) (("1" (case "vNum(b) >= radix") (("1" (case "vNum(b) + radix <= vNum(b) * 2") (("1" (case "vNum(b) * 2 <= vNum(b) * radix") (("1" (grind-reals) nil nil) ("2" (hide -1 -2 -3 -4 2) (("2" (cancel-by 1 "vNum(b)") nil nil)) nil)) nil) ("2" (hide -2 -3 2) (("2" (grind-reals) nil nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (case "integer_pred(vNum(b) / radix)") (("1" (case "vNum(b)>=1") (("1" (grind-reals) (("1" (lemma "div_simple") (("1" (inst -1 "vNum(b)" "radix") (("1" (grind-reals) (("1" (cancel-by 1 "radix") (("1" (grind-reals) (("1" (hide 1 -3 -2 -1) (("1" (case "k!1 >= 1 OR k!1 <=0") (("1" (split) (("1" (propax) nil nil) ("2" (case "k!1 * radix <= 0") (("1" (grind-reals) nil nil) ("2" (grind-reals) nil nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) (("2" (rewrite "radix_div_vNum") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (cancel-by 1 "radix") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flip-ineq 2) (("3" (case "abs(radix*(Fnum(f) - 1))< vNum(b) OR abs(radix*(Fnum(f) - 1)) >= vNum(b)") (("1" (split) (("1" (case "Fsubnormal?(b)((# Fnum := Fnum(f) - 1, Fexp := Fexp(f) #))") (("1" (expand "Fcanonic?") (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand* "Fsubnormal?" "Fbounded?") (("2" (split) (("1" (mult-by 1 "radix") (("1" (case-replace "abs(Fnum(f) - 1) * radix=abs(radix * (Fnum(f) - 1))") (("1" (case " vNum(b) <=vNum(b) * radix") (("1" (grind-reals) nil nil) ("2" (hide -1 -2 -3 -4 2) (("2" (div-by 1 "vNum(b)") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (rewrite "abs_mult") (("2" (expand "abs" 1 2) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "Fbounded?(b)(f)") (("1" (expand "Fbounded?") (("1" (flatten) nil nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil) ("3" (case "Fbounded?(b)(f)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil) ("4" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (case "Fnormal?(b)((# Fnum := Fnum(f) - 1, Fexp := Fexp(f) #))") (("1" (expand "Fcanonic?") (("1" (assert) nil nil)) nil) ("2" (hide 3) (("2" (expand* "Fnormal?" "Fbounded?") (("2" (split) (("1" (case "Fbounded?(b)(f)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (hide -2 -3 -4 -5) (("1" (expand* "abs") (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil) ("2" (case "Fbounded?(b)(f)") (("1" (expand "Fbounded?") (("1" (flatten) nil nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil) ("3" (hide -2 -3 2) (("3" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2 3) (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("4" (case "Fbounded?(b)(f)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (split-ineq -2) (("1" (case "abs(radix*(Fnum(f) - 1))< vNum(b) OR abs(radix*(Fnum(f) - 1)) >= vNum(b)") (("1" (split) (("1" (case "Fsubnormal?(b)((# Fnum := Fnum(f) - 1, Fexp := Fexp(f) #))") (("1" (expand "Fcanonic?") (("1" (assert) nil nil)) nil) ("2" (hide 4) (("2" (expand* "Fsubnormal?" "Fbounded?") (("2" (split) (("1" (case " abs(Fnum(f) - 1) <= abs(radix * (Fnum(f) - 1))") (("1" (grind-reals) nil nil) ("2" (rewrite "abs_mult") (("2" (expand "abs" 1 2) (("2" (div-by 1 "abs(Fnum(f) - 1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (case "Fnormal?(b)((# Fnum := Fnum(f) - 1, Fexp := Fexp(f) #))") (("1" (expand "Fcanonic?") (("1" (assert) nil nil)) nil) ("2" (hide 4) (("2" (expand* "Fnormal?" "Fbounded?") (("2" (split) (("1" (hide -1 -2 -4 -4 3) (("1" (expand* "abs") (("1" (grind-reals) nil nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil) ("2" (case "Fnormal?(b)((# Fnum := Fnum(f) - 1, Fexp := Fexp(f) #))") (("1" (expand "Fcanonic?") (("1" (assert) nil nil)) nil) ("2" (hide 5) (("2" (case "Fnormal?(b)(f)") (("1" (expand* "Fnormal?" "Fbounded?") (("1" (split) (("1" (hide -1 -3 -4 2 4) (("1" (expand* "abs") (("1" (grind-reals) nil nil)) nil)) nil) ("2" (hide -3 -4 2) (("2" (expand* "abs") (("2" (grind-reals) (("1" (case "Fnum(f) <=0") (("1" (grind-reals) nil nil) ("2" (case "Fnum(f) < 1") (("1" (grind-reals) nil nil) ("2" (mult-by 1 "radix") (("2" (hide -2 2 3 4 5 6) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (case "vNum(b) = radix * Fnum(f) OR vNum(b) < radix * Fnum(f)") (("1" (split) (("1" (assert) nil nil) ("2" (hide -2 1 3 4 5) (("2" (div-by -1 "radix") (("2" (div-by 1 "radix") (("2" (case-replace "(Fnum(f) * radix - radix) / radix=Fnum(f)-1") (("1" (hide -1) (("1" (lemma "div_simple") (("1" (inst -1 "vNum(b)" "radix") (("1" (case "(EXISTS (k:int): vNum(b) = k * radix)") (("1" (skosimp*) (("1" (case-replace "vNum(b) / radix=k!1") (("1" (hide -1 -2 -3) (("1" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil) ("2" (grind-reals) (("2" (rewrite "radix_div_vNum") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 4 5) (("2" (expand "Fcanonic?") (("2" (split) (("1" (propax) nil nil) ("2" (expand "Fsubnormal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (Fpred const-decl "float" float nil) (div_mult_pos_le1 formula-decl nil real_props nil) (div_cancel3 formula-decl nil real_props nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (f skolem-const-decl "float" float nil) (times_div_cancel1 formula-decl nil extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_simp formula-decl nil real_props nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (abs_mult formula-decl nil real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (FcanonicBounded formula-decl nil float nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (<= const-decl "bool" reals nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (div_simple formula-decl nil integer_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (neg_times_le formula-decl nil real_props nil) (div_cancel2 formula-decl nil real_props nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (nzint nonempty-type-eq-decl nil integers nil) (int_times_even_is_even application-judgement "even_int" integers nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (div_cancel1 formula-decl nil real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (Fcanonic? const-decl "bool" float nil) (radix_div_vNum formula-decl nil float nil) (closed_neg formula-decl nil integers nil) (times_div1 formula-decl nil real_props nil) (times_div2 formula-decl nil real_props nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (div_mult_pos_ge2 formula-decl nil real_props nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (< const-decl "bool" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (neg_neg formula-decl nil extra_tegies nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (posint_exp application-judgement "posint" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (Fsubnormal? const-decl "bool" float nil) (neg_times_lt formula-decl nil real_props nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (neg_lt formula-decl nil real_props nil) (zero_times1 formula-decl nil real_props nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (minus_rat_is_rat application-judgement "rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (Fbounded? const-decl "bool" float nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fnormal? const-decl "bool" float nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (radix formal-const-decl "above(1)" float nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (minus_int_is_int application-judgement "int" integers nil) (div_cancel4 formula-decl nil real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (RND_log_compute_TCC1 0 (RND_log_compute_TCC1-1 nil 3543227658 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil) (minus_int_is_int application-judgement "int" integers nil)) nil (RND_log_compute subtype "((number_fields.-)((number_fields.-)(dExp(float.b)), 1))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (RND_log_compute_TCC2 0 (RND_log_compute_TCC2-1 nil 3543227658 ("" (skeep) (("" (assert) (("" (case "x*radix/vNum(b) > 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (cross-mult 1) (("2" (lemma "posreal_times_posreal_is_posreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (div_mult_pos_gt1 formula-decl nil extra_real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Format type-eq-decl nil float nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil)) nil (RND_log_compute subtype "number_fields./(number_fields.*(float.x, float.radix), float.vNum(float.b))" "posreal"))) (RND_log_compute_TCC3 0 (RND_log_compute_TCC3-1 nil 3543227658 ("" (skosimp*) (("" (assert) nil nil)) nil) ((minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (RND_log_compute subtype "((number_fields.-)((number_fields.+)(1, dExp(float.b)), Prec(float.b)))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (RND_log_compute_TCC4 0 (RND_log_compute_TCC4-2 "" 3790102657 ("" (skeep) (("" (expand "vNum") (("" (rewrite "expt_plus" :dir rl) (("" (mult-by -1 "radix ^ (1 + dExp(b) - Prec(b))") (("" (rewrite "expt_plus" :dir rl) nil nil)) nil)) nil)) nil)) nil) ((vNum const-decl "posnat" float nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt_x0 formula-decl nil exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (radix formal-const-decl "above(1)" float nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (expt_plus formula-decl nil exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (RND_log_compute subtype "number_fields.*(float.x, exponentiation.^(float.radix, ((number_fields.-)((number_fields.+)(1, dExp(float.b)), Prec(float.b)))))" "{x: reals.real | reals.>=(x, 1)}")) (RND_log_compute_TCC4-1 nil 3543227658 ("" (skeep) (("" (expand "vNum") (("" (rewrite "expt_plus" :dir rl) (("" (mult-by -1 "radix ^ (1 + dExp(b) - Prec(b))") (("" (rewrite "expt_plus" :dir rl) (("" (case "dExp(b) + -dExp(b) = 0") (("1" (replace -1 :hide? t) (("1" (use "expt_x0") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (RND_log_compute subtype "number_fields.*(float.x, exponentiation.^(float.radix, ((number_fields.-)((number_fields.+)(1, dExp(float.b)), Prec(float.b)))))" "{x: reals.real | reals.>=(x, 1)}"))) (RND_log_compute 0 (RND_log_compute-2 "" 3790102660 ("" (case "FORALL (b: Format, x: nnreal):
               x >= radix ^ (-dExp(b) - 1) * vNum(b) IMPLIES
                floor(ln(x * radix / vNum(b)) / ln(radix)) =
                 log_nat(x * radix ^ (1 + dExp(b) - Prec(b)), radix)`1 - dExp(b)") (("1" (skeep) (("1" (inst - "b" "x") (("1" (assert) nil nil) ("2" (expand "vNum") (("2" (typepred "radix^(Prec(b)-dExp(b)-1)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "vNum") (("2" (rewrite "expt_plus" :dir rl) (("2" (name "yy" "x*radix^(dExp(b) - Prec(b) + 1)") (("2" (case "NOT yy>=1") (("1" (hide 2) (("1" (expand "yy" +) (("1" (mult-by 1 "radix ^ (Prec(b) - 1 + -dExp(b))") (("1" (lemma "expt_plus") (("1" (inst - "1 + dExp(b) - Prec(b)" "Prec(b) - 1 + -dExp(b)" "radix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT x = yy*radix ^ (Prec(b) - 1 + -dExp(b))") (("1" (hide 2) (("1" (expand "yy" +) (("1" (rewrite "expt_plus" :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (replace -1 +) (("2" (rewrite "ln_div") (("1" (case "radix ^ (Prec(b) - 1 + -dExp(b)) * radix = radix ^ (Prec(b) + -dExp(b))") (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "ln_mult") (("1" (rewrite "expt_plus" +) (("1" (rewrite "ln_mult") (("1" (assert) (("1" (case "(ln(radix ^ -dExp(b)) + ln(yy)) / ln(radix) = (ln(yy)/ln(radix))-dExp(b)") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "floor_eq_log_nat_ge_1") (("1" (inst - "yy" "radix") (("1" (case "floor((ln(yy) / ln(radix)) - dExp(b)) = floor(ln(yy) / ln(radix)) - dExp(b)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (lemma "floor_plus_int") (("2" (inst - "-dExp(b)" "ln(yy)/ln(radix)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ln(radix^(-dExp(b)))/ln(radix) = -dExp(b)") (("1" (assert) nil nil) ("2" (hide (2 3)) (("2" (cross-mult 1) (("2" (rewrite "ln_expt") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "expt_plus") (("2" (inst - "Prec(b)-1+-dExp(b)" "1" "radix") (("2" (expand "^" - 3) (("2" (expand "expt") (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "posreal_times_posreal_is_posreal") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "vNum") (("3" (mult-by 1 "radix ^ (Prec(b) - 1 + -dExp(b))") (("3" (lemma "expt_plus") (("3" (inst - "1 + dExp(b) - Prec(b)" "Prec(b) - 1 + -dExp(b)" "radix") (("3" (assert) (("3" (replace -1 :dir rl) (("3" (lemma "expt_plus") (("3" (inst - "Prec(b)" "-dExp(b)-1" "radix") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (assert) (("5" (lemma "exp_ln") (("5" (inst?) (("5" (replace -3) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (cross-mult 1) (("6" (assert) (("6" (lemma "posreal_times_posreal_is_posreal") (("6" (inst?) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (assert) nil nil)) nil)) nil)) nil) ((div_mult_pos_gt1 formula-decl nil extra_real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (exp_0 formula-decl nil ln_exp lnexp) (exp_ln formula-decl nil ln_exp lnexp) (b skolem-const-decl "Format" float nil) (ln_div formula-decl nil ln_exp lnexp) (real_minus_real_is_real application-judgement "real" reals nil) (expt def-decl "real" exponentiation nil) (ln_mult formula-decl nil ln_exp lnexp) (real_plus_real_is_real application-judgement "real" reals nil) (floor_plus_int formula-decl nil floor_ceil nil) (floor_eq_log_nat_ge_1 formula-decl nil ln_approx lnexp) (ln_expt formula-decl nil ln_exp lnexp) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_cancel3 formula-decl nil real_props nil) (posreal_times_posreal_is_posreal judgement-tcc nil real_types nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (expt_x0 formula-decl nil exponentiation nil) (yy skolem-const-decl "nnreal" float nil) (int_plus_int_is_int application-judgement "int" integers nil) (expt_plus formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (x skolem-const-decl "real" float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (= const-decl "[T, T -> boolean]" equalities nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (ln const-decl "real" ln_exp lnexp) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals)) shostak) (RND_log_compute-1 nil 3543227662 ("" (case "FORALL (b: Format, x: nnreal):
               x >= radix ^ (-dExp(b) - 1) * vNum(b) IMPLIES
                floor(ln(x * radix / vNum(b)) / ln(radix)) =
                 log_nat(x * radix ^ (1 + dExp(b) - Prec(b)), radix)`1 - dExp(b)") (("1" (skeep) (("1" (inst - "b" "x") (("1" (assert) nil nil) ("2" (expand "vNum") (("2" (typepred "radix^(Prec(b)-dExp(b)-1)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "vNum") (("2" (rewrite "expt_plus" :dir rl) (("2" (name "yy" "x*radix^(dExp(b) - Prec(b) + 1)") (("2" (case "NOT yy>=1") (("1" (hide 2) (("1" (expand "yy" +) (("1" (mult-by 1 "radix ^ (Prec(b) - 1 + -dExp(b))") (("1" (lemma "expt_plus") (("1" (inst - "1 + dExp(b) - Prec(b)" "Prec(b) - 1 + -dExp(b)" "radix") (("1" (assert) (("1" (replace -1 :dir rl :hide? t) (("1" (case "dExp(b) + -dExp(b) = 0") (("1" (replace -1 :hide? t) (("1" (use "expt_x0") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "NOT x = yy*radix ^ (Prec(b) - 1 + -dExp(b))") (("1" (hide 2) (("1" (expand "yy" +) (("1" (rewrite "expt_plus" :dir rl) (("1" (assert) (("1" (case "dExp(b) + -dExp(b) = 0") (("1" (replace -1 :hide? t) (("1" (use "expt_x0") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 +) (("2" (rewrite "ln_div") (("1" (case "radix ^ (Prec(b) - 1 + -dExp(b)) * radix = radix ^ (Prec(b) + -dExp(b))") (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "ln_mult") (("1" (rewrite "expt_plus" +) (("1" (rewrite "ln_mult") (("1" (assert) (("1" (case "(ln(radix ^ -dExp(b)) + ln(yy)) / ln(radix) = (ln(yy)/ln(radix))-dExp(b)") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "floor_eq_log_nat_ge_1") (("1" (inst - "yy" "radix") (("1" (case "floor((ln(yy) / ln(radix)) - dExp(b)) = floor(ln(yy) / ln(radix)) - dExp(b)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (lemma "floor_plus_int") (("2" (inst - "-dExp(b)" "ln(yy)/ln(radix)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "ln(radix^(-dExp(b)))/ln(radix) = -dExp(b)") (("1" (assert) nil nil) ("2" (hide (2 3)) (("2" (cross-mult 1) (("2" (rewrite "ln_expt") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "expt_plus") (("2" (inst - "Prec(b)-1+-dExp(b)" "1" "radix") (("2" (expand "^" - 3) (("2" (expand "expt") (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "posreal_times_posreal_is_posreal") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "vNum") (("3" (mult-by 1 "radix ^ (Prec(b) - 1 + -dExp(b))") (("3" (lemma "expt_plus") (("3" (inst - "1 + dExp(b) - Prec(b)" "Prec(b) - 1 + -dExp(b)" "radix") (("3" (assert) (("3" (replace -1 :dir rl) (("3" (lemma "expt_plus") (("3" (inst - "Prec(b)" "-dExp(b)-1" "radix") (("3" (assert) (("3" (case "dExp(b) + -dExp(b) = 0") (("1" (replace -1 :hide? t) (("1" (use "expt_x0") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (assert) (("5" (lemma "exp_ln") (("5" (inst?) (("5" (replace -3) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (cross-mult 1) (("6" (assert) (("6" (lemma "posreal_times_posreal_is_posreal") (("6" (inst?) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (assert) nil nil)) nil)) nil)) nil) ((exp_0 formula-decl nil ln_exp lnexp) (exp_ln formula-decl nil ln_exp lnexp) (ln_div formula-decl nil ln_exp lnexp) (ln_mult formula-decl nil ln_exp lnexp) (floor_eq_log_nat_ge_1 formula-decl nil ln_approx lnexp) (ln_expt formula-decl nil ln_exp lnexp) (ln const-decl "real" ln_exp lnexp) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals)) nil)) (RND_aux_TCC1 0 (RND_aux_TCC1-1 nil 3318940757 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nat_exp application-judgement "nat" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (hat_02n formula-decl nil power_series series) (/= const-decl "boolean" notequal nil) (vNum const-decl "posnat" float nil) (minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil)) nil (RND_aux subtype "(dExp(float.b))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (RND_aux_TCC2 0 (RND_aux_TCC2-2 "" 3790102662 ("" (skeep) (("" (expand "Fcanonic?") (("" (case "Fsubnormal?(b)
                                       ((# Fnum := floor(x * radix ^ (dExp(b))),
                                           Fexp := -dExp(b) #))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fsubnormal?") (("2" (case "abs(radix * floor(x * radix ^ (dExp(b)))) < vNum(b)") (("1" (expand "Fbounded?") (("1" (split) (("1" (rewrite "abs_mult" -1) (("1" (expand "abs" -1 1) (("1" (mult-by 1 "radix") (("1" (swap "abs(floor(x * radix ^ (dExp(b))))" * "radix") (("1" (case "vNum(b)<=vNum(b) * radix") (("1" (grind-reals) nil nil) ("2" (hide -1 -2 2) (("2" (div-by 1 "vNum(b)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "abs_mult") (("2" (expand "abs" 1 1) (("2" (div-by 1 "radix") (("2" (case "floor(x * radix ^ (dExp(b))) >=0") (("1" (expand "abs" 1 1) (("1" (case "x * radix ^ (dExp(b)) < vNum(b) / radix") (("1" (grind-reals) nil nil) ("2" (hide -1 2) (("2" (lemma "expt_inverse") (("2" (inst -1 "dExp(b)+1" "radix") (("2" (case-replace "-(dExp(b) + 1)=-dExp(b) - 1") (("1" (rewrite -2 -3) (("1" (rewrite "expt_plus" -3) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Fcanonic? const-decl "bool" float nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (times_div_cancel1 formula-decl nil extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_simp formula-decl nil real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (abs_mult formula-decl nil real_props nil) (Fbounded? const-decl "bool" float nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nzreal nonempty-type-eq-decl nil reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (neg_times_lt formula-decl nil real_props nil) (neg_times_le formula-decl nil real_props nil) (times_div2 formula-decl nil real_props nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (expt_x1 formula-decl nil exponentiation nil) (expt_plus formula-decl nil exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt_inverse formula-decl nil exponentiation nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (minus_int_is_int application-judgement "int" integers nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Fsubnormal? const-decl "bool" float nil) (real nonempty-type-from-decl nil reals nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (- const-decl "[numfield -> numfield]" number_fields nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak (RND_aux subtype "(# Fnum := floor_ceil.floor(number_fields.*(float.x, exponentiation.^(float.radix, (dExp(float.b))))), Fexp := (number_fields.-)(dExp(float.b)) #)" "(float.Fcanonic?(float.b))")) (RND_aux_TCC2-1 nil 3318940757 ("" (skeep) (("" (expand "Fcanonic?") (("" (case "Fsubnormal?(b)
                                       ((# Fnum := floor(x * radix ^ (dExp(b))),
                                           Fexp := -dExp(b) #))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fsubnormal?") (("2" (case "abs(radix * floor(x * radix ^ (dExp(b)))) < vNum(b)") (("1" (expand "Fbounded?") (("1" (split) (("1" (rewrite "abs_mult" -1) (("1" (expand "abs" -1 1) (("1" (mult-by 1 "radix") (("1" (swap "abs(floor(x * radix ^ (dExp(b))))" * "radix") (("1" (case "vNum(b)<=vNum(b) * radix") (("1" (grind-reals) nil nil) ("2" (hide -1 -2 2) (("2" (div-by 1 "vNum(b)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "abs_mult") (("2" (expand "abs" 1 1) (("2" (div-by 1 "radix") (("2" (case "floor(x * radix ^ (dExp(b))) >=0") (("1" (expand "abs" 1 1) (("1" (case "x * radix ^ (dExp(b)) < vNum(b) / radix") (("1" (grind-reals) nil nil) ("2" (hide -1 2) (("2" (lemma "expt_inverse") (("2" (inst -1 "dExp(b)+1" "radix") (("2" (case-replace "-(dExp(b) + 1)=-dExp(b) - 1") (("1" (rewrite -2 -3) (("1" (rewrite "expt_plus" -3) (("1" (grind-reals) (("1" (use "expt_x1") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (RND_aux subtype "(# Fnum := floor_ceil.floor(number_fields.*(float.x, exponentiation.^(float.radix, (dExp(float.b))))), Fexp := (number_fields.-)(dExp(float.b)) #)" "(float.Fcanonic?(float.b))"))) (RND_aux_TCC3 0 (RND_aux_TCC3-2 "" 3318950531 ("" (skeep) (("" (assert) nil nil)) nil) ((minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (RND_aux subtype "((number_fields.-)((number_fields.+)(1, dExp(float.b)), Prec(float.b)))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}")) (RND_aux_TCC3-1 nil 3318940757 ("" (skeep) (("" (expand "Fcanonic?") (("" (case "Fsubnormal?(b)
                  ((# Fnum := floor(x * radix ^ (dExp(b))),
                      Fexp := -dExp(b) #))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fsubnormal?") (("2" (case "abs(radix * floor(x * radix ^ (dExp(b)))) < vNum(b)") (("1" (expand "Fbounded?") (("1" (split) (("1" (rewrite "abs_mult" -1) (("1" (expand "abs" -1 1) (("1" (mult-by 1 "radix") (("1" (swap "abs(floor(x * radix ^ (dExp(b))))" * "radix") (("1" (case "vNum(b)<=vNum(b) * radix") (("1" (grind-reals) nil nil) ("2" (hide -1 -2 2) (("2" (div-by 1 "vNum(b)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "abs_mult") (("2" (expand "abs" 1 1) (("2" (expand "abs" 1 1) (("2" (div-by 1 "radix") (("2" (case "x * radix ^ (dExp(b)) < vNum(b) / radix") (("1" (grind-reals) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil) ("2" (hide 2) (("2" (div-by 1 "radix ^ (dExp(b))") (("2" (case "radix ^ (-dExp(b) - 1)=1/radix ^ (dExp(b)+1)") (("1" (rewrite -1 -2) (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (RND_aux subtype "((number_fields.-)((number_fields.+)(1, dExp(float.b)), Prec(float.b)))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (RND_aux_TCC4 0 (RND_aux_TCC4-2 "" 3790102664 ("" (skeep) (("" (expand "vNum") (("" (rewrite "expt_plus" :dir rl) (("" (mult-by 2 "radix ^ (Prec(b) - 1 + -dExp(b))") (("" (assert) (("" (rewrite "expt_plus" :dir rl) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vNum const-decl "posnat" float nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt_x0 formula-decl nil exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (radix formal-const-decl "above(1)" float nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (expt_plus formula-decl nil exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (RND_aux subtype "number_fields.*(float.x, exponentiation.^(float.radix, ((number_fields.-)((number_fields.+)(1, dExp(float.b)), Prec(float.b)))))" "{x: reals.real | reals.>=(x, 1)}")) (RND_aux_TCC4-1 nil 3318940757 ("" (skeep) (("" (expand "vNum") (("" (rewrite "expt_plus" :dir rl) (("" (mult-by 2 "radix ^ (Prec(b) - 1 + -dExp(b))") (("" (assert) (("" (rewrite "expt_plus" :dir rl) (("" (assert) (("" (expand ">=") (("" (case "dExp(b) + -dExp(b) = 0") (("1" (replace -1 :hide? t) (("1" (use "expt_x0") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (RND_aux subtype "number_fields.*(float.x, exponentiation.^(float.radix, ((number_fields.-)((number_fields.+)(1, dExp(float.b)), Prec(float.b)))))" "{x: reals.real | reals.>=(x, 1)}"))) (RND_aux_TCC5 0 (RND_aux_TCC5-1 nil 3318940757 ("" (skeep) (("" (expand "vNum") (("" (rewrite "expt_plus" :dir rl) (("" (mult-by 1 "radix ^ (1 + dExp(b) - Prec(b))") (("" (rewrite "expt_plus" :dir rl) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((vNum const-decl "posnat" float nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (expt_x0 formula-decl nil exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (radix formal-const-decl "above(1)" float nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (expt_plus formula-decl nil exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil)) nil (RND_aux subtype "((number_fields.-)(float.e))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (RND_aux_TCC6 0 (owre "fix" 3399983082 ("" (skeep) (("" (lemma "RND_log_compute") (("" (inst?) (("" (assert) (("" (replace -1 :dir rl) (("" (hide -1) (("" (skosimp) (("" (expand "Fcanonic?") (("" (assert) (("" (flatten) (("" (typepred "e!1") (("" (replace -2 :hide? t) (("" (name "AA" "floor(ln(x * radix / vNum(b)) / ln(radix))") (("" (replace -1) (("" (expand "Fnormal?") (("" (expand "Fbounded?") (("" (split) (("1" (case "0<= floor(x * radix ^ (-AA))") (("1" (expand "abs" 1 1) (("1" (grind-reals) (("1" (case "x * radix ^ (-AA) < vNum(b)") (("1" (grind-reals) nil nil) ("2" (hide 2 -1) (("2" (case "x * radix ^ (-AA)=x * radix ^^ (-AA)") (("1" (replace -1) (("1" (case "x * radix ^^ (-AA) < x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix)-1))") (("1" (case "x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix) - 1)) <= vNum(b)") (("1" (hide -3 -4) (("1" (name-replace "WW" "x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix) - 1))") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2 -1 -2 -3) (("2" (case-replace "(ln(x * radix / vNum(b)) / ln(radix) - 1)=ln(x / vNum(b)) / ln(radix)") (("1" (field) (("1" (rewrite "hathatln") (("1" (field) nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "ln_div") (("2" (rewrite "ln_div") (("2" (rewrite "ln_mult") (("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (cancel-by 1 "x") (("2" (hide -1 2) (("2" (expand "^^") (("2" (lemma "exp_strict_increasing") (("2" (expand "strict_increasing?") (("2" (rewrite -1) (("2" (hide -1 2) (("2" (field) (("2" (case "(ln(x * radix / vNum(b)) / ln(radix) - 1) < AA") (("1" (rewrite "ln_div") (("1" (rewrite "ln_mult") (("1" (field) (("1" (mult-by -1 "ln(radix)") (("1" (field -1) nil nil) ("2" (hide -1 -2 2) (("2" (case "ln(radix) > 0") (("1" (split) (("1" (grind-reals) nil nil) ("2" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst -1 "1" "radix") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (case "x>0") (("1" (grind-reals) nil nil) ("2" (hide 2) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "hathat_int") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "0 <= x * radix ^ (-AA)") (("1" (hide -2 -3 2) (("1" (grind-reals) nil nil)) nil) ("2" (hide -1 -2 2 3) (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (case "-dExp(b) <= ln(x * radix / vNum(b)) / ln(radix)") (("1" (grind-reals) nil nil) ("2" (hide -2 2) (("2" (mult-by 1 "ln(radix)" +) (("1" (both-sides-f 1 "exp") (("1" (case-replace "exp(-dExp(b) * ln(radix))=radix^^(-dExp(b))") (("1" (rewrite "exp_ln") (("1" (div-by 1 "radix") (("1" (mult-by 1 "vNum(b)") (("1" (case-replace " radix ^ (-dExp(b)) / radix=radix ^ (-dExp(b) - 1)") (("1" (field) (("1" (rewrite "hathat_int") (("1" (div-by 1 "radix") (("1" (hide -1 -2 -4) (("1" (case-replace "(vNum(b) * radix ^ (-dExp(b))) / radix =radix ^ (-dExp(b) - 1) * vNum(b)") (("1" (hide -2 2) (("1" (grind-reals) nil nil)) nil) ("2" (hide 2 -1 -2) (("2" (lemma "expt_plus") (("2" (inst -1 "-dExp(b)" "-1" "radix") (("2" (grind-reals) (("2" (expand "^" 1 2) (("2" (grind-reals) (("2" (rewrite "expt_x1_aux") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 -1 -2) (("2" (cross-mult 1) (("2" (case "radix^(-dExp(b)-1)*radix = radix^(-dExp(b)-1)*radix^1") (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "expt_plus" :dir rl) nil nil)) nil)) nil) ("2" (expand "^" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "^^") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "ln_increasing") (("2" (expand "increasing?") (("2" (lemma "ln_exp") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 -1) (("2" (case "ln(radix) > 0") (("1" (split) (("1" (assert) nil nil) ("2" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst -1 "1" "radix") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "abs" 1 1) (("3" (grind-reals) (("3" (cancel-by 1 "radix") (("3" (hide -1 1) (("3" (case "vNum(b) / radix <= x * radix ^ (-AA)") (("1" (case "integer_pred(vNum(b) / radix)") (("1" (hide -3 -4) (("1" (lemma "div_simple") (("1" (inst -1 "vNum(b)" "radix") (("1" (case "(EXISTS (k:int): vNum(b) = k * radix)") (("1" (skosimp*) (("1" (case-replace " vNum(b) / radix=k!1") (("1" (grind-reals) nil nil) ("2" (hide -2 -3 -4 2) (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (hide -3 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but 1) (("2" (rewrite "radix_div_vNum") nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "vNum(b) / radix <=  x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix)))") (("1" (case "x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix))) <= x * radix ^ (-AA)") (("1" (name-replace "A1" "x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix)))") (("1" (name-replace "A2" "vNum(b) / radix") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2 -1) (("2" (cancel-by 1 "x") (("2" (hide -1 1) (("2" (case-replace "radix ^ (-AA)=radix ^^ (-AA)") (("1" (expand "^^") (("1" (lemma "exp_increasing") (("1" (expand "increasing?") (("1" (rewrite -1) (("1" (hide -1 -2 -3 2) (("1" (div-by 1 "-ln(radix)" -) (("1" (field) nil nil) ("2" (case "ln(radix)>0") (("1" (assert) nil nil) ("2" (hide -1 2 3) (("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst -1 "1" "radix") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "hathat_int") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "hathatln") (("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_log_compute formula-decl nil float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Fcanonic? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (div_mult_pos_le1 formula-decl nil real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (radix_div_vNum formula-decl nil float nil) (nzint nonempty-type-eq-decl nil integers nil) (div_simple formula-decl nil integer_props nil) (neg_ge formula-decl nil real_props nil) (pos_times_ge formula-decl nil real_props nil) (cross_mult formula-decl nil real_props nil) (negreal nonempty-type-eq-decl nil real_types nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (both_sides_div_neg_le1 formula-decl nil real_props nil) (exp_increasing formula-decl nil ln_exp lnexp) (nzreal_times_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (div_194 skolem-const-decl "nonneg_real" float nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (both_sides_times_pos_le2 formula-decl nil real_props nil) (neg_times_gt formula-decl nil real_props nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (posrat nonempty-type-eq-decl nil rationals nil) (nonzero_times3 formula-decl nil real_props nil) (div_div1 formula-decl nil real_props nil) (div_mult_pos_le2 formula-decl nil real_props nil) (neg_times_le formula-decl nil real_props nil) (neg_times_lt formula-decl nil real_props nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (div_cancel2 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (ln_increasing formula-decl nil ln_exp lnexp) (ln_exp formula-decl nil ln_exp lnexp) (increasing? const-decl "bool" real_fun_preds reals) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nzreal nonempty-type-eq-decl nil reals nil) (posnat_expt application-judgement "posnat" exponentiation nil) (expt_x1_aux formula-decl nil exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (times_div2 formula-decl nil real_props nil) (both_sides_times2 formula-decl nil real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (div_cancel3 formula-decl nil real_props nil) (expt_plus formula-decl nil exponentiation nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (expt def-decl "real" exponentiation nil) (exp_ln formula-decl nil ln_exp lnexp) (exp const-decl "{py | x = ln(py)}" ln_exp lnexp) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (- const-decl "[numfield -> numfield]" number_fields nil) (TRUE const-decl "bool" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (hathat_int formula-decl nil float nil) (exp_strict_increasing formula-decl nil ln_exp lnexp) (int_times_int_is_int application-judgement "int" integers nil) (div_cancel1 formula-decl nil real_props nil) (ln_1 formula-decl nil ln_exp lnexp) (ln_strict_increasing formula-decl nil ln_exp lnexp) (strict_increasing? const-decl "bool" real_fun_preds reals) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (ge_times_ge_pos formula-decl nil real_props nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (div_190 skolem-const-decl "nonneg_real" float nil) (pos_div_ge formula-decl nil real_props nil) (both_sides_times_pos_lt2 formula-decl nil real_props nil) (times_div1 formula-decl nil real_props nil) (pos_div_gt formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (hathatln formula-decl nil float nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (pos_times_gt formula-decl nil real_props nil) (ln_div formula-decl nil ln_exp lnexp) (ln_mult formula-decl nil ln_exp lnexp) (real_plus_real_is_real application-judgement "real" reals nil) (div_cancel4 formula-decl nil real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (minus_real_is_real application-judgement "real" reals nil) (^^ const-decl "nnreal" expt lnexp) (nnreal type-eq-decl nil real_types nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (Fnormal? const-decl "bool" float nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (ln const-decl "real" ln_exp lnexp) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (radix formal-const-decl "above(1)" float nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak (RND_aux subtype "(# Fnum := floor_ceil.floor(number_fields.*(float.x, exponentiation.^(float.radix, ((number_fields.-)(float.e))))), Fexp := float.e #)" "(float.Fcanonic?(float.b))")) (RND_aux_TCC6-2 nil 3399983047 (";;; Proof RND_aux_TCC6-2 for formula float.RND_aux_TCC6" (skeep) ((";;; Proof RND_aux_TCC6-2 for formula float.RND_aux_TCC6" (skosimp) ((";;; Proof RND_aux_TCC6-2 for formula float.RND_aux_TCC6" (expand "Fcanonic?") ((";;; Proof RND_aux_TCC6-2 for formula float.RND_aux_TCC6" (assert) ((";;; Proof RND_aux_TCC6-2 for formula float.RND_aux_TCC6" (flatten) ((";;; Proof RND_aux_TCC6-2 for formula float.RND_aux_TCC6" (typepred "e!1") ((";;; Proof RND_aux_TCC6-2 for formula float.RND_aux_TCC6" (replace -3 :hide? t) ((";;; Proof RND_aux_TCC6-2 for formula float.RND_aux_TCC6" (name "AA" "floor(ln(x * radix / vNum(b)) / ln(radix))") ((";;; Proof RND_aux_TCC6-2 for formula float.RND_aux_TCC6" (replace -1) ((";;; Proof RND_aux_TCC6-2 for formula float.RND_aux_TCC6" (expand "Fnormal?") ((";;; Proof RND_aux_TCC6-2 for formula float.RND_aux_TCC6" (expand "Fbounded?") ((";;; Proof RND_aux_TCC6-2 for formula float.RND_aux_TCC6" (split) (("1" (case "0<= floor(x * radix ^ (-AA))") (("1" (expand "abs" 1 1) (("1" (grind-reals) (("1" (case "x * radix ^ (-AA) < vNum(b)") (("1" (grind-reals) nil) ("2" (hide 2 -1) (("2" (case "x * radix ^ (-AA)=x * radix ^^ (-AA)") (("1" (replace -1) (("1" (case "x * radix ^^ (-AA) < x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix)-1))") (("1" (case "x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix) - 1)) <= vNum(b)") (("1" (hide -3 -4) (("1" (name-replace "WW" "x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix) - 1))") (("1" (assert) nil))))) ("2" (hide 2 -1 -2 -3) (("2" (case-replace "(ln(x * radix / vNum(b)) / ln(radix) - 1)=ln(x / vNum(b)) / ln(radix)") (("1" (field) (("1" (rewrite "hathatln") (("1" (field) nil))))) ("2" (hide 2) (("2" (rewrite "ln_div") (("2" (rewrite "ln_div") (("2" (rewrite "ln_mult") (("2" (field) nil))))))))))))))) ("2" (hide -1 2) (("2" (cancel-by 1 "x") (("2" (hide -1 2) (("2" (expand "^^") (("2" (lemma "exp_strict_increasing") (("2" (expand "strict_increasing?") (("2" (rewrite -1) (("2" (hide -1 2) (("2" (field) (("2" (case "(ln(x * radix / vNum(b)) / ln(radix) - 1) < AA") (("1" (rewrite "ln_div") (("1" (rewrite "ln_mult") (("1" (field) (("1" (mult-by -1 "ln(radix)") (("1" (field -1) nil) ("2" (hide -1 -2 2) (("2" (case "ln(radix) > 0") (("1" (split) (("1" (grind-reals) nil) ("2" (propax) nil))) ("2" (hide 2) (("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst -1 "1" "radix") (("2" (grind-reals) nil))))))))))))))))))) ("2" (hide -1 -2 2) (("2" (case "x>0") (("1" (grind-reals) nil) ("2" (hide 2) (("2" (grind-reals) nil))))))))) ("2" (hide 2) (("2" (grind-reals) nil))))))))))))))))))))))))))) ("2" (hide -1 -2 2) (("2" (rewrite "hathat_int") nil))))))))))))) ("2" (case "0 <= x * radix ^ (-AA)") (("1" (hide -2 -3 2) (("1" (grind-reals) nil))) ("2" (hide -1 -2 2 3) (("2" (grind-reals) nil))))))) ("2" (case "-dExp(b) <= ln(x * radix / vNum(b)) / ln(radix)") (("1" (grind-reals) nil) ("2" (hide -2 2) (("2" (mult-by 1 "ln(radix)" +) (("1" (wrap-formula 1 "exp") (("1" (case-replace "exp(-dExp(b) * ln(radix))=radix^^(-dExp(b))") (("1" (rewrite "exp_ln") (("1" (div-by 1 "radix") (("1" (mult-by 1 "vNum(b)") (("1" (case-replace " radix ^ (-dExp(b)) / radix=radix ^ (-dExp(b) - 1)") (("1" (field) (("1" (rewrite "hathat_int") (("1" (div-by 1 "radix") (("1" (hide -1 -2 -4) (("1" (case-replace "(vNum(b) * radix ^ (-dExp(b))) / radix =radix ^ (-dExp(b) - 1) * vNum(b)") (("1" (hide -2 2) (("1" (grind-reals) nil))) ("2" (hide 2 -1 -2) (("2" (lemma "expt_plus") (("2" (inst -1 "-dExp(b)" "-1" "radix") (("2" (grind-reals) (("2" (expand "^" 1 2) (("2" (grind-reals) (("2" (rewrite "expt_x1_aux") nil))))))))))))))))))))))) ("2" (hide 2 -1 -2) (("2" (lemma "expt_plus") (("2" (inst -1 "-dExp(b)" "-1" "radix") (("2" (grind-reals) (("2" (expand "^" 1 2) (("2" (grind-reals) (("2" (rewrite "expt_x1_aux") nil))))))))))))))))))))) ("2" (hide -1 2) (("2" (expand "^^") (("2" (propax) nil))))))) ("2" (lemma "ln_increasing") (("2" (expand "increasing?") (("2" (lemma "ln_exp") (("2" (grind-reals) nil))))))))) ("2" (hide 2 -1) (("2" (case "ln(radix) > 0") (("1" (split) (("1" (assert) nil) ("2" (propax) nil))) ("2" (hide 2) (("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst -1 "1" "radix") (("2" (grind-reals) nil))))))))))))))))))) ("3" (expand "abs" 1 1) (("3" (grind-reals) (("3" (cancel-by 1 "radix") (("3" (hide -1 1) (("3" (case "vNum(b) / radix <= x * radix ^ (-AA)") (("1" (case "integer_pred(vNum(b) / radix)") (("1" (hide -3 -4) (("1" (lemma "div_simple") (("1" (inst -1 "vNum(b)" "radix") (("1" (case "(EXISTS (k:int): vNum(b) = k * radix)") (("1" (skosimp*) (("1" (case-replace " vNum(b) / radix=k!1") (("1" (grind-reals) nil) ("2" (hide -2 -3 -4 2) (("2" (grind-reals) nil))))))) ("2" (hide -3 2) (("2" (assert) nil))))))))))) ("2" (assert) (("2" (hide-all-but 1) (("2" (rewrite "radix_div_vNum") nil))))))) ("2" (hide 2) (("2" (case "vNum(b) / radix <=  x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix)))") (("1" (case "x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix))) <= x * radix ^ (-AA)") (("1" (assert) nil) ("2" (hide 2 -1) (("2" (cancel-by 1 "x") (("2" (hide -1 1) (("2" (case-replace "radix ^ (-AA)=radix ^^ (-AA)") (("1" (expand "^^") (("1" (lemma "exp_increasing") (("1" (expand "increasing?") (("1" (rewrite -1) (("1" (hide -1 -2 -3 2) (("1" (div-by 1 "-ln(radix)" -) (("1" (field) nil) ("2" (case "ln(radix)>0") (("1" (assert) nil) ("2" (hide -1 2 3) (("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst -1 "1" "radix") (("2" (grind-reals) nil))))))))))))))))))))))) ("2" (hide -1 -2 2) (("2" (rewrite "hathat_int") nil))))))))))))) ("2" (hide -1 -2 2) (("2" (rewrite "hathatln") (("2" (field) nil)))))))))))))))))))))))))))))))))))))))))) ";;; developed with shostak decision procedures") ((increasing? const-decl "bool" real_fun_preds reals) (strict_increasing? const-decl "bool" real_fun_preds reals)) nil (RND_aux subtype "(# Fnum := floor_ceil.floor(number_fields.*(float.x, exponentiation.^(float.radix, ((number_fields.-)(float.e))))), Fexp := float.e #)" "(float.Fcanonic?(float.b))")) (RND_aux_TCC6-1 nil 3318940757 ("" (skeep) (("" (case "Fnormal?(b)
                                   ((# Fnum
                                         := floor(x *
                                                   radix ^
                                                    (-floor(ln(x * radix / vNum(b))
                                                            /
                                                            ln(radix)))),
                                       Fexp := floor(ln(x * radix / vNum(b)) / ln(radix)) #))") (("1" (expand "Fcanonic?") (("1" (assert) nil nil)) nil) ("2" (hide 3) (("2" (name "AA" "floor(ln(x * radix / vNum(b)) / ln(radix))") (("2" (replace -1 1) (("2" (case "radix ^ (-dExp(b) - 1) * vNum(b) <= x") (("1" (hide 2) (("1" (expand* "Fnormal?" "Fbounded?") (("1" (split) (("1" (case "0<= floor(x * radix ^ (-AA))") (("1" (expand "abs" 1 1) (("1" (grind-reals) (("1" (case "x * radix ^ (-AA) < vNum(b)") (("1" (grind-reals) nil nil) ("2" (hide 2 -1) (("2" (case "x * radix ^ (-AA)=x * radix ^^ (-AA)") (("1" (replace -1) (("1" (case "x * radix ^^ (-AA) < x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix)-1))") (("1" (case "x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix) - 1)) <= vNum(b)") (("1" (hide -3 -4) (("1" (name-replace "WW" "x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix) - 1))") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2 -1 -2 -3) (("2" (case-replace "(ln(x * radix / vNum(b)) / ln(radix) - 1)=ln(x / vNum(b)) / ln(radix)") (("1" (field) (("1" (rewrite "hathatln") (("1" (field) nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "ln_div") (("2" (rewrite "ln_div") (("2" (rewrite "ln_mult") (("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (cancel-by 1 "x") (("2" (hide -1 2) (("2" (expand "^^") (("2" (lemma "exp_strict_increasing") (("2" (expand "strict_increasing?") (("2" (rewrite -1) (("2" (hide -1 2) (("2" (field) (("2" (case "(ln(x * radix / vNum(b)) / ln(radix) - 1) < AA") (("1" (rewrite "ln_div") (("1" (rewrite "ln_mult") (("1" (field) (("1" (mult-by -1 "ln(radix)") (("1" (field -1) nil nil) ("2" (hide -1 -2 2) (("2" (case "ln(radix) > 0") (("1" (split) (("1" (grind-reals) nil nil) ("2" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst -1 "1" "radix") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (case "x>0") (("1" (grind-reals) nil nil) ("2" (hide 2) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "hathat_int") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "0 <= x * radix ^ (-AA)") (("1" (hide -2 -3 2) (("1" (grind-reals) nil nil)) nil) ("2" (hide -1 -2 2 3) (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (case "-dExp(b) <= ln(x * radix / vNum(b)) / ln(radix)") (("1" (grind-reals) nil nil) ("2" (hide -2 2) (("2" (mult-by 1 "ln(radix)" +) (("1" (wrap-formula 1 "exp") (("1" (case-replace "exp(-dExp(b) * ln(radix))=radix^^(-dExp(b))") (("1" (rewrite "exp_ln") (("1" (div-by 1 "radix") (("1" (mult-by 1 "vNum(b)") (("1" (case-replace " radix ^ (-dExp(b)) / radix=radix ^ (-dExp(b) - 1)") (("1" (field) (("1" (rewrite "hathat_int") (("1" (div-by 1 "radix") (("1" (hide -1 -2 -4) (("1" (case-replace "(vNum(b) * radix ^ (-dExp(b))) / radix =radix ^ (-dExp(b) - 1) * vNum(b)") (("1" (hide -2 2) (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 -1 -2) (("2" (lemma "expt_plus") (("2" (inst -1 "-dExp(b)" "-1" "radix") (("2" (grind-reals) (("2" (expand "^" 1 2) (("2" (grind-reals) (("2" (rewrite "expt_x1_aux") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "^^") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "ln_increasing") (("2" (expand "increasing?") (("2" (lemma "ln_exp") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 -1) (("2" (case "ln(radix) > 0") (("1" (split) (("1" (assert) nil nil) ("2" (propax) nil nil)) nil) ("2" (hide 2) (("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst -1 "1" "radix") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "abs" 1 1) (("3" (grind-reals) (("3" (cancel-by 1 "radix") (("3" (hide -1 1) (("3" (case "vNum(b) / radix <= x * radix ^ (-AA)") (("1" (case "integer_pred(vNum(b) / radix)") (("1" (hide -3 -4) (("1" (lemma "div_simple") (("1" (inst -1 "vNum(b)" "radix") (("1" (case "(EXISTS (k:int): vNum(b) = k * radix)") (("1" (skosimp*) (("1" (case-replace " vNum(b) / radix=k!1") (("1" (grind-reals) nil nil) ("2" (hide -2 -3 -4 2) (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (hide -3 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but 1) (("2" (rewrite "radix_div_vNum") nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "vNum(b) / radix <=  x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix)))") (("1" (case "x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix))) <= x * radix ^ (-AA)") (("1" (assert) nil nil) ("2" (hide 2 -1) (("2" (cancel-by 1 "x") (("2" (hide -1 1) (("2" (case-replace "radix ^ (-AA)=radix ^^ (-AA)") (("1" (expand "^^") (("1" (lemma "exp_increasing") (("1" (expand "increasing?") (("1" (rewrite -1) (("1" (hide -1 -2 -3 2) (("1" (div-by 1 "-ln(radix)" -) (("1" (field) nil nil) ("2" (case "ln(radix)>0") (("1" (assert) nil nil) ("2" (hide -1 2 3) (("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst -1 "1" "radix") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "hathat_int") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 2) (("2" (rewrite "hathatln") (("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (grind-reals) nil nil)) nil)) nil)) nil) ((increasing? const-decl "bool" real_fun_preds reals) (strict_increasing? const-decl "bool" real_fun_preds reals)) nil (RND_aux subtype "(# Fnum := floor_ceil.floor(number_fields.*(float.x, exponentiation.^(float.radix, ((number_fields.-)(float.e))))), Fexp := float.e #)" "(float.Fcanonic?(float.b))"))) (RND_aux_alt_TCC1 0 (RND_aux_alt_TCC1-1 nil 3544343150 ("" (skeep) (("" (case "x>=0") (("1" (split-ineq -1) nil nil) ("2" (assert) nil nil)) nil)) nil) ((nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil)) nil (RND_aux_alt subtype "number_fields./(number_fields.*(float.x, float.radix), float.vNum(float.b))" "posreal"))) (RND_aux_alt_TCC2 0 (RND_aux_alt_TCC2-2 "" 3790102683 ("" (skosimp*) (("" (case "radix = 1") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil)) shostak (RND_aux_alt subtype "((number_fields.-)(float.e))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}")) (RND_aux_alt_TCC2-1 nil 3544343150 ("" (skosimp*) (("" (case "radix = 1") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (lemma "ln_eq_0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil (RND_aux_alt subtype "((number_fields.-)(float.e))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (RND_aux_alt_TCC3 0 (RND_aux_alt_TCC3-1 nil 3544343150 ("" (skeep) (("" (lemma "RND_aux_TCC6") (("" (inst?) (("" (assert) (("" (skosimp*) (("" (inst - "e!1") (("" (ground) (("" (lemma "RND_log_compute") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_aux_TCC6 subtype-tcc nil float nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (ln const-decl "real" ln_exp lnexp) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (radix formal-const-decl "above(1)" float nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (RND_log_compute formula-decl nil float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posrat_exp application-judgement "posrat" exponentiation nil)) nil (RND_aux_alt subtype "(# Fnum := floor_ceil.floor(number_fields.*(float.x, exponentiation.^(float.radix, ((number_fields.-)(float.e))))), Fexp := float.e #)" "(float.Fcanonic?(float.b))"))) (RND_aux_alt_def 0 (RND_aux_alt_def-1 nil 3544343151 ("" (decompose-equality) (("" (decompose-equality) (("" (expand "RND_aux") (("" (expand "RND_aux_alt") (("" (lift-if) (("" (ground) (("" (lemma "RND_log_compute") (("" (inst - "x!1" "x!2") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (RND_log_compute formula-decl nil float nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (Format type-eq-decl nil float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Fcanonic? const-decl "bool" float nil) (RND_aux_alt const-decl "(Fcanonic?(b))" float nil) (RND_aux const-decl "(Fcanonic?(b))" float nil)) shostak)) (RND_Min_TCC1 0 (RND_Min_TCC1-1 nil 3319384410 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (RND_Min subtype "float.x" "nonneg_real"))) (RND_Min_TCC2 0 (RND_Min_TCC2-1 nil 3319384410 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (minus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (RND_Min subtype "(number_fields.-)(float.x)" "nonneg_real"))) (RND_Min_TCC3 0 (RND_Min_TCC3-1 nil 3319384410 ("" (skeep*) (("" (replace -1 :hide? t) (("" (replace -2 :hide? t) (("" (lemma "FcanonicOpp") (("" (inst -1 "b" "RND_aux(b)(-x)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (x skolem-const-decl "real" float nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (Fcanonic? const-decl "bool" float nil) (RND_aux const-decl "(Fcanonic?(b))" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FcanonicOpp formula-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RND_Min subtype "float.ofmx" "(float.Fcanonic?(float.b))"))) (RND_Min_TCC4 0 (RND_Min_TCC4-1 nil 3319384410 ("" (skeep*) (("" (replace -1 :hide? t) (("" (rewrite "FpredCanonic") (("" (lemma "FcanonicOpp") (("" (inst -1 "b" "RND_aux(b)(-x)") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((FcanonicOpp formula-decl nil float nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (RND_aux const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (FpredCanonic formula-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (RND_Min subtype "float.Fpred(float.b)(float.ofmx)" "(float.Fcanonic?(float.b))"))) (RND_Max_TCC1 0 (RND_Max_TCC1-1 nil 3319894713 ("" (skeep) (("" (lemma "FcanonicOpp") (("" (inst -1 "b" "RND_Min(b)(-x)") (("" (assert) nil nil)) nil)) nil)) nil) ((FcanonicOpp formula-decl nil float nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (RND_Min const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (minus_real_is_real application-judgement "real" reals nil)) nil (RND_Max subtype "float.Fopp(float.RND_Min(float.b)((number_fields.-)(float.x)))" "(float.Fcanonic?(float.b))"))) (Exp_incr_1_TCC1 0 (Exp_incr_1_TCC1-1 nil 3318763952 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil (Exp_incr_1 subtype "float.e2" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (Exp_incr_1 0 (Exp_incr_1-1 nil 3318763991 ("" (skeep) (("" (use "both_sides_expt_gt1_lt") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ((both_sides_expt_gt1_lt formula-decl nil exponentiation nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil)) shostak)) (Exp_incr_2 0 (Exp_incr_2-1 nil 3318865674 ("" (skeep) (("" (use " both_sides_expt_gt1_lt") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ((both_sides_expt_gt1_lt formula-decl nil exponentiation nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil)) shostak)) (Exp_increq_1_TCC1 0 (Exp_increq_1_TCC1-1 nil 3318783146 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil)) nil (Exp_increq_1 subtype "float.e2" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (Exp_increq_1 0 (Exp_increq_1-1 nil 3318865769 ("" (skeep) (("" (use "both_sides_expt_gt1_le") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ((both_sides_expt_gt1_le formula-decl nil exponentiation nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil)) shostak)) (Exp_increq_2 0 (Exp_increq_2-1 nil 3318865818 ("" (skeep) (("" (use "both_sides_expt_gt1_le") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ((both_sides_expt_gt1_le formula-decl nil exponentiation nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil)) shostak)) (Exp_1 0 (Exp_1-2 "" 3790102692 ("" (skeep) (("" (case "0 <= e1") (("1" (case "e1 <= 0") (("1" (grind) nil nil) ("2" (rewrite "Exp_increq_2") nil nil)) nil) ("2" (rewrite "Exp_increq_2") nil nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (expt_x0 formula-decl nil exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (Exp_increq_2 formula-decl nil float nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak) (Exp_1-1 nil 3318698220 ("" (skeep) (("" (case "0 <= e1") (("1" (case "e1 <= 0") (("1" (grind) nil nil) ("2" (rewrite "Exp_increq_2") (("2" (rewrite "expt_x0") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "Exp_increq_2") (("2" (rewrite "expt_x0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) nil shostak)) (EqExpEq 0 (EqExpEq-1 nil 3318696278 ("" (skeep) (("" (case "e1 <= e2") (("1" (case "e2 <= e1") (("1" (grind) nil nil) ("2" (rewrite "Exp_increq_2") nil nil)) nil) ("2" (rewrite "Exp_increq_2") nil nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Exp_increq_2 formula-decl nil float nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (expt_odd_TCC1 0 (expt_odd_TCC1-1 nil 3319544683 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (expt_odd subtype "((number_fields.+)(float.n, 1))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (expt_odd 0 (expt_odd-2 "" 3790102694 ("" (induct "n") (("1" (grind-reals) nil nil) ("2" (rewrite "expt_x1") (("2" (grind-reals) nil nil)) nil) ("3" (skeep) (("3" (split 1) (("1" (skosimp*) (("1" (rewrite "expt_plus") (("1" (grind-reals) (("1" (rewrite "odd_times_odd_is_odd") nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (rewrite "expt_plus") (("2" (lemma "even_or_odd") (("2" (inst -1 "radix") (("2" (flatten) (("2" (case "even?(radix)") (("1" (hide -2 -3 1) (("1" (lemma "even_iff_not_odd") (("1" (inst -1 "(radix ^ (1 + j)) * radix") (("1" (flatten) (("1" (case "even?((radix ^ (1 + j)) * radix)") (("1" (assert) nil nil) ("2" (rewrite "int_times_even_is_even") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((even_or_odd formula-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_times_even_is_even judgement-tcc nil integers nil) (even_int nonempty-type-eq-decl nil integers nil) (even_iff_not_odd formula-decl nil naturalnumbers nil) (even? const-decl "bool" integers nil) (TRUE const-decl "bool" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_times_odd_is_odd judgement-tcc nil integers nil) (odd_int nonempty-type-eq-decl nil integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (expt_plus formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_x1 formula-decl nil exponentiation nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (odd? const-decl "bool" integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak) (expt_odd-1 nil 3319544683 ("" (induct "n") (("1" (grind-reals) (("1" (rewrite "expt_x1") nil nil)) nil) ("2" (rewrite "expt_x1") (("2" (grind-reals) nil nil)) nil) ("3" (skeep) (("3" (split 1) (("1" (skosimp*) (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (grind-reals) (("1" (rewrite "odd_times_odd_is_odd") nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (rewrite "expt_plus") (("2" (rewrite "expt_x1") (("2" (lemma "even_or_odd") (("2" (inst -1 "radix") (("2" (flatten) (("2" (case "even?(radix)") (("1" (hide -2 -3 1) (("1" (lemma "even_iff_not_odd") (("1" (inst -1 "(radix ^ (1 + j)) * radix") (("1" (flatten) (("1" (case "even?((radix ^ (1 + j)) * radix)") (("1" (assert) nil nil) ("2" (rewrite "int_times_even_is_even") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (expt_even 0 (expt_even-2 "" 3790102696 ("" (induct "n") (("1" (grind-reals) nil nil) ("2" (grind-reals) nil nil) ("3" (skeep) (("3" (rewrite 1 "expt_plus") (("1" (rewrite "expt_plus" :subst ("n0x" "radix" "i" "j+1" "j" "1")) (("1" (split 1) (("1" (skosimp*) (("1" (split -2) (("1" (rewrite "even_times_int_is_even") nil nil) ("2" (propax) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (case-replace "1+j=j+1") (("1" (hide -1) (("1" (case-replace "even?((radix ^ (j + 1)) * radix)=NOT odd?((radix ^ (1 + j)) * radix)") (("1" (case-replace "even?(radix)=NOT odd?(radix)") (("1" (rewrite "odd_times_odd_is_odd") (("1" (lemma "odd_or_even_int" :subst ("x" "radix ^ (1 + j)")) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "even_iff_not_odd" :subst ("x" "radix")) (("2" (grind-reals) nil nil)) nil)) nil) ("2" (case-replace "1+j=j+1") (("1" (lemma "even_iff_not_odd" :subst ("x" "((radix ^ (j + 1)) * radix)")) (("1" (grind-reals) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (hide 2) (("2" (case-replace "even?(radix)=NOT odd?(radix)") (("1" (case-replace "even?(radix^(1+j))=NOT odd?(radix^(1+j))") (("1" (case "odd?(radix ^ (1 + j))") (("1" (case-replace "even?(radix^(2+j))=NOT odd?(radix^(2+j))") (("1" (case-replace "2+j=1+(1+j)") (("1" (rewrite "expt_plus") (("1" (rewrite "odd_times_odd_is_odd") nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "even_iff_not_odd" :subst ("x" "radix ^ (2 + j)")) (("2" (grind-reals) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "even_iff_not_odd" :subst ("x" "radix ^ (1 + j)")) (("2" (grind-reals) nil nil)) nil)) nil) ("2" (lemma "even_iff_not_odd" :subst ("x" "radix")) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nzreal nonempty-type-eq-decl nil reals nil) (expt_plus formula-decl nil exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (odd_or_even_int formula-decl nil naturalnumbers nil) (odd_times_odd_is_odd judgement-tcc nil integers nil) (odd_int nonempty-type-eq-decl nil integers nil) (even_iff_not_odd formula-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (odd? const-decl "bool" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (even_int nonempty-type-eq-decl nil integers nil) (even_times_int_is_even judgement-tcc nil integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (expt_x1 formula-decl nil exponentiation nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (even? const-decl "bool" integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak) (expt_even-1 nil 3319562624 ("" (induct "n") (("1" (grind-reals) (("1" (rewrite "expt_x1") nil nil)) nil) ("2" (grind-reals) (("2" (rewrite "expt_x1") nil nil)) nil) ("3" (skeep) (("3" (rewrite 1 "expt_plus") (("1" (rewrite "expt_plus" :subst ("n0x" "radix" "i" "j+1" "j" "1")) (("1" (rewrite "expt_x1") (("1" (split 1) (("1" (skosimp*) (("1" (split -2) (("1" (rewrite "even_times_int_is_even") nil nil) ("2" (propax) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (case-replace "1+j=j+1") (("1" (hide -1) (("1" (case-replace "even?((radix ^ (j + 1)) * radix)=NOT odd?((radix ^ (1 + j)) * radix)") (("1" (case-replace "even?(radix)=NOT odd?(radix)") (("1" (rewrite "odd_times_odd_is_odd") (("1" (lemma "odd_or_even_int" :subst ("x" "radix ^ (1 + j)")) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "even_iff_not_odd" :subst ("x" "radix")) (("2" (grind-reals) nil nil)) nil)) nil) ("2" (case-replace "1+j=j+1") (("1" (lemma "even_iff_not_odd" :subst ("x" "((radix ^ (j + 1)) * radix)")) (("1" (grind-reals) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (hide 2) (("2" (case-replace "even?(radix)=NOT odd?(radix)") (("1" (case-replace "even?(radix^(1+j))=NOT odd?(radix^(1+j))") (("1" (case "odd?(radix ^ (1 + j))") (("1" (case-replace "even?(radix^(2+j))=NOT odd?(radix^(2+j))") (("1" (case-replace "2+j=1+(1+j)") (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (rewrite "odd_times_odd_is_odd") nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "even_iff_not_odd" :subst ("x" "radix ^ (2 + j)")) (("2" (grind-reals) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "even_iff_not_odd" :subst ("x" "radix ^ (1 + j)")) (("2" (grind-reals) nil nil)) nil)) nil) ("2" (lemma "even_iff_not_odd" :subst ("x" "radix")) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (FoppCorrect 0 (FoppCorrect-1 nil 3319368570 ("" (skeep) (("" (expand* "FtoR" "Fopp") (("" (grind-reals) nil nil)) nil)) nil) ((Fopp const-decl "float" float nil) (FtoR const-decl "real" float nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (minus_rat_is_rat application-judgement "rat" rationals nil)) shostak)) (FoppFopp 0 (FoppFopp-1 nil 3545043329 ("" (grind) (("" (decompose-equality) nil nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (float type-eq-decl nil float nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (minus_int_is_int application-judgement "int" integers nil) (Fopp const-decl "float" float nil)) shostak)) (Fopp_mult_left 0 (Fopp_mult_left-1 nil 3545043536 ("" (skeep) (("" (grind) nil nil)) nil) ((minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (* const-decl "float" float nil) (Fmult const-decl "float" float nil) (- const-decl "float" float nil) (Fopp const-decl "float" float nil)) shostak)) (Fopp_mult_right 0 (Fopp_mult_right-1 nil 3545043574 ("" (grind) nil nil) ((Fopp const-decl "float" float nil) (- const-decl "float" float nil) (Fmult const-decl "float" float nil) (* const-decl "float" float nil) (int_times_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil)) shostak)) (FabsCorrect 0 (FabsCorrect-1 nil 3319889181 ("" (skeep) (("" (expand* "Fabs" "FtoR") (("" (rewrite "abs_mult") (("" (expand "abs" 1 3) (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((FtoR const-decl "real" float nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (Fabs const-decl "float" float nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (abs_mult formula-decl nil real_props nil)) shostak)) (FplusCorrect 0 (FplusCorrect-1 nil 3319889234 ("" (skeep) (("" (expand* "Fplus" "FtoR") (("" (rewrite "expt_div" :dir rl) (("" (rewrite "expt_div" :dir rl) (("" (field) nil nil)) nil)) nil)) nil)) nil) ((FtoR const-decl "real" float nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (posrat_exp application-judgement "posrat" exponentiation nil) (Fplus const-decl "float" float nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (expt_div formula-decl nil exponentiation nil)) shostak)) (FplusAssociative 0 (FplusAssociative-2 "" 3790102702 ("" (expand "associative?") (("" (skeep) (("" (expand "Fplus" + 2) (("" (assert) (("" (expand "min") (("" (assert) (("" (lift-if) (("" (ground) (("1" (expand "Fplus" + 3) (("1" (expand "min") (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (expand "Fplus" + 1) (("1" (expand "min") (("1" (assert) (("1" (expand "Fplus" + 1) (("1" (expand "min") (("1" (assert) (("1" (lemma "expt_plus") (("1" (inst - "Fexp(x)-Fexp(y)" "Fexp(y)-Fexp(z)" "radix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "Fplus" 2 1) (("2" (expand "min") (("2" (assert) (("2" (expand "Fplus" 2 1) (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Fplus" 2 3) (("2" (expand "min") (("2" (lift-if) (("2" (ground) (("1" (expand "Fplus" 1 1) (("1" (expand "min") (("1" (lift-if) (("1" (ground) (("1" (expand "Fplus") (("1" (assert) (("1" (expand "min") (("1" (assert) (("1" (lemma "expt_plus") (("1" (inst - "Fexp(x)-Fexp(z)" "Fexp(y)-Fexp(x)" "radix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "Fplus") (("2" (expand "min") (("2" (assert) (("2" (lemma "expt_plus") (("2" (inst - "Fexp(y)-Fexp(z)" "Fexp(z)-Fexp(x)" "radix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Fplus" 2 1) (("2" (expand "min") (("2" (assert) (("2" (expand "Fplus" 2 1) (("2" (expand "min") (("2" (assert) (("2" (lemma "expt_plus") (("2" (inst - "Fexp(y)-Fexp(x)" "Fexp(z)-Fexp(y)" "radix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (expt_x0 formula-decl nil exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (float type-eq-decl nil float nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (int_plus_int_is_int application-judgement "int" integers nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (expt_plus formula-decl nil exponentiation nil) (int_times_int_is_int application-judgement "int" integers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (Fplus const-decl "float" float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (associative? const-decl "bool" operator_defs nil)) shostak) (FplusAssociative-1 nil 3545564973 ("" (expand "associative?") (("" (skeep) (("" (expand "Fplus" + 2) (("" (assert) (("" (expand "min") (("" (assert) (("" (lift-if) (("" (ground) (("1" (expand "Fplus" + 3) (("1" (expand "min") (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (assert) (("1" (expand "Fplus" + 1) (("1" (expand "min") (("1" (assert) (("1" (expand "Fplus" + 1) (("1" (expand "min") (("1" (assert) (("1" (lemma "expt_plus") (("1" (inst - "Fexp(x)-Fexp(y)" "Fexp(y)-Fexp(z)" "radix") (("1" (assert) (("1" (use "expt_x0") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (expand "Fplus" 2 1) (("2" (expand "min") (("2" (assert) (("2" (expand "Fplus" 2 1) (("2" (expand "min") (("2" (assert) (("2" (use "expt_x0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Fplus" 2 3) (("2" (expand "min") (("2" (lift-if) (("2" (ground) (("1" (expand "Fplus" 1 1) (("1" (expand "min") (("1" (lift-if) (("1" (ground) (("1" (expand "Fplus") (("1" (assert) (("1" (expand "min") (("1" (assert) (("1" (lemma "expt_plus") (("1" (inst - "Fexp(x)-Fexp(z)" "Fexp(y)-Fexp(x)" "radix") (("1" (assert) (("1" (use "expt_x0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "Fplus") (("2" (expand "min") (("2" (assert) (("2" (lemma "expt_plus") (("2" (inst - "Fexp(y)-Fexp(z)" "Fexp(z)-Fexp(x)" "radix") (("2" (assert) (("2" (use "expt_x0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Fplus" 2 1) (("2" (expand "min") (("2" (assert) (("2" (expand "Fplus" 2 1) (("2" (expand "min") (("2" (assert) (("2" (lemma "expt_plus") (("2" (inst - "Fexp(y)-Fexp(x)" "Fexp(z)-Fexp(y)" "radix") (("2" (assert) (("2" (use "expt_x0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (FmultAssociative 0 (FmultAssociative-1 nil 3545572260 ("" (grind) nil nil) ((Fmult const-decl "float" float nil) (associative? const-decl "bool" operator_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak)) (FminusCorrect 0 (FminusCorrect-1 nil 3319889348 ("" (skeep) (("" (expand* "Fminus" "FtoR") (("" (rewrite "expt_div" :dir rl) (("" (rewrite "expt_div" :dir rl) (("" (field) nil nil)) nil)) nil)) nil)) nil) ((FtoR const-decl "real" float nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (Fminus const-decl "float" float nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (expt_div formula-decl nil exponentiation nil)) shostak)) (FmultCorrect 0 (FmultCorrect-1 nil 3319889392 ("" (skeep) (("" (expand* "Fmult" "FtoR") (("" (rewrite "expt_plus") (("" (field) nil nil)) nil)) nil)) nil) ((FtoR const-decl "real" float nil) (Fmult const-decl "float" float nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (>= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (int_times_int_is_int application-judgement "int" integers nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (expt_plus formula-decl nil exponentiation nil)) shostak)) (Fmult_1_r 0 (Fmult_1_r-2 "" 3790102704 ("" (grind) (("" (decompose-equality) nil nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (float type-eq-decl nil float nil) (* const-decl "float" float nil) (Fmult const-decl "float" float nil) (float_int const-decl "float" float nil)) shostak) (Fmult_1_r-1 nil 3545401225 ("" (grind) (("" (decompose-equality) (("" (expand "divides") (("" (expand "divides") (("" (inst + "1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (Fmult_1_l 0 (Fmult_1_l-1 nil 3545401264 ("" (grind) (("" (decompose-equality) nil nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (float type-eq-decl nil float nil) (int_times_int_is_int application-judgement "int" integers nil) (* const-decl "float" float nil) (Fmult const-decl "float" float nil) (float_int const-decl "float" float nil)) nil)) (Fmult_2_r 0 (Fmult_2_r-1 nil 3545401333 ("" (grind) nil nil) ((float_int const-decl "float" float nil) (Fmult const-decl "float" float nil) (* const-decl "float" float nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (Fplus const-decl "float" float nil) (+ const-decl "float" float nil)) shostak)) (Fmult_2_l 0 (Fmult_2_l-1 nil 3545401340 ("" (grind) nil nil) ((float_int const-decl "float" float nil) (Fmult const-decl "float" float nil) (* const-decl "float" float nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (Fplus const-decl "float" float nil) (+ const-decl "float" float nil)) shostak)) (FDivKexpt_TCC1 0 (FDivKexpt_TCC1-1 nil 3545654182 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (FDivKexpt subtype "float.i" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (FDivKexpt_TCC2 0 (FDivKexpt_TCC2-1 nil 3545654182 ("" (subtype-tcc) nil nil) nil nil (FDivKexpt subtype "float.i" "{i: integers.int | booleans.OR(float.k /= 0, reals.>=(i, 0))}"))) (FDivKexpt_TCC3 0 (FDivKexpt_TCC3-2 nil 3697725215 ("" (skeep) (("" (case "FORALL (ik,jk:int): integer_pred(ik*jk)") (("1" (inst?) (("1" (hide 2) (("1" (case "FORALL (rp:nat): integer_pred((radix^rp)/(k^rp))") (("1" (inst?) nil nil) ("2" (hide 2) (("2" (induct "rp") (("1" (grind) nil nil) ("2" (skeep) (("2" (case "FORALL (ik,jk:int): integer_pred(ik*jk)") (("1" (case "(radix^(j+1))/(k^(j+1)) = (radix/k)*((radix^j/k^j))") (("1" (replaces -1) (("1" (inst?) (("1" (hide 2) (("1" (typepred "k") (("1" (expand "mod") (("1" (case "floor(radix/k) = radix/k") (("1" (replace -1 :dir rl) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^" +) (("2" (expand "expt" + 1) (("2" (expand "expt" + 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ((* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_times_int_is_int application-judgement "int" integers nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (j skolem-const-decl "nat" float nil) (NOT const-decl "[bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (<= const-decl "bool" reals nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (TRUE const-decl "bool" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (expt def-decl "real" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (i skolem-const-decl "nat" float nil) (k skolem-const-decl "{k: nzint | mod(radix, k) = 0}" float nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nzint nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (float type-eq-decl nil float nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil)) nil (FDivKexpt subtype "number_fields.*(Fnum(float.f), (number_fields./((exponentiation.^(float.radix, float.i)), (exponentiation.^(float.k, float.i)))))" "int")) (FDivKexpt_TCC3-1 nil 3697724945 ("" (subtype-tcc) nil nil) nil nil (FDivKexpt subtype "number_fields.*(Fnum(float.f), (number_fields./((exponentiation.^(float.radix, float.i)), (exponentiation.^(float.k, float.i)))))" "int"))) (FDivKexpt_def 0 (FDivKexpt_def-1 nil 3545651846 ("" (induct "i") (("1" (assert) (("1" (skeep) (("1" (expand "FDivKexpt") (("1" (assert) (("1" (expand "FtoR") (("1" (use "expt_x0") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (case "NOT FORALL (zd:nat): integer_pred((radix ^ (zd)) / (k ^ (zd)))") (("1" (hide (-1 2)) (("1" (induct "zd") (("1" (grind) nil nil) ("2" (skolem 1 "rk") (("2" (flatten) (("2" (case "FORALL (ik,jk:int): integer_pred(ik*jk)") (("1" (inst - "(radix ^ rk) / (k ^ rk)" "radix/k") (("1" (expand "^") (("1" (expand "expt" +) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "k") (("2" (expand "mod") (("2" (case "floor(radix/k) = radix/k") (("1" (assert) (("1" (replace -1 :dir rl) (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (label "hyp1" -1) (("2" (hide "hyp1") (("2" (inst - "f" "k") (("2" (expand "FDivKexpt") (("2" (mult-by 1 "k") (("1" (case "FtoR(f) / k ^ (1 + j) * k = FtoR(f)/k^j") (("1" (replace -1) (("1" (hide -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (lemma "float_int_def") (("1" (inst - "k") (("1" (case "FORALL (aa:real): aa*k = aa*FtoR(float_int(k))") (("1" (rewrite -1) (("1" (hide -1) (("1" (lemma "FmultCorrect") (("1" (rewrite -1 :dir rl) (("1" (hide -1) (("1" (assert) (("1" (expand "FtoR") (("1" (expand "Fmult") (("1" (real-props) (("1" (assert) (("1" (expand "float_int") (("1" (case "k^(1+j) = k*(k^j)") (("1" (replace -1) (("1" (hide -1) (("1" (lemma "expt_plus") (("1" (inst-cp - "1+j" "Fexp(f)-1-j" "radix") (("1" (assert) (("1" (mult-by -2 "Fnum(f) * (k ^ j)") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (assert) (("1" (inst - "Fexp(f)-j" "j" "radix") (("1" (mult-by -1 "Fnum(f) * (k ^ j)") (("1" (replace -1 :dir rl) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "^") (("2" (expand "expt" + 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "hyp1") (("2" (inst?) (("2" (assert) (("2" (case "FORALL (ik,jk:int): integer_pred(ik*jk)") (("1" (inst?) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal "hyp1") (("2" (inst?) (("2" (assert) (("2" (case "FORALL (ik,jk:int): integer_pred(ik*jk)") (("1" (inst?) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "float_int_def") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^") (("2" (expand "expt" + 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal "hyp1") (("2" (inst?) (("2" (assert) (("2" (case "FORALL (ik,jk:int): integer_pred(ik*jk)") (("1" (inst?) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (expt def-decl "real" exponentiation nil) (rk skolem-const-decl "nat" float nil) (k skolem-const-decl "{k: nzint | mod(radix, k) = 0}" float nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (integer nonempty-type-from-decl nil integers nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (FmultCorrect formula-decl nil float nil) (cross_mult formula-decl nil real_props nil) (times_div1 formula-decl nil real_props nil) (TRUE const-decl "bool" booleans nil) (expt_plus formula-decl nil exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (nzreal nonempty-type-eq-decl nil reals nil) (Fmult const-decl "float" float nil) (int_plus_int_is_int application-judgement "int" integers nil) (float_int const-decl "float" float nil) (float_int_def formula-decl nil float nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (f skolem-const-decl "float" float nil) (j skolem-const-decl "nat" float nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (both_sides_times1 formula-decl nil real_props nil) (expt_x0 formula-decl nil exponentiation nil) (rat_exp application-judgement "rat" exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nat_induction formula-decl nil naturalnumbers nil) (^ const-decl "real" exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (FDivKexpt const-decl "float" float nil) (FtoR const-decl "real" float nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (mod const-decl "{k | abs(k) < abs(j)}" mod nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (< const-decl "bool" reals nil) (nonzero_integer nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (nzint nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (float type-eq-decl nil float nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil)) nil)) (FoppBounded 0 (FoppBounded-1 nil 3319899604 ("" (skeep) (("" (expand* "Fbounded?" "Fopp") (("" (flatten) (("" (split) (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ((Fopp const-decl "float" float nil) (minus_int_is_int application-judgement "int" integers nil) (Fbounded? const-decl "bool" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)) shostak)) (FabsBounded 0 (FabsBounded-1 nil 3320082424 ("" (skeep) (("" (expand* "Fbounded?" "Fabs") (("" (flatten) (("" (split) (("1" (grind-reals) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ((Fabs const-decl "float" float nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (Fbounded? const-decl "bool" float nil) (abs_abs formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (FabsCanonic 0 (FabsCanonic-1 nil 3320082549 ("" (skeep) (("" (expand "Fcanonic?") (("" (split) (("1" (case "Fnormal?(b)(Fabs(f))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "Fnormal?") (("2" (flatten) (("2" (split) (("1" (rewrite "FabsBounded") nil nil) ("2" (expand "Fabs") (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "Fsubnormal?(b)(Fabs(f))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "Fsubnormal?") (("2" (flatten) (("2" (split) (("1" (rewrite "FabsBounded") nil nil) ("2" (expand "Fabs") (("2" (propax) nil nil)) nil) ("3" (expand "Fabs") (("3" (expand "abs") (("3" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Fcanonic? const-decl "bool" float nil) (Fsubnormal? const-decl "bool" float nil) (Fabs const-decl "float" float nil) (Fnormal? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_times_int_is_int application-judgement "int" integers nil) (FabsBounded formula-decl nil float nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (neg_times_lt formula-decl nil real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil)) shostak)) (LeR0Fnum 0 (LeR0Fnum-1 nil 3318679671 ("" (skeep) (("" (expand "FtoR") (("" (grind-reals) nil nil)) nil)) nil) ((FtoR const-decl "real" float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (pos_times_le formula-decl nil real_props nil)) shostak)) (LeFnumZERO 0 (LeFnumZERO-1 nil 3318680805 ("" (skosimp*) (("" (expand "FtoR") (("" (grind-reals) nil nil)) nil)) nil) ((FtoR const-decl "real" float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (pos_times_le formula-decl nil real_props nil)) shostak)) (FleCorrect 0 (FleCorrect-1 nil 3319904574 ("" (skeep) (("" (split) (("1" (skosimp*) (("1" (expand "Fle?") (("1" (case "FtoR(p) - FtoR(q) <= 0") (("1" (assert) nil nil) ("2" (rewrite "FminusCorrect" :dir rl) (("2" (expand "FtoR") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "Fle?") (("2" (case "FtoR(Fminus(p, q)) <= 0") (("1" (expand "FtoR") (("1" (grind-reals) nil nil)) nil) ("2" (rewrite "FminusCorrect") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Fle? const-decl "bool" float nil) (FminusCorrect formula-decl nil float nil) (neg_times_le formula-decl nil real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (FtoR const-decl "real" float nil) (Fminus const-decl "float" float nil)) shostak)) (rndf_monotone 0 (rndf_monotone-1 nil 3681058028 ("" (skeep) (("" (case "x=y") (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (typepred "round::(monotone?(b))") (("2" (expand "<=") (("2" (assert) (("2" (expand "monotone?") (("2" (inst?) (("2" (inst -1 "RtoF(x)" "RtoF(y)") (("2" (split -1) (("1" (use "FleCorrect") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil) ("3" (typepred "RtoF") (("3" (inst?) nil nil)) nil) ("4" (typepred "RtoF") (("4" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (Fminus const-decl "float" float nil) (Fle? const-decl "bool" float nil) (<= const-decl "bool" float nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (RNDF type-eq-decl nil float nil) (FleCorrect formula-decl nil float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Fbounded? const-decl "bool" float nil) (Rounding type-eq-decl nil float nil) (monotone? const-decl "bool" float nil)) shostak)) (FltCorrect 0 (FltCorrect-1 nil 3319904922 ("" (skeep) (("" (split) (("1" (skosimp*) (("1" (expand "Flt?") (("1" (case "FtoR(Fminus(p, q)) < 0") (("1" (rewrite "FminusCorrect") (("1" (assert) nil nil)) nil) ("2" (expand "FtoR") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (case "FtoR(Fminus(p, q)) < 0") (("1" (expand "FtoR") (("1" (expand "Flt?") (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FminusCorrect") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Flt? const-decl "bool" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (neg_times_lt formula-decl nil real_props nil) (FminusCorrect formula-decl nil float nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (FtoR const-decl "real" float nil) (Fminus const-decl "float" float nil)) shostak)) (Fle_transitive 0 (Fle_transitive-1 nil 3747655310 ("" (expand "transitive?") (("" (skeep) (("" (expand "<=") (("" (rewrite "FleCorrect") (("" (rewrite "FleCorrect") (("" (rewrite "FleCorrect") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FleCorrect formula-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (<= const-decl "bool" float nil) (transitive? const-decl "bool" relations nil)) shostak)) (Flt_transitive 0 (Flt_transitive-1 nil 3747666724 ("" (expand "transitive?") (("" (skeep) (("" (expand "<") (("" (rewrite "FltCorrect") (("" (rewrite "FltCorrect") (("" (rewrite "FltCorrect") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FltCorrect formula-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" float nil) (transitive? const-decl "bool" relations nil)) shostak)) (Fle_neg_Flt 0 (Fle_neg_Flt-1 nil 3747667012 ("" (skeep) (("" (expand "<") (("" (expand "<=") (("" (rewrite "FleCorrect") (("" (rewrite "FltCorrect") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((< const-decl "bool" float nil) (FleCorrect formula-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (FltCorrect formula-decl nil float nil) (<= const-decl "bool" float nil)) shostak)) (Flt_Fle_Flt 0 (Flt_Fle_Flt-1 nil 3747667064 ("" (skeep) (("" (expand "<") (("" (expand "<=") (("" (rewrite* "FleCorrect") (("" (rewrite* "FltCorrect") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((< const-decl "bool" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (FleCorrect formula-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (FltCorrect formula-decl nil float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (<= const-decl "bool" float nil)) nil)) (FminCorrect 0 (FminCorrect-1 nil 3320169103 ("" (skeep) (("" (expand "Fmin") (("" (lemma "FleCorrect") (("" (inst -1 "p" "q") (("" (rewrite -1) (("" (expand "min") (("" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Fmin const-decl "float" float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FleCorrect formula-decl nil float nil)) shostak)) (FmaxCorrect 0 (FmaxCorrect-1 nil 3320169183 ("" (skeep) (("" (expand "Fmax") (("" (lemma "FleCorrect" :subst ("p" "p" "q" "q")) (("" (rewrite -1) (("" (expand "max") (("" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ((Fmax const-decl "float" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (FleCorrect formula-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil)) shostak)) (FsubnormalUnique 0 (FsubnormalUnique-1 nil 3318681540 ("" (skosimp*) (("" (expand "FtoR") (("" (expand "Fsubnormal?") (("" (flatten) (("" (decompose-equality) (("" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ((FtoR const-decl "real" float nil) (both_sides_times1 formula-decl nil real_props nil) (abs_mult formula-decl nil real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (Fsubnormal? const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak)) (FnormalUnique 0 (FnormalUnique-1 nil 3318683813 ("" (skeep) (("" (expand* "Fnormal?" "Fbounded?" "FtoR") (("" (flatten) (("" (case-replace "Fexp(p)=Fexp(q)") (("1" (decompose-equality) (("1" (grind-reals) nil nil)) nil) ("2" (hide 2) (("2" (case "Fexp(p)<Fexp(q)+1") (("1" (case "Fexp(q)<Fexp(p)+1") (("1" (hide -3 -4 -5 -6 -7 -8 -9) (("1" (grind) nil nil)) nil) ("2" (hide -1 2) (("2" (rewrite "Exp_incr_2") (("2" (hide 2) (("2" (mult-by 1 "abs(Fnum(q))") (("2" (case-replace "abs(Fnum(q)) * radix ^ Fexp(q)=abs(Fnum(p)) * radix ^ Fexp(p)") (("1" (rewrite "expt_plus") (("1" (cancel-by 1 "radix ^ Fexp(p)") (("1" (rewrite "abs_mult" -8) (("1" (expand "abs" -8 1) (("1" (use "expt_x1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 -1 -2 -3 -4 -5 -6) (("2" (both-sides-f -1 "abs") (("2" (rewrite* ("abs_mult")) (("2" (expand "abs" -1 (2 4)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "Exp_incr_2") (("2" (hide 2) (("2" (mult-by 1 "abs(Fnum(p))") (("2" (case-replace "abs(Fnum(p)) * radix ^ Fexp(p)=abs(Fnum(q)) * radix ^ Fexp(q)") (("1" (rewrite "expt_plus") (("1" (cancel-by 1 "radix ^ Fexp(q)") (("1" (rewrite "abs_mult" -5) (("1" (expand "abs" -5 1) (("1" (use "expt_x1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-7 1)) (("2" (both-sides-f -1 "abs") (("2" (rewrite* ("abs_mult")) (("2" (expand "abs" -1 (2 4)) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Fbounded? const-decl "bool" float nil) (FtoR const-decl "real" float nil) (int_times_int_is_int application-judgement "int" integers nil) (Fnormal? const-decl "bool" float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (abs_mult formula-decl nil real_props nil) (both_sides_times1 formula-decl nil real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (posrat nonempty-type-eq-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (nat_exp application-judgement "nat" exponentiation nil) (expt_x1 formula-decl nil exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (expt_plus formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (rat_abs_is_nonneg application-judgement "{r: nonneg_rat | r >= q}" real_defs nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (Exp_incr_2 formula-decl nil float nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil)) shostak)) (NormalAndSubNormalNotEq 0 (NormalAndSubNormalNotEq-1 nil 3318856796 ("" (skeep) (("" (case "abs(FtoR(q)) < abs (FtoR(p))") (("1" (assert) nil nil) ("2" (expand* "FtoR" "Fnormal?" "Fsubnormal?") (("2" (flatten) (("2" (hide -6) (("2" (rewrite "abs_mult") (("2" (expand "abs" 1 2) (("2" (rewrite "abs_mult") (("2" (expand "abs" 1 3) (("2" (mult-by 1 "radix") (("2" (swap-group "abs(Fnum(q))" * "radix ^ (Fexp(q))" "radix" r) (("2" (swap-group "abs(Fnum(p))" * "radix ^ (Fexp(p))" "radix" r) (("2" (case "abs(Fnum(q)) * radix < abs(Fnum(p)) * radix" "radix ^ Fexp(q) <= radix ^ Fexp(p)") (("1" (grind-reals) nil nil) ("2" (hide -1 2) (("2" (expand "Fbounded?") (("2" (flatten) (("2" (rewrite -6) (("2" (rewrite "Exp_increq_1") nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (rewrite "abs_mult" -2) (("3" (rewrite "abs_mult" -5) (("3" (expand "abs" -2 1) (("3" (expand "abs" -5 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FtoR const-decl "real" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (abs_mult formula-decl nil real_props nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Exp_increq_1 formula-decl nil float nil) (minus_int_is_int application-judgement "int" integers nil) (Fbounded? const-decl "bool" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_times_lt_pos2 formula-decl nil real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (<= const-decl "bool" reals nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (Fsubnormal? const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil) (Fnormal? const-decl "bool" float nil)) shostak)) (FcanonicUnique 0 (FcanonicUnique-1 nil 3318616280 ("" (skeep) (("" (expand "Fcanonic?") (("" (split) (("1" (split) (("1" (use "FnormalUnique") (("1" (assert) nil nil)) nil) ("2" (use "NormalAndSubNormalNotEq") (("2" (assert) nil nil)) nil)) nil) ("2" (split) (("1" (lemma "NormalAndSubNormalNotEq") (("1" (inst -1 "b" "q" "p") (("1" (assert) nil nil)) nil)) nil) ("2" (use "FsubnormalUnique") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Fcanonic? const-decl "bool" float nil) (FsubnormalUnique formula-decl nil float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (FnormalUnique formula-decl nil float nil) (NormalAndSubNormalNotEq formula-decl nil float nil)) shostak)) (Fle_definition 0 (Fle_definition-1 nil 3747667139 ("" (skeep) (("" (expand "<") (("" (expand "<=") (("" (rewrite* "FleCorrect") (("" (rewrite* "FltCorrect") (("" (iff) (("" (split 1) (("1" (flatten) (("1" (expand "<=") (("1" (assert) (("1" (use "FcanonicUnique") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((< const-decl "bool" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (FleCorrect formula-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (FcanonicUnique formula-decl nil float nil) (<= const-decl "bool" reals nil) (FltCorrect formula-decl nil float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (<= const-decl "bool" float nil)) nil)) (FnormalizeCorrect 0 (FnormalizeCorrect-1 nil 3319283991 ("" (skeep) (("" (assert) nil nil)) nil) nil shostak)) (FnormalizeCanonicFnum_TCC1 0 (FnormalizeCanonicFnum_TCC1-1 nil 3698095010 ("" (skeep) (("" (expand "Fcanonic?") (("" (expand "Fnormal?") (("" (expand "Fsubnormal?") (("" (ground) nil nil)) nil)) nil)) nil)) nil) ((Fcanonic? const-decl "bool" float nil) (Fsubnormal? const-decl "bool" float nil) (Fnormal? const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil)) nil (FnormalizeCanonicFnum subtype "float.p" "(float.Fbounded?(float.b))"))) (FnormalizeCanonicFnum 0 (FnormalizeCanonicFnum-1 nil 3675512267 ("" (skeep) (("" (expand "Fcanonic?") (("" (split -1) (("1" (expand "Fnormal?") (("1" (flatten) (("1" (expand "Fnormalize") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Fsubnormal?") (("2" (flatten) (("2" (expand "Fnormalize") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Fcanonic? const-decl "bool" float nil) (Fsubnormal? const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil) (Fnormal? const-decl "bool" float nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (vNum const-decl "posnat" float nil) (Fbounded? const-decl "bool" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil)) shostak)) (FulpCanonic 0 (FulpCanonic-1 nil 3319375218 ("" (skeep) (("" (expand "Fulp") (("" (case-replace "Fnormalize(b)(p)=p") (("" (hide 2) (("" (lemma "FcanonicUnique") (("" (inst -1 "b" "Fnormalize(b)(p)" "p") (("" (rewrite -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Fulp const-decl "real" float nil) (FcanonicUnique formula-decl nil float nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (<= const-decl "bool" reals nil) (FtoR const-decl "real" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Fcanonic? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Format type-eq-decl nil float nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil)) shostak)) (Fulp_min 0 (Fulp_min-1 nil 3683129470 ("" (skeep) (("" (expand "Fulp") (("" (typepred "Fnormalize(b)(f)") (("" (name-replace "f_norm" "Fnormalize(b)(f)") (("" (use "FcanonicBounded") (("" (assert) (("" (expand "Fbounded?") (("" (expand "min_Fulp") (("" (flatten) (("" (use "both_sides_expt_gt1_le") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Fulp const-decl "real" float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (min_Fulp const-decl "nonneg_real" float nil) (both_sides_expt_gt1_le formula-decl nil exponentiation nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (radix formal-const-decl "above(1)" float nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (FcanonicBounded formula-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (FtoR const-decl "real" float nil) (<= const-decl "bool" reals nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil)) shostak)) (Lexico 0 (Lexico-2 "" 3790102742 ("" (skeep) (("" (case "0<= Fnum(p)") (("1" (case "0<= Fnum(q)") (("1" (expand "Fcanonic?") (("1" (split) (("1" (split) (("1" (case "Fexp(p) < Fexp(q)+1") (("1" (grind-reals) nil nil) ("2" (hide 2) (("2" (expand* "Fnormal?" "Fbounded?") (("2" (flatten) (("2" (hide -2 -3 -4 -5) (("2" (rewrite "abs_mult" -2) (("2" (expand* "abs") (("2" (grind-reals) (("2" (rewrite "Exp_incr_2") (("2" (hide 2) (("2" (mult-by 1 "Fnum(p)") (("2" (case-replace "radix ^ Fexp(p) * Fnum(p)= FtoR(p)") (("1" (case "FtoR(q)<radix ^ (1 + Fexp(q)) * Fnum(p)") (("1" (grind-reals) nil nil) ("2" (hide 2) (("2" (expand "FtoR") (("2" (rewrite "expt_plus") (("2" (div-by 1 "radix ^ (Fexp(q))") (("2" (case-replace "radix * radix ^ Fexp(q) * Fnum(p) / radix ^ (Fexp(q))=radix * Fnum(p)") (("1" (grind-reals) nil nil) ("2" (hide 2) (("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "FtoR") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "Fnormal?" "Fsubnormal?" "Fbounded?") (("2" (flatten) (("2" (rewrite "abs_mult") (("2" (rewrite "abs_mult") (("2" (expand* "abs") (("2" (grind-reals) (("2" (flip-ineq -11) (("2" (hide 2) (("2" (case "FtoR(q) < FtoR(p)") (("1" (grind-reals) nil nil) ("2" (hide 2 -10) (("2" (expand "FtoR") (("2" (case "Fnum(q) * radix ^ (Fexp(q)) <= Fnum(q) * radix ^ (Fexp(p))") (("1" (case "Fnum(q) * radix ^ (Fexp(p)) < Fnum(p) * radix ^ (Fexp(p))") (("1" (hide-all-but (-1 -2 1)) (("1" (name-replace "AA" "Fnum(q) * radix ^ (Fexp(q))") (("1" (name-replace "BB" "Fnum(q) * radix ^ (Fexp(p))") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (cancel-by 1 "radix ^ (Fexp(p))") (("2" (mult-by 1 "radix") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (cancel-by 1 "Fnum(q)") (("2" (rewrite "Exp_increq_1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "Fsubnormal?" "Fnormal?" "Fbounded?") (("2" (flatten) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (mult-by 1 "radix^Fexp(q)") (("1" (expand "FtoR") (("1" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (hide -1 -2 -4 2) (("2" (expand "FtoR") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ((float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (q skolem-const-decl "float" float nil) (Fcanonic? const-decl "bool" float nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (abs_mult formula-decl nil real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (TRUE const-decl "bool" booleans nil) (minus_int_is_int application-judgement "int" integers nil) (FtoR const-decl "real" float nil) (= const-decl "[T, T -> boolean]" equalities nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_plus formula-decl nil exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (expt_x1 formula-decl nil exponentiation nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (div_cancel3 formula-decl nil real_props nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (Exp_incr_2 formula-decl nil float nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (Fnormal? const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil) (Fbounded? const-decl "bool" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (lt_times_lt_pos2 formula-decl nil real_props nil) (both_sides_times_pos_ge1 formula-decl nil real_props nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (both_sides_div_pos_ge1 formula-decl nil real_props nil) (div_mult_pos_le1 formula-decl nil real_props nil) (zero_times1 formula-decl nil real_props nil) (ge_div_ge_pos formula-decl nil real_props nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (times_div1 formula-decl nil real_props nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (posrat nonempty-type-eq-decl nil rationals nil) (rat nonempty-type-eq-decl nil rationals nil) (Exp_increq_1 formula-decl nil float nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (div_198 skolem-const-decl "int" float nil) (even_times_int_is_even application-judgement "even_int" integers nil) (pos_div_gt formula-decl nil real_props nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (both_sides_times_pos_le2 formula-decl nil real_props nil) (Fsubnormal? const-decl "bool" float nil) (pos_times_le formula-decl nil real_props nil)) shostak) (Lexico-1 nil 3319234645 ("" (skeep) (("" (case "0<= Fnum(p)") (("1" (case "0<= Fnum(q)") (("1" (expand "Fcanonic?") (("1" (split) (("1" (split) (("1" (case "Fexp(p) < Fexp(q)+1") (("1" (grind-reals) nil nil) ("2" (hide 2) (("2" (expand* "Fnormal?" "Fbounded?") (("2" (flatten) (("2" (hide -2 -3 -4 -5) (("2" (rewrite "abs_mult" -2) (("2" (expand* "abs") (("2" (grind-reals) (("2" (rewrite "Exp_incr_2") (("2" (hide 2) (("2" (mult-by 1 "Fnum(p)") (("2" (case-replace "radix ^ Fexp(p) * Fnum(p)= FtoR(p)") (("1" (case "FtoR(q)<radix ^ (1 + Fexp(q)) * Fnum(p)") (("1" (grind-reals) nil nil) ("2" (hide 2) (("2" (expand "FtoR") (("2" (rewrite "expt_plus") (("2" (rewrite "expt_x1") (("2" (div-by 1 "radix ^ (Fexp(q))") (("2" (case-replace "radix * radix ^ Fexp(q) * Fnum(p) / radix ^ (Fexp(q))=radix * Fnum(p)") (("1" (grind-reals) nil nil) ("2" (hide 2) (("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "FtoR") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "Fnormal?" "Fsubnormal?" "Fbounded?") (("2" (flatten) (("2" (rewrite "abs_mult") (("2" (rewrite "abs_mult") (("2" (expand* "abs") (("2" (grind-reals) (("2" (flip-ineq -11) (("2" (hide 2) (("2" (case "FtoR(q) < FtoR(p)") (("1" (grind-reals) nil nil) ("2" (hide 2 -10) (("2" (expand "FtoR") (("2" (case "Fnum(q) * radix ^ (Fexp(q)) <= Fnum(q) * radix ^ (Fexp(p))") (("1" (case "Fnum(q) * radix ^ (Fexp(p)) < Fnum(p) * radix ^ (Fexp(p))") (("1" (hide-all-but (-1 -2 1)) (("1" (name-replace "AA" "Fnum(q) * radix ^ (Fexp(q))") (("1" (name-replace "BB" "Fnum(q) * radix ^ (Fexp(p))") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (cancel-by 1 "radix ^ (Fexp(p))") (("2" (mult-by 1 "radix") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (cancel-by 1 "Fnum(q)") (("2" (rewrite "Exp_increq_1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "Fsubnormal?" "Fnormal?" "Fbounded?") (("2" (flatten) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (mult-by 1 "radix^Fexp(q)") (("1" (expand "FtoR") (("1" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (hide -1 -2 -4 2) (("2" (expand "FtoR") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) nil shostak)) (CanonicLeastExp 0 (CanonicLeastExp-1 nil 3319282878 ("" (skeep) (("" (case-replace "p=Fnormalize(b)(q)") (("1" (hide -1 -2 -4) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (lemma "FcanonicUnique") (("2" (inst -1 "b" "p" "Fnormalize(b)(q)") (("2" (rewrite -1) nil nil)) nil)) nil)) nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (FtoR const-decl "real" float nil) (<= const-decl "bool" reals nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FcanonicUnique formula-decl nil float nil)) shostak)) (Fast_canonic 0 (Fast_canonic-1 nil 3319890253 ("" (skeep) (("" (split) (("1" (case "vNum(b) <= abs(radix * Fnum(p))") (("1" (expand* "Fcanonic?" "Fnormal?") (("1" (assert) nil nil)) nil) ("2" (expand* "Fcanonic?" "Fsubnormal?") (("2" (assert) nil nil)) nil)) nil) ("2" (expand* "Fcanonic?" "Fnormal?") (("2" (assert) nil nil)) nil)) nil)) nil) ((Fsubnormal? const-decl "bool" float nil) (Fnormal? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (radix formal-const-decl "above(1)" float nil) (float type-eq-decl nil float nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak)) (FulpOpp_TCC1 0 (FulpOpp_TCC1-1 nil 3319817879 ("" (skeep) (("" (rewrite "FoppBounded") nil nil)) nil) ((FoppBounded formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil)) nil (FulpOpp subtype "float.Fopp(float.f)" "(float.Fbounded?(float.b))"))) (FulpOpp 0 (FulpOpp-1 nil 3319817880 ("" (skeep) (("" (expand "Fulp") (("" (case "Fnormalize(b)(Fopp(f))=Fopp(Fnormalize(b)(f))") (("1" (rewrite -1) (("1" (expand "Fopp") (("1" (propax) nil nil)) nil)) nil) ("2" (rewrite "FcanonicUnique" :subst ("b" "b")) (("1" (case "FtoR(Fnormalize(b)(Fopp(f)))= FtoR(Fopp(f))") (("1" (rewrite -1) (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "FcanonicOpp") (("2" (inst -1 "b" "Fnormalize(b)(f)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Fulp const-decl "real" float nil) (FcanonicUnique formula-decl nil float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (minus_real_is_real application-judgement "real" reals nil) (FoppCorrect formula-decl nil float nil) (FcanonicOpp formula-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (FtoR const-decl "real" float nil) (<= const-decl "bool" reals nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (Fopp const-decl "float" float nil)) shostak)) (FulpAbs_TCC1 0 (FulpAbs_TCC1-1 nil 3320082088 ("" (skeep) (("" (rewrite "FabsBounded") nil nil)) nil) ((FabsBounded formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil)) nil (FulpAbs subtype "float.Fabs(float.f)" "(float.Fbounded?(float.b))"))) (FulpAbs 0 (FulpAbs-1 nil 3320082088 ("" (skeep) (("" (expand "Fabs") (("" (expand "abs") (("" (grind-reals) (("1" (case-replace "(# Fnum := -Fnum(f), Fexp := Fexp(f) #)=Fopp(f)") (("1" (rewrite "FulpOpp") nil nil) ("2" (expand "Fopp") (("2" (propax) nil nil)) nil)) nil) ("2" (case-replace "(# Fnum := Fnum(f), Fexp := Fexp(f) #)=f") (("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil) ((Fabs const-decl "float" float nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Fulp_posreal_j application-judgement "posreal" float nil) (minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (FulpOpp formula-decl nil float nil) (Fopp const-decl "float" float nil) (float type-eq-decl nil float nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)) shostak)) (FulpMonotone 0 (FulpMonotone-1 nil 3320081916 ("" (skeep) (("" (expand "Fulp") (("" (rewrite "Exp_increq_1") (("" (rewrite "Lexico" :subst ("b" "b")) nil nil)) nil)) nil)) nil) ((Fulp const-decl "real" float nil) (Lexico formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (<= const-decl "bool" reals nil) (FtoR const-decl "real" float nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Fcanonic? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (float type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Exp_increq_1 formula-decl nil float nil)) shostak)) (FulpMonotoneAbs 0 (FulpMonotoneAbs-1 nil 3320082046 ("" (skeep) (("" (rewrite "FulpAbs" :dir rl) (("" (rewrite "FulpAbs" :dir rl :subst ("f" "q")) (("" (rewrite "FulpMonotone") (("1" (rewrite "FabsCorrect") (("1" (rewrite "FabsCorrect") nil nil)) nil) ("2" (rewrite "FabsCorrect") (("2" (assert) nil nil)) nil) ("3" (rewrite "FabsBounded") nil nil) ("4" (rewrite "FabsBounded") nil nil)) nil)) nil)) nil)) nil) ((FulpAbs formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fulp_posreal_j application-judgement "posreal" float nil) (FulpMonotone formula-decl nil float nil) (Fabs const-decl "float" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FabsCorrect formula-decl nil float nil) (FabsBounded formula-decl nil float nil)) shostak)) (FloatPlusUlpBounded 0 (FloatPlusUlpBounded-2 "" 3790102750 ("" (skeep) (("" (case "FORALL (b: Format, p: float):
        Fcanonic?(b)(p) =>
         (EXISTS (f: (Fbounded?(b))): FtoR(f) = FtoR(p) + Fulp(b)(p))") (("1" (inst -1 "b" "Fnormalize(b)(p)") (("1" (split) (("1" (skosimp*) (("1" (inst 1 "f!1") (("1" (case "FtoR(Fnormalize(b)(p))=FtoR(p)") (("1" (case " Fulp(b)(Fnormalize(b)(p))=Fulp(b)(p)") (("1" (assert) nil nil) ("2" (hide -1 -2 2) (("2" (expand "Fulp") (("2" (rewrite "FcanonicUnique" :subst ("b" "b" "p" "Fnormalize(b)(Fnormalize(b)(p))" "q" "Fnormalize(b)(p)")) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2 -1) (("2" (skosimp*) (("2" (case "Fnum(p!1) = vNum(b!1)-1 OR Fnum(p!1) <= vNum(b!1)-2") (("1" (split) (("1" (inst 1 "(# Fnum:=vNum(b!1)/radix, Fexp:=Fexp(p!1)+1 #)") (("1" (rewrite "FulpCanonic") (("1" (expand "FtoR") (("1" (rewrite "expt_plus") (("1" (field) nil nil)) nil)) nil)) nil) ("2" (expand "Fbounded?") (("2" (case "Fbounded?(b!1)(p!1)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (split) (("1" (expand "abs") (("1" (grind-reals) (("1" (div-by 1 "vNum(b!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ("3" (lemma "radix_div_vNum") (("3" (inst -1 "b!1") nil nil)) nil)) nil) ("2" (inst 1 "(# Fnum:=Fnum(p!1)+1, Fexp:=Fexp(p!1) #)") (("1" (rewrite "FulpCanonic") (("1" (expand "FtoR") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "Fbounded?") (("2" (case "Fbounded?(b!1)(p!1)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (split) (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil) ("2" (case "Fbounded?(b!1)(p!1)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil) ((Fulp const-decl "real" float nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (FtoR const-decl "real" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (Fbounded? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_plus_real_is_real application-judgement "real" reals nil) (Fulp_posreal_j application-judgement "posreal" float nil) (FcanonicUnique formula-decl nil float nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (p skolem-const-decl "float" float nil) (b skolem-const-decl "Format" float nil) (radix_div_vNum formula-decl nil float nil) (FcanonicBounded formula-decl nil float nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (zero_times1 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (times_div_cancel1 formula-decl nil extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_simp formula-decl nil real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (FulpCanonic formula-decl nil float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_plus formula-decl nil exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (expt_x1 formula-decl nil exponentiation nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "real" exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (p!1 skolem-const-decl "float" float nil) (radix formal-const-decl "above(1)" float nil) (b!1 skolem-const-decl "Format" float nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (int_plus_int_is_int application-judgement "int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil)) shostak) (FloatPlusUlpBounded-1 nil 3319810465 ("" (skeep) (("" (case "FORALL (b: Format, p: float):
        Fcanonic?(b)(p) =>
         (EXISTS (f: (Fbounded?(b))): FtoR(f) = FtoR(p) + Fulp(b)(p))") (("1" (inst -1 "b" "Fnormalize(b)(p)") (("1" (split) (("1" (skosimp*) (("1" (inst 1 "f!1") (("1" (case "FtoR(Fnormalize(b)(p))=FtoR(p)") (("1" (case " Fulp(b)(Fnormalize(b)(p))=Fulp(b)(p)") (("1" (assert) nil nil) ("2" (hide -1 -2 2) (("2" (expand "Fulp") (("2" (rewrite "FcanonicUnique" :subst ("b" "b" "p" "Fnormalize(b)(Fnormalize(b)(p))" "q" "Fnormalize(b)(p)")) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2 -1) (("2" (skosimp*) (("2" (case "Fnum(p!1) = vNum(b!1)-1 OR Fnum(p!1) <= vNum(b!1)-2") (("1" (split) (("1" (inst 1 "(# Fnum:=vNum(b!1)/radix, Fexp:=Fexp(p!1)+1 #)") (("1" (rewrite "FulpCanonic") (("1" (expand "FtoR") (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (field) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Fbounded?") (("2" (case "Fbounded?(b!1)(p!1)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (split) (("1" (expand "abs") (("1" (grind-reals) (("1" (div-by 1 "vNum(b!1)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ("3" (lemma "radix_div_vNum") (("3" (inst -1 "b!1") nil nil)) nil)) nil) ("2" (inst 1 "(# Fnum:=Fnum(p!1)+1, Fexp:=Fexp(p!1) #)") (("1" (rewrite "FulpCanonic") (("1" (expand "FtoR") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "Fbounded?") (("2" (case "Fbounded?(b!1)(p!1)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (split) (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil) ("2" (case "Fbounded?(b!1)(p!1)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil) nil shostak)) (FloatMinusUlpBounded 0 (FloatMinusUlpBounded-1 nil 3319814672 ("" (skeep) (("" (lemma "FloatPlusUlpBounded") (("" (inst -1 "b" "Fopp(p)") (("" (split) (("1" (skosimp*) (("1" (inst 1 "Fopp(f!1)") (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (rewrite -1) (("1" (case "Fulp(b)(Fopp(p))=Fulp(b)(p)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "Fulp") (("2" (case "Fnormalize(b)(Fopp(p))=Fopp(Fnormalize(b)(p))") (("1" (rewrite -1) (("1" (expand "Fopp") (("1" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "FcanonicUnique" :subst ("b" "b")) (("1" (case "FtoR(Fnormalize(b)(Fopp(p)))=FtoR(Fopp(p))") (("1" (rewrite -1) (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "FcanonicOpp") (("2" (inst -1 "b" "Fnormalize(b)(p)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FoppBounded") nil nil)) nil)) nil) ("2" (rewrite "FoppBounded") nil nil)) nil)) nil)) nil)) nil) ((FloatPlusUlpBounded formula-decl nil float nil) (f!1 skolem-const-decl "(Fbounded?(b))" float nil) (b skolem-const-decl "Format" float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Fulp const-decl "real" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (real_minus_real_is_real application-judgement "real" reals nil) (FcanonicOpp formula-decl nil float nil) (FcanonicUnique formula-decl nil float nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (<= const-decl "bool" reals nil) (FtoR const-decl "real" float nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Fcanonic? const-decl "bool" float nil) (real_plus_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (Fulp_posreal_j application-judgement "posreal" float nil) (FoppCorrect formula-decl nil float nil) (FoppBounded formula-decl nil float nil) (Fopp const-decl "float" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (FpredFoppFsucc 0 (FpredFoppFsucc-1 nil 3319211967 ("" (skeep) (("" (expand* "Fpred" "Fopp" "Fsucc") (("" (grind-reals) nil nil)) nil)) nil) ((Fopp const-decl "float" float nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Fsucc const-decl "float" float nil) (int_minus_int_is_int application-judgement "int" integers nil) (Fpred const-decl "float" float nil) (int_plus_int_is_int application-judgement "int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (minus_int_is_int application-judgement "int" integers nil) (div_cancel4 formula-decl nil real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (FsuccFoppFpred 0 (FsuccFoppFpred-1 nil 3319212016 ("" (skeep) (("" (expand* "Fsucc" "Fopp" "Fpred") (("" (grind-reals) nil nil)) nil)) nil) ((Fopp const-decl "float" float nil) (int_minus_int_is_int application-judgement "int" integers nil) (Fpred const-decl "float" float nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Fsucc const-decl "float" float nil) (int_plus_int_is_int application-judgement "int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_int_is_int application-judgement "int" integers nil) (div_cancel4 formula-decl nil real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (FsuccFpred 0 (FsuccFpred-2 "" 3790102758 ("" (skeep) (("" (expand* "Fpred" "Fsucc") (("" (grind-reals) (("1" (lemma "radix_less_vNum" :subst ("b" "b")) (("1" (hide -2 -3) (("1" (field -2) nil nil)) nil)) nil) ("2" (apply-extensionality :hide? t) nil nil) ("3" (expand* "Fcanonic?" "Fnormal?" "Fsubnormal?" "Fbounded?") nil nil) ("4" (decompose-equality 2) (("1" (grind) nil nil) ("2" (replace -2 :dir rl :hide? t) (("2" (grind) nil nil)) nil)) nil) ("5" (expand* "Fcanonic?" "Fnormal?" "Fsubnormal?" "Fbounded?") (("5" (rewrite -2) (("5" (grind-reals) nil nil)) nil)) nil) ("6" (decompose-equality 3) nil nil) ("7" (expand* "Fcanonic?" "Fnormal?" "Fsubnormal?" "Fbounded?") (("7" (rewrite -2) (("7" (grind-reals) nil nil)) nil)) nil) ("8" (expand* "Fcanonic?" "Fnormal?" "Fsubnormal?" "Fbounded?") (("8" (flatten) (("8" (case-replace "Fnum(f)=1-(vNum(b) / radix)") (("1" (hide-all-but -3) (("1" (rewrite "abs_mult") (("1" (expand "abs") (("1" (grind-reals) (("1" (lemma "radix_less_vNum" :subst ("b" "b")) (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("9" (decompose-equality 3) nil nil)) nil)) nil)) nil) ((Fsucc const-decl "float" float nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (Fpred const-decl "float" float nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (abs_mult formula-decl nil real_props nil) (rat_abs_is_nonneg application-judgement "{r: nonneg_rat | r >= q}" real_defs nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (minus_rat_is_rat application-judgement "rat" rationals nil) (div_cancel2 formula-decl nil real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (f skolem-const-decl "float" float nil) (radix formal-const-decl "above(1)" float nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (posrat nonempty-type-eq-decl nil rationals nil) (both_sides_times_pos_lt2 formula-decl nil real_props nil) (both_sides_times_pos_le2 formula-decl nil real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (Fcanonic? const-decl "bool" float nil) (Fnormal? const-decl "bool" float nil) (Fsubnormal? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (float type-eq-decl nil float nil) (vNum const-decl "posnat" float nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (radix_less_vNum formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (int_times_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (minus_int_is_int application-judgement "int" integers nil) (div_cancel3 formula-decl nil real_props nil) (div_cancel4 formula-decl nil real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak) (FsuccFpred-1 nil 3319298166 ("" (skeep) (("" (expand* "Fpred" "Fsucc") (("" (grind-reals) (("1" (lemma "radix_less_vNum" :subst ("b" "b")) (("1" (hide -2 -3) (("1" (field -2) nil nil)) nil)) nil) ("2" (apply-extensionality :hide? t) nil nil) ("3" (expand* "Fcanonic?" "Fnormal?" "Fsubnormal?" "Fbounded?") nil nil) ("4" (decompose-equality 2) (("1" (rewrite "div_cancel4") (("1" (grind) nil nil)) nil) ("2" (rewrite "div_cancel4") (("2" (replace -2 :dir rl :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil) ("5" (expand* "Fcanonic?" "Fnormal?" "Fsubnormal?" "Fbounded?") (("5" (rewrite -2) (("5" (grind-reals) nil nil)) nil)) nil) ("6" (decompose-equality 3) nil nil) ("7" (expand* "Fcanonic?" "Fnormal?" "Fsubnormal?" "Fbounded?") (("7" (rewrite -2) (("7" (grind-reals) nil nil)) nil)) nil) ("8" (expand* "Fcanonic?" "Fnormal?" "Fsubnormal?" "Fbounded?") (("8" (flatten) (("8" (case-replace "Fnum(f)=1-(vNum(b) / radix)") (("1" (hide-all-but -3) (("1" (rewrite "abs_mult") (("1" (expand "abs") (("1" (grind-reals) (("1" (lemma "radix_less_vNum" :subst ("b" "b")) (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("9" (decompose-equality 3) nil nil)) nil)) nil)) nil) nil shostak)) (FpredFsucc 0 (FpredFsucc-1 nil 3319299927 ("" (skeep) (("" (case "f=Fopp(Fopp(f))") (("1" (rewrite -1 :target-fnums 1) (("1" (rewrite "FsuccFoppFpred") (("1" (rewrite "FpredFoppFsucc" :subst ("f" "(Fpred(b)(Fopp(f)))")) (("1" (rewrite "FsuccFpred") (("1" (lemma "FcanonicOpp") (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "Fopp") (("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil) ((Fopp const-decl "float" float nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (FsuccFoppFpred formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (FsuccFpred formula-decl nil float nil) (FcanonicOpp formula-decl nil float nil) (FpredFoppFsucc formula-decl nil float nil) (Fpred const-decl "float" float nil) (minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil)) shostak)) (FpredBounded 0 (FpredBounded-1 nil 3320428258 ("" (skeep) (("" (expand* "Fbounded?" "Fpred") (("" (grind-reals) (("1" (expand "abs" 1) (("1" (field 1) (("1" (div-by 1 "vNum(b)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "abs" 2) (("2" (assert) nil nil)) nil) ("3" (expand "abs") (("3" (grind-reals) nil nil)) nil) ("4" (expand "abs") (("4" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ((Fpred const-decl "float" float nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (Fbounded? const-decl "bool" float nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (radix formal-const-decl "above(1)" float nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (vNum const-decl "posnat" float nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (div_simp formula-decl nil real_props nil) (/= const-decl "boolean" notequal nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div_cancel1 formula-decl nil extra_real_props nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (abs_div formula-decl nil real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (div_cancel4 formula-decl nil real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (FsuccBounded 0 (FsuccBounded-1 nil 3320428394 ("" (skeep) (("" (case-replace "Fsucc(b)(f)=Fopp(Fopp(Fsucc(b)(f)))") (("1" (rewrite "FoppBounded") (("1" (rewrite "FpredFoppFsucc" :dir rl) (("1" (rewrite "FpredBounded") (("1" (rewrite "FoppBounded") nil nil)) nil)) nil)) nil) ("2" (expand "Fopp") (("2" (decompose-equality 1) nil nil)) nil)) nil)) nil) ((int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (Fsucc const-decl "float" float nil) (Fopp const-decl "float" float nil) (FpredFoppFsucc formula-decl nil float nil) (FpredBounded formula-decl nil float nil) (FoppBounded formula-decl nil float nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (minus_int_is_int application-judgement "int" integers nil)) shostak)) (FsuccCanonic 0 (FsuccCanonic-1 nil 3319233185 ("" (skeep) (("" (lemma "FcanonicOpp") (("" (inst-cp -1 "b" "Fsucc(b)(f)") (("" (flatten) (("" (rewrite -3) (("" (hide -2 -3 2) (("" (lemma "FpredFoppFsucc") (("" (inst -1 "b" "f") (("" (case "Fcanonic?(b)(Fpred(b)(Fopp(f)))") (("1" (assert) nil nil) ("2" (rewrite "FpredCanonic") (("2" (hide 2 3 -1) (("2" (inst -1 "b" "f") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FcanonicOpp formula-decl nil float nil) (FpredCanonic formula-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Fcanonic? const-decl "bool" float nil) (Fpred const-decl "float" float nil) (Fopp const-decl "float" float nil) (FpredFoppFsucc formula-decl nil float nil) (Fsucc const-decl "float" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (FpredPos 0 (FpredPos-1 nil 3319306101 ("" (skeep) (("" (expand "FtoR") (("" (div-by -2 "radix ^ (Fexp(p))") (("" (case-replace "0 / radix ^ (Fexp(p))=0") (("1" (hide -1) (("1" (expand "Fpred") (("1" (grind-reals) nil nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ((FtoR const-decl "real" float nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (Fpred const-decl "float" float nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (div_cancel4 formula-decl nil real_props nil) (pos_times_le formula-decl nil real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (float type-eq-decl nil float nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil)) shostak)) (FsuccPos 0 (FsuccPos-1 nil 3319462089 ("" (skeep) (("" (case "0 <=Fnum(p)") (("1" (case "0 < Fnum(Fsucc(b)(p))") (("1" (expand "FtoR" 1) (("1" (grind-reals) nil nil)) nil) ("2" (hide 2) (("2" (expand "Fsucc") (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (cross-mult 1) nil nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "FtoR" -2) (("2" (grind-reals) nil nil)) nil)) nil)) nil) ((float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (Fcanonic? const-decl "bool" float nil) (Fsubnormal? const-decl "bool" float nil) (Fnormal? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (radix formal-const-decl "above(1)" float nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (FtoR const-decl "real" float nil) (pos_times_lt formula-decl nil real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (Fsucc const-decl "float" float nil) (pos_times_le formula-decl nil real_props nil)) shostak)) (FpredDiff_TCC1 0 (FpredDiff_TCC1-1 nil 3319375218 ("" (skeep) (("" (rewrite "FcanonicBounded") (("" (rewrite "FpredCanonic") nil nil)) nil)) nil) ((FcanonicBounded formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fpred const-decl "float" float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (FpredCanonic formula-decl nil float nil)) nil (FpredDiff subtype "float.Fpred(float.b)(float.f)" "(float.Fbounded?(float.b))"))) (FpredDiff 0 (FpredDiff-2 "" 3790102766 ("" (skeep) (("" (rewrite "FulpCanonic") (("1" (expand* "FtoR" "Fpred") (("1" (grind-reals) (("1" (rewrite "expt_div" :dir rl) (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "FpredCanonic") nil nil)) nil)) nil) ((FulpCanonic formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fpred const-decl "float" float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (Fulp_posreal_j application-judgement "posreal" float nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (div_cancel4 formula-decl nil real_props nil) (pos_times_lt formula-decl nil real_props nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (times_div1 formula-decl nil real_props nil) (expt_x1 formula-decl nil exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (expt_div formula-decl nil exponentiation nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (FtoR const-decl "real" float nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (FpredCanonic formula-decl nil float nil)) shostak) (FpredDiff-1 nil 3319375376 ("" (skeep) (("" (rewrite "FulpCanonic") (("1" (expand* "FtoR" "Fpred") (("1" (grind-reals) (("1" (rewrite "expt_div" :dir rl) (("1" (rewrite "expt_x1") (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FpredCanonic") nil nil)) nil)) nil) nil shostak)) (FsuccDiff 0 (FsuccDiff-1 nil 3319461787 ("" (skeep) (("" (case "f=Fpred(b)(Fsucc(b)(f))") (("1" (case-replace "FtoR(f)=FtoR(Fpred(b)(Fsucc(b)(f)))") (("1" (case-replace "Fulp(b)(f)=Fulp(b)(Fpred(b)(Fsucc(b)(f)))") (("1" (rewrite "FpredDiff") (("1" (hide -1 -2 2) (("1" (rewrite "FsuccPos") nil nil)) nil) ("2" (rewrite "FsuccCanonic") nil nil)) nil) ("2" (grind-reals) nil nil) ("3" (rewrite -2 :dir rl) (("3" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil) ("2" (rewrite "FpredFsucc") nil nil)) nil)) nil) ((Fsucc const-decl "float" float nil) (Fpred const-decl "float" float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Fulp_posreal_j application-judgement "posreal" float nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (Fulp const-decl "real" float nil) (FsuccCanonic formula-decl nil float nil) (FsuccPos formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (FpredDiff formula-decl nil float nil) (FcanonicBounded formula-decl nil float nil) (FtoR const-decl "real" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (FpredFsucc formula-decl nil float nil)) shostak)) (FpredLt 0 (FpredLt-2 "" 3790102768 ("" (skeep) (("" (expand "Fpred") (("" (grind-reals) (("1" (expand "FtoR") (("1" (rewrite "expt_plus") (("1" (rewrite -1) (("1" (field) nil nil)) nil)) nil)) nil) ("2" (expand "FtoR") (("2" (case-replace "radix ^ (Fexp(f) - 1)=radix ^ (Fexp(f))/radix") (("1" (hide -1 -3 1) (("1" (field) nil nil)) nil) ("2" (hide -1 -2 2 3) (("2" (lemma "expt_div") (("2" (inst -1 "Fexp(f)" "1" "radix") (("2" (rewrite "expt_x1" -1) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 1 2) (("3" (expand "FtoR") (("3" (grind-reals) nil nil)) nil)) nil) ("4" (expand "FtoR") (("4" (hide 1 2) (("4" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (Fpred const-decl "float" float nil) (div_cancel3 formula-decl nil real_props nil) (expt_div formula-decl nil exponentiation nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (div_distributes_minus formula-decl nil real_props nil) (times_div1 formula-decl nil real_props nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (^ const-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (FtoR const-decl "real" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (times_div2 formula-decl nil real_props nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (expt_x1 formula-decl nil exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (expt_plus formula-decl nil exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (div_cancel4 formula-decl nil real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak) (FpredLt-1 nil 3319233508 ("" (skeep) (("" (expand "Fpred") (("" (grind-reals) (("1" (expand "FtoR") (("1" (rewrite "expt_plus") (("1" (rewrite "expt_x1") (("1" (rewrite -1) (("1" (field) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "FtoR") (("2" (case-replace "radix ^ (Fexp(f) - 1)=radix ^ (Fexp(f))/radix") (("1" (hide -1 -3 1) (("1" (field) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (hide -1 -2 2 3) (("2" (lemma "expt_div") (("2" (inst -1 "Fexp(f)" "1" "radix") (("2" (rewrite "expt_x1" -1) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 1 2) (("3" (expand "FtoR") (("3" (grind-reals) nil nil)) nil)) nil) ("4" (expand "FtoR") (("4" (hide 1 2) (("4" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (FpredLe_aux 0 (FpredLe_aux-2 "" 3790102794 ("" (skeep) (("" (case-replace "FtoR(Fpred(b)(p))=FtoR(p)-Fulp(b)(Fpred(b)(p))") (("1" (case-replace "FtoR(Fpred(b)(q))=FtoR(q)-Fulp(b)(Fpred(b)(q))") (("1" (rewrite "FulpCanonic") (("1" (rewrite "FulpCanonic") (("1" (hide -1 -2) (("1" (case "0<Fnum(p)") (("1" (case "0<Fnum(q)") (("1" (case "Fexp(p) <= Fexp(q)") (("1" (expand "Fpred") (("1" (grind-reals) (("1" (expand* "FtoR") (("1" (rewrite "expt_div" :dir rl) (("1" (rewrite "expt_div" :dir rl) (("1" (field) (("1" (div-by 1 "vNum(b)-1") (("1" (case-replace "Fnum(p)=vNum(b)/radix") (("1" (case-replace "Fnum(q)=vNum(b)/radix") (("1" (case-replace "(vNum(b) / radix * (radix ^ Fexp(p)) * radix - (radix ^ Fexp(p))) /
                                                                         (vNum(b) - 1)=radix ^ Fexp(p)") (("1" (case-replace "(vNum(b) / radix * (radix ^ Fexp(q)) * radix - (radix ^ Fexp(q))) /
                                                                                (vNum(b) - 1)=radix ^ Fexp(q)") (("1" (rewrite "Exp_increq_1") nil nil) ("2" (field) nil nil)) nil) ("2" (field 1) nil nil)) nil) ("2" (grind-reals) nil nil)) nil) ("2" (expand "Fcanonic?") (("2" (split) (("1" (expand "Fnormal?") (("1" (flatten) (("1" (rewrite "abs_mult" -2) (("1" (expand "abs" -2) (("1" (mult-by 2 "radix") (("1" (field 2) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace " Fnum(p) * (radix ^ Fexp(p)) * radix - (radix ^ Fexp(p))
                                                               = (vNum(b)-1)*radix ^ Fexp(p)") (("1" (case "(vNum(b) - 1) * radix ^ Fexp(p) <= (vNum(b) - 1) * radix ^ Fexp(q)") (("1" (case "(vNum(b) - 1) * radix ^ Fexp(q) <=  Fnum(q) * radix ^ (Fexp(q)) * radix - radix ^ Fexp(q) * radix") (("1" (grind-reals) nil nil) ("2" (cancel-by 1 "radix ^ Fexp(q)") nil nil)) nil) ("2" (hide-all-but (-5 2 3)) (("2" (case "vNum(b) = radix * Fnum(q) OR vNum(b) < radix * Fnum(q)") (("1" (split) (("1" (grind-reals) nil nil) ("2" (lemma "radix_div_vNum") (("2" (inst -1 "b") (("2" (rewrite "div_simple" -1 :dir rl) (("2" (skosimp*) (("2" (div-by -2 "radix") (("2" (case-replace "vNum(b) / radix=k!1") (("1" (case "k!1 <= Fnum(q)-1") (("1" (mult-by -1 "radix") (("1" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (div-by 1 "vNum(b) - 1") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Fcanonic?" -5) (("2" (split) (("1" (expand "Fnormal?") (("1" (flatten) (("1" (rewrite "abs_mult" -2) (("1" (expand "abs" -2) (("1" (expand "FtoR" 2) (("1" (rewrite "expt_div" :dir rl) (("1" (mult-by 2 "radix") (("1" (field 2) (("1" (case-replace " Fnum(p) * (radix ^ Fexp(p)) * radix - (radix ^ Fexp(p))
                                           = (vNum(b)-1)*radix ^ Fexp(p)") (("1" (case "(vNum(b) - 1) * radix ^ Fexp(p) <= (vNum(b) - 1) * radix ^ Fexp(q)") (("1" (case "(vNum(b) - 1) * radix ^ Fexp(q) <=  Fnum(q) * radix ^ (Fexp(q)) * radix - radix ^ Fexp(q) * radix") (("1" (grind-reals) nil nil) ("2" (cancel-by 1 "radix ^ Fexp(q)") (("2" (hide-all-but (-5 2 3)) (("2" (case "vNum(b) = radix * Fnum(q) OR vNum(b) < radix * Fnum(q)") (("1" (split) (("1" (grind-reals) nil nil) ("2" (lemma "radix_div_vNum") (("2" (inst -1 "b") (("2" (rewrite "div_simple" -1 :dir rl) (("2" (skosimp*) (("2" (div-by -2 "radix") (("2" (case-replace "vNum(b) / radix=k!1") (("1" (case "k!1 <= Fnum(q)-1") (("1" (mult-by -1 "radix") (("1" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (div-by 1 "vNum(b) - 1") (("2" (rewrite "Exp_increq_1") nil nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Fsubnormal?") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (case "-dExp(b) = Fexp(p)") (("1" (expand "abs" -2) (("1" (expand "FtoR" 2) (("1" (case "(vNum(b)-2)*radix ^ Fexp(p) <= Fnum(q) * radix ^ (Fexp(q)) - radix ^ (Fexp(q) - 1)") (("1" (case "Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p) <= (vNum(b) - 2) * radix ^ Fexp(p)") (("1" (grind-reals) nil nil) ("2" (div-by 1 "radix ^ (Fexp(p))") (("2" (case-replace "(Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p)) / radix ^ (Fexp(p))
                           = Fnum(p)-1") (("1" (grind-reals) nil nil) ("2" (field 1) nil nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (case "(vNum(b) - 2) * radix ^ (Fexp(q)-1) <= Fnum(q) * radix ^ (Fexp(q)) - radix ^ (Fexp(q) - 1)") (("1" (case "(vNum(b) - 2) * radix ^ Fexp(p) <=(vNum(b) - 2) * radix ^ (Fexp(q) - 1)") (("1" (grind-reals) nil nil) ("2" (div-by 1 "vNum(b) - 2") (("2" (rewrite "Exp_increq_1") nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "expt_div" :dir rl) (("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil) ("4" (case " Fexp(p)=-dExp(b)") (("1" (case " Fexp(q)=-dExp(b)") (("1" (hide 1 2 -3) (("1" (expand* "FtoR") (("1" (replace -2) (("1" (replace -1) (("1" (hide -4) (("1" (div-by -6 "radix ^ -dExp(b)") (("1" (div-by 1 "radix ^ -dExp(b)") (("1" (case-replace "(Fnum(p) * radix ^ -dExp(b) - radix ^ -dExp(b)) / radix ^ -dExp(b)
                       = Fnum(p)-1") (("1" (case-replace "(Fnum(q) * radix ^ -dExp(b) - radix ^ -dExp(b)) / radix ^ -dExp(b)
                         = Fnum(q)-1") (("1" (grind-reals) nil nil) ("2" (field 1) nil nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil) ("2" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (propax) nil nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ("5" (case "Fexp(p) = -dExp(b)") (("1" (hide 1) (("1" (split-ineq -2) (("1" (case "Fexp(p) < Fexp(q)") (("1" (hide 1) (("1" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (expand "abs" -1) (("1" (expand "Fcanonic?" -8) (("1" (expand* "Fnormal?" "Fsubnormal?") (("1" (flatten) (("1" (rewrite "abs_mult" -9) (("1" (expand "abs" -9) (("1" (hide -4) (("1" (expand "FtoR" 2) (("1" (case "(vNum(b)-2)* radix ^ Fexp(p) <= Fnum(q) * radix ^ (Fexp(q)) - radix ^ Fexp(q)") (("1" (case "Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p) <= (vNum(b) - 2) * radix ^ Fexp(p)") (("1" (assert) nil nil) ("2" (div-by 1 "radix ^ Fexp(p)") (("2" (case-replace "(Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p)) / radix ^ Fexp(p)
                             = Fnum(p)-1") (("1" (grind-reals) nil nil) ("2" (field 1) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (case "(vNum(b) - 2) * radix ^ (Fexp(q)-1) <= Fnum(q) * radix ^ (Fexp(q)) - radix ^ Fexp(q)") (("1" (case "(vNum(b) - 2) * radix ^ Fexp(p) <= (vNum(b) - 2) * radix ^ (Fexp(q) - 1)") (("1" (assert) nil nil) ("2" (div-by 1 "vNum(b) - 2") (("2" (rewrite "Exp_increq_1") nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "expt_div" :dir rl) (("2" (div-by 1 "radix ^ Fexp(q)") (("2" (case-replace "(vNum(b) - 2) * (radix ^ Fexp(q) / radix) / radix ^ Fexp(q)
                             = (vNum(b) - 2) / radix") (("1" (case-replace "(Fnum(q) * radix ^ (Fexp(q)) - radix ^ Fexp(q)) / radix ^ Fexp(q)
                               = Fnum(q)-1") (("1" (grind-reals) (("1" (case "vNum(b)/radix +1 <= Fnum(q)") (("1" (hide-all-but (-1 1)) (("1" (lemma "radix_less_vNum") (("1" (inst -1 "b") (("1" (mult-by -2 "radix") (("1" (field -1) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "radix_div_vNum") (("2" (inst -1 "b") (("2" (rewrite "div_simple" :dir rl) (("2" (hide -2) (("2" (skosimp*) (("2" (case "k!1 < Fnum(q)") (("1" (grind-reals) (("1" (field 1) nil nil)) nil) ("2" (grind-reals) (("2" (div-by -10 "radix") (("2" (div-by 4 "radix") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (field 1) nil nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ("6" (split-ineq -1) (("1" (expand "FtoR" -8) (("1" (expand "Fcanonic?" -6) (("1" (expand* "Fnormal?" "Fsubnormal?") (("1" (flatten) (("1" (rewrite "abs_mult" -7) (("1" (expand "abs" -7) (("1" (replaces -1 -9) (("1" (expand* "Fcanonic?" "Fnormal?" "Fsubnormal?") (("1" (flatten) (("1" (rewrite "abs_mult" -5) (("1" (expand "abs" -5) (("1" (div-by -9 "radix ^ (Fexp(q))") (("1" (mult-by -9 "radix") (("1" (rewrite -10) (("1" (hide-all-but (-1 -6 1)) (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case " Fexp(p) < Fexp(q)") (("1" (hide -2 1) (("1" (hide 1 -7) (("1" (expand "FtoR") (("1" (case "(vNum(b)-2)*radix ^ Fexp(p) <= Fnum(q) * radix ^ (Fexp(q)) - radix ^ (Fexp(q) - 1)") (("1" (case "Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p) <=(vNum(b) - 2) * radix ^ Fexp(p)") (("1" (assert) nil nil) ("2" (div-by 1 "radix ^ Fexp(p)") (("2" (case-replace "(Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p)) / radix ^ Fexp(p)=Fnum(p)-1") (("1" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil) ("2" (field) nil nil)) nil)) nil)) nil) ("2" (case "(vNum(b) - 2) * radix ^ (Fexp(q)-1) <=
                                    Fnum(q) * radix ^ (Fexp(q)) - radix ^ (Fexp(q) - 1)") (("1" (case "(vNum(b) - 2) * radix ^ Fexp(p) <= (vNum(b) - 2) * radix ^ (Fexp(q) - 1)") (("1" (assert) nil nil) ("2" (div-by 1 "(vNum(b) - 2)") (("1" (rewrite "Exp_increq_1") nil nil) ("2" (hide-all-but 1) (("2" (lemma "radix_less_vNum") (("2" (inst -1 "b") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (rewrite "expt_div" :dir rl) (("2" (div-by 1 "radix ^ Fexp(q)") (("2" (case-replace "(vNum(b) - 2) * (radix ^ Fexp(q) / radix) / radix ^ Fexp(q)
                            = (vNum(b) - 2)/radix") (("1" (case-replace "(Fnum(q) * radix ^ (Fexp(q)) - radix ^ Fexp(q) / radix) /
                                    radix ^ Fexp(q)=Fnum(q) -1/radix") (("1" (field 1) nil nil) ("2" (field 1) nil nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil) ("7" (expand* "FtoR") (("7" (case-replace "Fexp(q)=-dExp(b)") (("1" (case-replace "Fexp(p)=-dExp(b)") (("1" (grind-reals) nil nil) ("2" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (propax) nil nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ("2" (case "Fbounded?(b)(q)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil) ("8" (split-ineq -1) (("8" (case "Fexp(p) < Fexp(q)") (("1" (hide -2 1) (("1" (expand "FtoR" 3) (("1" (case "(vNum(b)-2)*radix ^ Fexp(p)<= Fnum(q) * radix ^ (Fexp(q)) - radix ^ Fexp(q)") (("1" (case "Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p) <= (vNum(b) - 2) * radix ^ Fexp(p)") (("1" (assert) nil nil) ("2" (div-by 1 "radix ^ Fexp(p)") (("2" (case-replace "(Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p)) / radix ^ Fexp(p)=Fnum(p)-1") (("1" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (expand "abs" -1) (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil) ("2" (field) nil nil)) nil)) nil)) nil) ("2" (case "(vNum(b) - 2) * radix ^ (Fexp(q)-1) <=
                                  Fnum(q) * radix ^ (Fexp(q)) - radix ^ Fexp(q)") (("1" (case "(vNum(b) - 2) * radix ^ Fexp(p) <= (vNum(b) - 2) * radix ^ (Fexp(q) - 1)") (("1" (assert) nil nil) ("2" (div-by 1 "vNum(b) - 2") (("1" (rewrite "Exp_increq_1") nil nil) ("2" (lemma "radix_less_vNum") (("2" (inst -1 "b") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 5) (("2" (rewrite "expt_div" :dir rl) (("2" (div-by 1 "radix ^ Fexp(q)") (("2" (case-replace "(vNum(b) - 2) * (radix ^ Fexp(q) / radix) / radix ^ Fexp(q)
                          = (vNum(b) - 2)/radix") (("1" (case-replace "(Fnum(q) * radix ^ (Fexp(q)) - radix ^ Fexp(q)) / radix ^ Fexp(q)
                           = Fnum(q)-1") (("1" (case "vNum(b)/radix +1 <= Fnum(q)") (("1" (mult-by -1 "radix") (("1" (mult-by 1 "radix") (("1" (field) nil nil)) nil)) nil) ("2" (lemma "radix_div_vNum") (("2" (inst -1 "b") (("2" (rewrite "div_simple" :dir rl) (("2" (skosimp*) (("2" (case "k!1 < Fnum(q)") (("1" (grind-reals) nil nil) ("2" (hide -2 -3 2 3) (("2" (expand "Fcanonic?" -6) (("2" (expand* "Fnormal?" "Fsubnormal?") (("2" (split) (("1" (flatten) (("1" (rewrite "abs_mult" -2) (("1" (expand "abs" -2) (("1" (hide-all-but (-2 -3 1 3)) (("1" (rewrite -2) (("1" (div-by -1 "radix") (("1" (div-by 2 "radix") (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (field 1) nil nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "Lexico") (("2" (inst -1 "b" "p" "q") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "0<FtoR(q)") (("1" (expand "FtoR" -1) (("1" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil) ("2" (expand "FtoR" -3) (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "FpredCanonic") nil nil)) nil) ("2" (rewrite "FpredCanonic") nil nil)) nil) ("2" (rewrite "FpredDiff" :dir rl) (("2" (assert) nil nil)) nil) ("3" (rewrite "FcanonicBounded") (("3" (rewrite "FpredCanonic") nil nil)) nil)) nil) ("2" (rewrite "FpredDiff" :dir rl) (("2" (assert) nil nil)) nil) ("3" (rewrite "FcanonicBounded") (("3" (rewrite "FpredCanonic") nil nil)) nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (FtoR const-decl "real" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (Fpred const-decl "float" float nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (Fulp const-decl "real" float nil) (FpredDiff formula-decl nil float nil) (FulpCanonic formula-decl nil float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (FpredCanonic formula-decl nil float nil) (Lexico formula-decl nil float nil) (int_minus_int_is_int application-judgement "int" integers nil) (times_div2 formula-decl nil real_props nil) (pos_times_lt formula-decl nil real_props nil) (nnrat_plus_posrat_is_posrat application-judgement "posrat" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (radix_less_vNum formula-decl nil float nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (div_div2 formula-decl nil real_props nil) (div_distributes_minus formula-decl nil real_props nil) (cross_mult formula-decl nil real_props nil) (both_sides_times_pos_le2 formula-decl nil real_props nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (le_times_le_pos formula-decl nil real_props nil) (times_div1 formula-decl nil real_props nil) (div_mult_pos_le1 formula-decl nil real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (FcanonicBounded formula-decl nil float nil) (Fsubnormal? const-decl "bool" float nil) (b skolem-const-decl "Format" float nil) (div_cancel3 formula-decl nil real_props nil) (rat nonempty-type-eq-decl nil rationals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Fcanonic? const-decl "bool" float nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (times_div_cancel1 formula-decl nil extra_real_props nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (div_simple formula-decl nil integer_props nil) (nzint nonempty-type-eq-decl nil integers nil) (radix_div_vNum formula-decl nil float nil) (posrat nonempty-type-eq-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (both_sides_div1 formula-decl nil real_props nil) (Fnormal? const-decl "bool" float nil) (abs_mult formula-decl nil real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (Exp_increq_1 formula-decl nil float nil) (both_sides_times1 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (div_cancel2 formula-decl nil real_props nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (^ const-decl "real" exponentiation nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (>= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (expt_x1 formula-decl nil exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (expt_div formula-decl nil exponentiation nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (div_cancel4 formula-decl nil real_props nil) (TRUE const-decl "bool" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (Fulp_posreal_j application-judgement "posreal" float nil)) shostak) (FpredLe_aux-1 nil 3319391212 ("" (skeep) (("" (case-replace "FtoR(Fpred(b)(p))=FtoR(p)-Fulp(b)(Fpred(b)(p))") (("1" (case-replace "FtoR(Fpred(b)(q))=FtoR(q)-Fulp(b)(Fpred(b)(q))") (("1" (rewrite "FulpCanonic") (("1" (rewrite "FulpCanonic") (("1" (hide -1 -2) (("1" (case "0<Fnum(p)") (("1" (case "0<Fnum(q)") (("1" (case "Fexp(p) <= Fexp(q)") (("1" (expand "Fpred") (("1" (grind-reals) (("1" (expand* "FtoR") (("1" (rewrite "expt_div" :dir rl) (("1" (rewrite "expt_div" :dir rl) (("1" (rewrite "expt_x1") (("1" (field) (("1" (div-by 1 "vNum(b)-1") (("1" (case-replace "Fnum(p)=vNum(b)/radix") (("1" (case-replace "Fnum(q)=vNum(b)/radix") (("1" (case-replace "(vNum(b) / radix * (radix ^ Fexp(p)) * radix - (radix ^ Fexp(p))) /
                                                                         (vNum(b) - 1)=radix ^ Fexp(p)") (("1" (case-replace "(vNum(b) / radix * (radix ^ Fexp(q)) * radix - (radix ^ Fexp(q))) /
                                                                                (vNum(b) - 1)=radix ^ Fexp(q)") (("1" (rewrite "Exp_increq_1") nil nil) ("2" (field) nil nil)) nil) ("2" (field 1) nil nil)) nil) ("2" (flatten) (("2" (grind-reals) nil nil)) nil)) nil) ("2" (expand "Fcanonic?") (("2" (split) (("1" (expand "Fnormal?") (("1" (flatten) (("1" (rewrite "abs_mult" -2) (("1" (expand "abs" -2) (("1" (mult-by 2 "radix") (("1" (field 2) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace " Fnum(p) * (radix ^ Fexp(p)) * radix - (radix ^ Fexp(p))
                                                               = (vNum(b)-1)*radix ^ Fexp(p)") (("1" (case "(vNum(b) - 1) * radix ^ Fexp(p) <= (vNum(b) - 1) * radix ^ Fexp(q)") (("1" (case "(vNum(b) - 1) * radix ^ Fexp(q) <=  Fnum(q) * radix ^ (Fexp(q)) * radix - radix ^ Fexp(q) * radix") (("1" (grind-reals) nil nil) ("2" (cancel-by 1 "radix ^ Fexp(q)") nil nil)) nil) ("2" (hide-all-but (-5 2 3)) (("2" (case "vNum(b) = radix * Fnum(q) OR vNum(b) < radix * Fnum(q)") (("1" (split) (("1" (grind-reals) nil nil) ("2" (lemma "radix_div_vNum") (("2" (inst -1 "b") (("2" (rewrite "div_simple" -1 :dir rl) (("2" (skosimp*) (("2" (div-by -2 "radix") (("2" (case-replace "vNum(b) / radix=k!1") (("1" (case "k!1 <= Fnum(q)-1") (("1" (mult-by -1 "radix") (("1" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (div-by 1 "vNum(b) - 1") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Fcanonic?" -5) (("2" (split) (("1" (expand "Fnormal?") (("1" (flatten) (("1" (rewrite "abs_mult" -2) (("1" (expand "abs" -2) (("1" (expand "FtoR" 2) (("1" (rewrite "expt_div" :dir rl) (("1" (rewrite "expt_x1") (("1" (mult-by 2 "radix") (("1" (field 2) (("1" (case-replace " Fnum(p) * (radix ^ Fexp(p)) * radix - (radix ^ Fexp(p))
                                           = (vNum(b)-1)*radix ^ Fexp(p)") (("1" (case "(vNum(b) - 1) * radix ^ Fexp(p) <= (vNum(b) - 1) * radix ^ Fexp(q)") (("1" (case "(vNum(b) - 1) * radix ^ Fexp(q) <=  Fnum(q) * radix ^ (Fexp(q)) * radix - radix ^ Fexp(q) * radix") (("1" (grind-reals) nil nil) ("2" (cancel-by 1 "radix ^ Fexp(q)") (("2" (hide-all-but (-5 2 3)) (("2" (case "vNum(b) = radix * Fnum(q) OR vNum(b) < radix * Fnum(q)") (("1" (split) (("1" (grind-reals) nil nil) ("2" (lemma "radix_div_vNum") (("2" (inst -1 "b") (("2" (rewrite "div_simple" -1 :dir rl) (("2" (skosimp*) (("2" (div-by -2 "radix") (("2" (case-replace "vNum(b) / radix=k!1") (("1" (case "k!1 <= Fnum(q)-1") (("1" (mult-by -1 "radix") (("1" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (div-by 1 "vNum(b) - 1") (("2" (rewrite "Exp_increq_1") nil nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Fsubnormal?") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (case "-dExp(b) = Fexp(p)") (("1" (expand "abs" -2) (("1" (expand "FtoR" 2) (("1" (case "(vNum(b)-2)*radix ^ Fexp(p) <= Fnum(q) * radix ^ (Fexp(q)) - radix ^ (Fexp(q) - 1)") (("1" (case "Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p) <= (vNum(b) - 2) * radix ^ Fexp(p)") (("1" (grind-reals) nil nil) ("2" (div-by 1 "radix ^ (Fexp(p))") (("2" (case-replace "(Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p)) / radix ^ (Fexp(p))
                           = Fnum(p)-1") (("1" (grind-reals) nil nil) ("2" (field 1) nil nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (case "(vNum(b) - 2) * radix ^ (Fexp(q)-1) <= Fnum(q) * radix ^ (Fexp(q)) - radix ^ (Fexp(q) - 1)") (("1" (case "(vNum(b) - 2) * radix ^ Fexp(p) <=(vNum(b) - 2) * radix ^ (Fexp(q) - 1)") (("1" (grind-reals) nil nil) ("2" (div-by 1 "vNum(b) - 2") (("2" (rewrite "Exp_increq_1") nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "expt_div" :dir rl) (("2" (rewrite "expt_x1") (("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil) ("4" (case " Fexp(p)=-dExp(b)") (("1" (case " Fexp(q)=-dExp(b)") (("1" (hide 1 2 -3) (("1" (expand* "FtoR") (("1" (replace -2) (("1" (replace -1) (("1" (hide -4) (("1" (div-by -6 "radix ^ -dExp(b)") (("1" (div-by 1 "radix ^ -dExp(b)") (("1" (case-replace "(Fnum(p) * radix ^ -dExp(b) - radix ^ -dExp(b)) / radix ^ -dExp(b)
                       = Fnum(p)-1") (("1" (case-replace "(Fnum(q) * radix ^ -dExp(b) - radix ^ -dExp(b)) / radix ^ -dExp(b)
                         = Fnum(q)-1") (("1" (grind-reals) nil nil) ("2" (field 1) nil nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil) ("2" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (propax) nil nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ("5" (case "Fexp(p) = -dExp(b)") (("1" (hide 1) (("1" (split-ineq -2) (("1" (case "Fexp(p) < Fexp(q)") (("1" (hide 1) (("1" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (expand "abs" -1) (("1" (expand "Fcanonic?" -8) (("1" (expand* "Fnormal?" "Fsubnormal?") (("1" (flatten) (("1" (rewrite "abs_mult" -9) (("1" (expand "abs" -9) (("1" (hide -4) (("1" (expand "FtoR" 2) (("1" (case "(vNum(b)-2)* radix ^ Fexp(p) <= Fnum(q) * radix ^ (Fexp(q)) - radix ^ Fexp(q)") (("1" (case "Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p) <= (vNum(b) - 2) * radix ^ Fexp(p)") (("1" (assert) nil nil) ("2" (div-by 1 "radix ^ Fexp(p)") (("2" (case-replace "(Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p)) / radix ^ Fexp(p)
                             = Fnum(p)-1") (("1" (grind-reals) nil nil) ("2" (field 1) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (case "(vNum(b) - 2) * radix ^ (Fexp(q)-1) <= Fnum(q) * radix ^ (Fexp(q)) - radix ^ Fexp(q)") (("1" (case "(vNum(b) - 2) * radix ^ Fexp(p) <= (vNum(b) - 2) * radix ^ (Fexp(q) - 1)") (("1" (assert) nil nil) ("2" (div-by 1 "vNum(b) - 2") (("2" (rewrite "Exp_increq_1") nil nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "expt_div" :dir rl) (("2" (rewrite "expt_x1") (("2" (div-by 1 "radix ^ Fexp(q)") (("2" (case-replace "(vNum(b) - 2) * (radix ^ Fexp(q) / radix) / radix ^ Fexp(q)
                             = (vNum(b) - 2) / radix") (("1" (case-replace "(Fnum(q) * radix ^ (Fexp(q)) - radix ^ Fexp(q)) / radix ^ Fexp(q)
                               = Fnum(q)-1") (("1" (grind-reals) (("1" (case "vNum(b)/radix +1 <= Fnum(q)") (("1" (hide-all-but (-1 1)) (("1" (lemma "radix_less_vNum") (("1" (inst -1 "b") (("1" (mult-by -2 "radix") (("1" (field -1) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "radix_div_vNum") (("2" (inst -1 "b") (("2" (rewrite "div_simple" :dir rl) (("2" (hide -2) (("2" (skosimp*) (("2" (case "k!1 < Fnum(q)") (("1" (grind-reals) (("1" (field 1) nil nil)) nil) ("2" (grind-reals) (("2" (div-by -10 "radix") (("2" (div-by 4 "radix") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (field 1) nil nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ("6" (split-ineq -1) (("1" (expand "FtoR" -8) (("1" (expand "Fcanonic?" -6) (("1" (expand* "Fnormal?" "Fsubnormal?") (("1" (flatten) (("1" (rewrite "abs_mult" -7) (("1" (expand "abs" -7) (("1" (replaces -1 -9) (("1" (expand* "Fcanonic?" "Fnormal?" "Fsubnormal?") (("1" (flatten) (("1" (rewrite "abs_mult" -5) (("1" (expand "abs" -5) (("1" (div-by -9 "radix ^ (Fexp(q))") (("1" (mult-by -9 "radix") (("1" (rewrite -10) (("1" (hide-all-but (-1 -6 1)) (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case " Fexp(p) < Fexp(q)") (("1" (hide -2 1) (("1" (hide 1 -7) (("1" (expand "FtoR") (("1" (case "(vNum(b)-2)*radix ^ Fexp(p) <= Fnum(q) * radix ^ (Fexp(q)) - radix ^ (Fexp(q) - 1)") (("1" (case "Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p) <=(vNum(b) - 2) * radix ^ Fexp(p)") (("1" (assert) nil nil) ("2" (div-by 1 "radix ^ Fexp(p)") (("2" (case-replace "(Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p)) / radix ^ Fexp(p)=Fnum(p)-1") (("1" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil) ("2" (field) nil nil)) nil)) nil)) nil) ("2" (case "(vNum(b) - 2) * radix ^ (Fexp(q)-1) <=
                                    Fnum(q) * radix ^ (Fexp(q)) - radix ^ (Fexp(q) - 1)") (("1" (case "(vNum(b) - 2) * radix ^ Fexp(p) <= (vNum(b) - 2) * radix ^ (Fexp(q) - 1)") (("1" (assert) nil nil) ("2" (div-by 1 "(vNum(b) - 2)") (("1" (rewrite "Exp_increq_1") nil nil) ("2" (hide-all-but 1) (("2" (lemma "radix_less_vNum") (("2" (inst -1 "b") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (rewrite "expt_div" :dir rl) (("2" (rewrite "expt_x1") (("2" (div-by 1 "radix ^ Fexp(q)") (("2" (case-replace "(vNum(b) - 2) * (radix ^ Fexp(q) / radix) / radix ^ Fexp(q)
                            = (vNum(b) - 2)/radix") (("1" (case-replace "(Fnum(q) * radix ^ (Fexp(q)) - radix ^ Fexp(q) / radix) /
                                    radix ^ Fexp(q)=Fnum(q) -1/radix") (("1" (field 1) nil nil) ("2" (field 1) nil nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil) ("7" (expand* "FtoR") (("7" (case-replace "Fexp(q)=-dExp(b)") (("1" (case-replace "Fexp(p)=-dExp(b)") (("1" (grind-reals) nil nil) ("2" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (propax) nil nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ("2" (case "Fbounded?(b)(q)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil) ("8" (split-ineq -1) (("8" (case "Fexp(p) < Fexp(q)") (("1" (hide -2 1) (("1" (expand "FtoR" 3) (("1" (case "(vNum(b)-2)*radix ^ Fexp(p)<= Fnum(q) * radix ^ (Fexp(q)) - radix ^ Fexp(q)") (("1" (case "Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p) <= (vNum(b) - 2) * radix ^ Fexp(p)") (("1" (assert) nil nil) ("2" (div-by 1 "radix ^ Fexp(p)") (("2" (case-replace "(Fnum(p) * radix ^ (Fexp(p)) - radix ^ Fexp(p)) / radix ^ Fexp(p)=Fnum(p)-1") (("1" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (expand "abs" -1) (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil) ("2" (field) nil nil)) nil)) nil)) nil) ("2" (case "(vNum(b) - 2) * radix ^ (Fexp(q)-1) <=
                                  Fnum(q) * radix ^ (Fexp(q)) - radix ^ Fexp(q)") (("1" (case "(vNum(b) - 2) * radix ^ Fexp(p) <= (vNum(b) - 2) * radix ^ (Fexp(q) - 1)") (("1" (assert) nil nil) ("2" (div-by 1 "vNum(b) - 2") (("1" (rewrite "Exp_increq_1") nil nil) ("2" (lemma "radix_less_vNum") (("2" (inst -1 "b") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 5) (("2" (rewrite "expt_div" :dir rl) (("2" (rewrite "expt_x1") (("2" (div-by 1 "radix ^ Fexp(q)") (("2" (case-replace "(vNum(b) - 2) * (radix ^ Fexp(q) / radix) / radix ^ Fexp(q)
                          = (vNum(b) - 2)/radix") (("1" (case-replace "(Fnum(q) * radix ^ (Fexp(q)) - radix ^ Fexp(q)) / radix ^ Fexp(q)
                           = Fnum(q)-1") (("1" (case "vNum(b)/radix +1 <= Fnum(q)") (("1" (mult-by -1 "radix") (("1" (mult-by 1 "radix") (("1" (field) nil nil)) nil)) nil) ("2" (lemma "radix_div_vNum") (("2" (inst -1 "b") (("2" (rewrite "div_simple" :dir rl) (("2" (skosimp*) (("2" (case "k!1 < Fnum(q)") (("1" (grind-reals) nil nil) ("2" (hide -2 -3 2 3) (("2" (expand "Fcanonic?" -6) (("2" (expand* "Fnormal?" "Fsubnormal?") (("2" (split) (("1" (flatten) (("1" (rewrite "abs_mult" -2) (("1" (expand "abs" -2) (("1" (hide-all-but (-2 -3 1 3)) (("1" (rewrite -2) (("1" (div-by -1 "radix") (("1" (div-by 2 "radix") (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (field 1) nil nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "Lexico") (("2" (inst -1 "b" "p" "q") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (case "0<FtoR(q)") (("1" (expand "FtoR" -1) (("1" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil) ("2" (expand "FtoR" -3) (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "FpredCanonic") nil nil)) nil) ("2" (rewrite "FpredCanonic") nil nil)) nil) ("2" (rewrite "FpredDiff" :dir rl) (("2" (assert) nil nil)) nil) ("3" (rewrite "FcanonicBounded") (("3" (rewrite "FpredCanonic") nil nil)) nil)) nil) ("2" (rewrite "FpredDiff" :dir rl) (("2" (assert) nil nil)) nil) ("3" (rewrite "FcanonicBounded") (("3" (rewrite "FpredCanonic") nil nil)) nil)) nil)) nil) nil shostak)) (FpredLe_aux2 0 (FpredLe_aux2-1 nil 3319461303 ("" (skeep) (("" (case-replace "FtoR(Fsucc(b)(p))=FtoR(p)+Fulp(b)(p)") (("1" (case-replace "FtoR(Fsucc(b)(q))=FtoR(q)+Fulp(b)(q)") (("1" (case "Fulp(b)(p) <=Fulp(b)(q)") (("1" (grind-reals) nil nil) ("2" (hide -1 -2 2) (("2" (rewrite "FulpCanonic") (("2" (rewrite "FulpCanonic") (("2" (rewrite "Exp_increq_1") (("2" (lemma "Lexico") (("2" (inst -1 "b" "p" "q") (("2" (rewrite -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FsuccDiff" :dir rl) (("2" (assert) nil nil)) nil) ("3" (rewrite "FcanonicBounded") nil nil)) nil) ("2" (rewrite "FsuccDiff" :dir rl) (("2" (assert) nil nil)) nil) ("3" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ((real_plus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (FtoR const-decl "real" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (Fsucc const-decl "float" float nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (Fulp const-decl "real" float nil) (FcanonicBounded formula-decl nil float nil) (FsuccDiff formula-decl nil float nil) (real_minus_real_is_real application-judgement "real" reals nil) (<= const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FulpCanonic formula-decl nil float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (Exp_increq_1 formula-decl nil float nil) (Lexico formula-decl nil float nil) (Fulp_posreal_j application-judgement "posreal" float nil)) shostak)) (FpredLe 0 (FpredLe-1 nil 3319368741 ("" (skeep) (("" (split) (("1" (skosimp) (("1" (case "0 < FtoR(p)") (("1" (rewrite "FpredLe_aux") nil nil) ("2" (flip-ineq 1) (("2" (case "FtoR(q)<=0") (("1" (neg-formula 1) (("1" (rewrite "FoppCorrect" :dir rl) (("1" (rewrite "FoppCorrect" :dir rl) (("1" (rewrite "FsuccFoppFpred" :dir rl) (("1" (rewrite "FsuccFoppFpred" :dir rl) (("1" (rewrite "FpredLe_aux2") (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FoppCorrect") (("2" (grind-reals) nil nil)) nil) ("3" (lemma "FcanonicOpp") (("3" (inst -1 "b" "p") (("3" (assert) nil nil)) nil)) nil) ("4" (lemma "FcanonicOpp") (("4" (inst -1 "b" "q") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (case "0 <= FtoR(Fpred(b)(q))") (("1" (grind-reals) (("1" (case "FtoR(Fpred(b)(p)) <= FtoR(p)") (("1" (assert) nil nil) ("2" (lemma "FpredLt") (("2" (inst -1 "b" "p") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FpredPos") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp) (("2" (case "0 <= FtoR(Fpred(b)(p))") (("1" (case-replace "FtoR(q)=FtoR(Fsucc(b)(Fpred(b)(q)))") (("1" (case-replace "FtoR(p)=FtoR(Fsucc(b)(Fpred(b)(p)))") (("1" (rewrite "FpredLe_aux2") (("1" (rewrite "FpredCanonic") nil nil) ("2" (rewrite "FpredCanonic") nil nil)) nil) ("2" (rewrite "FsuccFpred") nil nil)) nil) ("2" (rewrite "FsuccFpred") nil nil)) nil) ("2" (flip-ineq 1) (("2" (case "0 <= FtoR(Fpred(b)(q))") (("1" (case "FtoR(p) <= 0") (("1" (case "FtoR(Fpred(b)(q))<= FtoR(q)") (("1" (assert) nil nil) ("2" (lemma "FpredLt") (("2" (inst -1 "b" "q") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flip-ineq -2) (("2" (flip-ineq 2) (("2" (rewrite "FpredPos") nil nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (neg-formula 1) (("2" (rewrite "FoppCorrect" :dir rl) (("2" (rewrite "FoppCorrect" :dir rl) (("2" (case-replace "Fopp(q)=Fpred(b)(Fsucc(b)(Fopp(q)))") (("1" (case-replace "Fopp(p)=Fpred(b)(Fsucc(b)(Fopp(p)))") (("1" (rewrite "FsuccFoppFpred") (("1" (rewrite "FsuccFoppFpred") (("1" (lemma "FpredLe_aux") (("1" (inst -1 "b" "Fopp(Fpred(b)(q))" "Fopp(Fpred(b)(p))") (("1" (rewrite -1) (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FoppCorrect") (("2" (grind-reals) nil nil)) nil) ("3" (lemma "FcanonicOpp") (("3" (inst -1 "b" "Fpred(b)(p)") (("3" (flatten) (("3" (rewrite -1) (("3" (rewrite "FpredCanonic") nil nil)) nil)) nil)) nil)) nil) ("4" (lemma "FcanonicOpp") (("4" (inst -1 "b" "Fpred(b)(q)") (("4" (flatten) (("4" (rewrite -1) (("4" (rewrite "FpredCanonic") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FpredFsucc") (("2" (lemma "FcanonicOpp") (("2" (inst -1 "b" "p") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FpredFsucc") (("2" (lemma "FcanonicOpp") (("2" (inst -1 "b" "q") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FtoR const-decl "real" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (FpredLe_aux formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (<= const-decl "bool" reals nil) (FoppCorrect formula-decl nil float nil) (FsuccFoppFpred formula-decl nil float nil) (Fopp const-decl "float" float nil) (FpredLe_aux2 formula-decl nil float nil) (FcanonicOpp formula-decl nil float nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (negreal nonempty-type-eq-decl nil real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Fpred const-decl "float" float nil) (both_sides_times_neg_le1 formula-decl nil real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (mult_neg formula-decl nil extra_tegies nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (FpredLt formula-decl nil float nil) (FpredPos formula-decl nil float nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (>= const-decl "bool" reals nil) (FpredCanonic formula-decl nil float nil) (FsuccFpred formula-decl nil float nil) (Fsucc const-decl "float" float nil) (= const-decl "[T, T -> boolean]" equalities nil) (FpredFsucc formula-decl nil float nil)) shostak)) (FsuccLe 0 (FsuccLe-1 nil 3319371174 ("" (skeep) (("" (lemma "FpredLe") (("" (inst -1 "b" "Fsucc(b)(p)" "Fsucc(b)(q)") (("" (rewrite "FpredFsucc") (("" (rewrite "FpredFsucc") (("" (rewrite -1) (("1" (assert) nil nil) ("2" (rewrite "FsuccCanonic") nil nil) ("3" (rewrite "FsuccCanonic") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FpredLe formula-decl nil float nil) (FpredFsucc formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FsuccCanonic formula-decl nil float nil) (Fsucc const-decl "float" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (FpredProp_aux 0 (FpredProp_aux-2 "" 3790102806 ("" (skeep) (("" (case "Fexp(p) = Fexp(q) OR Fexp(p) < Fexp(q)") (("1" (split) (("1" (expand "FtoR" -5) (("1" (case-replace "Fexp(p) = Fexp(q)") (("1" (div-by -5 "radix ^ Fexp(q)") (("1" (case "(Fnum(q)-1)*radix^(Fexp(q)) <= FtoR(Fpred(b)(q))") (("1" (case " FtoR(p) <= (Fnum(q) - 1) * radix ^ (Fexp(q))") (("1" (grind-reals) nil nil) ("2" (expand "FtoR" 1) (("2" (replaces -2 1) (("2" (div-by 1 "radix ^ Fexp(q)") (("2" (case-replace "(Fnum(q) * radix ^ (Fexp(q)) - radix ^ (Fexp(q))) / radix ^ Fexp(q)=Fnum(q)-1") (("1" (grind-reals) nil nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "0<Fnum(q)") (("1" (expand "Fpred") (("1" (grind-reals) (("1" (expand "FtoR") (("1" (rewrite "expt_div" :dir rl) (("1" (rewrite -2 :dir rl) (("1" (grind-reals) (("1" (div-by 1 "radix ^ Fexp(q)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "FtoR") (("2" (grind-reals) nil nil)) nil) ("3" (expand "FtoR") (("3" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (case "0 <= Fnum(p)") (("1" (grind-reals) nil nil) ("2" (expand "FtoR" -4) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("3" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (case "(vNum(b)-1)*radix^(Fexp(q)-1) <= FtoR(Fpred(b)(q))") (("1" (case "FtoR(p) <= (vNum(b) - 1) * radix ^ (Fexp(q) - 1)") (("1" (grind-reals) nil nil) ("2" (hide -1 -4 -6 2) (("2" (expand "FtoR" 1) (("2" (case "Fnum(p) * radix ^ (Fexp(p)) <= Fnum(p) * radix ^ (Fexp(q)-1)") (("1" (case "Fnum(p) * radix ^ (Fexp(q) - 1) <= vNum(b) * radix ^ (Fexp(q) - 1) - radix ^ (Fexp(q) - 1)") (("1" (grind-reals) nil nil) ("2" (hide 2 -1 -4) (("2" (div-by 1 "radix ^ (Fexp(q) - 1)") (("2" (case-replace "(vNum(b) * radix ^ (Fexp(q) - 1) - radix ^ (Fexp(q) - 1)) /
        radix ^ (Fexp(q) - 1)=vNum(b)-1") (("1" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (hide -2 -3 -4 -5) (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil) ("2" (hide-all-but 1) (("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (case "0 <= Fnum(p)") (("1" (cancel-by 1 "Fnum(p)") (("1" (rewrite "Exp_increq_1") nil nil)) nil) ("2" (hide -1 2) (("2" (expand "FtoR") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "0<Fnum(q)") (("1" (expand* "FtoR" "Fpred") (("1" (grind-reals) (("1" (hide 2) (("1" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (propax) nil nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ("2" (rewrite "expt_div" :dir rl) (("2" (div-by 2 "radix ^ Fexp(q)") (("2" (case-replace "(vNum(b) * (radix ^ Fexp(q) / radix) - radix ^ Fexp(q) / radix) /
       radix ^ Fexp(q)=(vNum(b)-1)/radix") (("1" (case-replace "(Fnum(q) * radix ^ Fexp(q) - radix ^ Fexp(q)) / radix ^ Fexp(q)
= Fnum(q)-1") (("1" (hide -1 -2) (("1" (expand "Fcanonic?" -4) (("1" (split) (("1" (expand "Fnormal?") (("1" (flatten) (("1" (rewrite "abs_mult" -2) (("1" (expand "abs" -2) (("1" (hide -1 -4 -5 -6 -7) (("1" (case "vNum(b) < radix * Fnum(q)") (("1" (case "integer_pred(vNum(b) / radix)") (("1" (div-by -2 "radix") (("1" (case "(vNum(b) - 1) / radix <= vNum(b) / radix") (("1" (case "vNum(b) / radix <= Fnum(q) - 1") (("1" (grind-reals) nil nil) ("2" (hide -1 -4 -5 2 3) (("2" (lemma "div_simple") (("2" (case "(EXISTS (k:int): vNum(b) = k * radix)") (("1" (skosimp*) (("1" (case-replace "vNum(b) / radix=k!1") (("1" (grind-reals) nil nil) ("2" (grind-reals) nil nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil) ("2" (grind-reals) (("2" (rewrite "radix_div_vNum") nil nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Fsubnormal?") (("2" (flatten) (("2" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?" -1) (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (field) nil nil)) nil) ("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (mult-by 1 "radix ^ (Fexp(q))") (("2" (expand "FtoR") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("3" (grind-reals) nil nil)) nil)) nil) ("2" (case "Fexp(p) <= Fexp(q)") (("1" (grind-reals) nil nil) ("2" (hide 2 3) (("2" (lemma "Lexico") (("2" (inst -1 "b" "p" "q") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (vNum const-decl "posnat" float nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (FcanonicBounded formula-decl nil float nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (Fbounded? const-decl "bool" float nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (Exp_increq_1 formula-decl nil float nil) (pos_div_gt formula-decl nil real_props nil) (even_times_int_is_even application-judgement "even_int" integers nil) (div_mult_pos_ge1 formula-decl nil real_props nil) (zero_times1 formula-decl nil real_props nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (div_223 skolem-const-decl "int" float nil) (int_plus_int_is_int application-judgement "int" integers nil) (div_distributes_minus formula-decl nil real_props nil) (div_div2 formula-decl nil real_props nil) (cross_mult formula-decl nil real_props nil) (Fcanonic? const-decl "bool" float nil) (Fsubnormal? const-decl "bool" float nil) (Fnormal? const-decl "bool" float nil) (abs_mult formula-decl nil real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (div_cancel3 formula-decl nil real_props nil) (nzint nonempty-type-eq-decl nil integers nil) (div_simple formula-decl nil integer_props nil) (le_div_le_pos formula-decl nil real_props nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (radix_div_vNum formula-decl nil float nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (q skolem-const-decl "float" float nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (FtoR const-decl "real" float nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (le_minus_le formula-decl nil real_props nil) (div_simp formula-decl nil real_props nil) (times_div_cancel1 formula-decl nil extra_real_props nil) (times_div1 formula-decl nil real_props nil) (div_cancel2 formula-decl nil real_props nil) (div_mult_pos_le1 formula-decl nil real_props nil) (both_sides_minus_le2 formula-decl nil real_props nil) (pos_times_le formula-decl nil real_props nil) (expt_x1 formula-decl nil exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (expt_div formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (div_cancel4 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Fpred const-decl "float" float nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (Lexico formula-decl nil float nil)) shostak) (FpredProp_aux-1 nil 3319301588 ("" (skeep) (("" (case "Fexp(p) = Fexp(q) OR Fexp(p) < Fexp(q)") (("1" (split) (("1" (expand "FtoR" -5) (("1" (case-replace "Fexp(p) = Fexp(q)") (("1" (div-by -5 "radix ^ Fexp(q)") (("1" (case "(Fnum(q)-1)*radix^(Fexp(q)) <= FtoR(Fpred(b)(q))") (("1" (case " FtoR(p) <= (Fnum(q) - 1) * radix ^ (Fexp(q))") (("1" (grind-reals) nil nil) ("2" (expand "FtoR" 1) (("2" (replaces -2 1) (("2" (div-by 1 "radix ^ Fexp(q)") (("2" (case-replace "(Fnum(q) * radix ^ (Fexp(q)) - radix ^ (Fexp(q))) / radix ^ Fexp(q)=Fnum(q)-1") (("1" (grind-reals) nil nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "0<Fnum(q)") (("1" (expand "Fpred") (("1" (grind-reals) (("1" (expand "FtoR") (("1" (rewrite "expt_div" :dir rl) (("1" (rewrite "expt_x1") (("1" (rewrite -2 :dir rl) (("1" (grind-reals) (("1" (div-by 1 "radix ^ Fexp(q)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "FtoR") (("2" (grind-reals) nil nil)) nil) ("3" (expand "FtoR") (("3" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (case "0 <= Fnum(p)") (("1" (grind-reals) nil nil) ("2" (expand "FtoR" -4) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("3" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (case "(vNum(b)-1)*radix^(Fexp(q)-1) <= FtoR(Fpred(b)(q))") (("1" (case "FtoR(p) <= (vNum(b) - 1) * radix ^ (Fexp(q) - 1)") (("1" (grind-reals) nil nil) ("2" (hide -1 -4 -6 2) (("2" (expand "FtoR" 1) (("2" (case "Fnum(p) * radix ^ (Fexp(p)) <= Fnum(p) * radix ^ (Fexp(q)-1)") (("1" (case "Fnum(p) * radix ^ (Fexp(q) - 1) <= vNum(b) * radix ^ (Fexp(q) - 1) - radix ^ (Fexp(q) - 1)") (("1" (grind-reals) nil nil) ("2" (hide 2 -1 -4) (("2" (div-by 1 "radix ^ (Fexp(q) - 1)") (("2" (case-replace "(vNum(b) * radix ^ (Fexp(q) - 1) - radix ^ (Fexp(q) - 1)) /
        radix ^ (Fexp(q) - 1)=vNum(b)-1") (("1" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (hide -2 -3 -4 -5) (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil) ("2" (hide-all-but 1) (("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (case "0 <= Fnum(p)") (("1" (cancel-by 1 "Fnum(p)") (("1" (rewrite "Exp_increq_1") nil nil)) nil) ("2" (hide -1 2) (("2" (expand "FtoR") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "0<Fnum(q)") (("1" (expand* "FtoR" "Fpred") (("1" (grind-reals) (("1" (hide 2) (("1" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?") (("1" (propax) nil nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ("2" (rewrite "expt_div" :dir rl) (("2" (rewrite "expt_x1") (("2" (div-by 2 "radix ^ Fexp(q)") (("2" (case-replace "(vNum(b) * (radix ^ Fexp(q) / radix) - radix ^ Fexp(q) / radix) /
       radix ^ Fexp(q)=(vNum(b)-1)/radix") (("1" (case-replace "(Fnum(q) * radix ^ Fexp(q) - radix ^ Fexp(q)) / radix ^ Fexp(q)
= Fnum(q)-1") (("1" (hide -1 -2) (("1" (expand "Fcanonic?" -4) (("1" (split) (("1" (expand "Fnormal?") (("1" (flatten) (("1" (rewrite "abs_mult" -2) (("1" (expand "abs" -2) (("1" (hide -1 -4 -5 -6 -7) (("1" (case "vNum(b) < radix * Fnum(q)") (("1" (case "integer_pred(vNum(b) / radix)") (("1" (div-by -2 "radix") (("1" (case "(vNum(b) - 1) / radix <= vNum(b) / radix") (("1" (case "vNum(b) / radix <= Fnum(q) - 1") (("1" (grind-reals) nil nil) ("2" (hide -1 -4 -5 2 3) (("2" (lemma "div_simple") (("2" (case "(EXISTS (k:int): vNum(b) = k * radix)") (("1" (skosimp*) (("1" (case-replace "vNum(b) / radix=k!1") (("1" (grind-reals) nil nil) ("2" (grind-reals) nil nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil) ("2" (grind-reals) (("2" (rewrite "radix_div_vNum") nil nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Fsubnormal?") (("2" (flatten) (("2" (case "Fbounded?(b)(p)") (("1" (expand "Fbounded?" -1) (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (field) nil nil)) nil) ("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (mult-by 1 "radix ^ (Fexp(q))") (("2" (expand "FtoR") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("3" (grind-reals) nil nil)) nil)) nil) ("2" (case "Fexp(p) <= Fexp(q)") (("1" (grind-reals) nil nil) ("2" (hide 2 3) (("2" (lemma "Lexico") (("2" (inst -1 "b" "p" "q") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (FpredProp 0 (FpredProp-1 nil 3319214315 ("" (skeep) (("" (case "0 <= FtoR(p)") (("1" (rewrite "FpredProp_aux") nil nil) ("2" (flip-ineq 1) (("2" (case "0 < FtoR(q)") (("1" (case "0 <=  FtoR(Fpred(b)(q))") (("1" (grind-reals) nil nil) ("2" (rewrite "FpredPos") nil nil)) nil) ("2" (flip-ineq 1) (("2" (lemma "FsuccLe") (("2" (inst -1 "b" "p" "Fpred(b)(q)") (("2" (case "FtoR(Fsucc(b)(p)) <= FtoR(Fsucc(b)(Fpred(b)(q)))") (("1" (assert) (("1" (rewrite "FpredCanonic") nil nil)) nil) ("2" (hide -1 2) (("2" (rewrite "FsuccFpred") (("2" (neg-formula 1) (("2" (rewrite "FoppCorrect" :dir rl) (("2" (rewrite "FoppCorrect" :dir rl) (("2" (rewrite "FpredFoppFsucc" :dir rl) (("2" (rewrite "FpredProp_aux") (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "FoppCorrect") (("2" (assert) nil nil)) nil) ("3" (lemma "FcanonicOpp") (("3" (inst -1 "b" "p") (("3" (assert) nil nil)) nil)) nil) ("4" (lemma "FcanonicOpp") (("4" (inst -1 "b" "q") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FtoR const-decl "real" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (FpredProp_aux formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (< const-decl "bool" reals nil) (FpredPos formula-decl nil float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Fpred const-decl "float" float nil) (FsuccLe formula-decl nil float nil) (Fsucc const-decl "float" float nil) (FpredCanonic formula-decl nil float nil) (FsuccFpred formula-decl nil float nil) (FoppCorrect formula-decl nil float nil) (FpredFoppFsucc formula-decl nil float nil) (FcanonicOpp formula-decl nil float nil) (Fopp const-decl "float" float nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (negreal nonempty-type-eq-decl nil real_types nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_neg_le1 formula-decl nil real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (mult_neg formula-decl nil extra_tegies nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (>= const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil)) shostak)) (FsuccLt 0 (FsuccLt-2 nil 3566430744 ("" (skeep) (("" (neg-formula 1) (("" (rewrite "FoppCorrect" :dir rl) (("" (rewrite "FoppCorrect" :dir rl) (("" (rewrite "FpredFoppFsucc" :dir rl) (("" (rewrite "FpredLt") nil nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (mult_neg formula-decl nil extra_tegies nil) (minus_real_is_real application-judgement "real" reals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (both_sides_times_neg_ge1_imp formula-decl nil extra_real_props nil) (Fsucc const-decl "float" float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (FtoR const-decl "real" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nonpos_real nonempty-type-eq-decl nil real_types nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (Fopp const-decl "float" float nil) (FpredLt formula-decl nil float nil) (FpredFoppFsucc formula-decl nil float nil) (FoppCorrect formula-decl nil float nil)) nil) (FsuccLt-1 nil 3319467246 ("" (skeep) (("" (mult-by 1 "-1" -) (("" (field) (("" (rewrite "FoppCorrect" :dir rl) (("" (rewrite "FoppCorrect" :dir rl) (("" (rewrite "FpredFoppFsucc" :dir rl) (("" (rewrite "FpredLt") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (FsuccProp 0 (FsuccProp-1 nil 3319467325 ("" (skeep) (("" (case "q=Fpred(b)(Fsucc(b)(q))") (("1" (replace -1 1) (("1" (rewrite "FpredProp") (("1" (hide 2) (("1" (flip-ineq 1) (("1" (flip-ineq -5) (("1" (lemma "FsuccLe") (("1" (inst -1 "b" "q" "p") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FsuccCanonic") nil nil) ("3" (rewrite "FsuccCanonic") nil nil)) nil)) nil) ("2" (rewrite "FpredFsucc") nil nil)) nil)) nil) ((Fsucc const-decl "float" float nil) (Fpred const-decl "float" float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (FpredProp formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (FtoR const-decl "real" float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (FsuccLe formula-decl nil float nil) (FsuccCanonic formula-decl nil float nil) (FpredFsucc formula-decl nil float nil)) shostak)) (FsuccZleEq_aux 0 (FsuccZleEq_aux-1 nil 3319976732 ("" (skeep) (("" (assert) nil nil)) nil) ((int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (FsuccZleEq 0 (FsuccZleEq-2 "" 3790102812 ("" (skeep) (("" (expand "Fsucc") (("" (grind-reals) (("1" (expand "FtoR") (("1" (div-by 1 "radix ^ (Fexp(p))") (("1" (div-by -1 "radix ^ (Fexp(p))") (("1" (div-by -3 "radix ^ (Fexp(p))") (("1" (rewrite "expt_plus") (("1" (case-replace " Fnum(q) * radix ^ (Fexp(q)) / radix ^ (Fexp(p))= Fnum(q) * radix ^ (Fexp(q)-Fexp(p))") (("1" (hide -1) (("1" (case-replace " vNum(b) / radix * (radix * radix ^ Fexp(p)) / radix ^ (Fexp(p))=vNum(b)") (("1" (hide -1) (("1" (copy -3) (("1" (rewrite -3) (("1" (rewrite "FsuccZleEq_aux") (("1" (lemma "int_expt") (("1" (inst -1 "Fexp(q) - Fexp(p)" "radix") (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (field 1) nil nil)) nil)) nil) ("2" (rewrite "expt_div" :dir rl) (("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (expand "FtoR") (("2" (rewrites -2) (("2" (div-by -1 "radix ^ (Fexp(p))") (("2" (div-by -3 "radix ^ (Fexp(p))") (("2" (div-by 1 "radix ^ (Fexp(p))") (("2" (case-replace "Fnum(q) * radix ^ (Fexp(q)) / radix ^ (Fexp(p))=Fnum(q) * radix ^ (Fexp(q)-Fexp(p))") (("1" (hide -1) (("1" (rewrite "expt_div" :dir rl :subst ("j" "1")) (("1" (case-replace "-(vNum(b) - 1) * (radix ^ Fexp(p) / radix) / radix ^ (Fexp(p))=(-vNum(b)+1)/radix") (("1" (hide -1) (("1" (field -3) (("1" (rewrite "FsuccZleEq_aux") (("1" (expand "^") (("1" (propax) nil nil)) nil) ("2" (mult-by 1 "radix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil) ("2" (rewrite "expt_div" :dir rl) (("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 1 2) (("3" (expand "FtoR") (("3" (div-by 1 "radix ^ (Fexp(p))") (("3" (div-by -1 "radix ^ (Fexp(p))") (("3" (div-by -2 "radix ^ (Fexp(p))") (("3" (case-replace " Fnum(q) * radix ^ (Fexp(q)) / radix ^ (Fexp(p))=Fnum(q) * radix ^ (Fexp(q)-Fexp(p))") (("1" (hide -1) (("1" (case-replace "(radix ^ Fexp(p) + Fnum(p) * radix ^ Fexp(p)) / radix ^ (Fexp(p))=
                                 Fnum(p)+1") (("1" (hide -1) (("1" (rewrite "FsuccZleEq_aux") (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (field 1) nil nil)) nil)) nil) ("2" (rewrite "expt_div" :dir rl) (("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 1 2) (("4" (expand "FtoR") (("4" (div-by 1 "radix ^ (Fexp(p))") (("4" (div-by -1 "radix ^ (Fexp(p))") (("4" (div-by -2 "radix ^ (Fexp(p))") (("4" (case-replace "(radix ^ Fexp(p) + Fnum(p) * radix ^ Fexp(p)) / radix ^ (Fexp(p))=
                       Fnum(p)+1") (("1" (case-replace " Fnum(q) * radix ^ (Fexp(q)) / radix ^ (Fexp(p))=Fnum(q) * radix ^ (Fexp(q)-Fexp(p))") (("1" (hide -1 -2) (("1" (rewrite "FsuccZleEq_aux") (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (rewrite "expt_div" :dir rl) (("2" (field 1) nil nil)) nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (Fsucc const-decl "float" float nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (- const-decl "[numfield -> numfield]" number_fields nil) (cross_mult formula-decl nil real_props nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (< const-decl "bool" reals nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (FtoR const-decl "real" float nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_plus formula-decl nil exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (expt_x1 formula-decl nil exponentiation nil) (expt_div formula-decl nil exponentiation nil) (times_div1 formula-decl nil real_props nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (times_div2 formula-decl nil real_props nil) (div_div2 formula-decl nil real_props nil) (div_cancel3 formula-decl nil real_props nil) (int_expt judgement-tcc nil exponentiation nil) (FsuccZleEq_aux formula-decl nil float nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (vNum const-decl "posnat" float nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (/= const-decl "boolean" notequal nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (float type-eq-decl nil float nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (both_sides_div1 formula-decl nil real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (div_cancel4 formula-decl nil real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak) (FsuccZleEq-1 nil 3319973480 ("" (skeep) (("" (expand "Fsucc") (("" (grind-reals) (("1" (expand "FtoR") (("1" (div-by 1 "radix ^ (Fexp(p))") (("1" (div-by -1 "radix ^ (Fexp(p))") (("1" (div-by -3 "radix ^ (Fexp(p))") (("1" (rewrite "expt_plus") (("1" (case-replace " Fnum(q) * radix ^ (Fexp(q)) / radix ^ (Fexp(p))= Fnum(q) * radix ^ (Fexp(q)-Fexp(p))") (("1" (hide -1) (("1" (case-replace " vNum(b) / radix * (radix * radix ^ Fexp(p)) / radix ^ (Fexp(p))=vNum(b)") (("1" (hide -1) (("1" (copy -3) (("1" (rewrite -3) (("1" (rewrite "FsuccZleEq_aux") (("1" (lemma "int_expt") (("1" (inst -1 "Fexp(q) - Fexp(p)" "radix") (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (use "expt_x1") (("2" (replace -1 :hide? t) (("2" (div-by -1 "(radix * radix ^ Fexp(p))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (field 1) nil nil)) nil)) nil) ("2" (rewrite "expt_div" :dir rl) (("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (expand "FtoR") (("2" (rewrites -2) (("2" (div-by -1 "radix ^ (Fexp(p))") (("2" (div-by -3 "radix ^ (Fexp(p))") (("2" (div-by 1 "radix ^ (Fexp(p))") (("2" (case-replace "Fnum(q) * radix ^ (Fexp(q)) / radix ^ (Fexp(p))=Fnum(q) * radix ^ (Fexp(q)-Fexp(p))") (("1" (hide -1) (("1" (rewrite "expt_div" :dir rl :subst ("j" "1")) (("1" (case-replace "-(vNum(b) - 1) * (radix ^ Fexp(p) / radix) / radix ^ (Fexp(p))=(-vNum(b)+1)/radix") (("1" (hide -1) (("1" (field -3) (("1" (rewrite "FsuccZleEq_aux") (("1" (expand "^") (("1" (propax) nil nil)) nil) ("2" (mult-by 1 "radix") (("2" (assert) (("2" (use "expt_x1") (("2" (replace -1 :hide? t) (("2" (div-by -3 "(radix ^ Fexp(p))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil) ("2" (rewrite "expt_div" :dir rl) (("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 1 2) (("3" (expand "FtoR") (("3" (div-by 1 "radix ^ (Fexp(p))") (("3" (div-by -1 "radix ^ (Fexp(p))") (("3" (div-by -2 "radix ^ (Fexp(p))") (("3" (case-replace " Fnum(q) * radix ^ (Fexp(q)) / radix ^ (Fexp(p))=Fnum(q) * radix ^ (Fexp(q)-Fexp(p))") (("1" (hide -1) (("1" (case-replace "(radix ^ Fexp(p) + Fnum(p) * radix ^ Fexp(p)) / radix ^ (Fexp(p))=
                                 Fnum(p)+1") (("1" (hide -1) (("1" (rewrite "FsuccZleEq_aux") (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (field 1) nil nil)) nil)) nil) ("2" (rewrite "expt_div" :dir rl) (("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 1 2) (("4" (expand "FtoR") (("4" (div-by 1 "radix ^ (Fexp(p))") (("4" (div-by -1 "radix ^ (Fexp(p))") (("4" (div-by -2 "radix ^ (Fexp(p))") (("4" (case-replace "(radix ^ Fexp(p) + Fnum(p) * radix ^ Fexp(p)) / radix ^ (Fexp(p))=
                       Fnum(p)+1") (("1" (case-replace " Fnum(q) * radix ^ (Fexp(q)) / radix ^ (Fexp(p))=Fnum(q) * radix ^ (Fexp(q)-Fexp(p))") (("1" (hide -1 -2) (("1" (rewrite "FsuccZleEq_aux") (("1" (expand "^") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (rewrite "expt_div" :dir rl) (("2" (field 1) nil nil)) nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (EvenFsuccOdd_aux_TCC1 0 (EvenFsuccOdd_aux_TCC1-1 nil 3321636413 ("" (skeep) (("" (lemma "radix_div_vNum") (("" (inst?) nil nil)) nil)) nil) ((radix_div_vNum formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil)) nil (EvenFsuccOdd_aux subtype "number_fields./(float.vNum(float.b), float.radix)" "int"))) (EvenFsuccOdd_aux 0 (EvenFsuccOdd_aux-2 "" 3790102814 ("" (skeep) (("" (case "vNum(b)=radix^Prec(b)") (("1" (replace -1) (("1" (lemma "expt_odd") (("1" (inst-cp -1 "Prec(b)-2") (("1" (flatten) (("1" (case-replace "radix ^ Prec(b) / radix=radix ^ (Prec(b) - 2 + 1)") (("1" (assert) (("1" (hide -3) (("1" (lemma "expt_odd") (("1" (inst -1 "Prec(b)-1") (("1" (flatten) (("1" (lemma "even_iff_odd_succ") (("1" (inst -1 "radix ^ Prec(b) - 1") (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "expt_div" :dir rl) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "vNum") (("2" (propax) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ((radix formal-const-decl "above(1)" float nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vNum const-decl "posnat" float nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (expt_odd formula-decl nil float nil) (expt_div formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_x1 formula-decl nil exponentiation nil) (even_iff_odd_succ formula-decl nil naturalnumbers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (b skolem-const-decl "Format" float nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak) (EvenFsuccOdd_aux-1 nil 3319547273 ("" (skeep) (("" (case "vNum(b)=radix^Prec(b)") (("1" (replace -1) (("1" (lemma "expt_odd") (("1" (inst-cp -1 "Prec(b)-2") (("1" (flatten) (("1" (case-replace "radix ^ Prec(b) / radix=radix ^ (Prec(b) - 2 + 1)") (("1" (assert) (("1" (hide -3) (("1" (lemma "expt_odd") (("1" (inst -1 "Prec(b)-1") (("1" (flatten) (("1" (lemma "even_iff_odd_succ") (("1" (inst -1 "radix ^ Prec(b) - 1") (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (rewrite "expt_div" :dir rl) (("2" (rewrite "expt_x1") nil nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "vNum") (("2" (propax) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) nil shostak)) (EvenFsuccOdd 0 (EvenFsuccOdd-1 nil 3319544211 ("" (skeep) (("" (expand "Fsucc") (("" (grind-reals) (("1" (rewrite "EvenFsuccOdd_aux") nil nil) ("2" (rewrite "minus_odd_is_odd") (("2" (hide 2 3) (("2" (lemma "EvenFsuccOdd_aux") (("2" (inst -1 "b") (("2" (lemma "odd_iff_not_even") (("2" (inst -1 "vNum(b) - 1") (("2" (case "NOT even?(vNum(b) - 1)") (("1" (assert) nil nil) ("2" (case "odd?(vNum(b) / radix)") (("1" (case "even?(vNum(b) / radix)") (("1" (hide-all-but (-1 -2)) (("1" (lemma "even_or_odd") (("1" (inst -1 "vNum(b) / radix") (("1" (assert) nil nil) ("2" (lemma "radix_div_vNum") (("2" (inst -1 "b") nil nil)) nil)) nil)) nil)) nil) ("2" (div-by -7 "radix") (("2" (replace -7 -6) (("2" (hide-all-but (-6 1)) (("2" (lemma "minus_even_is_even") (("2" (case "vNum(b) / radix=-(-(vNum(b) / radix))") (("1" (replaces -1 1) (("1" (rewrite -1) (("1" (assert) (("1" (lemma "radix_div_vNum") (("1" (inst -1 "b") (("1" (rewrite "integers.closed_neg") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (lemma "radix_div_vNum") (("3" (inst -1 "b") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "even_iff_odd_succ") (("3" (inst -1 " Fnum(p)") (("3" (assert) nil nil)) nil)) nil) ("4" (lemma "even_iff_odd_succ") (("4" (inst -1 " Fnum(p)") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (Fsucc const-decl "float" float nil) (even_iff_odd_succ formula-decl nil naturalnumbers nil) (minus_odd_is_odd judgement-tcc nil integers nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (odd? const-decl "bool" integers nil) (odd_int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (odd_iff_not_even formula-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (even? const-decl "bool" integers nil) (even_or_odd formula-decl nil naturalnumbers nil) (radix_div_vNum formula-decl nil float nil) (b skolem-const-decl "Format" float nil) (minus_even_is_even judgement-tcc nil integers nil) (div_cancel3 formula-decl nil real_props nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (closed_neg formula-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (even_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (float type-eq-decl nil float nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (both_sides_div1 formula-decl nil real_props nil) (radix formal-const-decl "above(1)" float nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (EvenFsuccOdd_aux formula-decl nil float nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (div_cancel4 formula-decl nil real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (OddFsuccEven_aux_TCC1 0 (OddFsuccEven_aux_TCC1-1 nil 3321636413 ("" (skeep) (("" (lemma "radix_div_vNum") (("" (inst?) nil nil)) nil)) nil) ((radix_div_vNum formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil)) nil (OddFsuccEven_aux subtype "number_fields./(float.vNum(float.b), float.radix)" "int"))) (OddFsuccEven_aux 0 (OddFsuccEven_aux-2 "" 3790102816 ("" (skeep) (("" (expand "vNum") (("" (case-replace "radix ^ Prec(b) / radix=radix ^ (Prec(b)-1)") (("1" (case "even?(radix ^ Prec(b))") (("1" (lemma "expt_even") (("1" (inst-cp -1 "Prec(b)-2") (("1" (inst -1 "Prec(b)-1") (("1" (grind-reals) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (lemma "odd_iff_even_succ") (("2" (inst -1 "radix ^ Prec(b) - 1") (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "expt_div" :dir rl) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil) ((posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (vNum const-decl "posnat" float nil) (expt_x1 formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_div formula-decl nil exponentiation nil) (even? const-decl "bool" integers nil) (b skolem-const-decl "Format" float nil) (int_plus_int_is_int application-judgement "int" integers nil) (expt_even formula-decl nil float nil) (odd_iff_even_succ formula-decl nil naturalnumbers nil) (posint_exp application-judgement "posint" exponentiation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (number_field nonempty-type-from-decl nil number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak) (OddFsuccEven_aux-1 nil 3319564626 ("" (skeep) (("" (expand "vNum") (("" (case-replace "radix ^ Prec(b) / radix=radix ^ (Prec(b)-1)") (("1" (case "even?(radix ^ Prec(b))") (("1" (lemma "expt_even") (("1" (inst-cp -1 "Prec(b)-2") (("1" (inst -1 "Prec(b)-1") (("1" (grind-reals) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (lemma "odd_iff_even_succ") (("2" (inst -1 "radix ^ Prec(b) - 1") (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "expt_div" :dir rl) (("2" (rewrite "expt_x1") nil nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) nil shostak)) (OddFsuccEven 0 (OddFsuccEven-1 nil 3319562322 ("" (skeep) (("" (expand "Fsucc") (("" (grind-reals) (("1" (rewrite "OddFsuccEven_aux") nil nil) ("2" (lemma "OddFsuccEven_aux") (("2" (rewrite "minus_even_is_even") (("2" (case "odd?((vNum(b) / radix))") (("1" (hide -4 2 3) (("1" (case-replace "even?((vNum(b) - 1))= NOT odd?((vNum(b) - 1))") (("1" (case-replace "odd?((vNum(b) / radix))=NOT even?((vNum(b) / radix))") (("1" (inst? -4) (("1" (assert) nil nil)) nil) ("2" (lemma "odd_iff_not_even" :subst ("x" "(vNum(b) / radix)")) (("2" (grind-reals) nil nil)) nil)) nil) ("2" (lemma "even_iff_not_odd" :subst ("x" "(vNum(b) - 1)")) (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (div-by -4 "radix") (("2" (replace -4 -3) (("2" (hide-all-but (-3 1)) (("2" (case "(vNum(b) / radix)=-(-(vNum(b) / radix))") (("1" (replaces -1 1) (("1" (rewrite "minus_odd_is_odd") (("1" (rewrite "integers.closed_neg") nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (lemma "radix_div_vNum") (("3" (inst -1 "b") nil nil)) nil)) nil)) nil)) nil) ("3" (lemma "odd_iff_even_succ" :subst ("x" "Fnum(p)")) (("3" (assert) nil nil)) nil) ("4" (lemma "odd_iff_even_succ" :subst ("x" "Fnum(p)")) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (Fsucc const-decl "float" float nil) (odd_iff_even_succ formula-decl nil naturalnumbers nil) (odd? const-decl "bool" integers nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (radix formal-const-decl "above(1)" float nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (odd_iff_not_even formula-decl nil naturalnumbers nil) (even_iff_not_odd formula-decl nil naturalnumbers nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (odd_int nonempty-type-eq-decl nil integers nil) (minus_odd_is_odd judgement-tcc nil integers nil) (closed_neg formula-decl nil integers nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (div_cancel3 formula-decl nil real_props nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (float type-eq-decl nil float nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (both_sides_div1 formula-decl nil real_props nil) (radix_div_vNum formula-decl nil float nil) (vNum const-decl "posnat" float nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (even_int nonempty-type-eq-decl nil integers nil) (even? const-decl "bool" integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (minus_even_is_even judgement-tcc nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (OddFsuccEven_aux formula-decl nil float nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (div_cancel4 formula-decl nil real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (MinOppMax 0 (MinOppMax-1 nil 3319384478 ("" (expand* "isMin?" "isMax?") (("" (skeep) (("" (rewrite "FoppCorrect") (("" (split) (("1" (grind-reals) nil nil) ("2" (skosimp*) (("2" (case "FtoR(Fopp(f!1)) <= FtoR(p)") (("1" (rewrite "FoppCorrect") (("1" (grind-reals) nil nil)) nil) ("2" (hide 2) (("2" (rewrite -4) (("1" (rewrite "FoppCorrect") (("1" (grind-reals) nil nil)) nil) ("2" (rewrite "FoppBounded") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Fbounded? const-decl "bool" float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Fopp const-decl "float" float nil) (FtoR const-decl "real" float nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (b skolem-const-decl "Format" float nil) (f!1 skolem-const-decl "(Fbounded?(b))" float nil) (FoppBounded formula-decl nil float nil) (minus_real_is_real application-judgement "real" reals nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (FoppCorrect formula-decl nil float nil) (isMin? const-decl "bool" float nil) (isMax? const-decl "bool" float nil)) shostak)) (MaxOppMin 0 (MaxOppMin-1 nil 3319384878 ("" (expand* "isMin?" "isMax?") (("" (skeep) (("" (rewrite "FoppCorrect") (("" (split) (("1" (grind-reals) nil nil) ("2" (skosimp*) (("2" (case "FtoR(p) <= FtoR(Fopp(f!1))") (("1" (rewrite "FoppCorrect") (("1" (grind-reals) nil nil)) nil) ("2" (rewrite -4) (("1" (rewrite "FoppCorrect") (("1" (grind-reals) nil nil)) nil) ("2" (rewrite "FoppBounded") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Fbounded? const-decl "bool" float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Fopp const-decl "float" float nil) (FtoR const-decl "real" float nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (FoppBounded formula-decl nil float nil) (f!1 skolem-const-decl "(Fbounded?(b))" float nil) (b skolem-const-decl "Format" float nil) (minus_real_is_real application-judgement "real" reals nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (FoppCorrect formula-decl nil float nil) (isMin? const-decl "bool" float nil) (isMax? const-decl "bool" float nil)) shostak)) (ClosestFopp 0 (ClosestFopp-1 nil 3319817491 ("" (skeep) (("" (expand "Closest?") (("" (skosimp*) (("" (inst -2 "Fopp(f!1)") (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "FoppBounded") nil nil)) nil)) nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (minus_real_is_real application-judgement "real" reals nil) (Closest? const-decl "bool" float nil) (f!1 skolem-const-decl "(Fbounded?(b))" float nil) (Fopp const-decl "float" float nil) (b skolem-const-decl "Format" float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (both_sides_minus_le1 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (FoppCorrect formula-decl nil float nil) (FoppBounded formula-decl nil float nil)) shostak)) (EvenClosestFopp_TCC1 0 (EvenClosestFopp_TCC1-1 nil 3675510650 ("" (skeep) (("" (use "FcanonicOpp") (("" (replace -1 :hide? t) (("" (use "FcanonicBounded") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((FcanonicOpp formula-decl nil float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (FcanonicBounded formula-decl nil float nil) (Fopp const-decl "float" float nil)) nil (EvenClosestFopp subtype "float.Fopp(float.p)" "(float.Fbounded?(float.b))"))) (EvenClosestFopp 0 (EvenClosestFopp-1 nil 3675497929 ("" (skeep) (("" (expand "EvenClosest?") (("" (split 1) (("1" (use "ClosestFopp") (("1" (split -1) (("1" (propax) nil nil) ("2" (flatten) nil nil) ("3" (expand "Fcanonic?") (("3" (expand "Fnormal?") (("3" (expand "Fsubnormal?") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "even?(Fnum(Fnormalize(b)(p)))") (("1" (hide-all-but (-1 -2 1)) (("1" (use "FnormalizeCanonicFnum") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (use "FcanonicOpp") (("1" (replace -1 :hide? t) (("1" (use "FnormalizeCanonicFnum") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (expand "even?") (("1" (skeep) (("1" (inst 1 "-j") (("1" (assert) (("1" (expand "Fopp") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (use "FoppCorrect") (("2" (replace -1 :hide? t) (("2" (skeep) (("2" (inst -4 "Fopp(f)") (("1" (split -4) (("1" (use "FoppCorrect") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (expand "Closest?") (("2" (skolem 1 "g") (("2" (use "FoppCorrect") (("2" (replace -1 :hide? t) (("2" (inst -1 "Fopp(g)") (("1" (use "FoppCorrect") (("1" (replace -1 :hide? t) (("1" (case "FORALL(x,y:real): abs(-x - -y) = abs(x - y)") (("1" (inst-cp -1 "FtoR(f)" "-r") (("1" (replace -2 :hide? t :dir rl) (("1" (inst -1 "FtoR(g)" "r") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (use "FoppBounded") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "FoppBounded") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((EvenClosest? const-decl "bool" float nil) (b skolem-const-decl "Format" float nil) (f skolem-const-decl "(Fbounded?(b))" float nil) (FoppBounded formula-decl nil float nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (g skolem-const-decl "(Fbounded?(b))" float nil) (Closest? const-decl "bool" float nil) (real_minus_real_is_real application-judgement "real" reals nil) (FoppCorrect formula-decl nil float nil) (FcanonicOpp formula-decl nil float nil) (Fopp const-decl "float" float nil) (even_times_int_is_even application-judgement "even_int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_int_is_int application-judgement "int" integers nil) (FnormalizeCanonicFnum formula-decl nil float nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (bool nonempty-type-eq-decl nil booleans nil) (even? const-decl "bool" integers nil) (Fbounded? const-decl "bool" float nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (FtoR const-decl "real" float nil) (<= const-decl "bool" reals nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (ClosestFopp formula-decl nil float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (minus_real_is_real application-judgement "real" reals nil) (Fcanonic? const-decl "bool" float nil) (Fsubnormal? const-decl "bool" float nil) (Fnormal? const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil)) shostak)) (RleRoundedR0 0 (RleRoundedR0-1 nil 3319477344 ("" (skosimp*) (("" (expand "RoundedMode?") (("" (expand "MinOrMax?") (("" (flatten) (("" (inst -4 "r!1" "f!1") (("" (split) (("1" (expand "isMin?") (("1" (flatten) (("1" (inst -2 "(# Fnum:=0, Fexp:=0 #)") (("1" (expand "FtoR") (("1" (grind-reals) nil nil)) nil) ("2" (expand "Fbounded?") (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "isMax?") (("2" (flatten) (("2" (grind-reals) nil nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RoundedMode? const-decl "bool" float nil) (zero_is_neg_zero formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (posint_exp application-judgement "posint" exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (FtoR const-decl "real" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (expt_x0 formula-decl nil exponentiation nil) (b!1 skolem-const-decl "Format" float nil) (isMin? const-decl "bool" float nil) (isMax? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (MinOrMax? const-decl "bool" float nil)) shostak)) (rle_rounded_r0 0 (rle_rounded_r0-1 nil 3681746559 ("" (skeep) (("" (expand "rounded_mode?") (("" (expand "min_or_max?") (("" (flatten) (("" (inst -4 "r" "f") (("" (split) (("1" (expand "isMin?") (("1" (flatten) (("1" (inst -2 "(# Fnum:=0, Fexp:=0 #)") (("1" (expand "FtoR") (("1" (grind-reals) nil nil)) nil) ("2" (expand "Fbounded?") (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "isMax?") (("2" (flatten) (("2" (grind-reals) nil nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rounded_mode? const-decl "bool" float nil) (zero_is_neg_zero formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (posint_exp application-judgement "posint" exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (FtoR const-decl "real" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (expt_x0 formula-decl nil exponentiation nil) (b skolem-const-decl "Format" float nil) (isMin? const-decl "bool" float nil) (isMax? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (min_or_max? const-decl "bool" float nil)) shostak)) (RleRoundedLessR0 0 (RleRoundedLessR0-1 nil 3319477534 ("" (skosimp*) (("" (expand "RoundedMode?") (("" (expand "MinOrMax?") (("" (flatten) (("" (inst -4 "r!1" "f!1") (("" (split) (("1" (expand "isMin?") (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (expand "isMax?") (("2" (flatten) (("2" (inst -2 "(# Fnum:=0, Fexp:=0 #)") (("1" (expand "FtoR") (("1" (grind-reals) nil nil)) nil) ("2" (expand "Fbounded?") (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RoundedMode? const-decl "bool" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (isMin? const-decl "bool" float nil) (zero_is_neg_zero formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (posint_exp application-judgement "posint" exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (FtoR const-decl "real" float nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (expt_x0 formula-decl nil exponentiation nil) (b!1 skolem-const-decl "Format" float nil) (isMax? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (MinOrMax? const-decl "bool" float nil)) shostak)) (ulp_monotone 0 (ulp_monotone-1 nil 3680964440 ("" (skeep) (("" (expand "ulp") (("" (use "FulpMonotone") (("" (assert) (("" (split -1) (("1" (hide 2) (("1" (use "FleCorrect") (("1" (replace -1 :hide? t :dir rl) (("1" (lemma "rndf_monotone") (("1" (inst? -1 :where -3) (("1" (inst?) (("1" (assert) (("1" (expand "<=") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "round") (("2" (expand "rounded_mode?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "rle_rounded_r0") (("2" (inst? -1 :where -2) (("2" (inst? -1 :where 1) (("2" (inst?) (("2" (inst?) (("2" (split -1) (("1" (propax) nil nil) ("2" (typepred "r::RNDF(b,round)") (("2" (inst -1 "x") (("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil) ("4" (typepred "r::RNDF(b,round)") (("4" (inst -1 "x") nil nil)) nil) ("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ulp const-decl "posreal" float nil) (Fulp_posreal_j application-judgement "posreal" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rle_rounded_r0 formula-decl nil float nil) (NOT const-decl "[bool -> bool]" booleans nil) (<= const-decl "bool" float nil) (<= const-decl "bool" reals nil) (round skolem-const-decl "(rounded_mode?(b))" float nil) (b skolem-const-decl "Format" float nil) (monotone? const-decl "bool" float nil) (rndf_monotone formula-decl nil float nil) (FleCorrect formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (Rounding type-eq-decl nil float nil) (rounded_mode? const-decl "bool" float nil) (RNDF type-eq-decl nil float nil) (FulpMonotone formula-decl nil float nil)) shostak)) (RND_aux_le 0 (RND_aux_le-1 nil 3319375968 ("" (skeep) (("" (rewrite "RND_aux_alt_def") (("" (expand "RND_aux_alt") (("" (grind-reals) (("1" (expand "FtoR") (("1" (case "floor(x * radix ^ (dExp(b))) * radix ^ -dExp(b) <= (x * radix ^ (dExp(b))) * radix ^ -dExp(b)") (("1" (case "(x * radix ^ (dExp(b))) * radix ^ -dExp(b) <= x") (("1" (grind-reals) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "expt_inverse") (("2" (field) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (div-by 1 "radix ^ -dExp(b)") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (expand "FtoR") (("2" (case "floor(x * radix ^ (-floor(ln(x * radix / vNum(b)) / ln(radix)))) *
                radix ^ floor(ln(x * radix / vNum(b)) / ln(radix)) <= (x * radix ^ (-floor(ln(x * radix / vNum(b)) / ln(radix)))) *
                radix ^ floor(ln(x * radix / vNum(b)) / ln(radix))") (("1" (case "(x * radix ^ (-floor(ln(x * radix / vNum(b)) / ln(radix)))) *
                   radix ^ floor(ln(x * radix / vNum(b)) / ln(radix)) <= x") (("1" (grind-reals) nil nil) ("2" (hide 2 -1) (("2" (rewrite "expt_inverse") (("2" (field) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (div-by 1 "radix ^ floor(ln(x * radix / vNum(b)) / ln(radix))") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_aux_alt_def formula-decl nil float nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (expt_inverse formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (FtoR const-decl "real" float nil) (div_cancel2 formula-decl nil real_props nil) (times_div1 formula-decl nil real_props nil) (ln const-decl "real" ln_exp lnexp) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vNum const-decl "posnat" float nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (RND_aux_alt const-decl "(Fcanonic?(b))" float nil) (minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak)) (RND_aux_ge 0 (RND_aux_ge-2 "" 3790102831 ("" (skeep) (("" (rewrite "RND_aux_alt_def") (("" (expand "RND_aux_alt") (("" (lift-if) (("" (split +) (("1" (flatten) (("1" (expand "Fsucc") (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (expand "FtoR") (("1" (case-replace "vNum(b) / radix * radix ^ (1 - dExp(b))=radix*(radix ^ (-dExp(b) - 1) * vNum(b))") (("1" (case "radix ^ (-dExp(b) - 1) * vNum(b) <= radix * (radix ^ (-dExp(b) - 1) * vNum(b))") (("1" (grind-reals) nil nil) ("2" (hide-all-but 1) (("2" (div-by 1 "radix ^ (-dExp(b) - 1)*vNum(b)") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "expt_div" :dir rl) (("2" (rewrite "expt_div" :dir rl) (("2" (rewrite "expt_inverse") (("2" (use "expt_x1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "FtoR") (("2" (rewrite "expt_inverse") (("2" (field 2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (flip-ineq 1) (("2" (expand "Fsucc") (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (expand "FtoR") (("1" (rewrite "expt_plus") (("1" (use "expt_x1") (("1" (field 1) (("1" (mult-by 1 "radix ^ (-floor(ln(x * radix / vNum(b)) / ln(radix)))") (("1" (case-replace "(vNum(b) * (radix ^ floor(ln(x * radix / vNum(b)) / ln(radix)))) *
                                            radix ^ (-floor(ln(x * radix / vNum(b)) / ln(radix)))=vNum(b)") (("1" (grind-reals) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "expt_inverse") (("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "FtoR") (("1" (grind-reals) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "FtoR") (("2" (mult-by 2 "radix ^ (-floor(ln(x * radix / vNum(b)) / ln(radix)))") (("2" (invoke (case-replace "%1 = floor(x * radix ^ (-floor(ln(x * radix / vNum(b)) / ln(radix))))+1") (! 1 r)) (("1" (grind-reals) nil nil) ("2" (hide-all-but 2) (("2" (rewrite "expt_inverse") (("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_aux_alt_def formula-decl nil float nil) (nat_exp application-judgement "nat" exponentiation nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (expt_plus formula-decl nil exponentiation nil) (ln const-decl "real" ln_exp lnexp) (div_cancel4 formula-decl nil real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posrat nonempty-type-eq-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (posint nonempty-type-eq-decl nil integers nil) (posrat_plus_nnrat_is_posrat application-judgement "posrat" rationals nil) (NOT const-decl "[bool -> bool]" booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (radix formal-const-decl "above(1)" float nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_simp formula-decl nil real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_div formula-decl nil exponentiation nil) (expt_x1 formula-decl nil exponentiation nil) (expt_inverse formula-decl nil exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (FtoR const-decl "real" float nil) (Fsucc const-decl "float" float nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (RND_aux_alt const-decl "(Fcanonic?(b))" float nil) (minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak) (RND_aux_ge-1 nil 3319376479 ("" (skeep) (("" (rewrite "RND_aux_alt_def") (("" (expand "RND_aux_alt") (("" (lift-if) (("" (split +) (("1" (flatten) (("1" (expand "Fsucc") (("1" (lift-if) (("1" (split +) (("1" (flatten) (("1" (expand "FtoR") (("1" (case-replace "vNum(b) / radix * radix ^ (1 - dExp(b))=radix*(radix ^ (-dExp(b) - 1) * vNum(b))") (("1" (case "radix ^ (-dExp(b) - 1) * vNum(b) <= radix * (radix ^ (-dExp(b) - 1) * vNum(b))") (("1" (grind-reals) nil nil) ("2" (hide-all-but 1) (("2" (div-by 1 "radix ^ (-dExp(b) - 1)*vNum(b)") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "expt_div" :dir rl) (("2" (rewrite "expt_div" :dir rl) (("2" (rewrite "expt_inverse") (("2" (use "expt_x1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "FtoR") (("2" (rewrite "expt_inverse") (("2" (field 2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (flip-ineq 1) (("2" (expand "Fsucc") (("2" (lift-if) (("2" (split +) (("1" (flatten) (("1" (expand "FtoR") (("1" (rewrite "expt_plus") (("1" (use "expt_x1") (("1" (replace -1 :hide? t) (("1" (field 1) (("1" (mult-by 1 "radix ^ (-floor(ln(x * radix / vNum(b)) / ln(radix)))") (("1" (case-replace "(vNum(b) * (radix ^ floor(ln(x * radix / vNum(b)) / ln(radix)))) *
                                            radix ^ (-floor(ln(x * radix / vNum(b)) / ln(radix)))=vNum(b)") (("1" (grind-reals) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "expt_inverse") (("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (expand "FtoR") (("1" (grind-reals) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "FtoR") (("2" (mult-by 2 "radix ^ (-floor(ln(x * radix / vNum(b)) / ln(radix)))") (("2" (invoke (case-replace "%1 = floor(x * radix ^ (-floor(ln(x * radix / vNum(b)) / ln(radix))))+1") (! 1 r)) (("1" (grind-reals) nil nil) ("2" (hide-all-but 2) (("2" (rewrite "expt_inverse") (("2" (field) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ln const-decl "real" ln_exp lnexp)) shostak)) (RND_Min_isMin 0 (RND_Min_isMin-1 nil 3319384996 ("" (skeep) (("" (expand "RND_Min") (("" (grind-reals) (("1" (expand "isMin?") (("1" (split) (("1" (rewrite "RND_aux_le") nil nil) ("2" (skosimp*) (("2" (case-replace "FtoR(f!1)=FtoR(Fnormalize(b)(f!1))") (("1" (case-replace "RND_aux(b)(r)=Fpred(b)(Fsucc(b)(RND_aux(b)(r)))") (("1" (rewrite "FpredProp") (("1" (case "r < FtoR(Fsucc(b)(RND_aux(b)(r)))") (("1" (grind-reals) nil nil) ("2" (rewrite "RND_aux_ge") nil nil)) nil) ("2" (rewrite "FsuccCanonic") nil nil)) nil) ("2" (rewrite "FpredFsucc") nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (expand "isMin?") (("2" (skosimp*) (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("3" (expand "isMin?") (("3" (flip-ineq 1) (("3" (rewrite "FpredFoppFsucc") (("3" (rewrite "FoppCorrect") (("3" (rewrite "FoppCorrect") (("3" (split) (("1" (case "-r < FtoR(Fsucc(b)(RND_aux(b)(-r)))") (("1" (grind-reals) nil nil) ("2" (rewrite "RND_aux_ge") nil nil)) nil) ("2" (skosimp*) (("2" (case-replace "FtoR(f!1)=FtoR(Fnormalize(b)(f!1))") (("1" (case "FtoR(Fsucc(b)(RND_aux(b)(-r))) <= FtoR(Fopp(Fnormalize(b)(f!1)))") (("1" (rewrite "FoppCorrect") (("1" (grind-reals) nil nil)) nil) ("2" (rewrite "FsuccProp") (("1" (case "-r <= FtoR(Fopp(Fnormalize(b)(f!1)))") (("1" (case "FtoR(RND_aux(b)(-r)) < -r") (("1" (grind-reals) nil nil) ("2" (case "FtoR(RND_aux(b)(-r)) <= -r") (("1" (grind-reals) nil nil) ("2" (rewrite "RND_aux_le") nil nil)) nil)) nil) ("2" (rewrite "FoppCorrect") (("2" (grind-reals) nil nil)) nil)) nil) ("2" (lemma "FcanonicOpp") (("2" (inst -1 "b" "Fnormalize(b)(f!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_Min const-decl "(Fcanonic?(b))" float nil) (FpredFoppFsucc formula-decl nil float nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Fopp const-decl "float" float nil) (FcanonicOpp formula-decl nil float nil) (FsuccProp formula-decl nil float nil) (FoppCorrect formula-decl nil float nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (isMin? const-decl "bool" float nil) (Fsucc const-decl "float" float nil) (Fpred const-decl "float" float nil) (RND_aux const-decl "(Fcanonic?(b))" float nil) (FsuccCanonic formula-decl nil float nil) (< const-decl "bool" reals nil) (RND_aux_ge formula-decl nil float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (FpredProp formula-decl nil float nil) (FpredFsucc formula-decl nil float nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Fcanonic? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (FtoR const-decl "real" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (RND_aux_le formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (minus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (RND_Max_isMax 0 (RND_Max_isMax-1 nil 3319899789 ("" (skeep) (("" (expand "RND_Max") (("" (case-replace "r=--r") (("1" (rewrite "MinOppMax") (("1" (rewrite -1 :dir rl) (("1" (rewrite "RND_Min_isMin") nil nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((RND_Max const-decl "(Fcanonic?(b))" float nil) (MinOppMax formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (bool nonempty-type-eq-decl nil booleans nil) (Fcanonic? const-decl "bool" float nil) (RND_Min const-decl "(Fcanonic?(b))" float nil) (RND_Min_isMin formula-decl nil float nil) (FcanonicBounded formula-decl nil float nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (minus_real_is_real application-judgement "real" reals nil)) shostak)) (RND_aux_float_TCC1 0 (RND_aux_float_TCC1-1 nil 3544890397 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (RND_aux_float subtype "((number_fields.-)((number_fields.-)((number_fields.-)(Prec(float.b), Fexp(float.f)), dExp(float.b)), 1))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (RND_aux_float_TCC2 0 (RND_aux_float_TCC2-1 nil 3544890397 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_exp application-judgement "nat" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (RND_aux_float subtype "((number_fields.+)(dExp(float.b), Fexp(float.f)))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (RND_aux_float_TCC3 0 (RND_aux_float_TCC3-2 nil 3544978082 ("" (skeep) (("" (expand "Fcanonic?") (("" (case "Fsubnormal?(b)
                  ((# Fnum := floor(Fnum(f) * radix ^ (dExp(b) + Fexp(f))),
                      Fexp := -dExp(b) #))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fsubnormal?") (("2" (case "abs(radix * floor(Fnum(f) * radix ^ (dExp(b) + Fexp(f)))) < vNum(b)") (("1" (assert) (("1" (expand "Fbounded?") (("1" (rewrite "abs_mult" -1) (("1" (expand "abs" -1 1) (("1" (mult-by 1 "radix") (("1" (swap "abs(floor(Fnum(f) * radix ^ (dExp(b)+Fexp(f))))" * "radix") (("1" (case "vNum(b)<=vNum(b) * radix") (("1" (grind-reals) nil nil) ("2" (hide -1 -2 2) (("2" (div-by 1 "vNum(b)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "abs_mult") (("2" (expand "abs" 1 1) (("2" (div-by 1 "radix") (("2" (case "floor(Fnum(f) * radix ^ (dExp(b)+Fexp(f))) >=0") (("1" (expand "abs" 1 1) (("1" (assert) (("1" (case "Fnum(f) * radix ^ (dExp(b)+Fexp(f)) < vNum(b) / radix") (("1" (grind-reals) nil nil) ("2" (hide -1 2) (("2" (cross-mult 1) (("2" (expand "vNum") (("2" (case "radix ^ (Prec(b) - 1 - dExp(b) - Fexp(f)) = radix ^ Prec(b) * ( 1/ radix^(dExp(b) + Fexp(f)) ) * 1/radix") (("1" (replace -1 :hide? t) (("1" (grind-reals) nil nil)) nil) ("2" (hide-all-but 1) (("2" (case "Prec(b) - 1 - dExp(b) - Fexp(f) = Prec(b) + (- 1 - dExp(b) - Fexp(f))") (("1" (replace -1 :hide? t) (("1" (lemma "expt_plus") (("1" (inst? -1 :where 1) (("1" (replace -1 :hide? t) (("1" (case "(-1 - dExp(b) - Fexp(f)) = (-1 + -(dExp(b) +Fexp(f)))") (("1" (replace -1 :hide? t) (("1" (lemma "expt_plus") (("1" (inst? -1 :where 1) (("1" (replace -1 :hide? t) (("1" (use "expt_inverse") (("1" (replace -1 :hide? t) (("1" (use "expt_inverse") (("1" (replace -1 :hide? t) (("1" (use "expt_x1") (("1" (replace -1 :hide? t) (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "nnreal_times_nnreal_is_nnreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Fcanonic? const-decl "bool" float nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (Fbounded? const-decl "bool" float nil) (= const-decl "[T, T -> boolean]" equalities nil) (times_div_cancel1 formula-decl nil extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_simp formula-decl nil real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (abs_mult formula-decl nil real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (both_sides_div_pos_lt1 formula-decl nil real_props nil) (nnreal_times_nnreal_is_nnreal judgement-tcc nil real_types nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (div_mult_pos_lt2 formula-decl nil real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_exp application-judgement "posint" exponentiation nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (neg_times_lt formula-decl nil real_props nil) (neg_times_le formula-decl nil real_props nil) (div_div2 formula-decl nil real_props nil) (times_div1 formula-decl nil real_props nil) (expt_plus formula-decl nil exponentiation nil) (expt_inverse formula-decl nil exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (expt_x1 formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (int_times_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Fsubnormal? const-decl "bool" float nil) (real nonempty-type-from-decl nil reals nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (- const-decl "[numfield -> numfield]" number_fields nil) (posrat_exp application-judgement "posrat" exponentiation nil)) nil (RND_aux_float subtype "(# Fnum := floor_ceil.floor(number_fields.*(Fnum(float.f), exponentiation.^(float.radix, ((number_fields.+)(dExp(float.b), Fexp(float.f)))))), Fexp := (number_fields.-)(dExp(float.b)) #)" "(float.Fcanonic?(float.b))")) (RND_aux_float_TCC3-1 nil 3544890397 ("" (subtype-tcc) nil nil) nil nil (RND_aux_float subtype "(# Fnum := floor_ceil.floor(number_fields.*(Fnum(float.f), exponentiation.^(float.radix, ((number_fields.+)(dExp(float.b), Fexp(float.f)))))), Fexp := (number_fields.-)(dExp(float.b)) #)" "(float.Fcanonic?(float.b))"))) (RND_aux_float_TCC4 0 (RND_aux_float_TCC4-1 nil 3544890397 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_exp application-judgement "nat" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil)) nil (RND_aux_float subtype "((number_fields.-)((number_fields.+)((number_fields.+)(Fexp(float.f), 1), dExp(float.b)), Prec(float.b)))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (RND_aux_float_TCC5 0 (RND_aux_float_TCC5-1 nil 3544890397 ("" (skeep) (("" (mult-by 1 "radix ^ (Fexp(f) + 1 + dExp(b) - Prec(b))") (("" (rewrite "expt_plus" :dir rl) (("" (use "expt_x0") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((posrat_exp application-judgement "posrat" exponentiation nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (radix formal-const-decl "above(1)" float nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (rat_exp application-judgement "rat" exponentiation nil) (expt_x0 formula-decl nil exponentiation nil) (expt_plus formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil)) nil (RND_aux_float subtype "number_fields.*(Fnum(float.f), exponentiation.^(float.radix, ((number_fields.-)((number_fields.+)((number_fields.+)(Fexp(float.f), 1), dExp(float.b)), Prec(float.b)))))" "{x: reals.real | reals.>=(x, 1)}"))) (RND_aux_float_TCC6 0 (RND_aux_float_TCC6-1 nil 3544890397 ("" (skeep) (("" (assert) nil nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil)) nil (RND_aux_float subtype "((number_fields.-)(Fexp(float.f), float.e))" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (RND_aux_float_TCC7 0 (RND_aux_float_TCC7-3 nil 3544978679 ("" (skeep) (("" (skosimp*) (("" (lemma "RND_log_compute") (("" (inst?) (("" (expand "vNum" -1 1) (("" (rewrite "expt_plus" :dir rl) (("" (inst - "FtoR(f)") (("" (expand "FtoR" -1 1) (("" (split -) (("1" (expand "FtoR") (("1" (lemma "expt_plus") (("1" (inst - "Fexp(f)" "1+dExp(b)-Prec(b)" "radix") (("1" (mult-by -1 "Fnum(f)") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (replace -1 :dir rl) (("1" (lemma "RND_aux_TCC6") (("1" (inst - "b" "FtoR(f)") (("1" (assert) (("1" (split -) (("1" (inst - "e!1") (("1" (assert) (("1" (split -) (("1" (hide-all-but (-1 2)) (("1" (expand "FtoR") (("1" (lemma "expt_plus") (("1" (inst - "Fexp(f)" "-e!1" "radix") (("1" (assert) (("1" (mult-by -1 "Fnum(f)") (("1" (replace -1 :dir rl) (("1" (assert) (("1" (hide -1) (("1" (grind :exclude "Fcanonic?") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "FtoR" +) (("2" (lemma "expt_plus") (("2" (inst - "Fexp(f)" "1+dExp(b)-Prec(b)" "radix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-2 2)) (("2" (expand "FtoR") (("2" (mult-by 1 "radix^Fexp(f)") (("2" (rewrite "expt_plus" :dir rl) (("2" (assert) (("2" (expand "vNum") (("2" (rewrite "expt_plus" :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "FtoR") (("2" (case "Fnum(f)>=0") (("1" (mult-by -1 "radix^Fexp(f)") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (mult-by 2 "radix^Fexp(f)") (("2" (rewrite "expt_plus" :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_div_nzreal_is_real application-judgement "real" reals nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (real_minus_real_is_real application-judgement "real" reals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (expt_plus formula-decl nil exponentiation nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (nzreal nonempty-type-eq-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (f skolem-const-decl "{f | Fnum(f) >= 0}" float nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (expt def-decl "real" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (< const-decl "bool" reals nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (RND_aux_TCC6 subtype-tcc nil float nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "real" exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (both_sides_times1_imp formula-decl nil extra_real_props nil) (float type-eq-decl nil float nil) (FtoR const-decl "real" float nil) (>= const-decl "bool" reals nil) (vNum const-decl "posnat" float nil) (RND_log_compute formula-decl nil float nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil)) nil (RND_aux_float subtype "(# Fnum := floor_ceil.floor(number_fields.*(Fnum(float.f), exponentiation.^(float.radix, ((number_fields.-)(Fexp(float.f), float.e))))), Fexp := float.e #)" "(float.Fcanonic?(float.b))")) (RND_aux_float_TCC7-2 nil 3544978645 ("" (skeep) (("" (lemma "RND_log_compute") (("" (inst?) (("" (assert) (("" (replace -1 :dir rl) (("" (hide -1) (("" (skosimp) (("" (expand "Fcanonic?") (("" (assert) (("" (flatten) (("" (typepred "e!1") (("" (replace -2 :hide? t) (("" (name "AA" "floor(ln(x * radix / vNum(b)) / ln(radix))") (("" (replace -1) (("" (expand "Fnormal?") (("" (expand "Fbounded?") (("" (split) (("1" (case "0<= floor(x * radix ^ (-AA))") (("1" (expand "abs" 1 1) (("1" (grind-reals) (("1" (case "x * radix ^ (-AA) < vNum(b)") (("1" (grind-reals) nil) ("2" (hide 2 -1) (("2" (case "x * radix ^ (-AA)=x * radix ^^ (-AA)") (("1" (replace -1) (("1" (case "x * radix ^^ (-AA) < x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix)-1))") (("1" (case "x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix) - 1)) <= vNum(b)") (("1" (hide -3 -4) (("1" (name-replace "WW" "x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix) - 1))") (("1" (assert) nil))))) ("2" (hide 2 -1 -2 -3) (("2" (case-replace "(ln(x * radix / vNum(b)) / ln(radix) - 1)=ln(x / vNum(b)) / ln(radix)") (("1" (field) (("1" (rewrite "hathatln") (("1" (field) nil))))) ("2" (hide 2) (("2" (rewrite "ln_div") (("2" (rewrite "ln_div") (("2" (rewrite "ln_mult") (("2" (field) nil))))))))))))))) ("2" (hide -1 2) (("2" (cancel-by 1 "x") (("2" (hide -1 2) (("2" (expand "^^") (("2" (lemma "exp_strict_increasing") (("2" (expand "strict_increasing?") (("2" (rewrite -1) (("2" (hide -1 2) (("2" (field) (("2" (case "(ln(x * radix / vNum(b)) / ln(radix) - 1) < AA") (("1" (rewrite "ln_div") (("1" (rewrite "ln_mult") (("1" (field) (("1" (mult-by -1 "ln(radix)") (("1" (field -1) nil) ("2" (hide -1 -2 2) (("2" (case "ln(radix) > 0") (("1" (split) (("1" (grind-reals) nil) ("2" (propax) nil))) ("2" (hide 2) (("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst -1 "1" "radix") (("2" (grind-reals) nil))))))))))))))))))) ("2" (hide -1 -2 2) (("2" (case "x>0") (("1" (grind-reals) nil) ("2" (hide 2) (("2" (grind-reals) nil))))))))) ("2" (hide 2) (("2" (grind-reals) nil))))))))))))))))))))))))))) ("2" (hide -1 -2 2) (("2" (rewrite "hathat_int") nil))))))))))))) ("2" (case "0 <= x * radix ^ (-AA)") (("1" (hide -2 -3 2) (("1" (grind-reals) nil))) ("2" (hide -1 -2 2 3) (("2" (grind-reals) nil))))))) ("2" (case "-dExp(b) <= ln(x * radix / vNum(b)) / ln(radix)") (("1" (grind-reals) nil) ("2" (hide -2 2) (("2" (mult-by 1 "ln(radix)" +) (("1" (wrap-formula 1 "exp") (("1" (case-replace "exp(-dExp(b) * ln(radix))=radix^^(-dExp(b))") (("1" (rewrite "exp_ln") (("1" (div-by 1 "radix") (("1" (mult-by 1 "vNum(b)") (("1" (case-replace " radix ^ (-dExp(b)) / radix=radix ^ (-dExp(b) - 1)") (("1" (field) (("1" (rewrite "hathat_int") (("1" (div-by 1 "radix") (("1" (hide -1 -2 -4) (("1" (case-replace "(vNum(b) * radix ^ (-dExp(b))) / radix =radix ^ (-dExp(b) - 1) * vNum(b)") (("1" (hide -2 2) (("1" (grind-reals) nil))) ("2" (hide 2 -1 -2) (("2" (lemma "expt_plus") (("2" (inst -1 "-dExp(b)" "-1" "radix") (("2" (grind-reals) (("2" (expand "^" 1 2) (("2" (grind-reals) (("2" (rewrite "expt_x1_aux") nil))))))))))))))))))))))) ("2" (hide 2 -1 -2) (("2" (cross-mult 1) (("2" (case "radix^(-dExp(b)-1)*radix = radix^(-dExp(b)-1)*radix^1") (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "expt_plus" :dir rl) nil))))) ("2" (expand "^" 1) (("2" (expand "expt" 1) (("2" (expand "expt" 1) (("2" (propax) nil))))))))))))))))))))) ("2" (hide -1 2) (("2" (expand "^^") (("2" (propax) nil))))))) ("2" (lemma "ln_increasing") (("2" (expand "increasing?") (("2" (lemma "ln_exp") (("2" (grind-reals) nil))))))))) ("2" (hide 2 -1) (("2" (case "ln(radix) > 0") (("1" (split) (("1" (assert) nil) ("2" (propax) nil))) ("2" (hide 2) (("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst -1 "1" "radix") (("2" (grind-reals) nil))))))))))))))))))) ("3" (expand "abs" 1 1) (("3" (grind-reals) (("3" (cancel-by 1 "radix") (("3" (hide -1 1) (("3" (case "vNum(b) / radix <= x * radix ^ (-AA)") (("1" (case "integer_pred(vNum(b) / radix)") (("1" (hide -3 -4) (("1" (lemma "div_simple") (("1" (inst -1 "vNum(b)" "radix") (("1" (case "(EXISTS (k:int): vNum(b) = k * radix)") (("1" (skosimp*) (("1" (case-replace " vNum(b) / radix=k!1") (("1" (grind-reals) nil) ("2" (hide -2 -3 -4 2) (("2" (grind-reals) nil))))))) ("2" (hide -3 2) (("2" (assert) nil))))))))))) ("2" (assert) (("2" (hide-all-but 1) (("2" (rewrite "radix_div_vNum") nil))))))) ("2" (hide 2) (("2" (case "vNum(b) / radix <=  x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix)))") (("1" (case "x * radix ^^ (-(ln(x * radix / vNum(b)) / ln(radix))) <= x * radix ^ (-AA)") (("1" (assert) nil) ("2" (hide 2 -1) (("2" (cancel-by 1 "x") (("2" (hide -1 1) (("2" (case-replace "radix ^ (-AA)=radix ^^ (-AA)") (("1" (expand "^^") (("1" (lemma "exp_increasing") (("1" (expand "increasing?") (("1" (rewrite -1) (("1" (hide -1 -2 -3 2) (("1" (div-by 1 "-ln(radix)" -) (("1" (field) (("1" (field) nil))) ("2" (case "ln(radix)>0") (("1" (assert) nil) ("2" (hide -1 2 3) (("2" (lemma "ln_strict_increasing") (("2" (expand "strict_increasing?") (("2" (inst -1 "1" "radix") (("2" (grind-reals) nil))))))))))))))))))))))) ("2" (hide -1 -2 2) (("2" (rewrite "hathat_int") nil))))))))))))) ("2" (hide -1 -2 2) (("2" (rewrite "hathatln") (("2" (field) nil)))))))))))))))))))))))))))))))))))))))))))))))))))) nil) nil nil (RND_aux_float subtype "(# Fnum := floor_ceil.floor(number_fields.*(Fnum(float.f), exponentiation.^(float.radix, ((number_fields.-)(Fexp(float.f), float.e))))), Fexp := float.e #)" "(float.Fcanonic?(float.b))")) (RND_aux_float_TCC7-1 nil 3544890397 ("" (subtype-tcc) nil nil) nil nil (RND_aux_float subtype "(# Fnum := floor_ceil.floor(number_fields.*(Fnum(float.f), exponentiation.^(float.radix, ((number_fields.-)(Fexp(float.f), float.e))))), Fexp := float.e #)" "(float.Fcanonic?(float.b))"))) (RND_aux_float_def_TCC1 0 (RND_aux_float_def_TCC1-1 nil 3544890397 ("" (skeep) (("" (expand "FtoR") (("" (mult-by -1 "radix^Fexp(f)") (("" (assert) nil nil)) nil)) nil)) nil) ((FtoR const-decl "real" float nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (float type-eq-decl nil float nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil)) nil (RND_aux_float_def subtype "float.FtoR(float.f)" "nonneg_real"))) (RND_aux_float_def 0 (RND_aux_float_def-1 nil 3544890402 ("" (skeep) (("" (expand "RND_aux_float") (("" (expand "RND_aux") (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (assert) (("" (ground) (("1" (expand "FtoR") (("1" (lemma "expt_plus") (("1" (inst - "dExp(b)" "Fexp(f)" "radix") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (expand "FtoR") (("2" (mult-by -1 "radix^Fexp(f)") (("2" (rewrite "expt_plus" :dir rl) (("2" (expand "vNum") (("2" (rewrite "expt_plus" :dir rl) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 1) (("3" (expand "FtoR") (("3" (expand "vNum") (("3" (rewrite "expt_plus" :dir rl) (("3" (mult-by -1 "radix^Fexp(f)") (("3" (rewrite "expt_plus" :dir rl) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 1) (("4" (expand "FtoR") (("4" (expand "vNum") (("4" (rewrite "expt_plus" :dir rl) (("4" (mult-by 1 "radix^Fexp(f)") (("4" (rewrite "expt_plus" :dir rl) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 1) (("5" (expand "FtoR") (("5" (expand "vNum") (("5" (rewrite "expt_plus" :dir rl) (("5" (mult-by 1 "radix^Fexp(f)") (("5" (rewrite "expt_plus" :dir rl) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (case "FORALL (eg1:real,eg2:real): eg1 = eg2 IMPLIES floor(eg1) = floor(eg2)") (("1" (inst?) (("1" (ground) (("1" (hide 2) (("1" (expand "FtoR") (("1" (invoke (case "%1 = %2 * (%3)") (! 1 1 2) (! 1 2 2) (! 1 2 3)) (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "expt_plus" :dir rl) (("2" (assert) (("2" (case "Fnum(f) * radix ^ (1 + dExp(b) + Fexp(f) - Prec(b)) = Fnum(f) * radix ^ (Fexp(f)) *
                      radix ^ (1 + dExp(b) - Prec(b))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (invoke (case "%1 = %2 * (%3)") (! 1 1 2) (! 1 2 2) (! 1 2 3)) (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "expt_plus" :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (expand "FtoR") (("7" (lemma "expt_plus") (("7" (inst - "Fexp(f)" "1+dExp(b)-Prec(b)" "radix") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posrat_exp application-judgement "posrat" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (RND_aux_float const-decl "(Fcanonic?(b))" float nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (real_times_real_is_real application-judgement "real" reals nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (expt_plus formula-decl nil exponentiation nil) (radix formal-const-decl "above(1)" float nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (float type-eq-decl nil float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (FtoR const-decl "real" float nil) (int_times_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (vNum const-decl "posnat" float nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (< const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (RND_aux const-decl "(Fcanonic?(b))" float nil) (minus_int_is_int application-judgement "int" integers nil)) shostak)) (RND_float_Min_TCC1 0 (RND_float_Min_TCC1-1 nil 3544890397 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (RND_float_Min subtype "float.f" "{f | reals.>=(Fnum(float.f), 0)}"))) (RND_float_Min_TCC2 0 (RND_float_Min_TCC2-1 nil 3544890397 ("" (subtype-tcc) nil nil) ((minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Fopp const-decl "float" float nil) (- const-decl "float" float nil)) nil (RND_float_Min subtype "(float.-)(float.f)" "{f | reals.>=(Fnum(float.f), 0)}"))) (RND_float_Min_TCC3 0 (RND_float_Min_TCC3-1 nil 3544890397 ("" (skeep) (("" (lemma "FcanonicOpp") (("" (inst -1 "b" "RND_aux_float(b)(-f)") (("1" (assert) nil nil) ("2" (assert) (("2" (expand "-") (("2" (expand "Fopp") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FcanonicOpp formula-decl nil float nil) (Fopp const-decl "float" float nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (RND_aux_float const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (- const-decl "float" float nil) (f skolem-const-decl "float" float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (RND_float_Min subtype "float.Fopp(float.RND_aux_float(float.b)((float.-)(float.f)))" "(float.Fcanonic?(float.b))"))) (RND_float_Min_TCC4 0 (RND_float_Min_TCC4-2 nil 3545038497 ("" (skeep) (("" (rewrite "FpredCanonic") (("1" (lemma "FcanonicOpp") (("1" (rewrite "FpredCanonic") (("1" (lemma "FcanonicOpp") (("1" (inst -1 "b" "RND_aux_float(b)(-f)") (("1" (assert) nil nil) ("2" (expand "-") (("2" (expand "Fopp") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "-") (("2" (expand "Fopp") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "-") (("2" (expand "Fopp") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (FpredCanonic formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fopp const-decl "float" float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (Fcanonic? const-decl "bool" float nil) (RND_aux_float const-decl "(Fcanonic?(b))" float nil) (- const-decl "float" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (f skolem-const-decl "float" float nil) (minus_int_is_int application-judgement "int" integers nil) (FcanonicOpp formula-decl nil float nil)) nil (RND_float_Min subtype "float.Fpred(float.b)(float.Fopp(float.RND_aux_float(float.b)((float.-)(float.f))))" "(float.Fcanonic?(float.b))")) (RND_float_Min_TCC4-1 nil 3544890397 ("" (subtype-tcc) nil nil) nil nil (RND_float_Min subtype "float.Fpred(float.b)(float.Fopp(float.RND_aux_float(float.b)((float.-)(float.f))))" "(float.Fcanonic?(float.b))"))) (RND_float_Min_def 0 (RND_float_Min_def-1 nil 3544891290 ("" (skeep) (("" (expand "RND_float_Min") (("" (expand "RND_Min") (("" (assert) (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (ground) (("1" (rewrite "RND_aux_float_def") nil nil) ("2" (expand "FtoR") (("2" (mult-by -2 "radix^(Fexp(f))") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "FtoR") (("3" (mult-by -1 "radix^(Fexp(f))") (("3" (assert) nil nil)) nil)) nil) ("4" (expand "FtoR") (("4" (mult-by 2 "radix^(Fexp(f))") (("4" (assert) nil nil)) nil)) nil) ("5" (case "-FtoR(f) = FtoR(-f)") (("1" (replace -1) (("1" (rewrite "RND_aux_float_def" +) (("1" (hide -) (("1" (hide 2) (("1" (expand "-") (("1" (expand "Fopp") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("6" (case "-FtoR(f) = FtoR(-f)") (("1" (replace -1) (("1" (hide -1) (("1" (rewrite "RND_aux_float_def" -) (("1" (hide-all-but (1 5)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("7" (expand "FtoR") (("7" (mult-by 3 "radix^(Fexp(f))") (("7" (assert) nil nil)) nil)) nil) ("8" (case "-FtoR(f) = FtoR(-f)") (("1" (replace -1) (("1" (lemma "RND_aux_float_def") (("1" (inst - "b" "-f") (("1" (assert) (("1" (hide-all-but (1 5)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("9" (case "-FtoR(f) = FtoR(-f)") (("1" (replaces -1) (("1" (rewrite "RND_aux_float_def" +) (("1" (hide-all-but (1 6)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_float_Min const-decl "(Fcanonic?(b))" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (- const-decl "float" float nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (Fopp const-decl "float" float nil) (minus_int_is_int application-judgement "int" integers nil) (expt def-decl "real" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posreal nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (FtoR const-decl "real" float nil) (minus_rat_is_rat application-judgement "rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (RND_aux_float_def formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (minus_real_is_real application-judgement "real" reals nil) (RND_Min const-decl "(Fcanonic?(b))" float nil)) shostak)) (RND_float_Max_TCC1 0 (RND_float_Max_TCC1-2 nil 3545038630 ("" (skeep) (("" (lemma "FcanonicOpp") (("" (inst -1 "b" "RND_float_Min(b)(-f)") (("" (assert) nil nil)) nil)) nil)) nil) ((FcanonicOpp formula-decl nil float nil) (- const-decl "float" float nil) (RND_float_Min const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (RND_float_Max subtype "float.Fopp(float.RND_float_Min(float.b)((float.-)(float.f)))" "(float.Fcanonic?(float.b))")) (RND_float_Max_TCC1-1 nil 3544891797 ("" (subtype-tcc) nil nil) nil nil (RND_float_Max subtype "float.Fopp(float.RND_float_Min(float.b)((float.-)(float.f)))" "(float.Fcanonic?(float.b))"))) (RND_float_Max_def 0 (RND_float_Max_def-1 nil 3544891798 ("" (skeep) (("" (expand "RND_Max") (("" (expand "RND_float_Max") (("" (rewrite "RND_float_Min_def") (("" (case "-FtoR(f) = FtoR(-f)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_Max const-decl "(Fcanonic?(b))" float nil) (RND_float_Min_def formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (- const-decl "float" float nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_times_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (Fopp const-decl "float" float nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (minus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (FtoR const-decl "real" float nil) (RND_float_Max const-decl "(Fcanonic?(b))" float nil)) shostak)) (RND_float_Min_ge_canonic 0 (RND_float_Min_ge_canonic-1 nil 3544958511 ("" (skeep) (("" (ground) (("1" (expand ">=" -1) (("1" (rewrite "FleCorrect") (("1" (rewrite "RND_float_Min_def") (("1" (lemma "RND_Min_isMin") (("1" (inst?) (("1" (expand "isMin?") (("1" (flatten) (("1" (expand ">=" +) (("1" (rewrite "FleCorrect") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand ">=") (("2" (rewrite "FleCorrect") (("2" (rewrite "FleCorrect") (("2" (rewrite "RND_float_Min_def") (("2" (lemma "RND_Min_isMin") (("2" (inst?) (("2" (expand "isMin?") (("2" (flatten) (("2" (inst - "g") (("1" (assert) nil nil) ("2" (expand "Fcanonic?") (("2" (ground) (("1" (expand "Fnormal?") (("1" (propax) nil nil)) nil) ("2" (expand "Fsubnormal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FleCorrect formula-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Fcanonic? const-decl "bool" float nil) (RND_float_Min const-decl "(Fcanonic?(b))" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (RND_Min_isMin formula-decl nil float nil) (isMin? const-decl "bool" float nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (FtoR const-decl "real" float nil) (RND_float_Min_def formula-decl nil float nil) (>= const-decl "bool" float nil) (Fsubnormal? const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil) (Fnormal? const-decl "bool" float nil) (g skolem-const-decl "float" float nil) (b skolem-const-decl "Format" float nil) (Fbounded? const-decl "bool" float nil)) nil)) (RND_float_Max_le_canonic 0 (RND_float_Max_le_canonic-1 nil 3544958528 ("" (skeep) (("" (ground) (("1" (expand "<=" -1) (("1" (rewrite "FleCorrect") (("1" (rewrite "RND_float_Max_def") (("1" (lemma "RND_Max_isMax") (("1" (inst?) (("1" (expand "isMax?") (("1" (flatten) (("1" (expand "<=" +) (("1" (rewrite "FleCorrect") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "<=") (("2" (rewrite "FleCorrect") (("2" (rewrite "FleCorrect") (("2" (rewrite "RND_float_Max_def") (("2" (lemma "RND_Max_isMax") (("2" (inst?) (("2" (expand "isMax?") (("2" (flatten) (("2" (inst - "g") (("1" (assert) nil nil) ("2" (expand "Fcanonic?") (("2" (ground) (("1" (expand "Fnormal?") (("1" (propax) nil nil)) nil) ("2" (expand "Fsubnormal?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FleCorrect formula-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Fcanonic? const-decl "bool" float nil) (RND_float_Max const-decl "(Fcanonic?(b))" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (RND_Max_isMax formula-decl nil float nil) (isMax? const-decl "bool" float nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (FtoR const-decl "real" float nil) (RND_float_Max_def formula-decl nil float nil) (<= const-decl "bool" float nil) (Fsubnormal? const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil) (Fnormal? const-decl "bool" float nil) (g skolem-const-decl "float" float nil) (b skolem-const-decl "Format" float nil) (Fbounded? const-decl "bool" float nil)) nil)) (RND_float_Min_canonic 0 (RND_float_Min_canonic-1 nil 3545555881 ("" (skeep) (("" (lemma "FcanonicUnique") (("" (inst?) (("" (inst - "b") (("" (assert) (("" (hide 2) (("" (lemma "RND_float_Min_ge_canonic") (("" (inst?) (("" (inst - "f") (("" (assert) (("" (expand ">=") (("" (rewrite "FleCorrect") (("" (rewrite "FleCorrect") (("" (assert) (("" (case "FtoR(RND_float_Min(b)(f)) <= FtoR(f)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "RND_float_Min_def" +) (("2" (lemma "RND_Min_isMin") (("2" (inst?) (("2" (expand "isMin?") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FcanonicUnique formula-decl nil float nil) (FleCorrect formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (RND_Min_isMin formula-decl nil float nil) (isMin? const-decl "bool" float nil) (RND_float_Min_def formula-decl nil float nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (FtoR const-decl "real" float nil) (>= const-decl "bool" float nil) (RND_float_Min_ge_canonic formula-decl nil float nil) (RND_float_Min const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil)) shostak)) (RND_float_Max_canonic 0 (RND_float_Max_canonic-1 nil 3545556181 ("" (skeep) (("" (lemma "FcanonicUnique") (("" (inst?) (("" (inst - "b") (("" (assert) (("" (hide 2) (("" (lemma "RND_float_Max_le_canonic") (("" (inst?) (("" (inst - "f") (("" (assert) (("" (expand "<=") (("" (rewrite "FleCorrect") (("" (rewrite "FleCorrect") (("" (assert) (("" (case "FtoR(RND_float_Max(b)(f)) >= FtoR(f)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "RND_float_Max_def" +) (("2" (lemma "RND_Max_isMax") (("2" (inst?) (("2" (expand "isMax?") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FcanonicUnique formula-decl nil float nil) (FleCorrect formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (RND_Max_isMax formula-decl nil float nil) (isMax? const-decl "bool" float nil) (RND_float_Max_def formula-decl nil float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (FtoR const-decl "real" float nil) (<= const-decl "bool" float nil) (RND_float_Max_le_canonic formula-decl nil float nil) (RND_float_Max const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil)) nil)) (RND_float_Min_ge 0 (RND_float_Min_ge-1 nil 3544958600 ("" (skeep) (("" (lemma "RND_float_Min_ge_canonic") (("" (inst - "b" "f" "RND_float_Min(b)(g)") (("" (assert) (("" (hide 2) (("" (expand ">=") (("" (rewrite "FleCorrect") (("" (rewrite "FleCorrect") (("" (rewrite "RND_float_Min_def") (("" (lemma "RND_Min_isMin") (("" (inst?) (("" (expand "isMin?") (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_float_Min_ge_canonic formula-decl nil float nil) (>= const-decl "bool" float nil) (RND_Min_isMin formula-decl nil float nil) (isMin? const-decl "bool" float nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (FtoR const-decl "real" float nil) (RND_float_Min_def formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FleCorrect formula-decl nil float nil) (RND_float_Min const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (RND_float_Min_le 0 (RND_float_Min_le-1 nil 3544958730 ("" (skeep) (("" (lemma "RND_float_Min_ge_canonic") (("" (inst - "b" "g" "RND_float_Min(b)(f)") (("" (assert) (("" (ground) (("1" (expand ">=") (("1" (expand "<=") (("1" (propax) nil nil)) nil)) nil) ("2" (hide (2 3)) (("2" (expand ">=") (("2" (expand "<=") (("2" (rewrite "FleCorrect") (("2" (rewrite "FleCorrect") (("2" (rewrite "RND_float_Min_def") (("2" (lemma "RND_Min_isMin") (("2" (inst?) (("2" (expand "isMin?") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_float_Min_ge_canonic formula-decl nil float nil) (RND_Min_isMin formula-decl nil float nil) (isMin? const-decl "bool" float nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (FtoR const-decl "real" float nil) (RND_float_Min_def formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FleCorrect formula-decl nil float nil) (>= const-decl "bool" float nil) (<= const-decl "bool" float nil) (RND_float_Min const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil)) (RND_float_Max_ge 0 (RND_float_Max_ge-1 nil 3544962250 ("" (skeep) (("" (expand "RND_float_Max") (("" (lemma "RND_float_Min_le") (("" (inst - "b" "-f" "-g") (("" (split -) (("1" (expand "<=") (("1" (expand ">=") (("1" (rewrite "FleCorrect") (("1" (rewrite "FleCorrect") (("1" (rewrite "FleCorrect") (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_float_Max const-decl "(Fcanonic?(b))" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (- const-decl "float" float nil) (expt def-decl "real" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (Fle? const-decl "bool" float nil) (Fminus const-decl "float" float nil) (^ const-decl "real" exponentiation nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (minus_int_is_int application-judgement "int" integers nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (posnat_expt application-judgement "posnat" exponentiation nil) (<= const-decl "bool" float nil) (FleCorrect formula-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Fcanonic? const-decl "bool" float nil) (RND_float_Min const-decl "(Fcanonic?(b))" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Fopp const-decl "float" float nil) (minus_real_is_real application-judgement "real" reals nil) (FoppCorrect formula-decl nil float nil) (>= const-decl "bool" float nil) (RND_float_Min_le formula-decl nil float nil)) nil)) (RND_float_Max_le 0 (RND_float_Max_le-1 nil 3544962448 ("" (skeep) (("" (expand "RND_float_Max") (("" (lemma "RND_float_Min_ge") (("" (inst - "b" "-f" "-g") (("" (split -) (("1" (expand "<=") (("1" (expand ">=") (("1" (rewrite "FleCorrect") (("1" (rewrite "FleCorrect") (("1" (rewrite "FleCorrect") (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_float_Max const-decl "(Fcanonic?(b))" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (- const-decl "float" float nil) (expt def-decl "real" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (Fle? const-decl "bool" float nil) (Fminus const-decl "float" float nil) (^ const-decl "real" exponentiation nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (minus_int_is_int application-judgement "int" integers nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (posnat_expt application-judgement "posnat" exponentiation nil) (<= const-decl "bool" float nil) (FleCorrect formula-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Fcanonic? const-decl "bool" float nil) (RND_float_Min const-decl "(Fcanonic?(b))" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Fopp const-decl "float" float nil) (minus_real_is_real application-judgement "real" reals nil) (FoppCorrect formula-decl nil float nil) (>= const-decl "bool" float nil) (RND_float_Min_ge formula-decl nil float nil)) nil)) (RND_float_Min_lt_canonic 0 (RND_float_Min_lt_canonic-1 nil 3544975201 ("" (skeep) (("" (ground) (("1" (lemma "RND_float_Min_ge") (("1" (inst - "b" "f" "g") (("1" (split -) (("1" (case "FtoR(g) = FtoR(RND_float_Min(b)(g))") (("1" (expand ">=") (("1" (expand "<") (("1" (rewrite "FleCorrect") (("1" (rewrite "FltCorrect") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2)) (("2" (rewrite "RND_float_Min_def") (("2" (lemma "RND_Min_isMin") (("2" (inst?) (("2" (expand "isMin?") (("2" (flatten) (("2" (inst - "g") (("1" (assert) nil nil) ("2" (expand "Fcanonic?") (("2" (expand "Fnormal?") (("2" (expand "Fsubnormal?") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (expand ">=") (("2" (expand "<") (("2" (rewrite "FleCorrect") (("2" (rewrite "FltCorrect") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "<") (("2" (rewrite "FltCorrect") (("2" (rewrite "FltCorrect") (("2" (rewrite "RND_float_Min_def") (("2" (lemma "RND_Min_isMin") (("2" (inst?) (("2" (expand "isMin?") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (RND_float_Min const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (FtoR const-decl "real" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (< const-decl "bool" float nil) (FltCorrect formula-decl nil float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FleCorrect formula-decl nil float nil) (>= const-decl "bool" float nil) (RND_float_Min_def formula-decl nil float nil) (Fsubnormal? const-decl "bool" float nil) (Fnormal? const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil) (g skolem-const-decl "float" float nil) (b skolem-const-decl "Format" float nil) (Fbounded? const-decl "bool" float nil) (isMin? const-decl "bool" float nil) (RND_Min_isMin formula-decl nil float nil) (RND_float_Min_ge formula-decl nil float nil)) nil)) (RND_float_Min_gt_canonic 0 (RND_float_Min_gt_canonic-1 nil 3544976459 ("" (skeep) (("" (ground) (("1" (lemma "RND_float_Max_le") (("1" (inst - "b" "f" "g") (("1" (split -) (("1" (case "FtoR(g) = FtoR(RND_float_Max(b)(g))") (("1" (expand "<=") (("1" (expand ">") (("1" (rewrite "FleCorrect") (("1" (rewrite "FltCorrect") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2)) (("2" (rewrite "RND_float_Max_def") (("2" (lemma "RND_Max_isMax") (("2" (inst?) (("2" (expand "isMax?") (("2" (flatten) (("2" (inst - "g") (("1" (assert) nil nil) ("2" (expand "Fcanonic?") (("2" (expand "Fnormal?") (("2" (expand "Fsubnormal?") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (expand "<=") (("2" (expand ">") (("2" (rewrite "FleCorrect") (("2" (rewrite "FltCorrect") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand ">") (("2" (rewrite "FltCorrect") (("2" (rewrite "FltCorrect") (("2" (rewrite "RND_float_Max_def") (("2" (lemma "RND_Max_isMax") (("2" (inst?) (("2" (expand "isMax?") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (RND_float_Max const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (FtoR const-decl "real" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (> const-decl "bool" float nil) (FltCorrect formula-decl nil float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FleCorrect formula-decl nil float nil) (<= const-decl "bool" float nil) (RND_float_Max_def formula-decl nil float nil) (Fsubnormal? const-decl "bool" float nil) (Fnormal? const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil) (g skolem-const-decl "float" float nil) (b skolem-const-decl "Format" float nil) (Fbounded? const-decl "bool" float nil) (isMax? const-decl "bool" float nil) (RND_Max_isMax formula-decl nil float nil) (RND_float_Max_le formula-decl nil float nil)) nil)) (RND_float_Min_ge_0 0 (RND_float_Min_ge_0-1 nil 3544958916 ("" (skeep) (("" (lemma "RND_float_Min_ge") (("" (inst - "b" "f" "float_int(0)") (("" (assert) (("" (case "FtoR(RND_float_Min(b)(float_int(0))) = 0") (("1" (expand ">=") (("1" (expand ">=") (("1" (rewrite "FleCorrect") (("1" (rewrite "FleCorrect") (("1" (assert) (("1" (rewrite "RND_float_Min_def") (("1" (rewrite "RND_float_Min_def") (("1" (lemma "RND_Min_isMin") (("1" (inst-cp - "b" "FtoR(float_int(0))") (("1" (inst - "b" "FtoR(f)") (("1" (assert) (("1" (expand "isMin?") (("1" (ground) (("1" (inst - "float_int(0)") (("1" (ground) (("1" (expand "FtoR" + 1) (("1" (expand "float_int" 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "Fbounded?" 1) (("2" (assert) (("2" (expand "float_int" 1) (("2" (assert) (("2" (case "abs(0) = 0") (("1" (replace -1 :hide? t) (("1" (assert) (("1" (typepred "dExp(b)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "float_int") (("2" (expand "RND_float_Min") (("2" (expand "RND_aux_float") (("2" (lift-if) (("2" (ground) (("2" (rewrite "floor_int") (("2" (expand "FtoR") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_float_Min_ge formula-decl nil float nil) (radix formal-const-decl "above(1)" float nil) (> const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (integer nonempty-type-from-decl nil integers nil) (floor_int formula-decl nil floor_ceil nil) (minus_int_is_int application-judgement "int" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (RND_aux_float const-decl "(Fcanonic?(b))" float nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (>= const-decl "bool" float nil) (>= const-decl "bool" float nil) (FleCorrect formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (expt_x0 formula-decl nil exponentiation nil) (b skolem-const-decl "Format" float nil) (Fbounded? const-decl "bool" float nil) (isMin? const-decl "bool" float nil) (RND_Min_isMin formula-decl nil float nil) (RND_float_Min_def formula-decl nil float nil) (>= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (FtoR const-decl "real" float nil) (bool nonempty-type-eq-decl nil booleans nil) (Fcanonic? const-decl "bool" float nil) (RND_float_Min const-decl "(Fcanonic?(b))" float nil) (float_int const-decl "float" float nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (RND_float_Min_lt_0 0 (RND_float_Min_lt_0-1 nil 3544976537 ("" (skeep) (("" (lemma "RND_float_Min_lt_canonic") (("" (inst - "b" "f" "RND_float_Min(b)(float_int(0))") (("" (assert) (("" (expand "<") (("" (rewrite "FltCorrect") (("" (rewrite "FltCorrect") (("" (case "FtoR(RND_float_Min(b)(float_int(0))) = 0") (("1" (replaces -1) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "RND_float_Min_def") (("2" (case "FtoR(float_int(0)) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (expand "RND_Min") (("1" (expand "RND_aux") (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (rewrite "floor_int") (("1" (expand "FtoR") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_float_Min_lt_canonic formula-decl nil float nil) (FltCorrect formula-decl nil float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (FtoR const-decl "real" float nil) (RND_float_Min_def formula-decl nil float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (expt def-decl "real" exponentiation nil) (RND_Min const-decl "(Fcanonic?(b))" float nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (floor_int formula-decl nil floor_ceil nil) (integer nonempty-type-from-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (RND_aux const-decl "(Fcanonic?(b))" float nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (< const-decl "bool" float nil) (< const-decl "bool" float nil) (float_int const-decl "float" float nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (RND_float_Min const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil)) (RND_float_Max_le_0 0 (RND_float_Max_le_0-6 nil 3544965375 ("" (skeep) (("" (lemma "RND_float_Max_le") (("" (inst - "b" "f" "float_int(0)") (("" (assert) (("" (case "FtoR(RND_float_Max(b)(float_int(0))) = 0") (("1" (expand "<=") (("1" (expand "<=") (("1" (rewrite "FleCorrect") (("1" (rewrite "FleCorrect") (("1" (assert) (("1" (rewrite "RND_float_Max_def") (("1" (rewrite "RND_float_Max_def") (("1" (lemma "RND_Max_isMax") (("1" (inst-cp - "b" "FtoR(float_int(0))") (("1" (inst - "b" "FtoR(f)") (("1" (assert) (("1" (expand "isMax?") (("1" (ground) (("1" (inst - "float_int(0)") (("1" (ground) (("1" (expand "FtoR" + 1) (("1" (expand "float_int" 1) (("1" (expand "FtoR" 1) (("1" (assert) (("1" (expand "FtoR" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "Fbounded?" 1) (("2" (assert) (("2" (expand "float_int" 1) (("2" (assert) (("2" (typepred "dExp(b)") (("2" (assert) (("2" (case "abs(0) = 0") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "abs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide-all-but 2) (("2" (expand "RND_Max") (("2" (expand "RND_Min") (("2" (expand "RND_aux") (("2" (assert) (("2" (ground) (("2" (expand "Fopp") (("2" (rewrite "floor_int") (("2" (assert) (("2" (expand "FtoR") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "RND_float_Max") (("2" (expand "RND_float_Min") (("2" (lift-if) (("2" (ground) (("1" (expand "RND_aux_float") (("1" (lift-if) (("1" (ground) (("1" (expand "float_int") (("1" (hide -) (("1" (rewrite "floor_int") (("1" (grind) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 2) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 3) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_float_Max_le formula-decl nil float nil) (RND_float_Min const-decl "(Fcanonic?(b))" float nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "float" float nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (expt def-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (RND_aux_float const-decl "(Fcanonic?(b))" float nil) (int_plus_int_is_int application-judgement "int" integers nil) (<= const-decl "bool" float nil) (<= const-decl "bool" float nil) (FleCorrect formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (expt_x0 formula-decl nil exponentiation nil) (b skolem-const-decl "Format" float nil) (Fbounded? const-decl "bool" float nil) (RND_Min const-decl "(Fcanonic?(b))" float nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (Fopp const-decl "float" float nil) (minus_even_is_even application-judgement "even_int" integers nil) (floor_int formula-decl nil floor_ceil nil) (integer nonempty-type-from-decl nil integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (RND_aux const-decl "(Fcanonic?(b))" float nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (RND_Max const-decl "(Fcanonic?(b))" float nil) (isMax? const-decl "bool" float nil) (RND_Max_isMax formula-decl nil float nil) (RND_float_Max_def formula-decl nil float nil) (<= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (FtoR const-decl "real" float nil) (bool nonempty-type-eq-decl nil booleans nil) (Fcanonic? const-decl "bool" float nil) (RND_float_Max const-decl "(Fcanonic?(b))" float nil) (float_int const-decl "float" float nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil) (RND_float_Max_le_0-5 nil 3544962611 ("" (skeep) (("" (lemma "RND_float_Max_le") (("" (inst - "b" "f" "float_int(0)") (("" (assert) (("" (case "FtoR(RND_float_Max(b)(float_int(0))) = 0") (("1" (expand "<=") (("1" (expand "<=") (("1" (rewrite "FleCorrect") (("1" (rewrite "FleCorrect") (("1" (assert) (("1" (rewrite "RND_float_Max_def") (("1" (rewrite "RND_float_Max_def") (("1" (lemma "RND_Max_isMax") (("1" (inst-cp - "b" "FtoR(float_int(0))") (("1" (inst - "b" "FtoR(f)") (("1" (assert) (("1" (expand "isMax?") (("1" (ground) (("1" (inst - "float_int(0)") (("1" (ground) (("1" (expand "FtoR" + 1) (("1" (expand "float_int" 1) (("1" (assert) nil))))))) ("2" (expand "Fbounded?" 1) (("2" (assert) (("2" (expand "float_int" 1) (("2" (assert) (("2" (rewrite "abs_0") (("2" (assert) (("2" (typepred "dExp(b)") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "float_int") (("2" (expand "RND_float_Max") (("2" (expand "RND_aux_float") (("2" (lift-if) (("2" (ground) (("2" (rewrite "floor_int") (("2" (assert) (("2" (expand "FtoR") (("2" (propax) nil)))))))))))))))))))))))))))) nil) nil nil) (RND_float_Max_le_0-4 nil 3544962502 ("" (skeep) (("" (lemma "RND_float_Min_ge") (("" (inst - "b" "f" "float_int(0)") (("" (assert) (("" (case "FtoR(RND_float_Min(b)(float_int(0))) = 0") (("1" (expand ">=") (("1" (expand ">=") (("1" (rewrite "FleCorrect") (("1" (rewrite "FleCorrect") (("1" (assert) (("1" (rewrite "RND_float_Min_def") (("1" (rewrite "RND_float_Min_def") (("1" (lemma "RND_Min_isMin") (("1" (inst-cp - "b" "FtoR(float_int(0))") (("1" (inst - "b" "FtoR(f)") (("1" (assert) (("1" (expand "isMin?") (("1" (ground) (("1" (inst - "float_int(0)") (("1" (ground) (("1" (expand "FtoR" + 1) (("1" (expand "float_int" 1) (("1" (assert) nil))))))) ("2" (expand "Fbounded?" 1) (("2" (assert) (("2" (expand "float_int" 1) (("2" (assert) (("2" (rewrite "abs_0") (("2" (assert) (("2" (typepred "dExp(b)") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "float_int") (("2" (expand "RND_float_Min") (("2" (expand "RND_aux_float") (("2" (lift-if) (("2" (ground) (("2" (rewrite "floor_int") (("2" (assert) (("2" (expand "FtoR") (("2" (propax) nil)))))))))))))))))))))))))))) nil) nil nil) (RND_float_Max_le_0-3 nil 3544962139 ("" (skeep) (("" (lemma "RND_float_Max_le") (("" (inst - "b" "f" "float_int(0)") (("" (assert) (("" (case "FtoR(RND_float_Max(b)(float_int(0))) = 0") (("1" (expand "<=") (("1" (expand "<=") (("1" (rewrite "FleCorrect") (("1" (rewrite "FleCorrect") (("1" (assert) (("1" (rewrite "RND_float_Max_def") (("1" (rewrite "RND_float_Max_def") (("1" (lemma "RND_Max_isMax") (("1" (inst-cp - "b" "FtoR(float_int(0))") (("1" (inst - "b" "FtoR(f)") (("1" (assert) (("1" (expand "isMax?") (("1" (ground) (("1" (inst - "float_int(0)") (("1" (ground) (("1" (expand "FtoR" + 1) (("1" (expand "float_int" 1) (("1" (assert) nil))))))) ("2" (expand "Fbounded?" 1) (("2" (assert) (("2" (expand "float_int" 1) (("2" (assert) (("2" (rewrite "abs_0") (("2" (assert) (("2" (typepred "dExp(b)") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "float_int") (("2" (expand "RND_float_Max") (("2" (expand "RND_aux_float") (("2" (lift-if) (("2" (ground) (("2" (rewrite "floor_int") (("2" (assert) (("2" (expand "FtoR") (("2" (propax) nil)))))))))))))))))))))))))))) nil) nil nil) (RND_float_Max_le_0-2 nil 3544962107 ("" (skeep) (("" (lemma "RND_float_Max_ge") (("" (inst - "b" "f" "float_int(0)") (("" (assert) (("" (case "FtoR(RND_float_Max(b)(float_int(0))) = 0") (("1" (expand "<=") (("1" (expand "<=") (("1" (rewrite "FleCorrect") (("1" (rewrite "FleCorrect") (("1" (assert) (("1" (rewrite "RND_float_Max_def") (("1" (rewrite "RND_float_Max_def") (("1" (lemma "RND_Max_isMax") (("1" (inst-cp - "b" "FtoR(float_int(0))") (("1" (inst - "b" "FtoR(f)") (("1" (assert) (("1" (expand "isMax?") (("1" (ground) (("1" (inst - "float_int(0)") (("1" (ground) (("1" (expand "FtoR" + 1) (("1" (expand "float_int" 1) (("1" (assert) nil))))))) ("2" (expand "Fbounded?" 1) (("2" (assert) (("2" (expand "float_int" 1) (("2" (assert) (("2" (rewrite "abs_0") (("2" (assert) (("2" (typepred "dExp(b)") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "float_int") (("2" (expand "RND_float_Max") (("2" (expand "RND_aux_float") (("2" (lift-if) (("2" (ground) (("2" (rewrite "floor_int") (("2" (assert) (("2" (expand "FtoR") (("2" (propax) nil)))))))))))))))))))))))))))) nil) nil nil) (RND_float_Max_le_0-1 nil 3544962078 ("" (postpone) nil nil) nil shostak)) (RND_float_Max_gt_0 0 (RND_float_Max_gt_0-1 nil 3544976824 ("" (skeep) (("" (lemma "RND_float_Min_gt_canonic") (("" (inst - "b" "f" "RND_float_Min(b)(float_int(0))") (("" (assert) (("" (expand ">") (("" (rewrite "FltCorrect") (("" (rewrite "FltCorrect") (("" (case "FtoR(RND_float_Min(b)(float_int(0))) = 0") (("1" (replaces -1) (("1" (ground) nil nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "RND_float_Min_def") (("2" (case "FtoR(float_int(0)) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (expand "RND_Min") (("1" (expand "RND_aux") (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (rewrite "floor_int") (("1" (expand "FtoR") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RND_float_Min_gt_canonic formula-decl nil float nil) (RND_float_Max const-decl "(Fcanonic?(b))" float nil) (FltCorrect formula-decl nil float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (FtoR const-decl "real" float nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (RND_float_Min_def formula-decl nil float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (expt def-decl "real" exponentiation nil) (RND_Min const-decl "(Fcanonic?(b))" float nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (floor_int formula-decl nil floor_ceil nil) (integer nonempty-type-from-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (RND_aux const-decl "(Fcanonic?(b))" float nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (> const-decl "bool" float nil) (> const-decl "bool" float nil) (float_int const-decl "float" float nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (RND_float_Min const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil)) (Fmult_canonic_id_Min_TCC1 0 (Fmult_canonic_id_Min_TCC1-1 nil 3545491200 ("" (skeep) (("" (expand "float_int") (("" (expand "Fbounded?") (("" (expand "vNum") (("" (assert) (("" (typepred "dExp(b)") (("" (assert) (("" (expand "abs") (("" (lemma "increasing_expt_aux") (("" (inst - "radix" "Prec(b)-2") (("" (assert) (("" (expand "^") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((float_int const-decl "float" float nil) (vNum const-decl "posnat" float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (radix formal-const-decl "above(1)" float nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (increasing_expt_aux formula-decl nil exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (posint_exp application-judgement "posint" exponentiation nil) (Fbounded? const-decl "bool" float nil)) nil (Fmult_canonic_id_Min subtype "float.float_int(1)" "(float.Fbounded?(float.b))"))) (Fmult_canonic_id_Min 0 (Fmult_canonic_id_Min-1 nil 3545491201 ("" (lemma "FcanonicUnique") (("" (skeep) (("" (inst?) (("" (inst - "b") (("" (assert) (("" (hide 2) (("" (rewrite "RND_float_Min_def") (("" (expand "*") (("" (rewrite "FmultCorrect") (("" (typepred "Fnormalize(b)(float_int(1))") (("" (replace -2) (("" (rewrite "float_int_def" +) (("" (assert) (("" (rewrite "RND_float_Min_def" :dir rl) (("" (lemma "RND_float_Min_canonic") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (float_int_def formula-decl nil float nil) (RND_float_Min_canonic formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (FmultCorrect formula-decl nil float nil) (RND_float_Min_def formula-decl nil float nil) (float_int const-decl "float" float nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (<= const-decl "bool" reals nil) (FtoR const-decl "real" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Fbounded? const-decl "bool" float nil) (* const-decl "float" float nil) (RND_float_Min const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (FcanonicUnique formula-decl nil float nil)) shostak)) (Fmult_canonic_id_Max 0 (Fmult_canonic_id_Max-1 nil 3545556316 ("" (lemma "FcanonicUnique") (("" (skeep) (("" (inst?) (("" (inst - "b") (("" (assert) (("" (hide 2) (("" (rewrite "RND_float_Max_def") (("" (expand "*") (("" (rewrite "FmultCorrect") (("" (typepred "Fnormalize(b)(float_int(1))") (("" (replace -2) (("" (rewrite "float_int_def" +) (("" (assert) (("" (rewrite "RND_float_Max_def" :dir rl) (("" (lemma "RND_float_Max_canonic") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (float_int_def formula-decl nil float nil) (RND_float_Max_canonic formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (FmultCorrect formula-decl nil float nil) (RND_float_Max_def formula-decl nil float nil) (float_int const-decl "float" float nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (<= const-decl "bool" reals nil) (FtoR const-decl "real" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Fbounded? const-decl "bool" float nil) (* const-decl "float" float nil) (RND_float_Max const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (FcanonicUnique formula-decl nil float nil)) nil)) (Fplus_canonic_id_Min_TCC1 0 (Fplus_canonic_id_Min_TCC1-1 nil 3545563549 ("" (subtype-tcc) nil nil) ((^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (vNum const-decl "posnat" float nil) (Fbounded? const-decl "bool" float nil) (Fnormal? const-decl "bool" float nil) (Fsubnormal? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil) (float_int const-decl "float" float nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (int_times_int_is_int application-judgement "int" integers nil)) nil (Fplus_canonic_id_Min subtype "float.float_int(0)" "(float.Fbounded?(float.b))"))) (Fplus_canonic_id_Min 0 (Fplus_canonic_id_Min-1 nil 3545563553 ("" (lemma "FcanonicUnique") (("" (skeep) (("" (inst?) (("" (inst - "b") (("" (assert) (("" (hide 2) (("" (rewrite "RND_float_Min_def") (("" (expand "+") (("" (rewrite "FplusCorrect") (("" (typepred "Fnormalize(b)(float_int(0))") (("" (replace -2) (("" (rewrite "float_int_def" +) (("" (assert) (("" (rewrite "RND_float_Min_def" :dir rl) (("" (lemma "RND_float_Min_canonic") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (float_int_def formula-decl nil float nil) (RND_float_Min_canonic formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (FplusCorrect formula-decl nil float nil) (RND_float_Min_def formula-decl nil float nil) (float_int const-decl "float" float nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (<= const-decl "bool" reals nil) (FtoR const-decl "real" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Fbounded? const-decl "bool" float nil) (+ const-decl "float" float nil) (RND_float_Min const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (FcanonicUnique formula-decl nil float nil)) nil)) (Fplus_canonic_id_Max 0 (Fplus_canonic_id_Max-1 nil 3545563562 ("" (lemma "FcanonicUnique") (("" (skeep) (("" (inst?) (("" (inst - "b") (("" (assert) (("" (hide 2) (("" (rewrite "RND_float_Max_def") (("" (expand "+") (("" (rewrite "FplusCorrect") (("" (typepred "Fnormalize(b)(float_int(0))") (("" (replace -2) (("" (rewrite "float_int_def" +) (("" (assert) (("" (rewrite "RND_float_Max_def" :dir rl) (("" (lemma "RND_float_Max_canonic") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (float_int_def formula-decl nil float nil) (RND_float_Max_canonic formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (FplusCorrect formula-decl nil float nil) (RND_float_Max_def formula-decl nil float nil) (float_int const-decl "float" float nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (<= const-decl "bool" reals nil) (FtoR const-decl "real" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Fbounded? const-decl "bool" float nil) (+ const-decl "float" float nil) (RND_float_Max const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Format type-eq-decl nil float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (FcanonicUnique formula-decl nil float nil)) nil)) (MaxSuccMin_TCC1 0 (MaxSuccMin_TCC1-1 nil 3319555845 ("" (skeep) (("" (rewrite "FcanonicBounded") nil nil)) nil) ((FcanonicBounded formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil)) nil (MaxSuccMin subtype "float.q" "(float.Fbounded?(float.b))"))) (MaxSuccMin 0 (MaxSuccMin-1 nil 3319555553 ("" (skeep) (("" (lemma "FcanonicUnique") (("" (inst -1 "b" "q" "Fsucc(b)(p)") (("" (rewrite -1) (("1" (hide -1 3) (("1" (expand* "isMin?" "isMax?") (("1" (flatten) (("1" (case "FtoR(Fsucc(b)(p)) <= FtoR(q)") (("1" (case "FtoR(q) <= FtoR(Fsucc(b)(p))") (("1" (assert) nil nil) ("2" (hide -1 3) (("2" (lemma "FpredLe") (("2" (inst -1 "b" "q" "Fsucc(b)(p)") (("2" (split -1) (("1" (flatten) (("1" (rewrite -2) (("1" (rewrite "FpredFsucc") (("1" (rewrite -4) (("1" (flip-ineq 1) (("1" (lemma "FpredLt") (("1" (inst -1 "b" "q") (("1" (flip-ineq -1) (("1" (hide 2 3 4) (("1" (inst -7 "Fpred(b)(q)") (("1" (assert) nil nil) ("2" (rewrite "FcanonicBounded") (("2" (rewrite "FpredCanonic") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") (("2" (rewrite "FpredCanonic") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FsuccCanonic") nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FsuccProp") nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FsuccCanonic") nil nil)) nil)) nil)) nil)) nil) ((FcanonicUnique formula-decl nil float nil) (isMax? const-decl "bool" float nil) (isMin? const-decl "bool" float nil) (FtoR const-decl "real" float nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (FsuccCanonic formula-decl nil float nil) (FpredFsucc formula-decl nil float nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (FcanonicBounded formula-decl nil float nil) (FpredCanonic formula-decl nil float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (>= const-decl "bool" reals nil) (FpredLt formula-decl nil float nil) (q skolem-const-decl "float" float nil) (Fpred const-decl "float" float nil) (b skolem-const-decl "Format" float nil) (Fbounded? const-decl "bool" float nil) (FpredLe formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FsuccProp formula-decl nil float nil) (Fsucc const-decl "float" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (LeMinMaxClosest 0 (LeMinMaxClosest-2 "" 3790102880 ("" (skeep) (("" (expand "Closest?") (("" (skosimp*) (("" (expand "abs" 1 2) (("" (grind-reals) (("1" (expand "isMin?") (("1" (flatten) (("1" (inst -5 "f!1") (("1" (hide (-1 -2 -3 -7)) (("1" (expand "abs" +) (("1" (lift-if) (("1" (ground) (("1" (expand "abs") (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "abs" -3 1) (("2" (case "abs(FtoR(p) - r) = r - FtoR(p)") (("1" (replaces -1) (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (case "FORALL (xrp:nnreal): abs(-xrp)=xrp") (("1" (inst - "r-FtoR(p)") (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs" +) (("2" (lift-if) (("2" (hide (-1 -2 -3 -4)) (("2" (expand "isMax?") (("2" (flatten) (("2" (inst - "f!1") (("2" (grind :exclude "FtoR") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Closest? const-decl "bool" float nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (both_sides_minus_le1 formula-decl nil real_props nil) (isMax? const-decl "bool" float nil) (isMin? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (FtoR const-decl "real" float nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (real nonempty-type-from-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (nnreal type-eq-decl nil real_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (real_minus_real_is_real application-judgement "real" reals nil)) shostak) (LeMinMaxClosest-1 nil 3321095498 ("" (skeep) (("" (expand "Closest?") (("" (skosimp*) (("" (expand "abs" 1 2) (("" (grind-reals) (("1" (expand "isMin?") (("1" (flatten) (("1" (inst -5 "f!1") (("1" (hide (-1 -2 -3 -7)) (("1" (expand "abs" +) (("1" (lift-if) (("1" (ground) (("1" (expand "abs") (("1" (assert) (("1" (lift-if) (("1" (split -) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs" -3 1) (("2" (case "abs(FtoR(p) - r) = r - FtoR(p)") (("1" (replaces -1) (("1" (expand "abs") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (case "FORALL (xrp:nnreal): abs(-xrp)=xrp") (("1" (inst - "r-FtoR(p)") (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "abs" +) (("2" (assert) (("2" (lift-if) (("2" (hide (-1 -2 -3 -4)) (("2" (expand "isMax?") (("2" (flatten) (("2" (inst - "f!1") (("2" (grind :exclude "FtoR") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (isMin_Total 0 (isMin_Total-2 "" 3790102881 ("" (skeep) (("" (expand "Total?") (("" (skeep) (("" (inst 1 "RND_Min(b)(r)") (("" (rewrite "RND_Min_isMin") nil nil)) nil)) nil)) nil)) nil) ((Total? const-decl "bool" float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (Fcanonic? const-decl "bool" float nil) (RND_Min const-decl "(Fcanonic?(b))" float nil) (RND_Min_isMin formula-decl nil float nil)) shostak) (isMin_Total-1 nil 3318936846 ("" (skeep) (("" (expand "Total?") (("" (skeep) (("" (inst 1 "RND_Min(b)(r)") (("1" (rewrite "RND_Min_isMin") nil nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil) nil shostak)) (isMin_Compatible 0 (isMin_Compatible-1 nil 3318887445 ("" (expand* "Compatible?" "isMin?") (("" (skosimp*) (("" (split) (("1" (grind-reals) nil nil) ("2" (skeep) (("2" (inst? -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Compatible? const-decl "bool" float nil) (isMin? const-decl "bool" float nil)) shostak)) (isMin_Monotone 0 (isMin_Monotone-1 nil 3318937046 ("" (expand* "Monotone?" "isMin?") (("" (skosimp*) (("" (rewrite -5) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Monotone? const-decl "bool" float nil) (isMin? const-decl "bool" float nil)) shostak)) (isMin_RoundedMode 0 (isMin_RoundedMode-1 nil 3318937262 ("" (expand "RoundedMode?") (("" (skeep) (("" (split) (("1" (rewrite "isMin_Total") nil nil) ("2" (rewrite "isMin_Compatible") nil nil) ("3" (expand "MinOrMax?") (("3" (skeep) nil nil)) nil) ("4" (rewrite "isMin_Monotone") nil nil)) nil)) nil)) nil) ((isMin_Monotone formula-decl nil float nil) (MinOrMax? const-decl "bool" float nil) (isMin_Compatible formula-decl nil float nil) (isMin_Total formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (RoundedMode? const-decl "bool" float nil)) shostak)) (isMin_Unique 0 (isMin_Unique-1 nil 3318937365 ("" (expand* "Unique?" "isMin?") (("" (skosimp*) (("" (case "FtoR(f1!1) <= FtoR(f2!1)") (("1" (case "FtoR(f2!1) <= FtoR(f1!1)") (("1" (assert) nil nil) ("2" (rewrite -3) nil nil)) nil) ("2" (rewrite -4) nil nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (<= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (FtoR const-decl "real" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (Unique? const-decl "bool" float nil) (isMin? const-decl "bool" float nil)) shostak)) (isMax_Total 0 (isMax_Total-1 nil 3319385838 ("" (expand "Total?") (("" (skeep) (("" (skeep) (("" (inst 1 "Fopp(RND_Min(b)(-r))") (("1" (case-replace "r=--r") (("1" (rewrite "MinOppMax") (("1" (rewrite "RND_Min_isMin") nil nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (rewrite "FoppBounded") (("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil)) nil) ((minus_real_is_real application-judgement "real" reals nil) (r skolem-const-decl "real" float nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (RND_Min const-decl "(Fcanonic?(b))" float nil) (Fcanonic? const-decl "bool" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Fopp const-decl "float" float nil) (b skolem-const-decl "Format" float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (MinOppMax formula-decl nil float nil) (RND_Min_isMin formula-decl nil float nil) (FcanonicBounded formula-decl nil float nil) (= const-decl "[T, T -> boolean]" equalities nil) (FoppBounded formula-decl nil float nil) (Total? const-decl "bool" float nil)) shostak)) (isMax_Compatible 0 (isMax_Compatible-1 nil 3318937526 ("" (expand* "Compatible?" "isMax?") (("" (skosimp*) (("" (split) (("1" (grind-reals) nil nil) ("2" (skeep) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ((Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Compatible? const-decl "bool" float nil) (isMax? const-decl "bool" float nil)) shostak)) (isMax_Monotone 0 (isMax_Monotone-1 nil 3318937580 ("" (expand* "Monotone?" "isMax?") (("" (skosimp*) (("" (grind-reals) nil nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Monotone? const-decl "bool" float nil) (isMax? const-decl "bool" float nil)) shostak)) (isMax_RoundedMode 0 (isMax_RoundedMode-1 nil 3318937619 ("" (expand* "RoundedMode?") (("" (skeep) (("" (split) (("1" (rewrite "isMax_Total") nil nil) ("2" (rewrite "isMax_Compatible") nil nil) ("3" (expand "MinOrMax?") (("3" (skeep) nil nil)) nil) ("4" (rewrite "isMax_Monotone") nil nil)) nil)) nil)) nil) ((isMax_Monotone formula-decl nil float nil) (MinOrMax? const-decl "bool" float nil) (isMax_Compatible formula-decl nil float nil) (isMax_Total formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (RoundedMode? const-decl "bool" float nil)) shostak)) (isMax_Unique 0 (isMax_Unique-1 nil 3318938203 ("" (expand* "Unique?" "isMax?") (("" (skosimp*) (("" (case "FtoR(f1!1) <= FtoR(f2!1)") (("1" (case "FtoR(f2!1) <= FtoR(f1!1)") (("1" (assert) nil nil) ("2" (grind-reals) nil nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (<= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (FtoR const-decl "real" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (Unique? const-decl "bool" float nil) (isMax? const-decl "bool" float nil)) shostak)) (ToZero_Total 0 (ToZero_Total-1 nil 3319469754 ("" (skeep) (("" (expand "Total?") (("" (skeep) (("" (expand "ToZero?") (("" (grind-reals) (("" (case "0 <= r") (("1" (assert) (("1" (lemma "isMin_Total") (("1" (expand "Total?") (("1" (inst -1 "b" "r") nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "isMax_Total") (("2" (expand "Total?") (("2" (inst -1 "b" "r") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Total? const-decl "bool" float nil) (ToZero? const-decl "bool" float nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (isMin_Total formula-decl nil float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (isMax_Total formula-decl nil float nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (ToZero_Compatible 0 (ToZero_Compatible-1 nil 3319470173 ("" (expand "Compatible?") (("" (skosimp*) (("" (expand "ToZero?") (("" (grind-reals) (("1" (lemma "isMin_Compatible") (("1" (expand "Compatible?") (("1" (inst -1 "b!1" "r1!1" "r2!1" "f1!1" "f2!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "isMax_Compatible") (("2" (expand "Compatible?") (("2" (inst -1 "b!1" "r1!1" "r2!1" "f1!1" "f2!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (isMin_Compatible formula-decl nil float nil) (isMax_Compatible formula-decl nil float nil) (ToZero? const-decl "bool" float nil) (Compatible? const-decl "bool" float nil)) shostak)) (ToZero_MinOrMax 0 (ToZero_MinOrMax-1 nil 3319470366 ("" (expand* "MinOrMax?" "ToZero?") (("" (skeep) (("" (skeep) (("" (assert) nil nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (MinOrMax? const-decl "bool" float nil) (ToZero? const-decl "bool" float nil)) shostak)) (ToZero_Monotone 0 (ToZero_Monotone-1 nil 3319470437 ("" (expand "Monotone?") (("" (skeep) (("" (skeep) (("" (expand "ToZero?") (("" (grind-reals) (("1" (lemma "isMin_Monotone") (("1" (expand "Monotone?") (("1" (inst -1 "b" "r1" "r2" "f1" "f2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (case " FtoR(f1) <=0") (("1" (case "0<= FtoR(f2)") (("1" (assert) nil nil) ("2" (hide -1 -2 -3 -4 2) (("2" (expand "isMin?") (("2" (flatten) (("2" (inst -3 "(# Fnum:=0, Fexp:=0#)") (("1" (expand* "FtoR") (("1" (grind-reals) nil nil)) nil) ("2" (expand "Fbounded?") (("2" (grind-reals) (("2" (expand "abs" 1) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -4 -5 2) (("2" (expand "isMax?") (("2" (flatten) (("2" (inst -3 "(# Fnum:=0, Fexp:=0#)") (("1" (expand* "FtoR") (("1" (grind-reals) nil nil)) nil) ("2" (expand "Fbounded?") (("2" (grind-reals) (("2" (expand "abs" 1) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "isMax_Monotone") (("3" (expand "Monotone?") (("3" (inst -1 "b" "r1" "r2" "f1" "f2") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ToZero? const-decl "bool" float nil) (isMax_Monotone formula-decl nil float nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (neg_times_le formula-decl nil real_props nil) (isMax? const-decl "bool" float nil) (isMin? const-decl "bool" float nil) (b skolem-const-decl "Format" float nil) (expt_x0 formula-decl nil exponentiation nil) (pos_times_le formula-decl nil real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (zero_is_neg_zero formula-decl nil real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (<= const-decl "bool" reals nil) (FtoR const-decl "real" float nil) (isMin_Monotone formula-decl nil float nil) (Fbounded? const-decl "bool" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (Monotone? const-decl "bool" float nil)) shostak)) (ToZero_RoundedMode 0 (ToZero_RoundedMode-1 nil 3319471412 ("" (skeep) (("" (expand "RoundedMode?") (("" (split) (("1" (rewrite "ToZero_Total") nil nil) ("2" (rewrite "ToZero_Compatible") nil nil) ("3" (rewrite "ToZero_MinOrMax") nil nil) ("4" (rewrite "ToZero_Monotone") nil nil)) nil)) nil)) nil) ((RoundedMode? const-decl "bool" float nil) (ToZero_Monotone formula-decl nil float nil) (ToZero_MinOrMax formula-decl nil float nil) (ToZero_Compatible formula-decl nil float nil) (ToZero_Total formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil)) shostak)) (ToZero_Unique 0 (ToZero_Unique-1 nil 3319471464 ("" (expand "Unique?") (("" (skeep) (("" (skeep) (("" (expand "ToZero?") (("" (grind-reals) (("1" (lemma "isMin_Unique") (("1" (expand "Unique?") (("1" (inst -1 "b" "r" "f1" "f2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "isMax_Unique") (("2" (expand "Unique?") (("2" (inst -1 "b" "r" "f1" "f2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ToZero? const-decl "bool" float nil) (isMax_Unique formula-decl nil float nil) (isMin_Unique formula-decl nil float nil) (Fbounded? const-decl "bool" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Unique? const-decl "bool" float nil)) shostak)) (Closest_Total 0 (Closest_Total-1 nil 3319471553 ("" (skeep) (("" (lemma "isMin_Total") (("" (lemma "isMax_Total") (("" (expand "Total?") (("" (skeep) (("" (inst -1 "b" "r") (("" (inst -2 "b" "r") (("" (skosimp*) (("" (case "abs(FtoR(f!1)-r)<= abs(FtoR(f!2)-r)") (("1" (inst 1 "f!1") (("1" (expand "Closest?") (("1" (skosimp*) (("1" (expand* "isMin?" "isMax?") (("1" (flatten) (("1" (case " FtoR(f!3) <= r") (("1" (expand* "abs") (("1" (grind-reals) nil nil)) nil) ("2" (expand* "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (inst 1 "f!2") (("2" (expand* "Closest?" "isMin?" "isMax?") (("2" (flatten) (("2" (skosimp*) (("2" (case "FtoR(f!3) <= r") (("1" (expand* "abs") (("1" (grind-reals) nil nil)) nil) ("2" (expand* "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((isMin_Total formula-decl nil float nil) (Total? const-decl "bool" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_minus_gt1 formula-decl nil real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (both_sides_minus_le1 formula-decl nil real_props nil) (isMin? const-decl "bool" float nil) (isMax? const-decl "bool" float nil) (Closest? const-decl "bool" float nil) (real_minus_real_is_real application-judgement "real" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (FtoR const-decl "real" float nil) (Fbounded? const-decl "bool" float nil) (isMax_Total formula-decl nil float nil)) shostak)) (Closest_total 0 (Closest_total-1 nil 3681747416 ("" (skeep) (("" (lemma "isMin_Total") (("" (lemma "isMax_Total") (("" (expand "Total?") (("" (expand "total?") (("" (skeep) (("" (inst -1 "b" "r") (("" (inst -2 "b" "r") (("" (skosimp*) (("" (case "abs(FtoR(f!1)-r)<= abs(FtoR(f!2)-r)") (("1" (inst 1 "f!1") (("1" (expand "Closest?") (("1" (skosimp*) (("1" (expand* "isMin?" "isMax?") (("1" (flatten) (("1" (case " FtoR(f!3) <= r") (("1" (expand* "abs") (("1" (grind-reals) nil nil)) nil) ("2" (expand* "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (inst 1 "f!2") (("2" (expand* "Closest?" "isMin?" "isMax?") (("2" (flatten) (("2" (skosimp*) (("2" (case "FtoR(f!3) <= r") (("1" (expand* "abs") (("1" (grind-reals) nil nil)) nil) ("2" (expand* "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((isMin_Total formula-decl nil float nil) (Total? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (FtoR const-decl "real" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (Closest? const-decl "bool" float nil) (isMax? const-decl "bool" float nil) (isMin? const-decl "bool" float nil) (both_sides_minus_le1 formula-decl nil real_props nil) (minus_real_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_minus_gt1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (total? const-decl "bool" float nil) (isMax_Total formula-decl nil float nil)) shostak)) (Closest_Compatible 0 (Closest_Compatible-1 nil 3319474184 ("" (expand "Compatible?") (("" (skeep) (("" (skeep) (("" (expand "Closest?") (("" (skosimp*) (("" (inst -1 "f!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (Closest? const-decl "bool" float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Compatible? const-decl "bool" float nil)) shostak)) (Closest_compatible 0 (Closest_compatible-1 nil 3681747654 ("" (skeep) (("" (expand "compatible?") (("" (skeep) (("" (expand "Closest?") (("" (skosimp*) (("" (inst -1 "f!1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((compatible? const-decl "bool" float nil) (real_minus_real_is_real application-judgement "real" reals nil) (Closest? const-decl "bool" float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (Closest_MinOrMax 0 (Closest_MinOrMax-1 nil 3319474295 ("" (expand "MinOrMax?") (("" (skeep) (("" (skosimp*) (("" (case "r!1<= FtoR(f!1)") (("1" (hide 1) (("1" (expand* "isMax?" "Closest?") (("1" (split) (("1" (propax) nil nil) ("2" (skosimp*) (("2" (inst -3 "f!2") (("2" (expand "abs" -3) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (hide 2) (("2" (expand* "isMin?" "Closest?") (("2" (split) (("1" (assert) nil nil) ("2" (skosimp*) (("2" (inst -3 "f!2") (("2" (expand "abs" -3) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Fbounded? const-decl "bool" float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (FtoR const-decl "real" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Closest? const-decl "bool" float nil) (real_minus_real_is_real application-judgement "real" reals nil) (isMax? const-decl "bool" float nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (isMin? const-decl "bool" float nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (MinOrMax? const-decl "bool" float nil)) shostak)) (Closest_min_or_max 0 (Closest_min_or_max-1 nil 3681747767 ("" (expand "min_or_max?") (("" (skeep) (("" (skosimp*) (("" (case "r!1<= FtoR(f!1)") (("1" (hide 1) (("1" (expand* "isMax?" "Closest?") (("1" (split) (("1" (propax) nil nil) ("2" (skosimp*) (("2" (inst -3 "f!2") (("2" (expand "abs" -3) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (hide 2) (("2" (expand* "isMin?" "Closest?") (("2" (split) (("1" (assert) nil nil) ("2" (skosimp*) (("2" (inst -3 "f!2") (("2" (expand "abs" -3) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Fbounded? const-decl "bool" float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (FtoR const-decl "real" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Closest? const-decl "bool" float nil) (real_minus_real_is_real application-judgement "real" reals nil) (isMax? const-decl "bool" float nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (isMin? const-decl "bool" float nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (min_or_max? const-decl "bool" float nil)) shostak)) (Closest_Monotone 0 (Closest_Monotone-1 nil 3319474619 ("" (expand "Monotone?") (("" (skeep) (("" (skeep) (("" (expand "Closest?") (("" (inst -2 "f2") (("" (inst -3 "f1") (("" (expand* "abs") (("" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (Closest? const-decl "bool" float nil) (minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Monotone? const-decl "bool" float nil)) shostak)) (Closest_monotone 0 (Closest_monotone-1 nil 3681747846 ("" (expand "monotone?") (("" (skeep) (("" (skeep) (("" (expand "Closest?") (("" (inst -2 "f2") (("" (inst -3 "f1") (("" (expand* "abs") (("" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (Closest? const-decl "bool" float nil) (minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (monotone? const-decl "bool" float nil)) shostak)) (Closest_RoundedMode 0 (Closest_RoundedMode-1 nil 3319474736 ("" (skeep) (("" (expand "RoundedMode?") (("" (split) (("1" (rewrite "Closest_Total") nil nil) ("2" (rewrite "Closest_Compatible") nil nil) ("3" (rewrite "Closest_MinOrMax") nil nil) ("4" (rewrite "Closest_Monotone") nil nil)) nil)) nil)) nil) ((RoundedMode? const-decl "bool" float nil) (Closest_Monotone formula-decl nil float nil) (Closest_MinOrMax formula-decl nil float nil) (Closest_Compatible formula-decl nil float nil) (Closest_Total formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil)) shostak)) (Closest_rounded_mode 0 (Closest_rounded_mode-1 nil 3681744086 ("" (skeep) (("" (expand "rounded_mode?") (("" (split 1) (("1" (use "Closest_total") nil nil) ("2" (use "Closest_compatible") nil nil) ("3" (use "Closest_min_or_max") nil nil) ("4" (use "Closest_monotone") nil nil)) nil)) nil)) nil) ((rounded_mode? const-decl "bool" float nil) (Closest_monotone formula-decl nil float nil) (Closest_min_or_max formula-decl nil float nil) (Closest_compatible formula-decl nil float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Closest_total formula-decl nil float nil)) shostak)) (RND_EClosest_isEclosest 0 (RND_EClosest_isEclosest-2 "" 3790102908 ("" (skeep) (("" (expand "RND_EClosest") (("" (grind-reals) (("1" (expand "EvenClosest?") (("1" (case "Closest?(b)(r, RND_Min(b)(r))") (("1" (split) (("1" (propax) nil nil) ("2" (skosimp*) (("2" (lemma "Closest_MinOrMax") (("2" (expand "MinOrMax?") (("2" (inst -1 "b" "r" "f!1") (("2" (split) (("1" (lemma "isMin_Unique") (("1" (expand "Unique?") (("1" (inst -1 "b" "r" "f!1" "RND_Min(b)(r)") (("1" (assert) (("1" (rewrite "RND_Min_isMin") nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Closest?" -2) (("2" (inst -2 "RND_Min(b)(r)") (("2" (flip-ineq -2) (("2" (case-replace "FtoR(f!1) = FtoR(RND_Max(b)(r))") (("1" (assert) nil nil) ("2" (lemma "isMax_Unique") (("2" (expand "Unique?") (("2" (inst -1 "b" "r" "f!1" "RND_Max(b)(r)") (("2" (assert) (("2" (rewrite "RND_Max_isMax") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r")) (("2" (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r")) (("2" (expand* "isMin?" "isMax?" "Closest?") (("2" (flatten) (("2" (skosimp*) (("2" (case "FtoR(f!1) <= r") (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil) ("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (expand "EvenClosest?") (("2" (case "Closest?(b)(r, RND_Max(b)(r))") (("1" (split) (("1" (propax) nil nil) ("2" (skosimp*) (("2" (lemma "Closest_MinOrMax") (("2" (expand "MinOrMax?") (("2" (inst -1 "b" "r" "f!1") (("2" (split) (("1" (expand "Closest?" -2) (("1" (inst -2 "RND_Max(b)(r)") (("1" (flip-ineq -2) (("1" (case-replace "FtoR(f!1) = FtoR(RND_Min(b)(r))") (("1" (assert) nil nil) ("2" (lemma "isMin_Unique") (("2" (expand "Unique?") (("2" (inst -1 "b" "r" "f!1" "RND_Min(b)(r)") (("2" (assert) (("2" (rewrite "RND_Min_isMin") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "isMax_Unique") (("2" (expand "Unique?") (("2" (inst -1 "b" "r" "f!1" "RND_Max(b)(r)") (("2" (assert) (("2" (rewrite "RND_Max_isMax") nil nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r")) (("2" (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r")) (("2" (expand* "isMin?" "isMax?" "Closest?") (("2" (flatten) (("2" (skosimp*) (("2" (case "FtoR(f!1) <= r") (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil) ("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "EvenClosest?") (("3" (split) (("1" (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r")) (("1" (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r")) (("1" (expand* "isMin?" "isMax?" "Closest?") (("1" (flatten) (("1" (skosimp*) (("1" (case "FtoR(f!1) <= r") (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil) ("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "MaxSuccMin") (("2" (lemma "OddFsuccEven") (("2" (inst -2 "b" "RND_Min(b)(r)" "RND_Max(b)(r)" "r") (("2" (split) (("1" (inst -2 "b" "RND_Min(b)(r)") (("1" (split -2) (("1" (case-replace "Fnormalize(b)(RND_Max(b)(r))=RND_Max(b)(r)") (("1" (assert) nil nil) ("2" (rewrite "FcanonicUnique" :subst ("b" "b")) nil nil)) nil) ("2" (lemma "odd_or_even_int" :subst ("x" "Fnum(RND_Min(b)(r))")) (("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (rewrite "RND_Max_isMax") nil nil) ("4" (rewrite "RND_Min_isMin") nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (expand "EvenClosest?") (("4" (case "Closest?(b)(r, RND_Min(b)(r))") (("1" (split) (("1" (propax) nil nil) ("2" (skosimp*) (("2" (lemma "Closest_MinOrMax") (("2" (expand "MinOrMax?") (("2" (inst -1 "b" "r" "f!1") (("2" (split) (("1" (lemma "isMin_Unique") (("1" (expand "Unique?") (("1" (inst -1 "b" "r" "f!1" "RND_Min(b)(r)") (("1" (assert) (("1" (rewrite "RND_Min_isMin") nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "isMax_Unique") (("2" (expand "Unique?") (("2" (inst -1 "b" "r" "f!1" "RND_Max(b)(r)") (("2" (assert) (("2" (rewrite "RND_Max_isMax") nil nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r")) (("2" (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r")) (("2" (expand* "isMin?" "isMax?" "Closest?") (("2" (flatten) (("2" (skosimp*) (("2" (case "FtoR(f!1) <= r") (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil) ("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (flip-ineq 2) (("5" (expand "EvenClosest?") (("5" (case "Closest?(b)(r, RND_Min(b)(r))") (("1" (split) (("1" (propax) nil nil) ("2" (case-replace "Fnormalize(b)(RND_Min(b)(r))=RND_Min(b)(r)") (("1" (assert) nil nil) ("2" (rewrite "FcanonicUnique" :subst ("b" "b")) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r")) (("2" (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r")) (("2" (expand* "isMin?" "isMax?" "Closest?") (("2" (flatten) (("2" (skosimp*) (("2" (case "FtoR(f!1) <= r") (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil) ("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (RND_EClosest const-decl "(Fcanonic?(b))" float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_minus_le formula-decl nil real_props nil) (OddFsuccEven formula-decl nil float nil) (FcanonicUnique formula-decl nil float nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (odd_or_even_int formula-decl nil naturalnumbers nil) (MaxSuccMin formula-decl nil float nil) (both_sides_minus_le1 formula-decl nil real_props nil) (EvenClosest? const-decl "bool" float nil) (<= const-decl "bool" reals nil) (minus_real_is_real application-judgement "real" reals nil) (isMin? const-decl "bool" float nil) (isMax? const-decl "bool" float nil) (Closest_MinOrMax formula-decl nil float nil) (> const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (FtoR const-decl "real" float nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (isMax_Unique formula-decl nil float nil) (RND_Max_isMax formula-decl nil float nil) (= const-decl "[T, T -> boolean]" equalities nil) (RND_Max const-decl "(Fcanonic?(b))" float nil) (isMin_Unique formula-decl nil float nil) (RND_Min_isMin formula-decl nil float nil) (Unique? const-decl "bool" float nil) (MinOrMax? const-decl "bool" float nil) (Format type-eq-decl nil float nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Fbounded? const-decl "bool" float nil) (Closest? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil) (RND_Min const-decl "(Fcanonic?(b))" float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak) (RND_EClosest_isEclosest-1 nil 3319900439 ("" (skeep) (("" (expand "RND_EClosest") (("" (grind-reals) (("1" (expand "EvenClosest?") (("1" (case "Closest?(b)(r, RND_Min(b)(r))") (("1" (split) (("1" (propax) nil nil) ("2" (skosimp*) (("2" (lemma "Closest_MinOrMax") (("2" (expand "MinOrMax?") (("2" (inst -1 "b" "r" "f!1") (("2" (split) (("1" (lemma "isMin_Unique") (("1" (expand "Unique?") (("1" (inst -1 "b" "r" "f!1" "RND_Min(b)(r)") (("1" (assert) (("1" (rewrite "RND_Min_isMin") nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Closest?" -2) (("2" (inst -2 "RND_Min(b)(r)") (("2" (flip-ineq -2) (("2" (case-replace "FtoR(f!1) = FtoR(RND_Max(b)(r))") (("1" (assert) nil nil) ("2" (lemma "isMax_Unique") (("2" (expand "Unique?") (("2" (inst -1 "b" "r" "f!1" "RND_Max(b)(r)") (("1" (assert) (("1" (rewrite "RND_Max_isMax") nil nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r")) (("2" (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r")) (("2" (expand* "isMin?" "isMax?" "Closest?") (("2" (flatten) (("2" (skosimp*) (("2" (case "FtoR(f!1) <= r") (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil) ("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ("2" (hide 1) (("2" (expand "EvenClosest?") (("2" (case "Closest?(b)(r, RND_Max(b)(r))") (("1" (split) (("1" (propax) nil nil) ("2" (skosimp*) (("2" (lemma "Closest_MinOrMax") (("2" (expand "MinOrMax?") (("2" (inst -1 "b" "r" "f!1") (("2" (split) (("1" (expand "Closest?" -2) (("1" (inst -2 "RND_Max(b)(r)") (("1" (flip-ineq -2) (("1" (case-replace "FtoR(f!1) = FtoR(RND_Min(b)(r))") (("1" (assert) nil nil) ("2" (lemma "isMin_Unique") (("2" (expand "Unique?") (("2" (inst -1 "b" "r" "f!1" "RND_Min(b)(r)") (("1" (assert) (("1" (rewrite "RND_Min_isMin") nil nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "isMax_Unique") (("2" (expand "Unique?") (("2" (inst -1 "b" "r" "f!1" "RND_Max(b)(r)") (("2" (assert) (("2" (rewrite "RND_Max_isMax") nil nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r")) (("2" (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r")) (("2" (expand* "isMin?" "isMax?" "Closest?") (("2" (flatten) (("2" (skosimp*) (("2" (case "FtoR(f!1) <= r") (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil) ("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil) ("3" (expand "EvenClosest?") (("3" (split) (("1" (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r")) (("1" (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r")) (("1" (expand* "isMin?" "isMax?" "Closest?") (("1" (flatten) (("1" (skosimp*) (("1" (case "FtoR(f!1) <= r") (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil) ("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (lemma "MaxSuccMin") (("2" (lemma "OddFsuccEven") (("2" (inst -2 "b" "RND_Min(b)(r)" "RND_Max(b)(r)" "r") (("2" (split) (("1" (inst -2 "b" "RND_Min(b)(r)") (("1" (split -2) (("1" (case-replace "Fnormalize(b)(RND_Max(b)(r))=RND_Max(b)(r)") (("1" (assert) nil nil) ("2" (rewrite "FcanonicUnique" :subst ("b" "b")) nil nil)) nil) ("2" (lemma "odd_or_even_int" :subst ("x" "Fnum(RND_Min(b)(r))")) (("2" (assert) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (rewrite "RND_Max_isMax") nil nil) ("4" (rewrite "RND_Min_isMin") nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (expand "EvenClosest?") (("4" (case "Closest?(b)(r, RND_Min(b)(r))") (("1" (split) (("1" (propax) nil nil) ("2" (skosimp*) (("2" (lemma "Closest_MinOrMax") (("2" (expand "MinOrMax?") (("2" (inst -1 "b" "r" "f!1") (("2" (split) (("1" (lemma "isMin_Unique") (("1" (expand "Unique?") (("1" (inst -1 "b" "r" "f!1" "RND_Min(b)(r)") (("1" (assert) (("1" (rewrite "RND_Min_isMin") nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "isMax_Unique") (("2" (expand "Unique?") (("2" (inst -1 "b" "r" "f!1" "RND_Max(b)(r)") (("1" (assert) (("1" (rewrite "RND_Max_isMax") nil nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r")) (("2" (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r")) (("2" (expand* "isMin?" "isMax?" "Closest?") (("2" (flatten) (("2" (skosimp*) (("2" (case "FtoR(f!1) <= r") (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil) ("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil) ("5" (flip-ineq 2) (("5" (expand "EvenClosest?") (("5" (case "Closest?(b)(r, RND_Min(b)(r))") (("1" (split) (("1" (propax) nil nil) ("2" (case-replace "Fnormalize(b)(RND_Min(b)(r))=RND_Min(b)(r)") (("1" (assert) nil nil) ("2" (rewrite "FcanonicUnique" :subst ("b" "b")) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "RND_Min_isMin" :subst ("b" "b" "r" "r")) (("2" (lemma "RND_Max_isMax" :subst ("b" "b" "r" "r")) (("2" (expand* "isMin?" "isMax?" "Closest?") (("2" (flatten) (("2" (skosimp*) (("2" (case "FtoR(f!1) <= r") (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil) ("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (Closest_bounded_exact_rep_TCC1 0 (Closest_bounded_exact_rep_TCC1-1 nil 3698163284 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (Rounding type-eq-decl nil float nil) (RNDF type-eq-decl nil float nil) (Closest? const-decl "bool" float nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nat_exp application-judgement "nat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (hat_02n formula-decl nil power_series series) (vNum const-decl "posnat" float nil) (/= const-decl "boolean" notequal nil)) nil (Closest_bounded_exact_rep subtype "float.exp" "{i: integers.int | booleans.OR(float.radix /= 0, reals.>=(i, 0))}"))) (Closest_bounded_exact_rep 0 (Closest_bounded_exact_rep-1 nil 3698163434 ("" (skeep*) (("" (expand "exactly_representable") (("" (typepred "RtoF") (("" (expand "Closest?") (("" (inst -2 "x") (("" (inst -2 "float_pair(num,exp)") (("1" (hide -1) (("1" (expand "FtoR" -1 2) (("1" (expand "float_pair") (("1" (replace -4 -1 :dir rl) (("1" (assert) (("1" (expand "abs" -1 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Fbounded?") (("2" (expand "float_pair") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((exactly_representable const-decl "bool" float nil) (real_minus_real_is_real application-judgement "real" reals nil) (exp skolem-const-decl "int" float nil) (num skolem-const-decl "int" float nil) (float_pair const-decl "float" float nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (b skolem-const-decl "Format" float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (FtoR const-decl "real" float nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (minus_even_is_even application-judgement "even_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (Rounding type-eq-decl nil float nil) (RNDF type-eq-decl nil float nil) (Closest? const-decl "bool" float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (ClosestRtoF_exact_rep_conv 0 (ClosestRtoF_exact_rep_conv-1 nil 3698165766 ("" (skeep*) (("" (expand "exact_rep_conservation") (("" (skeep*) (("" (use "Closest_bounded_exact_rep") (("" (assert) (("" (hide 2) (("" (inst 1 "Fnum(f)" "n+Fexp(f)") (("" (expand "FtoR") (("" (typepred "f") (("" (expand "Fbounded?") (("" (flatten) (("" (assert) (("" (use "expt_plus") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_exp application-judgement "posint" exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (exact_rep_conservation const-decl "bool" float nil) (Closest_bounded_exact_rep formula-decl nil float nil) (FtoR const-decl "real" float nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (> const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (Closest? const-decl "bool" float nil) (RNDF type-eq-decl nil float nil) (Rounding type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_plus formula-decl nil exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (Closest_int_exact_rep 0 (Closest_int_exact_rep-1 nil 3698097844 ("" (skeep*) (("" (case "abs(z)=vNum(b)") (("1" (expand "exactly_representable") (("1" (typepred "RtoF") (("1" (inst -2 "z") (("1" (expand "Closest?") (("1" (expand "abs" -3) (("1" (lift-if -3) (("1" (split -3) (("1" (flatten) (("1" (inst -4 "float_pair(-vNum(b)/radix,1)") (("1" (grind-reals -4) nil nil) ("2" (expand "Fbounded?") (("2" (split 1) (("1" (expand "float_pair") (("1" (expand "abs") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (case "-(-vNum(b) / radix) = vNum(b) / radix") (("1" (replace -1 :hide? t) (("1" (typepred "radix") (("1" (lemma "lt_div_lt_pos1") (("1" (inst -1 "vNum(b)" "1" "radix" "vNum(b)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (grind-reals 2) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "float_pair") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "vNum") (("3" (case "-radix ^ Prec(b) / radix = - (radix^Prec(b)/radix)") (("1" (replace -1 :hide? t) (("1" (lemma "expt_x1") (("1" (case "radix ^ Prec(b) / radix = radix ^ (Prec(b)-1)") (("1" (replace -1 :hide? t) (("1" (subtype-tcc) nil nil)) nil) ("2" (lemma "expt_div") (("2" (inst -1 "Prec(b)" "1" "radix") (("2" (inst -2 "radix") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1 :hide? t) (("2" (inst -2 "float_pair(vNum(b)/radix,1)") (("1" (grind-reals -2) nil nil) ("2" (expand "float_pair") (("2" (expand "Fbounded?") (("2" (split 1) (("1" (case "abs(vNum(b) / radix) = vNum(b) / radix") (("1" (replace -1 :hide? t) (("1" (lemma "lt_div_lt_pos1") (("1" (inst -1 "vNum(b)" "1" "radix" "vNum(b)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "vNum") (("3" (case "radix ^ Prec(b) / radix = radix ^ (Prec(b)-1)") (("1" (replace -1 :hide? t) (("1" (subtype-tcc) nil nil)) nil) ("2" (lemma "expt_div") (("2" (inst -1 "Prec(b)" "1" "radix") (("2" (lemma "expt_x1") (("2" (inst -1 "radix") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "Closest_bounded_exact_rep") (("2" (assert) (("2" (hide 3) (("2" (inst 1 "z" "0") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vNum const-decl "posnat" float nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (real nonempty-type-from-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (float type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (Rounding type-eq-decl nil float nil) (RNDF type-eq-decl nil float nil) (Closest? const-decl "bool" float nil) (real_minus_real_is_real application-judgement "real" reals nil) (neg_times_lt formula-decl nil real_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_div formula-decl nil exponentiation nil) (expt_x1 formula-decl nil exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (div_mult_pos_lt1 formula-decl nil real_props nil) (zero_times1 formula-decl nil real_props nil) (lt_div_lt_pos1 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (FtoR const-decl "real" float nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (div_cancel2 formula-decl nil real_props nil) (minus_rat_is_rat application-judgement "rat" rationals nil) (rat_abs_is_nonneg application-judgement "{r: nonneg_rat | r >= q}" real_defs nil) (float_pair const-decl "float" float nil) (radix formal-const-decl "above(1)" float nil) (b skolem-const-decl "Format" float nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (exactly_representable const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil) (expt_x0 formula-decl nil exponentiation nil) (Closest_bounded_exact_rep formula-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (ClosestRNDF_FtoR_inverse 0 (ClosestRNDF_FtoR_inverse-1 nil 3698149233 ("" (skeep*) (("" (expand "FtoR_inverse") (("" (skeep) (("" (case "NOT FtoR(RtoF(FtoR(f))) = FtoR(f)") (("1" (hide 2) (("1" (typepred "RtoF") (("1" (typepred "round") (("1" (inst -2 "FtoR(f)") (("1" (inst? -1 :where -2) (("1" (assert) (("1" (expand "Closest?") (("1" (inst -1 "f") (("1" (assert) (("1" (expand "abs" -1 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "FcanonicUnique") (("2" (assert) (("2" (hide-all-but 1) (("2" (typepred "RtoF") (("2" (inst? -2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FtoR_inverse const-decl "bool" float nil) (CanonicRoundingFun type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil) (RNDF type-eq-decl nil float nil) (ClosestRoundingPred type-eq-decl nil float nil) (Closest? const-decl "bool" float nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Rounding type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (FtoR const-decl "real" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (minus_even_is_even application-judgement "even_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (FcanonicUnique formula-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (EvenClosest_Total 0 (EvenClosest_Total-2 "" 3790102917 ("" (skeep) (("" (expand "Total?") (("" (skeep) (("" (inst 1 "RND_EClosest(b)(r)") (("" (rewrite "RND_EClosest_isEclosest") nil nil)) nil)) nil)) nil)) nil) ((Total? const-decl "bool" float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (Fcanonic? const-decl "bool" float nil) (RND_EClosest const-decl "(Fcanonic?(b))" float nil) (RND_EClosest_isEclosest formula-decl nil float nil)) shostak) (EvenClosest_Total-1 nil 3319540196 ("" (skeep) (("" (expand "Total?") (("" (skeep) (("" (inst 1 "RND_EClosest(b)(r)") (("1" (rewrite "RND_EClosest_isEclosest") nil nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil) nil shostak)) (EvenClosest_total 0 (EvenClosest_total-1 nil 3682165501 ("" (skeep) (("" (expand "total?") (("" (use "EvenClosest_Total") (("" (expand "Total?") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((total? const-decl "bool" float nil) (Total? const-decl "bool" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (EvenClosest_Total formula-decl nil float nil)) shostak)) (EvenClosest_Compatible 0 (EvenClosest_Compatible-1 nil 3319798879 ("" (lemma "Closest_Compatible") (("" (expand "Compatible?") (("" (skeep) (("" (skeep) (("" (expand "EvenClosest?") (("" (split) (("1" (flatten) (("1" (inst -1 "b" "r1" "r2" "f1" "f2") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (split -3) (("1" (case-replace "Fnormalize(b)(f2)=Fnormalize(b)(f1)") (("1" (rewrite "FcanonicUnique" :subst ("b" "b")) nil nil)) nil) ("2" (skosimp*) (("2" (inst -1 "f!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Compatible? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (FcanonicUnique formula-decl nil float nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (<= const-decl "bool" reals nil) (FtoR const-decl "real" float nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Fcanonic? const-decl "bool" float nil) (= const-decl "[T, T -> boolean]" equalities nil) (EvenClosest? const-decl "bool" float nil) (Closest_Compatible formula-decl nil float nil)) shostak)) (EvenClosest_compatible 0 (EvenClosest_compatible-1 nil 3682165663 ("" (lemma "EvenClosest_Compatible") (("" (expand "compatible?") (("" (expand "Compatible?") (("" (skeep) (("" (inst?) (("" (skeep) (("" (inst? -1 :where 1) (("" (inst? -1 :where -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((compatible? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Compatible? const-decl "bool" float nil) (EvenClosest_Compatible formula-decl nil float nil)) shostak)) (EvenClosest_MinOrMax 0 (EvenClosest_MinOrMax-1 nil 3319799137 ("" (lemma "Closest_MinOrMax") (("" (expand "MinOrMax?") (("" (skeep) (("" (skeep) (("" (expand "EvenClosest?") (("" (flatten) (("" (inst -1 "b" "r" "f") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((MinOrMax? const-decl "bool" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (EvenClosest? const-decl "bool" float nil) (Closest_MinOrMax formula-decl nil float nil)) shostak)) (EvenClosest_min_or_max 0 (EvenClosest_min_or_max-1 nil 3682165832 ("" (skeep) (("" (expand "min_or_max?") (("" (use "EvenClosest_MinOrMax") (("" (expand "MinOrMax?") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((min_or_max? const-decl "bool" float nil) (MinOrMax? const-decl "bool" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (EvenClosest_MinOrMax formula-decl nil float nil)) shostak)) (EvenClosest_Monotone 0 (EvenClosest_Monotone-1 nil 3319799211 ("" (lemma "Closest_Monotone") (("" (expand "Monotone?") (("" (skeep) (("" (skeep) (("" (expand "EvenClosest?") (("" (flatten) (("" (inst -1 "b" "r1" "r2" "f1" "f2") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Monotone? const-decl "bool" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (EvenClosest? const-decl "bool" float nil) (Closest_Monotone formula-decl nil float nil)) shostak)) (EvenClosest_monotone 0 (EvenClosest_monotone-1 nil 3682166058 ("" (skeep) (("" (expand "monotone?") (("" (use "EvenClosest_Monotone") (("" (expand "Monotone?") (("" (skeep) (("" (inst? -1 :where 1) (("" (inst? -1 :where -2) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((monotone? const-decl "bool" float nil) (Monotone? const-decl "bool" float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (EvenClosest_Monotone formula-decl nil float nil)) shostak)) (EvenClosest_RoundedMode 0 (EvenClosest_RoundedMode-1 nil 3319799281 ("" (skeep) (("" (expand "RoundedMode?") (("" (split) (("1" (rewrite "EvenClosest_Total") nil nil) ("2" (rewrite "EvenClosest_Compatible") nil nil) ("3" (rewrite "EvenClosest_MinOrMax") nil nil) ("4" (rewrite "EvenClosest_Monotone") nil nil)) nil)) nil)) nil) ((RoundedMode? const-decl "bool" float nil) (EvenClosest_Monotone formula-decl nil float nil) (EvenClosest_MinOrMax formula-decl nil float nil) (EvenClosest_Compatible formula-decl nil float nil) (EvenClosest_Total formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil)) shostak)) (EvenClosest_rounded_mode 0 (EvenClosest_rounded_mode-1 nil 3682165606 ("" (skeep) (("" (expand "rounded_mode?") (("" (split 1) (("1" (use "EvenClosest_total") nil nil) ("2" (use "EvenClosest_compatible") nil nil) ("3" (use "EvenClosest_min_or_max") nil nil) ("4" (use "EvenClosest_monotone") nil nil)) nil)) nil)) nil) ((rounded_mode? const-decl "bool" float nil) (EvenClosest_monotone formula-decl nil float nil) (EvenClosest_min_or_max formula-decl nil float nil) (EvenClosest_compatible formula-decl nil float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (EvenClosest_total formula-decl nil float nil)) shostak)) (EvenClosest_Unique 0 (EvenClosest_Unique-1 nil 3319801122 ("" (expand "Unique?") (("" (skeep) (("" (skeep) (("" (lemma "EvenClosest_MinOrMax") (("" (expand "MinOrMax?") (("" (inst-cp -1 "b" "r" "f1") (("" (split) (("1" (inst -2 "b" "r" "f2") (("1" (split) (("1" (lemma "isMin_Unique") (("1" (expand "Unique?") (("1" (inst -1 "b" "r" "f1" "f2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "EvenClosest?") (("2" (flatten) (("2" (split) (("1" (split) (("1" (lemma "MaxSuccMin") (("1" (inst -1 "b" "Fnormalize(b)(f1)" "Fnormalize(b)(f2)" "r") (("1" (split) (("1" (case "odd?(Fnum(Fnormalize(b)(f2)))") (("1" (lemma "odd_iff_not_even") (("1" (inst -1 "Fnum(Fnormalize(b)(f2))") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite -1) (("2" (rewrite "EvenFsuccOdd") nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (lemma "isMax_Compatible") (("3" (expand "Compatible?") (("3" (inst -1 "b" "r" "r" "f2" "Fnormalize(b)(f2)") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (lemma "isMin_Compatible") (("4" (expand "Compatible?") (("4" (inst -1 "b" "r" "r" "f1" "Fnormalize(b)(f1)") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (assert) nil nil) ("6" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -1 "f1") (("2" (assert) nil nil)) nil)) nil) ("2" (inst -1 "f2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil) ("2" (inst -2 "b" "r" "f2") (("2" (split) (("1" (expand "EvenClosest?") (("1" (flatten) (("1" (split) (("1" (split) (("1" (lemma "MaxSuccMin") (("1" (inst -1 "b" "Fnormalize(b)(f2)" "Fnormalize(b)(f1)" "r") (("1" (split) (("1" (case "odd?(Fnum(Fnormalize(b)(f1)))") (("1" (lemma "odd_iff_not_even") (("1" (inst -1 "Fnum(Fnormalize(b)(f1))") (("1" (assert) nil nil)) nil)) nil) ("2" (copy -2) (("2" (rewrite -2) (("2" (rewrite "EvenFsuccOdd") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (lemma "isMax_Compatible") (("3" (expand "Compatible?") (("3" (inst -1 "b" "r" "r" "f1" "Fnormalize(b)(f1)") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (lemma "isMin_Compatible") (("4" (expand "Compatible?") (("4" (inst -1 "b" "r" "r" "f2" "Fnormalize(b)(f2)") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (assert) nil nil) ("6" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -1 "f1") (("2" (assert) nil nil)) nil)) nil) ("2" (inst -1 "f2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "isMax_Unique") (("2" (expand "Unique?") (("2" (inst -1 "b" "r" "f1" "f2") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((EvenClosest_MinOrMax formula-decl nil float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (isMax_Unique formula-decl nil float nil) (EvenClosest? const-decl "bool" float nil) (MaxSuccMin formula-decl nil float nil) (EvenFsuccOdd formula-decl nil float nil) (odd_iff_not_even formula-decl nil naturalnumbers nil) (odd? const-decl "bool" integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (Compatible? const-decl "bool" float nil) (isMax_Compatible formula-decl nil float nil) (isMin_Compatible formula-decl nil float nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (<= const-decl "bool" reals nil) (FtoR const-decl "real" float nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Fcanonic? const-decl "bool" float nil) (isMin_Unique formula-decl nil float nil) (MinOrMax? const-decl "bool" float nil) (Unique? const-decl "bool" float nil)) shostak)) (AFZClosest_Total 0 (AFZClosest_Total-1 nil 3321037213 ("" (lemma "isMin_Total") (("" (lemma "isMax_Total") (("" (expand "Total?") (("" (skeep) (("" (skeep) (("" (inst -1 "b" "r") (("" (inst -2 "b" "r") (("" (skosimp*) (("" (case "abs(FtoR(f!1)-r)<abs(FtoR(f!2)-r)") (("1" (inst 1 "f!1") (("1" (expand "AFZClosest?") (("1" (case "Closest?(b)(r, f!1)") (("1" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (hide 1) (("2" (skosimp*) (("2" (lemma "Closest_MinOrMax") (("2" (expand "MinOrMax?") (("2" (inst -1 "b" "r" "f!3") (("2" (split) (("1" (expand "Closest?" -2) (("1" (inst -2 "f!1") (("1" (flip-ineq -2) (("1" (case-replace "FtoR(f!3)=FtoR(f!2)") (("1" (assert) nil nil) ("2" (lemma "isMin_Unique") (("2" (expand "Unique?") (("2" (inst -1 "b" "r" "f!3" "f!2") (("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "isMax_Unique") (("2" (expand "Unique?") (("2" (inst -1 "b" "r" "f!3" "f!1") (("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "LeMinMaxClosest") (("2" (inst -1 "b" "f!1" "f!2" "f!1" "r") (("2" (split) (("1" (propax) nil nil) ("2" (grind-reals) nil nil) ("3" (propax) nil nil) ("4" (assert) nil nil) ("5" (propax) nil nil) ("6" (assert) nil nil) ("7" (assert) nil nil) ("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (split-ineq -1) (("1" (case "0 <= r") (("1" (inst 1 "f!1") (("1" (expand "AFZClosest?") (("1" (split) (("1" (lemma "LeMinMaxClosest") (("1" (inst -1 "b" "f!1" "f!2" "f!1" "r") (("1" (split) (("1" (propax) nil nil) ("2" (assert) nil nil) ("3" (propax) nil nil) ("4" (assert) nil nil) ("5" (propax) nil nil) ("6" (assert) nil nil) ("7" (assert) nil nil) ("8" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "isMax?") (("2" (flatten) (("2" (expand "abs" 1) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (inst 1 "f!2") (("2" (expand "AFZClosest?") (("2" (split) (("1" (lemma "LeMinMaxClosest") (("1" (inst -1 "b" "f!2" "f!2" "f!1" "r") (("1" (split) (("1" (propax) nil nil) ("2" (assert) nil nil) ("3" (propax) nil nil) ("4" (assert) nil nil) ("5" (propax) nil nil) ("6" (assert) nil nil) ("7" (assert) nil nil) ("8" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "isMin?") (("2" (flatten) (("2" (expand "abs" 1) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "abs(FtoR(f!2) - r) < abs(FtoR(f!1) - r)") (("1" (hide -2 1) (("1" (inst 1 "f!2") (("1" (expand "AFZClosest?") (("1" (case "Closest?(b)(r, f!2)") (("1" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (hide 1) (("2" (skosimp*) (("2" (lemma "Closest_MinOrMax") (("2" (expand "MinOrMax?") (("2" (inst -1 "b" "r" "f!3") (("2" (split) (("1" (lemma "isMin_Unique") (("1" (expand "Unique?") (("1" (inst -1 "b" "r" "f!3" "f!2") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Closest?" -2) (("2" (inst -2 "f!2") (("2" (flip-ineq -2) (("2" (case-replace "FtoR(f!3)=FtoR(f!1)") (("1" (assert) nil nil) ("2" (lemma "isMax_Unique") (("2" (expand "Unique?") (("2" (inst -1 "b" "r" "f!3" "f!1") (("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "LeMinMaxClosest") (("2" (inst -1 "b" "f!2" "f!2" "f!1" "r") (("2" (split) (("1" (propax) nil nil) ("2" (assert) nil nil) ("3" (propax) nil nil) ("4" (assert) nil nil) ("5" (propax) nil nil) ("6" (assert) nil nil) ("7" (assert) nil nil) ("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((isMax_Total formula-decl nil float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (isMax? const-decl "bool" float nil) (isMin? const-decl "bool" float nil) (minus_real_is_real application-judgement "real" reals nil) (Closest? const-decl "bool" float nil) (MinOrMax? const-decl "bool" float nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Unique? const-decl "bool" float nil) (isMin_Unique formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (isMax_Unique formula-decl nil float nil) (Closest_MinOrMax formula-decl nil float nil) (LeMinMaxClosest formula-decl nil float nil) (AFZClosest? const-decl "bool" float nil) (real_minus_real_is_real application-judgement "real" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (FtoR const-decl "real" float nil) (Fbounded? const-decl "bool" float nil) (Total? const-decl "bool" float nil) (isMin_Total formula-decl nil float nil)) shostak)) (AFZClosest_Compatible 0 (AFZClosest_Compatible-2 "" 3790102925 ("" (skeep) (("" (lemma "Closest_Compatible") (("" (inst -1 "b") (("" (expand "Compatible?") (("" (skeep) (("" (expand "AFZClosest?") (("" (flatten) (("" (split 1) (("1" (inst -1 "r1" "r2" "f1" "f2") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (propax) nil nil)) nil)) nil) ("2" (split) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (skosimp*) (("2" (rewrite -6 :dir rl) (("2" (rewrite -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Closest_Compatible formula-decl nil float nil) (Compatible? const-decl "bool" float nil) (AFZClosest? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak) (AFZClosest_Compatible-1 nil 3321035712 ("" (skeep) (("" (lemma "Closest_Compatible") (("" (inst -1 "b") (("" (expand "Compatible?") (("" (skeep) (("" (expand "AFZClosest?") (("" (flatten) (("" (split 1) (("1" (inst -1 "r1" "r2" "f1" "f2") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (propax) nil nil)) nil)) nil) ("2" (split) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (hide 1) (("2" (skosimp*) (("2" (rewrite -6 :dir rl) (("2" (rewrite -6) (("2" (rewrite -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (AFZClosest_MinOrMax 0 (AFZClosest_MinOrMax-1 nil 3321035974 ("" (lemma "Closest_MinOrMax") (("" (expand "MinOrMax?") (("" (skeep) (("" (skosimp*) (("" (inst -1 "b" "r!1" "f!1") (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (expand "AFZClosest?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((MinOrMax? const-decl "bool" float nil) (AFZClosest? const-decl "bool" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (Closest_MinOrMax formula-decl nil float nil)) shostak)) (AFZClosest_Monotone 0 (AFZClosest_Monotone-1 nil 3321036075 ("" (lemma "Closest_Monotone") (("" (expand "Monotone?") (("" (skeep) (("" (skeep) (("" (expand "AFZClosest?") (("" (flatten) (("" (inst -1 "b" "r1" "r2" "f1" "f2") (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Monotone? const-decl "bool" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (AFZClosest? const-decl "bool" float nil) (Closest_Monotone formula-decl nil float nil)) shostak)) (AFZClosest_RoundedMode 0 (AFZClosest_RoundedMode-1 nil 3321036146 ("" (skeep) (("" (expand "RoundedMode?") (("" (split) (("1" (rewrite "AFZClosest_Total") nil nil) ("2" (rewrite "AFZClosest_Compatible") nil nil) ("3" (rewrite "AFZClosest_MinOrMax") nil nil) ("4" (rewrite "AFZClosest_Monotone") nil nil)) nil)) nil)) nil) ((RoundedMode? const-decl "bool" float nil) (AFZClosest_Monotone formula-decl nil float nil) (AFZClosest_MinOrMax formula-decl nil float nil) (AFZClosest_Compatible formula-decl nil float nil) (AFZClosest_Total formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil)) shostak)) (AFZClosest_Unique 0 (AFZClosest_Unique-1 nil 3321036197 ("" (expand "Unique?") (("" (skeep) (("" (skeep) (("" (expand "AFZClosest?") (("" (flatten) (("" (split) (("1" (split) (("1" (lemma "Closest_MinOrMax") (("1" (expand "MinOrMax?") (("1" (inst-cp -1 "b" "r" "f1") (("1" (inst -1 "b" "r" "f2") (("1" (split) (("1" (split) (("1" (lemma "isMin_Unique") (("1" (expand "Unique?") (("1" (assert) (("1" (inst -1 "b" "r" "f1" "f2") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "0<= r") (("1" (case "0<= FtoR(f1)") (("1" (case "0<= FtoR(f2)") (("1" (expand "abs") (("1" (grind-reals) (("1" (expand* "isMin?" "isMax?") (("1" (flatten) (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "RleRoundedR0" :subst ("b" "b" "P" "isMin?" "r" "r" "f" "f2")) (("2" (rewrite "isMin_RoundedMode") nil nil)) nil)) nil) ("2" (rewrite "RleRoundedR0" :subst ("b" "b" "P" "isMax?" "r" "r" "f" "f1")) (("2" (rewrite "isMax_RoundedMode") nil nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (case "FtoR(f2) <= 0") (("1" (case "FtoR(f1) <= 0") (("1" (expand "abs") (("1" (grind-reals) (("1" (expand* "isMin?" "isMax?") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "RleRoundedLessR0" :subst ("b" "b" "P" "isMax?" "r" "r" "f" "f1")) (("2" (rewrite "isMax_RoundedMode") nil nil)) nil)) nil) ("2" (rewrite "RleRoundedLessR0" :subst ("b" "b" "P" "isMin?" "r" "r" "f" "f2")) (("2" (rewrite "isMin_RoundedMode") nil nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil) ("2" (split) (("1" (case "0<=r") (("1" (case "0<=FtoR(f1)") (("1" (case "0<=FtoR(f2)") (("1" (expand "abs") (("1" (grind-reals) (("1" (expand* "isMin?" "isMax?") (("1" (flatten) (("1" (inst -6 "f1") (("1" (split) (("1" (grind-reals) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "RleRoundedR0" :subst ("b" "b" "P" "isMax?" "r" "r" "f" "f2")) (("2" (rewrite "isMax_RoundedMode") nil nil)) nil)) nil) ("2" (rewrite "RleRoundedR0" :subst ("b" "b" "P" "isMin?" "r" "r" "f" "f1")) (("2" (rewrite "isMin_RoundedMode") nil nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (case "FtoR(f2) <= 0") (("1" (case "FtoR(f1) <= 0") (("1" (expand "abs") (("1" (grind-reals) (("1" (expand* "isMin?" "isMax?") (("1" (flatten) (("1" (inst -4 "f2") (("1" (split) (("1" (grind-reals) nil nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "RleRoundedLessR0" :subst ("b" "b" "P" "isMin?" "r" "r" "f" "f1")) (("2" (rewrite "isMin_RoundedMode") nil nil)) nil)) nil) ("2" (rewrite "RleRoundedLessR0" :subst ("b" "b" "P" "isMax?" "r" "r" "f" "f2")) (("2" (rewrite "isMax_RoundedMode") nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "isMax_Unique") (("2" (expand "Unique?") (("2" (inst -1 "b" "r" "f1" "f2") (("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite -1) nil nil)) nil) ("2" (rewrite -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((AFZClosest? const-decl "bool" float nil) (Closest_MinOrMax formula-decl nil float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (<= const-decl "bool" reals nil) (isMax_RoundedMode formula-decl nil float nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (isMin? const-decl "bool" float nil) (isMax? const-decl "bool" float nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (isMin_RoundedMode formula-decl nil float nil) (RleRoundedR0 formula-decl nil float nil) (RND type-eq-decl nil float nil) (FtoR const-decl "real" float nil) (RleRoundedLessR0 formula-decl nil float nil) (minus_real_is_real application-judgement "real" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (isMin_Unique formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (isMax_Unique formula-decl nil float nil) (MinOrMax? const-decl "bool" float nil) (Unique? const-decl "bool" float nil)) shostak)) (RoundedProjectorEq 0 (RoundedProjectorEq-1 nil 3319475225 ("" (skosimp*) (("" (expand* "RoundedMode?" "MinOrMax?") (("" (flatten) (("" (inst -5 "FtoR(f!1)" "p!1") (("" (split) (("1" (expand "isMin?") (("1" (flatten) (("1" (inst -2 "f!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "isMax?") (("2" (flatten) (("2" (inst -2 "f!1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((MinOrMax? const-decl "bool" float nil) (RoundedMode? const-decl "bool" float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (FtoR const-decl "real" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (isMax? const-decl "bool" float nil) (isMin? const-decl "bool" float nil) (b!1 skolem-const-decl "Format" float nil) (f!1 skolem-const-decl "float" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (RoundedProjector 0 (RoundedProjector-1 nil 3319475578 ("" (skosimp*) (("" (copy -2) (("" (expand "RoundedMode?" -1) (("" (flatten) (("" (expand "Total?") (("" (inst -1 "FtoR(f!1)") (("" (skosimp*) (("" (expand "Compatible?") (("" (inst -2 "FtoR(f!1)" "FtoR(f!1)" "f!2" "f!1") (("" (assert) (("" (lemma "RoundedProjectorEq") (("" (inst -1 "P!1" "b!1" "f!1" "f!2") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (FtoR const-decl "real" float nil) (Compatible? const-decl "bool" float nil) (RND type-eq-decl nil float nil) (RoundedProjectorEq formula-decl nil float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Total? const-decl "bool" float nil) (RoundedMode? const-decl "bool" float nil)) shostak)) (isMin_Rep 0 (isMin_Rep-1 nil 3319971693 ("" (skeep) (("" (case "Fexp(Fnormalize(b)(f)) <= Fexp(p)") (("1" (inst 1 "Fnum(p)") (("1" (case "FtoR(f) =FtoR(p)") (("1" (rewrite -1) (("1" (expand "FtoR") (("1" (propax) nil nil)) nil)) nil) ("2" (lemma "FsuccZleEq") (("2" (inst -1 "b" "Fnormalize(b)(f)" "p") (("2" (split) (("1" (assert) nil nil) ("2" (propax) nil nil) ("3" (hide 2 3) (("3" (expand "isMin?") (("3" (flatten) (("3" (inst -4 "Fsucc(b)(Fnormalize(b)(f))") (("1" (flip-ineq 1) (("1" (split) (("1" (flip-ineq -1) (("1" (lemma "FsuccLt") (("1" (inst -1 "b" "Fnormalize(b)(f)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") (("2" (rewrite "FsuccCanonic") nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "isMin?") (("4" (flatten) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (inst 1 "Fnum(Fnormalize(b)(f))*radix^(Fexp(Fnormalize(b)(f))-Fexp(p))") (("1" (rewrite "FnormalizeCorrect" :dir rl :subst ("b" "b" "p" "f")) (("1" (expand "FtoR") (("1" (rewrite "expt_div" :dir rl) (("1" (field 1) nil nil)) nil)) nil)) nil) ("2" (expand "^") (("2" (grind-reals) nil nil)) nil) ("3" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ((Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (FtoR const-decl "real" float nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Fcanonic? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Format type-eq-decl nil float nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (FcanonicBounded formula-decl nil float nil) (FsuccCanonic formula-decl nil float nil) (>= const-decl "bool" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FsuccLt formula-decl nil float nil) (f skolem-const-decl "float" float nil) (Fsucc const-decl "float" float nil) (b skolem-const-decl "Format" float nil) (isMin? const-decl "bool" float nil) (FsuccZleEq formula-decl nil float nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (p skolem-const-decl "float" float nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (radix formal-const-decl "above(1)" float nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (expt_div formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (FnormalizeCorrect formula-decl nil float nil) (int_times_int_is_int application-judgement "int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil)) shostak)) (RoundedModeRep 0 (RoundedModeRep-1 nil 3319911557 ("" (skeep) (("" (expand* "RoundedMode?" "MinOrMax?") (("" (flatten) (("" (inst -4 "FtoR(p)" "f") (("" (split) (("1" (lemma "isMin_Rep") (("1" (inst -1 "b" "f" "p") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "isMin_Rep") (("2" (inst -1 "b" "Fopp(f)" "Fopp(p)") (("2" (split) (("1" (skosimp*) (("1" (inst 1 "-m!1") (("1" (expand* "FtoR" "Fopp") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (rewrite "FoppCorrect") (("2" (rewrite "MaxOppMin") nil nil)) nil) ("3" (rewrite "FoppBounded") nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((MinOrMax? const-decl "bool" float nil) (RoundedMode? const-decl "bool" float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (FtoR const-decl "real" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (MaxOppMin formula-decl nil float nil) (minus_real_is_real application-judgement "real" reals nil) (FoppCorrect formula-decl nil float nil) (FoppBounded formula-decl nil float nil) (Fopp const-decl "float" float nil) (isMin_Rep formula-decl nil float nil)) shostak)) (RoundedModeUlp 0 (RoundedModeUlp-1 nil 3319477842 ("" (skeep) (("" (expand "RoundedMode?") (("" (expand "MinOrMax?") (("" (flatten) (("" (inst -4 "r" "p") (("" (split) (("1" (expand "isMin?") (("1" (flatten) (("1" (case-replace "abs(FtoR(p) - r)=r-FtoR(p)") (("1" (lemma "FloatPlusUlpBounded") (("1" (inst -1 "b" "p") (("1" (split) (("1" (skosimp*) (("1" (inst -4 "f!1") (("1" (split) (("1" (flip-ineq -1) (("1" (rewrite -1) (("1" (hide-all-but 1) (("1" (expand "Fulp") (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite -1) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "isMax?") (("2" (flatten) (("2" (case-replace "abs(FtoR(p) - r)=FtoR(p)-r") (("1" (lemma "FloatMinusUlpBounded") (("1" (inst -1 "b" "p") (("1" (split) (("1" (skosimp*) (("1" (inst -4 "f!1") (("1" (split) (("1" (flip-ineq -1) (("1" (rewrite -1) (("1" (hide-all-but 1) (("1" (expand "Fulp") (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite -1) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RoundedMode? const-decl "bool" float nil) (FloatPlusUlpBounded formula-decl nil float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (Fulp const-decl "real" float nil) (Fulp_posreal_j application-judgement "posreal" float nil) (real_plus_real_is_real application-judgement "real" reals nil) (FtoR const-decl "real" float nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (isMin? const-decl "bool" float nil) (FloatMinusUlpBounded formula-decl nil float nil) (isMax? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (MinOrMax? const-decl "bool" float nil) (real_minus_real_is_real application-judgement "real" reals nil)) shostak)) (ClosestUlp 0 (ClosestUlp-1 nil 3319816797 ("" (case "FORALL (b: Format, p: float, r: real):
               Fbounded?(b)(p) => 0 <= r =>
                Closest?(b)(r, p) => abs(FtoR(p) - r) <= Fulp(b)(p) / 2") (("1" (skeep) (("1" (case "0 <= r") (("1" (inst -2 "b" "p" "r") (("1" (assert) nil nil)) nil) ("2" (inst -1 "b" "Fopp(p)" "-r") (("2" (split) (("1" (rewrite "FulpOpp") (("1" (case-replace "abs(FtoR(p) - r)=abs(FtoR(Fopp(p)) - -r)") (("1" (rewrite "FoppCorrect") (("1" (hide-all-but 1) (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "ClosestFopp") nil nil) ("3" (grind-reals) nil nil) ("4" (rewrite "FoppBounded") nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (case "FtoR(p) <= r") (("1" (lemma "FloatPlusUlpBounded") (("1" (inst -1 "b" "p") (("1" (split) (("1" (skosimp*) (("1" (mult-by 1 "2") (("1" (case "abs(FtoR(p) - r) <= Fulp(b)(p)- abs(FtoR(p) - r)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "abs(FtoR(f!1) - r) <= Fulp(b)(p) - abs(FtoR(p) - r)") (("1" (case "abs(FtoR(p) - r) <= abs(FtoR(f!1) - r)") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (expand "Closest?") (("2" (inst -5 "f!1") nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite -1) (("2" (case "abs(FtoR(p)-r) < Fulp(b)(p)") (("1" (hide -2 -4 -6) (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "RoundedModeUlp" :subst ("b" "b" "P" "Closest?")) (("2" (rewrite "Closest_RoundedMode") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (lemma "FloatMinusUlpBounded") (("2" (inst -1 "b" "p") (("2" (split) (("1" (skosimp*) (("1" (mult-by 1 "2") (("1" (case "abs(FtoR(p) - r) <= Fulp(b)(p)- abs(FtoR(p) - r)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case "abs(FtoR(f!1) - r) <= Fulp(b)(p) - abs(FtoR(p) - r)") (("1" (case "abs(FtoR(p) - r) <= abs(FtoR(f!1) - r)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "Closest?") (("2" (inst -6 "f!1") nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (copy -2) (("2" (rewrite -2) (("2" (case "abs(FtoR(p)-r) < Fulp(b)(p)") (("1" (hide -3 -4 -6) (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "RoundedModeUlp" :subst ("b" "b" "P" "Closest?")) (("2" (rewrite "Closest_RoundedMode") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_plus_real_is_real application-judgement "real" reals nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (RND type-eq-decl nil float nil) (RoundedModeUlp formula-decl nil float nil) (Closest_RoundedMode formula-decl nil float nil) (both_sides_plus_le2 formula-decl nil real_props nil) (< const-decl "bool" reals nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_cancel2 formula-decl nil real_props nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (FloatPlusUlpBounded formula-decl nil float nil) (FloatMinusUlpBounded formula-decl nil float nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (Fopp const-decl "float" float nil) (FoppBounded formula-decl nil float nil) (ClosestFopp formula-decl nil float nil) (FulpOpp formula-decl nil float nil) (FoppCorrect formula-decl nil float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_minus_real_is_real application-judgement "real" reals nil) (Fulp_posreal_j application-judgement "posreal" float nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Fbounded? const-decl "bool" float nil) (<= const-decl "bool" reals nil) (Closest? const-decl "bool" float nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (FtoR const-decl "real" float nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (Fulp const-decl "real" float nil)) shostak)) (closest_ulp 0 (closest_ulp-1 nil 3681666755 ("" (skeep) (("" (expand "ulp") (("" (case "Closest?(b)(r, RtoF(r))") (("1" (lemma "ClosestUlp") (("1" (inst -1 "b" "RtoF(r)" "r") (("1" (assert) (("1" (case "abs(FtoR(RtoF(r)) - r) = abs(FtoR(p) - r)") (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil) ("2" (hide -1 2) (("2" (expand "Closest?") (("2" (inst -1 "p") (("2" (inst -3 "RtoF(r)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "RtoF") (("2" (inst?) (("2" (typepred "round") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ulp const-decl "posreal" float nil) (NOT const-decl "[bool -> bool]" booleans nil) (ClosestUlp formula-decl nil float nil) (Fulp_posreal_j application-judgement "posreal" float nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (FtoR const-decl "real" float nil) (Format type-eq-decl nil float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (Closest? const-decl "bool" float nil) (Rounding type-eq-decl nil float nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (RNDF type-eq-decl nil float nil) (real_minus_real_is_real application-judgement "real" reals nil)) shostak)) (RoundedModeNonDecreasing 0 (RoundedModeNonDecreasing-1 nil 3320428553 ("" (skeep) (("" (split-ineq -7) (("1" (expand "Unique?") (("1" (inst -5 "z1" "p" "q") (("1" (assert) nil nil)) nil)) nil) ("2" (expand* "RoundedMode?" "Monotone?") (("2" (flatten) (("2" (inst -6 "z1" "z2" "p" "q") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (Unique? const-decl "bool" float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (RoundedMode? const-decl "bool" float nil) (Monotone? const-decl "bool" float nil)) shostak)) (ClosestUlp2_TCC1 0 (ClosestUlp2_TCC1-1 nil 3320427865 ("" (skeep) (("" (rewrite "FpredBounded") (("" (rewrite "FabsBounded") (("" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil) ((FpredBounded formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fabs const-decl "float" float nil) (FcanonicBounded formula-decl nil float nil) (FabsBounded formula-decl nil float nil)) nil (ClosestUlp2 subtype "float.Fpred(float.b)(float.Fabs(float.p))" "(float.Fbounded?(float.b))"))) (ClosestUlp2 0 (ClosestUlp2-1 nil 3320428698 ("" (case "FORALL (b: Format, p: float, r: real):
                      Fcanonic?(b)(p) =>
                       Closest?(b)(r, p) => 0 <= r =>
                        r <= FtoR(p) + Fulp(b)(Fpred(b)(p)) / 2 =>
                         abs(FtoR(p) - r) <= Fulp(b)(Fpred(b)(p)) / 2") (("1" (skeep) (("1" (case "0<=r") (("1" (inst -2 "b" "p" "r") (("1" (case "0<= FtoR(p)") (("1" (case "Fabs(p)=p") (("1" (split) (("1" (assert) nil nil) ("2" (expand "abs" -6) (("2" (grind-reals) nil nil)) nil) ("3" (propax) nil nil) ("4" (propax) nil nil) ("5" (propax) nil nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (expand* "Fabs" "abs" "FtoR") (("2" (grind-reals) (("2" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "RleRoundedR0" :subst ("b" "b" "P" "Closest?" "r" "r")) (("1" (rewrite "Closest_RoundedMode") nil nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (inst -2 "b" "Fopp(p)" "-r") (("2" (case "FtoR(p) <= 0") (("1" (case "Fabs(p)=Fopp(p)") (("1" (split) (("1" (case-replace "abs(FtoR(Fopp(p)) - -r)=abs(FtoR(p) - r)") (("1" (assert) nil nil) ("2" (rewrite "FoppCorrect") (("2" (expand "abs" 1) (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (expand "abs" -6) (("2" (grind-reals) (("1" (rewrite "FoppCorrect") (("1" (assert) nil nil)) nil) ("2" (rewrite "FoppCorrect") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (rewrite "ClosestFopp") (("4" (rewrite "FcanonicBounded") nil nil)) nil) ("5" (lemma "FcanonicOpp") (("5" (inst -1 "b" "p") (("5" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (expand* "Fabs" "Fopp" "abs" "FtoR") (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "RleRoundedLessR0" :subst ("b" "b" "P" "Closest?" "r" "r")) (("1" (rewrite "Closest_RoundedMode") nil nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "abs" 1) (("2" (grind-reals) (("2" (flip-ineq 1) (("2" (copy -3) (("2" (expand "Closest?" -1) (("2" (inst -1 "Fpred(b)(p)") (("2" (case "FtoR(Fpred(b)(p)) - r <= 0") (("1" (expand "abs" -2) (("1" (grind-reals) (("1" (case " FtoR(p) - r -(FtoR(Fpred(b)(p)) - r) <= Fulp(b)(Fpred(b)(p))") (("1" (grind-reals) nil nil) ("2" (assert) (("2" (rewrite "FpredDiff") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flip-ineq 1) (("2" (flip-ineq -2) (("2" (expand "abs" 1) (("2" (grind-reals) (("2" (lemma "FpredLt") (("2" (inst -1 "b" "p") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (rewrite "FpredBounded") (("3" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (rewrite "FpredBounded") (("4" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil) ((FpredBounded formula-decl nil float nil) (FpredDiff formula-decl nil float nil) (FpredLt formula-decl nil float nil) (both_sides_minus_gt1 formula-decl nil real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (neg_times_le formula-decl nil real_props nil) (FoppCorrect formula-decl nil float nil) (div_mult_pos_le2 formula-decl nil real_props nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (ClosestFopp formula-decl nil float nil) (FcanonicOpp formula-decl nil float nil) (RleRoundedLessR0 formula-decl nil float nil) (Fopp const-decl "float" float nil) (minus_real_is_real application-judgement "real" reals nil) (RND type-eq-decl nil float nil) (RleRoundedR0 formula-decl nil float nil) (Closest_RoundedMode formula-decl nil float nil) (FcanonicBounded formula-decl nil float nil) (= const-decl "[T, T -> boolean]" equalities nil) (Fabs const-decl "float" float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnreal_plus_posreal_is_posreal application-judgement "posreal" real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (pos_times_le formula-decl nil real_props nil) (TRUE const-decl "bool" booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (Fulp_posreal_j application-judgement "posreal" float nil) (real_plus_real_is_real application-judgement "real" reals nil) (posreal_div_posreal_is_posreal application-judgement "posreal" real_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Fcanonic? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (Closest? const-decl "bool" float nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (FtoR const-decl "real" float nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (Fulp const-decl "real" float nil) (Fpred const-decl "float" float nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak)) (ClosestFabs 0 (ClosestFabs-1 nil 3320750464 ("" (skeep) (("" (expand "abs") (("" (grind-reals) (("1" (case-replace "Fabs(p)=Fopp(p)") (("1" (rewrite "ClosestFopp") nil nil) ("2" (expand* "Fabs" "Fopp") (("2" (case "FtoR(p) <= 0") (("1" (expand "FtoR") (("1" (expand "abs" 1) (("1" (grind-reals) nil nil)) nil)) nil) ("2" (rewrite "RleRoundedLessR0" :subst ("b" "b" "P" "Closest?" "r" "r" "f" "p")) (("2" (rewrite "Closest_RoundedMode") nil nil)) nil)) nil)) nil)) nil) ("2" (case-replace "Fabs(p)=p") (("2" (case "0 <= FtoR(p)") (("1" (expand "FtoR") (("1" (expand* "Fabs" "abs") (("1" (grind-reals) (("1" (decompose-equality 1) nil nil)) nil)) nil)) nil) ("2" (rewrite "RleRoundedR0" :subst ("b" "b" "P" "Closest?" "r" "r" "f" "p")) (("2" (rewrite "Closest_RoundedMode") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (RleRoundedR0 formula-decl nil float nil) (pos_times_le formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (= const-decl "[T, T -> boolean]" equalities nil) (Fabs const-decl "float" float nil) (Fopp const-decl "float" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ClosestFopp formula-decl nil float nil) (FtoR const-decl "real" float nil) (<= const-decl "bool" reals nil) (minus_int_is_int application-judgement "int" integers nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (neg_times_le formula-decl nil real_props nil) (Closest_RoundedMode formula-decl nil float nil) (RleRoundedLessR0 formula-decl nil float nil) (Fbounded? const-decl "bool" float nil) (RND type-eq-decl nil float nil) (Closest? const-decl "bool" float nil) (minus_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (SterbenzAux 0 (SterbenzAux-1 nil 3319905254 ("" (skeep) (("" (expand "Fbounded?" 1) (("" (split) (("1" (mult-by 1 "radix^Fexp(Fminus(q, p))") (("1" (case-replace "abs(Fnum(Fminus(q, p))) * radix ^ Fexp(Fminus(q, p))=FtoR(q)-FtoR(p)") (("1" (hide -1) (("1" (expand* "Fminus" "min") (("1" (grind-reals) (("1" (case "FtoR(q) - FtoR(p) <= FtoR(p)") (("1" (case " FtoR(p)< vNum(b) * radix ^ Fexp(p)") (("1" (assert) nil nil) ("2" (expand "FtoR" 1) (("2" (expand "Fbounded?" -3) (("2" (flatten) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil) ("2" (flip-ineq 1) (("2" (case "FtoR(q) - FtoR(p) <= FtoR(q)") (("1" (case "FtoR(q) < vNum(b) * radix ^ Fexp(q)") (("1" (assert) nil nil) ("2" (expand "Fbounded?" -4) (("2" (flatten) (("2" (expand "FtoR" 1) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "FminusCorrect" :dir rl) (("2" (case "FtoR(Fminus(q, p))=abs(FtoR(Fminus(q, p)))") (("1" (rewrite -1) (("1" (expand "FtoR" 1) (("1" (rewrite "abs_mult") (("1" (expand "abs" 1 3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "abs") (("2" (grind-reals) (("2" (rewrite "FminusCorrect") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (expand* "Fminus" "Fbounded?") (("2" (flatten) (("2" (expand "min") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Fbounded? const-decl "bool" float nil) (minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (vNum const-decl "posnat" float nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (radix formal-const-decl "above(1)" float nil) (>= const-decl "bool" reals nil) (float type-eq-decl nil float nil) (Fminus const-decl "float" float nil) (q skolem-const-decl "float" float nil) (p skolem-const-decl "float" float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (abs_mult formula-decl nil real_props nil) (FminusCorrect formula-decl nil float nil) (TRUE const-decl "bool" booleans nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_times_pos_lt1 formula-decl nil real_props nil) (<= const-decl "bool" reals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_minus_real_is_real application-judgement "real" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (FtoR const-decl "real" float nil)) shostak)) (Sterbenz 0 (Sterbenz-1 nil 3319906528 ("" (skeep) (("" (case "FtoR(p) <= FtoR(q)") (("1" (rewrite "SterbenzAux") nil nil) ("2" (case-replace "Fminus(q, p)=Fopp(Fminus(p, q))") (("1" (rewrite "FoppBounded") (("1" (rewrite "SterbenzAux") nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "Fminus" "Fopp") (("2" (case-replace "min(Fexp(q), Fexp(p)) = min(Fexp(p), Fexp(q))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "min") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FtoR const-decl "real" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (SterbenzAux formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_rat_is_rat application-judgement "rat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (FoppBounded formula-decl nil float nil) (real_times_real_is_real application-judgement "real" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (Fminus const-decl "float" float nil) (Fopp const-decl "float" float nil)) shostak)) (errorBoundedPlus 0 (errorBoundedPlus-1 nil 3319907549 ("" (case "FORALL (b: Format, f, p, q: float):
                      Fbounded?(b)(p) =>
                       Fbounded?(b)(q) =>
                        Fbounded?(b)(f) => Fexp(p) <= Fexp(q) =>
                         Closest?(b)(FtoR(p) + FtoR(q), f) =>
                          (EXISTS (e: (Fbounded?(b))):
                             FtoR(e) = FtoR(p) + FtoR(q) - FtoR(f) AND
                              Fexp(e) = min(Fexp(p), Fexp(q)))") (("1" (skeep) (("1" (case "Fexp(p) <= Fexp(q)") (("1" (inst -2 "b" "f" "p" "q") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil) ("4" (propax) nil nil) ("5" (propax) nil nil) ("6" (propax) nil nil)) nil)) nil) ("2" (inst -1 "b" "f" "q" "p") (("2" (split) (("1" (skosimp*) (("1" (inst 2 "e!1") (("1" (split) (("1" (assert) nil nil) ("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (propax) nil nil) ("5" (propax) nil nil) ("6" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (lemma "RoundedModeRep") (("2" (inst -1 "Closest?" "b" "f" "Fplus(p,q)") (("2" (split) (("1" (skosimp*) (("1" (case "FtoR(Fminus(Fplus(p,q),(# Fnum := m!1, Fexp := Fexp(Fplus(p, q)) #)))=FtoR(p)+FtoR(q)-FtoR(f)") (("1" (case "Fexp(Fminus(Fplus(p,q),(# Fnum := m!1, Fexp := Fexp(Fplus(p, q)) #)))=Fexp(p)") (("1" (inst 1 "(Fminus(Fplus(p, q), (# Fnum := m!1, Fexp := Fexp(Fplus(p, q)) #)))") (("1" (split) (("1" (propax) nil nil) ("2" (rewrite -1) (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "Fbounded?") (("2" (split) (("1" (mult-by 1 "radix^(Fexp(p))") (("1" (case-replace "abs(Fnum
                                            ((Fminus(Fplus(p, q),
                                                     (# Fnum := m!1, Fexp := Fexp(Fplus(p, q)) #)))))
                                       * radix ^ (Fexp(p))=abs(FtoR(p) + FtoR(q) - FtoR(f))") (("1" (expand "Closest?") (("1" (inst -9 "q") (("1" (case "abs(FtoR(q) - FtoR(p) - FtoR(q)) < vNum(b) * radix ^ (Fexp(p))") (("1" (case "abs(FtoR(p) + FtoR(q) - FtoR(f))=abs(FtoR(f) - FtoR(p) - FtoR(q))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -6 -7 -8 -9 2) (("2" (flatten) (("2" (assert) (("2" (expand "FtoR") (("2" (rewrite "abs_mult") (("2" (rewrite "abs_mult") (("2" (expand "abs" 1 1) (("2" (expand "abs" 1 2) (("2" (assert) (("2" (real-props :simple? t) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Fbounded?") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite -2 :dir rl) (("2" (expand "FtoR") (("2" (rewrite -1) (("2" (rewrite "abs_mult") (("2" (expand "abs" 1 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (rewrite -1) (("2" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand* "Fminus" "Fplus" "min") (("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "FminusCorrect") (("2" (rewrite "FplusCorrect") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FplusCorrect") nil nil) ("3" (rewrite "Closest_RoundedMode") nil nil) ("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((RoundedModeRep formula-decl nil float nil) (Fminus const-decl "float" float nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (b skolem-const-decl "Format" float nil) (p skolem-const-decl "float" float nil) (q skolem-const-decl "float" float nil) (m!1 skolem-const-decl "int" float nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_int_is_int application-judgement "int" integers nil) (abs_mult formula-decl nil real_props nil) (rat_abs_is_nonneg application-judgement "{r: nonneg_rat | r >= q}" real_defs nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (lt_times_lt_pos2 formula-decl nil real_props nil) (TRUE const-decl "bool" booleans nil) (one_times formula-decl nil extra_tegies nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (< const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (>= const-decl "bool" reals nil) (vNum const-decl "posnat" float nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (^ const-decl "real" exponentiation nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (posrat_exp application-judgement "posrat" exponentiation nil) (FminusCorrect formula-decl nil float nil) (FplusCorrect formula-decl nil float nil) (Closest_RoundedMode formula-decl nil float nil) (RND type-eq-decl nil float nil) (Fplus const-decl "float" float nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Fbounded? const-decl "bool" float nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (Closest? const-decl "bool" float nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (FtoR const-decl "real" float nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) shostak)) (errorBoundedMult_aux 0 (errorBoundedMult_aux-1 nil 3320160933 ("" (skeep) (("" (lemma "RoundedModeRep") (("" (inst -1 "isMin?" "b" "f" "Fmult(p,q)") (("" (split) (("1" (skosimp*) (("1" (case "FtoR(Fminus(Fmult(p,q),(# Fnum := m!1, Fexp := Fexp(Fmult(p, q)) #)))=FtoR(p) * FtoR(q) - FtoR(f)") (("1" (case "Fexp(Fminus(Fmult(p,q),(# Fnum := m!1, Fexp := Fexp(Fmult(p, q)) #)))=Fexp(p) + Fexp(q)") (("1" (inst 1 "(Fminus(Fmult(p, q), (# Fnum := m!1, Fexp := Fexp(Fmult(p, q)) #)))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil) ("2" (expand "Fbounded?" 1) (("2" (split) (("1" (mult-by 1 "radix^(Fexp(p) + Fexp(q))") (("1" (case "abs(Fnum
                                                                     ((Fminus(Fmult(p, q),
                                                                              (# Fnum := m!1, Fexp := Fexp(Fmult(p, q)) #)))))
                                                                * radix ^ (Fexp(p) + Fexp(q))=abs(FtoR(p) * FtoR(q) - FtoR(f))") (("1" (rewrite -1) (("1" (case "Fulp(b)(f) <= vNum(b) * radix ^ (Fexp(p) + Fexp(q))") (("1" (case "abs(FtoR(p) * FtoR(q) - FtoR(f)) < Fulp(b)(f)") (("1" (assert) nil nil) ("2" (hide 2 -1) (("2" (case-replace "abs(FtoR(p) * FtoR(q) - FtoR(f))=abs(FtoR(f)-(FtoR(p)*FtoR(q)))") (("1" (rewrite "RoundedModeUlp" :subst ("P" "isMin?")) (("1" (rewrite "isMin_RoundedMode") nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (case "vNum(b)=radix^Prec(b)") (("1" (case "Fbounded?(b)((# Fnum:=vNum(b)-1, Fexp:= Prec(b)+Fexp(p) + Fexp(q)#))") (("1" (case-replace "vNum(b) * radix ^ (Fexp(p) + Fexp(q))= Fulp(b)(
                                                                         (# Fnum:=vNum(b)-1, Fexp:= Prec(b)+Fexp(p) + Fexp(q)#))") (("1" (rewrite "FulpMonotone") (("1" (expand "isMin?") (("1" (flatten) (("1" (case "FtoR(p) * FtoR(q) <=
                                                                                          FtoR((# Fnum := vNum(b) - 1, Fexp := Fexp(p) + Fexp(q) + Prec(b) #))") (("1" (assert) nil nil) ("2" (hide 2 3 -1) (("2" (expand "FtoR") (("2" (rewrite "expt_plus") (("2" (rewrite "expt_plus") (("2" (div-by 1 "radix ^ (Fexp(q))*radix ^ (Fexp(p))") (("2" (case-replace "Fnum(p) * Fnum(q) * radix ^ (Fexp(p)) * radix ^ (Fexp(q)) /
                                                                                 (radix ^ (Fexp(q)) * radix ^ (Fexp(p)))=Fnum(p) * Fnum(q)") (("1" (case-replace "vNum(b) = radix ^ Prec(b)") (("1" (case-replace "(radix ^ Prec(b) * (radix ^ Fexp(p) * radix ^ Fexp(q) * radix ^ Prec(b)) -
                                                                                         radix ^ Fexp(p) * radix ^ Fexp(q) * radix ^ Prec(b))
                                                                                        / (radix ^ (Fexp(q)) * radix ^ (Fexp(p)))= (radix ^ Prec(b)-1)* radix ^ Prec(b)") (("1" (hide -1 -3 -4 -7 -10 -11 -12 -13) (("1" (expand "Fbounded?") (("1" (flatten) (("1" (expand "abs") (("1" (grind-reals) (("1" (case "Fnum(p) * Fnum(q) <= (radix ^ Prec(b) - 1) * Fnum(q)") (("1" (case "(radix ^ Prec(b) - 1) * Fnum(q) <= (radix ^ Prec(b) - 1) * radix ^ Prec(b)") (("1" (grind-reals) nil nil) ("2" (div-by 1 "radix ^ Prec(b) - 1") (("2" (grind-reals) nil nil)) nil)) nil) ("2" (div-by 1 "Fnum(q)") (("2" (hide -3 -4 -5 -6 -7 2) (("2" (copy -2) (("2" (rewrite -2 :dir rl) (("2" (flip-ineq -1) (("2" (hide -1) (("2" (case "forall (e1,e2:int): e1>= e2 OR e1 <= e2-1") (("1" (inst -1 "Fnum(p)" "vNum(b)") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (field 1) nil nil)) nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FulpCanonic") (("1" (rewrite "expt_plus") (("1" (rewrite "expt_plus") (("1" (rewrite "expt_plus") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "Fnormal?(b)((# Fnum := vNum(b) - 1, Fexp := Fexp(p) + Fexp(q) + Prec(b) #))") (("1" (expand "Fcanonic?") (("1" (assert) nil nil)) nil) ("2" (hide 2 3 4) (("2" (expand "Fnormal?") (("2" (lemma "radix_less_vNum") (("2" (inst -1 "b") (("2" (case "vNum(b) <= vNum(b) * radix - radix") (("1" (expand "abs" 1) (("1" (grind-reals) nil nil)) nil) ("2" (hide 2 -2 -3 -4 -5 -6 -7 -8 -9 -10 -11) (("2" (move-terms 1 l 1) (("2" (move-terms 1 r 2) (("2" (case "vNum(b) <= vNum(b) * radix - vNum(b)") (("1" (assert) nil nil) ("2" (div-by 1 "vNum(b)") (("2" (case-replace "(vNum(b) * radix - vNum(b)) / vNum(b)=radix -1") (("1" (assert) nil nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -2 -3 -4 -5 -6 -7 -8 2) (("2" (expand "Fbounded?") (("2" (lemma "radix_less_vNum") (("2" (inst -1 "b") (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "vNum") (("2" (propax) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite -2 :dir rl) (("2" (expand "FtoR" 1) (("2" (rewrite -1) (("2" (rewrite "abs_mult") (("2" (expand "abs" 1 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand* "Fmult" "Fminus" "min") nil nil)) nil) ("2" (rewrite "FminusCorrect") (("2" (rewrite "FmultCorrect") (("2" (rewrite -1) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FmultCorrect") nil nil) ("3" (rewrite "isMin_RoundedMode") nil nil) ("4" (propax) nil nil)) nil)) nil)) nil)) nil) ((RoundedModeRep formula-decl nil float nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (Fminus const-decl "float" float nil) (FtoR const-decl "real" float nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (b skolem-const-decl "Format" float nil) (p skolem-const-decl "float" float nil) (q skolem-const-decl "float" float nil) (m!1 skolem-const-decl "int" float nil) (<= const-decl "bool" reals nil) (Fulp const-decl "real" float nil) (RoundedModeUlp formula-decl nil float nil) (isMin_RoundedMode formula-decl nil float nil) (Fulp_posreal_j application-judgement "posreal" float nil) (posint_exp application-judgement "posint" exponentiation nil) (int_times_int_is_int application-judgement "int" integers nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_minus_le formula-decl nil real_props nil) (times_div_cancel1 formula-decl nil extra_real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (le_times_le_pos formula-decl nil real_props nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (pos_times_le formula-decl nil real_props nil) (TRUE const-decl "bool" booleans nil) (posrat nonempty-type-eq-decl nil rationals nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (div_cancel2 formula-decl nil real_props nil) (both_sides_times1 formula-decl nil real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (expt_plus formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (FulpMonotone formula-decl nil float nil) (Fnormal? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (div_simp formula-decl nil real_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (radix_less_vNum formula-decl nil float nil) (FulpCanonic formula-decl nil float nil) (int_minus_int_is_int application-judgement "int" integers nil) (abs_mult formula-decl nil real_props nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (< const-decl "bool" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (>= const-decl "bool" reals nil) (vNum const-decl "posnat" float nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (posrat_exp application-judgement "posrat" exponentiation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (FmultCorrect formula-decl nil float nil) (FminusCorrect formula-decl nil float nil) (Fmult const-decl "float" float nil) (isMin? const-decl "bool" float nil) (RND type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Format type-eq-decl nil float nil)) shostak)) (errorBoundedMult_aux2 0 (errorBoundedMult_aux2-1 nil 3320163336 ("" (skeep) (("" (lemma "RoundedModeRep") (("" (inst -1 "isMax?" "b" "f" "Fmult(p,q)") (("" (split) (("1" (skosimp*) (("1" (case "FtoR(Fminus(Fmult(p,q),(# Fnum := m!1, Fexp := Fexp(Fmult(p, q)) #)))=FtoR(p) * FtoR(q) - FtoR(f)") (("1" (case "Fexp(Fminus(Fmult(p,q),(# Fnum := m!1, Fexp := Fexp(Fmult(p, q)) #)))=Fexp(p) + Fexp(q)") (("1" (inst 1 "(Fminus(Fmult(p, q), (# Fnum := m!1, Fexp := Fexp(Fmult(p, q)) #)))") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil) ("2" (expand "Fbounded?" 1) (("2" (split) (("1" (mult-by 1 "radix^(Fexp(p) + Fexp(q))") (("1" (case "abs(Fnum
                                                                                        ((Fminus(Fmult(p, q),
                                                                                                 (# Fnum := m!1, Fexp := Fexp(Fmult(p, q)) #)))))
                                                                                   * radix ^ (Fexp(p) + Fexp(q))=abs(FtoR(p) * FtoR(q) - FtoR(f))") (("1" (rewrite -1) (("1" (case "Fulp(b)(f) <= vNum(b) * radix ^ (Fexp(p) + Fexp(q))") (("1" (case "abs(FtoR(p) * FtoR(q) - FtoR(f)) < Fulp(b)(f)") (("1" (assert) nil nil) ("2" (hide 2 -1) (("2" (case-replace "abs(FtoR(p) * FtoR(q) - FtoR(f))=abs(FtoR(f)-(FtoR(p)*FtoR(q)))") (("1" (rewrite "RoundedModeUlp" :subst ("P" "isMax?")) (("1" (rewrite "isMax_RoundedMode") nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 2) (("2" (case "vNum(b)=radix^Prec(b)") (("1" (case "Fbounded?(b)((# Fnum:=vNum(b)-1, Fexp:= Prec(b)+Fexp(p) + Fexp(q)#))") (("1" (case-replace "vNum(b) * radix ^ (Fexp(p) + Fexp(q))= Fulp(b)(
                                                                                             (# Fnum:=vNum(b)-1, Fexp:= Prec(b)+Fexp(p) + Fexp(q)#))") (("1" (rewrite "FulpMonotone") (("1" (expand "isMax?") (("1" (flatten) (("1" (inst -11 "(# Fnum := vNum(b) - 1, Fexp := Fexp(p) + Fexp(q) + Prec(b) #)") (("1" (rewrite -11) (("1" (hide 2 3 -1 -2 -3 -11) (("1" (expand "FtoR") (("1" (rewrite "expt_plus") (("1" (rewrite "expt_plus") (("1" (case-replace " vNum(b) = radix ^ Prec(b)") (("1" (div-by 1 "radix ^ (Fexp(q))*radix ^ (Fexp(p))") (("1" (case-replace "Fnum(p) * Fnum(q) * radix ^ (Fexp(p)) * radix ^ (Fexp(q)) /
                                                                                                       (radix ^ (Fexp(q)) * radix ^ (Fexp(p)))=Fnum(p) * Fnum(q)") (("1" (case-replace "(radix ^ Prec(b) * (radix ^ Fexp(p) * radix ^ Fexp(q) * radix ^ Prec(b)) -
                                                                                                                 radix ^ Fexp(p) * radix ^ Fexp(q) * radix ^ Prec(b))
                                                                                                                / (radix ^ (Fexp(q)) * radix ^ (Fexp(p)))= (radix ^ Prec(b)-1)* radix ^ Prec(b)") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (hide -1 -2) (("1" (expand "abs") (("1" (grind-reals) (("1" (case "Fnum(p) * Fnum(q) <= (radix ^ Prec(b) - 1) * Fnum(q)") (("1" (case "(radix ^ Prec(b) - 1) * Fnum(q) <= (radix ^ Prec(b) - 1) * radix ^ Prec(b)") (("1" (grind-reals) nil nil) ("2" (div-by 1 "radix ^ Prec(b) - 1") (("2" (grind-reals) nil nil)) nil)) nil) ("2" (div-by 1 "Fnum(q)") (("2" (hide -3 -4 -5 -6 -7 -8 -9 -10 -11 2) (("2" (case-replace "radix ^ Prec(b)= vNum(b)") (("1" (assert) (("1" (flip-ineq -2) (("1" (case "forall (e1,e2:int): e1>= e2 OR e1 <= e2-1") (("1" (inst -1 "Fnum(p)" "vNum(b)") (("1" (assert) nil nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (field 1) nil nil)) nil) ("2" (field 1) nil nil)) nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FulpCanonic") (("1" (rewrite "expt_plus") (("1" (rewrite "expt_plus") (("1" (rewrite "expt_plus") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "Fnormal?(b)((# Fnum := vNum(b) - 1, Fexp := Fexp(p) + Fexp(q) + Prec(b) #))") (("1" (expand "Fcanonic?") (("1" (assert) nil nil)) nil) ("2" (hide 2 3 4) (("2" (expand "Fnormal?") (("2" (lemma "radix_less_vNum") (("2" (inst -1 "b") (("2" (case "vNum(b) <= vNum(b) * radix - radix") (("1" (expand "abs") (("1" (grind-reals) nil nil)) nil) ("2" (hide-all-but (1 -1)) (("2" (move-terms 1 l 1) (("2" (move-terms 1 r 2) (("2" (case "vNum(b) <= vNum(b) * radix - vNum(b)") (("1" (assert) nil nil) ("2" (div-by 1 "vNum(b)") (("2" (case-replace "(vNum(b) * radix - vNum(b)) / vNum(b)=radix -1") (("1" (assert) nil nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Fbounded?") (("2" (split) (("1" (lemma "radix_less_vNum") (("1" (inst -1 "b") (("1" (expand "abs" 1) (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (expand "vNum") (("2" (propax) nil nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite -2 :dir rl) (("2" (expand "FtoR" 1) (("2" (rewrite -1) (("2" (rewrite "abs_mult") (("2" (expand "abs" 1 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand* "Fmult" "Fminus" "min") nil nil)) nil) ("2" (rewrite "FminusCorrect") (("2" (rewrite "FmultCorrect") (("2" (rewrite -1) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FmultCorrect") nil nil) ("3" (rewrite "isMax_RoundedMode") nil nil) ("4" (propax) nil nil)) nil)) nil)) nil)) nil) ((RoundedModeRep formula-decl nil float nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (Fminus const-decl "float" float nil) (FtoR const-decl "real" float nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_minus_real_is_real application-judgement "real" reals nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (b skolem-const-decl "Format" float nil) (p skolem-const-decl "float" float nil) (q skolem-const-decl "float" float nil) (m!1 skolem-const-decl "int" float nil) (<= const-decl "bool" reals nil) (Fulp const-decl "real" float nil) (RoundedModeUlp formula-decl nil float nil) (isMax_RoundedMode formula-decl nil float nil) (Fulp_posreal_j application-judgement "posreal" float nil) (posint_exp application-judgement "posint" exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (expt_plus formula-decl nil exponentiation nil) (int_times_int_is_int application-judgement "int" integers nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (NOT const-decl "[bool -> bool]" booleans nil) (both_sides_times1 formula-decl nil real_props nil) (div_cancel2 formula-decl nil real_props nil) (nonneg_rat nonempty-type-eq-decl nil rationals nil) (posrat nonempty-type-eq-decl nil rationals nil) (TRUE const-decl "bool" booleans nil) (pos_times_le formula-decl nil real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (times_div_cancel2 formula-decl nil extra_real_props nil) (le_times_le_pos formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (times_div_cancel1 formula-decl nil extra_real_props nil) (le_minus_le formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (posreal nonempty-type-eq-decl nil real_types nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (FulpMonotone formula-decl nil float nil) (Fnormal? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (div_simp formula-decl nil real_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (radix_less_vNum formula-decl nil float nil) (FulpCanonic formula-decl nil float nil) (int_minus_int_is_int application-judgement "int" integers nil) (abs_mult formula-decl nil real_props nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (< const-decl "bool" reals nil) (minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (>= const-decl "bool" reals nil) (vNum const-decl "posnat" float nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (posrat_exp application-judgement "posrat" exponentiation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (FmultCorrect formula-decl nil float nil) (FminusCorrect formula-decl nil float nil) (Fmult const-decl "float" float nil) (isMax? const-decl "bool" float nil) (RND type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Format type-eq-decl nil float nil)) nil)) (errorBoundedMult 0 (errorBoundedMult-1 nil 3320076840 ("" (skeep) (("" (case "0 <= FtoR(p)") (("1" (case "0 <= FtoR(q)") (("1" (case "0 <= FtoR(f)") (("1" (expand* "RoundedMode?" "MinOrMax?") (("1" (flatten) (("1" (inst -9 "FtoR(p)*FtoR(q)" "f") (("1" (split) (("1" (rewrite "errorBoundedMult_aux") nil nil) ("2" (rewrite "errorBoundedMult_aux2") nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "RleRoundedR0" :subst ("P" "P" "b" "b" "r" "FtoR(p)*FtoR(q)")) (("2" (grind-reals) nil nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (case "FtoR(f) <= 0") (("1" (expand* "RoundedMode?" "MinOrMax?") (("1" (flatten) (("1" (inst -9 "FtoR(p)*FtoR(q)" "f") (("1" (split) (("1" (lemma "errorBoundedMult_aux2") (("1" (inst -1 "b" "Fopp(f)" "p" "Fopp(q)") (("1" (split) (("1" (skosimp*) (("1" (inst 1 "Fopp(e!1)") (("1" (split) (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "Fopp") (("2" (propax) nil nil)) nil)) nil) ("2" (rewrite "FoppBounded") nil nil)) nil)) nil) ("2" (expand "Fopp") (("2" (propax) nil nil)) nil) ("3" (case-replace "FtoR(p) * FtoR(Fopp(q))=-(FtoR(p) * FtoR(q))") (("1" (rewrite "MinOppMax") nil nil) ("2" (rewrite "FoppCorrect") (("2" (assert) nil nil)) nil)) nil) ("4" (rewrite "FoppCorrect") (("4" (assert) nil nil)) nil) ("5" (rewrite "FoppCorrect") (("5" (assert) nil nil)) nil) ("6" (propax) nil nil) ("7" (rewrite "FoppBounded") nil nil) ("8" (rewrite "FoppBounded") nil nil) ("9" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "errorBoundedMult_aux") (("2" (inst -1 "b" "Fopp(f)" "p" "Fopp(q)") (("2" (split) (("1" (skosimp*) (("1" (inst 1 "Fopp(e!1)") (("1" (split) (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "Fopp") (("2" (propax) nil nil)) nil)) nil) ("2" (rewrite "FoppBounded") nil nil)) nil)) nil) ("2" (expand "Fopp") (("2" (propax) nil nil)) nil) ("3" (case-replace "FtoR(p) * FtoR(Fopp(q))=-(FtoR(p) * FtoR(q))") (("1" (rewrite "MaxOppMin") nil nil) ("2" (rewrite "FoppCorrect") (("2" (assert) nil nil)) nil)) nil) ("4" (rewrite "FoppCorrect") (("4" (assert) nil nil)) nil) ("5" (rewrite "FoppCorrect") (("5" (assert) nil nil)) nil) ("6" (propax) nil nil) ("7" (rewrite "FoppBounded") nil nil) ("8" (rewrite "FoppBounded") nil nil) ("9" (propax) nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "RleRoundedLessR0" :subst ("P" "P" "b" "b" "r" "FtoR(p)*FtoR(q)")) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (case "0 <= FtoR(q)") (("1" (case "FtoR(f) <= 0") (("1" (expand* "RoundedMode?" "MinOrMax?") (("1" (flatten) (("1" (inst -9 "FtoR(p)*FtoR(q)" "f") (("1" (split) (("1" (lemma "errorBoundedMult_aux2") (("1" (inst -1 "b" "Fopp(f)" "Fopp(p)" "q") (("1" (split) (("1" (skosimp*) (("1" (inst 1 "Fopp(e!1)") (("1" (split) (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "Fopp") (("2" (propax) nil nil)) nil)) nil) ("2" (rewrite "FoppBounded") nil nil)) nil)) nil) ("2" (expand "Fopp") (("2" (propax) nil nil)) nil) ("3" (case-replace "FtoR(Fopp(p)) * FtoR(q)=-(FtoR(p) * FtoR(q))") (("1" (rewrite "MinOppMax") nil nil) ("2" (rewrite "FoppCorrect") (("2" (assert) nil nil)) nil)) nil) ("4" (rewrite "FoppCorrect") (("4" (assert) nil nil)) nil) ("5" (propax) nil nil) ("6" (rewrite "FoppCorrect") (("6" (assert) nil nil)) nil) ("7" (rewrite "FoppBounded") nil nil) ("8" (propax) nil nil) ("9" (rewrite "FoppBounded") nil nil)) nil)) nil)) nil) ("2" (lemma "errorBoundedMult_aux") (("2" (inst -1 "b" "Fopp(f)" "Fopp(p)" "q") (("2" (split) (("1" (skosimp*) (("1" (inst 1 "Fopp(e!1)") (("1" (split) (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (rewrite "FoppCorrect") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "Fopp") (("2" (propax) nil nil)) nil)) nil) ("2" (rewrite "FoppBounded") nil nil)) nil)) nil) ("2" (expand "Fopp") (("2" (propax) nil nil)) nil) ("3" (case-replace "FtoR(Fopp(p)) * FtoR(q)=-(FtoR(p) * FtoR(q))") (("1" (rewrite "MaxOppMin") nil nil) ("2" (rewrite "FoppCorrect") (("2" (assert) nil nil)) nil)) nil) ("4" (rewrite "FoppCorrect") (("4" (assert) nil nil)) nil) ("5" (propax) nil nil) ("6" (rewrite "FoppCorrect") (("6" (assert) nil nil)) nil) ("7" (rewrite "FoppBounded") nil nil) ("8" (propax) nil nil) ("9" (rewrite "FoppBounded") nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "RleRoundedLessR0" :subst ("P" "P" "b" "b" "r" "FtoR(p)*FtoR(q)")) (("2" (grind-reals) nil nil)) nil)) nil) ("2" (flip-ineq 1) (("2" (case "0 <= FtoR(f)") (("1" (expand* "RoundedMode?" "MinOrMax?") (("1" (flatten) (("1" (inst -9 "FtoR(p)*FtoR(q)" "f") (("1" (split) (("1" (case-replace "FtoR(p) * FtoR(q)=FtoR(Fopp(p))*FtoR(Fopp(q))") (("1" (case-replace "Fexp(p) + Fexp(q)=Fexp(Fopp(p)) + Fexp(Fopp(q))") (("1" (rewrite "errorBoundedMult_aux") (("1" (rewrite "FoppCorrect") (("1" (assert) nil nil)) nil) ("2" (rewrite "FoppCorrect") (("2" (assert) nil nil)) nil) ("3" (rewrite "FoppBounded") nil nil) ("4" (rewrite "FoppBounded") nil nil)) nil) ("2" (expand "Fopp") (("2" (propax) nil nil)) nil)) nil) ("2" (rewrite "FoppCorrect") (("2" (rewrite "FoppCorrect") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (case-replace "Fexp(p) + Fexp(q)=Fexp(Fopp(p)) + Fexp(Fopp(q))") (("1" (case-replace "FtoR(p) * FtoR(q)=FtoR(Fopp(p))*FtoR(Fopp(q))") (("1" (rewrite "errorBoundedMult_aux2") (("1" (rewrite "FoppCorrect") (("1" (assert) nil nil)) nil) ("2" (rewrite "FoppCorrect") (("2" (assert) nil nil)) nil) ("3" (rewrite "FoppBounded") nil nil) ("4" (rewrite "FoppBounded") nil nil)) nil) ("2" (rewrite "FoppCorrect") (("2" (rewrite "FoppCorrect") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "Fopp") (("2" (propax) nil nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "RleRoundedR0" :subst ("P" "P" "b" "b" "r" "FtoR(p)*FtoR(q)")) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FtoR const-decl "real" float nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (RleRoundedLessR0 formula-decl nil float nil) (neg_times_le formula-decl nil real_props nil) (e!1 skolem-const-decl "(Fbounded?(b))" float nil) (MaxOppMin formula-decl nil float nil) (b skolem-const-decl "Format" float nil) (e!1 skolem-const-decl "(Fbounded?(b))" float nil) (FoppCorrect formula-decl nil float nil) (minus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (FoppBounded formula-decl nil float nil) (MinOppMax formula-decl nil float nil) (= const-decl "[T, T -> boolean]" equalities nil) (- const-decl "[numfield -> numfield]" number_fields nil) (Fopp const-decl "float" float nil) (errorBoundedMult_aux formula-decl nil float nil) (errorBoundedMult_aux2 formula-decl nil float nil) (Fbounded? const-decl "bool" float nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (RoundedMode? const-decl "bool" float nil) (MinOrMax? const-decl "bool" float nil) (pos_times_le formula-decl nil real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (RND type-eq-decl nil float nil) (RleRoundedR0 formula-decl nil float nil) (e!1 skolem-const-decl "(Fbounded?(b))" float nil) (e!1 skolem-const-decl "(Fbounded?(b))" float nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak)) (FulpLeN_TCC1 0 (FulpLeN_TCC1-1 nil 3698095010 ("" (subtype-tcc) nil nil) ((vNum const-decl "posnat" float nil) (Fbounded? const-decl "bool" float nil) (Fnormal? const-decl "bool" float nil) (int_times_int_is_int application-judgement "int" integers nil)) nil (FulpLeN subtype "float.p" "(float.Fbounded?(float.b))"))) (FulpLeN 0 (FulpLeN-1 nil 3320431414 ("" (skeep) (("" (rewrite "FulpCanonic") (("1" (expand "FtoR") (("1" (rewrite "abs_mult") (("1" (expand "abs" 1 2) (("1" (expand "Fnormal?") (("1" (flatten) (("1" (rewrite "abs_mult") (("1" (expand "abs" -2 1) (("1" (div-by 1 " radix ^ (Fexp(p))") (("1" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Fcanonic?") (("2" (propax) nil nil)) nil)) nil)) nil) ((FulpCanonic formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (Fulp_posreal_j application-judgement "posreal" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (abs_mult formula-decl nil real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (bool nonempty-type-eq-decl nil booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (rat_abs_is_nonneg application-judgement "{r: nonneg_rat | r >= q}" real_defs nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (int_times_int_is_int application-judgement "int" integers nil) (Fnormal? const-decl "bool" float nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (div_simp formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (div_cancel2 formula-decl nil real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (FtoR const-decl "real" float nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (Fcanonic? const-decl "bool" float nil)) shostak)) (FulpGe_TCC1 0 (FulpGe_TCC1-1 nil 3320431414 ("" (skeep) (("" (lemma "radix_less_vNum") (("" (inst -1 "b") (("" (grind-reals) nil nil)) nil)) nil)) nil) ((radix_less_vNum formula-decl nil float nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (FulpGe subtype "((number_fields.-)(float.vNum(float.b), 1))" "nznum"))) (FulpGe 0 (FulpGe-1 nil 3320431633 ("" (skeep) (("" (case-replace "FtoR(p)=FtoR(Fnormalize(b)(p))") (("1" (expand "FtoR" 1) (("1" (rewrite "abs_mult") (("1" (expand "abs" 1 2) (("1" (expand "Fulp") (("1" (div-by 1 " radix ^ (Fexp(Fnormalize(b)(p)))") (("1" (case-replace "abs(Fnum(Fnormalize(b)(p))) * radix ^ (Fexp(Fnormalize(b)(p))) /
                   (vNum(b) - 1)/ radix ^ (Fexp(Fnormalize(b)(p)))= abs(Fnum(Fnormalize(b)(p)))/(vNum(b) - 1)") (("1" (rewrite "div_cancel4") (("1" (field 1) (("1" (case "Fbounded?(b)(Fnormalize(b)(p))") (("1" (expand "Fbounded?") (("1" (flatten) (("1" (hide-all-but (-1 1)) (("1" (name-replace "AA" "vNum(b)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicBounded") nil nil)) nil)) nil)) nil) ("2" (field 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (FtoR const-decl "real" float nil) (Format type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (int_minus_int_is_int application-judgement "int" integers nil) (abs_mult formula-decl nil real_props nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (rat_abs_is_nonneg application-judgement "{r: nonneg_rat | r >= q}" real_defs nil) (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}" real_defs nil) (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}" real_defs nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (Fulp const-decl "real" float nil) (NOT const-decl "[bool -> bool]" booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (div_cancel2 formula-decl nil real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (fdx_238 skolem-const-decl "int" float nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (FcanonicBounded formula-decl nil float nil) (minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (div_cancel4 formula-decl nil real_props nil) (nonzero_real nonempty-type-eq-decl nil reals nil) (div_simp formula-decl nil real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (posreal nonempty-type-eq-decl nil real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (both_sides_div_pos_le1 formula-decl nil real_props nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil)) shostak)) (FulpLe 0 (FulpLe-2 "" 3790102975 ("" (skeep) (("" (case "Fcanonic?(b)(Fnormalize(b)(p))") (("1" (expand "Fcanonic?") (("1" (split) (("1" (case "Fulp(b)(p) <= abs(FtoR(p)) * radix/vNum(b)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case-replace "FtoR(p)=FtoR(Fnormalize(b)(p))") (("1" (case-replace "Fulp(b)(p)=Fulp(b)(Fnormalize(b)(p))") (("1" (rewrite "FulpLeN") nil nil) ("2" (expand "Fulp") (("2" (rewrite "FcanonicUnique" :subst ("b" "b" "p" "Fnormalize(b)(Fnormalize(b)(p))" "q" "Fnormalize(b)(p)")) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (case "Fulp(b)(p) = radix ^ (-dExp(b))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fulp" "Fsubnormal?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (<= const-decl "bool" reals nil) (FtoR const-decl "real" float nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Fbounded? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (FulpLeN formula-decl nil float nil) (FcanonicUnique formula-decl nil float nil) (minus_int_is_int application-judgement "int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (nonneg_real_max application-judgement "{z: nonneg_real | z >= x AND z >= y}" real_defs nil) (Fulp_posreal_j application-judgement "posreal" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnreal_div_posreal_is_nnreal application-judgement "nnreal" real_types nil) (Fulp const-decl "real" float nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (vNum const-decl "posnat" float nil) (int_times_int_is_int application-judgement "int" integers nil) (Fsubnormal? const-decl "bool" float nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (nnreal_times_nnreal_is_nnreal application-judgement "nnreal" real_types nil)) shostak) (FulpLe-1 nil 3320432430 ("" (skeep) (("" (case "Fcanonic?(b)(Fnormalize(b)(p))") (("1" (expand "Fcanonic?") (("1" (split) (("1" (case "Fulp(b)(p) <= abs(FtoR(p)) * radix/vNum(b)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (case-replace "FtoR(p)=FtoR(Fnormalize(b)(p))") (("1" (case-replace "Fulp(b)(p)=Fulp(b)(Fnormalize(b)(p))") (("1" (rewrite "FulpLeN") nil nil) ("2" (expand "Fulp") (("2" (rewrite "FcanonicUnique" :subst ("b" "b" "p" "Fnormalize(b)(Fnormalize(b)(p))" "q" "Fnormalize(b)(p)")) nil nil)) nil) ("3" (rewrite "FcanonicBounded") nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (case "Fulp(b)(p) = radix ^ (-dExp(b))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand* "Fulp" "Fsubnormal?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) nil shostak)) (FulpFpred1_TCC1 0 (FulpFpred1_TCC1-1 nil 3320433306 ("" (skeep) (("" (rewrite "FpredBounded") (("" (rewrite "FcanonicBounded") nil nil)) nil)) nil) ((FpredBounded formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (FcanonicBounded formula-decl nil float nil)) nil (FulpFpred1 subtype "float.Fpred(float.b)(float.p)" "(float.Fbounded?(float.b))"))) (FulpFpred1 0 (FulpFpred1-1 nil 3320490788 ("" (skeep) (("" (rewrite "FulpCanonic") (("1" (rewrite "FulpCanonic") (("1" (rewrite "Exp_increq_1") (("1" (rewrite "Lexico" :subst ("b" "b")) (("1" (lemma "FpredLt" :subst ("b" "b" "f" "p")) (("1" (assert) nil nil)) nil) ("2" (split-ineq -2) (("1" (case-replace "p=(# Fnum:=0, Fexp:=-dExp(b)#)") (("1" (hide-all-but 2) (("1" (expand "Fpred") (("1" (grind-reals) (("1" (lemma "radix_less_vNum" :subst ("b" "b")) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FcanonicUnique" :subst ("b" "b" "p" "p" "q" "(# Fnum := 0, Fexp := -dExp(b) #)")) (("1" (rewrite -1 :dir rl) (("1" (expand "FtoR" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "Fcanonic?" "Fsubnormal?" "Fbounded?") (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "FpredPos") nil nil)) nil) ("3" (rewrite "FpredCanonic") nil nil)) nil)) nil)) nil) ("2" (rewrite "FpredCanonic") nil nil)) nil)) nil) ((FulpCanonic formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fpred const-decl "float" float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (Fulp_posreal_j application-judgement "posreal" float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Exp_increq_1 formula-decl nil float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (FpredCanonic formula-decl nil float nil) (FtoR const-decl "real" float nil) (= const-decl "[T, T -> boolean]" equalities nil) (FcanonicUnique formula-decl nil float nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (Fsubnormal? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (Fcanonic? const-decl "bool" float nil) (zero_is_neg_zero formula-decl nil real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (radix_less_vNum formula-decl nil float nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (FpredPos formula-decl nil float nil) (FpredLt formula-decl nil float nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Lexico formula-decl nil float nil)) shostak)) (FulpFpred2 0 (FulpFpred2-2 "" 3790102978 ("" (skeep) (("" (rewrite "FulpCanonic") (("" (rewrite "FulpCanonic") (("1" (case-replace "radix * radix ^ (Fexp(Fpred(b)(p)))= radix ^ (1+Fexp(Fpred(b)(p)))") (("1" (rewrite "Exp_increq_1") (("1" (hide -1 2) (("1" (expand "Fpred") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "expt_plus") nil nil)) nil) ("2" (rewrite "FpredCanonic") nil nil)) nil)) nil)) nil) ((FulpCanonic formula-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fulp_posreal_j application-judgement "posreal" float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (FpredCanonic formula-decl nil float nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (radix formal-const-decl "above(1)" float nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (div_cancel4 formula-decl nil real_props nil) (minus_int_is_int application-judgement "int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (Exp_increq_1 formula-decl nil float nil) (expt_plus formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (posint_exp application-judgement "posint" exponentiation nil) (expt_x1 formula-decl nil exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posreal_times_posreal_is_posreal application-judgement "posreal" real_types nil) (Fpred const-decl "float" float nil)) shostak) (FulpFpred2-1 nil 3320491755 ("" (skeep) (("" (rewrite "FulpCanonic") (("" (rewrite "FulpCanonic") (("1" (case-replace "radix * radix ^ (Fexp(Fpred(b)(p)))= radix ^ (1+Fexp(Fpred(b)(p)))") (("1" (rewrite "Exp_increq_1") (("1" (hide -1 2) (("1" (expand "Fpred") (("1" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (rewrite "expt_plus") (("2" (rewrite "expt_x1") nil nil)) nil)) nil) ("2" (rewrite "FpredCanonic") nil nil)) nil)) nil)) nil) nil shostak)) (Fopp_RtoF 0 (Fopp_RtoF-1 nil 3681818301 ("" (skeep) (("" (use "FcanonicUnique") (("" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (use "EvenClosest_Unique") (("2" (expand "Unique?") (("2" (inst -1 "-x" "Fopp(RtoF(x))" "RtoF(-x)") (("1" (split -1) (("1" (assert) nil nil) ("2" (hide 2) (("2" (typepred "RtoF") (("2" (inst?) nil nil)) nil)) nil) ("3" (hide 2) (("3" (use "EvenClosestFopp") (("3" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (typepred "RtoF") (("2" (inst?) nil nil)) nil)) nil) ("3" (hide 2) (("3" (typepred "RtoF") (("3" (inst? -2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "FoppBounded") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "FcanonicOpp") (("3" (inst -1 "b" "RtoF(x)") (("3" (assert) (("3" (hide 2) (("3" (typepred "RtoF") (("3" (inst? -2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "RtoF") (("4" (inst? -2) nil nil)) nil)) nil)) nil)) nil)) nil) ((FcanonicUnique formula-decl nil float nil) (Fopp const-decl "float" float nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (CanonicRoundingFun type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil) (RNDF type-eq-decl nil float nil) (EvenClosest? const-decl "bool" float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (minus_real_is_real application-judgement "real" reals nil) (FcanonicOpp formula-decl nil float nil) (Unique? const-decl "bool" float nil) (FoppBounded formula-decl nil float nil) (NOT const-decl "[bool -> bool]" booleans nil) (EvenClosestFopp formula-decl nil float nil) (x skolem-const-decl "real" float nil) (RtoF skolem-const-decl "CanonicRoundingFun(b, EvenClosest?(b))" float nil) (b skolem-const-decl "Format" float nil) (EvenClosest_Unique formula-decl nil float nil)) shostak)) (ulp_abs 0 (ulp_abs-1 nil 3681747962 ("" (skeep) (("" (expand "ulp") (("" (lemma "FulpAbs") (("" (inst -1 "b" "RtoF(x)") (("" (assert) (("" (replace -1 :hide? t :dir rl) (("" (use "FulpCanonic") (("" (split -1) (("1" (replace -1 :hide? t) (("1" (lemma "FulpCanonic") (("1" (inst? -1) (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (expand "abs") (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "Fabs") (("1" (case "RtoF(-x)`Fexp = Fexp(RtoF(x))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (use "Fopp_RtoF") (("1" (grind) nil nil) ("2" (hide-all-but 1) (("2" (typepred "RtoF") (("2" (split 1) (("1" (skeep) (("1" (inst? -1) (("1" (typepred "round") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "Fabs") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "FabsCanonic") (("2" (assert) (("2" (hide-all-but 1) (("2" (typepred "RtoF") (("2" (inst? -2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "RtoF") (("2" (inst? -2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ulp const-decl "posreal" float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (Fbounded? const-decl "bool" float nil) (Rounding type-eq-decl nil float nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (EvenClosest? const-decl "bool" float nil) (RestrictedRounding type-eq-decl nil float nil) (RNDF type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil) (CanonicRoundingFun type-eq-decl nil float nil) (NOT const-decl "[bool -> bool]" booleans nil) (Fopp const-decl "float" float nil) (minus_int_is_int application-judgement "int" integers nil) (b skolem-const-decl "Format" float nil) (round skolem-const-decl "RestrictedRounding(b, EvenClosest?)" float nil) (RtoF skolem-const-decl "CanonicRoundingFun(b, round)" float nil) (Fopp_RtoF formula-decl nil float nil) (posrat_exp application-judgement "posrat" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (minus_real_is_real application-judgement "real" reals nil) (FabsCanonic formula-decl nil float nil) (Fabs const-decl "float" float nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (FulpCanonic formula-decl nil float nil) (Fulp_posreal_j application-judgement "posreal" float nil) (FulpAbs formula-decl nil float nil)) shostak)) (injrnd_ulp 0 (injrnd_ulp-1 nil 3681142042 ("" (skeep) (("" (expand "ulp") (("" (typepred "RtoF") (("" (expand "injective_rounding") (("" (flatten) (("" (inst -2 "f") (("1" (assert) nil nil) ("2" (expand "/=") (("2" (replace -1 1) (("2" (expand "Fulp" 1 2) (("2" (expand "Fnormalize") (("2" (assert) (("2" (expand "Fulp") (("2" (case "Fnum(f) = 0") (("1" (grind) nil nil) ("2" (use "ftor_zero_fnum") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ulp const-decl "posreal" float nil) (/= const-decl "boolean" notequal nil) (FtoR const-decl "real" float nil) (b skolem-const-decl "Format" float nil) (f skolem-const-decl "(Fbounded?(b))" float nil) (Fulp_posreal_j application-judgement "posreal" float nil) (int_times_int_is_int application-judgement "int" integers nil) (Fnormalize def-decl "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}" float nil) (ftor_zero_fnum formula-decl nil float nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (posrat_exp application-judgement "posrat" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (Fulp const-decl "real" float nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (Fbounded? const-decl "bool" float nil) (Rounding type-eq-decl nil float nil) (rounded_mode? const-decl "bool" float nil) (RNDF type-eq-decl nil float nil) (injective_rounding const-decl "bool" float nil)) shostak)) (Fulp_ulp 0 (Fulp_ulp-1 nil 3681141194 ("" (skeep) (("" (use "FulpAbs") (("" (assert) (("" (replace -1 :hide? t :dir rl) (("" (use "injrnd_ulp") (("" (replace -1 :hide? t) (("" (use "FabsCorrect") (("" (replace -1 :hide? t) (("" (use "ulp_monotone") (("" (assert) (("" (hide 2) (("" (case "NOT FORALL(x,y,z:real) : abs(x-y) <= z IMPLIES abs(x) <= abs(y) + z") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((FulpAbs formula-decl nil float nil) (Fbounded? const-decl "bool" float nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (float type-eq-decl nil float nil) (int nonempty-type-eq-decl nil integers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_plus_real_is_real application-judgement "real" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_real_is_real application-judgement "real" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (FtoR const-decl "real" float nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (ulp_monotone formula-decl nil float nil) (FabsCorrect formula-decl nil float nil) (Fabs const-decl "float" float nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (Rounding type-eq-decl nil float nil) (rounded_mode? const-decl "bool" float nil) (RNDF type-eq-decl nil float nil) (injective_rounding const-decl "bool" float nil) (injrnd_ulp formula-decl nil float nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Fulp_posreal_j application-judgement "posreal" float nil) (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types nil) (real_minus_real_is_real application-judgement "real" reals nil)) shostak)) (rndmaxismax_j 0 (rndmaxismax_j-1 nil 3699184522 ("" (skeep) (("" (split 1) (("1" (skeep) (("1" (use "RND_Max_isMax") nil nil)) nil) ("2" (skeep) (("2" (invoke (typepred "%1") (! 1 1)) nil nil)) nil)) nil)) nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (RND_Max_isMax formula-decl nil float nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil) (RND_Max const-decl "(Fcanonic?(b))" float nil)) nil (rndmaxismax_j subtype "float.RND_Max(float.b)" "float.CanonicRoundingFun(float.b, float.isMax?(float.b))"))) (rndminismin_j 0 (rndminismin_j-1 nil 3699182647 ("" (skeep) (("" (split 1) (("1" (skeep) (("1" (use "RND_Min_isMin") nil nil)) nil) ("2" (skeep) (("2" (invoke (typepred "%1") (! 1 1)) nil nil)) nil)) nil)) nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (RND_Min_isMin formula-decl nil float nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (float type-eq-decl nil float nil) (Fcanonic? const-decl "bool" float nil) (RND_Min const-decl "(Fcanonic?(b))" float nil)) nil (rndminismin_j subtype "float.RND_Min(float.b)" "float.CanonicRoundingFun(float.b, float.isMin?(float.b))"))) (rndeclosest_j 0 (rndeclosest_j-1 nil 3681830290 ("" (skeep) (("" (split 1) (("1" (skeep) (("1" (use "RND_EClosest_isEclosest") nil nil)) nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil) ((real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Format type-eq-decl nil float nil) (above nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (RND_EClosest_isEclosest formula-decl nil float nil)) nil (rndeclosest_j subtype "float.RND_EClosest(float.b)" "float.CanonicRoundingFun(float.b, float.EvenClosest?(float.b))"))))
