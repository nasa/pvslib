extended_float_mul
[ radix     : above(1),
  precision : above(1),
  dExp      : { d: posnat | d > 2*(precision-1) - 1 }
] : THEORY BEGIN

  IMPORTING extended_float_rounding[radix,precision,dExp]
  IMPORTING extended_float_operations_support[radix,precision,dExp]

  mul_non_finite(args: [efloat,efloat] | NOT is_finite?(args`1) OR NOT is_finite?(args`2))
  : efloat
  = LET x = args`1, y = args`2
    IN
    IF nan?(x) OR nan?(y) THEN nan_from(x,y)
    ELSIF   x = neginf  AND y = neginf    THEN posinf
    ELSIF   x = neginf  AND nznfinite?(y) THEN posinf
    ELSIF   x = neginf  AND y = negzero   THEN qnan
    ELSIF   x = neginf  AND y = poszero   THEN qnan
    ELSIF   x = neginf  AND nzpfinite?(y) THEN neginf
    ELSIF   x = neginf  AND y = posinf    THEN neginf

    ELSIF nznfinite?(x) AND y = neginf    THEN posinf
    ELSIF nznfinite?(x) AND y = negzero   THEN poszero
    ELSIF nznfinite?(x) AND y = poszero   THEN negzero
    ELSIF nznfinite?(x) AND y = posinf    THEN neginf

    ELSIF   x = negzero AND y = neginf    THEN qnan
    ELSIF   x = negzero AND y = posinf    THEN qnan

    ELSIF   x = poszero AND y = neginf    THEN qnan
    ELSIF   x = poszero AND y = posinf    THEN qnan
   
    ELSIF nzpfinite?(x) AND y = neginf    THEN neginf
    ELSIF nzpfinite?(x) AND y = negzero   THEN negzero
    ELSIF nzpfinite?(x) AND y = poszero   THEN poszero
    ELSIF nzpfinite?(x) AND y = posinf    THEN posinf

    ELSIF   x = posinf  AND y = neginf    THEN neginf
    ELSIF   x = posinf  AND nznfinite?(y) THEN neginf
    ELSIF   x = posinf  AND y = negzero   THEN qnan
    ELSIF   x = posinf  AND y = poszero   THEN qnan
    ELSIF   x = posinf  AND nzpfinite?(y) THEN posinf
    ELSE    posinf % Case: x = posinf  AND y = posinf

    ENDIF

  mul_zero(args: [(is_finite?), (is_finite?)] | zero?(args`1) OR zero?(args`2)): efloat
  = LET x = args`1, y = args`2 IN
  
       IF   x = negzero AND nznfinite?(y) THEN poszero
    ELSIF   x = negzero AND y = negzero   THEN poszero
    ELSIF   x = negzero AND y = poszero   THEN negzero
    ELSIF   x = negzero AND nzpfinite?(y) THEN negzero
    
    ELSIF   x = poszero AND nznfinite?(y) THEN negzero
    ELSIF   x = poszero AND y = negzero   THEN negzero
    ELSIF   x = poszero AND y = poszero   THEN poszero
    ELSIF   x = poszero AND nzpfinite?(y) THEN poszero
    
    ELSIF   nznfinite?(x) AND y = negzero THEN poszero
    ELSIF   nzpfinite?(x) AND y = negzero THEN negzero

    ELSIF   nznfinite?(x) AND y = poszero THEN negzero
    ELSE    poszero % case:  nzpfinite?(x) AND y = poszero THEN poszero
    
    ENDIF

  IMPORTING ieee754_operation_scheme__binary[
  	      efloat,
	      is_numeric?,
	      zero?,
	      is_finite?,
	      prj_ef,
	      rnd_ef,
	      trivial?1,
	      trivial?2,
	      LAMBDA(x,y:real):x*y,
	      mul_non_finite,
	      nan2,
	      mul_zero]

  mul_ed(X,Y: efloat): efloat = fun_fp(X,Y)

END extended_float_mul
