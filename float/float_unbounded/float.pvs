float[radix:above(1)]: THEORY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  This theory defines the representation and basic operations for 
%  floating point numbers for a given radix. 
%  Author: 
%  Sylvie Boldo (ENS-Lyon)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
EXPORTING ALL BUT ^ WITH ALL
BEGIN

  IMPORTING lnexp@ln_exp
  IMPORTING lnexp@expt
  IMPORTING lnexp@ln_approx

  ;^(r: real, i:{i:int | r /= 0 OR i >= 0}): MACRO real
    = exponentiation.^(r,i)
  
  % Type definitions
  float: TYPE = [# Fnum:int, Fexp:int #]
  
  float_pair(fn:int,fexp:int): float = (# Fnum := fn, Fexp := fexp #)
  
  Format: TYPE = [# Prec:above(1), dExp:nat #]
            
  vNum(b:Format):posnat = radix^Prec(b)  
  		      
  f,g,h: VAR float
  z,e1 : VAR int
  b    : VAR Format
  x,y  : VAR real
  n    : VAR nat
  
  radix_div_vNum : lemma integer_pred(vNum(b) / radix)
  radix_less_vNum: lemma radix <= vNum(b)
  
  % First functions
  
  FtoR(f):real=Fnum(f)*radix^(Fexp(f))
  CONVERSION FtoR
  
    ftor_zero_fnum : LEMMA
      FtoR(f) = 0 IMPLIES Fnum(f) = 0
  
  float_int(j:int): float = (# Fnum := j, Fexp := 0 #)
  
  float_int_def: LEMMA FORALL (j:int): FtoR(float_int(j)) = j
  
  Fabs(f):float= (# Fnum:=abs(Fnum(f)), Fexp:=Fexp(f) #)
  Fopp(f):float= (# Fnum:=-(Fnum(f)), Fexp:=Fexp(f) #)
  
  Fplus(f,g):float= (# Fnum:=Fnum(f)*radix^(Fexp(f)-min(Fexp(f),Fexp(g))) 
     + Fnum(g)*radix^(Fexp(g)-min(Fexp(f),Fexp(g))), Fexp:=min(Fexp(f),Fexp(g)) #)
  Fminus(f,g):float= (# Fnum:=Fnum(f)*radix^(Fexp(f)-min(Fexp(f),Fexp(g))) 
     - Fnum(g)*radix^(Fexp(g)-min(Fexp(f),Fexp(g))), Fexp:=min(Fexp(f),Fexp(g)) #)
  Fmult(f,g):float= (# Fnum:=Fnum(f)*Fnum(g), Fexp:=Fexp(f)+Fexp(g) #)
  
  Fle?(f,g):bool = Fnum(Fminus(f,g)) <= 0
  Flt?(f,g):bool = Fnum(Fminus(f,g)) <  0
  
  Fmin(f,g):float = if Fle?(f,g) then f else g endif
  Fmax(f,g):float = if Fle?(f,g) then g else f endif
  
  % Real Number Symbols on Floats
  
  ; +(f,g): float = Fplus(f,g)
  ; -(f,g): float = Fminus(f,g)
  ; *(f,g): float = Fmult(f,g)
  ; -(f)  : float = Fopp(f)
  ; <(f,g): bool = Flt?(f,g)
  ; <=(f,g): bool = Fle?(f,g)
  ; >(f,g): bool = Flt?(g,f)
  ; >=(f,g): bool = Fle?(g,f)
  
  rrr: VAR real
  ; <(f,rrr): bool = (FtoR(f) < rrr)
  ; <=(f,rrr): bool = (FtoR(f) <= rrr)
  ; >(f,rrr): bool = (FtoR(f) > rrr)
  ; >=(f,rrr): bool = (FtoR(f) >= rrr)
  ; >(rrr,f): bool = (f < rrr)
  ; >=(rrr,f): bool = (f <= rrr)
  ; <(rrr,f): bool = (f > rrr)
  ; <=(rrr,f): bool = (f >= rrr)
  ; /=(f,rrr): bool = (FtoR(f) /= rrr)
  ; /=(rrr,f): bool = (f /= rrr)
  
  % arithmetic properties
  
  sum_float_commutes: LEMMA f+g=g+f
  
  mult_float_commutes: LEMMA f*g=g*f
  
  % exponent
  
  Fexpt(f, (n:nat)): float = (# Fnum:=expt(Fnum(f),n), Fexp:=n*Fexp(f) #)
  ;^(f,(n:nat)): float = Fexpt(f,n)
  
  FexptCorrect: LEMMA FORALL (n:nat): FtoR(f^n) = FtoR(f)^n
  
  sq(f): float = Fmult(f,f)
  
  sigma(ii:nat,jj:nat,FF:[nat->float]): RECURSIVE float =
    IF ii > jj THEN float_int(0)
    ELSIF jj = 0 THEN FF(0)
    ELSE Fplus(FF(jj),sigma(ii,jj-1,FF))
    ENDIF MEASURE jj
  
  % Division by an integer that divides the radix
  
  FDivInt(f,(i:nzint | mod(radix,i)=0)) : float =
    (# Fnum:=Fnum(f)*(radix/i), Fexp:=Fexp(f)-1 #)
  
  FDivInt_def: LEMMA  FORALL (i:nzint): mod(radix,i)=0 IMPLIES
  	     FtoR(FDivInt(f,i)) = FtoR(f)/i
  
  % A bounded float
  Fbounded?(b)(f):bool= abs(Fnum(f))<vNum(b) AND -dExp(b) <= Fexp(f)
  
  minimum_positive_bounded_value(b): posreal
  = radix^-dExp(b)
  
  positive_minumum_bounded_closest_to_zero
  : LEMMA
    FORALL(bf: (Fbounded?(b)))
    : FtoR(bf) <= -minimum_positive_bounded_value(b)
      OR FtoR(bf) = 0
      OR minimum_positive_bounded_value(b) <= FtoR(bf)
  
  representability_limits_for_bounded_floats
  : LEMMA
    FORALL(E: int, bf: (Fbounded?(b)) | Fexp(bf) <= E)
    : LET maximum_positive_bounded_value: posreal = (vNum(b)-1) * radix^E
      IN ( -maximum_positive_bounded_value <= FtoR(bf) AND
      	   FtoR(bf) <= -minimum_positive_bounded_value(b) )
      	 OR FtoR(bf) = 0
      	 OR ( minimum_positive_bounded_value(b) <= FtoR(bf) AND
  	      FtoR(bf) <= maximum_positive_bounded_value )
  
  % Canonical representation
  Fnormal?(b)(f):bool= Fbounded?(b)(f) AND vNum(b)<=abs(radix*Fnum(f))
  
  Fsubnormal?(b)(f):bool= Fbounded?(b)(f) AND Fexp(f)=-dExp(b)
                        AND abs(radix*Fnum(f)) < vNum(b)
  
  Fcanonic?(b)(f):bool= Fnormal?(b)(f) OR Fsubnormal?(b)(f)
  
  % A few needed theorems
  
  hathatln: lemma (forall (r:posreal):
    radix^^(-(ln(r)/ln(radix)))=1/r)
  
  hathat_int: lemma 
    radix^^e1=radix^e1
  
  % Functions to get the predecessor, successor or canonical of a float 
  
  Fsucc(b)(f):float = IF Fnum(f)=vNum(b)-1 
      THEN (# Fnum:=vNum(b)/radix, Fexp:=Fexp(f)+1 #) 
      ELSIF  Fnum(f)=-vNum(b)/radix AND Fexp(f)>-dExp(b)
           THEN  (# Fnum:=-(vNum(b)-1), Fexp:=Fexp(f)-1 #) 
           ELSE  (# Fnum:=Fnum(f)+1, Fexp:=Fexp(f) #) 
      ENDIF
  
  Fpred(b)(f):float = IF Fnum(f)=-(vNum(b)-1) 
      THEN (# Fnum:=-vNum(b)/radix, Fexp:=Fexp(f)+1 #) 
      ELSIF  Fnum(f)=vNum(b)/radix AND Fexp(f)>-dExp(b)
           THEN  (# Fnum:=vNum(b)-1, Fexp:=Fexp(f)-1 #) 
           ELSE  (# Fnum:=Fnum(f)-1, Fexp:=Fexp(f) #) 
      ENDIF
  
  Fnormalize(b)(f:(Fbounded?(b))): recursive
  	{x : (Fcanonic?(b)) | FtoR(x)=FtoR(f)::real AND Fexp(x) <=  Fexp(f)} =
     if Fnum(f) = 0 then 
       (# Fnum:=0, Fexp:= -dExp(b)#)
     elsif Fexp(f) = -dExp(b) or 
                      abs(radix*Fnum(f)) >= vNum(b) then f
     else Fnormalize(b)((# Fnum:=radix*Fnum(f), Fexp:=Fexp(f)-1 #))
     endif
     measure vNum(b) - abs(Fnum(f))
  
  % Definition of the ulp
  
  Fulp(b)(f:(Fbounded?(b))):real = radix^(Fexp(Fnormalize(b)(f)))
  
  min_Fulp(b): nonneg_real = radix^(-dExp(b))
  
  Fulp_posreal_j: JUDGEMENT Fulp(b:Format)(f:(Fbounded?(b))) HAS_TYPE posreal
  
  % Definition of the rounding modes
  
  RND : TYPE = [b:Format -> [[real,(Fbounded?(b))]->bool]]
  
  Rounding(b:Format): TYPE = [[real,(Fbounded?(b))]->bool]
  
  P: VAR RND
  
  RestrictedRounding(b,P): TYPE =
    { round: Rounding(b) | âˆ€(f:(Fbounded?(b)),x): round(x,f) => P(b)(x,f) }
    
  % rounding functions
  RNDF(b:Format,round:Rounding(b)): TYPE =
    {f: [real->(Fbounded?(b))] | FORALL(x:real): round(x,f(x))}
  
  CanonicRoundingFun(b:Format,round:Rounding(b)): TYPE =
    { RtoF: RNDF(b,round) | FORALL(x:real): Fcanonic?(b)(RtoF(x)) }
  
  ulp(b,(P:Rounding(b)),(r:RNDF(b,P)))(x:real): posreal = Fulp(b)(r(x))
   
  injective_rounding(b:Format,round:Rounding(b))(RtoF:RNDF(b,round)): bool =
    (FORALL(f: (Fbounded?(b)) | FtoR(f) /= 0): RtoF(FtoR(f)) = f)
    AND Fnum(RtoF(0)) = 0
  
  exactly_representable(b:Format,round:Rounding(b),RtoF:RNDF(b,round))(x:real): bool =
    FtoR(RtoF(x)) = x
  
  exact_rep_conservation(b:Format,round:Rounding(b))(RtoF:RNDF(b,round)): bool =
    FORALL(f:(Fbounded?(b)),n:below(Prec(b)-Fexp(f))):
      exactly_representable(b,round,RtoF)(radix^n*FtoR(f))
  
  FtoR_inverse(b:Format,round:Rounding(b))(RtoF:RNDF(b,round)): bool =
    FORALL(f:(Fcanonic?(b))): RtoF(FtoR(f)) = f
  
  % Common rounding modes
  isMin?(b)(r:real,min:(Fbounded?(b))):bool =  (FtoR(min) <= r) AND
    (forall (f:(Fbounded?(b))): FtoR(f) <= r => FtoR(f) <= FtoR(min))
  
  TowardsNegativeInfinityRoundingPred(b:Format): TYPE =
      { round?: Rounding(b) |
           FORALL(x:real,f:(Fbounded?(b))): round?(x,f) IMPLIES isMin?(b)(x,f) }
  
  isMax?(b)(r:real,max:(Fbounded?(b))):bool =  (r <= FtoR(max)) AND
    (forall (f:(Fbounded?(b))): r <= FtoR(f) => FtoR(max) <= FtoR(f))
  
  TowardsPositiveInfinityRoundingPred(b:Format): TYPE =
      { round?: Rounding(b) |
           FORALL(x:real,f:(Fbounded?(b))): round?(x,f) IMPLIES isMax?(b)(x,f) }
  
  ToZero?(b)(r:real,c:(Fbounded?(b))):bool =  
      if 0 <= r then isMin?(b)(r,c)
                else isMax?(b)(r,c)
      endif
  
  Closest?(b)(r:real,c:(Fbounded?(b))):bool =  
    (forall (f:(Fbounded?(b))): abs(FtoR(c)-r) <= abs(FtoR(f)-r))
  
  ClosestRoundingPred(b:Format): TYPE =
      { round?: Rounding(b) |
           FORALL(x:real,f:(Fbounded?(b))): round?(x,f) IMPLIES Closest?(b)(x,f) }
  
  ClosestRoundingFun(b:Format,round:Rounding(b)): TYPE =
    { RtoF: RNDF(b,round) | FORALL(x:real): Closest?(b)(x,RtoF(x)) }
  
  EvenClosest?(b)(r:real,c:(Fbounded?(b))):bool =  Closest?(b)(r,c) AND
    (even?(Fnum(Fnormalize(b)(c))) OR 
        (forall (f:(Fbounded?(b))): Closest?(b)(r,f) => FtoR(f)=FtoR(c)::real))
  
  EvenClosestRoundingPred(b:Format): TYPE =
      { round?: Rounding(b) |
           FORALL(x:real,f:(Fbounded?(b))): round?(x,f) IMPLIES EvenClosest?(b)(x,f) }
  
  AFZClosest?(b)(r:real,c:(Fbounded?(b))):bool =  Closest?(b)(r,c) AND
    (abs(r) <= abs(FtoR(c)) OR 
        (forall (f:(Fbounded?(b))): Closest?(b)(r,f) => FtoR(f)=FtoR(c)::real))
  
  %
  
  FoppBounded: lemma 
     Fbounded?(b)(f) => Fbounded?(b)(Fopp(f))
  
  % Generic rounding mode
  Total?(b)(P):bool = (forall (r:real): 
          (exists (f:(Fbounded?(b))): P(b)(r,f)))
  
  total?(b)(P:Rounding(b)):bool =
    FORALL(r:real): EXISTS(f:(Fbounded?(b))): P(r,f)
  
  Compatible?(b)(P):bool = (forall (r1,r2:real, f1,f2:(Fbounded?(b))): 
     P(b)(r1,f1) => r1=r2 => FtoR(f1)=FtoR(f2)::real => P(b)(r2,f2))
  
  compatible?(b)(P:Rounding(b)):bool =
    FORALL(r1,r2:real, f1,f2:(Fbounded?(b))): 
      P(r1,f1) AND
      r1=r2 AND
      FtoR(f1)=FtoR(f2)::real
      IMPLIES P(r2,f2)
  
  MinOrMax?(b)(P):bool = (forall (r:real,f:(Fbounded?(b))):
      P(b)(r,f) => isMin?(b)(r,f) OR isMax?(b)(r,f))
  
  min_or_max?(b)(P:Rounding(b)): bool =
    FORALL(r:real,f:(Fbounded?(b))):
      P(r,f) => isMin?(b)(r,f) OR isMax?(b)(r,f)
  
  Monotone?(b)(P: RND):bool = (forall (r1,r2:real, f1,f2:(Fbounded?(b))):
     r1 < r2 => P(b)(r1,f1) =>  P(b)(r2,f2) => FtoR(f1) <= FtoR(f2))
  
  monotone?(b)(P:Rounding(b)):bool =
    FORALL (r1,r2:real, f1,f2:(Fbounded?(b))):
      r1 < r2 AND
      P(r1,f1) AND
      P(r2,f2)
      IMPLIES FtoR(f1) <= FtoR(f2)
  
  RoundedMode?(b)(P):bool = 
    Total?(b)(P) AND Compatible?(b)(P) AND MinOrMax?(b)(P) AND Monotone?(b)(P)
  
  rounded_mode?(b)(P:Rounding(b)):bool = 
    total?(b)(P) AND compatible?(b)(P) AND min_or_max?(b)(P) AND monotone?(b)(P)
  
  Unique?(b)(P):bool = (forall (r:real,f1,f2:(Fbounded?(b))): 
         P(b)(r,f1) => P(b)(r,f2) => FtoR(f1)=FtoR(f2)::real)
  
  rounded_opp?(b)(P:Rounding(b)):bool = (forall (r:real,p:(Fbounded?(b))): 
    P(r,p)=> P(-r,Fopp(p)))
  
  % A few needed theorems
  FcanonicOpp: lemma
     Fcanonic?(b)(f) IFF Fcanonic?(b)(Fopp(f))
  
  FcanonicBounded: lemma
     Fcanonic?(b)(f) => Fbounded?(b)(f)
  
  canonic_bounded_j: JUDGEMENT
    (Fcanonic?(b)) SUBTYPE_OF (Fbounded?(b))
  
  FpredCanonic: lemma
     Fcanonic?(b)(f) => Fcanonic?(b)(Fpred(b)(f))
  
  % Function to get the rounding down or up of a real
  
  RND_log_compute: LEMMA
    âˆ€(x:real): x>=radix^(-dExp(b)-1)*vNum(b)
               => floor(ln(x*radix/vNum(b))/ln(radix))
  	        = log_nat(x * radix ^ (1 + dExp(b) - Prec(b)),radix)`1-dExp(b)
  
  RND_aux(b)(x:nonneg_real): (Fcanonic?(b)) =
    if (x < radix^(-dExp(b)-1)*vNum(b))
       then (# Fnum:=floor(x*radix^(dExp(b))), Fexp:=-dExp(b) #)
       else let e=log_nat(x*radix ^ (1 + dExp(b) - Prec(b)),radix)`1-dExp(b) in
            (# Fnum:=floor(x*radix^(-e)), Fexp:=e #)
    endif
  
  
  RND_aux_alt(b)(x:nonneg_real): (Fcanonic?(b)) =
    if (x < radix^(-dExp(b)-1)*vNum(b))
       then (# Fnum:=floor(x*radix^(dExp(b))), Fexp:=-dExp(b) #)
       else let e=floor(ln(x*radix/vNum(b))/ln(radix)) in
            (# Fnum:=floor(x*radix^(-e)), Fexp:=e #)
    endif
  
  RND_aux_alt_def: LEMMA RND_aux=RND_aux_alt
  
  RND_Min(b)(x:real): (Fcanonic?(b)) =
    IF (0 <= x)
    THEN RND_aux(b)(x)
    ELSE LET fmx  = RND_aux(b)(-x),
             ofmx = Fopp(fmx) IN
         IF FtoR(ofmx)=x
         THEN ofmx
         ELSE Fpred(b)(ofmx) ENDIF ENDIF
  
  RND_Max(b)(x:real): (Fcanonic?(b)) = Fopp(RND_Min(b)(-x))
  
    % #TODO prove TCCs
    RND_ToZero(b)(x:real): (Fcanonic?(b))
    = IF (0 <= x) THEN RND_Min(b)(x)
      ELSE RND_Max(b)(x) ENDIF
           
  % Computable Rounding Functions
  
  % Function to get the even closest rounding
  
  RND_EClosest(b)(x:real): (Fcanonic?(b)) =
    LET min = RND_Min(b)(x),
        fmin = FtoR(min),
        min_err = abs(fmin-x),
        max = RND_Max(b)(x),
        fmax = FtoR(max),
        max_err = abs(fmax-x)
    IN IF    min_err < max_err THEN min
       ELSIF max_err < min_err THEN max
       ELSIF fmin=fmax         THEN min
       ELSIF even?(Fnum(min))  THEN min
       ELSE                         max ENDIF
  
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% End of definitions %%%%%%%%%%%%%%%%%%%%%%%%%%%
  e2         : VAR int
  q,p        : VAR float
  z1,z2,z3,r : VAR real
  
  % lemmas about exp
  Exp_incr_1: lemma
    e1 < e2 => radix^e1 < radix^e2
  
  Exp_incr_2: lemma
    radix^e1 < radix^e2 => e1 < e2
  
  Exp_increq_1: lemma
    e1 <= e2 => radix^e1 <= radix^e2
  
  Exp_increq_2: lemma
    radix^e1 <= radix^e2 => e1 <= e2
  
  Exp_1 : lemma
    radix^e1 = 1 => e1 = 0
  
  EqExpEq: lemma
    radix^e1=radix^e2 => e1=e2
  
  expt_odd: lemma
      (odd?(radix) IFF odd?(radix^(n+1)))
  
  expt_even: lemma
      (even?(radix) IFF even?(radix^(n+1)))
  
  % First lemmas about floats
  FoppCorrect: lemma
    FtoR(Fopp(f))=-FtoR(f)
  
  FoppFopp: LEMMA
  	  Fopp(Fopp(f)) = f
  
  Fopp_mult_left: LEMMA
  		(-f)*g = -(f*g)
  
  Fopp_mult_right: LEMMA
  		f*(-g) = -(f*g)
  
  FabsCorrect: lemma
     FtoR(Fabs(f))=abs(FtoR(f))
  
  FplusCorrect: lemma
     FtoR(Fplus(p,q))=FtoR(p)+FtoR(q)
  
  FplusAssociative: LEMMA associative?[float](Fplus)
  
  FmultAssociative: LEMMA associative?[float](Fmult)
  
  FminusCorrect: lemma
     FtoR(Fminus(p,q))=FtoR(p)-FtoR(q)
  
  FmultCorrect: lemma
     FtoR(Fmult(p,q))=FtoR(p)*FtoR(q)
  
  Fmult_1_r: LEMMA f*float_int(1) = f
  
  Fmult_1_l: LEMMA float_int(1)*f = f
  
  Fmult_2_r: LEMMA f*float_int(2) = f+f
  
  Fmult_2_l: LEMMA float_int(2)*f = f+f
  
  FDivKexpt(f,(k:nzint | mod(radix,k)=0),(i:nat)): float =
    (# Fnum:=Fnum(f)*((radix^i)/(k^i)), Fexp:=Fexp(f)-i #)
  
  FDivKexpt_def: LEMMA FORALL (i:nat,(k:nzint | mod(radix,k)=0)):
  	       FtoR(FDivKexpt(f,k,i)) = FtoR(f)/k^i
  
  FabsBounded: lemma 
     Fbounded?(b)(f) => Fbounded?(b)(Fabs(f))
  
  FabsCanonic: lemma 
     Fcanonic?(b)(f) => Fcanonic?(b)(Fabs(f))
  
  LeR0Fnum: lemma  
     0 <= FtoR(p) => 0 <= Fnum(p)
  
  LeFnumZERO: lemma 
     0 <= Fnum(p) => 0 <= FtoR(p)
  
  Lt0RFnum: lemma  
     FtoR(p) < 0 => Fnum(p) < 0
  
  LtZEROFnum: lemma 
     Fnum(p) < 0 => FtoR(p) < 0
     
  GtR0Fnum: lemma  
     FtoR(p) > 0 => Fnum(p) > 0
  
  GtFnumZERO: lemma 
     Fnum(p) > 0 => FtoR(p) > 0
  
  FleCorrect: lemma
     Fle?(p,q) IFF FtoR(p) <= FtoR(q)
  
  FtoR_monotonic: lemma
    p <= q IFF FtoR(p) <= FtoR(q)
  
  rndf_monotone: LEMMA
    FORALL(round: (monotone?(b)), RtoF: RNDF(b,round)):
      x <= y IMPLIES RtoF(x) <= RtoF(y)
  
  FltCorrect: lemma
     Flt?(p,q) IFF FtoR(p) < FtoR(q)
  
  Fle_transitive: LEMMA transitive?(<=::pred[[float,float]])
  
  Flt_transitive: LEMMA transitive?(<::pred[[float,float]])
  
  Fle_neg_Flt: LEMMA (NOT f<g) = g<=f
  
  Flt_Fle_Flt: LEMMA f<g AND g<=h IMPLIES f<h
  
  FminCorrect: lemma
     FtoR(Fmin(p,q))=min(FtoR(p),FtoR(q))
  
  FmaxCorrect: lemma
     FtoR(Fmax(p,q))=max(FtoR(p),FtoR(q))
  
  % Unicity of the canonical representant
  FsubnormalUnique: lemma
      Fsubnormal?(b)(p) => Fsubnormal?(b)(q) => FtoR(p)=FtoR(q)::real => p=q
  
  FnormalUnique: lemma
      Fnormal?(b)(p) => Fnormal?(b)(q) => FtoR(p)=FtoR(q)::real => p=q
  
  NormalAndSubNormalNotEq: lemma
      Fnormal?(b)(p) => Fsubnormal?(b)(q) => FtoR(p) /= FtoR(q)::real
  
  FcanonicUnique: lemma
      Fcanonic?(b)(p) => Fcanonic?(b)(q) => FtoR(p)=FtoR(q)::real => p=q
  
  Fle_definition: LEMMA
    Fcanonic?(b)(f) AND
    Fcanonic?(b)(g)
    IMPLIES f<=g = (f<g OR f=g)
  
  % A few properties on canonical representations
  FnormalizeCorrect: lemma 
      Fbounded?(b)(p) => FtoR(Fnormalize(b)(p))=FtoR(p)::real
  
  FnormalizeCanonicFnum: LEMMA
      Fcanonic?(b)(p) => Fnum(Fnormalize(b)(p)) = Fnum(p)
  
  FulpCanonic: lemma
     Fcanonic?(b)(p) => Fulp(b)(p)=radix^(Fexp(p))
  
  Fulp_min: LEMMA
      FORALL(f:(Fbounded?(b))): min_Fulp(b) <= Fulp(b)(f)
  
  Lexico: lemma
     Fcanonic?(b)(p) => Fcanonic?(b)(q) => 0 <= FtoR(p) => FtoR(p) <= FtoR(q)
       => Fexp(p) <= Fexp(q)
  
  CanonicLeastExp: lemma
     Fcanonic?(b)(p) => Fbounded?(b)(q) => FtoR(p)=FtoR(q)::real
       => Fexp(p) <= Fexp(q)
  
  Fast_canonic: lemma
     Fbounded?(b)(p) => Fexp(p)=-dExp(b) OR vNum(b)<=abs(radix*Fnum(p))
          => Fcanonic?(b)(p)
  
  % properties about the ulp
  FulpOpp: lemma Fbounded?(b)(f) => Fulp(b)(Fopp(f))=Fulp(b)(f)
  
  FulpAbs: lemma Fbounded?(b)(f) => Fulp(b)(Fabs(f))=Fulp(b)(f)
  
  FulpMonotone: lemma Fbounded?(b)(p) => Fbounded?(b)(q) =>
     0 <= FtoR(p) => FtoR(p) <= FtoR(q) => Fulp(b)(p) <= Fulp(b)(q)
   
  FulpMonotoneAbs: lemma Fbounded?(b)(p) => Fbounded?(b)(q) =>
     abs(FtoR(p)) <= abs(FtoR(q)) => Fulp(b)(p) <= Fulp(b)(q)
  
  FloatPlusUlpBounded: lemma
     Fbounded?(b)(p) => (exists (f:(Fbounded?(b))): FtoR(f)=FtoR(p)+Fulp(b)(p))
  
  FloatMinusUlpBounded: lemma
     Fbounded?(b)(p) => (exists (f:(Fbounded?(b))): FtoR(f)=FtoR(p)-Fulp(b)(p))
  
  % properties of Fpred and Fsucc
  FpredFoppFsucc: lemma 
      Fpred(b)(Fopp(f))=Fopp(Fsucc(b)(f))
  
  FsuccFoppFpred: lemma 
      Fsucc(b)(Fopp(f))=Fopp(Fpred(b)(f))
  
  FsuccFpred: lemma 
      Fcanonic?(b)(f) => Fsucc(b)(Fpred(b)(f))=f
  
  FpredFsucc: lemma 
      Fcanonic?(b)(f) => Fpred(b)(Fsucc(b)(f))=f
  
  FpredBounded: lemma
     Fbounded?(b)(f) => Fbounded?(b)(Fpred(b)(f))
  
  FsuccBounded: lemma
     Fbounded?(b)(f) => Fbounded?(b)(Fsucc(b)(f))
  
  FsuccCanonic: lemma
     Fcanonic?(b)(f) => Fcanonic?(b)(Fsucc(b)(f))
  
  FpredPos: lemma
    Fcanonic?(b)(p) => 0 < FtoR(p) => 0 <= FtoR(Fpred(b)(p))
  
  FsuccPos: lemma
    Fcanonic?(b)(p) => 0 <= FtoR(p) => 0 < FtoR(Fsucc(b)(p))
  
  FpredDiff: lemma
     Fcanonic?(b)(f) => 0 < FtoR(f)
        => FtoR(f)-FtoR(Fpred(b)(f))=Fulp(b)(Fpred(b)(f))
  
  FsuccDiff: lemma
     Fcanonic?(b)(f) => 0 <= FtoR(f)
        => FtoR(Fsucc(b)(f))-FtoR(f)=Fulp(b)(f)
  
  FpredLt: lemma
      FtoR(Fpred(b)(f)) < FtoR(f)
  
  FpredLe_aux: lemma
     Fcanonic?(b)(p) => Fcanonic?(b)(q) => 0 < FtoR(p) =>
       FtoR(p) <= FtoR(q) => FtoR(Fpred(b)(p)) <= FtoR(Fpred(b)(q))
  
  FpredLe_aux2: lemma
     Fcanonic?(b)(p) => Fcanonic?(b)(q) => 0 <= FtoR(p) =>
       FtoR(p) <= FtoR(q) => FtoR(Fsucc(b)(p)) <= FtoR(Fsucc(b)(q))
  
  FpredLe: lemma
     Fcanonic?(b)(p) => Fcanonic?(b)(q) =>
      (FtoR(p) <= FtoR(q) IFF FtoR(Fpred(b)(p)) <= FtoR(Fpred(b)(q)))
  
  FsuccLe: lemma
     Fcanonic?(b)(p) => Fcanonic?(b)(q) =>
      (FtoR(p) <= FtoR(q) IFF FtoR(Fsucc(b)(p)) <= FtoR(Fsucc(b)(q)))
  
  FpredProp_aux: lemma
    Fcanonic?(b)(p) => Fcanonic?(b)(q) => 0 <= FtoR(p) => FtoR(p) < FtoR(q) 
           => FtoR(p) <= FtoR(Fpred(b)(q))
  
  FpredProp: lemma
    Fcanonic?(b)(p) => Fcanonic?(b)(q) => FtoR(p) < FtoR(q) 
        => FtoR(p) <= FtoR(Fpred(b)(q))
  
  FsuccLt: lemma
    FtoR(f) < FtoR(Fsucc(b)(f))
  
  FsuccProp: lemma
    Fcanonic?(b)(p) => Fcanonic?(b)(q) =>
       FtoR(p) < FtoR(q) => FtoR(Fsucc(b)(p)) <= FtoR(q)
  
  FsuccZleEq_aux: lemma
      e1 <= r => r < e1+1 => rational_pred(r) => integer_pred(r) => e1=r
  
  FsuccZleEq: lemma
      FtoR(p) <= FtoR(q) => FtoR(q) < FtoR(Fsucc(b)(p)) => Fexp(p) <= Fexp(q) => FtoR(p)=FtoR(q)::real
  
  % properties of odd and even
  EvenFsuccOdd_aux: lemma
    even?(vNum(b)-1) => odd?(vNum(b)/radix)
  
  EvenFsuccOdd: lemma
    Fcanonic?(b)(p) => even?(Fnum(p)) => odd?(Fnum(Fsucc(b)(p)))
  
  OddFsuccEven_aux: lemma
    odd?(vNum(b)-1) => even?(vNum(b)/radix)
  
  OddFsuccEven: lemma
    Fcanonic?(b)(p) => odd?(Fnum(p)) => even?(Fnum(Fsucc(b)(p)))
  
  % Rounding modes properties
  MinOppMax :  lemma Fbounded?(b)(p) => isMin?(b)(r,p)  => isMax?(b)(-r,Fopp(p))
  
  MaxOppMin :  lemma Fbounded?(b)(p) => isMax?(b)(r,p)  => isMin?(b)(-r,Fopp(p))
  
  ToZeroFopp: LEMMA rounded_opp?(b)(ToZero?(b))
  
  ClosestFopp: lemma Fbounded?(b)(p) => Closest?(b)(r,p)=> Closest?(b)(-r,Fopp(p))
  
  EvenClosestFopp: LEMMA Fcanonic?(b)(p) => EvenClosest?(b)(r,p)=> EvenClosest?(b)(-r,Fopp(p))
  
  RleRoundedR0 : lemma Fbounded?(b)(f) =>
    RoundedMode?(b)(P) => P(b)(r,f) => 0 <= r => 0 <= FtoR(f)
  
  rle_rounded_r0 : LEMMA
     FORALL(round: Rounding(b)):
      Fbounded?(b)(f) AND
      rounded_mode?(b)(round) AND
      round(r,f) AND
      0 <= r
      IMPLIES 0 <= FtoR(f)
  
  RleRoundedLessR0 : lemma Fbounded?(b)(f) => 
    RoundedMode?(b)(P) => P(b)(r,f) => r <= 0 => FtoR(f) <= 0
  
  %|- ulp_generic_monotone : PROOF
  %|- (then (skeep)(expand "ulp")(use "FulpMonotone")(assert)
  %|-   (spread (split -1)
  %|-    ((then (hide 2)(use "FleCorrect")(replace -1 :hide? t :dir rl)(lemma "rndf_monotone")(inst? -1 :where -3)
  %|-      (spread (inst?)
  %|-       ((then (assert)(expand "<=")(propax))
  %|-        (then (typepred "round")(expand "rounded_mode?")(flatten)))))
  %|-     (then (lemma "rle_rounded_r0")(inst? -1 :where -2)(inst? -1 :where 1)(inst?)(inst?)
  %|-      (spread (split -1)
  %|-       ((then (propax))
  %|-        (then (typepred "r::RNDF(b,round)")(inst -1 "x")(assert))
  %|-        (then (assert))
  %|-        (then (typepred "r::RNDF(b,round)")(inst -1 "x"))
  %|-        (then (propax))))))))
  %|- QED ulp_generic_monotone
  ulp_generic_monotone: LEMMA
    FORALL(round: (rounded_mode?(b)), r:RNDF(b,round)):
    0 <= x AND x <= y
    IMPLIES ulp(b,round,r)(x) <= ulp(b,round,r)(y)
  
  RND_aux_le   : lemma (forall (x:nonneg_real): FtoR(RND_aux(b)(x)) <= x)
  
  RND_aux_ge   : lemma (forall (x:nonneg_real): x < FtoR(Fsucc(b)(RND_aux(b)(x))))
  
  RND_Min_isMin: lemma isMin?(b)(r,RND_Min(b)(r))
  
  RND_Max_isMax: lemma isMax?(b)(r,RND_Max(b)(r))
  
  RND_ToZero_ToZero: LEMMA FORALL (x: real): ToZero?(b)(x, RND_ToZero(b)(x))
  
  % Rounding floats to bounded
  
  RND_aux_float(b)((f|Fnum(f)>=0)): (Fcanonic?(b)) =
    IF (Fnum(f) < radix^(Prec(b)-Fexp(f)-dExp(b)-1))
    THEN (# Fnum := floor(Fnum(f)*radix^(dExp(b)+Fexp(f))),Fexp := -dExp(b) #)
    ELSE LET e =log_nat(Fnum(f)*radix^(Fexp(f)+1+dExp(b)-Prec(b)),
  			radix)`1-dExp(b)
         IN (# Fnum := floor(Fnum(f)*radix^(Fexp(f)-e)),Fexp := e #)
    ENDIF
  
  RND_aux_float_def: LEMMA Fnum(f)>=0 IMPLIES
    RND_aux_float(b)(f) = RND_aux(b)(FtoR(f))
  
  RND_float_Min(b)(f): (Fcanonic?(b)) =
    if (0 <= Fnum(f)) 
      then RND_aux_float(b)(f)
      elsif FtoR(Fopp(RND_aux_float(b)(-f)))=FtoR(f) then Fopp(RND_aux_float(b)(-f))
      else  Fpred(b)(Fopp(RND_aux_float(b)(-f)))
    endif
  
  RND_float_Min_def: LEMMA
    RND_float_Min(b)(f) = RND_Min(b)(FtoR(f))
  
  RND_float_Max(b)(f): (Fcanonic?(b)) = Fopp(RND_float_Min(b)(-f))
  
  RND_float_Max_def: LEMMA
    RND_float_Max(b)(f) = RND_Max(b)(FtoR(f))
  
  RND_float_Min_ge_canonic: LEMMA Fcanonic?(b)(g) IMPLIES
  	    (RND_float_Min(b)(f) >= g IFF f>=g)
  
  RND_float_Max_le_canonic: LEMMA Fcanonic?(b)(g) IMPLIES
  	    (RND_float_Max(b)(f) <= g IFF f<=g)
  
  RND_float_Min_canonic: LEMMA Fcanonic?(b)(f) IMPLIES
              RND_float_Min(b)(f) = f
  
  RND_float_Max_canonic: LEMMA Fcanonic?(b)(f) IMPLIES
              RND_float_Max(b)(f) = f
  
  RND_float_Min_ge: LEMMA
  	    f>=g IMPLIES RND_float_Min(b)(f)>=RND_float_Min(b)(g)
  
  RND_float_Min_le: LEMMA
  	    f<=g IMPLIES RND_float_Min(b)(f)<=RND_float_Min(b)(g)
  
  RND_float_Max_ge: LEMMA
  	    f>=g IMPLIES RND_float_Max(b)(f)>=RND_float_Max(b)(g)
  
  RND_float_Max_le: LEMMA
  	    f<=g IMPLIES RND_float_Max(b)(f)<=RND_float_Max(b)(g)
  
  RND_float_Min_lt_canonic: LEMMA Fcanonic?(b)(g) IMPLIES
  	    (RND_float_Min(b)(f) < g IFF f<g)
  
  RND_float_Min_gt_canonic: LEMMA Fcanonic?(b)(g) IMPLIES
  	    (RND_float_Max(b)(f) > g IFF f>g)
  
  RND_float_Min_ge_0: LEMMA RND_float_Min(b)(f) >= 0 IFF f>=0
  
  RND_float_Min_lt_0: LEMMA RND_float_Min(b)(f) < 0 IFF f<0
  
  RND_float_Max_le_0: LEMMA RND_float_Max(b)(f) <= 0 IFF f<=0
  
  RND_float_Max_gt_0: LEMMA RND_float_Max(b)(f) > 0 IFF f>0
  
  Fmult_canonic_id_Min: LEMMA Fcanonic?(b)(f) IMPLIES RND_float_Min(b)(f*Fnormalize(b)(float_int(1))) = f
  
  Fmult_canonic_id_Max: LEMMA Fcanonic?(b)(f) IMPLIES RND_float_Max(b)(f*Fnormalize(b)(float_int(1))) = f
  
  Fplus_canonic_id_Min: LEMMA Fcanonic?(b)(f) IMPLIES RND_float_Min(b)(f+Fnormalize(b)(float_int(0))) = f
  
  Fplus_canonic_id_Max: LEMMA Fcanonic?(b)(f) IMPLIES RND_float_Max(b)(f+Fnormalize(b)(float_int(0))) = f
  
  MaxSuccMin: lemma 
    Fcanonic?(b)(q) => Fcanonic?(b)(p) =>
    isMin?(b)(r,p) => isMax?(b)(r,q) => NOT FtoR(p)=FtoR(q)::real 
      => q=Fsucc(b)(p)
  
  LeMinMaxClosest: lemma Fbounded?(b)(f) =>  Fbounded?(b)(p) =>  Fbounded?(b)(q) => 
       isMin?(b)(r,p) =>  abs(FtoR(f)-r) <= abs(FtoR(p)-r) => isMax?(b)(r,q) =>  abs(FtoR(f)-r) <= abs(FtoR(q)-r)
        => Closest?(b)(r,f)
  
  isMin_Total       : lemma Total?(b)(isMin?)
  
  isMin_Compatible  : lemma Compatible?(b)(isMin?)
  
  isMin_Monotone    : lemma Monotone?(b)(isMin?)
  
  isMin_RoundedMode : lemma RoundedMode?(b)(isMin?)
  
  isMin_Unique      : lemma Unique?(b)(isMin?)
  
  isMax_Total       : lemma Total?(b)(isMax?)
  
  isMax_Compatible  : lemma Compatible?(b)(isMax?)
  
  isMax_Monotone    : lemma Monotone?(b)(isMax?)
  
  isMax_RoundedMode : lemma RoundedMode?(b)(isMax?)
  
  isMax_Unique      : lemma Unique?(b)(isMax?)
  
  ToZero_Total       : lemma Total?(b)(ToZero?)
  
  ToZero_Compatible  : lemma Compatible?(b)(ToZero?)
  
  ToZero_MinOrMax    : lemma MinOrMax?(b)(ToZero?)
  
  ToZero_Monotone    : lemma Monotone?(b)(ToZero?)
  
  ToZero_RoundedMode : lemma RoundedMode?(b)(ToZero?)
  
  ToZero_Unique      : lemma Unique?(b)(ToZero?)
  
  Closest_Total       : lemma Total?(b)(Closest?)
  
  Closest_total: LEMMA
    total?(b)(Closest?(b))
  
  Closest_Compatible  : lemma Compatible?(b)(Closest?)
  
  Closest_compatible: LEMMA
    compatible?(b)(Closest?(b))
  
  Closest_MinOrMax    : lemma MinOrMax?(b)(Closest?)
  
  Closest_min_or_max: LEMMA
    min_or_max?(b)(Closest?(b))
  
  Closest_Monotone    : lemma Monotone?(b)(Closest?)
  
  Closest_monotone: LEMMA
    monotone?(b)(Closest?(b))
  
  Closest_RoundedMode : lemma RoundedMode?(b)(Closest?)
  
  Closest_rounded_mode: LEMMA
    rounded_mode?(b)(Closest?(b))
  
  RND_EClosest_isEclosest : lemma EvenClosest?(b)(r,RND_EClosest(b)(r))
  
  Closest_bounded_exact_rep: LEMMA
    FORALL(b:Format,round:Rounding(b))
  	  (RtoF:RNDF(b,round) | FORALL(r:real): Closest?(b)(r,RtoF(r)))
  	  (x: real):
      (EXISTS(num,exp:int): abs(num) < vNum(b) AND
      			    -dExp(b) <= exp AND
  			    x = num*radix ^ exp)
        IMPLIES exactly_representable(b,round,RtoF)(x)
      
  ClosestRtoF_exact_rep_conv: COROLLARY
    FORALL(b:Format,round:Rounding(b))
  	  (RtoF:RNDF(b,round) | FORALL(r:real): Closest?(b)(r,RtoF(r))):
    exact_rep_conservation(b,round)(RtoF)
  
  Closest_int_exact_rep: COROLLARY
    FORALL(b:Format,round:Rounding(b))
  	  (RtoF:RNDF(b,round) | FORALL(r:real): Closest?(b)(r,RtoF(r)))
  	  (z: int | abs(z) <= vNum(b)):
      exactly_representable(b,round,RtoF)(z) 
  
  ClosestRNDF_FtoR_inverse: LEMMA
    FORALL(b     : Format,
  	   round : ClosestRoundingPred(b))
  	  (RtoF  : CanonicRoundingFun(b,round)):
      FtoR_inverse(b,round)(RtoF)
  
  EvenClosest_Total       : lemma Total?(b)(EvenClosest?)
  
  EvenClosest_total: LEMMA
    total?(b)(EvenClosest?(b))
  
  EvenClosest_Compatible  : lemma Compatible?(b)(EvenClosest?)
  
  EvenClosest_compatible: LEMMA
    compatible?(b)(EvenClosest?(b))  
  
  EvenClosest_MinOrMax    : lemma MinOrMax?(b)(EvenClosest?)
  
  EvenClosest_min_or_max: LEMMA
    min_or_max?(b)(EvenClosest?(b))
  
  EvenClosest_Monotone    : lemma Monotone?(b)(EvenClosest?)
  
  EvenClosest_monotone: LEMMA
    monotone?(b)(EvenClosest?(b))
  
  EvenClosest_RoundedMode : lemma RoundedMode?(b)(EvenClosest?)
  
  EvenClosest_rounded_mode: LEMMA
    rounded_mode?(b)(EvenClosest?(b))
  
  EvenClosest_Unique      : lemma Unique?(b)(EvenClosest?)
  
  AFZClosest_Total       : lemma Total?(b)(AFZClosest?)
  
  AFZClosest_Compatible  : lemma Compatible?(b)(AFZClosest?)
  
  AFZClosest_MinOrMax    : lemma MinOrMax?(b)(AFZClosest?)
  
  AFZClosest_Monotone    : lemma Monotone?(b)(AFZClosest?)
  
  AFZClosest_RoundedMode : lemma RoundedMode?(b)(AFZClosest?)
  
  AFZClosest_Unique      : lemma Unique?(b)(AFZClosest?)
  
  RoundedProjectorEq : lemma Fbounded?(b)(f) => Fbounded?(b)(p) => 
    RoundedMode?(b)(P) => P(b)(FtoR(f),p) => FtoR(p)=FtoR(f)::real
  
  RoundedProjector : lemma Fbounded?(b)(f) =>
    RoundedMode?(b)(P) => P(b)(FtoR(f),f)
  
  isMin_Rep :  lemma Fbounded?(b)(f) => isMin?(b)(FtoR(p),f) 
      => (exists (m:int): FtoR(f)=FtoR((# Fnum:=m, Fexp:=Fexp(p) #))::real) 
  
  RoundedModeRep : lemma Fbounded?(b)(f) => RoundedMode?(b)(P) =>  
    P(b)(FtoR(p),f) => (exists (m:int): FtoR(f)=FtoR((# Fnum:=m, Fexp:=Fexp(p) #))::real) 
  
  RoundedModeUlp : lemma Fbounded?(b)(p) =>
    RoundedMode?(b)(P) => P(b)(r,p) => abs(FtoR(p)-r) < Fulp(b)(p)
  
  %
  % Goldberg's ULP
  %
  rnd_tozero_is_tozero?_j: JUDGEMENT
    RND_ToZero(b) HAS_TYPE CanonicRoundingFun[radix](b, ToZero?(b))
    
  ulp(b: Format)(x:real): posreal = ulp(b,ToZero?(b),RND_ToZero(b))(x)
  
  %
  %
  %
  
  ulp_monotone: LEMMA
    0 <= x AND x <= y
    IMPLIES ulp(b)(x) <= ulp(b)(y)
  
  ClosestUlp : lemma Fbounded?(b)(p) => 
      Closest?(b)(r,p) => abs(FtoR(p)-r) <= Fulp(b)(p)/2
  
  %|- away_to_closest_by_half_to_nearest_ulp : PROOF
  %|- (then (skeep)(expand "ulp")
  %|-   (spread (case "Closest?(b)(r, RtoF(r))")
  %|-    ((then (lemma "ClosestUlp")(inst -1 "b" "RtoF(r)" "r")(assert)
  %|-      (spread (case "abs(FtoR(RtoF(r)) - r) = abs(FtoR(p) - r)")
  %|-       ((then (replace -1 :hide? t)(propax))
  %|-        (then (hide -1 2)(expand "Closest?")(inst -1 "p")(inst -3 "RtoF(r)")(assert)))))
  %|-     (then (typepred "RtoF")(inst?)(typepred "round")(inst?)(assert)))))
  %|- QED away_to_closest_by_half_to_nearest_ulp
  away_to_closest_by_half_to_nearest_ulp : LEMMA
   FORALL(round: Rounding(b) |
            FORALL(f:(Fbounded?(b)),x): round(x,f) IMPLIES Closest?(b)(x,f),
          RtoF: RNDF(b,round)):
    Fbounded?(b)(p)  AND
    Closest?(b)(r,p)
    IMPLIES abs(FtoR(p)-r) <= ulp(b,round,RtoF)(r)/2
  
  min_is_max_for_floats : LEMMA
    FORALL (b:Format, r:real, p:(Fcanonic?(b))) :
      r = FtoR(p)
      IMPLIES
      FtoR(RND_Min(b)(r)) = FtoR(RND_Max(b)(r))
  
  min_is_max_implies_ftor: CONJECTURE
    RND_Min(b)(r) = RND_Max(b)(r) IMPLIES r = FtoR(RND_Min(b)(r))
  
    % #TODO rename to away_to_closest_by_half_to_zero_ulp_pos

  RoundedModeNonDecreasing : lemma 
     Fbounded?(b)(p) => Fbounded?(b)(q) =>  RoundedMode?(b)(P) => Unique?(b)(P) 
       => P(b)(z1,p) =>  P(b)(z2,q)  =>  z1 <= z2 => FtoR(p) <= FtoR(q)
  
  ClosestUlp2 : lemma 
      Fcanonic?(b)(p) => Closest?(b)(r,p) => 
      abs(r) <= abs(FtoR(p)) + Fulp(b)(Fpred(b)(Fabs(p)))/2  => abs(FtoR(p)-r) <= Fulp(b)(Fpred(b)(Fabs(p)))/2
  
  ClosestFabs: lemma Fbounded?(b)(p) => Closest?(b)(r,p)=> Closest?(b)(abs(r),Fabs(p))
  
  % Representable floats are computed exactly
  SterbenzAux : lemma
   Fbounded?(b)(p) => Fbounded?(b)(q) => 
     FtoR(p) <= FtoR(q) =>  FtoR(q) <= 2*FtoR(p) => Fbounded?(b)(Fminus(q,p)) 
  
  Sterbenz : lemma
   Fbounded?(b)(p) => Fbounded?(b)(q) => 
     FtoR(p)/2 <= FtoR(q) =>  FtoR(q) <= 2*FtoR(p) => Fbounded?(b)(Fminus(q,p)) 
  
  errorBoundedPlus : lemma
     Fbounded?(b)(p) => Fbounded?(b)(q) => Fbounded?(b)(f) => 
     Closest?(b)(FtoR(p)+FtoR(q),f) => 
     (exists (e:(Fbounded?(b))): FtoR(e)=FtoR(p)+FtoR(q)-FtoR(f) AND Fexp(e)=min(Fexp(p),Fexp(q)))
  
  errorBoundedMult_aux : lemma
     Fbounded?(b)(p) => Fbounded?(b)(q) => Fbounded?(b)(f) => 
        0 <= FtoR(p) => 0 <= FtoR(q) => 0 <= FtoR(f) =>
          isMin?(b)(FtoR(p)*FtoR(q),f) => -dExp(b) <= Fexp(p)+Fexp(q) =>
          (exists (e:(Fbounded?(b))): FtoR(e)=FtoR(p)*FtoR(q)-FtoR(f) AND Fexp(e)=Fexp(p)+Fexp(q))
   
  errorBoundedMult_aux2 : lemma
     Fbounded?(b)(p) => Fbounded?(b)(q) => Fbounded?(b)(f) => 
        0 <= FtoR(p) => 0 <= FtoR(q) => 0 <= FtoR(f) =>
          isMax?(b)(FtoR(p)*FtoR(q),f) => -dExp(b) <= Fexp(p)+Fexp(q) =>
          (exists (e:(Fbounded?(b))): FtoR(e)=FtoR(p)*FtoR(q)-FtoR(f) AND Fexp(e)=Fexp(p)+Fexp(q))
  
  errorBoundedMult : lemma
     Fbounded?(b)(p) => Fbounded?(b)(q) => Fbounded?(b)(f) => 
     RoundedMode?(b)(P) => P(b)(FtoR(p)*FtoR(q),f) => -dExp(b) <= Fexp(p)+Fexp(q) =>
     (exists (e:(Fbounded?(b))): FtoR(e)=FtoR(p)*FtoR(q)-FtoR(f) AND Fexp(e)=Fexp(p)+Fexp(q))
  
  % Properties on the ulp
  FulpLeN : lemma
    Fnormal?(b)(p)  => Fulp(b)(p) <= abs(FtoR(p)) * radix/vNum(b)
  
  FulpGe  : lemma
    Fbounded?(b)(p) => abs(FtoR(p))/(vNum(b)-1) <= Fulp(b)(p)
  
  FulpLe  : lemma
    Fbounded?(b)(p) => Fulp(b)(p) <= max(abs(FtoR(p)) * radix/vNum(b), radix^(-dExp(b)))
  
  FulpFpred1 : lemma
    Fcanonic?(b)(p) => 0 <= FtoR(p) => Fulp(b)(Fpred(b)(p)) <= Fulp(b)(p)
  
  FulpFpred2 : lemma
    Fcanonic?(b)(p) => 0 <= FtoR(p) => Fulp(b)(p) <= radix*Fulp(b)(Fpred(b)(p))
  
  % RtoF properties
    
  Fopp_RtoF: LEMMA
   FORALL(round?: Rounding(b) |
            Unique?(b)(LAMBDA(b1:Format)(x:real, f:(Fbounded?(b1))):b=b1 AND round?(x,f)) AND
  	    rounded_opp?(b)(round?),
          RtoF: CanonicRoundingFun(b,round?)):
    RtoF(-x) = Fopp(RtoF(x))
  
  % %|- ulp_abs : PROOF
  % %|- (then (skeep)(expand "ulp")(lemma "FulpAbs")(inst -1 "b" "RtoF(x)")(assert)(replace -1 :hide? t :dir rl)(use "FulpCanonic")
  % %|-   (spread (split -1)
  % %|-    ((then (replace -1 :hide? t)(lemma "FulpCanonic")(inst? -1)
  % %|-      (spread (split -1)
  % %|-       ((then (replace -1 :hide? t)(expand "abs")(lift-if 1)
  % %|-         (spread (split 1)
  % %|-          ((then (flatten)(expand "Fabs")
  % %|-            (spread (case "RtoF(-x)`Fexp = Fexp(RtoF(x))")
  % %|-             ((then (assert))
  % %|-              (then (hide 2)
  % %|-               (spread (use "Fopp_RtoF")
  % %|-                ((then (grind))
  % %|-                 (then (hide-all-but 1)(typepred "RtoF")
  % %|-                  (spread (split 1)
  % %|-                   ((then (skeep)(inst? -1)(typepred "round")(inst?)(assert))
  % %|-                    (then (propax)))))))))))
  % %|-           (then (flatten)(expand "Fabs")(propax)))))
  % %|-        (then (use "FabsCanonic")(assert)(hide-all-but 1)(typepred "RtoF")(inst? -2)))))
  % %|-     (then (typepred "RtoF")(inst? -2)))))
  % %|- QED ulp_abs
  %   ulp_abs: LEMMA
  %    FORALL(round: Rounding(b) | Unique?(b)(LAMBDA(b:Format):round),
  %           RtoF: CanonicRoundingFun(b,round)):
  %     ulp(b,round,RtoF)(abs(x))=ulp(b,round,RtoF)(x)
  ulp_abs: LEMMA
    ulp(b)(abs(x))=ulp(b)(x)
  
  injrnd_ulp: LEMMA
   FORALL(f     : (Fbounded?(b)),
          round : (rounded_mode?(b)),
  	  RtoF  : (injective_rounding(b,round))):
    Fulp(b)(f) = ulp(b,round,RtoF)(FtoR(f))
  
  Fulp_ulp: LEMMA
   FORALL(e     : nonneg_real, 
  	        f     : (Fbounded?(b)),
          round : (rounded_mode?(b)),
  	  RtoF  : (injective_rounding(b,round))):
    abs( FtoR(f) - x ) <= e
    IMPLIES Fulp(b)(f) <= ulp(b,round,RtoF)(abs(x) + e)
  
  rndmaxismax_j: JUDGEMENT
    RND_Max(b) HAS_TYPE CanonicRoundingFun(b, isMax?(b))
  
  rndminismin_j: JUDGEMENT
    RND_Min(b) HAS_TYPE CanonicRoundingFun(b, isMin?(b))
  
  rndeclosest_j: JUDGEMENT
    RND_EClosest(b) HAS_TYPE CanonicRoundingFun(b, EvenClosest?(b))


    closest_ulp_pos 
    : lemma
      Fcanonic?(b)(p)  âˆ§
      Closest?(b)(r,p) âˆ§
      r >= 0
      => abs(FtoR(p)-r) <= ulp(b)(r)/2

%|- closest_ulp_pos : PROOF
%|- (then (skeep) (expand "ulp") (expand "ulp") (expand "RND_ToZero")
%|-  (assert) (lemma "MaxSuccMin")
%|-  (inst -1 "b" "RND_Min(b)(r)" "RND_Max(b)(r)" "r") (assert)
%|-  (spread (split)
%|-   ((then (lemma "FsuccDiff") (inst -1 "b" "RND_Min(b)(r)") (assert)
%|-     (spread (split)
%|-      ((then (replace -1 :dir rl)
%|-        (spread (case "p=RND_Min(b)(r)")
%|-         ((then (replace -1) (hide -1) (expand "Closest?")
%|-           (spread (inst -4 " Fsucc(b)(RND_Min(b)(r))")
%|-            ((then (use "RND_Min_isMin") (expand "isMin?") (flatten)
%|-              (use "RND_Max_isMax") (replace -5) (expand "isMax?")
%|-              (flatten)
%|-              (spread
%|-               (case "abs(FtoR(RND_Min(b)(r)) - r) = r - FtoR(RND_Min(b)(r))")
%|-               ((then (replace -1) (hide -1)
%|-                 (spread
%|-                  (case "abs(FtoR(Fsucc(b)(RND_Min(b)(r))) - r) = FtoR(Fsucc(b)(RND_Min(b)(r))) - r")
%|-                  ((then (replace -1) (hide -1) (assert))
%|-                   (then (hide-all-but (1 -1)) (expand "abs")
%|-                    (spread
%|-                     (case "FtoR(Fsucc(b)(RND_Min(b)(r))) - r < 0")
%|-                     ((assert)
%|-                      (spread
%|-                       (case "FtoR(Fsucc(b)(RND_Min(b)(r))) - r = 0")
%|-                       ((then (replace -1) (assert)) (assert)))))))))
%|-                (then (hide-all-but (1 -3)) (expand "abs")
%|-                 (spread (case "FtoR(RND_Min(b)(r)) - r < 0")
%|-                  ((assert)
%|-                   (spread (case "FtoR(RND_Min(b)(r)) - r = 0")
%|-                    ((then (replace -1) (assert)) (assert)))))))))
%|-             (then (lemma "FsuccBounded") (inst -1 "b" "RND_Min(b)(r)")
%|-              (typepred "RND_Min(b)(r)") (assert)
%|-              (use "canonic_bounded_j")))))
%|-          (spread (case "p=Fsucc(b)(RND_Min(b)(r))")
%|-           ((then (replace -1) (hide -1 -2 1) (expand "Closest?")
%|-             (inst -3 "(RND_Min(b)(r))")
%|-             (spread
%|-              (case "abs(FtoR(Fsucc(b)(RND_Min(b)(r))) - r) = FtoR(Fsucc(b)(RND_Min(b)(r))) - r")
%|-              ((then (replace -1) (hide -1)
%|-                (spread
%|-                 (case "abs(FtoR((RND_Min(b)(r))) - r) = r - FtoR((RND_Min(b)(r)))")
%|-                 ((then (replace -1) (hide -1) (assert))
%|-                  (then (use "RND_Min_isMin") (expand "isMin?")
%|-                   (flatten) (hide-all-but (1 -1)) (expand "abs")
%|-                   (spread (case "FtoR((RND_Min(b)(r))) - r < 0 ")
%|-                    ((assert)
%|-                     (spread (case "FtoR((RND_Min(b)(r))) - r = 0")
%|-                      ((then (replace -1) (assert)) (assert)))))))))
%|-               (then (use "RND_Max_isMax") (expand "isMax?") (flatten)
%|-                (hide-all-but (1 -1)) (expand "abs")
%|-                (spread (case "FtoR(Fsucc(b)(RND_Min(b)(r))) - r < 0")
%|-                 ((assert)
%|-                  (spread (case "FtoR(Fsucc(b)(RND_Min(b)(r))) - r = 0")
%|-                   ((then (replace -1) (assert)) (assert)))))))))
%|-            (then (use "Closest_min_or_max") (expand "min_or_max?")
%|-             (inst -1 "r" "p") (assert)
%|-             (spread (split)
%|-              ((then (use "isMin_Unique") (expand "Unique?")
%|-                (inst -1 "r" "p" "RND_Min(b)(r)") (assert)
%|-                (spread (split)
%|-                 ((then (lemma "FcanonicUnique")
%|-                   (inst -1 "b" "p" "RND_Min(b)(r)") (assert))
%|-                  (use "RND_Min_isMin"))))
%|-               (then (replace -3 :dir rl) (use "isMax_Unique")
%|-                (expand "Unique?") (inst -1 "r" "p" "RND_Max(b)(r)")
%|-                (assert)
%|-                (spread (split)
%|-                 ((then (lemma "FcanonicUnique")
%|-                   (inst -1 "b" "p" "RND_Max(b)(r)") (assert))
%|-                  (use "RND_Max_isMax"))))))))))))
%|-       (then (lemma "rle_rounded_r0")
%|-        (inst -1 "b" " RND_Min(b)(r)" "r" "isMin?(b)") (assert)
%|-        (use "RND_Min_isMin") (assert) (typepred "RND_Min(b)(r)")
%|-        (use "FcanonicBounded") (assert) (use "isMin_RoundedMode")
%|-        (hide-all-but (-1 1)) (expand "RoundedMode?")
%|-        (expand "rounded_mode?") (expand "Total?") (expand "total?")
%|-        (flatten)
%|-        (spread (split)
%|-         ((propax)
%|-          (then (expand "Compatible?") (expand "compatible?") (hide -1)
%|-           (skeep) (insteep) (assert))
%|-          (then (expand "MinOrMax?") (expand "min_or_max?") (propax))
%|-          (then (expand "Monotone?") (expand "monotone?") (skeep)
%|-           (insteep -7) (assert))))))))
%|-    (then (lemma "Closest_min_or_max") (inst -1 "b")
%|-     (expand "min_or_max?") (inst -1 "r" "p") (assert)
%|-     (spread (split -1)
%|-      ((then (use "isMin_Unique") (expand "Unique?")
%|-        (inst -1 "r" "p" "RND_Min(b)(r)") (assert) (use "RND_Min_isMin")
%|-        (assert) (replace -2) (use "min_is_max_implies_ftor")
%|-        (spread (split)
%|-         ((then (replace -1 :dir rl) (assert) (expand "abs") (assert))
%|-          (then (use "FcanonicUnique") (assert)))))
%|-       (then (use "isMax_Unique") (expand "Unique?")
%|-        (inst -1 "r" "p" "RND_Max(b)(r)") (assert) (use "RND_Max_isMax")
%|-        (assert) (replace -2) (use "min_is_max_implies_ftor")
%|-        (spread (split)
%|-         ((then (replace -5 :dir rl) (replace -1 :dir rl) (assert)
%|-           (expand "abs") (assert))
%|-          (then (use "FcanonicUnique") (assert))))))))
%|-    (use "RND_Max_isMax") (use "RND_Min_isMin"))))
%|- QED closest_ulp_pos


  % #TODO rename to away_to_closest_by_half_to_zero_ulp
  closest_ulp
  : conjecture
    Fcanonic?(b)(p)  AND
    Closest?(b)(r,p) 
    IMPLIES abs(FtoR(p)-r) <= ulp(b)(r)/2

END float
