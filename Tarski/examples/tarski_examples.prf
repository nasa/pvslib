(tarski_examples
 (example_1_TCC1 0
  (example_1_TCC1-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (example_1 subtype "3"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_1_TCC2 0
  (example_1_TCC2-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_times_real_is_real application-judgement "real" reals nil))
   nil
   (example_1 subtype "2"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_1 0
  (example_1-1 nil 3703615086 ("" (tarski) nil nil)
   ((pmonom def-decl "{pl: Polylist |
   length(pl) = deg + 1 AND FORALL (x: real): polylist(pl)(x) = c * x ^ deg}"
            polylist "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (length def-decl "nat" list_props nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (zero_pol const-decl "rat" polylist "Sturm/")
    (list2array def-decl "T" array2list "structures/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (PolyRelExpr type-decl nil PolyRelExpr_adt "Tarski/")
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (PREL? adt-recognizer-decl "[PolyRelExpr -> boolean]"
     PolyRelExpr_adt "Tarski/")
    (PNOT? adt-recognizer-decl "[PolyRelExpr -> boolean]"
     PolyRelExpr_adt "Tarski/")
    (PNOT adt-constructor-decl "[PolyRelExpr -> (PNOT?)]"
     PolyRelExpr_adt "Tarski/")
    (POR? adt-recognizer-decl "[PolyRelExpr -> boolean]"
     PolyRelExpr_adt "Tarski/")
    (POR adt-constructor-decl "[[PolyRelExpr, PolyRelExpr] -> (POR?)]"
     PolyRelExpr_adt "Tarski/")
    (TarskiRel type-decl nil poly_system_strategy "Tarski/")
    (PREL adt-constructor-decl
     "[[[nat -> rat], nat, TarskiRel, rat] -> (PREL?)]" PolyRelExpr_adt
     "Tarski/")
    (plt? adt-recognizer-decl "[TarskiRel -> boolean]"
     poly_system_strategy "Tarski/")
    (plt adt-constructor-decl "(plt?)" poly_system_strategy "Tarski/")
    (pgt? adt-recognizer-decl "[TarskiRel -> boolean]"
     poly_system_strategy "Tarski/")
    (pgt adt-constructor-decl "(pgt?)" poly_system_strategy "Tarski/")
    (peq? adt-recognizer-decl "[TarskiRel -> boolean]"
     poly_system_strategy "Tarski/")
    (peq adt-constructor-decl "(peq?)" poly_system_strategy "Tarski/")
    (eval_rel const-decl "bool" dnf_polynomials "Tarski/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (polylist_prod formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (FALSE const-decl "bool" booleans nil)
    (rel_to_tarski const-decl "bool" dnf_strategy "Tarski/")
    (rel_to_tarski_sound formula-decl nil dnf_strategy "Tarski/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (example_2_TCC1 0
  (example_2_TCC1-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil))
   nil
   (example_2 subtype "2"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_2 0
  (example_2-1 nil 3703615086 ("" (tarski) nil nil)
   ((pmonom def-decl "{pl: Polylist |
   length(pl) = deg + 1 AND FORALL (x: real): polylist(pl)(x) = c * x ^ deg}"
            polylist "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (pminus const-decl "Polylist" polylist "Sturm/")
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (tarski_def formula-decl nil poly_system_strategy "Tarski/")
    (for const-decl "T" for_iterate "structures/")
    (iterate_left const-decl "T" for_iterate "structures/")
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate "structures/")
    (polylist_eval formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (forall_and_upto formula-decl nil for_examples "structures/")
    (sequence type-eq-decl nil sequences nil)
    (polynomial const-decl "[real -> real]" polynomials "reals/")
    (tarski const-decl "bool" poly_system_strategy "Tarski/")
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (even? const-decl "bool" integers nil)
    (even_int nonempty-type-eq-decl nil integers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (list2array def-decl "T" array2list "structures/")
    (zero_pol const-decl "rat" polylist "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (example_3_TCC1 0
  (example_3_TCC1-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (example_3 subtype "2"
    "{i: integers.int | booleans.OR(((number_fields.-)(tarski_examples.x, 2)) /= 0, reals.>=(i, 0))}")))
 (example_3_TCC2 0
  (example_3_TCC2-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil))
   nil
   (example_3 subtype "2"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_3_TCC3 0
  (example_3_TCC3-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil))
   nil
   (example_3 subtype "2"
    "{i: integers.int | booleans.OR(((number_fields.-)(tarski_examples.x, 3)) /= 0, reals.>=(i, 0))}")))
 (example_3_TCC4 0
  (example_3_TCC4-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil))
   nil
   (example_3 subtype "3"
    "{i: integers.int | booleans.OR((booleans.NOT)(((number_fields.-)(tarski_examples.x, 11/12)) = 0), reals.>=(i, 0))}")))
 (example_3_TCC5 0
  (example_3_TCC5-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil))
   nil
   (example_3 subtype "3"
    "{i: integers.int | booleans.OR((booleans.NOT)(((number_fields.-)(tarski_examples.x, 41/10)) = 0), reals.>=(i, 0))}")))
 (example_3 0
  (example_3-1 nil 3703615086 ("" (tarski) nil nil)
   ((/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (pconst const-decl "Polylist" polylist "Sturm/")
    (pmonom def-decl "{pl: Polylist |
   length(pl) = deg + 1 AND FORALL (x: real): polylist(pl)(x) = c * x ^ deg}"
            polylist "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (length def-decl "nat" list_props nil)
    (pminus const-decl "Polylist" polylist "Sturm/")
    (ppow def-decl "Polylist" polylist "Sturm/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (pneg const-decl "Polylist" polylist "Sturm/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (zero_pol const-decl "rat" polylist "Sturm/")
    (list2array def-decl "T" array2list "structures/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (tarski const-decl "bool" poly_system_strategy "Tarski/")
    (FALSE const-decl "bool" booleans nil)
    (polynomial const-decl "[real -> real]" polynomials "reals/")
    (sequence type-eq-decl nil sequences nil)
    (forall_and_upto formula-decl nil for_examples "structures/")
    (polylist_eval formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_prod formula-decl nil polylist "Sturm/")
    (polylist_pow formula-decl nil polylist "Sturm/")
    (minus_real_is_real application-judgement "real" reals nil)
    (polylist_neg formula-decl nil polylist "Sturm/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate "structures/")
    (iterate_left const-decl "T" for_iterate "structures/")
    (for const-decl "T" for_iterate "structures/")
    (tarski_def formula-decl nil poly_system_strategy "Tarski/")
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (psum def-decl "{pql: Polylist |
   FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
          polylist "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (example_4_TCC1 0
  (example_4_TCC1-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (example_4 subtype "4"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_4_TCC2 0
  (example_4_TCC2-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil))
   nil
   (example_4 subtype "12"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_4 0
  (example_4-1 nil 3703615086 ("" (tarski) nil nil)
   ((minus_odd_is_odd application-judgement "odd_int" integers nil)
    (pmonom def-decl "{pl: Polylist |
   length(pl) = deg + 1 AND FORALL (x: real): polylist(pl)(x) = c * x ^ deg}"
            polylist "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (length def-decl "nat" list_props nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (pminus const-decl "Polylist" polylist "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (tarski_def formula-decl nil poly_system_strategy "Tarski/")
    (for const-decl "T" for_iterate "structures/")
    (iterate_left const-decl "T" for_iterate "structures/")
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate "structures/")
    (polylist_eval formula-decl nil polylist "Sturm/")
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (forall_and_upto formula-decl nil for_examples "structures/")
    (sequence type-eq-decl nil sequences nil)
    (polynomial const-decl "[real -> real]" polynomials "reals/")
    (FALSE const-decl "bool" booleans nil)
    (tarski const-decl "bool" poly_system_strategy "Tarski/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (list2array def-decl "T" array2list "structures/")
    (zero_pol const-decl "rat" polylist "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (example_5 0
  (example_5-1 nil 3703615086 ("" (tarski) nil nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (pconst const-decl "Polylist" polylist "Sturm/")
    (pmonom def-decl "{pl: Polylist |
   length(pl) = deg + 1 AND FORALL (x: real): polylist(pl)(x) = c * x ^ deg}"
            polylist "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (length def-decl "nat" list_props nil)
    (ppow def-decl "Polylist" polylist "Sturm/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (pneg const-decl "Polylist" polylist "Sturm/")
    (pprod const-decl "Polylist" polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (zero_pol const-decl "rat" polylist "Sturm/")
    (list2array def-decl "T" array2list "structures/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (tarski const-decl "bool" poly_system_strategy "Tarski/")
    (polynomial const-decl "[real -> real]" polynomials "reals/")
    (sequence type-eq-decl nil sequences nil)
    (forall_and_upto formula-decl nil for_examples "structures/")
    (polylist_eval formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_prod formula-decl nil polylist "Sturm/")
    (polylist_pow formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (minus_real_is_real application-judgement "real" reals nil)
    (polylist_neg formula-decl nil polylist "Sturm/")
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate "structures/")
    (iterate_left const-decl "T" for_iterate "structures/")
    (for const-decl "T" for_iterate "structures/")
    (tarski_def formula-decl nil poly_system_strategy "Tarski/")
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (psum def-decl "{pql: Polylist |
   FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
          polylist "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (example_6_TCC1 0
  (example_6_TCC1-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (example_6 subtype "5"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_6_TCC2 0
  (example_6_TCC2-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (example_6 subtype "12"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_6_TCC3 0
  (example_6_TCC3-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (example_6 subtype "11"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_6_TCC4 0
  (example_6_TCC4-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (example_6 subtype "10"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_6_TCC5 0
  (example_6_TCC5-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (example_6 subtype "8"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_6_TCC6 0
  (example_6_TCC6-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (example_6 subtype "7"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_6_TCC7 0
  (example_6_TCC7-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (example_6 subtype "6"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_6_TCC8 0
  (example_6_TCC8-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (example_6 subtype "4"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_6_TCC9 0
  (example_6_TCC9-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil
   (example_6 subtype "2"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_6_TCC10 0
  (example_6_TCC10-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil))
   nil
   (example_6 subtype "22"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_6_TCC11 0
  (example_6_TCC11-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil))
   nil
   (example_6 subtype "20"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_6 0
  (example_6-1 nil 3703615086 ("" (tarski) nil nil)
   ((pconst const-decl "Polylist" polylist "Sturm/")
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (pmonom def-decl "{pl: Polylist |
   length(pl) = deg + 1 AND FORALL (x: real): polylist(pl)(x) = c * x ^ deg}"
            polylist "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (pminus const-decl "Polylist" polylist "Sturm/")
    (psum def-decl "{pql: Polylist |
   FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
          polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (tarski_def formula-decl nil poly_system_strategy "Tarski/")
    (for const-decl "T" for_iterate "structures/")
    (iterate_left const-decl "T" for_iterate "structures/")
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate "structures/")
    (polylist_eval formula-decl nil polylist "Sturm/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (expt_x1 formula-decl nil exponentiation nil)
    (minus_nzrat_is_nzrat application-judgement "nzrat" rationals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (forall_and_upto formula-decl nil for_examples "structures/")
    (sequence type-eq-decl nil sequences nil)
    (polynomial const-decl "[real -> real]" polynomials "reals/")
    (tarski const-decl "bool" poly_system_strategy "Tarski/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (list2array def-decl "T" array2list "structures/")
    (zero_pol const-decl "rat" polylist "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (example_7_TCC1 0
  (example_7_TCC1-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (example_7 subtype "2"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_7 0
  (example_7-1 nil 3703615086 ("" (tarski) nil nil)
   ((pconst const-decl "Polylist" polylist "Sturm/")
    (pmonom def-decl "{pl: Polylist |
   length(pl) = deg + 1 AND FORALL (x: real): polylist(pl)(x) = c * x ^ deg}"
            polylist "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (psum def-decl "{pql: Polylist |
   FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
          polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (zero_pol const-decl "rat" polylist "Sturm/")
    (list2array def-decl "T" array2list "structures/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (tarski const-decl "bool" poly_system_strategy "Tarski/")
    (FALSE const-decl "bool" booleans nil)
    (polynomial const-decl "[real -> real]" polynomials "reals/")
    (sequence type-eq-decl nil sequences nil)
    (forall_and_upto formula-decl nil for_examples "structures/")
    (polylist_eval formula-decl nil polylist "Sturm/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (abs_ge formula-decl nil abs_lems "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate "structures/")
    (iterate_left const-decl "T" for_iterate "structures/")
    (for const-decl "T" for_iterate "structures/")
    (tarski_def formula-decl nil poly_system_strategy "Tarski/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (pminus const-decl "Polylist" polylist "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (example_8_TCC1 0
  (example_8_TCC1-1 nil 3771772352 ("" (subtype-tcc) nil nil) nil nil
   (example_8 subtype "9"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (example_8 0
  (example_8-1 nil 3771772463 ("" (tarski) nil nil)
   ((pmonom def-decl "{pl: Polylist |
   length(pl) = deg + 1 AND FORALL (x: real): polylist(pl)(x) = c * x ^ deg}"
            polylist "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (length def-decl "nat" list_props nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (pminus const-decl "Polylist" polylist "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (tarski_def formula-decl nil poly_system_strategy "Tarski/")
    (for const-decl "T" for_iterate "structures/")
    (iterate_left const-decl "T" for_iterate "structures/")
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate "structures/")
    (polylist_eval formula-decl nil polylist "Sturm/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (forall_and_upto formula-decl nil for_examples "structures/")
    (sequence type-eq-decl nil sequences nil)
    (polynomial const-decl "[real -> real]" polynomials "reals/")
    (FALSE const-decl "bool" booleans nil)
    (tarski const-decl "bool" poly_system_strategy "Tarski/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (list2array def-decl "T" array2list "structures/")
    (zero_pol const-decl "rat" polylist "Sturm/")
    (psum def-decl "{pql: Polylist |
   FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
          polylist "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (legendre_4_TCC1 0
  (legendre_4_TCC1-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (legendre_4 subtype "4"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (legendre_6_TCC1 0
  (legendre_6_TCC1-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (legendre_6 subtype "6"
    "{i: integers.int | booleans.OR(tarski_examples.x /= 0, reals.>=(i, 0))}")))
 (Legendre_2_6 0
  (Legendre_2_6-1 nil 3703615086 ("" (tarski) nil nil)
   ((pconst const-decl "Polylist" polylist "Sturm/")
    (pmonom def-decl "{pl: Polylist |
   length(pl) = deg + 1 AND FORALL (x: real): polylist(pl)(x) = c * x ^ deg}"
            polylist "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (psum def-decl "{pql: Polylist |
   FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
          polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (pminus const-decl "Polylist" polylist "Sturm/")
    (pdiv const-decl "Polylist" polylist "Sturm/")
    (nzrat nonempty-type-eq-decl nil rationals nil)
    (/= const-decl "boolean" notequal nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (zero_pol const-decl "rat" polylist "Sturm/")
    (list2array def-decl "T" array2list "structures/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (tarski const-decl "bool" poly_system_strategy "Tarski/")
    (FALSE const-decl "bool" booleans nil)
    (polynomial const-decl "[real -> real]" polynomials "reals/")
    (sequence type-eq-decl nil sequences nil)
    (rel5 const-decl "bool" preprocessing_univariate "Tarski/")
    (forall_and_upto formula-decl nil for_examples "structures/")
    (polylist_eval formula-decl nil polylist "Sturm/")
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (polylist_div formula-decl nil polylist "Sturm/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (real_plus_real_is_real application-judgement "real" reals nil)
    (polylist_sum formula-decl nil polylist "Sturm/")
    (real_times_real_is_real application-judgement "real" reals nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (expt_x1 formula-decl nil exponentiation nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate "structures/")
    (iterate_left const-decl "T" for_iterate "structures/")
    (for const-decl "T" for_iterate "structures/")
    (tarski_def formula-decl nil poly_system_strategy "Tarski/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (conflict?_TCC1 0
  (conflict?_TCC1-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (conflict? subtype "2"
    "{i: integers.int | booleans.OR(tarski_examples.t /= 0, reals.>=(i, 0))}")))
 (yes_conflict_TCC1 0
  (yes_conflict_TCC1-1 nil 3771772352 ("" (subtype-tcc) nil nil) nil
   nil
   (yes_conflict subtype "2"
    "{i: integers.int | booleans.OR(tarski_examples.t /= 0, reals.>=(i, 0))}")))
 (yes_conflict 0
  (yes_conflict-1 nil 3703615086 ("" (tarski) nil nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (pconst const-decl "Polylist" polylist "Sturm/")
    (pmonom def-decl "{pl: Polylist |
   length(pl) = deg + 1 AND FORALL (x: real): polylist(pl)(x) = c * x ^ deg}"
            polylist "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (pminus const-decl "Polylist" polylist "Sturm/")
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (psum def-decl "{pql: Polylist |
   FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
          polylist "Sturm/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (pprod const-decl "Polylist" polylist "Sturm/")
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (H const-decl "real" tarski_examples nil)
    (vz const-decl "real" tarski_examples nil)
    (sz const-decl "real" tarski_examples nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (D const-decl "real" tarski_examples nil)
    (Vector type-eq-decl nil vectors_2D "vectors/")
    (* const-decl "real" vectors_2D "vectors/")
    (- const-decl "Vector" vectors_2D "vectors/")
    (Vect2 type-eq-decl nil vectors_2D_def "vectors/")
    (vo const-decl "Vect2" tarski_examples nil)
    (vi const-decl "Vect2" tarski_examples nil)
    (* const-decl "Vector" vectors_2D "vectors/")
    (so const-decl "Vect2" tarski_examples nil)
    (si const-decl "Vect2" tarski_examples nil)
    (Interval type-eq-decl nil interval "interval_arith/")
    ([\|\|] const-decl "Interval" interval "interval_arith/")
    (eval def-decl "bool" dnf_polynomials "Tarski/")
    (polylist_eval formula-decl nil polylist "Sturm/")
    (pl__1 skolem-const-decl "Polylist" tarski_examples nil)
    (pl__2 skolem-const-decl "{pl: Polylist |
   length(pl) = 2 AND FORALL (x: real): polylist(pl)(x) = 1 * x ^ 1}"
           tarski_examples nil)
    (pl__3 skolem-const-decl "Polylist" tarski_examples nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (times_div2 formula-decl nil real_props nil)
    (pl__4 skolem-const-decl "{pql: Polylist |
   FORALL (x):
     polylist(pql)(x) =
      polylist(pconst(305))(x) +
       polylist(psum(pconst(144), pprod(pmonom(1, 1), pconst(1/25))))(x)}"
           tarski_examples nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (expt_x1 formula-decl nil exponentiation nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_prod formula-decl nil polylist "Sturm/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (pl__5 skolem-const-decl "Polylist" tarski_examples nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs_lt formula-decl nil abs_lems "reals/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ge_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (x__17 skolem-const-decl "real" tarski_examples nil)
    (|##| const-decl "bool" interval "interval_arith/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (eval_rel const-decl "bool" dnf_polynomials "Tarski/")
    (be__16 skolem-const-decl "(PAND?)" tarski_examples nil)
    (rel_to_tarski const-decl "bool" dnf_strategy "Tarski/")
    (rel_to_tarski_sound formula-decl nil dnf_strategy "Tarski/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (PolyRelExpr type-decl nil PolyRelExpr_adt "Tarski/")
    (PREL? adt-recognizer-decl "[PolyRelExpr -> boolean]"
     PolyRelExpr_adt "Tarski/")
    (PAND? adt-recognizer-decl "[PolyRelExpr -> boolean]"
     PolyRelExpr_adt "Tarski/")
    (PAND adt-constructor-decl
     "[[PolyRelExpr, PolyRelExpr] -> (PAND?)]" PolyRelExpr_adt
     "Tarski/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (TarskiRel type-decl nil poly_system_strategy "Tarski/")
    (PREL adt-constructor-decl
     "[[[nat -> rat], nat, TarskiRel, rat] -> (PREL?)]" PolyRelExpr_adt
     "Tarski/")
    (list2array def-decl "T" array2list "structures/")
    (ple? adt-recognizer-decl "[TarskiRel -> boolean]"
     poly_system_strategy "Tarski/")
    (ple adt-constructor-decl "(ple?)" poly_system_strategy "Tarski/")
    (pge? adt-recognizer-decl "[TarskiRel -> boolean]"
     poly_system_strategy "Tarski/")
    (pge adt-constructor-decl "(pge?)" poly_system_strategy "Tarski/")
    (plt? adt-recognizer-decl "[TarskiRel -> boolean]"
     poly_system_strategy "Tarski/")
    (plt adt-constructor-decl "(plt?)" poly_system_strategy "Tarski/")
    (pgt? adt-recognizer-decl "[TarskiRel -> boolean]"
     poly_system_strategy "Tarski/")
    (pgt adt-constructor-decl "(pgt?)" poly_system_strategy "Tarski/")
    (listn_0 name-judgement "listn[int](0)" gcd_coeff "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (no_conflict_TCC1 0
  (no_conflict_TCC1-1 nil 3703615086 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (no_conflict subtype "2"
    "{i: integers.int | booleans.OR(tarski_examples.t /= 0, reals.>=(i, 0))}")))
 (no_conflict 0
  (no_conflict-1 nil 3703615086 ("" (tarski) nil nil)
   ((real_times_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (pmonom def-decl "{pl: Polylist |
   length(pl) = deg + 1 AND FORALL (x: real): polylist(pl)(x) = c * x ^ deg}"
            polylist "Sturm/")
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (pprod const-decl "Polylist" polylist "Sturm/")
    (pconst const-decl "Polylist" polylist "Sturm/")
    (psum def-decl "{pql: Polylist |
   FORALL (x): polylist(pql)(x) = polylist(pl)(x) + polylist(ql)(x)}"
          polylist "Sturm/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (polylist const-decl "real" polylist "Sturm/")
    (Polylist type-eq-decl nil polylist "Sturm/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (rat nonempty-type-eq-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (zero_pol const-decl "rat" polylist "Sturm/")
    (list2array def-decl "T" array2list "structures/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (tarski const-decl "bool" poly_system_strategy "Tarski/")
    (FALSE const-decl "bool" booleans nil)
    (for const-decl "T" for_iterate "structures/")
    (iterate_left const-decl "T" for_iterate "structures/")
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate "structures/")
    (real_minus_real_is_real application-judgement "real" reals nil)
    (polylist_minus formula-decl nil polylist "Sturm/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_realorder name-judgement "RealOrder" real_orders "reals/")
    (abs_lt formula-decl nil abs_lems "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_realorder name-judgement "RealOrder" real_orders "reals/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (gt_realorder name-judgement "RealOrder" real_orders "reals/")
    (expt_x1 formula-decl nil exponentiation nil)
    (polylist_monom formula-decl nil polylist "Sturm/")
    (polylist_prod formula-decl nil polylist "Sturm/")
    (polylist_const formula-decl nil polylist "Sturm/")
    (polylist_sum formula-decl nil polylist "Sturm/")
    (polylist_eval formula-decl nil polylist "Sturm/")
    (forall_and_upto formula-decl nil for_examples "structures/")
    (sequence type-eq-decl nil sequences nil)
    (polynomial const-decl "[real -> real]" polynomials "reals/")
    (|##| const-decl "bool" interval "interval_arith/")
    (Interval type-eq-decl nil interval "interval_arith/")
    (si const-decl "Vect2" tarski_examples nil)
    (so const-decl "Vect2" tarski_examples nil)
    (* const-decl "Vector" vectors_2D "vectors/")
    (vi const-decl "Vect2" tarski_examples nil)
    (vo const-decl "Vect2" tarski_examples nil)
    (Vect2 type-eq-decl nil vectors_2D_def "vectors/")
    (* const-decl "real" vectors_2D "vectors/")
    (Vector type-eq-decl nil vectors_2D "vectors/")
    (D const-decl "real" tarski_examples nil)
    (sq const-decl "nonneg_real" sq "reals/")
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (sz const-decl "real" tarski_examples nil)
    (vz const-decl "real" tarski_examples nil)
    (H const-decl "real" tarski_examples nil)
    (tarski_def formula-decl nil poly_system_strategy "Tarski/")
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (pminus const-decl "Polylist" polylist "Sturm/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak)))

