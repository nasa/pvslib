(tarski_query (NSol_squared_gt 0 (NSol_squared_gt-1 nil 3619522848 ("" (skeep) (("" (expand "NSol") (("" (case "Sol(a, n, polynomial_prod(g, k, g, k), 2 * k, >)=Sol(a, n, g, k, /=)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (decompose-equality) (("2" (expand "Sol") (("2" (rewrite "polynomial_prod_def" :dir rl) (("2" (iff) (("2" (typepred "sq(polynomial(g,k)(x!1))") (("2" (lemma "sq_eq_0") (("2" (inst?) (("2" (expand "sq") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NSol const-decl "{d: nat |
   EXISTS (enumsol: [below(d) -> (Sol(a, m, g, k, rel))]):
     bijective?(enumsol)}" sturmtarski nil) (sq_eq_0 formula-decl nil sq reals) (polynomial const-decl "[real -> real]" polynomials reals) (sq const-decl "nonneg_real" sq reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (polynomial_prod_def formula-decl nil polynomials reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (Sol const-decl "finite_set[real]" sturmtarski nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (sequence type-eq-decl nil sequences nil) (polynomial_prod const-decl "real" polynomials reals) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak)) (NSol_squared_lt 0 (NSol_squared_lt-1 nil 3619522969 ("" (skeep) (("" (expand "NSol") (("" (lemma "empty_card[real]") (("" (inst?) (("" (assert) (("" (hide 3) (("" (expand "empty?") (("" (expand "member") (("" (skosimp*) (("" (expand "Sol") (("" (rewrite "polynomial_prod_def" :dir rl) (("" (flatten) (("" (typepred "sq(polynomial(g,k)(x!1))") (("" (expand "sq") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NSol const-decl "{d: nat |
   EXISTS (enumsol: [below(d) -> (Sol(a, m, g, k, rel))]):
     bijective?(enumsol)}" sturmtarski nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (Sol const-decl "finite_set[real]" sturmtarski nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (sequence type-eq-decl nil sequences nil) (polynomial_prod const-decl "real" polynomials reals) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (member const-decl "bool" sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (polynomial const-decl "[real -> real]" polynomials reals) (sq const-decl "nonneg_real" sq reals) (nonneg_real nonempty-type-eq-decl nil real_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (polynomial_prod_def formula-decl nil polynomials reals) (empty? const-decl "bool" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (empty_card formula-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil)) (NSol_poly1_lt 0 (NSol_poly1_lt-1 nil 3619523064 ("" (skeep) (("" (expand "NSol") (("" (lemma "empty_card[real]") (("" (inst?) (("" (assert) (("" (hide 3) (("" (expand "empty?") (("" (expand "member") (("" (skosimp*) (("" (expand "Sol") (("" (flatten) (("" (expand "polynomial" -2) (("" (expand "sigma") (("" (expand "sigma") (("" (expand "poly1") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NSol const-decl "{d: nat |
   EXISTS (enumsol: [below(d) -> (Sol(a, m, g, k, rel))]):
     bijective?(enumsol)}" sturmtarski nil) (bool nonempty-type-eq-decl nil booleans nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (Sol const-decl "finite_set[real]" sturmtarski nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (poly1 const-decl "nat" poly_families nil) (< const-decl "bool" reals nil) (member const-decl "bool" sets nil) (polynomial const-decl "[real -> real]" polynomials reals) (sigma def-decl "real" sigma reals) (empty? const-decl "bool" sets nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (empty_card formula-decl nil finite_sets nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) shostak)) (A3_TCC1 0 (A3_TCC1-2 "" 3790099364 ("" (eval-formula) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) shostak (A3 subtype "(: (: 1, 0, -1 :), (: 0, number_fields./(1, 2), number_fields./(1, 2) :), (: 0, number_fields./(-1, 2), number_fields./(1, 2) :) :)" "{M: matrices.PosFullMatrix | booleans.AND(matrices.rows(M) = 3, matrices.columns(M) = 3)}")) (A3_TCC1-1 nil 3619454656 ("" (eval-formula)) nil nil (A3 subtype "(: (: 1, 0, -1 :), (: 0, number_fields./(1, 2), number_fields./(1, 2) :), (: 0, number_fields./(-1, 2), number_fields./(1, 2) :) :)" "{M: matrices.PosFullMatrix | booleans.AND(matrices.rows(M) = 3, matrices.columns(M) = 3)}"))) (A3_inv_TCC1 0 (A3_inv_TCC1-1 nil 3619779062 ("" (skeep) (("" (assert) nil nil)) nil) nil shostak (A3_inv subtype "tarski_query.M" "{SQ | booleans.OR(matrix_props.det(matrix_inv.SQ) /= 0, matrix_inv.invertible?(matrix_inv.SQ))}"))) (A3_inv_TCC2 0 (A3_inv_TCC2-2 "" 3790099365 ("" (eval-formula) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) shostak (A3_inv subtype "(: (: 1, 1, 1 :), (: 0, 1, -1 :), (: 0, 1, 1 :) :)" "{M: matrices.PosFullMatrix | booleans.AND(matrices.rows(M) = 3, booleans.AND(matrices.columns(M) = 3, booleans.AND(matrix_props.det(M) /= 0, matrix_inv.inverse(M) = tarski_query.A3)))}")) (A3_inv_TCC2-1 nil 3619779062 ("" (eval-formula)) nil nil (A3_inv subtype "(: (: 1, 1, 1 :), (: 0, 1, -1 :), (: 0, 1, 1 :) :)" "{M: matrices.PosFullMatrix | booleans.AND(matrices.rows(M) = 3, booleans.AND(matrices.columns(M) = 3, booleans.AND(matrix_props.det(M) /= 0, matrix_inv.inverse(M) = tarski_query.A3)))}"))) (TQ_vect3_TCC1 0 (TQ_vect3_TCC1-1 nil 3619454656 ("" (subtype-tcc) nil nil) ((poly1 const-decl "nat" poly_families nil)) shostak (TQ_vect3 subtype "0" "{k | poly_families.poly1(compute_sturm_tarski.k) /= 0}"))) (TQ_vect3_TCC2 0 (TQ_vect3_TCC2-2 "" 3790099365 ("" (expand "polynomial_prod") (("" (propax) nil nil)) nil) ((polynomial_prod const-decl "real" polynomials reals) (sigma_int application-judgement "int" sigma_nat reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (TQ_vect3 subtype "polynomials.polynomial_prod(tarski_query.g, tarski_query.k, tarski_query.g, tarski_query.k)" "[nat -> int]")) (TQ_vect3_TCC2-1 nil 3619454656 ("" (expand "polynomial_prod") (("" (skeep) (("" (skeep) (("" (case "FORALL (GB:[nat->int],jj,kk:nat): 
        rational_pred(sigma(jj,kk,
                            GB))
         AND
         integer_pred(sigma(jj,kk,
                            GB))
") (("1" (inst?) (("1" (assert) nil nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "kk") (("1" (skeep) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (inst - "GB" "jj") (("2" (expand "sigma" +) (("2" (flatten) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (case "FORALL (rd:int): rational_pred(GB(1+j)+rd)") (("1" (rewrite -1) nil nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil) ("2" (case "FORALL (rd:int): integer_pred(GB(1+j)+rd)") (("1" (rewrite -1) nil nil) ("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((polynomial_prod const-decl "real" polynomials reals)) shostak (TQ_vect3 subtype "polynomials.polynomial_prod(tarski_query.g, tarski_query.k, tarski_query.g, tarski_query.k)" "[nat -> int]"))) (TQ_vect3_TCC3 0 (TQ_vect3_TCC3-1 nil 3619454656 ("" (skeep) (("" (expand "polynomial_prod") (("" (expand "max") (("" (expand "sigma") (("" (expand "sigma") (("" (typepred "k") (("" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (polynomial_prod const-decl "real" polynomials reals) (sigma def-decl "real" sigma reals) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (/= const-decl "boolean" notequal nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_times_int_is_int application-judgement "int" integers nil) (nonzero_times3 formula-decl nil real_props nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)) shostak (TQ_vect3 subtype "number_fields.*(2, tarski_query.k)" "{k_1 | polynomials.polynomial_prod(tarski_query.g, tarski_query.k, tarski_query.g, tarski_query.k)(k_1) /= 0}"))) (TQ_vect3_TCC4 0 (TQ_vect3_TCC4-1 nil 3619454656 ("" (skeep) (("" (deftactic jiffy (then (replaces -1) (replaces -1) (repeat (expand "nth")) (repeat (expand "length")) (ground))) (("" (split) (("1" (flatten) (("1" (skosimp*) (("1" (case "i!1 = 0 OR i!1 = 1 OR i!1 = 2") (("1" (case "j!1 = 0 OR j!1 = 1 OR j!1 =2") (("1" (ground) (("1" (jiffy) nil nil) ("2" (jiffy) nil nil) ("3" (jiffy) nil nil) ("4" (jiffy) nil nil) ("5" (jiffy) nil nil) ("6" (jiffy) nil nil)) nil) ("2" (hide (2 3)) (("2" (typepred "j!1") (("2" (jiffy) nil nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (typepred "i!1") (("2" (jiffy) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind :exclude ("TQ" "polynomial_prod")) nil nil) ("3" (grind :exclude ("TQ" "polynomial_prod")) nil nil) ("4" (grind :exclude ("TQ" "polynomial_prod")) nil nil) ("5" (grind :exclude ("TQ" "polynomial_prod")) nil nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (TRUE const-decl "bool" booleans nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices matrices) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (rows const-decl "nat" matrices matrices) (below type-eq-decl nil naturalnumbers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (polynomial_prod const-decl "real" polynomials reals) (sequence type-eq-decl nil sequences nil) (poly1 const-decl "nat" poly_families nil) (TQ const-decl "int" compute_sturm_tarski nil) (/= const-decl "boolean" notequal nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (listn_0 name-judgement "listn(0)" gcd_coeff Sturm) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nth def-decl "T" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (TQ_vect3 subtype "(: (: compute_sturm_tarski.TQ(tarski_query.a, tarski_query.n, poly_families.poly1, 0) :), (: compute_sturm_tarski.TQ(tarski_query.a, tarski_query.n, tarski_query.g, tarski_query.k) :), (: compute_sturm_tarski.TQ(tarski_query.a, tarski_query.n, polynomials.polynomial_prod(tarski_query.g, tarski_query.k, tarski_query.g, tarski_query.k), number_fields.*(2, tarski_query.k)) :) :)" "{v: matrices.PosFullMatrix | booleans.AND(matrices.rows(v) = 3, matrices.columns(v) = 1)}"))) (NSol_vect3_TCC1 0 (NSol_vect3_TCC1-1 nil 3619454656 ("" (skeep) (("" (deftactic jiffy (then (replaces -1) (replaces -1) (repeat (expand "nth")) (repeat (expand "length")) (ground))) (("" (split) (("1" (flatten) (("1" (skosimp*) (("1" (case "i!1 = 0 OR i!1 = 1 OR i!1 = 2") (("1" (case "j!1 = 0 OR j!1 = 1 OR j!1 =2") (("1" (ground) (("1" (jiffy) nil nil) ("2" (jiffy) nil nil) ("3" (jiffy) nil nil) ("4" (jiffy) nil nil) ("5" (jiffy) nil nil) ("6" (jiffy) nil nil)) nil) ("2" (hide (2 3)) (("2" (typepred "j!1") (("2" (jiffy) nil nil)) nil)) nil)) nil) ("2" (hide (2 3)) (("2" (typepred "i!1") (("2" (jiffy) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (TRUE const-decl "bool" booleans nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices matrices) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (rows const-decl "nat" matrices matrices) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (NSol const-decl "{d: nat |
   EXISTS (enumsol: [below(d) -> (Sol(a, m, g, k, rel))]):
     bijective?(enumsol)}" sturmtarski nil) (bijective? const-decl "bool" functions nil) (Sol const-decl "finite_set[real]" sturmtarski nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (below type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (listn_0 name-judgement "listn(0)" gcd_coeff Sturm) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nth def-decl "T" list_props nil)) shostak (NSol_vect3 subtype "(: (: sturmtarski.NSol(tarski_query.a, tarski_query.n, tarski_query.g, tarski_query.k, =) :), (: sturmtarski.NSol(tarski_query.a, tarski_query.n, tarski_query.g, tarski_query.k, reals.>) :), (: sturmtarski.NSol(tarski_query.a, tarski_query.n, tarski_query.g, tarski_query.k, reals.<) :) :)" "{v: matrices.PosFullMatrix | booleans.AND(matrices.rows(v) = 3, matrices.columns(v) = 1)}"))) (tarski_query_system_basic_3 0 (tarski_query_system_basic_3-2 nil 3767374774 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (invoke (case "NOT %1") (! 3 1)) (("1" (hide 4) (("1" (rewrite "rows_mult") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (invoke (case "NOT %1") (! 3 1)) (("1" (assert) (("1" (hide 4) (("1" (rewrite "columns_mult") (("1" (assert) nil nil) ("2" (hide-all-but -1) (("2" (expand "A3") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (typepred "i") (("2" (rewrite "rows_mult") (("2" (typepred "j") (("2" (rewrite "columns_mult") (("1" (assert) (("1" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (case "NOT (i = 0 OR i = 1 OR i = 2)") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (split) (("1" (replace -1) (("1" (assert) (("1" (rewrite "entry_mult" +) (("1" (expand "row" + 1) (("1" (assert) (("1" (expand "A3" +) (("1" (assert) (("1" (expand "length" + 1) (("1" (assert) (("1" (expand "length" + 1) (("1" (expand "length" + 1) (("1" (expand "length" + 1) (("1" (expand "nth" + 1) (("1" (expand "*" +) (("1" (rewrite "dot_eq_sigma") (("1" (rewrite "length_col") (("1" (expand "length" + 1) (("1" (expand "length" + 1) (("1" (expand "length" + 1) (("1" (expand "length" + 1) (("1" (expand "min") (("1" (assert) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (rewrite "access_col") (("1" (rewrite "access_col") (("1" (rewrite "access_col") (("1" (expand "access" + 1) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "nth" +) (("1" (expand "access" + 2) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "nth" +) (("1" (expand "nth" +) (("1" (expand "access" + 2) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "nth" +) (("1" (expand "nth" +) (("1" (expand "nth" +) (("1" (assert) (("1" (expand "access") (("1" (rewrite "length_row") (("1" (rewrite "length_row") (("1" (assert) (("1" (expand "row") (("1" (assert) (("1" (typepred "TQ_vect3(a,n,g,k)") (("1" (expand "rows" -5) (("1" (assert) (("1" (expand "TQ_vect3" +) (("1" (expand "nth" + 2) (("1" (expand "nth" + 1) (("1" (expand "nth" + 2) (("1" (expand "nth" + 2) (("1" (expand "nth" + 2) (("1" (expand "nth" + 1) (("1" (expand "entry" +) (("1" (expand "access" +) (("1" (rewrite "length_row" +) (("1" (assert) (("1" (expand "NSol_vect3" +) (("1" (expand "row" +) (("1" (assert) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "nth" + 2) (("1" (expand "nth" + 1) (("1" (lemma "TQ_def") (("1" (inst - "a" "poly1" "0" "n") (("1" (assert) (("1" (split -1) (("1" (replaces -1) (("1" (lemma "TQ_def") (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (replace -1) (("1" (assert) (("1" (rewrite "NSol_squared_gt") (("1" (rewrite "NSol_squared_lt") (("1" (assert) (("1" (rewrite "NSol_poly1_lt") (("1" (assert) (("1" (invoke (both-sides "+" "%1" 3) (! 3 1 2)) (("1" (assert) (("1" (lemma "card_disj_union[real]") (("1" (expand "NSol" +) (("1" (rewrite -1 + :dir rl) (("1" (hide -1) (("1" (case "Sol(a, n, poly1, 0, >) =union(Sol(a, n, g, k, /=),
                                                                                             Sol(a, n, g, k, =))") (("1" (assert) nil nil) ("2" (hide 4) (("2" (decompose-equality 1) (("2" (expand "Sol" +) (("2" (expand "union") (("2" (expand "member" +) (("2" (case "polynomial(poly1,0)(x!1)>0") (("1" (assert) (("1" (iff) (("1" (ground) nil nil)) nil)) nil) ("2" (expand "poly1" 1) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (expand "member") (("2" (expand "intersection") (("2" (expand "member") (("2" (expand "Sol") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "polynomial_prod" 1) (("2" (expand "max") (("2" (expand "sigma") (("2" (expand "sigma") (("2" (assert) (("2" (lemma "nzreal_times_nzreal_is_nzreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "poly1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (rewrite "entry_mult" +) (("2" (expand "row" + 1) (("2" (assert) (("2" (expand "A3" +) (("2" (assert) (("2" (expand "length" + 1) (("2" (assert) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "nth" + 1) (("2" (expand "nth" + 1) (("2" (expand "*" +) (("2" (rewrite "dot_eq_sigma") (("2" (rewrite "length_col") (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "min") (("2" (assert) (("2" (expand "sigma") (("2" (expand "sigma") (("2" (expand "sigma") (("2" (expand "sigma") (("2" (rewrite "access_col") (("2" (rewrite "access_col") (("2" (rewrite "access_col") (("2" (expand "access" + 1) (("2" (expand "length" +) (("2" (expand "length" +) (("2" (expand "length" +) (("2" (expand "nth" +) (("2" (expand "access" + 2) (("2" (rewrite "length_row") (("2" (assert) (("2" (expand "access" + 1) (("2" (expand "length" +) (("2" (expand "length" +) (("2" (expand "length" +) (("2" (expand "access" + 1) (("2" (expand "length" +) (("2" (expand "length" +) (("2" (expand "length" +) (("2" (expand "TQ_vect3" +) (("2" (expand "row") (("2" (expand "access") (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (assert) (("2" (expand "nth" + 1) (("2" (expand "nth" + 1) (("2" (expand "nth" + 2) (("2" (expand "nth" + 2) (("2" (expand "nth" + 2) (("2" (expand "nth" + 2) (("2" (expand "nth" + 2) (("2" (assert) (("2" (expand "nth" + 1) (("2" (expand "nth" + 1) (("2" (expand "nth" + 1) (("2" (expand "nth" + 1) (("2" (expand "length" + 1) (("2" (expand "nth" + 2) (("2" (expand "nth" + 2) (("2" (expand "nth" + 2) (("2" (expand "nth" + 1) (("2" (expand "NSol_vect3" +) (("2" (expand "entry") (("2" (expand "row") (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "nth" +) (("2" (expand "nth" +) (("2" (expand "access") (("2" (expand "length" + 1) (("2" (expand "nth") (("2" (lemma "TQ_def") (("2" (inst?) (("2" (assert) (("2" (split -1) (("1" (replaces -1) (("1" (lemma "TQ_def") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (assert) (("1" (expand "NSol") (("1" (case "Sol(a, n, g, k, /=) = union(Sol(a, n, g, k, >),Sol(a, n, g, k, <))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (split -1) (("1" (replace -2 :dir rl) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 4) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (expand "intersection") (("2" (expand "member") (("2" (skosimp*) (("2" (expand "Sol") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (decompose-equality 1) (("2" (expand "union") (("2" (expand "member") (("2" (expand "Sol") (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "polynomial_prod") (("2" (expand "max") (("2" (expand "sigma") (("2" (expand "sigma") (("2" (lemma "nzreal_times_nzreal_is_nzreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -1) (("3" (assert) (("3" (rewrite "entry_mult" +) (("3" (expand "row" + 1) (("3" (assert) (("3" (expand "A3" +) (("3" (assert) (("3" (expand "length" + 1) (("3" (assert) (("3" (expand "length" + 1) (("3" (expand "length" + 1) (("3" (expand "length" + 1) (("3" (expand "nth" + 1) (("3" (expand "nth" + 1) (("3" (expand "*" +) (("3" (rewrite "dot_eq_sigma") (("3" (rewrite "length_col") (("3" (expand "nth" + 1) (("3" (expand "length" + 1) (("3" (expand "length" + 1) (("3" (expand "length" + 1) (("3" (expand "length" + 1) (("3" (expand "min") (("3" (expand "sigma") (("3" (expand "sigma") (("3" (expand "sigma") (("3" (expand "sigma") (("3" (rewrite "access_col") (("3" (rewrite "access_col") (("3" (rewrite "access_col") (("3" (expand "access" + 1) (("3" (expand "nth" + 1) (("3" (expand "length" +) (("3" (expand "length" +) (("3" (expand "length" +) (("3" (expand "nth" + 1) (("3" (expand "NSol_vect3") (("3" (hide -) (("3" (grind :exclude ("TQ" "NSol")) (("3" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (expand "NSol") (("1" (case "Sol(a, n, g, k, /=) = union(Sol(a, n, g, k,>),Sol(a,n,g,k,<))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" 1) (("1" (expand "empty?") (("1" (expand "intersection") (("1" (expand "member") (("1" (skosimp*) (("1" (expand "Sol" (-1 -2)) (("1" (flatten) (("1" (name "ZZP" "polynomial(g,k)(x!1)") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "Sol") (("2" (expand "union") (("2" (expand "member") (("2" (name "RD" "polynomial(a,n)") (("2" (replaces -1) (("2" (name "D65" "polynomial(g,k)") (("2" (replaces -1) (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "nzreal_times_nzreal_is_nzreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (typepred "A3") (("2" (expand "rows") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ((mult_full application-judgement "FullMatrix" matrices matrices) (full_matrix_eq formula-decl nil matrices matrices) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices matrices) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices matrices) (rows const-decl "nat" matrices matrices) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices matrices) (MatrixMN type-eq-decl nil matrices matrices) (entry const-decl "real" matrices matrices) (Vector type-eq-decl nil matrices matrices) (* const-decl "real" matrices matrices) (row const-decl "Vector" matrices matrices) (VectorN type-eq-decl nil matrices matrices) (col def-decl "VectorN(rows(M))" matrices matrices) (* const-decl "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i: nat, j: nat): entry(A)(i, j) = row(M)(i) * col(N)(j)}" matrices matrices) (> const-decl "bool" reals nil) (PosFullMatrix type-eq-decl nil matrices matrices) (A3 const-decl "{M: PosFullMatrix | rows(M) = 3 AND columns(M) = 3}" tarski_query nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (TQ_vect3 const-decl "{v: PosFullMatrix | rows(v) = 3 AND columns(v) = 1}" tarski_query nil) (NSol_vect3 const-decl "{v: PosFullMatrix | rows(v) = 3 AND columns(v) = 1}" tarski_query nil) (length_col formula-decl nil matrices matrices) (access const-decl "real" matrices matrices) (real_minus_real_is_real application-judgement "real" reals nil) (length_row formula-decl nil matrix_props matrices) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (TQ_def formula-decl nil compute_sturm_tarski nil) (TRUE const-decl "bool" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (polynomial_prod const-decl "real" polynomials reals) (sequence type-eq-decl nil sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (NSol_squared_lt formula-decl nil tarski_query nil) (NSol_poly1_lt formula-decl nil tarski_query nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (NSol const-decl "{d: nat |
   EXISTS (enumsol: [below(d) -> (Sol(a, m, g, k, rel))]):
     bijective?(enumsol)}" sturmtarski nil) (bijective? const-decl "bool" functions nil) (Sol const-decl "finite_set[real]" sturmtarski nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (card_disj_union formula-decl nil finite_sets nil) (finite_union application-judgement "finite_set" finite_sets nil) (union const-decl "set" sets nil) (polynomial const-decl "[real -> real]" polynomials reals) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (member const-decl "bool" sets nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (disjoint? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (empty? const-decl "bool" sets nil) (NSol_squared_gt formula-decl nil tarski_query nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nzreal_times_nzreal_is_nzreal judgement-tcc nil real_types nil) (nzreal nonempty-type-eq-decl nil reals nil) (int_times_int_is_int application-judgement "int" integers nil) (poly1 const-decl "nat" poly_families nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (access_col formula-decl nil matrix_props matrices) (sigma def-decl "real" sigma reals) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (dot_eq_sigma formula-decl nil matrices matrices) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nil application-judgement "above(n)" exp2 nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (listn_0 name-judgement "listn(0)" gcd_coeff Sturm) (entry_mult formula-decl nil matrices matrices) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (sigma_int application-judgement "int" sigma_nat reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (columns_mult formula-decl nil matrices matrices) (rows_mult formula-decl nil matrices matrices) (NOT const-decl "[bool -> bool]" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil) (tarski_query_system_basic_3-1 nil 3619454894 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (invoke (case "NOT %1") (! 3 1)) (("1" (hide 4) (("1" (rewrite "rows_mult") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (invoke (case "NOT %1") (! 3 1)) (("1" (assert) (("1" (hide 4) (("1" (rewrite "columns_mult") (("1" (assert) nil nil) ("2" (hide-all-but -1) (("2" (expand "A3") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (typepred "i") (("2" (rewrite "rows_mult") (("2" (typepred "j") (("2" (rewrite "columns_mult") (("1" (assert) (("1" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (case "NOT (i = 0 OR i = 1 OR i = 2)") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (split) (("1" (replace -1) (("1" (assert) (("1" (rewrite "entry_mult" +) (("1" (expand "row" + 1) (("1" (assert) (("1" (expand "A3" +) (("1" (assert) (("1" (expand "length" + 1) (("1" (assert) (("1" (expand "length" + 1) (("1" (expand "length" + 1) (("1" (expand "length" + 1) (("1" (expand "nth" + 1) (("1" (expand "*" +) (("1" (rewrite "dot_eq_sigma") (("1" (rewrite "length_col") (("1" (expand "length" + 1) (("1" (expand "length" + 1) (("1" (expand "length" + 1) (("1" (expand "length" + 1) (("1" (expand "min") (("1" (assert) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (rewrite "access_col") (("1" (rewrite "access_col") (("1" (rewrite "access_col") (("1" (expand "access" + 1) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "nth" +) (("1" (expand "access" + 2) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "nth" +) (("1" (expand "nth" +) (("1" (expand "access" + 2) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "nth" +) (("1" (expand "nth" +) (("1" (expand "nth" +) (("1" (assert) (("1" (expand "access") (("1" (rewrite "length_row") (("1" (rewrite "length_row") (("1" (assert) (("1" (expand "row") (("1" (assert) (("1" (typepred "TQ_vect3(a,n,g,k)") (("1" (expand "rows" -5) (("1" (assert) (("1" (expand "TQ_vect3" +) (("1" (expand "nth" + 2) (("1" (expand "nth" + 1) (("1" (expand "nth" + 2) (("1" (expand "nth" + 2) (("1" (expand "nth" + 2) (("1" (expand "nth" + 1) (("1" (expand "entry" +) (("1" (expand "access" +) (("1" (rewrite "length_row" +) (("1" (assert) (("1" (expand "NSol_vect3" +) (("1" (expand "row" +) (("1" (assert) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "length" +) (("1" (expand "nth" + 2) (("1" (expand "nth" + 1) (("1" (expand "restrict") (("1" (lemma "TQ_def") (("1" (inst - "a" "poly1" "0" "n") (("1" (assert) (("1" (split -1) (("1" (replaces -1) (("1" (lemma "TQ_def") (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (replace -1) (("1" (assert) (("1" (rewrite "NSol_squared_gt") (("1" (expand "restrict") (("1" (rewrite "NSol_squared_lt") (("1" (assert) (("1" (rewrite "NSol_poly1_lt") (("1" (assert) (("1" (invoke (both-sides "+" "%1" 3) (! 3 1 2)) (("1" (assert) (("1" (lemma "card_disj_union[real]") (("1" (expand "NSol" +) (("1" (rewrite -1 + :dir rl) (("1" (hide -1) (("1" (case "Sol(a, n, poly1, 0, >) =union(Sol(a, n, g, k, LAMBDA (s: [real, real]): =(s)),
                                                                    Sol(a, n, g, k, LAMBDA (s: [real, real]): /=(s)))") (("1" (assert) nil nil) ("2" (hide 4) (("2" (decompose-equality 1) (("2" (expand "Sol" +) (("2" (expand "union") (("2" (expand "member" +) (("2" (case "polynomial(poly1,0)(x!1)>0") (("1" (assert) (("1" (iff) (("1" (ground) nil nil)) nil)) nil) ("2" (expand "poly1" 1) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (expand "member") (("2" (expand "intersection") (("2" (expand "member") (("2" (expand "Sol") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "polynomial_prod" 1) (("2" (expand "max") (("2" (expand "sigma") (("2" (expand "sigma") (("2" (assert) (("2" (lemma "nzreal_times_nzreal_is_nzreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "poly1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (assert) (("2" (rewrite "entry_mult" +) (("2" (expand "row" + 1) (("2" (assert) (("2" (expand "A3" +) (("2" (assert) (("2" (expand "length" + 1) (("2" (assert) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "nth" + 1) (("2" (expand "nth" + 1) (("2" (expand "*" +) (("2" (rewrite "dot_eq_sigma") (("2" (rewrite "length_col") (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "min") (("2" (assert) (("2" (expand "sigma") (("2" (expand "sigma") (("2" (expand "sigma") (("2" (expand "sigma") (("2" (rewrite "access_col") (("2" (rewrite "access_col") (("2" (rewrite "access_col") (("2" (expand "access" + 1) (("2" (expand "length" +) (("2" (expand "length" +) (("2" (expand "length" +) (("2" (expand "nth" +) (("2" (expand "access" + 2) (("2" (rewrite "length_row") (("2" (assert) (("2" (expand "access" + 1) (("2" (expand "length" +) (("2" (expand "length" +) (("2" (expand "length" +) (("2" (expand "access" + 1) (("2" (expand "length" +) (("2" (expand "length" +) (("2" (expand "length" +) (("2" (expand "TQ_vect3" +) (("2" (expand "row") (("2" (expand "access") (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (assert) (("2" (expand "nth" + 1) (("2" (expand "nth" + 1) (("2" (expand "nth" + 2) (("2" (expand "nth" + 2) (("2" (expand "nth" + 2) (("2" (expand "nth" + 2) (("2" (expand "nth" + 2) (("2" (assert) (("2" (expand "nth" + 1) (("2" (expand "nth" + 1) (("2" (expand "nth" + 1) (("2" (expand "nth" + 1) (("2" (expand "length" + 1) (("2" (expand "nth" + 2) (("2" (expand "nth" + 2) (("2" (expand "nth" + 2) (("2" (expand "nth" + 1) (("2" (expand "NSol_vect3" +) (("2" (expand "restrict") (("2" (expand "entry") (("2" (expand "row") (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "length" + 1) (("2" (expand "nth" +) (("2" (expand "nth" +) (("2" (expand "access") (("2" (expand "length" + 1) (("2" (expand "nth") (("2" (lemma "TQ_def") (("2" (inst?) (("2" (assert) (("2" (split -1) (("1" (replaces -1) (("1" (lemma "TQ_def") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (expand "restrict") (("1" (assert) (("1" (expand "NSol") (("1" (case "Sol(a, n, g, k, LAMBDA (s: [real, real]): /=(s)) = union(Sol(a, n, g, k, >),Sol(a, n, g, k, <))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (split -1) (("1" (replace -2 :dir rl) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 4) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (expand "intersection") (("2" (expand "member") (("2" (skosimp*) (("2" (expand "Sol") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (decompose-equality 1) (("2" (expand "union") (("2" (expand "member") (("2" (expand "Sol") (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "polynomial_prod") (("2" (expand "max") (("2" (expand "sigma") (("2" (expand "sigma") (("2" (lemma "nzreal_times_nzreal_is_nzreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (replace -1) (("3" (assert) (("3" (rewrite "entry_mult" +) (("3" (expand "row" + 1) (("3" (assert) (("3" (expand "A3" +) (("3" (assert) (("3" (expand "length" + 1) (("3" (assert) (("3" (expand "length" + 1) (("3" (expand "length" + 1) (("3" (expand "length" + 1) (("3" (expand "nth" + 1) (("3" (expand "nth" + 1) (("3" (expand "*" +) (("3" (rewrite "dot_eq_sigma") (("3" (rewrite "length_col") (("3" (expand "nth" + 1) (("3" (expand "length" + 1) (("3" (expand "length" + 1) (("3" (expand "length" + 1) (("3" (expand "length" + 1) (("3" (expand "min") (("3" (expand "sigma") (("3" (expand "sigma") (("3" (expand "sigma") (("3" (expand "sigma") (("3" (rewrite "access_col") (("3" (rewrite "access_col") (("3" (rewrite "access_col") (("3" (expand "access" + 1) (("3" (expand "nth" + 1) (("3" (expand "length" +) (("3" (expand "length" +) (("3" (expand "length" +) (("3" (expand "nth" + 1) (("3" (expand "NSol_vect3") (("3" (hide -) (("3" (grind :exclude ("TQ" "NSol")) (("3" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (expand "restrict") (("1" (expand "NSol") (("1" (case "Sol(a, n, g, k, LAMBDA (s: [real, real]): /=(s)) = union(Sol(a, n, g, k,>),Sol(a,n,g,k,<))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (expand "disjoint?" 1) (("1" (expand "empty?") (("1" (expand "intersection") (("1" (expand "member") (("1" (skosimp*) (("1" (expand "Sol" (-1 -2)) (("1" (flatten) (("1" (name "ZZP" "polynomial(g,k)(x!1)") (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "Sol") (("2" (expand "union") (("2" (expand "member") (("2" (name "RD" "polynomial(a,n)") (("2" (replaces -1) (("2" (name "D65" "polynomial(g,k)") (("2" (replaces -1) (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "nzreal_times_nzreal_is_nzreal") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (typepred "A3") (("2" (expand "rows") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ((mult_full application-judgement "FullMatrix" matrices matrices) (full_matrix_eq formula-decl nil matrices matrices) (Matrix type-eq-decl nil matrices matrices) (FullMatrix type-eq-decl nil matrices matrices) (rows const-decl "nat" matrices matrices) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices matrices) (MatrixMN type-eq-decl nil matrices matrices) (entry const-decl "real" matrices matrices) (Vector type-eq-decl nil matrices matrices) (* const-decl "real" matrices matrices) (row const-decl "Vector" matrices matrices) (VectorN type-eq-decl nil matrices matrices) (col def-decl "VectorN(rows(M))" matrices matrices) (PosFullMatrix type-eq-decl nil matrices matrices) (length_col formula-decl nil matrices matrices) (access const-decl "real" matrices matrices) (length_row formula-decl nil matrix_props matrices) (poly1 const-decl "nat" poly_families nil) (polynomial const-decl "[real -> real]" polynomials reals) (polynomial_prod const-decl "real" polynomials reals) (TQ_def formula-decl nil compute_sturm_tarski nil) (access_col formula-decl nil matrix_props matrices) (sigma def-decl "real" sigma reals) (dot_eq_sigma formula-decl nil matrices matrices) (entry_mult formula-decl nil matrices matrices) (columns_mult formula-decl nil matrices matrices) (rows_mult formula-decl nil matrices matrices)) shostak)) (A6_TCC1 0 (A6_TCC1-2 "" 3790099376 ("" (eval-formula) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil)) shostak (A6 subtype "(: (: 1, 0, -1 :), (: 0, number_fields./(1, 2), number_fields./(1, 2) :), (: 0, number_fields./(-1, 2), number_fields./(1, 2) :), (: 0, 0, 1 :), (: 1, number_fields./(1, 2), number_fields./(-1, 2) :), (: 1, number_fields./(-1, 2), number_fields./(-1, 2) :) :)" "{M: matrices.PosFullMatrix | booleans.AND(matrices.rows(M) = 6, matrices.columns(M) = 3)}")) (A6_TCC1-1 nil 3619526340 ("" (eval-formula)) nil nil (A6 subtype "(: (: 1, 0, -1 :), (: 0, number_fields./(1, 2), number_fields./(1, 2) :), (: 0, number_fields./(-1, 2), number_fields./(1, 2) :), (: 0, 0, 1 :), (: 1, number_fields./(1, 2), number_fields./(-1, 2) :), (: 1, number_fields./(-1, 2), number_fields./(-1, 2) :) :)" "{M: matrices.PosFullMatrix | booleans.AND(matrices.rows(M) = 6, matrices.columns(M) = 3)}"))) (NSol_vect6_TCC1 0 (NSol_vect6_TCC1-1 nil 3619526340 ("" (skeep) (("" (split) (("1" (flatten) (("1" (hide 1) (("1" (deftactic flipper (then (replaces -1) (replaces -1) (repeat (expand "nth")) (repeat (expand "length")) (assert))) (("1" (skeep) (("1" (case "i = 0 OR i = 1 OR i = 2 OR i = 3 OR i = 4 OR i = 5") (("1" (case "j = 0 OR j = 1 OR j = 2 OR j = 3 OR j = 4 OR j = 5") (("1" (deftactic skipper (then (split -) (split -) (flipper))) (("1" (skipper) nil nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "j") (("2" (grind :exclude "NSol") nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "i") (("2" (grind :exclude "NSol") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind :exclude "NSol") nil nil) ("3" (grind :exclude "NSol") nil nil) ("4" (grind :exclude "NSol") nil nil) ("5" (grind :exclude "NSol") nil nil)) nil)) nil) ((nth def-decl "T" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn(0)" gcd_coeff Sturm) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (/= const-decl "boolean" notequal nil) (below type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (Sol const-decl "finite_set[real]" sturmtarski nil) (bijective? const-decl "bool" functions nil) (NSol const-decl "{d: nat |
   EXISTS (enumsol: [below(d) -> (Sol(a, m, g, k, rel))]):
     bijective?(enumsol)}" sturmtarski nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (rows const-decl "nat" matrices matrices) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices matrices) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil)) shostak (NSol_vect6 subtype "(: (: sturmtarski.NSol(tarski_query.a, tarski_query.n, tarski_query.g, tarski_query.k, =) :), (: sturmtarski.NSol(tarski_query.a, tarski_query.n, tarski_query.g, tarski_query.k, reals.>) :), (: sturmtarski.NSol(tarski_query.a, tarski_query.n, tarski_query.g, tarski_query.k, reals.<) :), (: sturmtarski.NSol(tarski_query.a, tarski_query.n, tarski_query.g, tarski_query.k, /=) :), (: sturmtarski.NSol(tarski_query.a, tarski_query.n, tarski_query.g, tarski_query.k, reals.>=) :), (: sturmtarski.NSol(tarski_query.a, tarski_query.n, tarski_query.g, tarski_query.k, reals.<=) :) :)" "{v: matrices.PosFullMatrix | booleans.AND(matrices.rows(v) = 6, matrices.columns(v) = 1)}"))) (tarski_query_system_basic_6 0 (tarski_query_system_basic_6-3 "" 3884456470 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (invoke (case "NOT %1") (! 3 1)) (("1" (hide 2) (("1" (rewrite "rows_mult") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (invoke (case "NOT %1") (! 3 1)) (("1" (hide 2) (("1" (rewrite "columns_mult") (("1" (assert) nil nil) ("2" (hide-all-but -1) (("2" (expand "A6") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (typepred "i") (("2" (rewrite "rows_mult") (("2" (typepred "j") (("2" (rewrite "columns_mult") (("1" (assert) (("1" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (case "NOT (i = 0 OR i = 1 OR i = 2 OR i = 3 OR i = 4 OR i = 5)") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (split) (("1" (replace -1) (("1" (hide -) (("1" (grind :exclude ("TQ" "NSol")) (("1" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (rewrite "NSol_poly1_lt") (("1" (assert) (("1" (expand "NSol") (("1" (case "Sol(a, n, poly1, 0, >) =union(Sol(a, n, g, k, /=),
                                                                                                                                                                                             Sol(a, n, g, k, =))") (("1" (assert) (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (name "AB" "Sol(a, n, poly1, 0, >)") (("2" (replaces -1) (("2" (name "ABC" "Sol(a, n, g, k, =)") (("2" (replaces -1) (("2" (name "ABCD" "Sol(a, n, g, k, /=)") (("2" (replaces -1) (("2" (decompose-equality 1) (("2" (iff) (("2" (expand "ABC") (("2" (expand "ABCD") (("2" (expand "AB") (("2" (expand "Sol") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -) (("2" (grind :exclude ("TQ" "NSol")) (("2" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (case "Sol(a, n, g, k, /=) = union(Sol(a, n, g, k, >) ,Sol(a, n, g, k, <))") (("1" (expand "NSol") (("1" (assert) (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (flatten) (("1" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil) ("3" (replace -1) (("3" (hide -) (("3" (grind :exclude ("TQ" "NSol")) (("3" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (case "Sol(a, n, g, k, /=) = union(Sol(a, n, g, k, >) ,Sol(a, n, g, k, <))") (("1" (lemma "card_disj_union[real]") (("1" (expand "NSol") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (flatten) (("1" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil) ("4" (replace -1) (("4" (hide -) (("4" (grind :exclude ("TQ" "NSol")) (("4" (rewrite "TQ_def") (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") nil nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil) ("5" (replace -1) (("5" (hide -) (("5" (grind :exclude ("TQ" "NSol")) (("5" (rewrite "TQ_def") (("5" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (rewrite "NSol_poly1_lt") (("1" (assert) (("1" (expand "NSol") (("1" (case "Sol(a, n, g, k, /=) = union(Sol(a, n, g, k, >) ,Sol(a, n, g, k, <))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (replace -2) (("1" (replace -1) (("1" (assert) (("1" (case "card(Sol(a, n, poly1, 0, >)) - card(Sol(a, n, g, k, <))=card(Sol(a, n, g, k, >=))") (("1" (propax) nil nil) ("2" (hide 4) (("2" (hide -) (("2" (case "Sol(a, n, poly1, 0, >) = union(Sol(a, n, g, k, <),Sol(a, n, g, k, >=))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (case "polynomial(poly1,0)(x!1) > 0") (("1" (ground) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (expand "member") (("2" (expand "intersection") (("2" (expand "member") (("2" (expand "Sol") (("2" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (replace -1) (("6" (hide -) (("6" (grind :exclude ("TQ" "NSol")) (("6" (rewrite "TQ_def") (("6" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (assert) (("1" (rewrite "NSol_poly1_lt") (("1" (assert) (("1" (case "Sol(a, n, g, k, /=) = union(Sol(a, n, g, k, >) ,Sol(a, n, g, k, <))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (expand "NSol") (("1" (assert) (("1" (split -1) (("1" (replaces -2) (("1" (replaces -1) (("1" (assert) (("1" (case "Sol(a, n, poly1, 0, >) = union(Sol(a, n, g, k, >),Sol(a, n, g, k, <=))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (expand "member") (("2" (expand "intersection") (("2" (expand "member") (("2" (expand "Sol") (("2" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) nil shostak) (tarski_query_system_basic_6-2 nil 3767374977 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (invoke (case "NOT %1") (! 3 1)) (("1" (hide 2) (("1" (rewrite "rows_mult") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (invoke (case "NOT %1") (! 3 1)) (("1" (hide 2) (("1" (rewrite "columns_mult") (("1" (assert) nil nil) ("2" (hide-all-but -1) (("2" (expand "A6") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (typepred "i") (("2" (rewrite "rows_mult") (("2" (typepred "j") (("2" (rewrite "columns_mult") (("1" (assert) (("1" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (case "NOT (i = 0 OR i = 1 OR i = 2 OR i = 3 OR i = 4 OR i = 5)") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (split) (("1" (replace -1) (("1" (hide -) (("1" (grind :exclude ("TQ" "NSol")) (("1" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (rewrite "NSol_poly1_lt") (("1" (assert) (("1" (expand "NSol") (("1" (case "Sol(a, n, poly1, 0, >) =union(Sol(a, n, g, k, /=),
                                                                                                                                                                                             Sol(a, n, g, k, =))") (("1" (assert) (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (name "AB" "Sol(a, n, poly1, 0, >)") (("2" (replaces -1) (("2" (name "ABC" "Sol(a, n, g, k, =)") (("2" (replaces -1) (("2" (name "ABCD" "Sol(a, n, g, k, /=)") (("2" (replaces -1) (("2" (decompose-equality 1) (("2" (iff) (("2" (expand "ABC") (("2" (expand "ABCD") (("2" (expand "AB") (("2" (expand "Sol") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -) (("2" (grind :exclude ("TQ" "NSol")) (("2" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (case "Sol(a, n, g, k, /=) = union(Sol(a, n, g, k, >) ,Sol(a, n, g, k, <))") (("1" (expand "NSol") (("1" (assert) (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (flatten) (("1" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil) ("3" (replace -1) (("3" (hide -) (("3" (grind :exclude ("TQ" "NSol")) (("3" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (case "Sol(a, n, g, k, /=) = union(Sol(a, n, g, k, >) ,Sol(a, n, g, k, <))") (("1" (lemma "card_disj_union[real]") (("1" (expand "NSol") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (flatten) (("1" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil) ("4" (replace -1) (("4" (hide -) (("4" (grind :exclude ("TQ" "NSol")) (("4" (rewrite "TQ_def") (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") nil nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil) ("5" (replace -1) (("5" (hide -) (("5" (grind :exclude ("TQ" "NSol")) (("5" (rewrite "TQ_def") (("5" (rewrite "TQ_def") (("5" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (rewrite "NSol_poly1_lt") (("1" (assert) (("1" (expand "NSol") (("1" (case "Sol(a, n, g, k, /=) = union(Sol(a, n, g, k, >) ,Sol(a, n, g, k, <))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (replace -2) (("1" (replace -1) (("1" (assert) (("1" (case "card(Sol(a, n, poly1, 0, >)) - card(Sol(a, n, g, k, <))=card(Sol(a, n, g, k, >=))") (("1" (assert) nil nil) ("2" (hide 4) (("2" (hide -) (("2" (case "Sol(a, n, poly1, 0, >) = union(Sol(a, n, g, k, <),Sol(a, n, g, k, >=))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (case "polynomial(poly1,0)(x!1) > 0") (("1" (ground) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (expand "member") (("2" (expand "intersection") (("2" (expand "member") (("2" (expand "Sol") (("2" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (replace -1) (("6" (hide -) (("6" (grind :exclude ("TQ" "NSol")) (("6" (rewrite "TQ_def") (("6" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (assert) (("1" (rewrite "NSol_poly1_lt") (("1" (assert) (("1" (case "Sol(a, n, g, k, /=) = union(Sol(a, n, g, k, >) ,Sol(a, n, g, k, <))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (expand "NSol") (("1" (assert) (("1" (split -1) (("1" (replaces -2) (("1" (replaces -1) (("1" (assert) (("1" (case "Sol(a, n, poly1, 0, >) = union(Sol(a, n, g, k, >),Sol(a, n, g, k, <=))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (expand "member") (("2" (expand "intersection") (("2" (expand "member") (("2" (expand "Sol") (("2" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ((mult_full application-judgement "FullMatrix" matrices matrices) (full_matrix_eq formula-decl nil matrices matrices) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (Matrix type-eq-decl nil matrices matrices) (OR const-decl "[bool, bool -> bool]" booleans nil) (real nonempty-type-from-decl nil reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (FullMatrix type-eq-decl nil matrices matrices) (rows const-decl "nat" matrices matrices) (<= const-decl "bool" reals nil) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices matrices) (MatrixMN type-eq-decl nil matrices matrices) (entry const-decl "real" matrices matrices) (Vector type-eq-decl nil matrices matrices) (* const-decl "real" matrices matrices) (row const-decl "Vector" matrices matrices) (VectorN type-eq-decl nil matrices matrices) (col def-decl "VectorN(rows(M))" matrices matrices) (* const-decl "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i: nat, j: nat): entry(A)(i, j) = row(M)(i) * col(N)(j)}" matrices matrices) (> const-decl "bool" reals nil) (PosFullMatrix type-eq-decl nil matrices matrices) (A6 const-decl "{M: PosFullMatrix | rows(M) = 6 AND columns(M) = 3}" tarski_query nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (TQ_vect3 const-decl "{v: PosFullMatrix | rows(v) = 3 AND columns(v) = 1}" tarski_query nil) (NSol_vect6 const-decl "{v: PosFullMatrix | rows(v) = 6 AND columns(v) = 1}" tarski_query nil) (poly1 const-decl "nat" poly_families nil) (TQ_def formula-decl nil compute_sturm_tarski nil) (nonzero_times3 formula-decl nil real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (NSol_squared_gt formula-decl nil tarski_query nil) (finite_union application-judgement "finite_set" finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (Sol const-decl "finite_set[real]" sturmtarski nil) (union const-decl "set" sets nil) (card_disj_union formula-decl nil finite_sets nil) (finite_intersection1 application-judgement "finite_set" finite_sets nil) (disjoint? const-decl "bool" sets nil) (intersection const-decl "set" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (ABC skolem-const-decl "finite_set[real]" tarski_query nil) (AB skolem-const-decl "finite_set[real]" tarski_query nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (polynomial const-decl "[real -> real]" polynomials reals) (ABCD skolem-const-decl "finite_set[real]" tarski_query nil) (TRUE const-decl "bool" booleans nil) (NSol const-decl "{d: nat |
   EXISTS (enumsol: [below(d) -> (Sol(a, m, g, k, rel))]):
     bijective?(enumsol)}" sturmtarski nil) (NSol_poly1_lt formula-decl nil tarski_query nil) (NSol_squared_lt formula-decl nil tarski_query nil) (sigma def-decl "real" sigma reals) (sigma_int application-judgement "int" sigma_nat reals) (int_max application-judgement "{k: int | i <= k AND j <= k}" real_defs nil) (rat_max application-judgement "{s: rat | s >= q AND s >= r}" real_defs nil) (int_times_int_is_int application-judgement "int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (sequence type-eq-decl nil sequences nil) (polynomial_prod const-decl "real" polynomials reals) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (nil application-judgement "above(n)" exp2 nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (form_matrix_square application-judgement "FullMatrix" matrices matrices) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nprat_div_posrat_is_nprat application-judgement "nprat" rationals nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (listn_0 name-judgement "listn(0)" gcd_coeff Sturm) (access const-decl "real" matrices matrices) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (dot def-decl "real" matrices matrices) (form_matrix const-decl "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" matrices matrices) (mult const-decl "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i: nat, j: nat): entry(A)(i, j) = row(M)(i) * col(N)(j)}" matrices matrices) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (columns_mult formula-decl nil matrices matrices) (rows_mult formula-decl nil matrices matrices) (NOT const-decl "[bool -> bool]" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil) (tarski_query_system_basic_6-1 nil 3619526348 ("" (skeep) (("" (rewrite "full_matrix_eq") (("" (invoke (case "NOT %1") (! 3 1)) (("1" (hide 2) (("1" (rewrite "rows_mult") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (invoke (case "NOT %1") (! 3 1)) (("1" (hide 2) (("1" (rewrite "columns_mult") (("1" (assert) nil nil) ("2" (hide-all-but -1) (("2" (expand "A6") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (typepred "i") (("2" (rewrite "rows_mult") (("2" (typepred "j") (("2" (rewrite "columns_mult") (("1" (assert) (("1" (case "NOT j = 0") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (case "NOT (i = 0 OR i = 1 OR i = 2 OR i = 3 OR i = 4 OR i = 5)") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (split) (("1" (replace -1) (("1" (hide -) (("1" (grind :exclude ("TQ" "NSol")) (("1" (expand "restrict") (("1" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (expand "restrict") (("1" (rewrite "NSol_poly1_lt") (("1" (assert) (("1" (expand "NSol") (("1" (case "Sol(a, n, poly1, 0, >) =union(Sol(a, n, g, k, LAMBDA (s: [real, real]): =(s)),
                                                                                                                                                                        Sol(a, n, g, k, LAMBDA (s: [real, real]): /=(s)))") (("1" (assert) (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (name "AB" "Sol(a, n, poly1, 0, >)") (("2" (replaces -1) (("2" (name "ABC" "Sol(a, n, g, k, LAMBDA (s: [real, real]): =(s))") (("2" (replaces -1) (("2" (name "ABCD" "Sol(a, n, g, k, LAMBDA (s: [real, real]): /=(s))") (("2" (replaces -1) (("2" (decompose-equality 1) (("2" (iff) (("2" (expand "ABC") (("2" (expand "ABCD") (("2" (expand "AB") (("2" (expand "Sol") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (hide -) (("2" (grind :exclude ("TQ" "NSol")) (("2" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (expand "restrict") (("1" (case "Sol(a, n, g, k, LAMBDA (s: [real, real]): /=(s)) = union(Sol(a, n, g, k, >) ,Sol(a, n, g, k, <))") (("1" (expand "NSol") (("1" (assert) (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (flatten) (("1" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil) ("3" (replace -1) (("3" (hide -) (("3" (grind :exclude ("TQ" "NSol")) (("3" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (expand "restrict") (("1" (case "Sol(a, n, g, k, LAMBDA (s: [real, real]): /=(s)) = union(Sol(a, n, g, k, >) ,Sol(a, n, g, k, <))") (("1" (lemma "card_disj_union[real]") (("1" (expand "NSol") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (flatten) (("1" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil) ("4" (replace -1) (("4" (hide -) (("4" (grind :exclude ("TQ" "NSol")) (("4" (expand "restrict") (("4" (rewrite "TQ_def") (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (replace -1) (("5" (hide -) (("5" (grind :exclude ("TQ" "NSol")) (("5" (rewrite "TQ_def") (("5" (rewrite "TQ_def") (("5" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (expand "restrict") (("1" (rewrite "NSol_poly1_lt") (("1" (assert) (("1" (expand "NSol") (("1" (case "Sol(a, n, g, k, LAMBDA (s: [real, real]): /=(s)) = union(Sol(a, n, g, k, >) ,Sol(a, n, g, k, <))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (replace -2) (("1" (replace -1) (("1" (assert) (("1" (case "card(Sol(a, n, poly1, 0, >)) - card(Sol(a, n, g, k, <))=card(Sol(a, n, g, k, >=))") (("1" (assert) nil nil) ("2" (hide 4) (("2" (hide -) (("2" (case "Sol(a, n, poly1, 0, >) = union(Sol(a, n, g, k, <),Sol(a, n, g, k, >=))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (case "polynomial(poly1,0)(x!1) > 0") (("1" (ground) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (expand "member") (("2" (expand "intersection") (("2" (expand "member") (("2" (expand "Sol") (("2" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (replace -1) (("6" (hide -) (("6" (grind :exclude ("TQ" "NSol")) (("6" (rewrite "TQ_def") (("6" (rewrite "TQ_def") (("1" (rewrite "TQ_def") (("1" (assert) (("1" (rewrite "NSol_squared_lt") (("1" (rewrite "NSol_squared_gt") (("1" (expand "restrict") (("1" (assert) (("1" (rewrite "NSol_poly1_lt") (("1" (assert) (("1" (case "Sol(a, n, g, k, LAMBDA (s: [real, real]): /=(s)) = union(Sol(a, n, g, k, >) ,Sol(a, n, g, k, <))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (expand "NSol") (("1" (assert) (("1" (split -1) (("1" (replaces -2) (("1" (replaces -1) (("1" (assert) (("1" (case "Sol(a, n, poly1, 0, >) = union(Sol(a, n, g, k, >),Sol(a, n, g, k, <=))") (("1" (lemma "card_disj_union[real]") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (expand "disjoint?") (("1" (expand "empty?") (("1" (skeep) (("1" (expand "member") (("1" (expand "intersection") (("1" (expand "member") (("1" (expand "Sol") (("1" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "disjoint?") (("2" (expand "empty?") (("2" (skeep) (("2" (expand "member") (("2" (expand "intersection") (("2" (expand "member") (("2" (expand "Sol") (("2" (grind :exclude "polynomial") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (expand "union") (("2" (expand "member") (("2" (grind :exclude "polynomial") (("2" (decompose-equality 1) (("2" (iff) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (real-props) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil) ((mult_full application-judgement "FullMatrix" matrices matrices) (full_matrix_eq formula-decl nil matrices matrices) (Matrix type-eq-decl nil matrices matrices) (FullMatrix type-eq-decl nil matrices matrices) (rows const-decl "nat" matrices matrices) (columns def-decl "{c: nat |
   (FORALL (i: below(length(M))): length(nth(M, i)) <= c) AND
    (null?(M) AND c = 0 OR
      EXISTS (i: below(length(M))): length(nth(M, i)) = c)}" matrices matrices) (MatrixMN type-eq-decl nil matrices matrices) (entry const-decl "real" matrices matrices) (Vector type-eq-decl nil matrices matrices) (* const-decl "real" matrices matrices) (row const-decl "Vector" matrices matrices) (VectorN type-eq-decl nil matrices matrices) (col def-decl "VectorN(rows(M))" matrices matrices) (PosFullMatrix type-eq-decl nil matrices matrices) (polynomial_prod const-decl "real" polynomials reals) (sigma def-decl "real" sigma reals) (polynomial const-decl "[real -> real]" polynomials reals) (TQ_def formula-decl nil compute_sturm_tarski nil) (poly1 const-decl "nat" poly_families nil) (form_matrix_square application-judgement "FullMatrix" matrices matrices) (access const-decl "real" matrices matrices) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (dot def-decl "real" matrices matrices) (form_matrix const-decl "{M: MatrixMN(m, n) |
   FORALL (i: below(m), j: below(n)): nth(row(M)(i), j) = F(i, j)}" matrices matrices) (mult const-decl "{A: MatrixMN(rows(M), columns(N)) |
   FORALL (i: nat, j: nat): entry(A)(i, j) = row(M)(i) * col(N)(j)}" matrices matrices) (columns_mult formula-decl nil matrices matrices) (rows_mult formula-decl nil matrices matrices)) nil)))
