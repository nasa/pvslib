(dnf_strategy (remove_constants_rec_TCC1 0 (remove_constants_rec_TCC1-1 nil 3770629764 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil)) nil (remove_constants_rec subtype "dnf_strategy.l" "(list_adt[DNF_Atom].cons?)"))) (remove_constants_rec_TCC2 0 (remove_constants_rec_TCC2-1 nil 3770629764 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (polynomial const-decl "[real -> real]" polynomials reals) (eval_rel const-decl "bool" dnf_polynomials nil) (eval_atm const-decl "bool" dnf_polynomials nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil)) nil (remove_constants_rec termination "dnf_strategy.remove_constants_rec(list_adt[DNF_Atom].cdr(dnf_strategy.l), dnf_strategy.a)" "nil"))) (remove_constants_rec_TCC3 0 (remove_constants_rec_TCC3-1 nil 3770629764 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals)) nil (remove_constants_rec termination "dnf_strategy.remove_constants_rec(list_adt[DNF_Atom].cdr(dnf_strategy.l), list_adt[DNF_Atom].cons(list_adt[DNF_Atom].car(dnf_strategy.l), dnf_strategy.a))" "nil"))) (when_not_none 0 (when_not_none-7 nil 3772803657 ("" (induct "l1") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "remove_constants_rec" 1) (("2" (expand "remove_constants_rec" -2) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (inst -3 "l2" "l3") (("1" (split -3) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -1 "cons(cons1_var, l2)" "cons(cons1_var, l3)") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((< const-decl "bool" reals nil) (eval_atm const-decl "bool" dnf_polynomials nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list_induction formula-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil)) nil) (when_not_none-6 nil 3772803574 ("" (induct "l1") (("1" (grind) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "remove_constants_rec" 1) (("2" (expand "remove_constants_rec" -2) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (inst -3 "l2" "l3") (("1" (split -3) (("1" (propax) nil) ("2" (propax) nil))))))) ("2" (assert) nil))))) ("2" (assert) (("2" (inst -1 "cons(cons1_var, l2)" "cons(cons1_var, l3)") (("2" (split -1) (("1" (propax) nil) ("2" (propax) nil)))))))))))))))))) nil) nil nil) (when_not_none-5 nil 3772803547 ("" (induct "l1") (("1" (grind) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "remove_constants_rec" 1) (("2" (expand "remove_constants_rec" -2) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (inst -3 "l2" "l3") (("1" (split -3) (("1" (propax) nil) ("2" (propax) nil))))))) ("2" (assert) nil))))) ("2" (assert) (("2" (inst -1 "cons(cons1_var, l2)" "cons(cons1_var, l3)") (("2" (split -1) (("1" (propax) nil) ("2" (propax) nil)))))))))))))))))) nil) nil nil) (when_not_none-4 nil 3772793259 ("" (induct "l1") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "remove_constants_rec" 1) (("2" (expand "remove_constants_rec" -2) (("2" (case "degr_rec(cons1_var`pn, cons1_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (inst -3 "l2" "l3") (("1" (split -3) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -1 "cons(cons1_var, l2)" "cons(cons1_var, l3)") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_atm const-decl "bool" dnf_polynomials nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list_induction formula-decl nil list_adt nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (list type-decl nil list_adt nil)) nil) (when_not_none-3 nil 3772793236 ("" (induct "l1") (("1" (grind) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "remove_constants_rec" 1) (("2" (expand "remove_constants_rec" -2) (("2" (case "degr_rec(cons1_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (inst -3 "l2" "l3") (("1" (split -3) (("1" (propax) nil) ("2" (propax) nil))))))) ("2" (assert) nil))))) ("2" (assert) (("2" (inst -1 "cons(cons1_var, l2)" "cons(cons1_var, l3)") (("2" (split -1) (("1" (propax) nil) ("2" (propax) nil)))))))))))))))))) nil) nil nil) (when_not_none-2 nil 3772790781 ("" (induct "l1") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "remove_constants_rec" 1) (("2" (expand "remove_constants_rec" -2) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (inst -3 "l2" "l3") (("1" (split -3) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -1 "cons(cons1_var, l2)" "cons(cons1_var, l3)") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (list_induction formula-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (eval_atm const-decl "bool" dnf_polynomials nil)) nil) (when_not_none-1 nil 3770638874 ("" (induct "l1") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "remove_constants_rec" 1) (("2" (expand "remove_constants_rec" -2) (("2" (assert) (("2" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((deg const-decl "{d: below(length(pl)) |
   (d > 0 IFF EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0) AND
    (d > 0 IMPLIES
      (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
     AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist Sturm) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (eval_atm const-decl "bool" dnf_polynomials nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (list_induction formula-decl nil list_adt nil) (Polylist type-eq-decl nil polylist Sturm) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (list type-decl nil list_adt nil)) shostak)) (relation_remove_constants_rec 0 (relation_remove_constants_rec-5 nil 3772803696 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" 1) (("2" (case "cons1_var`d < 1") (("1" (ground) (("1" (case "eval_atm(cons1_var)(0)") (("1" (ground) (("1" (inst? -3) (("1" (split -3) (("1" (propax) nil nil) ("2" (assert) (("2" (hide 2) (("2" (expand "remove_constants_rec" -4) (("2" (hide -1 -2 -3) (("2" (lemma when_not_none) (("2" (inst?) (("2" (inst -1 "l2") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (hide -1 -2 -3) (("3" (expand "remove_constants_rec" -1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (expand "remove_constants_rec" -4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (case "cons(cons1_var, append(l2, (: a :))) = append(cons(cons1_var, l2), (: a :))") (("1" (replace -1 2) (("1" (hide -1) (("1" (inst?) (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2 3) (("2" (expand "remove_constants_rec" -2) (("2" (hide -1) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, l2)" "append(cons(cons1_var, l2), (: a :))") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (hide -1) (("3" (expand "remove_constants_rec" -1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (< const-decl "bool" reals nil) (eval_atm const-decl "bool" dnf_polynomials nil) (when_not_none formula-decl nil dnf_strategy nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (list_induction formula-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (append def-decl "list[T]" list_props nil) (remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil)) nil) (relation_remove_constants_rec-4 nil 3772793691 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" 1) (("2" (case "degr_rec(cons1_var`pn, cons1_var`d) < 1") (("1" (ground) (("1" (case "eval_atm(cons1_var)(0)") (("1" (ground) (("1" (inst? -3) (("1" (split -3) (("1" (propax) nil nil) ("2" (assert) (("2" (hide 2) (("2" (expand "remove_constants_rec" -4) (("2" (hide -1 -2 -3) (("2" (lemma when_not_none) (("2" (inst?) (("2" (inst -1 "l2") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (hide -1 -2 -3) (("3" (expand "remove_constants_rec" -1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (expand "remove_constants_rec" -4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (case "cons(cons1_var, append(l2, (: a :))) = append(cons(cons1_var, l2), (: a :))") (("1" (replace -1 2) (("1" (hide -1) (("1" (inst?) (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2 3) (("2" (expand "remove_constants_rec" -2) (("2" (hide -1) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, l2)" "append(cons(cons1_var, l2), (: a :))") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (hide -1) (("3" (expand "remove_constants_rec" -1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_atm const-decl "bool" dnf_polynomials nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (list_induction formula-decl nil list_adt nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (list type-decl nil list_adt nil)) nil) (relation_remove_constants_rec-3 nil 3772790964 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" 1) (("2" (case "cons1_var`d < 1") (("1" (ground) (("1" (case "eval_atm(cons1_var)(0)") (("1" (ground) (("1" (inst? -3) (("1" (split -3) (("1" (propax) nil nil) ("2" (assert) (("2" (hide 2) (("2" (expand "remove_constants_rec" -4) (("2" (hide -1 -2 -3) (("2" (lemma when_not_none) (("2" (inst?) (("2" (inst -1 "l2") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (hide -1 -2 -3) (("3" (expand "remove_constants_rec" -1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (expand "remove_constants_rec" -4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (case "cons(cons1_var, append(l2, (: a :))) = append(cons(cons1_var, l2), (: a :))") (("1" (replace -1 2) (("1" (hide -1) (("1" (inst?) (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2 3) (("2" (expand "remove_constants_rec" -2) (("2" (hide -1) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, l2)" "append(cons(cons1_var, l2), (: a :))") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (hide -1) (("3" (expand "remove_constants_rec" -1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (list_induction formula-decl nil list_adt nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (eval_atm const-decl "bool" dnf_polynomials nil)) nil) (relation_remove_constants_rec-2 nil 3770641182 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" 1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (ground) (("1" (case "eval_atm(cons1_var)(0)") (("1" (ground) (("1" (inst? -3) (("1" (split -3) (("1" (propax) nil nil) ("2" (assert) (("2" (hide 2) (("2" (expand "remove_constants_rec" -4) (("2" (hide -1 -2 -3) (("2" (lemma when_not_none) (("2" (inst?) (("2" (inst -1 "l2") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (hide -1 -2 -3) (("3" (expand "remove_constants_rec" -1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (expand "remove_constants_rec" -4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (case "cons(cons1_var, append(l2, (: a :))) = append(cons(cons1_var, l2), (: a :))") (("1" (replace -1 2) (("1" (hide -1) (("1" (inst?) (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2 3) (("2" (expand "remove_constants_rec" -2) (("2" (hide -1) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, l2)" "append(cons(cons1_var, l2), (: a :))") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (hide -1) (("3" (expand "remove_constants_rec" -1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((deg const-decl "{d: below(length(pl)) |
   (d > 0 IFF EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0) AND
    (d > 0 IMPLIES
      (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
     AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist Sturm) (eval_atm const-decl "bool" dnf_polynomials nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (list_induction formula-decl nil list_adt nil) (Polylist type-eq-decl nil polylist Sturm) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (list type-decl nil list_adt nil)) nil) (relation_remove_constants_rec-1 nil 3770640283 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "remove_constants_rec" 1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (ground) (("1" (case "eval_atm(cons1_var)(0)") (("1" (ground) (("1" (inst -3 "a") (("1" (split -3) (("1" (propax) nil nil) ("2" (expand "remove_constants_rec" -4) (("2" (hide -1 -2 -3) (("2" (hide 2) (("2" (lemma when_not_none) (("2" (inst?) (("2" (inst -1 "null") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "remove_constants_rec" -4) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (expand "remove_constants_rec" -4) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (remove_constants_TCC1 0 (remove_constants_TCC1-13 "" 3790099609 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" -2) (("2" (split 1) (("1" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (flatten -2) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (split -1) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (lemma relation_remove_constants_rec) (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null[DNF_Atom])") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "i < length(val(remove_constants_rec(cons2_var, null))) + 1") (("1" (hide -2) (("1" (case " i = length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (replace -1 2) (("1" (hide -2 -3) (("1" (case " nth[DNF_Atom]
                                                                                                                                                  (append(val(remove_constants_rec(cons2_var, null)),
                                                                                                                                                          (: cons1_var :)),
                                                                                                                                                   length(val(remove_constants_rec(cons2_var, null)))) = cons1_var") (("1" (assert) nil nil) ("2" (hide 2 3) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) (("1" (replace -1 1) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i <length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (case "nth(append(val(remove_constants_rec(cons2_var, null)),
                                                                                                                                                                      (: cons1_var :)), i) =
                                                                                                                                                              nth(val(remove_constants_rec(cons2_var, null)), i)") (("1" (replace -1 3) (("1" (hide -1) (("1" (inst -2 "i") (("1" (flatten -2) nil nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (hide -2) (("2" (hide 2 3 4) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) nil nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -2 -3) (("2" (hide 2 3) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) (("2" (replace -1 -2) (("2" (hide -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -1 -2) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3 -1 -2) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("3" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null[DNF_Atom])" "null[DNF_Atom]") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (expand "remove_constants_rec" 1) (("1" (flatten -2) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null[DNF_Atom])" "null[DNF_Atom]") (("2" (split -1) (("1" (assert) (("1" (typepred "i") (("1" (lemma "relation_remove_constants_rec") (("1" (expand "remove_constants_rec" 2) (("1" (case "cons(cons1_var, null[DNF_Atom]) = (: cons1_var :)") (("1" (replaces -1) (("1" (inst -1 "cons2_var" "null[DNF_Atom]" "cons1_var") (("1" (split -1) (("1" (case "append(null[DNF_Atom], (: cons1_var :)) = (: cons1_var :)") (("1" (replace -1 -2) (("1" (replaces -2) (("1" (hide -1) (("1" (expand "remove_constants_rec" -1) (("1" (reveal -4 -2 -1) (("1" (replace -3 -4) (("1" (replace -2 -4) (("1" (hide -2 -3) (("1" (case "i < length(val(remove_constants_rec(cons2_var, null[DNF_Atom]))) + 1") (("1" (case "i < length(val(remove_constants_rec(cons2_var, null[DNF_Atom])))") (("1" (inst -7 "i") (("1" (flatten -7) (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst -1 "val(remove_constants_rec(cons2_var, null[DNF_Atom]))" "(: cons1_var :)" "i") (("1" (split -1) (("1" (assert) nil nil) ("2" (hide 2 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i = length(val(remove_constants_rec(cons2_var, null[DNF_Atom])))") (("1" (assert) (("1" (replace -1 -6) (("1" (hide -7) (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst -1 "val(remove_constants_rec(cons2_var, null[DNF_Atom]))" "(: cons1_var :)" "i") (("1" (split -1) (("1" (assert) (("1" (case "nth(append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                                                                                                        (: cons1_var :)),
                                                                                                 i) =  cons1_var ") (("1" (hide -2) (("1" (case "(nth[DNF_Atom]
                                                                                                        (append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                                                                                                                (: cons1_var :)),
                                                                                                         i)`pn)
                                                                                                       (nth[DNF_Atom]
                                                                                                            (append(val(remove_constants_rec(cons2_var,
                                                                                                                                             null[DNF_Atom])),
                                                                                                                    (: cons1_var :)),
                                                                                                             i)`d)
                                                                                                    = 0") (("1" (hide -8) (("1" (replaces -2) (("1" (hide -4) (("1" (hide -4) (("1" (hide -2 -3) (("1" (reveal -1) (("1" (typepred "cons1_var`d") (("1" (typepred "cons1_var") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -5 -6) (("2" (hide 2 3) (("2" (hide -1 -2 -4) (("2" (reveal -3) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -7) (("2" (hide -2 -3 -4 -5 -6) (("2" (hide -2) (("2" (reveal -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -5 -6 3) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1 -3 2) (("2" (hide -2 -3 -4) (("2" (grind) (("2" (case "length(append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                                                                                          (: cons1_var :))) = length(val(remove_constants_rec(cons2_var, null[DNF_Atom]))) + length((: cons1_var :))") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -3 -4) (("2" (expand "append" 1) (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (when_not_none formula-decl nil dnf_strategy nil) (= const-decl "[T, T -> boolean]" equalities nil) (append def-decl "list[T]" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nth_append formula-decl nil more_list_props structures) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_singleton formula-decl nil more_list_props structures) (length_append formula-decl nil list_props nil) (relation_remove_constants_rec formula-decl nil dnf_strategy nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons1_var skolem-const-decl "DNF_Atom" dnf_strategy nil) (cons2_var skolem-const-decl "list[DNF_Atom]" dnf_strategy nil) (i skolem-const-decl "below(length(val(remove_constants_rec(cons(cons1_var, cons2_var), null))))" dnf_strategy nil) (eval_atm const-decl "bool" dnf_polynomials nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (NOT const-decl "[bool -> bool]" booleans nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list_induction formula-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil)) shostak (remove_constants subtype "dnf_strategy.remove_constants_rec(dnf_strategy.l, list_adt[DNF_Atom].null)" "{m: Maybe[list[DNF_Atom]].Maybe | booleans.IMPLIES(Maybe[list[DNF_Atom]].some?(m), FORALL (i: naturalnumbers.below(list_props[DNF_Atom].length(Maybe[list[DNF_Atom]].val(m)))): booleans.AND(reals.>=((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d, 1), ((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`pn)((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d) /= 0))}")) (remove_constants_TCC1-12 nil 3772803778 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" -2) (("2" (split 1) (("1" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (flatten -2) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (split -1) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (lemma relation_remove_constants_rec) (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null[DNF_Atom])") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "i < length(val(remove_constants_rec(cons2_var, null))) + 1") (("1" (hide -2) (("1" (case " i = length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (replace -1 2) (("1" (hide -2 -3) (("1" (case " nth[DNF_Atom]
                                                                                                                                                  (append(val(remove_constants_rec(cons2_var, null)),
                                                                                                                                                          (: cons1_var :)),
                                                                                                                                                   length(val(remove_constants_rec(cons2_var, null)))) = cons1_var") (("1" (assert) nil nil) ("2" (hide 2 3) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) (("1" (replace -1 1) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i <length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (case "nth(append(val(remove_constants_rec(cons2_var, null)),
                                                                                                                                                                      (: cons1_var :)), i) =
                                                                                                                                                              nth(val(remove_constants_rec(cons2_var, null)), i)") (("1" (replace -1 3) (("1" (hide -1) (("1" (inst -2 "i") (("1" (flatten -2) nil nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (hide -2) (("2" (hide 2 3 4) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) nil nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -2 -3) (("2" (hide 2 3) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) (("2" (replace -1 -2) (("2" (hide -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -1 -2) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3 -1 -2) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("3" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null[DNF_Atom])" "null[DNF_Atom]") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (expand "remove_constants_rec" 1) (("1" (flatten -2) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null[DNF_Atom])" "null[DNF_Atom]") (("2" (split -1) (("1" (assert) (("1" (typepred "i") (("1" (lemma "relation_remove_constants_rec") (("1" (expand "remove_constants_rec" 2) (("1" (case "cons(cons1_var, null[DNF_Atom]) = (: cons1_var :)") (("1" (replaces -1) (("1" (inst -1 "cons2_var" "null[DNF_Atom]" "cons1_var") (("1" (split -1) (("1" (replaces -1) (("1" (case "append(null[DNF_Atom], (: cons1_var :)) = (: cons1_var :)") (("1" (replace -1 -2) (("1" (replaces -2) (("1" (hide -1) (("1" (expand "remove_constants_rec" -1) (("1" (reveal -4 -2 -1) (("1" (replace -3 -4) (("1" (replace -2 -4) (("1" (hide -2 -3) (("1" (case "i < length(val(remove_constants_rec(cons2_var, null[DNF_Atom]))) + 1") (("1" (case "i < length(val(remove_constants_rec(cons2_var, null[DNF_Atom])))") (("1" (inst -7 "i") (("1" (flatten -7) (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst -1 "val(remove_constants_rec(cons2_var, null[DNF_Atom]))" "(: cons1_var :)" "i") (("1" (split -1) (("1" (assert) nil nil) ("2" (hide 2 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i = length(val(remove_constants_rec(cons2_var, null[DNF_Atom])))") (("1" (assert) (("1" (replace -1 -6) (("1" (hide -7) (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst -1 "val(remove_constants_rec(cons2_var, null[DNF_Atom]))" "(: cons1_var :)" "i") (("1" (split -1) (("1" (assert) (("1" (case "nth(append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                                                                                                        (: cons1_var :)),
                                                                                                 i) =  cons1_var ") (("1" (hide -2) (("1" (replaces -1) (("1" (case "(nth[DNF_Atom]
                                                                                                        (append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                                                                                                                (: cons1_var :)),
                                                                                                         i)`pn)
                                                                                                       (nth[DNF_Atom]
                                                                                                            (append(val(remove_constants_rec(cons2_var,
                                                                                                                                             null[DNF_Atom])),
                                                                                                                    (: cons1_var :)),
                                                                                                             i)`d)
                                                                                                    = 0") (("1" (hide -8) (("1" (replaces -2) (("1" (hide -4) (("1" (hide -4) (("1" (hide -2 -3) (("1" (reveal -1) (("1" (typepred "cons1_var`d") (("1" (typepred "cons1_var") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -5 -6) (("2" (hide 2 3) (("2" (hide -1 -2 -4) (("2" (reveal -3) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -7) (("2" (hide -2 -3 -4 -5 -6) (("2" (hide -2) (("2" (reveal -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -5 -6 3) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1 -3 2) (("2" (hide -2 -3 -4) (("2" (grind) (("2" (case "length(append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                                                                                          (: cons1_var :))) = length(val(remove_constants_rec(cons2_var, null[DNF_Atom]))) + length((: cons1_var :))") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -3 -4) (("2" (expand "append" 1) (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (when_not_none formula-decl nil dnf_strategy nil) (= const-decl "[T, T -> boolean]" equalities nil) (append def-decl "list[T]" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nth_append formula-decl nil more_list_props structures) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_singleton formula-decl nil more_list_props structures) (length_append formula-decl nil list_props nil) (relation_remove_constants_rec formula-decl nil dnf_strategy nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) nil nil nil (eval_atm const-decl "bool" dnf_polynomials nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (NOT const-decl "[bool -> bool]" booleans nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list_induction formula-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil)) nil (remove_constants subtype "dnf_strategy.remove_constants_rec(dnf_strategy.l, list_adt[DNF_Atom].null)" "{m: Maybe[list[DNF_Atom]].Maybe | booleans.IMPLIES(Maybe[list[DNF_Atom]].some?(m), FORALL (i: naturalnumbers.below(list_props[DNF_Atom].length(Maybe[list[DNF_Atom]].val(m)))): booleans.AND(reals.>=((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d, 1), ((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`pn)((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d) /= 0))}")) (remove_constants_TCC1-11 nil 3772803709 ("" (induct "l") (("1" (grind) nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" -2) (("2" (split 1) (("1" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (flatten -2) nil))))))))))) ("2" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (split -1) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (lemma relation_remove_constants_rec) (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null[DNF_Atom])") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "i < length(val(remove_constants_rec(cons2_var, null))) + 1") (("1" (hide -2) (("1" (case " i = length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (replace -1 2) (("1" (hide -2 -3) (("1" (case " nth[DNF_Atom]
                                                                                                                           (append(val(remove_constants_rec(cons2_var, null)),
                                                                                                                                   (: cons1_var :)),
                                                                                                                            length(val(remove_constants_rec(cons2_var, null)))) = cons1_var") (("1" (assert) nil) ("2" (hide 2 3) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) (("1" (replace -1 1) (("1" (expand "nth" 1) (("1" (propax) nil))))))) ("2" (hide 2) (("2" (grind) nil))))))))))))))))))) ("2" (case "i <length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (case "nth(append(val(remove_constants_rec(cons2_var, null)),
                                                                                                                                             (: cons1_var :)), i) =
                                                                                                                                     nth(val(remove_constants_rec(cons2_var, null)), i)") (("1" (replace -1 3) (("1" (hide -1) (("1" (inst -2 "i") (("1" (flatten -2) nil))))))) ("2" (hide -2) (("2" (hide -2) (("2" (hide 2 3 4) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) nil) ("2" (hide 2) (("2" (assert) nil))))))))))))))) ("3" (propax) nil))))) ("2" (assert) nil))))))) ("2" (hide -2 -3) (("2" (hide 2 3) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) (("2" (replace -1 -2) (("2" (hide -1) (("2" (grind) nil))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))) ("2" (hide 2 3) (("2" (hide -1 -2) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("2" (split -1) (("1" (propax) nil) ("2" (propax) nil))))))))))))) ("3" (hide 2 3 -1 -2) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("3" (split -1) (("1" (propax) nil) ("2" (propax) nil))))))))))))))))))))) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null[DNF_Atom])" "null[DNF_Atom]") (("2" (split -1) (("1" (propax) nil) ("2" (propax) nil))))))))))))))))) ("2" (case " degr_rec(cons1_var`pn, cons1_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (expand "remove_constants_rec" 1) (("1" (flatten -2) nil))))))))) ("2" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null[DNF_Atom])" "null[DNF_Atom]") (("2" (split -1) (("1" (assert) (("1" (typepred "i") (("1" (lemma "relation_remove_constants_rec") (("1" (expand "remove_constants_rec" 2) (("1" (case "cons(cons1_var, null[DNF_Atom]) = (: cons1_var :)") (("1" (replaces -1) (("1" (inst -1 "cons2_var" "null[DNF_Atom]" "cons1_var") (("1" (split -1) (("1" (replaces -1) (("1" (case "append(null[DNF_Atom], (: cons1_var :)) = (: cons1_var :)") (("1" (replace -1 -2) (("1" (replaces -2) (("1" (hide -1) (("1" (expand "remove_constants_rec" -1) (("1" (reveal -4 -2 -1) (("1" (replace -3 -4) (("1" (replace -2 -4) (("1" (hide -2 -3) (("1" (case "i < length(val(remove_constants_rec(cons2_var, null[DNF_Atom]))) + 1") (("1" (case "i < length(val(remove_constants_rec(cons2_var, null[DNF_Atom])))") (("1" (inst -7 "i") (("1" (flatten -7) (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst -1 "val(remove_constants_rec(cons2_var, null[DNF_Atom]))" "(: cons1_var :)" "i") (("1" (split -1) (("1" (assert) nil) ("2" (hide 2 3) (("2" (assert) nil))))))))))))) ("2" (case "i = length(val(remove_constants_rec(cons2_var, null[DNF_Atom])))") (("1" (assert) (("1" (replace -1 -6) (("1" (hide -7) (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst -1 "val(remove_constants_rec(cons2_var, null[DNF_Atom]))" "(: cons1_var :)" "i") (("1" (split -1) (("1" (assert) (("1" (case "nth(append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                                                                           (: cons1_var :)),
                                                                    i) =  cons1_var ") (("1" (hide -2) (("1" (replaces -1) (("1" (case "(nth[DNF_Atom]
                                                                         (append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                                                                                 (: cons1_var :)),
                                                                          i)`pn)
                                                                        (nth[DNF_Atom]
                                                                             (append(val(remove_constants_rec(cons2_var,
                                                                                                              null[DNF_Atom])),
                                                                                     (: cons1_var :)),
                                                                              i)`d)
                                                                     = 0") (("1" (hide -8) (("1" (replaces -2) (("1" (hide -4) (("1" (hide -4) (("1" (hide -2 -3) (("1" (expand "degr_rec") (("1" (postpone) nil))))))))))))) ("2" (hide -2 -3 -5 -6) (("2" (hide 2 3) (("2" (hide -1 -2 -4) (("2" (reveal -3) (("2" (ground) nil))))))))))))))) ("2" (hide 2 3) (("2" (hide -7) (("2" (hide -2 -3 -4 -5 -6) (("2" (hide -2) (("2" (reveal -2) (("2" (grind) nil))))))))))))))) ("2" (assert) nil))))))))))))) ("2" (hide -2 -3 -4 -5 -6 3) (("2" (assert) nil))))))) ("2" (hide -1 -3 2) (("2" (hide -2 -3 -4) (("2" (grind) (("2" (case "length(append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                                                                   (: cons1_var :))) = length(val(remove_constants_rec(cons2_var, null[DNF_Atom]))) + length((: cons1_var :))") (("1" (assert) nil) ("2" (hide -1 2) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) nil))))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))))) ("2" (hide 2) (("2" (hide -3 -4) (("2" (expand "append" 1) (("2" (propax) nil))))))) ("3" (propax) nil))))))) ("2" (propax) nil))))))))))) ("2" (propax) nil)))))))))))))))))) nil) nil nil (remove_constants subtype "dnf_strategy.remove_constants_rec(dnf_strategy.l, list_adt[DNF_Atom].null)" "{m: Maybe[list[DNF_Atom]].Maybe | booleans.IMPLIES(Maybe[list[DNF_Atom]].some?(m), FORALL (i: naturalnumbers.below(list_props[DNF_Atom].length(Maybe[list[DNF_Atom]].val(m)))): booleans.AND(reals.>=((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d, 1), ((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`pn)((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d) /= 0))}")) (remove_constants_TCC1-10 nil 3772799551 ("" (induct "l") (("1" (grind) nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" -2) (("2" (split 1) (("1" (case " degr_rec(cons1_var`pn, cons1_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (flatten -2) nil))))))))))) ("2" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (split -1) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (lemma relation_remove_constants_rec) (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null[DNF_Atom])") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "i < length(val(remove_constants_rec(cons2_var, null))) + 1") (("1" (hide -2) (("1" (case " i = length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (replace -1 2) (("1" (hide -2 -3) (("1" (case " nth[DNF_Atom]
                                                                                                    (append(val(remove_constants_rec(cons2_var, null)),
                                                                                                            (: cons1_var :)),
                                                                                                     length(val(remove_constants_rec(cons2_var, null)))) = cons1_var") (("1" (assert) nil) ("2" (hide 2 3) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) (("1" (replace -1 1) (("1" (expand "nth" 1) (("1" (propax) nil))))))) ("2" (hide 2) (("2" (grind) nil))))))))))))))))))) ("2" (case "i <length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (case "nth(append(val(remove_constants_rec(cons2_var, null)),
                                                                                                                    (: cons1_var :)), i) =
                                                                                                            nth(val(remove_constants_rec(cons2_var, null)), i)") (("1" (replace -1 3) (("1" (hide -1) (("1" (inst -2 "i") (("1" (flatten -2) nil))))))) ("2" (hide -2) (("2" (hide -2) (("2" (hide 2 3 4) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) nil) ("2" (hide 2) (("2" (assert) nil))))))))))))))) ("3" (propax) nil))))) ("2" (assert) nil))))))) ("2" (hide -2 -3) (("2" (hide 2 3) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) (("2" (replace -1 -2) (("2" (hide -1) (("2" (grind) nil))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))) ("2" (hide 2 3) (("2" (hide -1 -2) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("2" (split -1) (("1" (propax) nil) ("2" (propax) nil))))))))))))) ("3" (hide 2 3 -1 -2) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("3" (split -1) (("1" (propax) nil) ("2" (propax) nil))))))))))))))))))))) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null[DNF_Atom])" "null[DNF_Atom]") (("2" (split -1) (("1" (propax) nil) ("2" (propax) nil))))))))))))))))) ("2" (case " degr_rec(cons1_var`pn, cons1_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (expand "remove_constants_rec" 1) (("1" (flatten -2) nil))))))))) ("2" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null[DNF_Atom])" "null[DNF_Atom]") (("2" (split -1) (("1" (assert) (("1" (typepred "i") (("1" (lemma "relation_remove_constants_rec") (("1" (expand "remove_constants_rec" 2) (("1" (case "cons(cons1_var, null[DNF_Atom]) = (: cons1_var :)") (("1" (replaces -1) (("1" (inst -1 "cons2_var" "null[DNF_Atom]" "cons1_var") (("1" (split -1) (("1" (replaces -1) (("1" (case "append(null[DNF_Atom], (: cons1_var :)) = (: cons1_var :)") (("1" (replace -1 -2) (("1" (replaces -2) (("1" (hide -1) (("1" (expand "remove_constants_rec" -1) (("1" (reveal -4 -2 -1) (("1" (replace -3 -4) (("1" (replace -2 -4) (("1" (hide -2 -3) (("1" (case "i < length(val(remove_constants_rec(cons2_var, null[DNF_Atom]))) + 1") (("1" (case "i < length(val(remove_constants_rec(cons2_var, null[DNF_Atom])))") (("1" (inst -7 "i") (("1" (flatten -7) (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst -1 "val(remove_constants_rec(cons2_var, null[DNF_Atom]))" "(: cons1_var :)" "i") (("1" (split -1) (("1" (assert) nil) ("2" (hide 2 3) (("2" (assert) nil))))))))))))) ("2" (case "i = length(val(remove_constants_rec(cons2_var, null[DNF_Atom])))") (("1" (assert) (("1" (replace -1 -6) (("1" (hide -7) (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst -1 "val(remove_constants_rec(cons2_var, null[DNF_Atom]))" "(: cons1_var :)" "i") (("1" (split -1) (("1" (assert) (("1" (case "nth(append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                                              (: cons1_var :)),
                                       i) =  cons1_var ") (("1" (hide -2) (("1" (replaces -1) (("1" (case "(nth[DNF_Atom]
                                          (append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                                                  (: cons1_var :)),
                                           i)`pn)
                                         (nth[DNF_Atom]
                                              (append(val(remove_constants_rec(cons2_var,
                                                                               null[DNF_Atom])),
                                                      (: cons1_var :)),
                                               i)`d)
                                      = 0") (("1" (hide -8) (("1" (replaces -2) (("1" (hide -4) (("1" (hide -4) (("1" (hide -2 -3) (("1" (expand "degr_rec") (("1" (postpone) nil))))))))))))) ("2" (hide -2 -3 -5 -6) (("2" (hide 2 3) (("2" (hide -1 -2 -4) (("2" (reveal -3) (("2" (ground) nil))))))))))))))) ("2" (hide 2 3) (("2" (hide -7) (("2" (hide -2 -3 -4 -5 -6) (("2" (hide -2) (("2" (reveal -2) (("2" (grind) nil))))))))))))))) ("2" (assert) nil))))))))))))) ("2" (hide -2 -3 -4 -5 -6 3) (("2" (assert) nil))))))) ("2" (hide -1 -3 2) (("2" (hide -2 -3 -4) (("2" (grind) (("2" (case "length(append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                                            (: cons1_var :))) = length(val(remove_constants_rec(cons2_var, null[DNF_Atom]))) + length((: cons1_var :))") (("1" (assert) nil) ("2" (hide -1 2) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) nil))))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))))) ("2" (hide 2) (("2" (hide -3 -4) (("2" (expand "append" 1) (("2" (propax) nil))))))) ("3" (propax) nil))))))) ("2" (propax) nil))))))))))) ("2" (propax) nil)))))))))))))))))) nil) nil nil (remove_constants subtype "dnf_strategy.remove_constants_rec(dnf_strategy.l, list_adt[DNF_Atom].null)" "{m: Maybe[list[DNF_Atom]].Maybe | booleans.IMPLIES(Maybe[list[DNF_Atom]].some?(m), FORALL (i: naturalnumbers.below(list_props[DNF_Atom].length(Maybe[list[DNF_Atom]].val(m)))): booleans.AND(reals.>=((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d, 1), ((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`pn)((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d) /= 0))}")) (remove_constants_TCC1-9 nil 3772799399 ("" (induct "l") (("1" (grind) nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" -2) (("2" (split 1) (("1" (case " degr_rec(cons1_var`pn, cons1_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (flatten -2) nil))))))))))) ("2" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (split -1) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (lemma relation_remove_constants_rec) (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null[DNF_Atom])") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "i < length(val(remove_constants_rec(cons2_var, null))) + 1") (("1" (hide -2) (("1" (case " i = length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (replace -1 2) (("1" (hide -2 -3) (("1" (case " nth[DNF_Atom]
                                                                                                    (append(val(remove_constants_rec(cons2_var, null)),
                                                                                                            (: cons1_var :)),
                                                                                                     length(val(remove_constants_rec(cons2_var, null)))) = cons1_var") (("1" (assert) nil) ("2" (hide 2 3) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) (("1" (replace -1 1) (("1" (expand "nth" 1) (("1" (propax) nil))))))) ("2" (hide 2) (("2" (grind) nil))))))))))))))))))) ("2" (case "i <length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (case "nth(append(val(remove_constants_rec(cons2_var, null)),
                                                                                                                    (: cons1_var :)), i) =
                                                                                                            nth(val(remove_constants_rec(cons2_var, null)), i)") (("1" (replace -1 3) (("1" (hide -1) (("1" (inst -2 "i") (("1" (flatten -2) nil))))))) ("2" (hide -2) (("2" (hide -2) (("2" (hide 2 3 4) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) nil) ("2" (hide 2) (("2" (assert) nil))))))))))))))) ("3" (propax) nil))))) ("2" (assert) nil))))))) ("2" (hide -2 -3) (("2" (hide 2 3) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) (("2" (replace -1 -2) (("2" (hide -1) (("2" (grind) nil))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))) ("2" (hide 2 3) (("2" (hide -1 -2) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("2" (split -1) (("1" (propax) nil) ("2" (propax) nil))))))))))))) ("3" (hide 2 3 -1 -2) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("3" (split -1) (("1" (propax) nil) ("2" (propax) nil))))))))))))))))))))) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null[DNF_Atom])" "null[DNF_Atom]") (("2" (split -1) (("1" (propax) nil) ("2" (propax) nil))))))))))))))))) ("2" (case " degr_rec(cons1_var`pn, cons1_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (expand "remove_constants_rec" 1) (("1" (flatten -2) nil))))))))) ("2" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (postpone) nil)))))))))))) nil) nil nil (remove_constants subtype "dnf_strategy.remove_constants_rec(dnf_strategy.l, list_adt[DNF_Atom].null)" "{m: Maybe[list[DNF_Atom]].Maybe | booleans.IMPLIES(Maybe[list[DNF_Atom]].some?(m), FORALL (i: naturalnumbers.below(list_props[DNF_Atom].length(Maybe[list[DNF_Atom]].val(m)))): booleans.AND(reals.>=((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d, 1), ((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`pn)((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d) /= 0))}")) (remove_constants_TCC1-8 nil 3772794065 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" -2) (("2" (split 1) (("1" (case " degr_rec(cons1_var`pn, cons1_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (flatten -2) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (split -1) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (lemma relation_remove_constants_rec) (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null[DNF_Atom])") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "i < length(val(remove_constants_rec(cons2_var, null))) + 1") (("1" (hide -2) (("1" (case " i = length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (replace -1 2) (("1" (hide -2 -3) (("1" (case " nth[DNF_Atom]
                                                                             (append(val(remove_constants_rec(cons2_var, null)),
                                                                                     (: cons1_var :)),
                                                                              length(val(remove_constants_rec(cons2_var, null)))) = cons1_var") (("1" (assert) nil nil) ("2" (hide 2 3) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) (("1" (replace -1 1) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i <length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (case "nth(append(val(remove_constants_rec(cons2_var, null)),
                                                                                           (: cons1_var :)), i) =
                                                                                   nth(val(remove_constants_rec(cons2_var, null)), i)") (("1" (replace -1 3) (("1" (hide -1) (("1" (inst -2 "i") (("1" (flatten -2) nil nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (hide -2) (("2" (hide 2 3 4) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) nil nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -2 -3) (("2" (hide 2 3) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) (("2" (replace -1 -2) (("2" (hide -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -1 -2) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3 -1 -2) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("3" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null[DNF_Atom])" "null[DNF_Atom]") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case " degr_rec(cons1_var`pn, cons1_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (expand "remove_constants_rec" 1) (("1" (flatten -2) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null[DNF_Atom])" "null[DNF_Atom]") (("2" (split -1) (("1" (assert) (("1" (typepred "i") (("1" (lemma "relation_remove_constants_rec") (("1" (expand "remove_constants_rec" 2) (("1" (case "cons(cons1_var, null[DNF_Atom]) = (: cons1_var :)") (("1" (replaces -1) (("1" (inst -1 "cons2_var" "null[DNF_Atom]" "cons1_var") (("1" (split -1) (("1" (replaces -1) (("1" (case "append(null[DNF_Atom], (: cons1_var :)) = (: cons1_var :)") (("1" (replace -1 -2) (("1" (replaces -2) (("1" (hide -1) (("1" (expand "remove_constants_rec" -1) (("1" (reveal -4 -2 -1) (("1" (replace -3 -4) (("1" (replace -2 -4) (("1" (hide -2 -3) (("1" (case "i < length(val(remove_constants_rec(cons2_var, null[DNF_Atom]))) + 1") (("1" (case "i < length(val(remove_constants_rec(cons2_var, null[DNF_Atom])))") (("1" (inst -7 "i") (("1" (flatten -7) (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst -1 "val(remove_constants_rec(cons2_var, null[DNF_Atom]))" "(: cons1_var :)" "i") (("1" (split -1) (("1" (assert) nil nil) ("2" (hide 2 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i = length(val(remove_constants_rec(cons2_var, null[DNF_Atom])))") (("1" (assert) (("1" (replace -1 -6) (("1" (hide -7) (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst -1 "val(remove_constants_rec(cons2_var, null[DNF_Atom]))" "(: cons1_var :)" "i") (("1" (split -1) (("1" (assert) (("1" (case "nth(append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                 (: cons1_var :)),
          i) =  cons1_var ") (("1" (hide -2) (("1" (replaces -1) (("1" (case "(nth[DNF_Atom]
           (append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                   (: cons1_var :)),
            i)`pn)
          (nth[DNF_Atom]
               (append(val(remove_constants_rec(cons2_var,
                                                null[DNF_Atom])),
                       (: cons1_var :)),
                i)`d)
       = 0") (("1" (hide -8) (("1" (replaces -2) (("1" (hide -4) (("1" (hide -4) (("1" (hide -2 -3) (("1" (expand "degr_rec") (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -5 -6) (("2" (hide 2 3) (("2" (hide -1 -2 -4) (("2" (reveal -3) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -7) (("2" (hide -2 -3 -4 -5 -6) (("2" (hide -2) (("2" (reveal -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 -5 -6 3) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1 -3 2) (("2" (hide -2 -3 -4) (("2" (grind) (("2" (case "length(append(val(remove_constants_rec(cons2_var, null[DNF_Atom])),
                     (: cons1_var :))) = length(val(remove_constants_rec(cons2_var, null[DNF_Atom]))) + length((: cons1_var :))") (("1" (assert) nil nil) ("2" (hide -1 2) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -3 -4) (("2" (expand "append" 1) (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (remove_constants subtype "dnf_strategy.remove_constants_rec(dnf_strategy.l, list_adt[DNF_Atom].null)" "{m: Maybe[list[DNF_Atom]].Maybe | booleans.IMPLIES(Maybe[list[DNF_Atom]].some?(m), FORALL (i: naturalnumbers.below(list_props[DNF_Atom].length(Maybe[list[DNF_Atom]].val(m)))): booleans.AND(reals.>=((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d, 1), ((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`pn)((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d) /= 0))}")) (remove_constants_TCC1-7 nil 3772793301 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" -2) (("2" (split 1) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (list_induction formula-decl nil list_adt nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nth_append formula-decl nil more_list_props structures) (length_singleton formula-decl nil more_list_props structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (eval_atm const-decl "bool" dnf_polynomials nil)) nil (remove_constants subtype "dnf_strategy.remove_constants_rec(dnf_strategy.l, list_adt[DNF_Atom].null)" "{m: Maybe[list[DNF_Atom]].Maybe | booleans.IMPLIES(Maybe[list[DNF_Atom]].some?(m), FORALL (i: naturalnumbers.below(list_props[DNF_Atom].length(Maybe[list[DNF_Atom]].val(m)))): booleans.AND(reals.>=((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d, 1), ((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`pn)((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d) /= 0))}")) (remove_constants_TCC1-6 nil 3772791013 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" -2) (("2" (case " cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (split -1) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (lemma relation_remove_constants_rec) (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null[DNF_Atom])") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "i < length(val(remove_constants_rec(cons2_var, null))) + 1") (("1" (hide -2) (("1" (case " i = length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (replace -1 2) (("1" (hide -2 -3) (("1" (case " nth[DNF_Atom]
                                   (append(val(remove_constants_rec(cons2_var, null)),
                                           (: cons1_var :)),
                                    length(val(remove_constants_rec(cons2_var, null)))) = cons1_var") (("1" (assert) nil nil) ("2" (hide 2 3) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) (("1" (replace -1 1) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i <length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (case "nth(append(val(remove_constants_rec(cons2_var, null)),
                                             (: cons1_var :)), i) =
                                     nth(val(remove_constants_rec(cons2_var, null)), i)") (("1" (replace -1 3) (("1" (hide -1) (("1" (inst -2 "i") nil nil)) nil)) nil) ("2" (hide -2) (("2" (hide -2) (("2" (hide 2 3 4) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) nil nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -2 -3) (("2" (hide 2 3) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) (("2" (replace -1 -2) (("2" (hide -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -1 -2) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3 -1 -2) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("3" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null[DNF_Atom])" "null[DNF_Atom]") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (list_induction formula-decl nil list_adt nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (nth_append formula-decl nil more_list_props structures) (length_singleton formula-decl nil more_list_props structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (eval_atm const-decl "bool" dnf_polynomials nil)) nil (remove_constants subtype "dnf_strategy.remove_constants_rec(dnf_strategy.l, list_adt[DNF_Atom].null)" "{m: Maybe[list[DNF_Atom]].Maybe | booleans.IMPLIES(Maybe[list[DNF_Atom]].some?(m), FORALL (i: naturalnumbers.below(list_props[DNF_Atom].length(Maybe[list[DNF_Atom]].val(m)))): booleans.AND(reals.>=((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d, 1), ((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`pn)((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d) /= 0))}")) (remove_constants_TCC1-5 nil 3770638653 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" -2) (("2" (case " deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (split -1) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (lemma relation_remove_constants_rec) (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null[DNF_Atom])") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "i < length(val(remove_constants_rec(cons2_var, null))) + 1") (("1" (hide -2) (("1" (case " i = length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (replace -1 2) (("1" (hide -2 -3) (("1" (case " nth[DNF_Atom]
              (append(val(remove_constants_rec(cons2_var, null)),
                      (: cons1_var :)),
               length(val(remove_constants_rec(cons2_var, null)))) = cons1_var") (("1" (assert) nil nil) ("2" (hide 2 3) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) (("1" (replace -1 1) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i <length(val(remove_constants_rec(cons2_var, null)))") (("1" (hide -2) (("1" (case "nth(append(val(remove_constants_rec(cons2_var, null)),
                      (: cons1_var :)), i) = 
              nth(val(remove_constants_rec(cons2_var, null)), i)") (("1" (replace -1 3) (("1" (hide -1) (("1" (inst -2 "i") nil nil)) nil)) nil) ("2" (hide -2) (("2" (hide -2) (("2" (hide 2 3 4) (("2" (lemma nth_append[DNF_Atom]) (("2" (inst?) (("2" (split -1) (("1" (assert) nil nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -2 -3) (("2" (hide 2 3) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) (("2" (replace -1 -2) (("2" (hide -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -1 -2) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3 -1 -2) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null[DNF_Atom])") (("3" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null[DNF_Atom])" "null[DNF_Atom]") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_atm const-decl "bool" dnf_polynomials nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (length_singleton formula-decl nil more_list_props structures) (nth_append formula-decl nil more_list_props structures) (lt_realorder name-judgement "RealOrder" real_orders reals) (list_induction formula-decl nil list_adt nil) (Polylist type-eq-decl nil polylist Sturm) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (deg const-decl "{d: below(length(pl)) |
   (d > 0 IFF EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0) AND
    (d > 0 IMPLIES
      (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
     AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist Sturm) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (list type-decl nil list_adt nil)) nil (remove_constants subtype "dnf_strategy.remove_constants_rec(dnf_strategy.l, list_adt[DNF_Atom].null)" "{m: Maybe[list[DNF_Atom]].Maybe | booleans.IMPLIES(Maybe[list[DNF_Atom]].some?(m), FORALL (i: naturalnumbers.below(list_props[DNF_Atom].length(Maybe[list[DNF_Atom]].val(m)))): booleans.AND(reals.>=((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d, 1), ((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`pn)((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d) /= 0))}")) (remove_constants_TCC1-4 nil 3770638302 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" -2) (("2" (case " deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (expand "remove_constants_rec" 2) (("2" (case "null?(cons2_var)") (("1" (assert) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (expand "remove_constants_rec" -1) (("1" (case "i = 0") (("1" (replace -1 2) (("1" (hide -2 -4) (("1" (case "nth[DNF_Atom](cons(cons1_var, null[DNF_Atom]), 0) = cons1_var") (("1" (replace -1 2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4 2 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (remove_constants subtype "dnf_strategy.remove_constants_rec(dnf_strategy.l, list_adt[DNF_Atom].null)" "{m: Maybe[list[DNF_Atom]].Maybe | booleans.IMPLIES(Maybe[list[DNF_Atom]].some?(m), FORALL (i: naturalnumbers.below(list_props[DNF_Atom].length(Maybe[list[DNF_Atom]].val(m)))): booleans.AND(reals.>=((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d, 1), ((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`pn)((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d) /= 0))}")) (remove_constants_TCC1-3 nil 3770638232 ("" (induct "l") (("1" (grind) nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" 1) (("2" (assert) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (expand "remove_constants_rec" -1) (("1" (inst -2 "i") (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (propax) nil))))))))))) ("2" (propax) nil))))) ("2" (assert) nil))))) ("2" (postpone) nil)))))))))) nil) nil nil (remove_constants subtype "dnf_strategy.remove_constants_rec(dnf_strategy.l, list_adt[DNF_Atom].null)" "{m: Maybe[list[DNF_Atom]].Maybe | booleans.IMPLIES(Maybe[list[DNF_Atom]].some?(m), FORALL (i: naturalnumbers.below(list_props[DNF_Atom].length(Maybe[list[DNF_Atom]].val(m)))): booleans.AND(reals.>=((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d, 1), ((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`pn)((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d) /= 0))}")) (remove_constants_TCC1-2 nil 3770637432 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep*) (("2" (expand "remove_constants_rec" 1) (("2" (assert) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil nil (remove_constants subtype "dnf_strategy.remove_constants_rec(dnf_strategy.l, list_adt[DNF_Atom].null)" "{m: Maybe[list[DNF_Atom]].Maybe | booleans.IMPLIES(Maybe[list[DNF_Atom]].some?(m), FORALL (i: naturalnumbers.below(list_props[DNF_Atom].length(Maybe[list[DNF_Atom]].val(m)))): booleans.AND(reals.>=((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d, 1), ((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`pn)((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d) /= 0))}")) (remove_constants_TCC1-1 nil 3770629764 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "remove_constants_rec" -2) (("2" (assert) (("2" (case "length(cons1_var`plist) = 1") (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (typepred "i") (("1" (inst -2 "i") nil nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (remove_constants subtype "dnf_strategy.remove_constants_rec(dnf_strategy.l, list_adt[DNF_Atom].null)" "{m: Maybe[list[DNF_Atom]].Maybe | booleans.IMPLIES(Maybe[list[DNF_Atom]].some?(m), FORALL (i: naturalnumbers.below(list_props[DNF_Atom].length(Maybe[list[DNF_Atom]].val(m)))): booleans.AND(reals.>=((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d, 1), ((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`pn)((list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(m), i))`d) /= 0))}"))) (relation_remove_constants_single 0 (relation_remove_constants_single-3 nil 3772803925 ("" (skeep) (("" (expand "remove_constants") (("" (expand "remove_constants_rec") (("" (case " a`d < 1") (("1" (assert) (("1" (case "eval_atm(a)(0)") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (rat nonempty-type-eq-decl nil rationals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (eval_atm const-decl "bool" dnf_polynomials nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil)) nil) (relation_remove_constants_single-2 nil 3772793718 ("" (skeep) (("" (expand "remove_constants") (("" (expand "remove_constants_rec") (("" (case "degr_rec(a`pn, a`d) < 1") (("1" (assert) (("1" (case "eval_atm(a)(0)") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((DNF_Atom type-eq-decl nil dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (eval_atm const-decl "bool" dnf_polynomials nil) (lt_realorder name-judgement "RealOrder" real_orders reals)) nil) (relation_remove_constants_single-1 nil 3770725617 ("" (skeep) (("" (expand "remove_constants") (("" (expand "remove_constants_rec") (("" (case "deg(a`plist) < 1") (("1" (assert) (("1" (case "eval_atm(a)(0)") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((DNF_Atom type-eq-decl nil dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (deg const-decl "{d: below(length(pl)) |
   (d > 0 IFF EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0) AND
    (d > 0 IMPLIES
      (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
     AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist Sturm) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (Polylist type-eq-decl nil polylist Sturm) (eval_atm const-decl "bool" dnf_polynomials nil) (lt_realorder name-judgement "RealOrder" real_orders reals)) shostak)) (relation_remove_constants_null_TCC1 0 (relation_remove_constants_null_TCC1-2 nil 3772803934 ("" (skeep) (("" (expand "remove_constants" 1) (("" (expand "remove_constants_rec" 1) (("" (expand "remove_constants_rec" 1) (("" (assert) (("" (case "a`d < 1") (("1" (assert) (("1" (case " eval_atm(a)(0)") (("1" (assert) nil nil) ("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (rat nonempty-type-eq-decl nil rationals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (eval_atm const-decl "bool" dnf_polynomials nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil)) nil (relation_remove_constants_null subtype "dnf_strategy.remove_constants((: dnf_strategy.a :))" "(Maybe[list[DNF_Atom]].some?)")) (relation_remove_constants_null_TCC1-1 nil 3770726473 ("" (skeep) (("" (expand "remove_constants" 1) (("" (expand "remove_constants_rec" 1) (("" (expand "remove_constants_rec" 1) (("" (assert) (("" (case "degr_rec(a`pn, a`d) < 1") (("1" (assert) (("1" (case " eval_atm(a)(0)") (("1" (assert) nil nil) ("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((DNF_Atom type-eq-decl nil dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (eval_atm const-decl "bool" dnf_polynomials nil) (lt_realorder name-judgement "RealOrder" real_orders reals)) nil (relation_remove_constants_null subtype "dnf_strategy.remove_constants((: dnf_strategy.a :))" "(Maybe[list[DNF_Atom]].some?)"))) (relation_remove_constants_null_TCC2 0 (relation_remove_constants_null_TCC2-1 nil 3772816485 ("" (skeep) (("" (expand "remove_constants") (("" (expand "remove_constants_rec" -1) (("" (case " a`d < 1") (("1" (assert) (("1" (case " eval_atm(a)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "l" "cons(a, null)" "null") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (rat nonempty-type-eq-decl nil rationals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (eval_atm const-decl "bool" dnf_polynomials nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (when_not_none formula-decl nil dnf_strategy nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil)) nil (relation_remove_constants_null subtype "dnf_strategy.remove_constants(dnf_strategy.l)" "(Maybe[list[DNF_Atom]].some?)"))) (relation_remove_constants_null 0 (relation_remove_constants_null-3 nil 3772803952 ("" (skeep*) (("" (expand "remove_constants") (("" (expand "remove_constants_rec" 1) (("" (expand "remove_constants_rec" -2) (("" (case " a`d < 1") (("1" (assert) (("1" (case "eval_atm(a)(0)") (("1" (assert) (("1" (case "null?(l)") (("1" (assert) nil nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (sigma_rat application-judgement "rational" sigma_nat reals) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (sigma def-decl "real" sigma reals) (polynomial const-decl "[real -> real]" polynomials reals) (eval_rel const-decl "bool" dnf_polynomials nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (eval_atm const-decl "bool" dnf_polynomials nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil) (relation_remove_constants_null-2 nil 3772793512 ("" (skeep*) (("" (expand "remove_constants") (("" (expand "remove_constants_rec" 1) (("" (expand "remove_constants_rec" -2) (("" (case "degr_rec(a`pn, a`d) < 1") (("1" (assert) (("1" (case "eval_atm(a)(0)") (("1" (assert) (("1" (case "null?(l)") (("1" (assert) nil nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (sigma def-decl "real" sigma reals) (polynomial const-decl "[real -> real]" polynomials reals) (eval_rel const-decl "bool" dnf_polynomials nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (eval_atm const-decl "bool" dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil)) nil) (relation_remove_constants_null-1 nil 3770726474 ("" (skeep*) (("" (expand "remove_constants") (("" (expand "remove_constants_rec" 1) (("" (expand "remove_constants_rec" -2) (("" (case "deg(a`plist) < 1") (("1" (assert) (("1" (case "eval_atm(a)(0)") (("1" (assert) (("1" (case "null?(l)") (("1" (assert) nil nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((lt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (polylist const-decl "real" polylist Sturm) (eval_rel const-decl "bool" dnf_polynomials nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (eval_atm const-decl "bool" dnf_polynomials nil) (Polylist type-eq-decl nil polylist Sturm) (list type-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (deg const-decl "{d: below(length(pl)) |
   (d > 0 IFF EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0) AND
    (d > 0 IMPLIES
      (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
     AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist Sturm) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil)) shostak)) (relation_remove_constants_TCC1 0 (relation_remove_constants_TCC1-1 nil 3772816485 ("" (skeep) (("" (hide -2) (("" (expand "remove_constants") (("" (expand "remove_constants_rec" -1) (("" (case "a`d < 1") (("1" (assert) (("1" (case " eval_atm(a)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "l" "cons(a, null)" "null") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (when_not_none formula-decl nil dnf_strategy nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (eval_atm const-decl "bool" dnf_polynomials nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil)) nil (relation_remove_constants subtype "dnf_strategy.remove_constants(dnf_strategy.l)" "(Maybe[list[DNF_Atom]].some?)"))) (relation_remove_constants 0 (relation_remove_constants-6 nil 3772804017 ("" (skeep*) (("" (expand "remove_constants" 1) (("" (expand "remove_constants") (("" (expand "remove_constants_rec") (("" (case " a`d < 1") (("1" (assert) (("1" (case "eval_atm(a)(0) ") (("1" (assert) (("1" (expand "remove_constants_rec" -4) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "null?(l)") (("1" (assert) (("1" (case "l = null") (("1" (replace -1 2) (("1" (expand "remove_constants_rec") (("1" (hide-all-but 2) (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma relation_remove_constants_rec) (("2" (inst -1 "l" "null" "a") (("2" (split -1) (("1" (assert) (("1" (case "val(remove_constants_rec(l, append(null, (: a :)))) =append(IF car(l)`d < 1
                                                                                 THEN IF eval_atm(car(l))(0)
                                                                                        THEN val(remove_constants_rec(cdr(l), null))
                                                                                      ELSE val(None)
                                                                                      ENDIF
                                                                               ELSE val(remove_constants_rec(cdr(l), cons(car(l), null)))
                                                                               ENDIF,
                                                                               (: a :))") (("1" (grind) nil nil) ("2" (hide 2 3 4) (("2" (grind) nil nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (assert) (("3" (hide -2 2 3 4) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(a, null)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil) (remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil) (when_not_none formula-decl nil dnf_strategy nil) (sigma_rat application-judgement "rational" sigma_nat reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (eval_rel const-decl "bool" dnf_polynomials nil) (polynomial const-decl "[real -> real]" polynomials reals) (sigma def-decl "real" sigma reals) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (None adt-constructor-decl "(none?)" Maybe structures) (relation_remove_constants_rec formula-decl nil dnf_strategy nil) (append def-decl "list[T]" list_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (eval_atm const-decl "bool" dnf_polynomials nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil) (relation_remove_constants-5 nil 3772803976 ("" (skeep*) (("" (expand "remove_constants" 1) (("" (expand "remove_constants") (("" (expand "remove_constants_rec") (("" (case " a`d < 1") (("1" (assert) (("1" (case "eval_atm(a)(0) ") (("1" (assert) (("1" (expand "remove_constants_rec" -4) (("1" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (case "null?(l)") (("1" (assert) (("1" (case "l = null") (("1" (replace -1 2) (("1" (expand "remove_constants_rec") (("1" (hide-all-but 2) (("1" (expand "append") (("1" (propax) nil))))))))) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma relation_remove_constants_rec) (("2" (inst -1 "l" "null" "a") (("2" (split -1) (("1" (assert) (("1" (case "val(remove_constants_rec(l, append(null, (: a :)))) =append(IF degr_rec(car(l)`pn, car(l)`d) < 1
                                                                    THEN IF eval_atm(car(l))(0)
                                                                           THEN val(remove_constants_rec(cdr(l), null))
                                                                         ELSE val(None)
                                                                         ENDIF
                                                                  ELSE val(remove_constants_rec(cdr(l), cons(car(l), null)))
                                                                  ENDIF,
                                                                  (: a :))") (("1" (grind) nil) ("2" (hide 2 3 4) (("2" (grind) nil))) ("3" (grind) nil) ("4" (grind) nil) ("5" (grind) nil))))) ("2" (grind) nil) ("3" (assert) (("3" (hide -2 2 3 4) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(a, null)") (("3" (assert) nil)))))))))))))))))))))))))))))))) nil) nil nil) (relation_remove_constants-4 nil 3772795018 ("" (skeep*) (("" (expand "remove_constants" 1) (("" (expand "remove_constants") (("" (expand "remove_constants_rec") (("" (case "degr_rec(a`pn, a`d) < 1") (("1" (assert) (("1" (case "eval_atm(a)(0) ") (("1" (assert) (("1" (expand "remove_constants_rec" -4) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "null?(l)") (("1" (assert) (("1" (case "l = null") (("1" (replace -1 2) (("1" (expand "remove_constants_rec") (("1" (hide-all-but 2) (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma relation_remove_constants_rec) (("2" (inst -1 "l" "null" "a") (("2" (split -1) (("1" (assert) (("1" (case "val(remove_constants_rec(l, append(null, (: a :)))) =append(IF degr_rec(car(l)`pn, car(l)`d) < 1
                                                       THEN IF eval_atm(car(l))(0)
                                                              THEN val(remove_constants_rec(cdr(l), null))
                                                            ELSE val(None)
                                                            ENDIF
                                                     ELSE val(remove_constants_rec(cdr(l), cons(car(l), null)))
                                                     ENDIF,
                                                     (: a :))") (("1" (grind) nil nil) ("2" (hide 2 3 4) (("2" (grind) nil nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (assert) (("3" (hide -2 2 3 4) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(a, null)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (eval_rel const-decl "bool" dnf_polynomials nil) (polynomial const-decl "[real -> real]" polynomials reals) (sigma def-decl "real" sigma reals) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (None adt-constructor-decl "(none?)" Maybe structures) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (eval_atm const-decl "bool" dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil)) nil) (relation_remove_constants-3 nil 3772794958 ("" (skeep*) (("" (expand "remove_constants" 1) (("" (expand "remove_constants") (("" (expand "remove_constants_rec") (("" (case "degr_rec(a`pn, a`d) < 1") (("1" (assert) (("1" (case "eval_atm(a)(0) ") (("1" (assert) (("1" (expand "remove_constants_rec" -4) (("1" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (case "null?(l)") (("1" (assert) (("1" (case "l = null") (("1" (replace -1 2) (("1" (expand "remove_constants_rec") (("1" (hide-all-but 2) (("1" (expand "append") (("1" (propax) nil))))))))) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma relation_remove_constants_rec) (("2" (inst -1 "l" "null" "a") (("2" (split -1) (("1" (assert) (("1" (case "val(remove_constants_rec(l, append(null, (: a :)))) =append(IF deg(car(l)`plist) < 1
                                          THEN IF eval_atm(car(l))(0)
                                                 THEN val(remove_constants_rec(cdr(l), null))
                                               ELSE val(None)
                                               ENDIF
                                        ELSE val(remove_constants_rec(cdr(l), cons(car(l), null)))
                                        ENDIF,
                                        (: a :))") (("1" (grind) nil) ("2" (hide 2 3 4) (("2" (grind) nil))) ("3" (grind) nil) ("4" (grind) nil) ("5" (grind) nil))))) ("2" (grind) nil) ("3" (assert) (("3" (hide -2 2 3 4) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(a, null)") (("3" (assert) nil)))))))))))))))))))))))))))))))) nil) nil nil) (relation_remove_constants-2 nil 3772790863 ("" (skeep*) (("" (expand "remove_constants" 1) (("" (expand "remove_constants") (("" (expand "remove_constants_rec") (("" (case "a`d < 1") (("1" (assert) (("1" (case "eval_atm(a)(0) ") (("1" (assert) (("1" (expand "remove_constants_rec" -4) (("1" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (case "null?(l)") (("1" (assert) (("1" (case "l = null") (("1" (replace -1 2) (("1" (expand "remove_constants_rec") (("1" (hide-all-but 2) (("1" (expand "append") (("1" (propax) nil))))))))) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma relation_remove_constants_rec) (("2" (inst -1 "l" "null" "a") (("2" (split -1) (("1" (assert) (("1" (case "val(remove_constants_rec(l, append(null, (: a :)))) =append(IF deg(car(l)`plist) < 1
                             THEN IF eval_atm(car(l))(0)
                                    THEN val(remove_constants_rec(cdr(l), null))
                                  ELSE val(None)
                                  ENDIF
                           ELSE val(remove_constants_rec(cdr(l), cons(car(l), null)))
                           ENDIF,
                           (: a :))") (("1" (grind) nil) ("2" (hide 2 3 4) (("2" (grind) nil))) ("3" (grind) nil) ("4" (grind) nil) ("5" (grind) nil))))) ("2" (grind) nil) ("3" (assert) (("3" (hide -2 2 3 4) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(a, null)") (("3" (assert) nil)))))))))))))))))))))))))))))))) nil) nil nil) (relation_remove_constants-1 nil 3770725415 ("" (skeep*) (("" (expand "remove_constants" 1) (("" (expand "remove_constants") (("" (expand "remove_constants_rec") (("" (case "deg(a`plist) < 1") (("1" (assert) (("1" (case "eval_atm(a)(0) ") (("1" (assert) (("1" (expand "remove_constants_rec" -4) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "null?(l)") (("1" (assert) (("1" (case "l = null") (("1" (replace -1 2) (("1" (expand "remove_constants_rec") (("1" (hide-all-but 2) (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma relation_remove_constants_rec) (("2" (inst -1 "l" "null" "a") (("2" (split -1) (("1" (assert) (("1" (case "val(remove_constants_rec(l, append(null, (: a :)))) =append(IF deg(car(l)`plist) < 1
                THEN IF eval_atm(car(l))(0)
                       THEN val(remove_constants_rec(cdr(l), null))
                     ELSE val(None)
                     ENDIF
              ELSE val(remove_constants_rec(cdr(l), cons(car(l), null)))
              ENDIF,
              (: a :))") (("1" (grind) nil nil) ("2" (hide 2 3 4) (("2" (grind) nil nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (assert) (("3" (hide -2 2 3 4) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(a, null)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_rel const-decl "bool" dnf_polynomials nil) (polylist const-decl "real" polylist Sturm) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (None adt-constructor-decl "(none?)" Maybe structures) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (eval_atm const-decl "bool" dnf_polynomials nil) (Polylist type-eq-decl nil polylist Sturm) (list type-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (deg const-decl "{d: below(length(pl)) |
   (d > 0 IFF EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0) AND
    (d > 0 IMPLIES
      (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
     AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist Sturm) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil)) shostak)) (eval_truth 0 (eval_truth-2 nil 3772804032 ("" (skeep) (("" (skeep*) (("" (lemma eval_atm_list_prop) (("" (inst -1 "x" "(: a :)" "l") (("" (case "append((: a :), l) = cons(a, l)") (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "eval_atm_list((: a :))(x) = eval_atm(a)(x)") (("1" (assert) (("1" (replace -1 -2) (("1" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (expand "eval_atm_list") (("2" (expand "eval_atm_list") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "append") (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (eval_atm_list def-decl "bool" dnf_polynomials nil) (eval_atm const-decl "bool" dnf_polynomials nil) (= const-decl "[T, T -> boolean]" equalities nil) (append def-decl "list[T]" list_props nil) (eval_atm_list_prop formula-decl nil dnf_polynomials nil)) nil) (eval_truth-1 nil 3770646535 ("" (skeep) (("" (skeep*) (("" (lemma eval_atm_list_prop) (("" (inst -1 "x" "(: a :)" "l") (("" (case "append((: a :), l) = cons(a, l)") (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "eval_atm_list((: a :))(x) = eval_atm(a)(x)") (("1" (assert) (("1" (replace -1 -2) (("1" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (expand "eval_atm_list") (("2" (expand "eval_atm_list") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "append") (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TarskiRel type-decl nil poly_system_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (list type-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (eval_atm_list def-decl "bool" dnf_polynomials nil) (eval_atm const-decl "bool" dnf_polynomials nil) (eval_atm_list_prop formula-decl nil dnf_polynomials nil)) shostak)) (degr_lemma 0 (degr_lemma-2 nil 3772808325 ("" (skeep) (("" (skeep) (("" (induct "deg") (("1" (flatten 1) (("1" (expand "polynomial") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "degr_rec" -2) (("2" (case "polyn(1 + j) = 0") (("1" (assert) (("1" (assert) (("1" (expand "polynomial" 1) (("1" (expand "sigma" 1) (("1" (replaces -1) (("1" (expand "polynomial" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat_exp application-judgement "nat" exponentiation nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (TRUE const-decl "bool" booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (sigma_rat application-judgement "rational" sigma_nat reals) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (sigma def-decl "real" sigma reals) (nat_induction formula-decl nil naturalnumbers nil) (polynomial const-decl "[real -> real]" polynomials reals) (sequence type-eq-decl nil sequences nil) (degr_rec def-decl "upto(deg)" dnf_polynomials nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (rat nonempty-type-eq-decl nil rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil) (degr_lemma-1 nil 3772808195 ("" (skeep) (("" (skeep) (("" (induct "deg") (("1" (flatten 1) (("1" (expand "polynomial") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "degr_rec" -2) (("2" (case "polyn(1 + j) = 0") (("1" (assert) (("1" (assert) (("1" (expand "polynomial" 1) (("1" (expand "sigma" 1) (("1" (replaces -1) (("1" (assert) (("1" (expand "polynomial" -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil)) nil)) nil) nil shostak)) (eval_remove_constants_none 0 (eval_remove_constants_none-4 nil 3772795080 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (case "degr_rec(cons1_var`pn, cons1_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (inst -1 "x") (("1" (lemma eval_truth) (("1" (inst?) (("1" (replace -1 -5) (("1" (hide -1) (("1" (flatten -4) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "remove_constants" 1) (("2" (case "cons1_var`d < 1") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "null" "cons(cons1_var, null)") (("2" (split -1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -3) (("2" (lemma eval_truth) (("2" (inst?) (("2" (replace -1 -4) (("2" (hide -1) (("2" (flatten -3) (("2" (hide -4) (("2" (expand "eval_atm" -3) (("2" (expand "eval_atm" 1) (("2" (expand "degr_rec") (("2" (assert) (("2" (case "cons1_var`d = 0") (("1" (assert) (("1" (replace -1 -4) (("1" (replace -1 1) (("1" (expand "polynomial" -4) (("1" (expand "sigma" -4) (("1" (expand "sigma" -4) (("1" (expand "polynomial" 1) (("1" (expand "sigma" 1) (("1" (expand "sigma" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case " cons1_var`pn(cons1_var`d) /= 0") (("1" (assert) nil nil) ("2" (case "degr_rec(cons1_var`pn, cons1_var`d) = 0") (("1" (hide -2) (("1" (hide -2 1 2) (("1" (lemma "degr_lemma") (("1" (inst -1 "cons1_var`pn" "x" "cons1_var`d") (("1" (split -1) (("1" (assert) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split -1) (("1" (inst -1 "x") (("1" (hide -1 2) (("1" (lemma eval_truth) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "null" "cons(cons1_var, null)") (("2" (split -1) (("1" (assert) nil nil) ("2" (expand "remove_constants" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (degr_rec def-decl "upto(deg)" dnf_polynomials nil) (eval_atm const-decl "bool" dnf_polynomials nil) (eval_truth formula-decl nil dnf_strategy nil) (when_not_none formula-decl nil dnf_strategy nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (degr_lemma formula-decl nil dnf_strategy nil) (sigma def-decl "real" sigma reals) (polynomial const-decl "[real -> real]" polynomials reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil) (list_induction formula-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (FALSE const-decl "bool" booleans nil) (eval_atm_list def-decl "bool" dnf_polynomials nil) (= const-decl "[T, T -> boolean]" equalities nil) (remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil)) nil) (eval_remove_constants_none-3 nil 3772795059 ("" (induct "l") (("1" (grind) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (case "degr_rec(cons1_var`pn, cons1_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (inst -1 "x") (("1" (lemma eval_truth) (("1" (inst?) (("1" (replace -1 -5) (("1" (hide -1) (("1" (flatten -4) nil))))))))))) ("2" (expand "remove_constants" 1) (("2" (propax) nil))))))) ("2" (assert) (("2" (hide -3) (("2" (lemma eval_truth) (("2" (inst?) (("2" (replace -1 -4) (("2" (hide -1) (("2" (flatten -3) (("2" (hide -4) (("2" (expand "eval_atm" -3) (("2" (expand "eval_atm" 1) (("2" (lemma "polylist_eval") (("2" (inst -1 "cons1_var`plist" "x") (("2" (lemma "eval_constant_polys") (("2" (inst?) (("2" (split -1) (("1" (inst -1 "0") (("1" (reveal -1) (("1" (inst -1 "x") (("1" (assert) nil))))))) ("2" (propax) nil))))))))))))))))))))))))))))))))))) ("2" (assert) (("2" (split -1) (("1" (inst -1 "x") (("1" (hide -1 2) (("1" (lemma eval_truth) (("1" (inst?) (("1" (assert) nil))))))))) ("2" (hide -2 2) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "null" "cons(cons1_var, null)") (("2" (split -1) (("1" (assert) nil) ("2" (expand "remove_constants" 2) (("2" (assert) nil)))))))))))))))))))))))))) nil) nil nil) (eval_remove_constants_none-2 nil 3772795042 ("" (induct "l") (("1" (grind) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (case "degr_rec(cons1_var`pn, cons`_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (inst -1 "x") (("1" (lemma eval_truth) (("1" (inst?) (("1" (replace -1 -5) (("1" (hide -1) (("1" (flatten -4) nil))))))))))) ("2" (expand "remove_constants" 1) (("2" (propax) nil))))))) ("2" (assert) (("2" (hide -3) (("2" (lemma eval_truth) (("2" (inst?) (("2" (replace -1 -4) (("2" (hide -1) (("2" (flatten -3) (("2" (hide -4) (("2" (expand "eval_atm" -3) (("2" (expand "eval_atm" 1) (("2" (lemma "polylist_eval") (("2" (inst -1 "cons1_var`plist" "x") (("2" (lemma "eval_constant_polys") (("2" (inst?) (("2" (split -1) (("1" (inst -1 "0") (("1" (reveal -1) (("1" (inst -1 "x") (("1" (assert) nil))))))) ("2" (propax) nil))))))))))))))))))))))))))))))))))) ("2" (assert) (("2" (split -1) (("1" (inst -1 "x") (("1" (hide -1 2) (("1" (lemma eval_truth) (("1" (inst?) (("1" (assert) nil))))))))) ("2" (hide -2 2) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "null" "cons(cons1_var, null)") (("2" (split -1) (("1" (assert) nil) ("2" (expand "remove_constants" 2) (("2" (assert) nil)))))))))))))))))))))))))) nil) nil nil) (eval_remove_constants_none-1 nil 3770646184 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (inst -1 "x") (("1" (lemma eval_truth) (("1" (inst?) (("1" (replace -1 -5) (("1" (hide -1) (("1" (flatten -4) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "remove_constants" 1) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -3) (("2" (lemma eval_truth) (("2" (inst?) (("2" (replace -1 -4) (("2" (hide -1) (("2" (flatten -3) (("2" (hide -4) (("2" (expand "eval_atm" -3) (("2" (expand "eval_atm" 1) (("2" (lemma "polylist_eval") (("2" (inst -1 "cons1_var`plist" "x") (("2" (lemma "eval_constant_polys") (("2" (inst?) (("2" (split -1) (("1" (inst -1 "0") (("1" (reveal -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (split -1) (("1" (inst -1 "x") (("1" (hide -1 2) (("1" (lemma eval_truth) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "null" "cons(cons1_var, null)") (("2" (split -1) (("1" (assert) nil nil) ("2" (expand "remove_constants" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_atm const-decl "bool" dnf_polynomials nil) (polylist_eval formula-decl nil polylist Sturm) (lt_realorder name-judgement "RealOrder" real_orders reals) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (list_induction formula-decl nil list_adt nil) (Polylist type-eq-decl nil polylist Sturm) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (eval_atm_list def-decl "bool" dnf_polynomials nil) (deg const-decl "{d: below(length(pl)) |
   (d > 0 IFF EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0) AND
    (d > 0 IMPLIES
      (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
     AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist Sturm) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (list type-decl nil list_adt nil)) shostak)) (eval_remove_constants 0 (eval_remove_constants-14 nil 3772810041 ("" (skeep) (("" (induct "l") (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case " cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (expand "remove_constants" -1) (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (hide -1) (("1" (reveal -1) (("1" (ground) (("1" (hide -1 -2 -3 -4 -7) (("1" (lemma "degr_lemma") (("1" (inst -1 "cons1_var`pn" "x" "cons1_var`d") (("1" (split -1) (("1" (assert) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 1) (("1" (hide -1) (("1" (reveal -3) (("1" (expand "eval_atm" 1) (("1" (expand "eval_atm" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "degr_rec") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -3) (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (split -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma eval_atm_list_prop) (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (assert) (("1" (expand "remove_constants" -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (case "eval_atm_list((: cons1_var :))(x) = eval_atm(cons1_var)(x)") (("1" (replace -1 2) (("1" (ground) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_atm_list") (("2" (expand "eval_atm_list") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide -1 2 3) (("2" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2 3 -1) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (expand "remove_constants" 1) (("1" (propax) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (below type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil) (= const-decl "[T, T -> boolean]" equalities nil) (eval_atm_list def-decl "bool" dnf_polynomials nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (rat nonempty-type-eq-decl nil rationals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list_induction formula-decl nil list_adt nil) (remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil) (eval_atm const-decl "bool" dnf_polynomials nil) (eval_truth formula-decl nil dnf_strategy nil) (degr_rec def-decl "upto(deg)" dnf_polynomials nil) (degr_lemma formula-decl nil dnf_strategy nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (when_not_none formula-decl nil dnf_strategy nil) (append def-decl "list[T]" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (eval_atm_list_prop formula-decl nil dnf_polynomials nil) (relation_remove_constants_rec formula-decl nil dnf_strategy nil)) nil) (eval_remove_constants-13 nil 3772809990 ("" (skeep) (("" (induct "l") (("1" (grind) nil) ("2" (skeep) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case " cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (expand "remove_constants" -1) (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 1) (("1" (hide -1) (("1" (expand "eval_atm" 1) (("1" (reveal -1) (("1" (expand "eval_atm" -3) (("1" (ground) (("1" (hide -1 -2 -3 -4 -7) (("1" (lemma "degr_lemma") (("1" (inst -1 "cons1_var`pn" "x" "cons1_var`d") (("1" (split -1) (("1" (assert) nil) ("2" (expand "degr_rec") (("2" (propax) nil))))))))))) ("2" (postpone) nil))))))))))))))))))))))) ("2" (hide 2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil))))))))))) ("2" (assert) (("2" (expand "remove_constants" -3) (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil))))))))))) ("2" (assert) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (split -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma eval_atm_list_prop) (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (assert) (("1" (expand "remove_constants" -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (case "eval_atm_list((: cons1_var :))(x) = eval_atm(cons1_var)(x)") (("1" (replace -1 2) (("1" (ground) (("1" (hide-all-but 2) (("1" (grind) nil))))))) ("2" (hide-all-but 1) (("2" (expand "eval_atm_list") (("2" (expand "eval_atm_list") (("2" (propax) nil))))))))))))))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))) ("2" (hide -1 2 3) (("2" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (assert) nil) ("2" (hide-all-but 1) (("2" (grind) nil))))))) ("3" (hide 2 3 -1) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil))))))))))))))) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (expand "remove_constants" 1) (("1" (propax) nil))) ("2" (propax) nil)))))))))))))))))))))))))))) nil) nil nil) (eval_remove_constants-12 nil 3772809514 ("" (skeep) (("" (induct "l") (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case " cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (expand "remove_constants" -1) (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 1) (("1" (hide -1) (("1" (expand "eval_atm" 1) (("1" (lemma eval_constant_polys) (("1" (reveal -1) (("1" (expand "eval_atm" -3) (("1" (ground) (("1" (hide -1 -2 -3 -4 -7) (("1" (lemma "degr_lemma") (("1" (inst -1 "cons1_var`pn" "x" "cons1_var`d") (("1" (split -1) (("1" (assert) nil nil) ("2" (expand "degr_rec") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -3) (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (split -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma eval_atm_list_prop) (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (assert) (("1" (expand "remove_constants" -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (case "eval_atm_list((: cons1_var :))(x) = eval_atm(cons1_var)(x)") (("1" (replace -1 2) (("1" (ground) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_atm_list") (("2" (expand "eval_atm_list") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide -1 2 3) (("2" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2 3 -1) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (expand "remove_constants" 1) (("1" (propax) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (eval_remove_constants-11 nil 3772809485 ("" (skeep) (("" (induct "l") (("1" (grind) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (case "cons1_var`d< 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (inst -1 "x") (("1" (lemma eval_truth) (("1" (inst?) (("1" (replace -1 -5) (("1" (hide -1) (("1" (flatten -4) nil))))))))))) ("2" (expand "remove_constants" 1) (("2" (propax) nil))))))) ("2" (assert) (("2" (hide -3) (("2" (lemma eval_truth) (("2" (inst?) (("2" (replace -1 -4) (("2" (hide -1) (("2" (flatten -3) (("2" (hide -4) (("2" (expand "eval_atm" -3) (("2" (expand "eval_atm" 1) (("2" (lemma "polylist_eval") (("2" (inst -1 "cons1_var`plist" "x") (("2" (lemma "eval_constant_polys") (("2" (inst?) (("2" (split -1) (("1" (inst -1 "0") (("1" (reveal -1) (("1" (inst -1 "x") (("1" (assert) nil))))))) ("2" (propax) nil))))))))))))))))))))))))))))))))))) ("2" (assert) (("2" (split -1) (("1" (inst -1 "x") (("1" (hide -1 2) (("1" (lemma eval_truth) (("1" (inst?) (("1" (assert) nil))))))))) ("2" (hide -2 2) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "null" "cons(cons1_var, null)") (("2" (split -1) (("1" (assert) nil) ("2" (expand "remove_constants" 2) (("2" (assert) nil)))))))))))))))))))))))))))) nil) nil nil) (eval_remove_constants-10 nil 3772809388 ("" (skeep) (("" (induct "l") (("1" (grind) nil) ("2" (skeep) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (expand "remove_constants" -1) (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 1) (("1" (hide -1) (("1" (expand "eval_atm" 1) (("1" (lemma eval_constant_polys) (("1" (reveal -1) (("1" (expand "eval_atm" -3) (("1" (ground) (("1" (case "cons1_var`d < 1") (("1" (assert) (("1" (postpone) nil))) ("2" (assert) (("2" (postpone) nil))))) ("2" (postpone) nil) ("3" (postpone) nil))))))))))))))))))))))))) ("2" (hide 2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -3) (("2" (case "cons1_var`d < 1") (("1" (assert) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (propax) nil) ("2" (propax) nil))))))))))))))))))))) ("2" (assert) (("2" (expand "remove_constants" -3) (("2" (postpone) nil))))))))) ("2" (assert) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (split -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma eval_atm_list_prop) (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (assert) (("1" (expand "remove_constants" -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (case "eval_atm_list((: cons1_var :))(x) = eval_atm(cons1_var)(x)") (("1" (replace -1 2) (("1" (ground) (("1" (hide-all-but 2) (("1" (grind) nil))))))) ("2" (hide-all-but 1) (("2" (expand "eval_atm_list") (("2" (expand "eval_atm_list") (("2" (propax) nil))))))))))))))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))) ("2" (hide -1 2 3) (("2" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (assert) nil) ("2" (hide-all-but 1) (("2" (grind) nil))))))) ("3" (hide 2 3 -1) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil))))))))))))))) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (expand "remove_constants" 1) (("1" (propax) nil))) ("2" (propax) nil)))))))))))))))))))))))))))) nil) nil nil) (eval_remove_constants-9 nil 3772809089 ("" (skeep) (("" (induct "l") (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "degr_rec(cons1_var`pn, cons1_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (expand "remove_constants" -1) (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 1) (("1" (hide -1) (("1" (expand "eval_atm" 1) (("1" (lemma eval_constant_polys) (("1" (reveal -1) (("1" (expand "eval_atm" -3) (("1" (ground) (("1" (case "cons1_var`d < 1") (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (assert) (("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -3) (("2" (case "cons1_var`d < 1") (("1" (assert) nil nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -3) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (split -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma eval_atm_list_prop) (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (assert) (("1" (expand "remove_constants" -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (case "eval_atm_list((: cons1_var :))(x) = eval_atm(cons1_var)(x)") (("1" (replace -1 2) (("1" (ground) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_atm_list") (("2" (expand "eval_atm_list") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide -1 2 3) (("2" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2 3 -1) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (expand "remove_constants" 1) (("1" (propax) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (eval_remove_constants-8 nil 3772809057 ("" (grind) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil) nil nil) (eval_remove_constants-7 nil 3772795354 ("" (skeep) (("" (induct "l") (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "degr_rec(cons1_var`pn, cons1_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (expand "remove_constants" -1) (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 1) (("1" (hide -1) (("1" (expand "eval_atm" 1) (("1" (lemma eval_constant_polys) (("1" (reveal -1) (("1" (expand "eval_atm" -3) (("1" (ground) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -3) (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (split -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma eval_atm_list_prop) (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (assert) (("1" (expand "remove_constants" -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (case "eval_atm_list((: cons1_var :))(x) = eval_atm(cons1_var)(x)") (("1" (replace -1 2) (("1" (ground) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_atm_list") (("2" (expand "eval_atm_list") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide -1 2 3) (("2" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2 3 -1) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (expand "remove_constants" 1) (("1" (propax) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (eval_remove_constants-6 nil 3772795338 ("" (skeep) (("" (induct "l") (("1" (grind) nil) ("2" (skeep) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "degr_red(cons1_var`pn, cons1_var`d) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (expand "remove_constants" -1) (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 1) (("1" (hide -1) (("1" (expand "eval_atm" 1) (("1" (lemma eval_constant_polys) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "0") (("1" (reveal -1) (("1" (inst -1 "x") (("1" (replace -1 1) (("1" (expand "eval_atm" -3) (("1" (replace -2 -3) (("1" (ground) nil))))))))))))) ("2" (propax) nil))))))))))))))))))))))) ("2" (hide 2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil))))))))))) ("2" (assert) (("2" (expand "remove_constants" -3) (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil))))))))))) ("2" (assert) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (split -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma eval_atm_list_prop) (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (assert) (("1" (expand "remove_constants" -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (case "eval_atm_list((: cons1_var :))(x) = eval_atm(cons1_var)(x)") (("1" (replace -1 2) (("1" (ground) (("1" (hide-all-but 2) (("1" (grind) nil))))))) ("2" (hide-all-but 1) (("2" (expand "eval_atm_list") (("2" (expand "eval_atm_list") (("2" (propax) nil))))))))))))))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))) ("2" (hide -1 2 3) (("2" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (assert) nil) ("2" (hide-all-but 1) (("2" (grind) nil))))))) ("3" (hide 2 3 -1) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil))))))))))))))) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (expand "remove_constants" 1) (("1" (propax) nil))) ("2" (propax) nil)))))))))))))))))))))))))))) nil) nil nil) (eval_remove_constants-5 nil 3770652884 ("" (skeep) (("" (induct "l") (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (split -3) (("1" (expand "remove_constants" -1) (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 1) (("1" (hide -1) (("1" (expand "eval_atm" 1) (("1" (lemma eval_constant_polys) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "0") (("1" (reveal -1) (("1" (inst -1 "x") (("1" (replace -1 1) (("1" (expand "eval_atm" -3) (("1" (replace -2 -3) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -3) (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (split -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma eval_atm_list_prop) (("1" (inst?) (("1" (replace -1 2) (("1" (hide -1) (("1" (assert) (("1" (expand "remove_constants" -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (case "eval_atm_list((: cons1_var :))(x) = eval_atm(cons1_var)(x)") (("1" (replace -1 2) (("1" (ground) (("1" (hide-all-but 2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_atm_list") (("2" (expand "eval_atm_list") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide -1 2 3) (("2" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2 3 -1) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (expand "remove_constants" 1) (("1" (propax) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (deg const-decl "{d: below(length(pl)) |
   (d > 0 IFF EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0) AND
    (d > 0 IMPLIES
      (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
     AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist Sturm) (eval_atm_list def-decl "bool" dnf_polynomials nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (Polylist type-eq-decl nil polylist Sturm) (list_induction formula-decl nil list_adt nil) (eval_atm const-decl "bool" dnf_polynomials nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (eval_atm_list_prop formula-decl nil dnf_polynomials nil)) nil) (eval_remove_constants-4 nil 3770652842 ("" (induct "l") (("1" (grind) nil) ("2" (skeep*) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (postpone) nil))) ("2" (assert) (("2" (expand "remove_constants" -3) (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil))))))))))) ("2" (assert) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (split -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (postpone) nil))))))))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))) ("2" (hide -1 2 3) (("2" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (assert) nil) ("2" (hide-all-but 1) (("2" (grind) nil))))))) ("3" (hide 2 3 -1) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil))))))))))))))) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (expand "remove_constants" 1) (("1" (propax) nil))) ("2" (propax) nil)))))))))))))))))))))))))) nil) nil nil) (eval_remove_constants-3 nil 3770645042 ("" (induct "l") (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -3) (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (split -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (hide -1) (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "eval_truth") (("1" (inst?) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide -1 2 3) (("2" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2 3 -1) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (expand "remove_constants" 1) (("1" (propax) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (eval_remove_constants-2 nil 3770644714 ("" (measure-induct "l" "depth(l)") (("1" (grind) nil) ("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (propax) nil))))) ("3" (skeep) (("3" (split 1) (("1" (flatten 1) (("1" (expand "remove_constants" 1) (("1" (expand "remove_constants_rec" 1) (("1" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (postpone) nil))) ("2" (postpone) nil))))))))) ("2" (flatten 1) (("2" (skeep) (("2" (expand "remove_constants" -1) (("2" (hide -2) (("2" (expand "remove_constants_rec" -1) (("2" (postpone) nil)))))))))))))))) nil) nil nil) (eval_remove_constants-1 nil 3770644060 ("" (induct "l") (("1" (grind) nil nil) ("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (propax) nil nil)) nil)) nil) ("3" (skeep) (("3" (split 1) (("1" (flatten 1) (("1" (expand "remove_constants" 1) (("1" (expand "remove_constants_rec" 1) (("1" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (expand "remove_constants" -1) (("2" (hide -2) (("2" (expand "remove_constants_rec" -1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (conj_to_tarski_TCC1 0 (conj_to_tarski_TCC1-1 nil 3770629764 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (below type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil)) nil (conj_to_tarski subtype "dnf_strategy.rc" "(Maybe[list[DNF_Atom]].some?)"))) (conj_to_tarski_TCC2 0 (conj_to_tarski_TCC2-1 nil 3770629764 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (below type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil)) nil (conj_to_tarski subtype "dnf_strategy.j" "below[length[DNF_Atom](l)]"))) (conj_to_tarski_TCC3 0 (conj_to_tarski_TCC3-1 nil 3770631655 ("" (skeep*) (("" (replace -2 -3) (("" (hide -1 -2 -4 -5 -6) (("" (grind) nil nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (conj_to_tarski subtype "dnf_strategy.k" "nat"))) (conj_to_tarski_TCC4 0 (conj_to_tarski_TCC4-1 nil 3772791084 ("" (skeep*) (("" (typepred "j") (("" (replace -5 3) (("" (replace -6 3) (("" (assert) (("" (replace -3 3) (("" (hide -5 -6) (("" (hide -5) (("" (typepred "rc") (("" (split -1) (("1" (inst -1 "j") (("1" (split 3) (("1" (flatten -2) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((upto nonempty-type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (below type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (conj_to_tarski subtype "dnf_strategy.n" "{n | FORALL (j: naturalnumbers.upto(dnf_strategy.k)): booleans.AND(dnf_strategy.pq(j)(poly_system_strategy.n(j)) /= 0, reals.>(poly_system_strategy.n(j), 0))}")) (conj_to_tarski_TCC3-1 nil 3770629764 ("" (skeep*) (("" (typepred "j") (("" (replace -5 3) (("" (replace -6 3) (("" (assert) (("" (replace -3 3) (("" (hide -5 -6) (("" (hide -5) (("" (typepred "rc") (("" (split -1) (("1" (inst -1 "j") (("1" (split 3) (("1" (typepred "deg(nth(val(rc), j)`plist)") (("1" (hide -1 -2 -3 -4) (("1" (split -1) (("1" (hide -3 -4 -5 -6 -7 1 2) (("1" (lemma list2array_sound[rat]) (("1" (inst?) (("1" (replace -1 -3) (("1" (hide -1) (("1" (case "deg(nth(val(rc), j)`plist) < length(nth(val(rc), j)`plist)") (("1" (assert) nil nil) ("2" (hide -1 -2) (("2" (typepred "deg(nth(val(rc), j)`plist)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (list2array_sound formula-decl nil array2list structures) (lt_realorder name-judgement "RealOrder" real_orders reals) (Polylist type-eq-decl nil polylist Sturm) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (list type-decl nil list_adt nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (deg const-decl "{d: below(length(pl)) |
   (d > 0 IFF EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0) AND
    (d > 0 IMPLIES
      (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
     AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist Sturm) (le_realorder name-judgement "RealOrder" real_orders reals)) nil (conj_to_tarski subtype "dnf_strategy.n" "{n | FORALL (j: naturalnumbers.upto(dnf_strategy.k)): booleans.AND(dnf_strategy.pq(j)(poly_system_strategy.n(j)) /= 0, reals.>(poly_system_strategy.n(j), 0))}"))) (conj_to_tarski_TCC5 0 (conj_to_tarski_TCC4-1 nil 3770629764 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (below type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (x1!1 skolem-const-decl "nat" dnf_strategy nil) (rc!1 skolem-const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil) (remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil)) nil (conj_to_tarski subtype "dnf_strategy.rel" "[nat -> integers.subrange(0, 5)]"))) (satisfiability_relation_TCC1 0 (satisfiability_relation_TCC1-1 nil 3770655019 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (satisfiability_relation subtype "poly_system_strategy.to_nat(dnf_strategy.a`rel)" "integers.subrange(0, 5)"))) (satisfiability_relation 0 (satisfiability_relation-3 "" 3790099613 ("" (skeep) (("" (skeep) (("" (expand "eval_atm") (("" (lemma "polylist_eval") (("" (inst?) (("" (hide -1) (("" (lemma "polylist_eval_deg") (("" (inst?) (("" (hide -1) (("" (case "to_nat(a`rel) = 0 OR to_nat(a`rel) = 1 OR to_nat(a`rel) = 2 OR to_nat(a`rel) = 3 OR to_nat(a`rel) = 4 OR to_nat(a`rel) = 5") (("1" (split -1) (("1" (expand "rel5") (("1" (assert) (("1" (expand "to_nat") (("1" (case "a`rel = peq") (("1" (replace -1 1) (("1" (expand "eval_rel") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "rel5") (("2" (assert) (("2" (expand "to_nat") (("2" (case "a`rel = pgt") (("1" (replace -1 1) (("1" (expand "eval_rel") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "rel5") (("3" (assert) (("3" (expand "to_nat") (("3" (case "a`rel = plt") (("1" (replace -1 1) (("1" (expand "eval_rel") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "rel5") (("4" (assert) (("4" (expand "to_nat") (("4" (case "a`rel = pneq") (("1" (replace -1 1) (("1" (expand "eval_rel") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "rel5") (("5" (assert) (("5" (expand "to_nat") (("5" (case "a`rel = pge") (("1" (replace -1 1) (("1" (expand "eval_rel") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "rel5") (("6" (assert) (("6" (expand "to_nat") (("6" (case "a`rel = ple") (("1" (replace -1 1) (("1" (expand "eval_rel") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((polylist_eval formula-decl nil polylist Sturm) (to_nat const-decl "upto(5)" poly_system_strategy nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ple adt-constructor-decl "(ple?)" poly_system_strategy nil) (ple? adt-recognizer-decl "[TarskiRel -> boolean]" poly_system_strategy nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (pge adt-constructor-decl "(pge?)" poly_system_strategy nil) (pge? adt-recognizer-decl "[TarskiRel -> boolean]" poly_system_strategy nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (pneq adt-constructor-decl "(pneq?)" poly_system_strategy nil) (pneq? adt-recognizer-decl "[TarskiRel -> boolean]" poly_system_strategy nil) (plt adt-constructor-decl "(plt?)" poly_system_strategy nil) (plt? adt-recognizer-decl "[TarskiRel -> boolean]" poly_system_strategy nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pgt adt-constructor-decl "(pgt?)" poly_system_strategy nil) (pgt? adt-recognizer-decl "[TarskiRel -> boolean]" poly_system_strategy nil) (rel5 const-decl "bool" preprocessing_univariate nil) (eval_rel const-decl "bool" dnf_polynomials nil) (peq adt-constructor-decl "(peq?)" poly_system_strategy nil) (peq? adt-recognizer-decl "[TarskiRel -> boolean]" poly_system_strategy nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (polylist_eval_deg formula-decl nil polylist Sturm) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (rat nonempty-type-eq-decl nil rationals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (eval_atm const-decl "bool" dnf_polynomials nil)) shostak) (satisfiability_relation-2 nil 3770655927 ("" (skeep) (("" (skeep) (("" (expand "eval_atm") (("" (lemma "polylist_eval") (("" (inst?) (("" (replace -1 1) (("" (hide -1) (("" (lemma "polylist_eval_deg") (("" (inst?) (("" (split -1) (("1" (replace -1 1) (("1" (hide -1) (("1" (case "to_nat(a`rel) = 0 OR to_nat(a`rel) = 1 OR to_nat(a`rel) = 2 OR to_nat(a`rel) = 3 OR to_nat(a`rel) = 4 OR to_nat(a`rel) = 5") (("1" (split -1) (("1" (expand "rel5") (("1" (assert) (("1" (expand "to_nat") (("1" (case "a`rel = peq") (("1" (replace -1 1) (("1" (expand "eval_rel") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "rel5") (("2" (assert) (("2" (expand "to_nat") (("2" (case "a`rel = pgt") (("1" (replace -1 1) (("1" (expand "eval_rel") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "rel5") (("3" (assert) (("3" (expand "to_nat") (("3" (case "a`rel = plt") (("1" (replace -1 1) (("1" (expand "eval_rel") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "rel5") (("4" (assert) (("4" (expand "to_nat") (("4" (case "a`rel = pneq") (("1" (replace -1 1) (("1" (expand "eval_rel") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "rel5") (("5" (assert) (("5" (expand "to_nat") (("5" (case "a`rel = pge") (("1" (replace -1 1) (("1" (expand "eval_rel") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "rel5") (("6" (assert) (("6" (expand "to_nat") (("6" (case "a`rel = ple") (("1" (replace -1 1) (("1" (expand "eval_rel") (("1" (assert) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((polylist_eval formula-decl nil polylist Sturm) (to_nat const-decl "upto(5)" poly_system_strategy nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (ple adt-constructor-decl "(ple?)" poly_system_strategy nil) (ple? adt-recognizer-decl "[TarskiRel -> boolean]" poly_system_strategy nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (pge adt-constructor-decl "(pge?)" poly_system_strategy nil) (pge? adt-recognizer-decl "[TarskiRel -> boolean]" poly_system_strategy nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (pneq adt-constructor-decl "(pneq?)" poly_system_strategy nil) (pneq? adt-recognizer-decl "[TarskiRel -> boolean]" poly_system_strategy nil) (plt adt-constructor-decl "(plt?)" poly_system_strategy nil) (plt? adt-recognizer-decl "[TarskiRel -> boolean]" poly_system_strategy nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pgt adt-constructor-decl "(pgt?)" poly_system_strategy nil) (pgt? adt-recognizer-decl "[TarskiRel -> boolean]" poly_system_strategy nil) (rel5 const-decl "bool" preprocessing_univariate nil) (eval_rel const-decl "bool" dnf_polynomials nil) (peq adt-constructor-decl "(peq?)" poly_system_strategy nil) (peq? adt-recognizer-decl "[TarskiRel -> boolean]" poly_system_strategy nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (polylist_eval_deg formula-decl nil polylist Sturm) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (/= const-decl "boolean" notequal nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (TarskiRel type-decl nil poly_system_strategy nil) (rat nonempty-type-eq-decl nil rationals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (eval_atm const-decl "bool" dnf_polynomials nil)) nil) (satisfiability_relation-1 nil 3770655020 ("" (skeep) (("" (skeep) (("" (expand "eval_atm") (("" (lemma "polylist_eval") (("" (inst?) (("" (replace -1 1) (("" (hide -1) (("" (lemma "polylist_eval_deg") (("" (inst?) (("" (split -1) (("1" (replace -1 1) (("1" (hide -1) (("1" (case "to_nat(a`rel) = 0 OR to_nat(a`rel) = 1 OR to_nat(a`rel) = 2 OR to_nat(a`rel) = 3 OR to_nat(a`rel) = 4 OR to_nat(a`rel) = 5") (("1" (split -1) (("1" (expand "rel5") (("1" (assert) (("1" (expand "to_nat") (("1" (case "a`rel = peq") (("1" (replace -1 1) (("1" (expand "eval_rel") (("1" (assert) (("1" (ground) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (satisfiability_relation_system_TCC1 0 (satisfiability_relation_system_TCC2-1 nil 3770657142 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (length def-decl "nat" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil)) nil (satisfiability_relation_system subtype "dnf_strategy.j" "below[length[DNF_Atom](val[list[DNF_Atom]](remove_constants(ll)))]"))) (satisfiability_relation_system_TCC2 0 (satisfiability_relation_system_TCC3-1 nil 3770657142 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (upto nonempty-type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (Maybe type-decl nil Maybe structures) (length def-decl "nat" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil)) nil (satisfiability_relation_system subtype "poly_system_strategy.to_nat(list_props[DNF_Atom].nth(Maybe[list[DNF_Atom]].val(dnf_strategy.remove_constants(dnf_strategy.ll)), dnf_strategy.j)`rel)" "integers.subrange(0, 5)"))) (satisfiability_relation_system 0 (satisfiability_relation_system-16 "" 3804271943 ("" (induct "ll") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (case "cons2_var = null") (("1" (hide -2) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (hide -1) (("1" (replaces -1) (("1" (hide -1) (("1" (case "cons(cons1_var, null) = (: cons1_var :)") (("1" (replaces -1) (("1" (case "val(remove_constants((: cons1_var :))) = (: cons1_var :)") (("1" (replaces -1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (case "(rel5(to_nat(cons1_var`rel))
                                                 (polynomial(cons1_var`pn, cons1_var`d)(x), 0))
                                       IFF (FORALL (j:
                                                       upto(length(val(remove_constants(cons
                                                                                        (cons1_var, cons2_var))))
                                                             - 1)):
                                               rel5(to_nat(nth((: cons1_var :), j)`rel))
                                                   (polynomial(nth((: cons1_var :), j)`pn,
                                                               nth((: cons1_var :), j)`d)
                                                              (x),
                                                    0))") (("1" (ground) nil nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -4) (("2" (split 1) (("1" (flatten 1) (("1" (skeep) (("1" (typepred "j") (("1" (case "j = 0") (("1" (assert) nil nil) ("2" (reveal -10 -8 -7) (("2" (replace -3 -4) (("2" (replace -2 -4) (("2" (replace -1 -4) (("2" (hide-all-but (-4 1)) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (inst -1 "0") (("1" (assert) nil nil) ("2" (assert) (("2" (reveal -11 -9 -8) (("2" (replace -3 1) (("2" (replace -2 1) (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (split 1) (("1" (typepred "to_nat(nth[DNF_Atom]((: cons1_var :), j)`rel)") (("1" (assert) nil nil)) nil) ("2" (typepred "to_nat(nth[DNF_Atom]((: cons1_var :), j)`rel)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (typepred "j") (("4" (reveal -3 -4 -6) (("4" (replace -3 -4) (("4" (replace -2 -4) (("4" (replace -1 -4) (("4" (hide-all-but (-4 1)) (("4" (expand "length") (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (split 2) (("1" (flatten 1) (("1" (inst -1 "0") (("1" (replace -2 -1) (("1" (assert) (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -6) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "eval_atm(cons1_var)(0) ") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal -4 -5 -7) (("2" (replace -3 1) (("2" (replace -2 1) (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = 0") (("1" (replace -1 1) (("1" (replaces -4) (("1" (assert) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (expand "eval_atm_list") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -6) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (reveal -6 -4 -3) (("2" (replace -3 -4) (("2" (replace -2 -4) (("2" (replace -1 -4) (("2" (hide-all-but (-4 1)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -3) (("1" (expand "length" -3) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal -2 -1) (("2" (replaces -1 -2) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "relation_remove_constants_single") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (lemma "relation_remove_constants_null") (("1" (inst -1 "cons2_var" "cons1_var") (("1" (split -1) (("1" (replaces -1) (("1" (split 2) (("1" (flatten 1) (("1" (split 1) (("1" (lemma "satisfiability_relation") (("1" (hide -4 -7) (("1" (expand "remove_constants" -3) (("1" (expand "remove_constants_rec" -3) (("1" (assert) (("1" (case " eval_atm(cons1_var)(0)") (("1" (assert) (("1" (case "cons1_var`d < 1") (("1" (assert) (("1" (hide-all-but (-1 -2 1)) (("1" (expand "eval_atm") (("1" (case "cons1_var`d = 0") (("1" (replace -1 -3) (("1" (replace -1 1) (("1" (expand "polynomial") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (typepred "cons1_var`d") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but -4) (("2" (lemma "relation_remove_constants_rec") (("2" (inst -1 "null" "null" "cons1_var") (("2" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (replace -2 -3) (("1" (hide-all-but -3) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "remove_constants_rec" 1) (("2" (propax) nil nil)) nil) ("3" (expand "remove_constants_rec" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -4) (("2" (expand "remove_constants_rec" -4) (("2" (case "cons1_var`d < 1 ") (("1" (assert) nil nil) ("2" (assert) (("2" (hide-all-but -3) (("2" (lemma "relation_remove_constants_rec") (("2" (inst -1 "null" "null" "cons1_var") (("2" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (replace -2 -3) (("1" (hide-all-but -3) (("1" (expand "append") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append") (("2" (propax) nil nil)) nil)) nil) ("2" (expand "remove_constants_rec" 1) (("2" (propax) nil nil)) nil) ("3" (expand "remove_constants_rec" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "x") (("2" (ground) (("2" (hide 1) (("2" (skeep) (("2" (inst -1 "j") (("2" (hide 2 3 4) (("2" (typepred "j") (("2" (hide -2 -3 -4 -5) (("2" (reveal -7) (("2" (replace -1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (reveal -1) (("2" (skeep) (("2" (inst -5 "x") (("2" (ground) (("2" (inst -1 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "relation_remove_constants") (("2" (inst -1 "cons2_var" "cons1_var") (("2" (split -1) (("1" (replaces -1) (("1" (reveal -1) (("1" (split 2) (("1" (flatten 1) (("1" (split 1) (("1" (inst -1 "length(val(remove_constants(cons
                                                 (cons1_var, cons2_var))))
                      - 1") (("1" (case "nth(append(val(remove_constants(cons2_var)),
                             (: cons1_var :)),
                      length(val(remove_constants(cons
                                                  (cons1_var, cons2_var))))
                       - 1) = cons1_var") (("1" (replaces -1) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (hide -6 -7) (("2" (hide -4) (("2" (hide -1 -2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -3) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -7) (("2" (hide -4) (("2" (hide -1) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)" "length(val(remove_constants(cons(cons1_var, cons2_var)))) - 1") (("1" (split -1) (("1" (case "length(val(remove_constants(cons(cons1_var, cons2_var)))) - 1 =
           length(val(remove_constants(cons2_var)))") (("1" (assert) (("1" (replace -1 -2) (("1" (assert) (("1" (hide-all-but (-2 1)) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -2 1) (("2" (hide -1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -1 1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -1 1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (replace -2 1) (("3" (hide-all-but 1) (("3" (lemma "length_append[DNF_Atom]") (("3" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("3" (replace -1 1) (("3" (case "length((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -7) (("2" (inst -4 "x") (("2" (ground) (("2" (hide 1) (("2" (skeep) (("2" (inst -1 "j") (("1" (case "nth(append(val(remove_constants(cons2_var)),
                             (: cons1_var :)),
                      j) = nth(val(remove_constants(cons2_var)), j)") (("1" (assert) nil nil) ("2" (hide 2 3 4) (("2" (hide -1) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)" "j") (("2" (typepred "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4) (("2" (replace -1 1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = length(val(remove_constants(cons(cons1_var, cons2_var)))) - 1") (("1" (hide -2) (("1" (case "nth(append(val(remove_constants(cons2_var)),
                             (: cons1_var :)),
                      j) = cons1_var") (("1" (replaces -1) (("1" (hide-all-but (-2 1)) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (reveal -6 -4) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -3) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide-all-but (-1 1)) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)" "j") (("2" (case "j = length(val(remove_constants(cons2_var)))") (("1" (assert) (("1" (replace -1 -2) (("1" (assert) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -10) (("2" (replace -1 -3) (("2" (hide-all-but (-3 1)) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 -2) (("2" (hide -1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide -1 2) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "j < length(val(remove_constants(cons(cons1_var, cons2_var)))) - 1") (("1" (hide -10) (("1" (inst -7 "x") (("1" (ground) (("1" (inst -1 "j") (("1" (case "nth(append(val(remove_constants(cons2_var)),
                             (: cons1_var :)),
                      j) = nth(val(remove_constants(cons2_var)), j)") (("1" (assert) nil nil) ("2" (hide 2 3 4) (("2" (hide -4) (("2" (hide -1) (("2" (hide-all-but (-2 -5 1)) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)" "j") (("2" (replace -3 -2) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 -3) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 -4) (("1" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4) (("2" (replace -6 -2) (("2" (hide -3) (("2" (hide-all-but (-2 1)) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 -2) (("2" (hide -1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (expand "remove_constants" -1) (("3" (expand "remove_constants_rec" -1) (("3" (expand "remove_constants" 1) (("3" (expand "remove_constants_rec" 1) (("3" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (skeep) (("2" (hide-all-but 1) (("2" (typepred "remove_constants(cons2_var)") (("2" (split -1) (("1" (inst -1 "j") (("1" (assert) (("1" (flatten -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (hide 2) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" -1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (hide -2 -3) (("3" (expand "remove_constants" -1) (("3" (expand "remove_constants_rec" -1) (("3" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (assert) (("2" (expand "remove_constants" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case " length(val(remove_constants(cons2_var))) = 0") (("1" (hide -4 1) (("1" (case "val(remove_constants(cons(cons1_var, cons2_var))) = (: cons1_var :)") (("1" (replace -1 2) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (replace -1 2) (("1" (hide -1) (("1" (split 2) (("1" (flatten 1) (("1" (split 1) (("1" (inst -1 "0") (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 -2) (("1" (hide -1) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (case "val(remove_constants_rec(cons2_var, null)) = null") (("1" (replace -1 -5) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (expand "remove_constants" -5) (("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -5) (("2" (expand "remove_constants_rec" -5) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "eval_remove_constants") (("2" (inst -1 "x" "cons2_var") (("2" (split -1) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (replace -1 -2) (("1" (case "eval_atm_list(null)(x)") (("1" (hide-all-but (-1 -3 1)) (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "eval_atm_list" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" -1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = 0") (("1" (replace -1 1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants" -7) (("2" (expand "remove_constants_rec" -7) (("2" (expand "remove_constants" -5) (("2" (expand "remove_constants_rec" -5) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (expand "remove_constants" -1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (replace -4 -1) (("2" (hide-all-but (-1 1)) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" (-2 -3 1)) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "cons(cons1_var, null) = (: cons1_var :)") (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case " append(null, (: cons1_var :))= (: cons1_var :)") (("1" (replace -1 -2) (("1" (replace -2 2) (("1" (hide -1 -2) (("1" (case "val(remove_constants_rec(cons2_var, null)) = null") (("1" (replace -1 2) (("1" (hide-all-but 2) (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "append(null, (: cons1_var :))") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (lemma "when_not_none") (("3" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("3" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (skeep) (("3" (hide-all-but 2) (("3" (typepred "to_nat(nth[DNF_Atom]
                                  (val[list[DNF_Atom]](remove_constants(ll)), j)`rel)") (("1" (assert) (("1" (reveal 1) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) (("2" (grind) (("2" (reveal -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (satisfiability_relation_system-15 "" 3790099620 ("" (induct "ll") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (case "cons2_var = null") (("1" (hide -2) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (hide -1) (("1" (replaces -1) (("1" (hide -1) (("1" (case "cons(cons1_var, null) = (: cons1_var :)") (("1" (replaces -1) (("1" (case "val(remove_constants((: cons1_var :))) = (: cons1_var :)") (("1" (replaces -1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (case "(rel5(to_nat(cons1_var`rel))
                                                 (polynomial(cons1_var`pn, cons1_var`d)(x), 0))
                                       IFF (FORALL (j:
                                                       upto(length(val(remove_constants(cons
                                                                                        (cons1_var, cons2_var))))
                                                             - 1)):
                                               rel5(to_nat(nth((: cons1_var :), j)`rel))
                                                   (polynomial(nth((: cons1_var :), j)`pn,
                                                               nth((: cons1_var :), j)`d)
                                                              (x),
                                                    0))") (("1" (ground) nil nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -4) (("2" (split 1) (("1" (flatten 1) (("1" (skeep) (("1" (typepred "j") (("1" (case "j = 0") (("1" (assert) nil nil) ("2" (reveal -10 -8 -7) (("2" (replace -3 -4) (("2" (replace -2 -4) (("2" (replace -1 -4) (("2" (hide-all-but (-4 1)) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (inst -1 "0") (("1" (assert) nil nil) ("2" (assert) (("2" (reveal -11 -9 -8) (("2" (replace -3 1) (("2" (replace -2 1) (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (split 1) (("1" (typepred "to_nat(nth[DNF_Atom]((: cons1_var :), j)`rel)") (("1" (assert) nil nil)) nil) ("2" (typepred "to_nat(nth[DNF_Atom]((: cons1_var :), j)`rel)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (typepred "j") (("4" (reveal -3 -4 -6) (("4" (replace -3 -4) (("4" (replace -2 -4) (("4" (replace -1 -4) (("4" (hide-all-but (-4 1)) (("4" (expand "length") (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (split 2) (("1" (flatten 1) (("1" (inst -1 "0") (("1" (replace -2 -1) (("1" (assert) (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -6) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "eval_atm(cons1_var)(0) ") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal -4 -5 -7) (("2" (replace -3 1) (("2" (replace -2 1) (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = 0") (("1" (replace -1 1) (("1" (replaces -4) (("1" (assert) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (expand "eval_atm_list") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -6) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (reveal -6 -4 -3) (("2" (replace -3 -4) (("2" (replace -2 -4) (("2" (replace -1 -4) (("2" (hide-all-but (-4 1)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -3) (("1" (expand "length" -3) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal -2 -1) (("2" (replaces -1 -2) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "relation_remove_constants_single") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (lemma "relation_remove_constants_null") (("1" (inst -1 "cons2_var" "cons1_var") (("1" (split -1) (("1" (replaces -1) (("1" (split 2) (("1" (flatten 1) (("1" (split 1) (("1" (lemma "satisfiability_relation") (("1" (hide -4 -7) (("1" (expand "remove_constants" -3) (("1" (expand "remove_constants_rec" -3) (("1" (assert) (("1" (case " eval_atm(cons1_var)(0)") (("1" (assert) (("1" (case "cons1_var`d < 1") (("1" (assert) (("1" (hide-all-but (-1 -2 1)) (("1" (expand "eval_atm") (("1" (case "cons1_var`d = 0") (("1" (replace -1 -3) (("1" (replace -1 1) (("1" (expand "polynomial") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (typepred "cons1_var`d") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but -4) (("2" (lemma "relation_remove_constants_rec") (("2" (inst -1 "null" "null" "cons1_var") (("2" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (replace -2 -3) (("1" (hide-all-but -3) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "remove_constants_rec" 1) (("2" (propax) nil nil)) nil) ("3" (expand "remove_constants_rec" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -4) (("2" (expand "remove_constants_rec" -4) (("2" (case "cons1_var`d < 1 ") (("1" (assert) nil nil) ("2" (assert) (("2" (hide-all-but -3) (("2" (lemma "relation_remove_constants_rec") (("2" (inst -1 "null" "null" "cons1_var") (("2" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (replace -2 -3) (("1" (hide-all-but -3) (("1" (expand "append") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append") (("2" (propax) nil nil)) nil)) nil) ("2" (expand "remove_constants_rec" 1) (("2" (propax) nil nil)) nil) ("3" (expand "remove_constants_rec" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "x") (("2" (ground) (("2" (hide 1) (("2" (skeep) (("2" (inst -1 "j") (("2" (hide 2 3 4) (("2" (typepred "j") (("2" (hide -2 -3 -4 -5) (("2" (reveal -7) (("2" (replace -1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (reveal -1) (("2" (skeep) (("2" (inst -5 "x") (("2" (ground) (("2" (inst -1 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "relation_remove_constants") (("2" (inst -1 "cons2_var" "cons1_var") (("2" (split -1) (("1" (replaces -1) (("1" (reveal -1) (("1" (split 2) (("1" (flatten 1) (("1" (split 1) (("1" (inst -1 "length(val(remove_constants(cons
                                                 (cons1_var, cons2_var))))
                      - 1") (("1" (case "nth(append(val(remove_constants(cons2_var)),
                             (: cons1_var :)),
                      length(val(remove_constants(cons
                                                  (cons1_var, cons2_var))))
                       - 1) = cons1_var") (("1" (replaces -1) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (hide -6 -7) (("2" (hide -4) (("2" (hide -1 -2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -3) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -7) (("2" (hide -4) (("2" (hide -1) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)" "length(val(remove_constants(cons(cons1_var, cons2_var)))) - 1") (("1" (split -1) (("1" (case "length(val(remove_constants(cons(cons1_var, cons2_var)))) - 1 =
           length(val(remove_constants(cons2_var)))") (("1" (assert) (("1" (replace -1 -2) (("1" (assert) (("1" (hide-all-but (-2 1)) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -2 1) (("2" (hide -1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -1 1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -1 1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (replace -2 1) (("3" (hide-all-but 1) (("3" (lemma "length_append[DNF_Atom]") (("3" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("3" (replace -1 1) (("3" (case "length((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -7) (("2" (inst -4 "x") (("2" (ground) (("2" (hide 1) (("2" (skeep) (("2" (inst -1 "j") (("1" (case "nth(append(val(remove_constants(cons2_var)),
                             (: cons1_var :)),
                      j) = nth(val(remove_constants(cons2_var)), j)") (("1" (assert) nil nil) ("2" (hide 2 3 4) (("2" (hide -1) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)" "j") (("2" (typepred "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4) (("2" (replace -1 1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = length(val(remove_constants(cons(cons1_var, cons2_var)))) - 1") (("1" (hide -2) (("1" (case "nth(append(val(remove_constants(cons2_var)),
                             (: cons1_var :)),
                      j) = cons1_var") (("1" (replaces -1) (("1" (hide-all-but (-2 1)) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (reveal -6 -4) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -3) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide-all-but (-1 1)) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)" "j") (("2" (case "j = length(val(remove_constants(cons2_var)))") (("1" (assert) (("1" (replace -1 -2) (("1" (assert) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -10) (("2" (replace -1 -3) (("2" (hide-all-but (-3 1)) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 -2) (("2" (hide -1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide -1 2) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "j < length(val(remove_constants(cons(cons1_var, cons2_var)))) - 1") (("1" (hide -10) (("1" (inst -7 "x") (("1" (ground) (("1" (inst -1 "j") (("1" (case "nth(append(val(remove_constants(cons2_var)),
                             (: cons1_var :)),
                      j) = nth(val(remove_constants(cons2_var)), j)") (("1" (assert) nil nil) ("2" (hide 2 3 4) (("2" (hide -4) (("2" (hide -1) (("2" (hide-all-but (-2 -5 1)) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)" "j") (("2" (replace -3 -2) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 -3) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 -4) (("1" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4) (("2" (replace -6 -2) (("2" (hide -3) (("2" (hide-all-but (-2 1)) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 -2) (("2" (hide -1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (expand "remove_constants" -1) (("3" (expand "remove_constants_rec" -1) (("3" (expand "remove_constants" 1) (("3" (expand "remove_constants_rec" 1) (("3" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (skeep) (("2" (hide-all-but 1) (("2" (typepred "remove_constants(cons2_var)") (("2" (split -1) (("1" (inst -1 "j") (("1" (assert) (("1" (flatten -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (hide 2) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" -1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (hide -2 -3) (("3" (expand "remove_constants" -1) (("3" (expand "remove_constants_rec" -1) (("3" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (assert) (("2" (expand "remove_constants" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case " length(val(remove_constants(cons2_var))) = 0") (("1" (hide -4 1) (("1" (case "val(remove_constants(cons(cons1_var, cons2_var))) = (: cons1_var :)") (("1" (replace -1 2) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (replace -1 2) (("1" (hide -1) (("1" (split 2) (("1" (flatten 1) (("1" (split 1) (("1" (inst -1 "0") (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 -2) (("1" (hide -1) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (case "val(remove_constants_rec(cons2_var, null)) = null") (("1" (replace -1 -5) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (expand "remove_constants" -5) (("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -5) (("2" (expand "remove_constants_rec" -5) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "eval_remove_constants") (("2" (inst -1 "x" "cons2_var") (("2" (split -1) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (replace -1 -2) (("1" (case "eval_atm_list(null)(x)") (("1" (hide-all-but (-1 -3 1)) (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "eval_atm_list" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" -1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = 0") (("1" (replace -1 1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants" -7) (("2" (expand "remove_constants_rec" -7) (("2" (expand "remove_constants" -5) (("2" (expand "remove_constants_rec" -5) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (expand "remove_constants" -1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (replace -4 -1) (("2" (hide-all-but (-1 1)) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" (-2 -3 1)) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "cons(cons1_var, null) = (: cons1_var :)") (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case " append(null, (: cons1_var :))= (: cons1_var :)") (("1" (replace -1 -2) (("1" (replace -2 2) (("1" (hide -1 -2) (("1" (case "val(remove_constants_rec(cons2_var, null)) = null") (("1" (replace -1 2) (("1" (hide-all-but 2) (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "append(null, (: cons1_var :))") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (lemma "when_not_none") (("3" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("3" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (skeep) (("3" (hide-all-but 2) (("3" (typepred "to_nat(nth[DNF_Atom]
                              (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("1" (assert) (("1" (reveal 1) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) (("2" (reveal -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((eval_remove_constants formula-decl nil dnf_strategy nil) (when_not_none formula-decl nil dnf_strategy nil) (j skolem-const-decl "upto(length(val(remove_constants(cons(cons1_var, cons2_var)))) - 1)" dnf_strategy nil) (j skolem-const-decl "upto(length(val(remove_constants(cons2_var))) - 1)" dnf_strategy nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_append formula-decl nil list_props nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (nth_append formula-decl nil more_list_props structures) (relation_remove_constants formula-decl nil dnf_strategy nil) (j skolem-const-decl "upto(length(val(remove_constants(cons2_var))) - 1)" dnf_strategy nil) (append def-decl "list[T]" list_props nil) (relation_remove_constants_rec formula-decl nil dnf_strategy nil) (relation_remove_constants_null formula-decl nil dnf_strategy nil) (relation_remove_constants_single formula-decl nil dnf_strategy nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (eval_rel const-decl "bool" dnf_polynomials nil) (sigma def-decl "real" sigma reals) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (sigma_rat application-judgement "rational" sigma_nat reals) (eval_atm const-decl "bool" dnf_polynomials nil) (cons2_var skolem-const-decl "list[DNF_Atom]" dnf_strategy nil) (cons1_var skolem-const-decl "DNF_Atom" dnf_strategy nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (length_singleton formula-decl nil more_list_props structures) (satisfiability_relation formula-decl nil dnf_strategy nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (TRUE const-decl "bool" booleans nil) (eval_truth formula-decl nil dnf_strategy nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (list_induction formula-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (eval_atm_list def-decl "bool" dnf_polynomials nil) (polynomial const-decl "[real -> real]" polynomials reals) (sequence type-eq-decl nil sequences nil) (rel5 const-decl "bool" preprocessing_univariate nil) (subrange type-eq-decl nil integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (to_nat const-decl "upto(5)" poly_system_strategy nil)) shostak) (satisfiability_relation_system-14 nil 3772881581 ("" (induct "ll") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (case "cons2_var = null") (("1" (hide -2) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (hide -1) (("1" (replaces -1) (("1" (hide -1) (("1" (case "cons(cons1_var, null) = (: cons1_var :)") (("1" (replaces -1) (("1" (case "val(remove_constants((: cons1_var :))) = (: cons1_var :)") (("1" (replaces -1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replaces -1) (("1" (replaces -1) (("1" (replaces -2) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (replaces -1 1) (("1" (case "(rel5(to_nat(cons1_var`rel))
                                                 (polynomial(cons1_var`pn, cons1_var`d)(x), 0))
                                       IFF (FORALL (j:
                                                       upto(length(val(remove_constants(cons
                                                                                        (cons1_var, cons2_var))))
                                                             - 1)):
                                               rel5(to_nat(nth((: cons1_var :), j)`rel))
                                                   (polynomial(nth((: cons1_var :), j)`pn,
                                                               nth((: cons1_var :), j)`d)
                                                              (x),
                                                    0))") (("1" (ground) nil nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -4) (("2" (split 1) (("1" (flatten 1) (("1" (skeep) (("1" (typepred "j") (("1" (case "j = 0") (("1" (assert) nil nil) ("2" (reveal -10 -8 -7) (("2" (replace -3 -4) (("2" (replace -2 -4) (("2" (replace -1 -4) (("2" (hide-all-but (-4 1)) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (inst -1 "0") (("1" (assert) nil nil) ("2" (assert) (("2" (reveal -11 -9 -8) (("2" (replace -3 1) (("2" (replace -2 1) (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (split 1) (("1" (typepred "to_nat(nth[DNF_Atom]((: cons1_var :), j)`rel)") (("1" (assert) nil nil)) nil) ("2" (typepred "to_nat(nth[DNF_Atom]((: cons1_var :), j)`rel)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (typepred "j") (("4" (reveal -3 -4 -6) (("4" (replace -3 -4) (("4" (replace -2 -4) (("4" (replace -1 -4) (("4" (hide-all-but (-4 1)) (("4" (expand "length") (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (split 2) (("1" (flatten 1) (("1" (inst -1 "0") (("1" (replace -2 -1) (("1" (assert) (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -6) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "eval_atm(cons1_var)(0) ") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal -4 -5 -7) (("2" (replace -3 1) (("2" (replace -2 1) (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = 0") (("1" (replace -1 1) (("1" (replaces -4) (("1" (assert) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (expand "eval_atm_list") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -6) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (reveal -6 -4 -3) (("2" (replace -3 -4) (("2" (replace -2 -4) (("2" (replace -1 -4) (("2" (hide-all-but (-4 1)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -3) (("1" (expand "length" -3) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal -2 -1) (("2" (replaces -1 -2) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "relation_remove_constants_single") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (lemma "relation_remove_constants_null") (("1" (inst -1 "cons2_var" "cons1_var") (("1" (split -1) (("1" (replaces -1) (("1" (split 2) (("1" (flatten 1) (("1" (split 1) (("1" (lemma "satisfiability_relation") (("1" (hide -4 -7) (("1" (expand "remove_constants" -3) (("1" (expand "remove_constants_rec" -3) (("1" (assert) (("1" (case " eval_atm(cons1_var)(0)") (("1" (assert) (("1" (case "cons1_var`d < 1") (("1" (assert) (("1" (hide-all-but (-1 -2 1)) (("1" (expand "eval_atm") (("1" (case "cons1_var`d = 0") (("1" (replace -1 -3) (("1" (replace -1 1) (("1" (expand "polynomial") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (typepred "cons1_var`d") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but -4) (("2" (lemma "relation_remove_constants_rec") (("2" (inst -1 "null" "null" "cons1_var") (("2" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (replace -2 -3) (("1" (hide-all-but -3) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "remove_constants_rec" 1) (("2" (propax) nil nil)) nil) ("3" (expand "remove_constants_rec" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -4) (("2" (expand "remove_constants_rec" -4) (("2" (case "cons1_var`d < 1 ") (("1" (assert) nil nil) ("2" (assert) (("2" (hide-all-but -3) (("2" (lemma "relation_remove_constants_rec") (("2" (inst -1 "null" "null" "cons1_var") (("2" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (replace -2 -3) (("1" (hide-all-but -3) (("1" (expand "append") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append") (("2" (propax) nil nil)) nil)) nil) ("2" (expand "remove_constants_rec" 1) (("2" (propax) nil nil)) nil) ("3" (expand "remove_constants_rec" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "x") (("2" (ground) (("2" (hide 1) (("2" (skeep) (("2" (inst -1 "j") (("2" (hide 2 3 4) (("2" (typepred "j") (("2" (hide -2 -3 -4 -5) (("2" (reveal -7) (("2" (replace -1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (reveal -1) (("2" (skeep) (("2" (inst -5 "x") (("2" (ground) (("2" (inst -1 "j") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "relation_remove_constants") (("2" (inst -1 "cons2_var" "cons1_var") (("2" (split -1) (("1" (replaces -1) (("1" (reveal -1) (("1" (split 2) (("1" (flatten 1) (("1" (split 1) (("1" (inst -1 "length(val(remove_constants(cons
                                                 (cons1_var, cons2_var))))
                      - 1") (("1" (case "nth(append(val(remove_constants(cons2_var)),
                             (: cons1_var :)),
                      length(val(remove_constants(cons
                                                  (cons1_var, cons2_var))))
                       - 1) = cons1_var") (("1" (replaces -1) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (hide -6 -7) (("2" (hide -4) (("2" (hide -1 -2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -3) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -7) (("2" (hide -4) (("2" (hide -1) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)" "length(val(remove_constants(cons(cons1_var, cons2_var)))) - 1") (("1" (split -1) (("1" (case "length(val(remove_constants(cons(cons1_var, cons2_var)))) - 1 =
           length(val(remove_constants(cons2_var)))") (("1" (assert) (("1" (replace -1 -2) (("1" (assert) (("1" (hide-all-but (-2 1)) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -2 1) (("2" (hide -1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -1 1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -1 1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replaces -1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (replace -2 1) (("3" (hide-all-but 1) (("3" (lemma "length_append[DNF_Atom]") (("3" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("3" (replace -1 1) (("3" (case "length((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -7) (("2" (inst -4 "x") (("2" (ground) (("2" (hide 1) (("2" (skeep) (("2" (inst -1 "j") (("1" (case "nth(append(val(remove_constants(cons2_var)),
                             (: cons1_var :)),
                      j) = nth(val(remove_constants(cons2_var)), j)") (("1" (assert) nil nil) ("2" (hide 2 3 4) (("2" (hide -1) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)" "j") (("2" (typepred "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4) (("2" (replace -1 1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = length(val(remove_constants(cons(cons1_var, cons2_var)))) - 1") (("1" (hide -2) (("1" (case "nth(append(val(remove_constants(cons2_var)),
                             (: cons1_var :)),
                      j) = cons1_var") (("1" (replaces -1) (("1" (hide-all-but (-2 1)) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (reveal -6 -4) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -3) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide-all-but (-1 1)) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)" "j") (("2" (case "j = length(val(remove_constants(cons2_var)))") (("1" (assert) (("1" (replace -1 -2) (("1" (assert) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -10) (("2" (replace -1 -3) (("2" (hide-all-but (-3 1)) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 -2) (("2" (hide -1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide -1 2) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "j < length(val(remove_constants(cons(cons1_var, cons2_var)))) - 1") (("1" (hide -10) (("1" (inst -7 "x") (("1" (ground) (("1" (inst -1 "j") (("1" (case "nth(append(val(remove_constants(cons2_var)),
                             (: cons1_var :)),
                      j) = nth(val(remove_constants(cons2_var)), j)") (("1" (assert) nil nil) ("2" (hide 2 3 4) (("2" (hide -4) (("2" (hide -1) (("2" (hide-all-but (-2 -5 1)) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)" "j") (("2" (replace -3 -2) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 -3) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 -4) (("1" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4) (("2" (replace -6 -2) (("2" (hide -3) (("2" (hide-all-but (-2 1)) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst -1 "val(remove_constants(cons2_var))" "(: cons1_var :)") (("2" (replace -1 -2) (("2" (hide -1) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 -2) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (expand "remove_constants" -1) (("3" (expand "remove_constants_rec" -1) (("3" (expand "remove_constants" 1) (("3" (expand "remove_constants_rec" 1) (("3" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (skeep) (("2" (hide-all-but 1) (("2" (typepred "remove_constants(cons2_var)") (("2" (split -1) (("1" (inst -1 "j") (("1" (assert) (("1" (flatten -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (hide 2) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" -1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (hide -2 -3) (("3" (expand "remove_constants" -1) (("3" (expand "remove_constants_rec" -1) (("3" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (assert) (("2" (expand "remove_constants" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case " length(val(remove_constants(cons2_var))) = 0") (("1" (hide -4 1) (("1" (case "val(remove_constants(cons(cons1_var, cons2_var))) = (: cons1_var :)") (("1" (replace -1 2) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (replace -1 2) (("1" (hide -1) (("1" (split 2) (("1" (flatten 1) (("1" (split 1) (("1" (inst -1 "0") (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 -2) (("1" (hide -1) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (case "val(remove_constants_rec(cons2_var, null)) = null") (("1" (replace -1 -5) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (expand "remove_constants" -5) (("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -5) (("2" (expand "remove_constants_rec" -5) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "eval_remove_constants") (("2" (inst -1 "x" "cons2_var") (("2" (split -1) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (replace -1 -2) (("1" (case "eval_atm_list(null)(x)") (("1" (hide-all-but (-1 -3 1)) (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "eval_atm_list" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" -1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = 0") (("1" (replace -1 1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants" -7) (("2" (expand "remove_constants_rec" -7) (("2" (expand "remove_constants" -5) (("2" (expand "remove_constants_rec" -5) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (expand "remove_constants" -1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (replace -4 -1) (("2" (hide-all-but (-1 1)) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" (-2 -3 1)) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "cons(cons1_var, null) = (: cons1_var :)") (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case " append(null, (: cons1_var :))= (: cons1_var :)") (("1" (replace -1 -2) (("1" (replace -2 2) (("1" (hide -1 -2) (("1" (case "val(remove_constants_rec(cons2_var, null)) = null") (("1" (replace -1 2) (("1" (hide-all-but 2) (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "append(null, (: cons1_var :))") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (lemma "when_not_none") (("3" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("3" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (skeep) (("3" (hide-all-but 2) (("3" (typepred "to_nat(nth[DNF_Atom]
                              (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("1" (assert) (("1" (reveal 1) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) (("2" (reveal -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (eval_truth formula-decl nil dnf_strategy nil) (satisfiability_relation formula-decl nil dnf_strategy nil) (length_singleton formula-decl nil more_list_props structures) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) nil nil nil (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (sigma def-decl "real" sigma reals) (eval_rel const-decl "bool" dnf_polynomials nil) (eval_atm const-decl "bool" dnf_polynomials nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (TRUE const-decl "bool" booleans nil) (eval_remove_constants formula-decl nil dnf_strategy nil) (when_not_none formula-decl nil dnf_strategy nil) (relation_remove_constants_single formula-decl nil dnf_strategy nil) nil (relation_remove_constants_rec formula-decl nil dnf_strategy nil) (append def-decl "list[T]" list_props nil) (relation_remove_constants_null formula-decl nil dnf_strategy nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (length_append formula-decl nil list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nth_append formula-decl nil more_list_props structures) nil nil (relation_remove_constants formula-decl nil dnf_strategy nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil) (list_induction formula-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (eval_atm_list def-decl "bool" dnf_polynomials nil) (polynomial const-decl "[real -> real]" polynomials reals) (sequence type-eq-decl nil sequences nil) (rel5 const-decl "bool" preprocessing_univariate nil) (subrange type-eq-decl nil integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (to_nat const-decl "upto(5)" poly_system_strategy nil)) nil) (satisfiability_relation_system-13 nil 3772880516 ("" (induct "ll") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (case "cons2_var = null") (("1" (hide -2) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (hide -1) (("1" (replaces -1) (("1" (hide -1) (("1" (case "cons(cons1_var, null) = (: cons1_var :)") (("1" (replaces -1) (("1" (case "val(remove_constants((: cons1_var :))) = (: cons1_var :)") (("1" (replaces -1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replaces -1) (("1" (replaces -1) (("1" (replaces -2) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (replaces -1 1) (("1" (case "(rel5(to_nat(cons1_var`rel))
                              (polynomial(cons1_var`pn, cons1_var`d)(x), 0))
                    IFF (FORALL (j:
                                    upto(length(val(remove_constants(cons
                                                                     (cons1_var, cons2_var))))
                                          - 1)):
                            rel5(to_nat(nth((: cons1_var :), j)`rel))
                                (polynomial(nth((: cons1_var :), j)`pn,
                                            nth((: cons1_var :), j)`d)
                                           (x),
                                 0))") (("1" (ground) nil nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -4) (("2" (split 1) (("1" (flatten 1) (("1" (skeep) (("1" (typepred "j") (("1" (case "j = 0") (("1" (assert) nil nil) ("2" (reveal -10 -8 -7) (("2" (replace -3 -4) (("2" (replace -2 -4) (("2" (replace -1 -4) (("2" (hide-all-but (-4 1)) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (inst -1 "0") (("1" (assert) nil nil) ("2" (assert) (("2" (reveal -11 -9 -8) (("2" (replace -3 1) (("2" (replace -2 1) (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (split 1) (("1" (typepred "to_nat(nth[DNF_Atom]((: cons1_var :), j)`rel)") (("1" (assert) nil nil)) nil) ("2" (typepred "to_nat(nth[DNF_Atom]((: cons1_var :), j)`rel)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (typepred "j") (("4" (reveal -3 -4 -6) (("4" (replace -3 -4) (("4" (replace -2 -4) (("4" (replace -1 -4) (("4" (hide-all-but (-4 1)) (("4" (expand "length") (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (split 2) (("1" (flatten 1) (("1" (inst -1 "0") (("1" (replace -2 -1) (("1" (assert) (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -6) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "eval_atm(cons1_var)(0) ") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal -4 -5 -7) (("2" (replace -3 1) (("2" (replace -2 1) (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = 0") (("1" (replace -1 1) (("1" (replaces -4) (("1" (assert) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (expand "eval_atm_list") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -6) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (reveal -6 -4 -3) (("2" (replace -3 -4) (("2" (replace -2 -4) (("2" (replace -1 -4) (("2" (hide-all-but (-4 1)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -3) (("1" (expand "length" -3) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal -2 -1) (("2" (replaces -1 -2) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "relation_remove_constants_single") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (lemma "relation_remove_constants_null") (("1" (inst -1 "cons2_var" "cons1_var") (("1" (split -1) (("1" (replaces -1) (("1" (split 2) (("1" (flatten 1) (("1" (split 1) (("1" (lemma "satisfiability_relation") (("1" (hide -4 -7) (("1" (expand "remove_constants" -3) (("1" (expand "remove_constants_rec" -3) (("1" (assert) (("1" (case " eval_atm(cons1_var)(0)") (("1" (assert) (("1" (case "cons1_var`d < 1") (("1" (assert) (("1" (hide-all-but (-1 -2 1)) (("1" (expand "eval_atm") (("1" (case "cons1_var`d = 0") (("1" (replace -1 -3) (("1" (replace -1 1) (("1" (expand "polynomial") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 2) (("2" (typepred "cons1_var`d") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide-all-but -4) (("2" (lemma "relation_remove_constants_rec") (("2" (inst -1 "null" "null" "cons1_var") (("2" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (replace -2 -3) (("1" (hide-all-but -3) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (reveal -5) (("2" (expand "remove_constants_rec" 1) (("2" (propax) nil nil)) nil)) nil) ("3" (expand "remove_constants_rec" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -4) (("2" (expand "remove_constants_rec" -4) (("2" (case "cons1_var`d < 1 ") (("1" (assert) nil nil) ("2" (assert) (("2" (hide-all-but -3) (("2" (lemma "relation_remove_constants_rec") (("2" (inst -1 "null" "null" "cons1_var") (("2" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (replace -2 -3) (("1" (hide-all-but -3) (("1" (expand "append") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append") (("2" (propax) nil nil)) nil)) nil) ("2" (expand "remove_constants_rec" 1) (("2" (propax) nil nil)) nil) ("3" (expand "remove_constants_rec" 1) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -3 "x") (("2" (ground) (("2" (hide 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma "relation_remove_constants") (("2" (inst -1 "cons2_var" "cons1_var") (("2" (split -1) (("1" (replaces -1) (("1" (postpone) nil nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (expand "remove_constants" -1) (("3" (expand "remove_constants_rec" -1) (("3" (expand "remove_constants" 1) (("3" (expand "remove_constants_rec" 1) (("3" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (skeep) (("2" (hide-all-but 1) (("2" (typepred "remove_constants(cons2_var)") (("2" (split -1) (("1" (inst -1 "j") (("1" (assert) (("1" (flatten -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (hide 2) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" -1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (hide -2 -3) (("3" (expand "remove_constants" -1) (("3" (expand "remove_constants_rec" -1) (("3" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (assert) (("2" (expand "remove_constants" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case " length(val(remove_constants(cons2_var))) = 0") (("1" (hide -4 1) (("1" (case "val(remove_constants(cons(cons1_var, cons2_var))) = (: cons1_var :)") (("1" (replace -1 2) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (replace -1 2) (("1" (hide -1) (("1" (split 2) (("1" (flatten 1) (("1" (split 1) (("1" (inst -1 "0") (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 -2) (("1" (hide -1) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (case "val(remove_constants_rec(cons2_var, null)) = null") (("1" (replace -1 -5) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (expand "remove_constants" -5) (("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -5) (("2" (expand "remove_constants_rec" -5) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "eval_remove_constants") (("2" (inst -1 "x" "cons2_var") (("2" (split -1) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (replace -1 -2) (("1" (case "eval_atm_list(null)(x)") (("1" (hide-all-but (-1 -3 1)) (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "eval_atm_list" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" -1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = 0") (("1" (replace -1 1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants" -7) (("2" (expand "remove_constants_rec" -7) (("2" (expand "remove_constants" -5) (("2" (expand "remove_constants_rec" -5) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (expand "remove_constants" -1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (replace -4 -1) (("2" (hide-all-but (-1 1)) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" (-2 -3 1)) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "cons(cons1_var, null) = (: cons1_var :)") (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case " append(null, (: cons1_var :))= (: cons1_var :)") (("1" (replace -1 -2) (("1" (replace -2 2) (("1" (hide -1 -2) (("1" (case "val(remove_constants_rec(cons2_var, null)) = null") (("1" (replace -1 2) (("1" (hide-all-but 2) (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "append(null, (: cons1_var :))") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (lemma "when_not_none") (("3" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("3" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (skeep) (("3" (hide-all-but 2) (("3" (typepred "to_nat(nth[DNF_Atom]
                          (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("1" (assert) (("1" (reveal 1) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) (("2" (reveal -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (satisfiability_relation_system-12 nil 3772880166 ("" (induct "ll") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (case "cons2_var = null") (("1" (hide -2) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (hide -1) (("1" (replaces -1) (("1" (hide -1) (("1" (case "cons(cons1_var, null) = (: cons1_var :)") (("1" (replaces -1) (("1" (case "val(remove_constants((: cons1_var :))) = (: cons1_var :)") (("1" (replaces -1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replaces -1) (("1" (replaces -1) (("1" (replaces -2) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (replaces -1 1) (("1" (case "(rel5(to_nat(cons1_var`rel))
                              (polynomial(cons1_var`pn, cons1_var`d)(x), 0))
                    IFF (FORALL (j:
                                    upto(length(val(remove_constants(cons
                                                                     (cons1_var, cons2_var))))
                                          - 1)):
                            rel5(to_nat(nth((: cons1_var :), j)`rel))
                                (polynomial(nth((: cons1_var :), j)`pn,
                                            nth((: cons1_var :), j)`d)
                                           (x),
                                 0))") (("1" (ground) nil nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -4) (("2" (split 1) (("1" (flatten 1) (("1" (skeep) (("1" (typepred "j") (("1" (case "j = 0") (("1" (assert) nil nil) ("2" (reveal -10 -8 -7) (("2" (replace -3 -4) (("2" (replace -2 -4) (("2" (replace -1 -4) (("2" (hide-all-but (-4 1)) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (inst -1 "0") (("1" (assert) nil nil) ("2" (assert) (("2" (reveal -11 -9 -8) (("2" (replace -3 1) (("2" (replace -2 1) (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (split 1) (("1" (typepred "to_nat(nth[DNF_Atom]((: cons1_var :), j)`rel)") (("1" (assert) nil nil)) nil) ("2" (typepred "to_nat(nth[DNF_Atom]((: cons1_var :), j)`rel)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (typepred "j") (("4" (reveal -3 -4 -6) (("4" (replace -3 -4) (("4" (replace -2 -4) (("4" (replace -1 -4) (("4" (hide-all-but (-4 1)) (("4" (expand "length") (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (split 2) (("1" (flatten 1) (("1" (inst -1 "0") (("1" (replace -2 -1) (("1" (assert) (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -6) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "eval_atm(cons1_var)(0) ") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal -4 -5 -7) (("2" (replace -3 1) (("2" (replace -2 1) (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = 0") (("1" (replace -1 1) (("1" (replaces -4) (("1" (assert) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (expand "eval_atm_list") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -6) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (reveal -6 -4 -3) (("2" (replace -3 -4) (("2" (replace -2 -4) (("2" (replace -1 -4) (("2" (hide-all-but (-4 1)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -3) (("1" (expand "length" -3) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal -2 -1) (("2" (replaces -1 -2) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (skeep) (("3" (split 1) (("1" (typepred "to_nat(nth[DNF_Atom]
                  (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("1" (assert) nil nil)) nil) ("2" (typepred "to_nat(nth[DNF_Atom]
                  (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (satisfiability_relation_system-11 nil 3772818607 ("" (induct "ll") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (case "cons2_var = null") (("1" (hide -2) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (hide -1) (("1" (replaces -1) (("1" (hide -1) (("1" (case "cons(cons1_var, null) = (: cons1_var :)") (("1" (replaces -1) (("1" (case "val(remove_constants((: cons1_var :))) = (: cons1_var :)") (("1" (replaces -1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replaces -1) (("1" (replaces -1) (("1" (replaces -2) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (replaces -1 1) (("1" (case "(rel5(to_nat(cons1_var`rel))
           (polynomial(cons1_var`pn, cons1_var`d)(x), 0))
 IFF (FORALL (j:
                 upto(length(val(remove_constants(cons
                                                  (cons1_var, cons2_var))))
                       - 1)):
         rel5(to_nat(nth((: cons1_var :), j)`rel))
             (polynomial(nth((: cons1_var :), j)`pn,
                         nth((: cons1_var :), j)`d)
                        (x),
              0))") (("1" (ground) nil nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -4) (("2" (split 1) (("1" (flatten 1) (("1" (skeep) (("1" (typepred "j") (("1" (case "j = 0") (("1" (assert) nil nil) ("2" (reveal -10 -8 -7) (("2" (replace -3 -4) (("2" (replace -2 -4) (("2" (replace -1 -4) (("2" (hide-all-but (-4 1)) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (inst -1 "0") (("1" (assert) nil nil) ("2" (assert) (("2" (reveal -11 -9 -8) (("2" (replace -3 1) (("2" (replace -2 1) (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (split 1) (("1" (typepred "to_nat(nth[DNF_Atom]((: cons1_var :), j)`rel)") (("1" (assert) nil nil)) nil) ("2" (typepred "to_nat(nth[DNF_Atom]((: cons1_var :), j)`rel)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (typepred "j") (("4" (reveal -3 -4 -6) (("4" (replace -3 -4) (("4" (replace -2 -4) (("4" (replace -1 -4) (("4" (hide-all-but (-4 1)) (("4" (expand "length") (("4" (expand "length") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (split 2) (("1" (flatten 1) (("1" (inst -1 "0") (("1" (replace -2 -1) (("1" (assert) (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -6) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "eval_atm(cons1_var)(0) ") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal -4 -5 -7) (("2" (replace -3 1) (("2" (replace -2 1) (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = 0") (("1" (replace -1 1) (("1" (replaces -4) (("1" (assert) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (expand "eval_atm_list") (("1" (assert) nil nil)) nil)) nil) ("2" (reveal -6) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (reveal -6 -4 -3) (("2" (replace -3 -4) (("2" (replace -2 -4) (("2" (replace -1 -4) (("2" (hide-all-but (-4 1)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -3) (("1" (expand "length" -3) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal -2 -1) (("2" (replaces -1 -2) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split 2) (("1" (flatten 1) (("1" (split 1) (("1" (postpone) nil nil) ("2" (inst -3 "x") (("2" (case "(FORALL (j: upto(length(val(remove_constants(cons2_var))) - 1)):
         rel5(to_nat(nth(val(remove_constants(cons2_var)), j)`rel))
             (polynomial(nth(val(remove_constants(cons2_var)), j)`pn,
                         nth(val(remove_constants(cons2_var)), j)`d)
                        (x),
              0))") (("1" (assert) nil nil) ("2" (hide 2 3) (("2" (hide -2 -3) (("2" (skeep) (("2" (inst -1 "j") (("1" (assert) (("1" (case "nth(val(remove_constants(cons(cons1_var, cons2_var))),
                      j) = nth(val(remove_constants(cons2_var)), j)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (typepred "j") (("2" (hide -2 -5) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants" 1) (("1" (case "val(remove_constants_rec(cons(cons1_var, cons2_var), null)) = val(remove_constants_rec(cons2_var, null))") (("1" (replace -1 1) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (case "remove_constants_rec(cons2_var, null) = remove_constants(cons2_var)") (("1" (replace -1 1) (("1" (expand "remove_constants_rec" 1) (("1" (expand "remove_constants" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "remove_constants") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" 2) (("2" (case "remove_constants_rec(cons2_var, null) = remove_constants(cons2_var)") (("1" (replace -1 2) (("1" (expand "remove_constants_rec" 2) (("1" (case "cons(cons1_var, null) = (: cons1_var :)") (("1" (replace -1 2) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case "append(null, (: cons1_var :)) = (: cons1_var :)") (("1" (replace -1 -2) (("1" (replace -2 2) (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst -1 "val(remove_constants_rec(cons2_var, null))" "(: cons1_var :)" "j") (("1" (split -1) (("1" (assert) nil nil) ("2" (hide 2 3) (("2" (hide-all-but (-5 1)) (("2" (case "length((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (expand "remove_constants") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (postpone) nil nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "remove_constants") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "j") (("2" (hide -3 -4) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants" -3) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -3) (("2" (expand "remove_constants_rec" -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "relation_remove_constants_rec") (("2" (inst -1 "cons2_var" "null" "cons1_var") (("2" (split -1) (("1" (case "append(null, (: cons1_var :)) = cons(cons1_var, null)") (("1" (replace -1 -2) (("1" (replace -2 2) (("1" (lemma "length_append[DNF_Atom]") (("1" (inst -1 "val(remove_constants_rec(cons2_var, null))" "(: cons1_var :)") (("1" (replace -1 2) (("1" (hide-all-but (-4 2)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "append(null, (: cons1_var :))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (expand "remove_constants" -1) (("3" (expand "remove_constants_rec" -1) (("3" (lemma "when_not_none") (("3" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (split 1) (("1" (typepred "to_nat(nth[DNF_Atom]
                  (val[list[DNF_Atom]](remove_constants(cons2_var)), j)`rel)
") (("1" (assert) nil nil)) nil) ("2" (typepred "to_nat(nth[DNF_Atom]
                  (val[list[DNF_Atom]](remove_constants(cons2_var)), j)`rel)
") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-4 1)) (("4" (expand "remove_constants" -1) (("4" (expand "remove_constants_rec" -1) (("4" (expand "remove_constants" 1) (("4" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (skeep) (("2" (hide-all-but 1) (("2" (typepred "remove_constants(cons2_var)") (("2" (split -1) (("1" (inst -1 "j") (("1" (assert) (("1" (flatten -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -1) (("2" (hide 2) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" -1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (hide -2 -3) (("3" (expand "remove_constants" -1) (("3" (expand "remove_constants_rec" -1) (("3" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (assert) (("2" (expand "remove_constants" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case " length(val(remove_constants(cons2_var))) = 0") (("1" (hide -4 1) (("1" (case "val(remove_constants(cons(cons1_var, cons2_var))) = (: cons1_var :)") (("1" (replace -1 2) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (replace -1 2) (("1" (hide -1) (("1" (split 2) (("1" (flatten 1) (("1" (split 1) (("1" (inst -1 "0") (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 -2) (("1" (hide -1) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec" -2) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (case "val(remove_constants_rec(cons2_var, null)) = null") (("1" (replace -1 -5) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (expand "remove_constants" -5) (("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants" -5) (("2" (expand "remove_constants_rec" -5) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (lemma "eval_remove_constants") (("2" (inst -1 "x" "cons2_var") (("2" (split -1) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (replace -1 -2) (("1" (case "eval_atm_list(null)(x)") (("1" (hide-all-but (-1 -3 1)) (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "eval_atm_list" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" -1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = 0") (("1" (replace -1 1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 1) (("1" (hide -1) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants" -7) (("2" (expand "remove_constants_rec" -7) (("2" (expand "remove_constants" -5) (("2" (expand "remove_constants_rec" -5) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (expand "remove_constants" -1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (replace -4 -1) (("2" (hide-all-but (-1 1)) (("2" (expand "length") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" (-2 -3 1)) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (case "cons(cons1_var, null) = (: cons1_var :)") (("1" (replace -1 2) (("1" (hide -1) (("1" (lemma "relation_remove_constants_rec") (("1" (inst -1 "cons2_var" "null" "cons1_var") (("1" (split -1) (("1" (case " append(null, (: cons1_var :))= (: cons1_var :)") (("1" (replace -1 -2) (("1" (replace -2 2) (("1" (hide -1 -2) (("1" (case "val(remove_constants_rec(cons2_var, null)) = null") (("1" (replace -1 2) (("1" (hide-all-but 2) (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "append") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "append(null, (: cons1_var :))") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-2 1)) (("3" (lemma "when_not_none") (("3" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("3" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (skeep) (("3" (hide-all-but 2) (("3" (typepred "to_nat(nth[DNF_Atom]
                      (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("1" (assert) (("1" (reveal 1) (("1" (assert) nil nil)) nil)) nil) ("2" (grind) (("2" (reveal -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (satisfiability_relation_system-10 nil 3772812277 ("" (induct "ll") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (case "cons2_var = null") (("1" (hide -2) (("1" (lemma "eval_truth") (("1" (inst -1 "x" "cons2_var" "cons1_var") (("1" (hide -1) (("1" (replaces -1) (("1" (hide -1) (("1" (case "cons(cons1_var, null) = (: cons1_var :)") (("1" (replaces -1) (("1" (case "val(remove_constants((: cons1_var :))) = (: cons1_var :)") (("1" (replaces -1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replaces -1) (("1" (replaces -1) (("1" (replaces -2) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (postpone) nil nil)) nil)) nil) ("2" (hide -3) (("2" (split 2) (("1" (flatten 1) (("1" (inst -1 "0") (("1" (replace -2 -1) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil) ("2" (assert) (("2" (reveal -4 -5 -7) (("2" (replace -3 1) (("2" (replace -2 1) (("2" (replace -1 1) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (typepred "j") (("2" (case "j = 0") (("1" (replace -1 1) (("1" (replaces -4) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (reveal -6 -4 -3) (("2" (replace -3 -4) (("2" (replace -2 -4) (("2" (replace -1 -4) (("2" (hide-all-but (-4 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -3) (("1" (expand "length" -3) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (reveal -2 -1) (("2" (replaces -1 -2) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (skeep) (("3" (hide-all-but 2) (("3" (typepred "to_nat(nth[DNF_Atom]
                  (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("1" (assert) (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (satisfiability_relation_system-9 nil 3772810827 ("" (induct "ll") (("1" (grind) nil nil) ("2" (skeep) (("2" (case "cons2_var = null") (("1" (replace -1 1) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (hide -2) (("1" (replace -1 -2) (("1" (case "cons(cons1_var, cons2_var) = (: cons1_var :)") (("1" (replace -1 -4) (("1" (case "some?(remove_constants((: cons1_var :)))") (("1" (hide -4) (("1" (lemma "satisfiability_relation") (("1" (hide -1) (("1" (case " length(val(remove_constants((: cons1_var :)))) = 1") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (skeep*) (("1" (split -1) (("1" (inst -1 "x") (("1" (case "(rel5(to_nat(nth(val(remove_constants(cons(cons1_var, null))),
                                                                                                                                                       0)`rel))
                                                                                                                                           (polynomial(nth(val(remove_constants
                                                                                                                                                                    (cons(cons1_var, null))),
                                                                                                                                                                0)`pn,
                                                                                                                                                       nth(val(remove_constants
                                                                                                                                                                   (cons(cons1_var, null))),
                                                                                                                                                               0)`d)
                                                                                                                                                      (x),
                                                                                                                                            0))
                                                                                                                                     IFF eval_atm(cons1_var)(x)") (("1" (hide 1) (("1" (hide -3 -4 -5 -6 -7 -8) (("1" (hide -2) (("1" (split 1) (("1" (flatten 1) (("1" (reveal -2) (("1" (inst -2 "0") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (assert) (("2" (skeep 1) (("2" (typepred "j") (("2" (reveal -2) (("2" (case "j = 0") (("1" (postpone) nil nil) ("2" (hide 2) (("2" (hide -4) (("2" (expand "remove_constants" -1) (("2" (reveal -4) (("2" (replace -1 -3) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (case "val(remove_constants(cons(cons1_var, null))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (hide 2) (("1" (case " nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -1) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (hide-all-but -7) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (split 1) (("1" (typepred "to_nat(nth[DNF_Atom]
                  (val[list[DNF_Atom]]
                       (remove_constants(cons[DNF_Atom]
                                         (cons1_var, null[DNF_Atom]))),
                   0)`rel)") (("1" (assert) nil nil)) nil) ("2" (typepred "to_nat(nth[DNF_Atom]
                  (val[list[DNF_Atom]]
                       (remove_constants(cons[DNF_Atom]
                                         (cons1_var, null[DNF_Atom]))),
                   0)`rel)") (("2" (propax) nil nil)) nil)) nil)) nil) ("4" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2 -3 -5) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2 -3 -4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "eval_truth") (("2" (inst? -1) (("2" (hide -1) (("2" (split -1) (("1" (lemma "relation_remove_constants_single") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (lemma relation_remove_constants_null) (("1" (inst -1 "cons2_var" "cons1_var") (("1" (split -1) (("1" (lemma "eval_remove_constants") (("1" (postpone) nil nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma relation_remove_constants) (("2" (inst -1 "cons2_var" "cons1_var") (("2" (split -1) (("1" (replace -1 2) (("1" (postpone) nil nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (hide -3 -4) (("3" (hide -1) (("3" (expand "remove_constants") (("3" (expand "remove_constants_rec") (("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil) nil nil) (satisfiability_relation_system-8 nil 3772810689 ("" (induct "ll") (("1" (grind) nil) ("2" (skeep) (("2" (case "cons2_var = null") (("1" (replace -1 1) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (hide -2) (("1" (replace -1 -4) (("1" (replace -1 -2) (("1" (case "cons(cons1_var, cons2_var) = (: cons1_var :)") (("1" (replace -1 -4) (("1" (case "some?(remove_constants((: cons1_var :)))") (("1" (hide -4) (("1" (lemma "satisfiability_relation") (("1" (hide -1) (("1" (case " length(val(remove_constants((: cons1_var :)))) = 1") (("1" (inst -6 "0") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (skeep*) (("1" (split -1) (("1" (inst -1 "x") (("1" (case "(rel5(to_nat(nth(val(remove_constants(cons(cons1_var, null))),
                                                                                                                                  0)`rel))
                                                                                                                      (polynomial(nth(val(remove_constants
                                                                                                                                               (cons(cons1_var, null))),
                                                                                                                                           0)`pn,
                                                                                                                                  nth(val(remove_constants
                                                                                                                                              (cons(cons1_var, null))),
                                                                                                                                          0)`d)
                                                                                                                                 (x),
                                                                                                                       0))
                                                                                                                IFF eval_atm(cons1_var)(x)") (("1" (hide 1) (("1" (hide -3 -4 -5 -6 -7 -8) (("1" (hide -2) (("1" (split 1) (("1" (flatten 1) (("1" (reveal -2) (("1" (inst -2 "0") (("1" (grind) nil) ("2" (hide -2 2) (("2" (reveal -6) (("2" (replace -1 1) (("2" (case "cons[DNF_Atom](cons1_var, null) = (: cons1_var :)") (("1" (replace -1 1) (("1" (assert) nil))) ("2" (propax) nil))))))))))))))) ("2" (flatten 1) (("2" (assert) (("2" (skeep 1) (("2" (typepred "j") (("2" (reveal -2) (("2" (case "j = 0") (("1" (replace -1 1) (("1" (propax) nil))) ("2" (hide 2) (("2" (hide -4) (("2" (expand "remove_constants" -1) (("2" (reveal -4) (("2" (replace -1 -3) (("2" (grind) nil))))))))))))))))))))))))))))))) ("2" (hide 3) (("2" (case "val(remove_constants(cons(cons1_var, null))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (replace -1 -2) (("1" (hide 2) (("1" (case " nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 1) (("1" (assert) (("1" (replace -1 -3) (("1" (propax) nil))))))) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil))))))))))))) ("2" (hide 2 3) (("2" (hide -1) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (hide-all-but -7) (("1" (grind) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil))))))))))))))))))))))) ("2" (propax) nil))))))))) ("2" (hide 2) (("2" (assert) nil))))) ("2" (hide 2) (("2" (hide -2 -3 -5) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (grind) nil))) ("2" (assert) nil))))))))))))))))))))))) ("2" (propax) nil))))) ("2" (hide 2) (("2" (hide -2 -3 -4) (("2" (grind) nil))))))))))))))))))) ("2" (skeep) (("2" (lemma "eval_truth") (("2" (inst? -1) (("2" (replace -1 2) (("2" (hide -1) (("2" (split -1) (("1" (inst -1 "x") (("1" (lemma "relation_remove_constants_single") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (lemma relation_remove_constants_null) (("1" (inst -1 "cons2_var" "cons1_var") (("1" (split -1) (("1" (lemma "eval_remove_constants") (("1" (inst -1 "x" "(: cons1_var :)") (("1" (split -1) (("1" (case "eval_atm(cons1_var)(x) = TRUE") (("1" (assert) (("1" (hide-all-but 2) (("1" (reveal -5) (("1" (reveal -3) (("1" (ground) (("1" (skeep) (("1" (inst -2 "j") (("1" (replace -4 1) (("1" (propax) nil))))))) ("2" (skeep) (("2" (inst -1 "j") (("2" (replace -2 -1) (("2" (propax) nil))))))))))))))))) ("2" (hide 2 3) (("2" (hide -7) (("2" (hide -4 -5 -6) (("2" (replace -3 -1) (("2" (grind) nil))))))))))) ("2" (hide 2 3) (("2" (hide -5 -6) (("2" (hide -1 -2 -3) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (propax) nil))))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil))))))))))))))))))))))))))) ("2" (propax) nil) ("3" (propax) nil))))))) ("2" (lemma relation_remove_constants) (("2" (inst -1 "cons2_var" "cons1_var") (("2" (split -1) (("1" (replace -1 2) (("1" (split 2) (("1" (flatten 1) (("1" (case "(FORALL (j: upto(length(val(remove_constants(cons2_var))) - 1)):
                                                                                                        rel5(to_nat(nth(val(remove_constants(cons2_var)), j)`rel))
                                                                                                            (polynomial(nth(val(remove_constants(cons2_var)),
                                                                                                                                 j)`pn,
                                                                                                                        nth(val(remove_constants(cons2_var)),
                                                                                                                                j)`d))
                                                                                                                       (x),
                                                                                                             0)") (("1" (assert) (("1" (ground) (("1" (hide-all-but -4) (("1" (reveal 1) (("1" (inst -1 "length(val(remove_constants(cons
                                                                                                                                 (cons1_var, cons2_var))))
                                                                                                      - 1") (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (reveal -5) (("1" (replace -1 -2) (("1" (case "nth(append(val(remove_constants(cons2_var)), (: cons1_var :)),
                                                                                                                             length(append(val(remove_constants(cons2_var)), (: cons1_var :)))
                                                                                                                              - 1) = cons1_var") (("1" (hide -3) (("1" (replace -2 -3) (("1" (replace -1 -3) (("1" (hide -1 -2) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil))) ("2" (reveal -9) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (assert) (("2" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -2) (("1" (propax) nil))))) ("2" (assert) (("2" (reveal -10) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil))))))))))))))))))))))))))))))))) ("2" (hide 2) (("2" (hide -3) (("2" (hide -1) (("2" (case "length(append(val(remove_constants(cons2_var)), (: cons1_var :)))
                                                                                                                                        - 1
                                                                                                                                        < length(val(remove_constants(cons2_var)))") (("1" (hide-all-but -1) (("1" (lemma length_append[DNF_Atom]) (("1" (inst?) (("1" (replace -1 -2) (("1" (grind) nil))))))))) ("2" (assert) (("2" (hide 1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (simplify) (("2" (hide -1) (("2" (case "length[DNF_Atom]((: cons1_var :)) - 1 = 0") (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 -2) (("1" (assert) (("1" (hide -1) (("1" (lemma "length_append[DNF_Atom]") (("1" (inst?) (("1" (replace -1 1) (("1" (hide -1) (("1" (case "length[DNF_Atom]((: cons1_var :))
                                                                                                                                                                      - 1 = 0") (("1" (assert) nil) ("2" (hide 2) (("2" (hide -1) (("2" (grind) nil))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil))))))))))) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil))))))))))))))))))))))))))))))))))))) ("2" (hide -1) (("2" (lemma length_append[DNF_Atom]) (("2" (reveal -6) (("2" (replace -1 1) (("2" (inst?) (("2" (replace -2 1) (("2" (assert) nil))))))))))))))))))))))))))))))) ("2" (hide 2 3) (("2" (hide -2 -3 -4 -5 -6) (("2" (hide -2) (("2" (skeep) (("2" (inst -1 "j") (("1" (assert) (("1" (typepred "j") (("1" (lemma nth_append[DNF_Atom]) (("1" (inst?) (("1" (split -1) (("1" (assert) nil) ("2" (assert) nil))))))))))) ("2" (assert) (("2" (typepred "j") (("2" (hide 2) (("2" (reveal -3) (("2" (replace -1 1) (("2" (hide -1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) (("2" (replace -1 1) (("2" (assert) nil))))))))))))))))))))))))))))) ("3" (hide-all-but 1) (("3" (skeep) (("3" (grind) nil))))))))) ("2" (flatten 1) (("2" (skeep) (("2" (case "j <= length(val(remove_constants(cons2_var))) - 1") (("1" (assert) (("1" (inst -7 "j") (("1" (assert) (("1" (lemma nth_append[DNF_Atom]) (("1" (inst?) (("1" (split -1) (("1" (assert) nil) ("2" (hide 2 3) (("2" (assert) nil))))))))))))))) ("2" (hide 2 3) (("2" (assert) (("2" (case "j = length(val(remove_constants(cons(cons1_var, cons2_var))))- 1") (("1" (hide -6 -10) (("1" (reveal 1) (("1" (hide -2) (("1" (hide 2) (("1" (case "nth(append(val(remove_constants(cons2_var)), (: cons1_var :)), j) = cons1_var") (("1" (replace -1 1) (("1" (lemma "satisfiability_relation") (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil))) ("2" (hide 2) (("2" (hide -1 -2 -3 -4 -6 -7 -8) (("2" (typepred "remove_constants((: cons1_var :))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -2 -1) (("1" (hide -2) (("1" (expand "nth" -1) (("1" (assert) nil))))))) ("2" (grind) nil))) ("2" (reveal -6) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -4) (("1" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) nil))))))))))))))))))))))))) ("2" (hide 2) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst?) (("2" (split -1) (("1" (assert) (("1" (replace -2 -1) (("1" (lemma length_append[DNF_Atom]) (("1" (inst?) (("1" (replace -3 1) (("1" (replace -2 1) (("1" (replace -5 1) (("1" (replace -1 1) (("1" (hide-all-but 1) (("1" (simplify) (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (propax) nil))))))))))))))))))))))))))) ("2" (hide 2) (("2" (replace -3 -1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (replace -2 1) (("2" (simplify) (("2" (hide-all-but 1) (("2" (case "length[DNF_Atom]((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil))) ("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (propax) nil))))))))))))))))))))))))))))))))))))))))) ("2" (hide -7 -9) (("2" (hide -5 -6) (("2" (typepred "j") (("2" (replace -4 -1) (("2" (replace -4 1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (replace -1 1) (("2" (hide -1) (("2" (hide -2 -3 -4 -5 -6) (("2" (case "length[DNF_Atom]((: cons1_var :)) = 1") (("1" (replace -1 -2) (("1" (replace -1 1) (("1" (simplify) (("1" (assert) nil))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))))))))))))))))))))))))))))))))))))))))) ("2" (propax) nil) ("3" (propax) nil))))))) ("3" (hide 2 3) (("3" (hide -3 -4) (("3" (hide -1) (("3" (expand "remove_constants") (("3" (expand "remove_constants_rec") (("3" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil))))))))))))))))))))))))) ("2" (hide 2 3) (("2" (skeep) (("2" (hide -2 -3) (("2" (typepred "remove_constants(cons2_var)") (("2" (split -1) (("1" (inst -1 "j") (("1" (split 1) (("1" (typepred " deg(nth(val(remove_constants(cons2_var)), j)`plist)") (("1" (hide -1 -2 -3 -4) (("1" (split -1) (("1" (lemma "list2array_sound[rat]") (("1" (inst?) (("1" (assert) nil))))) ("2" (assert) nil))))))) ("2" (assert) nil))))) ("2" (hide 2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil))))))))))))))))))))))))))) ("3" (hide 3) (("3" (hide -2 -3) (("3" (expand "remove_constants") (("3" (expand "remove_constants_rec" -1) (("3" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil))))))))))))))))))) ("4" (case "length(val(remove_constants(cons2_var))) = 0") (("1" (hide 1) (("1" (lemma "eval_remove_constants") (("1" (inst?) (("1" (split -1) (("1" (hide -5) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (replace -1 -2) (("1" (case "(FORALL (j:
                                                                                                                upto(length(val(remove_constants(cons
                                                                                                                                                 (cons1_var, cons2_var))))
                                                                                                                      - 1)):
                                                                                                        rel5(to_nat(nth(val(remove_constants(cons(cons1_var, cons2_var))),
                                                                                                                        j)`rel))
                                                                                                            (polynomial(nth(val(remove_constants
                                                                                                                                     (cons(cons1_var, cons2_var))),
                                                                                                                                 j)`pn,
                                                                                                                        nth(val(remove_constants
                                                                                                                                    (cons(cons1_var, cons2_var))),
                                                                                                                                j)`d)
                                                                                                                       (x),
                                                                                                             0))
                                                                                                      IFF (eval_atm(cons1_var)(x) AND eval_atm_list(null)(x))") (("1" (ground) nil) ("2" (hide 3) (("2" (case "eval_atm_list(null)(x) = TRUE") (("1" (assert) (("1" (case "val(remove_constants(cons(cons1_var, cons2_var))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (split 1) (("1" (flatten 1) (("1" (inst -1 "0") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (hide -2 -3 -4 -5 -6 -7 -8 -9 2) (("1" (expand "nth") (("1" (propax) nil))))))))) ("2" (typepred "remove_constants(cons(cons1_var, cons2_var))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -3 -1) (("1" (assert) nil))))) ("2" (propax) nil))))))))))))))) ("2" (flatten 1) (("2" (skeep) (("2" (case "j = 0") (("1" (replace -1 1) (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "nth" 1) (("1" (propax) nil))))))) ("2" (typepred "remove_constants(cons(cons1_var, cons2_var))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -4 -1) (("1" (assert) nil))))) ("2" (propax) nil))))))))))))) ("2" (hide 2 3) (("2" (typepred "j") (("2" (replace -3 -1) (("2" (hide -2 -3 -4 -5 -6 -7 -8 -9) (("2" (grind) nil))))))))))))))))))) ("2" (hide 2) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants" -8) (("1" (expand "remove_constants_rec" -8) (("1" (expand "remove_constants" -4) (("1" (replace -4 -8) (("1" (hide-all-but -8) (("1" (grind) nil))))))))))))) ("2" (expand "remove_constants" -6) (("2" (expand "remove_constants_rec" -6) (("2" (assert) nil))))))))) ("2" (assert) (("2" (lemma relation_remove_constants_rec) (("2" (inst -1 "cons2_var" "null" "cons1_var") (("2" (split -1) (("1" (expand "remove_constants" -3) (("1" (replace -3 -1) (("1" (expand "append" -1) (("1" (propax) nil))))))) ("2" (expand "append" 1) (("2" (hide -1 -2 -3 -4 -6) (("2" (hide 2 3 4) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil))))))))))) ("3" (hide -1 -2 -3 -4 -6) (("3" (hide 2 3 4) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (expand "remove_constants" -2) (("3" (expand "remove_constants_rec" -2) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil))))))))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "eval_atm_list") (("2" (propax) nil))))))))) ("3" (hide-all-but 1) (("3" (skeep) (("3" (grind) nil))))))))) ("2" (hide 2 3) (("2" (hide -1 -3 -4) (("2" (grind) nil))))))))) ("2" (hide 2 3) (("2" (hide -3 -4) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants") (("2" (hide -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil))))))))))))))))))))))))))))))) ("2" (hide 3 4) (("2" (hide -1 -2 -3) (("2" (assert) nil))))))))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (typepred "to_nat(nth[DNF_Atom]
                                              (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("3" (split 1) (("1" (assert) nil) ("2" (propax) nil)))))))))))) nil) nil nil) (satisfiability_relation_system-7 nil 3772810641 ("" (induct "ll") (("1" (grind) nil) ("2" (skeep) (("2" (skeep) (("2" (case "cons2_var = null") (("1" (replace -1 1) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (hide -2) (("1" (replace -1 -4) (("1" (replace -1 -2) (("1" (case "cons(cons1_var, cons2_var) = (: cons1_var :)") (("1" (replace -1 -4) (("1" (case "some?(remove_constants((: cons1_var :)))") (("1" (hide -4) (("1" (lemma "satisfiability_relation") (("1" (hide -1) (("1" (case " length(val(remove_constants((: cons1_var :)))) = 1") (("1" (inst -6 "0") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (skeep*) (("1" (split -1) (("1" (inst -1 "x") (("1" (case "(rel5(to_nat(nth(val(remove_constants(cons(cons1_var, null))),
                                                                                                             0)`rel))
                                                                                                 (polynomial(nth(val(remove_constants
                                                                                                                          (cons(cons1_var, null))),
                                                                                                                      0)`pn,
                                                                                                             nth(val(remove_constants
                                                                                                                         (cons(cons1_var, null))),
                                                                                                                     0)`d)
                                                                                                            (x),
                                                                                                  0))
                                                                                           IFF eval_atm(cons1_var)(x)") (("1" (hide 1) (("1" (hide -3 -4 -5 -6 -7 -8) (("1" (hide -2) (("1" (split 1) (("1" (flatten 1) (("1" (reveal -2) (("1" (inst -2 "0") (("1" (grind) nil) ("2" (hide -2 2) (("2" (reveal -6) (("2" (replace -1 1) (("2" (case "cons[DNF_Atom](cons1_var, null) = (: cons1_var :)") (("1" (replace -1 1) (("1" (assert) nil))) ("2" (propax) nil))))))))))))))) ("2" (flatten 1) (("2" (assert) (("2" (skeep 1) (("2" (typepred "j") (("2" (reveal -2) (("2" (case "j = 0") (("1" (replace -1 1) (("1" (propax) nil))) ("2" (hide 2) (("2" (hide -4) (("2" (expand "remove_constants" -1) (("2" (reveal -4) (("2" (replace -1 -3) (("2" (grind) nil))))))))))))))))))))))))))))))) ("2" (hide 3) (("2" (case "val(remove_constants(cons(cons1_var, null))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (replace -1 -2) (("1" (hide 2) (("1" (case " nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 1) (("1" (assert) (("1" (replace -1 -3) (("1" (propax) nil))))))) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil))))))))))))) ("2" (hide 2 3) (("2" (hide -1) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (hide-all-but -7) (("1" (grind) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil))))))))))))))))))))))) ("2" (propax) nil))))))))) ("2" (hide 2) (("2" (assert) nil))))) ("2" (hide 2) (("2" (hide -2 -3 -5) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (grind) nil))) ("2" (assert) nil))))))))))))))))))))))) ("2" (propax) nil))))) ("2" (hide 2) (("2" (hide -2 -3 -4) (("2" (grind) nil))))))))))))))))))) ("2" (skeep) (("2" (lemma "eval_truth") (("2" (inst? -1) (("2" (replace -1 2) (("2" (hide -1) (("2" (split -1) (("1" (inst -1 "x") (("1" (lemma "relation_remove_constants_single") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (lemma relation_remove_constants_null) (("1" (inst -1 "cons2_var" "cons1_var") (("1" (split -1) (("1" (lemma "eval_remove_constants") (("1" (inst -1 "x" "(: cons1_var :)") (("1" (split -1) (("1" (case "eval_atm(cons1_var)(x) = TRUE") (("1" (assert) (("1" (hide-all-but 2) (("1" (reveal -5) (("1" (reveal -3) (("1" (ground) (("1" (skeep) (("1" (inst -2 "j") (("1" (replace -4 1) (("1" (propax) nil))))))) ("2" (skeep) (("2" (inst -1 "j") (("2" (replace -2 -1) (("2" (propax) nil))))))))))))))))) ("2" (hide 2 3) (("2" (hide -7) (("2" (hide -4 -5 -6) (("2" (replace -3 -1) (("2" (grind) nil))))))))))) ("2" (hide 2 3) (("2" (hide -5 -6) (("2" (hide -1 -2 -3) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (propax) nil))))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil))))))))))))))))))))))))))) ("2" (propax) nil) ("3" (propax) nil))))))) ("2" (lemma relation_remove_constants) (("2" (inst -1 "cons2_var" "cons1_var") (("2" (split -1) (("1" (replace -1 2) (("1" (split 2) (("1" (flatten 1) (("1" (case "(FORALL (j: upto(length(val(remove_constants(cons2_var))) - 1)):
                                                                                     rel5(to_nat(nth(val(remove_constants(cons2_var)), j)`rel))
                                                                                         (polynomial(nth(val(remove_constants(cons2_var)),
                                                                                                              j)`pn,
                                                                                                     nth(val(remove_constants(cons2_var)),
                                                                                                             j)`d))
                                                                                                    (x),
                                                                                          0)") (("1" (assert) (("1" (ground) (("1" (hide-all-but -4) (("1" (reveal 1) (("1" (inst -1 "length(val(remove_constants(cons
                                                                                                                 (cons1_var, cons2_var))))
                                                                                      - 1") (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (reveal -5) (("1" (replace -1 -2) (("1" (case "nth(append(val(remove_constants(cons2_var)), (: cons1_var :)),
                                                                                                      length(append(val(remove_constants(cons2_var)), (: cons1_var :)))
                                                                                                       - 1) = cons1_var") (("1" (hide -3) (("1" (replace -2 -3) (("1" (replace -1 -3) (("1" (hide -1 -2) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil))) ("2" (reveal -9) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (assert) (("2" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -2) (("1" (propax) nil))))) ("2" (assert) (("2" (reveal -10) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil))))))))))))))))))))))))))))))))) ("2" (hide 2) (("2" (hide -3) (("2" (hide -1) (("2" (case "length(append(val(remove_constants(cons2_var)), (: cons1_var :)))
                                                                                                               - 1
                                                                                                               < length(val(remove_constants(cons2_var)))") (("1" (hide-all-but -1) (("1" (lemma length_append[DNF_Atom]) (("1" (inst?) (("1" (replace -1 -2) (("1" (grind) nil))))))))) ("2" (assert) (("2" (hide 1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (simplify) (("2" (hide -1) (("2" (case "length[DNF_Atom]((: cons1_var :)) - 1 = 0") (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 -2) (("1" (assert) (("1" (hide -1) (("1" (lemma "length_append[DNF_Atom]") (("1" (inst?) (("1" (replace -1 1) (("1" (hide -1) (("1" (case "length[DNF_Atom]((: cons1_var :))
                                                                                                                                       - 1 = 0") (("1" (assert) nil) ("2" (hide 2) (("2" (hide -1) (("2" (grind) nil))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil))))))))))) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil))))))))))))))))))))))))))))))))))))) ("2" (hide -1) (("2" (lemma length_append[DNF_Atom]) (("2" (reveal -6) (("2" (replace -1 1) (("2" (inst?) (("2" (replace -2 1) (("2" (assert) nil))))))))))))))))))))))))))))))) ("2" (hide 2 3) (("2" (hide -2 -3 -4 -5 -6) (("2" (hide -2) (("2" (skeep) (("2" (inst -1 "j") (("1" (assert) (("1" (typepred "j") (("1" (lemma nth_append[DNF_Atom]) (("1" (inst?) (("1" (split -1) (("1" (assert) nil) ("2" (assert) nil))))))))))) ("2" (assert) (("2" (typepred "j") (("2" (hide 2) (("2" (reveal -3) (("2" (replace -1 1) (("2" (hide -1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) (("2" (replace -1 1) (("2" (assert) nil))))))))))))))))))))))))))))) ("3" (hide-all-but 1) (("3" (skeep) (("3" (grind) nil))))))))) ("2" (flatten 1) (("2" (skeep) (("2" (case "j <= length(val(remove_constants(cons2_var))) - 1") (("1" (assert) (("1" (inst -7 "j") (("1" (assert) (("1" (lemma nth_append[DNF_Atom]) (("1" (inst?) (("1" (split -1) (("1" (assert) nil) ("2" (hide 2 3) (("2" (assert) nil))))))))))))))) ("2" (hide 2 3) (("2" (assert) (("2" (case "j = length(val(remove_constants(cons(cons1_var, cons2_var))))- 1") (("1" (hide -6 -10) (("1" (reveal 1) (("1" (hide -2) (("1" (hide 2) (("1" (case "nth(append(val(remove_constants(cons2_var)), (: cons1_var :)), j) = cons1_var") (("1" (replace -1 1) (("1" (lemma "satisfiability_relation") (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil))) ("2" (hide 2) (("2" (hide -1 -2 -3 -4 -6 -7 -8) (("2" (typepred "remove_constants((: cons1_var :))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -2 -1) (("1" (hide -2) (("1" (expand "nth" -1) (("1" (assert) nil))))))) ("2" (grind) nil))) ("2" (reveal -6) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -4) (("1" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) nil))))))))))))))))))))))))) ("2" (hide 2) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst?) (("2" (split -1) (("1" (assert) (("1" (replace -2 -1) (("1" (lemma length_append[DNF_Atom]) (("1" (inst?) (("1" (replace -3 1) (("1" (replace -2 1) (("1" (replace -5 1) (("1" (replace -1 1) (("1" (hide-all-but 1) (("1" (simplify) (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (propax) nil))))))))))))))))))))))))))) ("2" (hide 2) (("2" (replace -3 -1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (replace -2 1) (("2" (simplify) (("2" (hide-all-but 1) (("2" (case "length[DNF_Atom]((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil))) ("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (propax) nil))))))))))))))))))))))))))))))))))))))))) ("2" (hide -7 -9) (("2" (hide -5 -6) (("2" (typepred "j") (("2" (replace -4 -1) (("2" (replace -4 1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (replace -1 1) (("2" (hide -1) (("2" (hide -2 -3 -4 -5 -6) (("2" (case "length[DNF_Atom]((: cons1_var :)) = 1") (("1" (replace -1 -2) (("1" (replace -1 1) (("1" (simplify) (("1" (assert) nil))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))))))))))))))))))))))))))))))))))))))))) ("2" (propax) nil) ("3" (propax) nil))))))) ("3" (hide 2 3) (("3" (hide -3 -4) (("3" (hide -1) (("3" (expand "remove_constants") (("3" (expand "remove_constants_rec") (("3" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil))))))))))))))))))))))))) ("2" (hide 2 3) (("2" (skeep) (("2" (hide -2 -3) (("2" (typepred "remove_constants(cons2_var)") (("2" (split -1) (("1" (inst -1 "j") (("1" (split 1) (("1" (typepred " deg(nth(val(remove_constants(cons2_var)), j)`plist)") (("1" (hide -1 -2 -3 -4) (("1" (split -1) (("1" (lemma "list2array_sound[rat]") (("1" (inst?) (("1" (assert) nil))))) ("2" (assert) nil))))))) ("2" (assert) nil))))) ("2" (hide 2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil))))))))))))))))))))))))))) ("3" (hide 3) (("3" (hide -2 -3) (("3" (expand "remove_constants") (("3" (expand "remove_constants_rec" -1) (("3" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil))))))))))))))))))) ("4" (case "length(val(remove_constants(cons2_var))) = 0") (("1" (hide 1) (("1" (lemma "eval_remove_constants") (("1" (inst?) (("1" (split -1) (("1" (hide -5) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (replace -1 -2) (("1" (case "(FORALL (j:
                                                                                             upto(length(val(remove_constants(cons
                                                                                                                              (cons1_var, cons2_var))))
                                                                                                   - 1)):
                                                                                     rel5(to_nat(nth(val(remove_constants(cons(cons1_var, cons2_var))),
                                                                                                     j)`rel))
                                                                                         (polynomial(nth(val(remove_constants
                                                                                                                  (cons(cons1_var, cons2_var))),
                                                                                                              j)`pn,
                                                                                                     nth(val(remove_constants
                                                                                                                 (cons(cons1_var, cons2_var))),
                                                                                                             j)`d)
                                                                                                    (x),
                                                                                          0))
                                                                                   IFF (eval_atm(cons1_var)(x) AND eval_atm_list(null)(x))") (("1" (ground) nil) ("2" (hide 3) (("2" (case "eval_atm_list(null)(x) = TRUE") (("1" (assert) (("1" (case "val(remove_constants(cons(cons1_var, cons2_var))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (split 1) (("1" (flatten 1) (("1" (inst -1 "0") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (hide -2 -3 -4 -5 -6 -7 -8 -9 2) (("1" (expand "nth") (("1" (propax) nil))))))))) ("2" (typepred "remove_constants(cons(cons1_var, cons2_var))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -3 -1) (("1" (assert) nil))))) ("2" (propax) nil))))))))))))))) ("2" (flatten 1) (("2" (skeep) (("2" (case "j = 0") (("1" (replace -1 1) (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "nth" 1) (("1" (propax) nil))))))) ("2" (typepred "remove_constants(cons(cons1_var, cons2_var))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -4 -1) (("1" (assert) nil))))) ("2" (propax) nil))))))))))))) ("2" (hide 2 3) (("2" (typepred "j") (("2" (replace -3 -1) (("2" (hide -2 -3 -4 -5 -6 -7 -8 -9) (("2" (grind) nil))))))))))))))))))) ("2" (hide 2) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants" -8) (("1" (expand "remove_constants_rec" -8) (("1" (expand "remove_constants" -4) (("1" (replace -4 -8) (("1" (hide-all-but -8) (("1" (grind) nil))))))))))))) ("2" (expand "remove_constants" -6) (("2" (expand "remove_constants_rec" -6) (("2" (assert) nil))))))))) ("2" (assert) (("2" (lemma relation_remove_constants_rec) (("2" (inst -1 "cons2_var" "null" "cons1_var") (("2" (split -1) (("1" (expand "remove_constants" -3) (("1" (replace -3 -1) (("1" (expand "append" -1) (("1" (propax) nil))))))) ("2" (expand "append" 1) (("2" (hide -1 -2 -3 -4 -6) (("2" (hide 2 3 4) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil))))))))))) ("3" (hide -1 -2 -3 -4 -6) (("3" (hide 2 3 4) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (expand "remove_constants" -2) (("3" (expand "remove_constants_rec" -2) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil))))))))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "eval_atm_list") (("2" (propax) nil))))))))) ("3" (hide-all-but 1) (("3" (skeep) (("3" (grind) nil))))))))) ("2" (hide 2 3) (("2" (hide -1 -3 -4) (("2" (grind) nil))))))))) ("2" (hide 2 3) (("2" (hide -3 -4) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants") (("2" (hide -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil))))))))))))))))))))))))))))))) ("2" (hide 3 4) (("2" (hide -1 -2 -3) (("2" (assert) nil))))))))))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (typepred "to_nat(nth[DNF_Atom]
                                          (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("3" (split 1) (("1" (assert) nil) ("2" (propax) nil)))))))))))) nil) nil nil) (satisfiability_relation_system-6 nil 3772810572 ("" (induct "ll") (("1" (grind) nil) ("2" (skeep) (("2" (case "cons2_var = null") (("1" (replace -1 1) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (hide -2) (("1" (replace -1 -4) (("1" (replace -1 -2) (("1" (case "cons(cons1_var, cons2_var) = (: cons1_var :)") (("1" (replace -1 -4) (("1" (case "some?(remove_constants((: cons1_var :)))") (("1" (hide -4) (("1" (lemma "satisfiability_relation") (("1" (hide -1) (("1" (case " length(val(remove_constants((: cons1_var :)))) = 1") (("1" (inst -6 "0") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (skeep*) (("1" (split -1) (("1" (inst -1 "x") (("1" (case "(rel5(to_nat(nth(val(remove_constants(cons(cons1_var, null))),
                                                                                        0)`rel))
                                                                            (polynomial(nth(val(remove_constants
                                                                                                     (cons(cons1_var, null))),
                                                                                                 0)`pn,
                                                                                        nth(val(remove_constants
                                                                                                    (cons(cons1_var, null))),
                                                                                                0)`d)
                                                                                       (x),
                                                                             0))
                                                                      IFF eval_atm(cons1_var)(x)") (("1" (hide 1) (("1" (hide -3 -4 -5 -6 -7 -8) (("1" (hide -2) (("1" (split 1) (("1" (flatten 1) (("1" (reveal -2) (("1" (inst -2 "0") (("1" (grind) nil) ("2" (hide -2 2) (("2" (reveal -6) (("2" (replace -1 1) (("2" (case "cons[DNF_Atom](cons1_var, null) = (: cons1_var :)") (("1" (replace -1 1) (("1" (assert) nil))) ("2" (propax) nil))))))))))))))) ("2" (flatten 1) (("2" (assert) (("2" (skeep 1) (("2" (typepred "j") (("2" (reveal -2) (("2" (case "j = 0") (("1" (replace -1 1) (("1" (propax) nil))) ("2" (hide 2) (("2" (hide -4) (("2" (expand "remove_constants" -1) (("2" (reveal -4) (("2" (replace -1 -3) (("2" (grind) nil))))))))))))))))))))))))))))))) ("2" (hide 3) (("2" (case "val(remove_constants(cons(cons1_var, null))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (replace -1 -2) (("1" (hide 2) (("1" (case " nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 1) (("1" (assert) (("1" (replace -1 -3) (("1" (propax) nil))))))) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil))))))))))))) ("2" (hide 2 3) (("2" (hide -1) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (hide-all-but -7) (("1" (grind) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil))))))))))))))))))))))) ("2" (propax) nil))))))))) ("2" (hide 2) (("2" (assert) nil))))) ("2" (hide 2) (("2" (hide -2 -3 -5) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (grind) nil))) ("2" (assert) nil))))))))))))))))))))))) ("2" (propax) nil))))) ("2" (hide 2) (("2" (hide -2 -3 -4) (("2" (grind) nil))))))))))))))))))) ("2" (skeep) (("2" (lemma "eval_truth") (("2" (inst? -1) (("2" (replace -1 2) (("2" (hide -1) (("2" (split -1) (("1" (inst -1 "x") (("1" (lemma "relation_remove_constants_single") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (lemma relation_remove_constants_null) (("1" (inst -1 "cons2_var" "cons1_var") (("1" (split -1) (("1" (lemma "eval_remove_constants") (("1" (inst -1 "x" "(: cons1_var :)") (("1" (split -1) (("1" (case "eval_atm(cons1_var)(x) = TRUE") (("1" (assert) (("1" (hide-all-but 2) (("1" (reveal -5) (("1" (reveal -3) (("1" (ground) (("1" (skeep) (("1" (inst -2 "j") (("1" (replace -4 1) (("1" (propax) nil))))))) ("2" (skeep) (("2" (inst -1 "j") (("2" (replace -2 -1) (("2" (propax) nil))))))))))))))))) ("2" (hide 2 3) (("2" (hide -7) (("2" (hide -4 -5 -6) (("2" (replace -3 -1) (("2" (grind) nil))))))))))) ("2" (hide 2 3) (("2" (hide -5 -6) (("2" (hide -1 -2 -3) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (propax) nil))))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil))))))))))))))))))))))))))) ("2" (propax) nil) ("3" (propax) nil))))))) ("2" (lemma relation_remove_constants) (("2" (inst -1 "cons2_var" "cons1_var") (("2" (split -1) (("1" (replace -1 2) (("1" (split 2) (("1" (flatten 1) (("1" (case "(FORALL (j: upto(length(val(remove_constants(cons2_var))) - 1)):
                                                                  rel5(to_nat(nth(val(remove_constants(cons2_var)), j)`rel))
                                                                      (polynomial(nth(val(remove_constants(cons2_var)),
                                                                                           j)`pn,
                                                                                  nth(val(remove_constants(cons2_var)),
                                                                                          j)`d))
                                                                                 (x),
                                                                       0)") (("1" (assert) (("1" (ground) (("1" (hide-all-but -4) (("1" (reveal 1) (("1" (inst -1 "length(val(remove_constants(cons
                                                                                                 (cons1_var, cons2_var))))
                                                                      - 1") (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (reveal -5) (("1" (replace -1 -2) (("1" (case "nth(append(val(remove_constants(cons2_var)), (: cons1_var :)),
                                                                               length(append(val(remove_constants(cons2_var)), (: cons1_var :)))
                                                                                - 1) = cons1_var") (("1" (hide -3) (("1" (replace -2 -3) (("1" (replace -1 -3) (("1" (hide -1 -2) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil))) ("2" (reveal -9) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (assert) (("2" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -2) (("1" (propax) nil))))) ("2" (assert) (("2" (reveal -10) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil))))))))))))))))))))))))))))))))) ("2" (hide 2) (("2" (hide -3) (("2" (hide -1) (("2" (case "length(append(val(remove_constants(cons2_var)), (: cons1_var :)))
                                                                                      - 1
                                                                                      < length(val(remove_constants(cons2_var)))") (("1" (hide-all-but -1) (("1" (lemma length_append[DNF_Atom]) (("1" (inst?) (("1" (replace -1 -2) (("1" (grind) nil))))))))) ("2" (assert) (("2" (hide 1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (simplify) (("2" (hide -1) (("2" (case "length[DNF_Atom]((: cons1_var :)) - 1 = 0") (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 -2) (("1" (assert) (("1" (hide -1) (("1" (lemma "length_append[DNF_Atom]") (("1" (inst?) (("1" (replace -1 1) (("1" (hide -1) (("1" (case "length[DNF_Atom]((: cons1_var :))
                                                                                                        - 1 = 0") (("1" (assert) nil) ("2" (hide 2) (("2" (hide -1) (("2" (grind) nil))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil))))))))))) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil))))))))))))))))))))))))))))))))))))) ("2" (hide -1) (("2" (lemma length_append[DNF_Atom]) (("2" (reveal -6) (("2" (replace -1 1) (("2" (inst?) (("2" (replace -2 1) (("2" (assert) nil))))))))))))))))))))))))))))))) ("2" (hide 2 3) (("2" (hide -2 -3 -4 -5 -6) (("2" (hide -2) (("2" (skeep) (("2" (inst -1 "j") (("1" (assert) (("1" (typepred "j") (("1" (lemma nth_append[DNF_Atom]) (("1" (inst?) (("1" (split -1) (("1" (assert) nil) ("2" (assert) nil))))))))))) ("2" (assert) (("2" (typepred "j") (("2" (hide 2) (("2" (reveal -3) (("2" (replace -1 1) (("2" (hide -1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) (("2" (replace -1 1) (("2" (assert) nil))))))))))))))))))))))))))))) ("3" (hide-all-but 1) (("3" (skeep) (("3" (grind) nil))))))))) ("2" (flatten 1) (("2" (skeep) (("2" (case "j <= length(val(remove_constants(cons2_var))) - 1") (("1" (assert) (("1" (inst -7 "j") (("1" (assert) (("1" (lemma nth_append[DNF_Atom]) (("1" (inst?) (("1" (split -1) (("1" (assert) nil) ("2" (hide 2 3) (("2" (assert) nil))))))))))))))) ("2" (hide 2 3) (("2" (assert) (("2" (case "j = length(val(remove_constants(cons(cons1_var, cons2_var))))- 1") (("1" (hide -6 -10) (("1" (reveal 1) (("1" (hide -2) (("1" (hide 2) (("1" (case "nth(append(val(remove_constants(cons2_var)), (: cons1_var :)), j) = cons1_var") (("1" (replace -1 1) (("1" (lemma "satisfiability_relation") (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil))) ("2" (hide 2) (("2" (hide -1 -2 -3 -4 -6 -7 -8) (("2" (typepred "remove_constants((: cons1_var :))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -2 -1) (("1" (hide -2) (("1" (expand "nth" -1) (("1" (assert) nil))))))) ("2" (grind) nil))) ("2" (reveal -6) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -4) (("1" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) nil))))))))))))))))))))))))) ("2" (hide 2) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst?) (("2" (split -1) (("1" (assert) (("1" (replace -2 -1) (("1" (lemma length_append[DNF_Atom]) (("1" (inst?) (("1" (replace -3 1) (("1" (replace -2 1) (("1" (replace -5 1) (("1" (replace -1 1) (("1" (hide-all-but 1) (("1" (simplify) (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (propax) nil))))))))))))))))))))))))))) ("2" (hide 2) (("2" (replace -3 -1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (replace -2 1) (("2" (simplify) (("2" (hide-all-but 1) (("2" (case "length[DNF_Atom]((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil))) ("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (propax) nil))))))))))))))))))))))))))))))))))))))))) ("2" (hide -7 -9) (("2" (hide -5 -6) (("2" (typepred "j") (("2" (replace -4 -1) (("2" (replace -4 1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (replace -1 1) (("2" (hide -1) (("2" (hide -2 -3 -4 -5 -6) (("2" (case "length[DNF_Atom]((: cons1_var :)) = 1") (("1" (replace -1 -2) (("1" (replace -1 1) (("1" (simplify) (("1" (assert) nil))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))))))))))))))))))))))))))))))))))))))))) ("2" (propax) nil) ("3" (propax) nil))))))) ("3" (hide 2 3) (("3" (hide -3 -4) (("3" (hide -1) (("3" (expand "remove_constants") (("3" (expand "remove_constants_rec") (("3" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil))))))))))))))))))))))))) ("2" (hide 2 3) (("2" (skeep) (("2" (hide -2 -3) (("2" (typepred "remove_constants(cons2_var)") (("2" (split -1) (("1" (inst -1 "j") (("1" (split 1) (("1" (typepred " deg(nth(val(remove_constants(cons2_var)), j)`plist)") (("1" (hide -1 -2 -3 -4) (("1" (split -1) (("1" (lemma "list2array_sound[rat]") (("1" (inst?) (("1" (assert) nil))))) ("2" (assert) nil))))))) ("2" (assert) nil))))) ("2" (hide 2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil))))))))))))))))))))))))))) ("3" (hide 3) (("3" (hide -2 -3) (("3" (expand "remove_constants") (("3" (expand "remove_constants_rec" -1) (("3" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil))))))))))))))))))) ("4" (case "length(val(remove_constants(cons2_var))) = 0") (("1" (hide 1) (("1" (lemma "eval_remove_constants") (("1" (inst?) (("1" (split -1) (("1" (hide -5) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (replace -1 -2) (("1" (case "(FORALL (j:
                                                                          upto(length(val(remove_constants(cons
                                                                                                           (cons1_var, cons2_var))))
                                                                                - 1)):
                                                                  rel5(to_nat(nth(val(remove_constants(cons(cons1_var, cons2_var))),
                                                                                  j)`rel))
                                                                      (polynomial(nth(val(remove_constants
                                                                                               (cons(cons1_var, cons2_var))),
                                                                                           j)`pn,
                                                                                  nth(val(remove_constants
                                                                                              (cons(cons1_var, cons2_var))),
                                                                                          j)`d)
                                                                                 (x),
                                                                       0))
                                                                IFF (eval_atm(cons1_var)(x) AND eval_atm_list(null)(x))") (("1" (ground) nil) ("2" (hide 3) (("2" (case "eval_atm_list(null)(x) = TRUE") (("1" (assert) (("1" (case "val(remove_constants(cons(cons1_var, cons2_var))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (split 1) (("1" (flatten 1) (("1" (inst -1 "0") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (hide -2 -3 -4 -5 -6 -7 -8 -9 2) (("1" (expand "nth") (("1" (propax) nil))))))))) ("2" (typepred "remove_constants(cons(cons1_var, cons2_var))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -3 -1) (("1" (assert) nil))))) ("2" (propax) nil))))))))))))))) ("2" (flatten 1) (("2" (skeep) (("2" (case "j = 0") (("1" (replace -1 1) (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "nth" 1) (("1" (propax) nil))))))) ("2" (typepred "remove_constants(cons(cons1_var, cons2_var))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -4 -1) (("1" (assert) nil))))) ("2" (propax) nil))))))))))))) ("2" (hide 2 3) (("2" (typepred "j") (("2" (replace -3 -1) (("2" (hide -2 -3 -4 -5 -6 -7 -8 -9) (("2" (grind) nil))))))))))))))))))) ("2" (hide 2) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants" -8) (("1" (expand "remove_constants_rec" -8) (("1" (expand "remove_constants" -4) (("1" (replace -4 -8) (("1" (hide-all-but -8) (("1" (grind) nil))))))))))))) ("2" (expand "remove_constants" -6) (("2" (expand "remove_constants_rec" -6) (("2" (assert) nil))))))))) ("2" (assert) (("2" (lemma relation_remove_constants_rec) (("2" (inst -1 "cons2_var" "null" "cons1_var") (("2" (split -1) (("1" (expand "remove_constants" -3) (("1" (replace -3 -1) (("1" (expand "append" -1) (("1" (propax) nil))))))) ("2" (expand "append" 1) (("2" (hide -1 -2 -3 -4 -6) (("2" (hide 2 3 4) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil))))))))))) ("3" (hide -1 -2 -3 -4 -6) (("3" (hide 2 3 4) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (expand "remove_constants" -2) (("3" (expand "remove_constants_rec" -2) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil))))))))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "eval_atm_list") (("2" (propax) nil))))))))) ("3" (hide-all-but 1) (("3" (skeep) (("3" (grind) nil))))))))) ("2" (hide 2 3) (("2" (hide -1 -3 -4) (("2" (grind) nil))))))))) ("2" (hide 2 3) (("2" (hide -3 -4) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants") (("2" (hide -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil))))))))))))))))))))))))))))))) ("2" (hide 3 4) (("2" (hide -1 -2 -3) (("2" (assert) nil))))))))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (typepred "to_nat(nth[DNF_Atom]
                                      (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("3" (split 1) (("1" (assert) nil) ("2" (propax) nil)))))))))))) nil) nil nil) (satisfiability_relation_system-5 nil 3772810367 ("" (induct "ll") (("1" (grind) nil) ("2" (skeep) (("2" (case "cons2_var = null") (("1" (replace -1 1) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (hide -2) (("1" (replace -1 -4) (("1" (replace -1 -2) (("1" (case "cons(cons1_var, cons2_var) = (: cons1_var :)") (("1" (replace -1 -4) (("1" (case "some?(remove_constants((: cons1_var :)))") (("1" (hide -4) (("1" (lemma "satisfiability_relation") (("1" (hide -1) (("1" (case " length(val(remove_constants((: cons1_var :)))) = 1") (("1" (inst -6 "0") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (skeep*) (("1" (split -1) (("1" (inst -1 "x") (("1" (case "(
                                                   rel5(to_nat(nth(val(remove_constants(cons(cons1_var, null))),
                                                                   0)`rel))
                                                       (polynomial(nth(val(remove_constants
                                                                                (cons(cons1_var, null))),
                                                                            0)`pn,
                                                                   nth(val(remove_constants
                                                                               (cons(cons1_var, null))),
                                                                           0)`d)
                                                                  (x),
                                                        0))
                                                 IFF eval_atm(cons1_var)(x)") (("1" (hide 1) (("1" (hide -3 -4 -5 -6 -7 -8) (("1" (hide -2) (("1" (split 1) (("1" (flatten 1) (("1" (reveal -2) (("1" (inst -2 "0") (("1" (grind) nil) ("2" (hide -2 2) (("2" (reveal -6) (("2" (replace -1 1) (("2" (case "cons[DNF_Atom](cons1_var, null) = (: cons1_var :)") (("1" (replace -1 1) (("1" (assert) nil))) ("2" (propax) nil))))))))))))))) ("2" (flatten 1) (("2" (assert) (("2" (skeep 1) (("2" (typepred "j") (("2" (reveal -2) (("2" (case "j = 0") (("1" (replace -1 1) (("1" (propax) nil))) ("2" (hide 2) (("2" (hide -4) (("2" (expand "remove_constants" -1) (("2" (reveal -4) (("2" (replace -1 -3) (("2" (grind) nil))))))))))))))))))))))))))))))) ("2" (hide 3) (("2" (case "val(remove_constants(cons(cons1_var, null))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (replace -1 -2) (("1" (hide 2) (("1" (case " nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 1) (("1" (assert) (("1" (replace -1 -3) (("1" (propax) nil))))))) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil))))))))))))) ("2" (hide 2 3) (("2" (hide -1) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (hide-all-but -7) (("1" (grind) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil))))))))))))))))))))))) ("2" (propax) nil))))))))) ("2" (hide 2) (("2" (assert) nil))))) ("2" (hide 2) (("2" (hide -2 -3 -5) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (grind) nil))) ("2" (assert) nil))))))))))))))))))))))) ("2" (propax) nil))))) ("2" (hide 2) (("2" (hide -2 -3 -4) (("2" (grind) nil))))))))))))))))))) ("2" (skeep) (("2" (lemma "eval_truth") (("2" (inst? -1) (("2" (replace -1 2) (("2" (hide -1) (("2" (split -1) (("1" (inst -1 "x") (("1" (lemma "relation_remove_constants_single") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (lemma relation_remove_constants_null) (("1" (inst -1 "cons2_var" "cons1_var") (("1" (split -1) (("1" (lemma "eval_remove_constants") (("1" (inst -1 "x" "(: cons1_var :)") (("1" (split -1) (("1" (case "eval_atm(cons1_var)(x) = TRUE") (("1" (assert) (("1" (hide-all-but 2) (("1" (reveal -5) (("1" (reveal -3) (("1" (ground) (("1" (skeep) (("1" (inst -2 "j") (("1" (replace -4 1) (("1" (propax) nil))))))) ("2" (skeep) (("2" (inst -1 "j") (("2" (replace -2 -1) (("2" (propax) nil))))))))))))))))) ("2" (hide 2 3) (("2" (hide -7) (("2" (hide -4 -5 -6) (("2" (replace -3 -1) (("2" (grind) nil))))))))))) ("2" (hide 2 3) (("2" (hide -5 -6) (("2" (hide -1 -2 -3) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (propax) nil))))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil))))))))))))))))))))))))))) ("2" (propax) nil) ("3" (propax) nil))))))) ("2" (lemma relation_remove_constants) (("2" (inst -1 "cons2_var" "cons1_var") (("2" (split -1) (("1" (replace -1 2) (("1" (split 2) (("1" (flatten 1) (("1" (case "(FORALL (j: upto(length(val(remove_constants(cons2_var))) - 1)):
                                               rel5(to_nat(nth(val(remove_constants(cons2_var)), j)`rel))
                                                   (polynomial(nth(val(remove_constants(cons2_var)),
                                                                        j)`pn,
                                                               nth(val(remove_constants(cons2_var)),
                                                                       j)`d))
                                                              (x),
                                                    0))") (("1" (assert) (("1" (ground) (("1" (hide-all-but -4) (("1" (reveal 1) (("1" (inst -1 "length(val(remove_constants(cons
                                                                                 (cons1_var, cons2_var))))
                                                      - 1") (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (reveal -5) (("1" (replace -1 -2) (("1" (case "nth(append(val(remove_constants(cons2_var)), (: cons1_var :)),
                                                        length(append(val(remove_constants(cons2_var)), (: cons1_var :)))
                                                         - 1) = cons1_var") (("1" (hide -3) (("1" (replace -2 -3) (("1" (replace -1 -3) (("1" (hide -1 -2) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil))) ("2" (reveal -9) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (assert) (("2" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -2) (("1" (propax) nil))))) ("2" (assert) (("2" (reveal -10) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil))))))))))))))))))))))))))))))))) ("2" (hide 2) (("2" (hide -3) (("2" (hide -1) (("2" (case "length(append(val(remove_constants(cons2_var)), (: cons1_var :)))
                                                             - 1
                                                             < length(val(remove_constants(cons2_var)))") (("1" (hide-all-but -1) (("1" (lemma length_append[DNF_Atom]) (("1" (inst?) (("1" (replace -1 -2) (("1" (grind) nil))))))))) ("2" (assert) (("2" (hide 1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (simplify) (("2" (hide -1) (("2" (case "length[DNF_Atom]((: cons1_var :)) - 1 = 0") (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 -2) (("1" (assert) (("1" (hide -1) (("1" (lemma "length_append[DNF_Atom]") (("1" (inst?) (("1" (replace -1 1) (("1" (hide -1) (("1" (case "length[DNF_Atom]((: cons1_var :))
                                                                         - 1 = 0") (("1" (assert) nil) ("2" (hide 2) (("2" (hide -1) (("2" (grind) nil))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil))))))))))) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil))))))))))))))))))))))))))))))))))))) ("2" (hide -1) (("2" (lemma length_append[DNF_Atom]) (("2" (reveal -6) (("2" (replace -1 1) (("2" (inst?) (("2" (replace -2 1) (("2" (assert) nil))))))))))))))))))))))))))))))) ("2" (hide 2 3) (("2" (hide -2 -3 -4 -5 -6) (("2" (hide -2) (("2" (skeep) (("2" (inst -1 "j") (("1" (assert) (("1" (typepred "j") (("1" (lemma nth_append[DNF_Atom]) (("1" (inst?) (("1" (split -1) (("1" (assert) nil) ("2" (assert) nil))))))))))) ("2" (assert) (("2" (typepred "j") (("2" (hide 2) (("2" (reveal -3) (("2" (replace -1 1) (("2" (hide -1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) (("2" (replace -1 1) (("2" (assert) nil))))))))))))))))))))))))))))) ("3" (hide-all-but 1) (("3" (skeep) (("3" (grind) nil))))))))) ("2" (flatten 1) (("2" (skeep) (("2" (case "j <= length(val(remove_constants(cons2_var))) - 1") (("1" (assert) (("1" (inst -7 "j") (("1" (assert) (("1" (lemma nth_append[DNF_Atom]) (("1" (inst?) (("1" (split -1) (("1" (assert) nil) ("2" (hide 2 3) (("2" (assert) nil))))))))))))))) ("2" (hide 2 3) (("2" (assert) (("2" (case "j = length(val(remove_constants(cons(cons1_var, cons2_var))))- 1") (("1" (hide -6 -10) (("1" (reveal 1) (("1" (hide -2) (("1" (hide 2) (("1" (case "nth(append(val(remove_constants(cons2_var)), (: cons1_var :)), j) = cons1_var") (("1" (replace -1 1) (("1" (lemma "satisfiability_relation") (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil))) ("2" (hide 2) (("2" (hide -1 -2 -3 -4 -6 -7 -8) (("2" (typepred "remove_constants((: cons1_var :))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -2 -1) (("1" (hide -2) (("1" (expand "nth" -1) (("1" (assert) nil))))))) ("2" (grind) nil))) ("2" (reveal -6) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -4) (("1" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) nil))))))))))))))))))))))))) ("2" (hide 2) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst?) (("2" (split -1) (("1" (assert) (("1" (replace -2 -1) (("1" (lemma length_append[DNF_Atom]) (("1" (inst?) (("1" (replace -3 1) (("1" (replace -2 1) (("1" (replace -5 1) (("1" (replace -1 1) (("1" (hide-all-but 1) (("1" (simplify) (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (propax) nil))))))))))))))))))))))))))) ("2" (hide 2) (("2" (replace -3 -1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (replace -2 1) (("2" (simplify) (("2" (hide-all-but 1) (("2" (case "length[DNF_Atom]((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil))) ("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (propax) nil))))))))))))))))))))))))))))))))))))))))) ("2" (hide -7 -9) (("2" (hide -5 -6) (("2" (typepred "j") (("2" (replace -4 -1) (("2" (replace -4 1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (replace -1 1) (("2" (hide -1) (("2" (hide -2 -3 -4 -5 -6) (("2" (case "length[DNF_Atom]((: cons1_var :)) = 1") (("1" (replace -1 -2) (("1" (replace -1 1) (("1" (simplify) (("1" (assert) nil))))))) ("2" (hide-all-but 1) (("2" (grind) nil))))))))))))))))))))))))))))))))))))))))))) ("2" (propax) nil) ("3" (propax) nil))))))) ("3" (hide 2 3) (("3" (hide -3 -4) (("3" (hide -1) (("3" (expand "remove_constants") (("3" (expand "remove_constants_rec") (("3" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (propax) nil))))) ("2" (assert) nil))))) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil))))))))))))))))))))))))) ("2" (hide 2 3) (("2" (skeep) (("2" (hide -2 -3) (("2" (typepred "remove_constants(cons2_var)") (("2" (split -1) (("1" (inst -1 "j") (("1" (split 1) (("1" (typepred " deg(nth(val(remove_constants(cons2_var)), j)`plist)") (("1" (hide -1 -2 -3 -4) (("1" (split -1) (("1" (lemma "list2array_sound[rat]") (("1" (inst?) (("1" (assert) nil))))) ("2" (assert) nil))))))) ("2" (assert) nil))))) ("2" (hide 2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil))))))))))))))))))))))))))) ("3" (hide 3) (("3" (hide -2 -3) (("3" (expand "remove_constants") (("3" (expand "remove_constants_rec" -1) (("3" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil))))))))))))))))))) ("4" (case "length(val(remove_constants(cons2_var))) = 0") (("1" (hide 1) (("1" (lemma "eval_remove_constants") (("1" (inst?) (("1" (split -1) (("1" (hide -5) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (replace -1 -2) (("1" (case "(FORALL (j:
                                                       upto(length(val(remove_constants(cons
                                                                                        (cons1_var, cons2_var))))
                                                             - 1)):
                                               rel5(to_nat(nth(val(remove_constants(cons(cons1_var, cons2_var))),
                                                               j)`rel))
                                                   (polynomial(nth(val(remove_constants
                                                                            (cons(cons1_var, cons2_var))),
                                                                        j)`pn,
                                                               nth(val(remove_constants
                                                                           (cons(cons1_var, cons2_var))),
                                                                       j)`d)
                                                              (x),
                                                    0))
                                             IFF (eval_atm(cons1_var)(x) AND eval_atm_list(null)(x))") (("1" (ground) nil) ("2" (hide 3) (("2" (case "eval_atm_list(null)(x) = TRUE") (("1" (assert) (("1" (case "val(remove_constants(cons(cons1_var, cons2_var))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (split 1) (("1" (flatten 1) (("1" (inst -1 "0") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (hide -2 -3 -4 -5 -6 -7 -8 -9 2) (("1" (expand "nth") (("1" (propax) nil))))))))) ("2" (typepred "remove_constants(cons(cons1_var, cons2_var))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -3 -1) (("1" (assert) nil))))) ("2" (propax) nil))))))))))))))) ("2" (flatten 1) (("2" (skeep) (("2" (case "j = 0") (("1" (replace -1 1) (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "nth" 1) (("1" (propax) nil))))))) ("2" (typepred "remove_constants(cons(cons1_var, cons2_var))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -4 -1) (("1" (assert) nil))))) ("2" (propax) nil))))))))))))) ("2" (hide 2 3) (("2" (typepred "j") (("2" (replace -3 -1) (("2" (hide -2 -3 -4 -5 -6 -7 -8 -9) (("2" (grind) nil))))))))))))))))))) ("2" (hide 2) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants" -8) (("1" (expand "remove_constants_rec" -8) (("1" (expand "remove_constants" -4) (("1" (replace -4 -8) (("1" (hide-all-but -8) (("1" (grind) nil))))))))))))) ("2" (expand "remove_constants" -6) (("2" (expand "remove_constants_rec" -6) (("2" (assert) nil))))))))) ("2" (assert) (("2" (lemma relation_remove_constants_rec) (("2" (inst -1 "cons2_var" "null" "cons1_var") (("2" (split -1) (("1" (expand "remove_constants" -3) (("1" (replace -3 -1) (("1" (expand "append" -1) (("1" (propax) nil))))))) ("2" (expand "append" 1) (("2" (hide -1 -2 -3 -4 -6) (("2" (hide 2 3 4) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil))))))))))) ("3" (hide -1 -2 -3 -4 -6) (("3" (hide 2 3 4) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (expand "remove_constants" -2) (("3" (expand "remove_constants_rec" -2) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil))))))))))))))))))))))))))))))))))) ("2" (hide-all-but 1) (("2" (expand "eval_atm_list") (("2" (propax) nil))))))))) ("3" (hide-all-but 1) (("3" (skeep) (("3" (grind) nil))))))))) ("2" (hide 2 3) (("2" (hide -1 -3 -4) (("2" (grind) nil))))))))) ("2" (hide 2 3) (("2" (hide -3 -4) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants") (("2" (hide -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "cons1_var`d < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil))))))))))))))))))))))))))))))) ("2" (hide 3 4) (("2" (hide -1 -2 -3) (("2" (assert) nil))))))))))))))))))))))) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (typepred "to_nat(nth[DNF_Atom]
                                  (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("3" (split 1) (("1" (assert) nil) ("2" (propax) nil)))))))))))) nil) nil nil) (satisfiability_relation_system-4 nil 3770729579 ("" (induct "ll") (("1" (grind) nil nil) ("2" (skeep) (("2" (case "cons2_var = null") (("1" (replace -1 1) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (hide -2) (("1" (replace -1 -4) (("1" (replace -1 -2) (("1" (case "cons(cons1_var, cons2_var) = (: cons1_var :)") (("1" (replace -1 -4) (("1" (case "some?(remove_constants((: cons1_var :)))") (("1" (hide -4) (("1" (lemma "satisfiability_relation") (("1" (hide -1) (("1" (case " length(val(remove_constants((: cons1_var :)))) = 1") (("1" (inst -6 "0") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (skeep*) (("1" (split -1) (("1" (inst -1 "x") (("1" (case "(
                              rel5(to_nat(nth(val(remove_constants(cons(cons1_var, null))),
                                              0)`rel))
                                  (polynomial(list2array[rat]
                                                  (0)
                                                  (nth(val(remove_constants
                                                           (cons(cons1_var, null))),
                                                       0)`plist),
                                              deg(nth(val(remove_constants
                                                          (cons(cons1_var, null))),
                                                      0)`plist))
                                             (x),
                                   0))
                            IFF eval_atm(cons1_var)(x)") (("1" (hide 1) (("1" (hide -3 -4 -5 -6 -7 -8) (("1" (hide -2) (("1" (split 1) (("1" (flatten 1) (("1" (reveal -2) (("1" (inst -2 "0") (("1" (grind) nil nil) ("2" (hide -2 2) (("2" (reveal -6) (("2" (replace -1 1) (("2" (case "cons[DNF_Atom](cons1_var, null) = (: cons1_var :)") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (assert) (("2" (skeep 1) (("2" (typepred "j") (("2" (reveal -2) (("2" (case "j = 0") (("1" (replace -1 1) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (hide -4) (("2" (expand "remove_constants" -1) (("2" (reveal -4) (("2" (replace -1 -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (case "val(remove_constants(cons(cons1_var, null))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (replace -1 -2) (("1" (hide 2) (("1" (case " nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 1) (("1" (assert) (("1" (replace -1 -3) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -1) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (hide-all-but -7) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2 -3 -5) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec") (("2" (expand "remove_constants_rec") (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2 -3 -4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "eval_truth") (("2" (inst? -1) (("2" (replace -1 2) (("2" (hide -1) (("2" (split -1) (("1" (inst -1 "x") (("1" (lemma "relation_remove_constants_single") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (lemma relation_remove_constants_null) (("1" (inst -1 "cons2_var" "cons1_var") (("1" (split -1) (("1" (lemma "eval_remove_constants") (("1" (inst -1 "x" "(: cons1_var :)") (("1" (split -1) (("1" (case "eval_atm(cons1_var)(x) = TRUE") (("1" (assert) (("1" (hide-all-but 2) (("1" (reveal -5) (("1" (reveal -3) (("1" (ground) (("1" (skeep) (("1" (inst -2 "j") (("1" (replace -4 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -1 "j") (("2" (replace -2 -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -7) (("2" (hide -4 -5 -6) (("2" (replace -3 -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -5 -6) (("2" (hide -1 -2 -3) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma relation_remove_constants) (("2" (inst -1 "cons2_var" "cons1_var") (("2" (split -1) (("1" (replace -1 2) (("1" (split 2) (("1" (flatten 1) (("1" (case "(FORALL (j: upto(length(val(remove_constants(cons2_var))) - 1)):
                            rel5(to_nat(nth(val(remove_constants(cons2_var)), j)`rel))
                                (polynomial(list2array[rat]
                                                (0)
                                                (nth(val(remove_constants(cons2_var)),
                                                     j)`plist),
                                            deg(nth(val(remove_constants(cons2_var)),
                                                    j)`plist))
                                           (x),
                                 0))") (("1" (assert) (("1" (ground) (("1" (hide-all-but -4) (("1" (reveal 1) (("1" (inst -1 "length(val(remove_constants(cons
                                                                 (cons1_var, cons2_var))))
                                      - 1") (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (reveal -5) (("1" (replace -1 -2) (("1" (case "nth(append(val(remove_constants(cons2_var)), (: cons1_var :)),
                                 length(append(val(remove_constants(cons2_var)), (: cons1_var :)))
                                  - 1) = cons1_var") (("1" (hide -3) (("1" (replace -2 -3) (("1" (replace -1 -3) (("1" (hide -1 -2) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (reveal -9) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (assert) (("2" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (reveal -10) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -3) (("2" (hide -1) (("2" (case "length(append(val(remove_constants(cons2_var)), (: cons1_var :)))
                                    - 1
                                    < length(val(remove_constants(cons2_var)))") (("1" (hide-all-but -1) (("1" (lemma length_append[DNF_Atom]) (("1" (inst?) (("1" (replace -1 -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (simplify) (("2" (hide -1) (("2" (case "length[DNF_Atom]((: cons1_var :)) - 1 = 0") (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 -2) (("1" (assert) (("1" (hide -1) (("1" (lemma "length_append[DNF_Atom]") (("1" (inst?) (("1" (replace -1 1) (("1" (hide -1) (("1" (case "length[DNF_Atom]((: cons1_var :))
                                          - 1 = 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma length_append[DNF_Atom]) (("2" (reveal -6) (("2" (replace -1 1) (("2" (inst?) (("2" (replace -2 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -2 -3 -4 -5 -6) (("2" (hide -2) (("2" (skeep) (("2" (inst -1 "j") (("1" (assert) (("1" (typepred "j") (("1" (lemma nth_append[DNF_Atom]) (("1" (inst?) (("1" (split -1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "j") (("2" (hide 2) (("2" (reveal -3) (("2" (replace -1 1) (("2" (hide -1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) (("2" (replace -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (case "j <= length(val(remove_constants(cons2_var))) - 1") (("1" (assert) (("1" (inst -7 "j") (("1" (assert) (("1" (lemma nth_append[DNF_Atom]) (("1" (inst?) (("1" (split -1) (("1" (assert) nil nil) ("2" (hide 2 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (assert) (("2" (case "j = length(val(remove_constants(cons(cons1_var, cons2_var))))- 1") (("1" (hide -6 -10) (("1" (reveal 1) (("1" (hide -2) (("1" (hide 2) (("1" (case "nth(append(val(remove_constants(cons2_var)), (: cons1_var :)), j) = cons1_var") (("1" (replace -1 1) (("1" (lemma "satisfiability_relation") (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (hide -1 -2 -3 -4 -6 -7 -8) (("2" (typepred "remove_constants((: cons1_var :))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -2 -1) (("1" (hide -2) (("1" (expand "nth" -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (reveal -6) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -4) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "nth_append[DNF_Atom]") (("2" (inst?) (("2" (split -1) (("1" (assert) (("1" (replace -2 -1) (("1" (lemma length_append[DNF_Atom]) (("1" (inst?) (("1" (replace -3 1) (("1" (replace -2 1) (("1" (replace -5 1) (("1" (replace -1 1) (("1" (hide-all-but 1) (("1" (simplify) (("1" (expand "length") (("1" (expand "length") (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -3 -1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (replace -2 1) (("2" (simplify) (("2" (hide-all-but 1) (("2" (case "length[DNF_Atom]((: cons1_var :)) = 1") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (expand "length" 1) (("2" (expand "length" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -7 -9) (("2" (hide -5 -6) (("2" (typepred "j") (("2" (replace -4 -1) (("2" (replace -4 1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (replace -1 1) (("2" (hide -1) (("2" (hide -2 -3 -4 -5 -6) (("2" (case "length[DNF_Atom]((: cons1_var :)) = 1") (("1" (replace -1 -2) (("1" (replace -1 1) (("1" (simplify) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (hide -3 -4) (("3" (hide -1) (("3" (expand "remove_constants") (("3" (expand "remove_constants_rec") (("3" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (skeep) (("2" (hide -2 -3) (("2" (typepred "remove_constants(cons2_var)") (("2" (split -1) (("1" (inst -1 "j") (("1" (split 1) (("1" (typepred " deg(nth(val(remove_constants(cons2_var)), j)`plist)") (("1" (hide -1 -2 -3 -4) (("1" (split -1) (("1" (lemma "list2array_sound[rat]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (hide -2 -3) (("3" (expand "remove_constants") (("3" (expand "remove_constants_rec" -1) (("3" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case "length(val(remove_constants(cons2_var))) = 0") (("1" (hide 1) (("1" (lemma "eval_remove_constants") (("1" (inst?) (("1" (split -1) (("1" (hide -5) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (replace -1 -2) (("1" (case "(FORALL (j:
                                    upto(length(val(remove_constants(cons
                                                                     (cons1_var, cons2_var))))
                                          - 1)):
                            rel5(to_nat(nth(val(remove_constants(cons(cons1_var, cons2_var))),
                                            j)`rel))
                                (polynomial(list2array[rat]
                                                (0)
                                                (nth(val(remove_constants
                                                         (cons(cons1_var, cons2_var))),
                                                     j)`plist),
                                            deg(nth(val(remove_constants
                                                        (cons(cons1_var, cons2_var))),
                                                    j)`plist))
                                           (x),
                                 0))
                          IFF (eval_atm(cons1_var)(x) AND eval_atm_list(null)(x))") (("1" (ground) nil nil) ("2" (hide 3) (("2" (case "eval_atm_list(null)(x) = TRUE") (("1" (assert) (("1" (case "val(remove_constants(cons(cons1_var, cons2_var))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (split 1) (("1" (flatten 1) (("1" (inst -1 "0") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (hide -2 -3 -4 -5 -6 -7 -8 -9 2) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "remove_constants(cons(cons1_var, cons2_var))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -3 -1) (("1" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (case "j = 0") (("1" (replace -1 1) (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "remove_constants(cons(cons1_var, cons2_var))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -4 -1) (("1" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (typepred "j") (("2" (replace -3 -1) (("2" (hide -2 -3 -4 -5 -6 -7 -8 -9) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants" -8) (("1" (expand "remove_constants_rec" -8) (("1" (expand "remove_constants" -4) (("1" (replace -4 -8) (("1" (hide-all-but -8) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "remove_constants" -6) (("2" (expand "remove_constants_rec" -6) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma relation_remove_constants_rec) (("2" (inst -1 "cons2_var" "null" "cons1_var") (("2" (split -1) (("1" (expand "remove_constants" -3) (("1" (replace -3 -1) (("1" (expand "append" -1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (hide -1 -2 -3 -4 -6) (("2" (hide 2 3 4) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 -3 -4 -6) (("3" (hide 2 3 4) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (expand "remove_constants" -2) (("3" (expand "remove_constants_rec" -2) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_atm_list") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -1 -3 -4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -3 -4) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants") (("2" (hide -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3 4) (("2" (hide -1 -2 -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (typepred "to_nat(nth[DNF_Atom]
                              (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("3" (split 1) (("1" (assert) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list2array_sound formula-decl nil array2list structures) (nth_append formula-decl nil more_list_props structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (eval_rel const-decl "bool" dnf_polynomials nil) (polylist const-decl "real" polylist Sturm) (lt_realorder name-judgement "RealOrder" real_orders reals) (eval_atm const-decl "bool" dnf_polynomials nil) (le_realorder name-judgement "RealOrder" real_orders reals) (length_singleton formula-decl nil more_list_props structures) (ge_realorder name-judgement "RealOrder" real_orders reals) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (list_induction formula-decl nil list_adt nil) (Polylist type-eq-decl nil polylist Sturm) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (eval_atm_list def-decl "bool" dnf_polynomials nil) (polynomial const-decl "[real -> real]" polynomials reals) (rel5 const-decl "bool" preprocessing_univariate nil) (list type-decl nil list_adt nil) (Maybe type-decl nil Maybe structures) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (deg const-decl "{d: below(length(pl)) |
   (d > 0 IFF EXISTS (j: below(length(pl))): j > 0 AND nth(pl, j) /= 0) AND
    (d > 0 IMPLIES
      (FORALL (j: below(length(pl))): j > d IMPLIES nth(pl, j) = 0))
     AND (d > 0 IMPLIES nth(pl, d) /= 0)}" polylist Sturm) (list2array def-decl "T" array2list structures) (to_nat const-decl "upto(5)" poly_system_strategy nil)) nil) (satisfiability_relation_system-3 nil 3770717776 ("" (induct "ll") (("1" (grind) nil nil) ("2" (skeep) (("2" (case "cons2_var = null") (("1" (replace -1 1) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (hide -2) (("1" (replace -1 -4) (("1" (replace -1 -2) (("1" (case "cons(cons1_var, cons2_var) = (: cons1_var :)") (("1" (replace -1 -4) (("1" (case "some?(remove_constants((: cons1_var :)))") (("1" (hide -4) (("1" (lemma "satisfiability_relation") (("1" (hide -1) (("1" (case " length(val(remove_constants((: cons1_var :)))) = 1") (("1" (inst -6 "0") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (skeep*) (("1" (split -1) (("1" (inst -1 "x") (("1" (case "(
         rel5(to_nat(nth(val(remove_constants(cons(cons1_var, null))),
                         0)`rel))
             (polynomial(list2array[rat]
                             (0)
                             (nth(val(remove_constants
                                      (cons(cons1_var, null))),
                                  0)`plist),
                         deg(nth(val(remove_constants
                                     (cons(cons1_var, null))),
                                 0)`plist))
                        (x),
              0))
       IFF eval_atm(cons1_var)(x)") (("1" (hide 1) (("1" (hide -3 -4 -5 -6 -7 -8) (("1" (hide -2) (("1" (split 1) (("1" (flatten 1) (("1" (reveal -2) (("1" (inst -2 "0") (("1" (grind) nil nil) ("2" (hide -2 2) (("2" (reveal -6) (("2" (replace -1 1) (("2" (case "cons[DNF_Atom](cons1_var, null) = (: cons1_var :)") (("1" (replace -1 1) (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (assert) (("2" (skeep 1) (("2" (typepred "j") (("2" (reveal -2) (("2" (case "j = 0") (("1" (replace -1 1) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (hide -4) (("2" (expand "remove_constants" -1) (("2" (reveal -4) (("2" (replace -1 -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (case "val(remove_constants(cons(cons1_var, null))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (replace -1 -2) (("1" (hide 2) (("1" (case " nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 1) (("1" (assert) (("1" (replace -1 -3) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -1) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (hide-all-but -7) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2 -3 -5) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec") (("2" (expand "remove_constants_rec") (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2 -3 -4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "eval_truth") (("2" (inst? -1) (("2" (replace -1 2) (("2" (hide -1) (("2" (split -1) (("1" (inst -1 "x") (("1" (lemma "relation_remove_constants_single") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (lemma relation_remove_constants_null) (("1" (inst -1 "cons2_var" "cons1_var") (("1" (split -1) (("1" (lemma "eval_remove_constants") (("1" (inst -1 "x" "(: cons1_var :)") (("1" (split -1) (("1" (case "eval_atm(cons1_var)(x) = TRUE") (("1" (assert) (("1" (hide-all-but 2) (("1" (reveal -5) (("1" (reveal -3) (("1" (ground) (("1" (skeep) (("1" (inst -2 "j") (("1" (replace -4 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -1 "j") (("2" (replace -2 -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -7) (("2" (hide -4 -5 -6) (("2" (replace -3 -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -5 -6) (("2" (hide -1 -2 -3) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (assert) (("1" (expand "remove_constants_rec" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (lemma relation_remove_constants) (("2" (inst -1 "cons2_var" "cons1_var") (("2" (split -1) (("1" (replace -1 2) (("1" (split 2) (("1" (flatten 1) (("1" (case "(FORALL (j: upto(length(val(remove_constants(cons2_var))) - 1)):
         rel5(to_nat(nth(val(remove_constants(cons2_var)), j)`rel))
             (polynomial(list2array[rat]
                             (0)
                             (nth(val(remove_constants(cons2_var)),
                                  j)`plist),
                         deg(nth(val(remove_constants(cons2_var)),
                                 j)`plist))
                        (x),
              0))") (("1" (assert) (("1" (ground) (("1" (hide-all-but -4) (("1" (reveal 1) (("1" (inst -1 "length(val(remove_constants(cons
                                                 (cons1_var, cons2_var))))
                      - 1") (("1" (lemma "nth_append[DNF_Atom]") (("1" (inst?) (("1" (assert) (("1" (split -1) (("1" (reveal -5) (("1" (replace -1 -2) (("1" (case "nth(append(val(remove_constants(cons2_var)), (: cons1_var :)),
          length(append(val(remove_constants(cons2_var)), (: cons1_var :)))
           - 1) = cons1_var") (("1" (hide -3) (("1" (replace -2 -3) (("1" (replace -1 -3) (("1" (hide -1 -2) (("1" (lemma "satisfiability_relation") (("1" (inst -1 "cons1_var") (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (reveal -9) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (assert) (("2" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -2) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (reveal -10) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -3) (("2" (hide -1) (("2" (case "length(append(val(remove_constants(cons2_var)), (: cons1_var :)))
           - 1
           < length(val(remove_constants(cons2_var)))") (("1" (hide-all-but -1) (("1" (lemma length_append[DNF_Atom]) (("1" (inst?) (("1" (replace -1 -2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (simplify) (("2" (hide -1) (("2" (case "length[DNF_Atom]((: cons1_var :)) - 1 = 0") (("1" (replace -1 -2) (("1" (hide -1) (("1" (case "nth((: cons1_var :), 0) = cons1_var") (("1" (replace -1 -2) (("1" (assert) (("1" (hide -1) (("1" (lemma "length_append[DNF_Atom]") (("1" (inst?) (("1" (replace -1 1) (("1" (hide -1) (("1" (case "length[DNF_Atom]((: cons1_var :))
           - 1 = 0") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "nth") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "length") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (lemma length_append[DNF_Atom]) (("2" (reveal -6) (("2" (replace -1 1) (("2" (inst?) (("2" (replace -2 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -2 -3 -4 -5 -6) (("2" (hide -2) (("2" (skeep) (("2" (inst -1 "j") (("1" (assert) (("1" (typepred "j") (("1" (lemma nth_append[DNF_Atom]) (("1" (inst?) (("1" (split -1) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "j") (("2" (hide 2) (("2" (reveal -3) (("2" (replace -1 1) (("2" (hide -1) (("2" (lemma "length_append[DNF_Atom]") (("2" (inst?) (("2" (replace -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (case "j < length(val(remove_constants(cons2_var))) - 1") (("1" (assert) (("1" (inst -7 "j") (("1" (assert) (("1" (lemma nth_append[DNF_Atom]) (("1" (inst?) (("1" (split -1) (("1" (assert) nil nil) ("2" (hide 2 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (assert) (("2" (case "j = length(val(remove_constants(cons(cons1_var, cons2_var))))- 1") (("1" (postpone) nil nil) ("2" (hide -7 -9) (("2" (hide -5 -6) (("2" (typepred "j") (("2" (replace -4 -1) (("2" (replace -4 1) (("2" (lemma length_append[DNF_Atom]) (("2" (inst?) (("2" (replace -1 -2) (("2" (replace -1 1) (("2" (hide -1) (("2" (hide -2 -3 -4 -5 -6) (("2" (case "length[DNF_Atom]((: cons1_var :)) = 1") (("1" (replace -1 -2) (("1" (replace -1 1) (("1" (simplify) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (hide -3 -4) (("3" (hide -1) (("3" (expand "remove_constants") (("3" (expand "remove_constants_rec") (("3" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (skeep) (("2" (hide -2 -3) (("2" (typepred "remove_constants(cons2_var)") (("2" (split -1) (("1" (inst -1 "j") (("1" (split 1) (("1" (typepred " deg(nth(val(remove_constants(cons2_var)), j)`plist)") (("1" (hide -1 -2 -3 -4) (("1" (split -1) (("1" (lemma "list2array_sound[rat]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 3) (("3" (hide -2 -3) (("3" (expand "remove_constants") (("3" (expand "remove_constants_rec" -1) (("3" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (case "length(val(remove_constants(cons2_var))) = 0") (("1" (hide 1) (("1" (lemma "eval_remove_constants") (("1" (inst?) (("1" (split -1) (("1" (hide -5) (("1" (case "val(remove_constants(cons2_var)) = null") (("1" (replace -1 -2) (("1" (case "(FORALL (j:
                 upto(length(val(remove_constants(cons
                                                  (cons1_var, cons2_var))))
                       - 1)):
         rel5(to_nat(nth(val(remove_constants(cons(cons1_var, cons2_var))),
                         j)`rel))
             (polynomial(list2array[rat]
                             (0)
                             (nth(val(remove_constants
                                      (cons(cons1_var, cons2_var))),
                                  j)`plist),
                         deg(nth(val(remove_constants
                                     (cons(cons1_var, cons2_var))),
                                 j)`plist))
                        (x),
              0))
       IFF (eval_atm(cons1_var)(x) AND eval_atm_list(null)(x))") (("1" (ground) nil nil) ("2" (hide 3) (("2" (case "eval_atm_list(null)(x) = TRUE") (("1" (assert) (("1" (case "val(remove_constants(cons(cons1_var, cons2_var))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (split 1) (("1" (flatten 1) (("1" (inst -1 "0") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (hide -2 -3 -4 -5 -6 -7 -8 -9 2) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "remove_constants(cons(cons1_var, cons2_var))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -3 -1) (("1" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep) (("2" (case "j = 0") (("1" (replace -1 1) (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (split -1) (("1" (inst -1 "x") (("1" (assert) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "remove_constants(cons(cons1_var, cons2_var))") (("2" (split -1) (("1" (inst -1 "0") (("1" (replace -4 -1) (("1" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (typepred "j") (("2" (replace -3 -1) (("2" (hide -2 -3 -4 -5 -6 -7 -8 -9) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants_rec" 1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants" -8) (("1" (expand "remove_constants_rec" -8) (("1" (expand "remove_constants" -4) (("1" (replace -4 -8) (("1" (hide-all-but -8) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "remove_constants" -6) (("2" (expand "remove_constants_rec" -6) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma relation_remove_constants_rec) (("2" (inst -1 "cons2_var" "null" "cons1_var") (("2" (split -1) (("1" (expand "remove_constants" -3) (("1" (replace -3 -1) (("1" (expand "append" -1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (hide -1 -2 -3 -4 -6) (("2" (hide 2 3 4) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 -3 -4 -6) (("3" (hide 2 3 4) (("3" (lemma "when_not_none") (("3" (inst?) (("3" (expand "remove_constants" -2) (("3" (expand "remove_constants_rec" -2) (("3" (inst -1 "cons(cons1_var, null)") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eval_atm_list") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -1 -3 -4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -3 -4) (("2" (expand "remove_constants" -1) (("2" (expand "remove_constants") (("2" (hide -1) (("2" (expand "remove_constants_rec" -1) (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst?) (("2" (inst -1 "cons(cons1_var, null)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3 4) (("2" (hide -1 -2 -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (typepred "to_nat(nth[DNF_Atom]
                          (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("3" (split 1) (("1" (assert) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (satisfiability_relation_system-2 nil 3770717500 ("" (induct "ll") (("1" (grind) nil nil) ("2" (skeep) (("2" (case "cons2_var = null") (("1" (replace -1 1) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (hide -2) (("1" (replace -1 -4) (("1" (replace -1 -2) (("1" (case "cons(cons1_var, cons2_var) = (: cons1_var :)") (("1" (replace -1 -4) (("1" (case "some?(remove_constants((: cons1_var :)))") (("1" (hide -4) (("1" (lemma "satisfiability_relation") (("1" (hide -1) (("1" (case " length(val(remove_constants((: cons1_var :)))) = 1") (("1" (inst -6 "0") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (skeep) (("1" (split -1) (("1" (inst -1 "x") (("1" (skeep) (("1" (typepred "j") (("1" (case "j = 0") (("1" (replace -1 2) (("1" (case "(eval_atm(nth(val(remove_constants(cons(cons1_var, null))), 0))(x)) IFF eval_atm(cons1_var)(x)") (("1" (grind) nil nil) ("2" (hide 3) (("2" (hide 2) (("2" (hide -3 -4) (("2" (case "val(remove_constants(cons(cons1_var, null))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2) (("2" (hide -4 -6) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -6) (("1" (hide-all-but -6) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -3) (("2" (hide -2) (("2" (replace -4 -1) (("2" (replace -2 -1) (("2" (simplify) (("2" (hide -2 -3 -4 -5 -6 -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2 -3 -5) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec") (("2" (expand "remove_constants_rec") (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2 -3 -4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "eval_truth") (("2" (inst? -1) (("2" (replace -1 2) (("2" (hide -1) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (typepred "to_nat(nth[DNF_Atom]
                      (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("3" (split 1) (("1" (assert) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (satisfiability_relation_system-1 nil 3770657146 ("" (induct "ll") (("1" (grind) nil nil) ("2" (skeep) (("2" (case "cons2_var = null") (("1" (replace -1 1) (("1" (expand "eval_atm_list" 1) (("1" (expand "eval_atm_list" 1) (("1" (hide -2) (("1" (replace -1 -4) (("1" (replace -1 -2) (("1" (case "cons(cons1_var, cons2_var) = (: cons1_var :)") (("1" (replace -1 -4) (("1" (case "some?(remove_constants((: cons1_var :)))") (("1" (hide -4) (("1" (lemma "satisfiability_relation") (("1" (hide -1) (("1" (case " length(val(remove_constants((: cons1_var :)))) = 1") (("1" (inst -6 "0") (("1" (lemma satisfiability_relation) (("1" (inst?) (("1" (skeep) (("1" (split -1) (("1" (inst -1 "x") (("1" (skeep) (("1" (typepred "j") (("1" (case "j = 0") (("1" (replace -1 2) (("1" (case "(eval_atm(nth(val(remove_constants(cons(cons1_var, null))), 0))(x)) IFF eval_atm(cons1_var)(x)") (("1" (grind) nil nil) ("2" (hide 3) (("2" (hide 2) (("2" (hide -3 -4) (("2" (case "val(remove_constants(cons(cons1_var, null))) = (: cons1_var :)") (("1" (replace -1 1) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2) (("2" (hide -4 -6) (("2" (expand "remove_constants") (("2" (expand "remove_constants_rec") (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) (("1" (expand "remove_constants_rec" -6) (("1" (hide-all-but -6) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "remove_constants_rec" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (hide -3) (("2" (hide -2) (("2" (replace -4 -1) (("2" (replace -2 -1) (("2" (simplify) (("2" (hide -2 -3 -4 -5 -6 -7) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2 -3 -5) (("2" (expand "remove_constants" 1) (("2" (expand "remove_constants" -2) (("2" (expand "remove_constants_rec") (("2" (expand "remove_constants_rec") (("2" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -2 -3 -4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (split -1) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (hide 3 -3) (("3" (expand "remove_constants") (("3" (expand "remove_constants_rec" -1) (("3" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (lemma "when_not_none") (("2" (inst -1 "cons2_var" "cons(cons1_var, null)" "null") (("2" (split -1) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -3 3) (("4" (expand "remove_constants") (("4" (expand "remove_constants_rec" -2) (("4" (case "deg(cons1_var`plist) < 1") (("1" (assert) (("1" (case "eval_atm(cons1_var)(0)") (("1" (assert) nil nil) ("2" (expand "remove_constants_rec" -2) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma relation_remove_constants_rec) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (typepred "to_nat(nth[DNF_Atom]
                  (val[list[DNF_Atom]](remove_constants(ll)), j1)`rel)") (("3" (split 1) (("1" (assert) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (conj_to_tarski_sound 0 (conj_to_tarski_sound-1 nil 3770653842 ("" (skeep) (("" (expand "conj_to_tarski") (("" (case "remove_constants(ll) = None") (("1" (assert) (("1" (lemma eval_remove_constants_none) (("1" (inst?) (("1" (split -1) (("1" (hide -2) (("1" (skeep -2) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case "length(val(remove_constants(ll))) = 0") (("1" (assert) (("1" (lemma "eval_remove_constants") (("1" (inst?) (("1" (inst -1 "0") (("1" (split -1) (("1" (inst 2 "0") (("1" (replace 2 -1) (("1" (grind) (("1" (expand "eval_atm_list") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma tarski_def) (("2" (inst?) (("1" (lemma satisfiability_relation_system) (("1" (inst? -1) (("1" (split -1) (("1" (split -2) (("1" (split 3) (("1" (flatten 1) (("1" (assert) (("1" (skeep -2) (("1" (inst -3 "x") (("1" (inst 1 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (assert) (("2" (hide 1) (("2" (skeep -1) (("2" (inst -2 "x") (("2" (inst 1 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (hide 2 3) (("2" (skeep) (("2" (case "j_1 <= length(val(remove_constants(ll))) - 1") (("1" (assert) (("1" (typepred "remove_constants(ll)") (("1" (hide -2 -3) (("1" (split -1) (("1" (inst -1 "j_1") (("1" (assert) (("1" (flatten -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) (("1" (typepred "nth(val(remove_constants_rec(ll, null)), j_1)") (("1" (assert) (("1" (typepred "remove_constants(ll)") (("1" (split -1) (("1" (inst -1 "j_1") (("1" (flatten -1) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "j_1") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (grind) (("2" (reveal 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) (("2" (reveal 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (typepred "remove_constants(ll)") (("2" (split -1) (("1" (inst -1 "j") (("1" (assert) (("1" (flatten -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 3)) (("3" (assert) nil nil)) nil) ("4" (hide-all-but (1 2)) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (split 1) (("1" (typepred "to_nat(nth[DNF_Atom]
                  (val[list[DNF_Atom]](remove_constants(ll)), j)`rel)") (("1" (assert) nil nil)) nil) ("2" (typepred "to_nat(nth[DNF_Atom]
                  (val[list[DNF_Atom]](remove_constants(ll)), j)`rel)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (conj_to_tarski const-decl "bool" dnf_strategy nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (ll skolem-const-decl "list[DNF_Atom]" dnf_strategy nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (to_nat const-decl "upto(5)" poly_system_strategy nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (subrange type-eq-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (remove_constants_rec def-decl "Maybe[list[DNF_Atom]]" dnf_strategy nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (j_1 skolem-const-decl "upto(length(val(remove_constants(ll))) - 1)" dnf_strategy nil) (satisfiability_relation_system formula-decl nil dnf_strategy nil) (tarski_def formula-decl nil poly_system_strategy nil) (eval_atm_list def-decl "bool" dnf_polynomials nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (polynomial const-decl "[real -> real]" polynomials reals) (eval_rel const-decl "bool" dnf_polynomials nil) (eval_atm const-decl "bool" dnf_polynomials nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (sigma_rat application-judgement "rational" sigma_nat reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (eval_remove_constants formula-decl nil dnf_strategy nil) (eval_remove_constants_none formula-decl nil dnf_strategy nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (Maybe type-decl nil Maybe structures) (= const-decl "[T, T -> boolean]" equalities nil) (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (val adt-accessor-decl "[(some?) -> T]" Maybe structures) (below type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (remove_constants const-decl "{m: Maybe[list[DNF_Atom]] |
   some?(m) IMPLIES
    FORALL (i: below(length(val(m)))):
      (nth(val(m), i))`d >= 1 AND
       ((nth(val(m), i))`pn)((nth(val(m), i))`d) /= 0}" dnf_strategy nil) (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe structures) (None adt-constructor-decl "(none?)" Maybe structures)) shostak)) (dnf_eval_truth 0 (dnf_eval_truth-1 nil 3770737292 ("" (induct "d") (("1" (grind) nil nil) ("2" (skeep) (("2" (skeep) (("2" (inst -1 "x") (("2" (expand "eval" 1) (("2" (split 1) (("1" (flatten 1) (("1" (split -1) (("1" (inst 1 "0") (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (inst 1 "i + 1") (("1" (grind) nil nil) ("2" (typepred "i") (("2" (hide -2 -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep -1) (("2" (typepred "i") (("2" (case "i = 0") (("1" (replace -1 -3) (("1" (hide-all-but -3) (("1" (reveal 1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (split -3) (("1" (propax) nil nil) ("2" (inst 1 "i - 1") (("1" (grind) nil nil) ("2" (hide -2) (("2" (hide 3 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cons2_var skolem-const-decl "list[list[DNF_Atom]]" dnf_strategy nil) (cons1_var skolem-const-decl "list[DNF_Atom]" dnf_strategy nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (i skolem-const-decl "below(length(cons2_var))" dnf_strategy nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (i skolem-const-decl "below(length(cons(cons1_var, cons2_var)))" dnf_strategy nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (list_induction formula-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (eval_atm_list def-decl "bool" dnf_polynomials nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (eval def-decl "bool" dnf_polynomials nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (DNF type-eq-decl nil dnf_polynomials nil)) shostak)) (rel_to_tarski_sound 0 (rel_to_tarski_sound-1 nil 3770736851 ("" (skeep) (("" (expand "rel_to_tarski") (("" (lemma "dnf_preserves_truth") (("" (inst?) (("" (case "(EXISTS (i: below(length(dnf(rel)))):
                conj_to_tarski(nth(dnf(rel), i)))
              IFF EXISTS (x: real): eval(dnf(rel))(x)") (("1" (assert) (("1" (ground) (("1" (skeep -3) (("1" (inst -4 "x") (("1" (inst 1 "x") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep -1) (("2" (inst -2 "x") (("2" (inst 2 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma dnf_eval_truth) (("2" (split 1) (("1" (flatten 1) (("1" (skeep -1) (("1" (lemma "conj_to_tarski_sound") (("1" (inst?) (("1" (assert) (("1" (skeep -1) (("1" (inst -3 "dnf(rel)" "x") (("1" (inst 1 "x") (("1" (assert) (("1" (inst 2 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (skeep -1) (("2" (inst -2 "dnf(rel)" "x") (("2" (assert) (("2" (skeep -2) (("2" (lemma conj_to_tarski_sound) (("2" (inst?) (("2" (inst 1 "i") (("2" (assert) (("2" (inst 1 "x") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rel_to_tarski const-decl "bool" dnf_strategy nil) (PolyRelExpr type-decl nil PolyRelExpr_adt nil) (conj_to_tarski_sound formula-decl nil dnf_strategy nil) (dnf_eval_truth formula-decl nil dnf_strategy nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (rat nonempty-type-eq-decl nil rationals nil) (TarskiRel type-decl nil poly_system_strategy nil) (DNF_At type-eq-decl nil dnf_polynomials nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (DNF_Atom type-eq-decl nil dnf_polynomials nil) (length def-decl "nat" list_props nil) (DNF type-eq-decl nil dnf_polynomials nil) (dnf const-decl "DNF" dnf_polynomials nil) (below type-eq-decl nil naturalnumbers nil) (conj_to_tarski const-decl "bool" dnf_strategy nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (eval def-decl "bool" dnf_polynomials nil) (dnf_preserves_truth formula-decl nil dnf_polynomials nil)) shostak)))
