(multi_bernstein (IMP_sigma_bijection_TCC1 0 (IMP_sigma_bijection_TCC1-1 nil 3618684915 ("" (assuming-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (integer nonempty-type-from-decl nil integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (IMP_sigma_bijection assuming "sigma_set@sigma_bijection[nat].sigma_bijection" "connected_domain: ASSUMPTION (FORALL (x, y: sigma_bijection.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), sigma_bijection.T_pred(z)))"))) (bsproduct_eval_TCC1 0 (bsproduct_eval_TCC1-1 nil 3498406967 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (bsproduct_eval subtype "multi_bernstein.bsdegmono(multi_bernstein.i)" "above((number_fields.-)(multi_bernstein.j, 1))"))) (multibs_eval_rec_TCC1 0 (multibs_eval_rec_TCC1-1 nil 3498990086 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (multibs_eval_rec subtype "multi_bernstein.bsdegmono(multi_bernstein.k)" "above((number_fields.-)(multi_bernstein.f(multi_bernstein.k), 1))"))) (multibs_eval_rec_TCC2 0 (multibs_eval_rec_TCC2-1 nil 3498990086 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (multibs_eval_rec subtype "(number_fields.-)(multi_bernstein.v, 1)" "nat"))) (multibs_eval_rec_TCC3 0 (multibs_eval_rec_TCC3-1 nil 3498990086 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (multibs_eval_rec termination "multi_bernstein.multibs_eval_rec(multi_bernstein.bspoly, multi_bernstein.bsdegmono, multi_bernstein.cf, multi_bernstein.nvars, multi_bernstein.terms, (number_fields.-)(multi_bernstein.v, 1))" "nil"))) (multibs_eval_1_term 0 (multibs_eval_1_term-2 "" 3790097887 ("" (expand "multibs_eval") (("" (expand "sigma") (("" (expand "sigma") (("" (case "FORALL (X: Vars, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                          cf: Coeff, mvars: nat):
                                    cf(0) * bsproduct_eval(bspoly(0), bsdegmono, mvars+1)(X) =
                                     multibs_eval_rec(bspoly, bsdegmono, cf, mvars+1, 1, mvars+1)
                                                     (LAMBDA (i: nat): 0)(X)") (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "mvars") (("1" (skeep) (("1" (assert) (("1" (expand "bsproduct_eval") (("1" (expand "product") (("1" (expand "product") (("1" (expand "multibs_eval_rec") (("1" (rewrite "sigma_scal" :dir rl) (("1" (rewrite "sigma_restrict_eq") (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (hide 3) (("1" (expand "multibs_eval_rec") (("1" (expand "product") (("1" (expand "product") (("1" (expand "multibs_eval_mono") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "product") (("1" (expand "product") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "vv") (("2" (flatten) (("2" (skeep) (("2" (assert) (("2" (expand "bsproduct_eval" +) (("2" (expand "product" + 1) (("2" (lemma "sigma_scal") (("2" (inst - "LAMBDA (j: nat):
                                        IF j > bsdegmono(1 + vv) THEN 0
                                        ELSE bspoly(0)(1 + vv)(j) *
                                              Bern(j, bsdegmono(1 + vv))(X(1 + vv))
                                        ENDIF" "cf(0) *
                                 product(0, vv,
                                         LAMBDA (i: nat):
                                           sigma(0, bsdegmono(i),
                                                 LAMBDA (j: nat):
                                                   IF j > bsdegmono(i) THEN 0
                                                   ELSE bspoly(0)(i)(j) *
                                                         Bern(j, bsdegmono(i))(X(i))
                                                   ENDIF))" "bsdegmono(1+vv)" "0") (("1" (assert) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (expand "multibs_eval_rec" +) (("1" (rewrite "sigma_restrict_eq") (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (hide 3) (("1" (expand "bsproduct_eval") (("1" (inst?) (("1" (inst - "cf") (("1" (mult-by -1 "bspoly(0)(1 + vv)(x!1) * Bern(x!1, bsdegmono(1 + vv))(X(1 + vv))") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (rr:nat,cgm:CoeffMono): rr<=vv IMPLIES multibs_eval_rec(bspoly, bsdegmono, cf, 1 + vv, 1, 1 + rr)
                                                                                                  (cgm)(X)
                                                                                   * (bspoly(0)(1 + vv)(x!1) * Bern(x!1, bsdegmono(1 + vv))(X(1 + vv)))
                                                                                   =
                                                                                   multibs_eval_rec(bspoly, bsdegmono, cf, 2 + vv, 1, 1 + rr)
                                                                                                   (cgm WITH [(1 + vv) := x!1])(X)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 3) (("2" (induct "rr") (("1" (skeep) (("1" (expand "multibs_eval_rec") (("1" (hide -1) (("1" (lemma "sigma_scal") (("1" (inst - "(LAMBDA (d: nat):
                                                                                      multibs_eval_rec(bspoly, bsdegmono, cf, 1 + vv, 1, 0)
                                                                                                      (cgm WITH [(0) := d])(X))" "(bspoly(0)(1 + vv)(x!1) * Bern(x!1, bsdegmono(1 + vv))(X(1 + vv)))" "bsdegmono(0)" "0") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (rewrite "sigma_restrict_eq") (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (hide 3) (("1" (expand "multibs_eval_rec") (("1" (expand "multibs_eval_mono") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "product" + 3) (("1" (expand "product" + 3) (("1" (case "NOT product(0, vv,
                                                             LAMBDA (k: nat):
                                                               IF cgm WITH [(0) := x!2](k) <= bsdegmono(k)
                                                                 THEN Bern(cgm WITH [(0) := x!2](k), bsdegmono(k))(X(k))
                                                               ELSE 1
                                                               ENDIF) = product(0, vv,
                                                              LAMBDA (k: nat):
                                                                IF cgm WITH [(1 + vv) := x!1, (0) := x!2](k) <=
                                                                    bsdegmono(k)
                                                                  THEN Bern(cgm WITH [(1 + vv) := x!1, (0) := x!2](k),
                                                                            bsdegmono(k))
                                                                           (X(k))
                                                                ELSE 1
                                                                ENDIF)") (("1" (hide 3) (("1" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (case "product(0, vv,
                                                                 LAMBDA (j: nat): bspoly(0)(j)(cgm WITH [(0) := x!2](j)))=product(0, vv,
                                                                  LAMBDA (j: nat):
                                                                    bspoly(0)(j)(cgm WITH [(1 + vv) := x!1, (0) := x!2](j)))") (("1" (assert) nil nil) ("2" (hide 3) (("2" (rewrite "product_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "rr") (("2" (flatten) (("2" (skeep) (("2" (assert) (("2" (expand "multibs_eval_rec" +) (("2" (lemma "sigma_scal") (("2" (inst?) (("2" (inst - "(bspoly(0)(1 + vv)(x!1) * Bern(x!1, bsdegmono(1 + vv))(X(1 + vv)))") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (inst - "cgm WITH [(1 + rr) := x!2]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (sigma def-decl "real" sigma reals) (multibs_eval_rec def-decl "real" multi_bernstein nil) (CoeffMono type-eq-decl nil util nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (bsproduct_eval const-decl "real" multi_bernstein nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (Coeff type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (Vars type-eq-decl nil util nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (product def-decl "real" product reals) (sigma_restrict_eq formula-decl nil sigma reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (multibs_eval_mono const-decl "real" multi_bernstein nil) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (restrict const-decl "[T -> real]" sigma reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (sigma_scal formula-decl nil sigma reals) (IF const-decl "[boolean, T, T -> T]" if_def nil) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials reals) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (vv skolem-const-decl "nat" multi_bernstein nil) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (both_sides_times1_imp formula-decl nil extra_real_props nil) (cgm skolem-const-decl "CoeffMono" multi_bernstein nil) (x!2 skolem-const-decl "nat" multi_bernstein nil) (x!1 skolem-const-decl "nat" multi_bernstein nil) (restrict const-decl "[T -> real]" product reals) (product_restrict_eq formula-decl nil product reals) (multibs_eval const-decl "real" multi_bernstein nil)) shostak) (multibs_eval_1_term-1 nil 3499083500 ("" (expand "multibs_eval") (("" (expand "sigma") (("" (expand "sigma") (("" (case "FORALL (X: Vars, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                          cf: Coeff, mvars: nat):
                                    cf(0) * bsproduct_eval(bspoly(0), bsdegmono, mvars+1)(X) =
                                     multibs_eval_rec(bspoly, bsdegmono, cf, mvars+1, 1, mvars+1)
                                                     (LAMBDA (i: nat): 0)(X)") (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "mvars") (("1" (skeep) (("1" (assert) (("1" (expand "bsproduct_eval") (("1" (expand "product") (("1" (expand "product") (("1" (expand "multibs_eval_rec") (("1" (rewrite "sigma_scal" :dir rl) (("1" (rewrite "sigma_restrict_eq") (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (hide 3) (("1" (expand "multibs_eval_rec") (("1" (expand "product") (("1" (expand "product") (("1" (expand "multibs_eval_mono") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "product") (("1" (expand "product") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "vv") (("2" (flatten) (("2" (skeep) (("2" (assert) (("2" (expand "bsproduct_eval" +) (("2" (expand "product" + 1) (("2" (lemma "sigma_scal") (("2" (inst - "LAMBDA (j: nat):
                                        IF j > bsdegmono(1 + vv) THEN 0
                                        ELSE bspoly(0)(1 + vv)(j) *
                                              Bern(j, bsdegmono(1 + vv))(X(1 + vv))
                                        ENDIF" "cf(0) *
                                 product(0, vv,
                                         LAMBDA (i: nat):
                                           sigma(0, bsdegmono(i),
                                                 LAMBDA (j: nat):
                                                   IF j > bsdegmono(i) THEN 0
                                                   ELSE bspoly(0)(i)(j) *
                                                         Bern(j, bsdegmono(i))(X(i))
                                                   ENDIF))" "bsdegmono(1+vv)" "0") (("1" (assert) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (expand "multibs_eval_rec" +) (("1" (rewrite "sigma_restrict_eq") (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (hide 3) (("1" (expand "bsproduct_eval") (("1" (inst?) (("1" (inst - "cf") (("1" (mult-by -1 "bspoly(0)(1 + vv)(x!1) * Bern(x!1, bsdegmono(1 + vv))(X(1 + vv))") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (rr:nat,cgm:CoeffMono): rr<=vv IMPLIES multibs_eval_rec(bspoly, bsdegmono, cf, 1 + vv, 1, 1 + rr)
                                                                                                  (cgm)(X)
                                                                                   * (bspoly(0)(1 + vv)(x!1) * Bern(x!1, bsdegmono(1 + vv))(X(1 + vv)))
                                                                                   =
                                                                                   multibs_eval_rec(bspoly, bsdegmono, cf, 2 + vv, 1, 1 + rr)
                                                                                                   (cgm WITH [(1 + vv) := x!1])(X)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 3) (("2" (induct "rr") (("1" (skeep) (("1" (expand "multibs_eval_rec") (("1" (hide -1) (("1" (lemma "sigma_scal") (("1" (inst - "(LAMBDA (d: nat):
                                                                                      multibs_eval_rec(bspoly, bsdegmono, cf, 1 + vv, 1, 0)
                                                                                                      (cgm WITH [(0) := d])(X))" "(bspoly(0)(1 + vv)(x!1) * Bern(x!1, bsdegmono(1 + vv))(X(1 + vv)))" "bsdegmono(0)" "0") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (rewrite "sigma_restrict_eq") (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (hide 3) (("1" (expand "multibs_eval_rec") (("1" (expand "multibs_eval_mono") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "product" + 3) (("1" (expand "product" + 3) (("1" (case "NOT product(0, vv,
                                                             LAMBDA (k: nat):
                                                               IF cgm WITH [(0) := x!2](k) <= bsdegmono(k)
                                                                 THEN Bern(cgm WITH [(0) := x!2](k), bsdegmono(k))(X(k))
                                                               ELSE 1
                                                               ENDIF) = product(0, vv,
                                                              LAMBDA (k: nat):
                                                                IF cgm WITH [(1 + vv) := x!1, (0) := x!2](k) <=
                                                                    bsdegmono(k)
                                                                  THEN Bern(cgm WITH [(1 + vv) := x!1, (0) := x!2](k),
                                                                            bsdegmono(k))
                                                                           (X(k))
                                                                ELSE 1
                                                                ENDIF)") (("1" (hide 3) (("1" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (case "product(0, vv,
                                                                 LAMBDA (j: nat): bspoly(0)(j)(cgm WITH [(0) := x!2](j)))=product(0, vv,
                                                                  LAMBDA (j: nat):
                                                                    bspoly(0)(j)(cgm WITH [(1 + vv) := x!1, (0) := x!2](j)))") (("1" (assert) nil nil) ("2" (hide 3) (("2" (rewrite "product_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "rr") (("2" (flatten) (("2" (skeep) (("2" (assert) (("2" (expand "multibs_eval_rec" +) (("2" (lemma "sigma_scal") (("2" (inst?) (("2" (inst - "(bspoly(0)(1 + vv)(x!1) * Bern(x!1, bsdegmono(1 + vv))(X(1 + vv)))") (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (inst - "cgm WITH [(1 + rr) := x!2]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma def-decl "real" sigma reals) (CoeffMono type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (Vars type-eq-decl nil util nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (product def-decl "real" product reals) (sigma_restrict_eq formula-decl nil sigma reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (restrict const-decl "[T -> real]" sigma reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (sigma_scal formula-decl nil sigma reals) (Bern const-decl "real" bernstein_polynomials reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (restrict const-decl "[T -> real]" product reals) (product_restrict_eq formula-decl nil product reals)) nil)) (multibs_eval_equiv 0 (multibs_eval_equiv-3 nil 3499083601 ("" (case "FORALL (X: Vars, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                                                                         cf: Coeff, nvars, terms: posnat,cfn:nat,ct:nat,lb:nat,pz:nat): lb<=pz AND cfn+lb<=ct AND ct<=terms-1 IMPLIES LET cfnew = (LAMBDA (i:nat): IF i<=cfn+lb AND i>=cfn THEN cf(i) ELSE 0 ENDIF) IN
                                                                                                   multibs_eval(bspoly, bsdegmono, cfnew, nvars, terms)(X) =
                                                                                                    multibs_eval_rec(bspoly, bsdegmono, cfnew, nvars, terms, nvars)
                                                                                                                    (LAMBDA (i: nat): 0)(X)") (("1" (skeep) (("1" (inst - "X" "bsdegmono" "bspoly" "cf" "nvars" "terms" "0" "terms-1" "terms-1" "terms-1") (("1" (assert) (("1" (case "multibs_eval(bspoly, bsdegmono,
                                                                                                                                        LAMBDA (i: nat):
                                                                                                                                          IF i <= terms - 1 THEN cf(i) ELSE 0 ENDIF,
                                                                                                                                        nvars, terms)
                                                                                                                                       (X) = multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X) AND multibs_eval_rec(bspoly, bsdegmono,
                                                                                                                                             LAMBDA (i: nat):
                                                                                                                                               IF i <= terms - 1 THEN cf(i) ELSE 0 ENDIF,
                                                                                                                                             nvars, terms, nvars)
                                                                                                                                            (LAMBDA (i: nat): 0)(X) = multibs_eval_rec(bspoly, bsdegmono, cf, nvars, terms, nvars)
                                                                                                                                            (LAMBDA (i: nat): 0)(X)") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (split) (("1" (expand "multibs_eval") (("1" (rewrite "sigma_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (v:nat,cfmono:CoeffMono): v<=nvars IMPLIES multibs_eval_rec(bspoly, bsdegmono,
                                                                                                                                                                                                LAMBDA (i: nat):
                                                                                                                                                                                                  IF i <= terms - 1 THEN cf(i) ELSE 0 ENDIF,
                                                                                                                                                                                                nvars, terms, v)
                                                                                                                                                                                               (cfmono)(X)
                                                                                                                                                                                =
                                                                                                                                                                                multibs_eval_rec(bspoly, bsdegmono, cf, nvars, terms, v)
                                                                                                                                                                                                (cfmono)(X)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "multibs_eval_rec") (("1" (case "multibs_eval_mono(bspoly, bsdegmono,
                                                                                                                                                                                                                                                     LAMBDA (i: nat):
                                                                                                                                                                                                                                                       IF i <= terms - 1 THEN cf(i) ELSE 0 ENDIF,
                                                                                                                                                                                                                                                     nvars, terms)
                                                                                                                                                                                                                                                    (cfmono)
                                                                                                                                                                                                                                    =
                                                                                                                                                                                                                                    multibs_eval_mono(bspoly, bsdegmono, cf, nvars, terms)(cfmono)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "multibs_eval_mono") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "v") (("2" (flatten) (("2" (skeep) (("2" (expand "multibs_eval_rec" +) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "pz") (("1" (assert) nil nil) ("2" (skeep) (("2" (case "lb = 0") (("1" (replace -1) (("1" (hide -1) (("1" (hide -1) (("1" (name "bspolynew" "LAMBDA (i:nat): bspoly(i+cfn)") (("1" (lemma "multibs_eval_1_term") (("1" (inst - "X" "bsdegmono" "bspolynew" "LAMBDA (i:nat): IF i=0 THEN cf(cfn) ELSE 0 ENDIF" "nvars") (("1" (case "multibs_eval(bspolynew, bsdegmono,
                                                                                           LAMBDA (i: nat): IF i = 0 THEN cf(cfn) ELSE 0 ENDIF,
                                                                                           nvars, 1)
                                                                                          (X)=
                                                                               multibs_eval(bspoly, bsdegmono,
                                                                                           LAMBDA (i: nat):
                                                                                             IF i <= cfn AND i >= cfn THEN cf(i) ELSE 0 ENDIF,
                                                                                           nvars, terms)
                                                                                          (X)
                                                                               and
                                                                               multibs_eval_rec(bspoly, bsdegmono,
                                                                                                LAMBDA (i: nat):
                                                                                                  IF i <= cfn AND i >= cfn THEN cf(i) ELSE 0 ENDIF,
                                                                                                nvars, terms, nvars)
                                                                                               (LAMBDA (i: nat): 0)(X)=
                                                                               multibs_eval_rec(bspolynew, bsdegmono,
                                                                                                LAMBDA (i: nat):
                                                                                                  IF i = 0 THEN cf(cfn) ELSE 0 ENDIF,
                                                                                                nvars, 1, nvars)
                                                                                               (LAMBDA (i: nat): 0)(X)") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (split) (("1" (expand "multibs_eval") (("1" (expand "sigma" + 1) (("1" (expand "sigma" + 1) (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "cfn") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst - "LAMBDA (i_1: nat):
                                                                         IF i_1 <= cfn AND i_1 >= cfn THEN cf(i_1) ELSE 0 ENDIF *
                                                                          bsproduct_eval(bspoly(i_1), bsdegmono, nvars)(X)" "cfn" "0" "cfn-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(0, cfn - 1,
                                                                                                LAMBDA (i_1: nat):
                                                                                                  IF i_1 <= cfn AND i_1 >= cfn THEN cf(i_1) ELSE 0 ENDIF *
                                                                                                   bsproduct_eval(bspoly(i_1), bsdegmono, nvars)(X))=0 AND 0=
                                                                                           sigma(1 + cfn, terms - 1,
                                                                                                 LAMBDA (i_1: nat):
                                                                                                   IF i_1 <= cfn AND i_1 >= cfn THEN cf(i_1) ELSE 0 ENDIF *
                                                                                                    bsproduct_eval(bspoly(i_1), bsdegmono, nvars)(X))") (("1" (flatten) (("1" (replace -1) (("1" (hide -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (assert) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "bspolynew") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split) (("1" (rewrite "sigma_restrict_eq_0") nil nil) ("2" (rewrite "sigma_restrict_eq_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (cfm:CoeffMono,vv:nat): vv<=nvars IMPLIES multibs_eval_rec(bspoly, bsdegmono,
                                                                                         LAMBDA (i: nat):
                                                                                           IF i <= cfn AND i >= cfn THEN cf(i) ELSE 0 ENDIF,
                                                                                         nvars, terms, vv)
                                                                                        (cfm)(X)
                                                                         =
                                                                         multibs_eval_rec(bspolynew, bsdegmono,
                                                                                          LAMBDA (i: nat):
                                                                                            IF i = 0 THEN cf(cfn) ELSE 0 ENDIF,
                                                                                          nvars, 1, vv)
                                                                                         (cfm)(X)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "vv") (("1" (skeep) (("1" (expand "multibs_eval_rec") (("1" (case "multibs_eval_mono(bspoly, bsdegmono,
                                                                                                          LAMBDA (i: nat):
                                                                                                            IF i <= cfn AND i >= cfn THEN cf(i) ELSE 0 ENDIF,
                                                                                                          nvars, terms)
                                                                                                         (cfm)
                                                                                         =
                                                                                         multibs_eval_mono(bspolynew, bsdegmono,
                                                                                                           LAMBDA (i: nat):
                                                                                                             IF i = 0 THEN cf(cfn) ELSE 0 ENDIF,
                                                                                                           nvars, 1)
                                                                                                          (cfm)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "multibs_eval_mono") (("2" (expand "sigma" + 2) (("2" (expand "sigma" + 2) (("2" (expand "bspolynew") (("2" (lemma "sigma_split") (("2" (inst?) (("2" (inst - "cfn") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_split") (("2" (inst - "(LAMBDA (i_1: nat):
                                                                                    IF i_1 <= cfn AND i_1 >= cfn THEN cf(i_1) ELSE 0 ENDIF *
                                                                                     product(0, nvars - 1,
                                                                                             LAMBDA (j: nat): bspoly(i_1)(j)(cfm(j))))" "cfn" "0" "cfn-1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (case "sigma(0, cfn - 1,
                                                                                                      (LAMBDA (i_1: nat):
                                                                                                         IF i_1 <= cfn AND i_1 >= cfn THEN cf(i_1) ELSE 0 ENDIF *
                                                                                                          product(0, nvars - 1,
                                                                                                                  LAMBDA (j: nat): bspoly(i_1)(j)(cfm(j)))))=0 AND 0=
                                                                                                 sigma(1 + cfn, terms - 1,
                                                                                                       LAMBDA (i_1: nat):
                                                                                                         IF i_1 <= cfn AND i_1 >= cfn THEN cf(i_1) ELSE 0 ENDIF *
                                                                                                          product(0, nvars - 1,
                                                                                                                  LAMBDA (j: nat): bspoly(i_1)(j)(cfm(j))))") (("1" (flatten) (("1" (replace -1) (("1" (hide -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (assert) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split) (("1" (rewrite "sigma_restrict_eq_0") nil nil) ("2" (rewrite "sigma_restrict_eq_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "vv") (("2" (flatten) (("2" (skeep) (("2" (expand "multibs_eval_rec" +) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("3" (skolem 1 "pz") (("3" (flatten) (("3" (skeep) (("3" (case "lb = 0") (("1" (inst?) (("1" (inst - "cfn+lb") (("1" (assert) nil nil)) nil)) nil) ("2" (label "lbzero" 1) (("2" (hide "lbzero") (("2" (name "cflow" "LAMBDA (i:nat): IF i<=cfn+lb-1 AND i>=cfn THEN cf(i) ELSE 0 ENDIF") (("2" (name "cfhigh" "LAMBDA (i:nat): IF i=cfn+lb THEN cf(i) ELSE 0 ENDIF") (("2" (case "multibs_eval(bspoly, bsdegmono,
                                                        LAMBDA (i: nat):
                                                          IF i <= cfn + lb AND i >= cfn THEN cf(i) ELSE 0 ENDIF,
                                                        nvars, terms)
                                                       (X) = multibs_eval(bspoly, bsdegmono,
                                                        cflow,
                                                        nvars, terms)
                                                       (X)+multibs_eval(bspoly, bsdegmono,
                                                        cfhigh,
                                                        nvars, terms)
                                                       (X)") (("1" (replace -1) (("1" (case "multibs_eval_rec(bspoly, bsdegmono,
                                                                   LAMBDA (i: nat):
                                                                     IF i <= cfn + lb AND i >= cfn THEN cf(i)
                                                                     ELSE 0
                                                                     ENDIF,
                                                                   nvars, terms, nvars)
                                                                  (LAMBDA (i: nat): 0)(X) = multibs_eval_rec(bspoly, bsdegmono,
                                                                   cflow,
                                                                   nvars, terms, nvars)
                                                                  (LAMBDA (i: nat): 0)(X)+multibs_eval_rec(bspoly, bsdegmono,
                                                                   cfhigh,
                                                                   nvars, terms, nvars)
                                                                  (LAMBDA (i: nat): 0)(X)") (("1" (replace -1) (("1" (hide -1) (("1" (hide -1) (("1" (reveal "lbzero") (("1" (inst-cp - "X" "bsdegmono" "bspoly" "cf" "nvars" "terms" "cfn" "ct" "lb-1") (("1" (hide "lbzero") (("1" (assert) (("1" (replace -2) (("1" (inst - "X" "bsdegmono" "bspoly" "cf" "nvars" "terms" "cfn+lb" "ct" "0") (("1" (assert) (("1" (case "(LAMBDA (i: nat):
                                                                            IF i <= cfn + lb AND i >= cfn + lb THEN cf(i)
                                                                            ELSE 0
                                                                            ENDIF) = cfhigh") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "cfhigh") (("2" (decompose-equality) (("2" (lift-if) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (hide -1) (("2" (hide -1) (("2" (hide -1) (("2" (case "FORALL (v:nat,iggy:CoeffMono): v<=nvars IMPLIES multibs_eval_rec(bspoly, bsdegmono,
                                                         LAMBDA (i: nat):
                                                           IF i <= cfn + lb AND i >= cfn THEN cf(i)
                                                           ELSE 0
                                                           ENDIF,
                                                         nvars, terms, v)
                                                        (iggy)(X)
                                         =
                                         multibs_eval_rec(bspoly, bsdegmono, cflow, nvars, terms, v)
                                                         (iggy)(X)
                                          +
                                          multibs_eval_rec(bspoly, bsdegmono, cfhigh, nvars, terms, v)
                                                          (iggy)(X)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "multibs_eval_rec") (("1" (case "multibs_eval_mono(bspoly, bsdegmono,
                                                                  LAMBDA (i: nat):
                                                                    IF i <= cfn + lb AND i >= cfn THEN cf(i)
                                                                    ELSE 0
                                                                    ENDIF,
                                                                  nvars, terms)
                                                                 (iggy)
                                                 =
                                                 multibs_eval_mono(bspoly, bsdegmono, cfhigh, nvars, terms)(iggy)
                                                  +
                                                  multibs_eval_mono(bspoly, bsdegmono, cflow, nvars, terms)(iggy)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "multibs_eval_mono") (("2" (rewrite "sigma_sum") (("2" (hide -1) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("1" (expand "cfhigh") (("1" (expand "cflow") (("1" (lift-if) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "cfhigh") (("2" (expand "cflow") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "cflow") (("3" (expand "cfhigh") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "v") (("2" (flatten) (("2" (skeep) (("2" (expand "multibs_eval_rec" +) (("2" (rewrite "sigma_sum" +) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (hide -1) (("2" (hide -1) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_sum") (("2" (rewrite "sigma_restrict_eq") (("2" (decompose-equality) (("2" (hide 2) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("1" (expand "cfhigh") (("1" (expand "cflow") (("1" (lift-if) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "cfhigh") (("2" (expand "cflow") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "cfhigh") (("3" (expand "cflow") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cfhigh skolem-const-decl "[nat -> real]" multi_bernstein nil) (lb skolem-const-decl "nat" multi_bernstein nil) (sigma_sum formula-decl nil sigma reals) (cflow skolem-const-decl "[nat -> real]" multi_bernstein nil) (multibs_eval_1_term formula-decl nil multi_bernstein nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (bspolynew skolem-const-decl "[nat -> Polyproduct]" multi_bernstein nil) (sigma_restrict_eq_0 formula-decl nil sigma reals) (real_plus_real_is_real application-judgement "real" reals nil) (sigma_split formula-decl nil sigma reals) (sigma def-decl "real" sigma reals) (int_plus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (OR const-decl "[bool, bool -> bool]" booleans nil) (bsproduct_eval const-decl "real" multi_bernstein nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_restrict_eq formula-decl nil sigma reals) (real_times_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (restrict const-decl "[T -> real]" sigma reals) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (multibs_eval_mono const-decl "real" multi_bernstein nil) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (product def-decl "real" product reals) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Vars type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (multibs_eval const-decl "real" multi_bernstein nil) (CoeffMono type-eq-decl nil util nil) (multibs_eval_rec def-decl "real" multi_bernstein nil) (IF const-decl "[boolean, T, T -> T]" if_def nil)) nil) (multibs_eval_equiv-2 nil 3499083540 ("" (case "FORALL (X: Vars, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                                                                  cf: Coeff, nvars, terms: posnat,cfn:nat,ct:nat,lb:nat,pz:nat): lb<=pz AND cfn+lb<=ct AND ct<=terms-1 IMPLIES LET cfnew = (LAMBDA (i:nat): IF i<=cfn+lb AND i>=cfn THEN cf(i) ELSE 0 ENDIF) IN
                                                                                            multibs_eval(bspoly, bsdegmono, cfnew, nvars, terms)(X) =
                                                                                             multibs_eval_rec(bspoly, bsdegmono, cfnew, nvars, terms, nvars)
                                                                                                             (LAMBDA (i: nat): 0)(X)") (("1" (skeep) (("1" (inst - "X" "bsdegmono" "bspoly" "cf" "nvars" "terms" "0" "terms-1" "terms-1" "terms-1") (("1" (assert) (("1" (case "multibs_eval(bspoly, bsdegmono,
                                                                                                                               LAMBDA (i: nat):
                                                                                                                                 IF i <= terms - 1 THEN cf(i) ELSE 0 ENDIF,
                                                                                                                               nvars, terms)
                                                                                                                              (X) = multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X) AND multibs_eval_rec(bspoly, bsdegmono,
                                                                                                                                    LAMBDA (i: nat):
                                                                                                                                      IF i <= terms - 1 THEN cf(i) ELSE 0 ENDIF,
                                                                                                                                    nvars, terms, nvars)
                                                                                                                                   (LAMBDA (i: nat): 0)(X) = multibs_eval_rec(bspoly, bsdegmono, cf, nvars, terms, nvars)
                                                                                                                                   (LAMBDA (i: nat): 0)(X)") (("1" (assert) (("1" (flatten) (("1" (assert) nil))))) ("2" (hide 2) (("2" (hide -1) (("2" (split) (("1" (expand "multibs_eval") (("1" (rewrite "sigma_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (propax) nil))))))))))) ("2" (case "FORALL (v:nat,cfmono:CoeffMono): v<=nvars IMPLIES multibs_eval_rec(bspoly, bsdegmono,
                                                                                                                                                                                   LAMBDA (i: nat):
                                                                                                                                                                                     IF i <= terms - 1 THEN cf(i) ELSE 0 ENDIF,
                                                                                                                                                                                   nvars, terms, v)
                                                                                                                                                                                  (cfmono)(X)
                                                                                                                                                                   =
                                                                                                                                                                   multibs_eval_rec(bspoly, bsdegmono, cf, nvars, terms, v)
                                                                                                                                                                                   (cfmono)(X)") (("1" (inst?) (("1" (assert) nil))) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "multibs_eval_rec") (("1" (case "multibs_eval_mono(bspoly, bsdegmono,
                                                                                                                                                                                                                                    LAMBDA (i: nat):
                                                                                                                                                                                                                                      IF i <= terms - 1 THEN cf(i) ELSE 0 ENDIF,
                                                                                                                                                                                                                                    nvars, terms)
                                                                                                                                                                                                                                   (cfmono)
                                                                                                                                                                                                                   =
                                                                                                                                                                                                                   multibs_eval_mono(bspoly, bsdegmono, cf, nvars, terms)(cfmono)") (("1" (assert) nil) ("2" (hide 2) (("2" (expand "multibs_eval_mono") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (propax) nil))))))))))))))))))) ("2" (skolem 1 "v") (("2" (flatten) (("2" (skeep) (("2" (expand "multibs_eval_rec" +) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (inst?) nil))))))))))))))))))))))))))))))))))))))))) ("2" (hide 2) (("2" (induct "pz") (("1" (assert) nil) ("2" (skeep) (("2" (case "lb = 0") (("1" (replace -1) (("1" (hide -1) (("1" (hide -1) (("1" (name "bspolynew" "LAMBDA (i:nat): bspoly(i+cfn)") (("1" (lemma "multibs_eval_equiv2") (("1" (inst - "X" "bsdegmono" "bspolynew" "LAMBDA (i:nat): IF i=0 THEN cf(cfn) ELSE 0 ENDIF" "nvars") (("1" (case "multibs_eval(bspolynew, bsdegmono,
                                                                              LAMBDA (i: nat): IF i = 0 THEN cf(cfn) ELSE 0 ENDIF,
                                                                              nvars, 1)
                                                                             (X)=
                                                                  multibs_eval(bspoly, bsdegmono,
                                                                              LAMBDA (i: nat):
                                                                                IF i <= cfn AND i >= cfn THEN cf(i) ELSE 0 ENDIF,
                                                                              nvars, terms)
                                                                             (X)
                                                                  and
                                                                  multibs_eval_rec(bspoly, bsdegmono,
                                                                                   LAMBDA (i: nat):
                                                                                     IF i <= cfn AND i >= cfn THEN cf(i) ELSE 0 ENDIF,
                                                                                   nvars, terms, nvars)
                                                                                  (LAMBDA (i: nat): 0)(X)=
                                                                  multibs_eval_rec(bspolynew, bsdegmono,
                                                                                   LAMBDA (i: nat):
                                                                                     IF i = 0 THEN cf(cfn) ELSE 0 ENDIF,
                                                                                   nvars, 1, nvars)
                                                                                  (LAMBDA (i: nat): 0)(X)") (("1" (assert) (("1" (flatten) (("1" (assert) nil))))) ("2" (hide 2) (("2" (hide -1) (("2" (split) (("1" (expand "multibs_eval") (("1" (expand "sigma" + 1) (("1" (expand "sigma" + 1) (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "cfn") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst - "LAMBDA (i_1: nat):
                                                             IF i_1 <= cfn AND i_1 >= cfn THEN cf(i_1) ELSE 0 ENDIF *
                                                              bsproduct_eval(bspoly(i_1), bsdegmono, nvars)(X)" "cfn" "0" "cfn-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(0, cfn - 1,
                                                                               LAMBDA (i_1: nat):
                                                                                 IF i_1 <= cfn AND i_1 >= cfn THEN cf(i_1) ELSE 0 ENDIF *
                                                                                  bsproduct_eval(bspoly(i_1), bsdegmono, nvars)(X))=0 AND 0=
                                                                          sigma(1 + cfn, terms - 1,
                                                                                LAMBDA (i_1: nat):
                                                                                  IF i_1 <= cfn AND i_1 >= cfn THEN cf(i_1) ELSE 0 ENDIF *
                                                                                   bsproduct_eval(bspoly(i_1), bsdegmono, nvars)(X))") (("1" (flatten) (("1" (replace -1) (("1" (hide -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (assert) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (expand "bspolynew") (("1" (propax) nil))))))))))))))))))) ("2" (hide 2) (("2" (split) (("1" (rewrite "sigma_restrict_eq_0") nil) ("2" (rewrite "sigma_restrict_eq_0") nil))))))))))))))))))))))))))))))))))) ("2" (case "FORALL (cfm:CoeffMono,vv:nat): vv<=nvars IMPLIES multibs_eval_rec(bspoly, bsdegmono,
                                                                        LAMBDA (i: nat):
                                                                          IF i <= cfn AND i >= cfn THEN cf(i) ELSE 0 ENDIF,
                                                                        nvars, terms, vv)
                                                                       (cfm)(X)
                                                        =
                                                        multibs_eval_rec(bspolynew, bsdegmono,
                                                                         LAMBDA (i: nat):
                                                                           IF i = 0 THEN cf(cfn) ELSE 0 ENDIF,
                                                                         nvars, 1, vv)
                                                                        (cfm)(X)") (("1" (inst?) (("1" (assert) nil))) ("2" (hide 2) (("2" (induct "vv") (("1" (skeep) (("1" (expand "multibs_eval_rec") (("1" (case "multibs_eval_mono(bspoly, bsdegmono,
                                                                                     LAMBDA (i: nat):
                                                                                       IF i <= cfn AND i >= cfn THEN cf(i) ELSE 0 ENDIF,
                                                                                     nvars, terms)
                                                                                    (cfm)
                                                                    =
                                                                    multibs_eval_mono(bspolynew, bsdegmono,
                                                                                      LAMBDA (i: nat):
                                                                                        IF i = 0 THEN cf(cfn) ELSE 0 ENDIF,
                                                                                      nvars, 1)
                                                                                     (cfm)") (("1" (assert) nil) ("2" (hide 2) (("2" (expand "multibs_eval_mono") (("2" (expand "sigma" + 2) (("2" (expand "sigma" + 2) (("2" (expand "bspolynew") (("2" (lemma "sigma_split") (("2" (inst?) (("2" (inst - "cfn") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "sigma_split") (("2" (inst - "(LAMBDA (i_1: nat):
                                                                  IF i_1 <= cfn AND i_1 >= cfn THEN cf(i_1) ELSE 0 ENDIF *
                                                                   product(0, nvars - 1,
                                                                           LAMBDA (j: nat): bspoly(i_1)(j)(cfm(j))))" "cfn" "0" "cfn-1") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (case "sigma(0, cfn - 1,
                                                                               (LAMBDA (i_1: nat):
                                                                                  IF i_1 <= cfn AND i_1 >= cfn THEN cf(i_1) ELSE 0 ENDIF *
                                                                                   product(0, nvars - 1,
                                                                                           LAMBDA (j: nat): bspoly(i_1)(j)(cfm(j)))))=0 AND 0=
                                                                          sigma(1 + cfn, terms - 1,
                                                                                LAMBDA (i_1: nat):
                                                                                  IF i_1 <= cfn AND i_1 >= cfn THEN cf(i_1) ELSE 0 ENDIF *
                                                                                   product(0, nvars - 1,
                                                                                           LAMBDA (j: nat): bspoly(i_1)(j)(cfm(j))))") (("1" (flatten) (("1" (replace -1) (("1" (hide -1) (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (assert) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (propax) nil))))))))))))))))) ("2" (hide 2) (("2" (split) (("1" (rewrite "sigma_restrict_eq_0") nil) ("2" (rewrite "sigma_restrict_eq_0") nil))))))))))))))))))))))))))))))))))))))))))))) ("2" (skolem 1 "vv") (("2" (flatten) (("2" (skeep) (("2" (expand "multibs_eval_rec" +) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (inst?) nil))))))))))))))))))))))))))))))))))))))))))))))) ("2" (assert) nil))))) ("3" (skolem 1 "pz") (("3" (flatten) (("3" (skeep) (("3" (case "lb = 0") (("1" (inst?) (("1" (inst - "cfn+lb") (("1" (assert) nil))))) ("2" (label "lbzero" 1) (("2" (hide "lbzero") (("2" (name "cflow" "LAMBDA (i:nat): IF i<=cfn+lb-1 AND i>=cfn THEN cf(i) ELSE 0 ENDIF") (("2" (name "cfhigh" "LAMBDA (i:nat): IF i=cfn+lb THEN cf(i) ELSE 0 ENDIF") (("2" (case "multibs_eval(bspoly, bsdegmono,
                                           LAMBDA (i: nat):
                                             IF i <= cfn + lb AND i >= cfn THEN cf(i) ELSE 0 ENDIF,
                                           nvars, terms)
                                          (X) = multibs_eval(bspoly, bsdegmono,
                                           cflow,
                                           nvars, terms)
                                          (X)+multibs_eval(bspoly, bsdegmono,
                                           cfhigh,
                                           nvars, terms)
                                          (X)") (("1" (replace -1) (("1" (case "multibs_eval_rec(bspoly, bsdegmono,
                                                    LAMBDA (i: nat):
                                                      IF i <= cfn + lb AND i >= cfn THEN cf(i)
                                                      ELSE 0
                                                      ENDIF,
                                                    nvars, terms, nvars)
                                                   (LAMBDA (i: nat): 0)(X) = multibs_eval_rec(bspoly, bsdegmono,
                                                    cflow,
                                                    nvars, terms, nvars)
                                                   (LAMBDA (i: nat): 0)(X)+multibs_eval_rec(bspoly, bsdegmono,
                                                    cfhigh,
                                                    nvars, terms, nvars)
                                                   (LAMBDA (i: nat): 0)(X)") (("1" (replace -1) (("1" (hide -1) (("1" (hide -1) (("1" (reveal "lbzero") (("1" (inst-cp - "X" "bsdegmono" "bspoly" "cf" "nvars" "terms" "cfn" "ct" "lb-1") (("1" (hide "lbzero") (("1" (assert) (("1" (replace -2) (("1" (inst - "X" "bsdegmono" "bspoly" "cf" "nvars" "terms" "cfn+lb" "ct" "0") (("1" (assert) (("1" (case "(LAMBDA (i: nat):
                                                         IF i <= cfn + lb AND i >= cfn + lb THEN cf(i)
                                                         ELSE 0
                                                         ENDIF) = cfhigh") (("1" (assert) nil) ("2" (hide-all-but 1) (("2" (expand "cfhigh") (("2" (decompose-equality) (("2" (lift-if) (("2" (lift-if) (("2" (ground) nil))))))))))))))))))))))) ("2" (assert) nil))))))))))) ("2" (hide 2) (("2" (hide -1) (("2" (hide -1) (("2" (hide -1) (("2" (hide -1) (("2" (case "FORALL (v:nat,iggy:CoeffMono): v<=nvars IMPLIES multibs_eval_rec(bspoly, bsdegmono,
                                        LAMBDA (i: nat):
                                          IF i <= cfn + lb AND i >= cfn THEN cf(i)
                                          ELSE 0
                                          ENDIF,
                                        nvars, terms, v)
                                       (iggy)(X)
                        =
                        multibs_eval_rec(bspoly, bsdegmono, cflow, nvars, terms, v)
                                        (iggy)(X)
                         +
                         multibs_eval_rec(bspoly, bsdegmono, cfhigh, nvars, terms, v)
                                         (iggy)(X)") (("1" (inst?) (("1" (assert) nil))) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "multibs_eval_rec") (("1" (case "multibs_eval_mono(bspoly, bsdegmono,
                                             LAMBDA (i: nat):
                                               IF i <= cfn + lb AND i >= cfn THEN cf(i)
                                               ELSE 0
                                               ENDIF,
                                             nvars, terms)
                                            (iggy)
                            =
                            multibs_eval_mono(bspoly, bsdegmono, cfhigh, nvars, terms)(iggy)
                             +
                             multibs_eval_mono(bspoly, bsdegmono, cflow, nvars, terms)(iggy)") (("1" (assert) nil) ("2" (hide 2) (("2" (expand "multibs_eval_mono") (("2" (rewrite "sigma_sum") (("2" (hide -1) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("1" (expand "cfhigh") (("1" (expand "cflow") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (ground) nil))))))))))) ("2" (expand "cfhigh") (("2" (expand "cflow") (("2" (propax) nil))))) ("3" (expand "cflow") (("3" (expand "cfhigh") (("3" (propax) nil))))))))))))))))))))))))))))))) ("2" (skolem 1 "v") (("2" (flatten) (("2" (skeep) (("2" (expand "multibs_eval_rec" +) (("2" (rewrite "sigma_sum" +) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (inst?) nil))))))))))))))))))))))))))))))))))))))))))) ("2" (hide 2) (("2" (hide -1) (("2" (hide -1) (("2" (hide -1) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_sum") (("2" (rewrite "sigma_restrict_eq") (("2" (decompose-equality) (("2" (hide 2) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("1" (expand "cfhigh") (("1" (expand "cflow") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (ground) nil))))))))))) ("2" (expand "cfhigh") (("2" (expand "cflow") (("2" (propax) nil))))) ("3" (expand "cfhigh") (("3" (expand "cflow") (("3" (propax) nil)))))))))))))))))))))))))))))))))))))))))))))))))))) nil) nil nil) (multibs_eval_equiv-1 nil 3498990121 ("" (case "FORALL (X: Vars, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                   cf: Coeff, nvars, terms: posnat,cfn:nat,ct:nat): cfn<=ct IMPLIES LET cfnew = (LAMBDA (i:nat): IF i<=cfn THEN cf(i) ELSE 0 ENDIF) IN
                             multibs_eval(bspoly, bsdegmono, cfnew, nvars, terms)(X) =
                              multibs_eval_rec(bspoly, bsdegmono, cfnew, nvars, terms, nvars)
                                              (LAMBDA (i: nat): 0)(X)") (("1" (skeep) (("1" (inst - "X" "bsdegmono" "bspoly" "cf" "nvars" "terms" "terms-1" "terms-1") (("1" (assert) (("1" (case "multibs_eval(bspoly, bsdegmono,
                                              LAMBDA (i: nat):
                                                IF i <= terms - 1 THEN cf(i) ELSE 0 ENDIF,
                                              nvars, terms)
                                             (X) = multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X) AND multibs_eval_rec(bspoly, bsdegmono,
                                                   LAMBDA (i: nat):
                                                     IF i <= terms - 1 THEN cf(i) ELSE 0 ENDIF,
                                                   nvars, terms, nvars)
                                                  (LAMBDA (i: nat): 0)(X) = multibs_eval_rec(bspoly, bsdegmono, cf, nvars, terms, nvars)
                                                  (LAMBDA (i: nat): 0)(X)") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (split) (("1" (expand "multibs_eval") (("1" (rewrite "sigma_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "FORALL (v:nat,cfmono:CoeffMono): v<=nvars IMPLIES multibs_eval_rec(bspoly, bsdegmono,
                                                              LAMBDA (i: nat):
                                                                IF i <= terms - 1 THEN cf(i) ELSE 0 ENDIF,
                                                              nvars, terms, v)
                                                             (cfmono)(X)
                                              =
                                              multibs_eval_rec(bspoly, bsdegmono, cf, nvars, terms, v)
                                                              (cfmono)(X)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "multibs_eval_rec") (("1" (case "multibs_eval_mono(bspoly, bsdegmono,
                                                                           LAMBDA (i: nat):
                                                                             IF i <= terms - 1 THEN cf(i) ELSE 0 ENDIF,
                                                                           nvars, terms)
                                                                          (cfmono)
                                                          =
                                                          multibs_eval_mono(bspoly, bsdegmono, cf, nvars, terms)(cfmono)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "multibs_eval_mono") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "v") (("2" (flatten) (("2" (skeep) (("2" (expand "multibs_eval_rec" +) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "ct") (("1" (assert) nil nil) ("2" (case "FORALL (X: Vars, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                               cf: Coeff, nvars, terms: posnat):
                                          multibs_eval(bspoly, bsdegmono,
                                                       cf,
                                                       nvars, 1)
                                                      (X)
                                           =
                                           multibs_eval_rec(bspoly, bsdegmono,
                                                            cf,
                                                            nvars, 1, nvars)
                                                           (LAMBDA (i: nat): 0)(X)") (("1" (skeep) (("1" (case "cfn = 0") (("1" (replace -1) (("1" (hide -3) (("1" (hide -1) (("1" (case "multibs_eval(bspoly, bsdegmono,
                                  LAMBDA (i: nat): IF i <= 0 THEN cf(i) ELSE 0 ENDIF,
                                  nvars, terms)
                                 (X) = multibs_eval(bspoly, bsdegmono,
                                  LAMBDA (i: nat): IF i <= 0 THEN cf(i) ELSE 0 ENDIF,
                                  nvars, 1)
                                 (X)") (("1" (case " multibs_eval_rec(bspoly, bsdegmono,
                                         LAMBDA (i: nat): IF i <= 0 THEN cf(i) ELSE 0 ENDIF,
                                         nvars, terms, nvars)
                                        (LAMBDA (i: nat): 0)(X) =  multibs_eval_rec(bspoly, bsdegmono,
                                         LAMBDA (i: nat): IF i <= 0 THEN cf(i) ELSE 0 ENDIF,
                                         nvars, 1, nvars)
                                        (LAMBDA (i: nat): 0)(X)") (("1" (inst - "X" "bsdegmono" "bspoly" "LAMBDA (i:nat): IF i<=0 THEN cf(i) ELSE 0 ENDIF" "nvars" "1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (hide -1) (("2" (case "FORALL (cfmono:CoeffMono,v:nat):v<=nvars IMPLIES multibs_eval_rec(bspoly, bsdegmono,
                                                             LAMBDA (i: nat): IF i <= 0 THEN cf(i) ELSE 0 ENDIF,
                                                             nvars, terms, v)
                                                            (cfmono)(X)
                                             =
                                             multibs_eval_rec(bspoly, bsdegmono,
                                                              LAMBDA (i: nat): IF i <= 0 THEN cf(i) ELSE 0 ENDIF,
                                                              nvars, 1, v)
                                                             (cfmono)(X)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "multibs_eval_rec") (("1" (case " multibs_eval_mono(bspoly, bsdegmono,
                                               LAMBDA (i: nat): IF i <= 0 THEN cf(i) ELSE 0 ENDIF,
                                               nvars, terms)
                                              (cfmono)
                              =
                              multibs_eval_mono(bspoly, bsdegmono,
                                                LAMBDA (i: nat):
                                                  IF i <= 0 THEN cf(i) ELSE 0 ENDIF,
                                                nvars, 1)
                                               (cfmono)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "multibs_eval_mono") (("2" (lemma "sigma_split") (("2" (inst?) (("2" (inst - "0") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (assert) (("2" (rewrite "sigma_restrict_eq_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "v") (("2" (flatten) (("2" (skeep) (("2" (expand "multibs_eval_rec" +) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (expand "multibs_eval") (("2" (lemma "sigma_split") (("2" (inst?) (("2" (inst - "0") (("2" (assert) (("2" (replace -1) (("2" (hide -1) (("2" (assert) (("2" (rewrite "sigma_restrict_eq_0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "multibs_eval") (("2" (expand "sigma") (("2" (expand "sigma") (("2" (expand "bsproduct_eval") (("2" (case "FORALL (cfmono:CoeffMono,v:nat): v<nvars IMPLIES  cf(0) *
       product(0, v,
               LAMBDA (i: nat):
                 sigma(0, bsdegmono(i),
                       LAMBDA (j: nat):
                         IF j > bsdegmono(i) THEN 0
                         ELSE bspoly(0)(i)(j) * Bern(j, bsdegmono(i))(X(i))
                         ENDIF))
       =
       multibs_eval_rec(bspoly, bsdegmono, cf, v+1, 1, v+1)
                       (cfmono)(X)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "product") (("1" (expand "product") (("1" (expand "multibs_eval_rec") (("1" (rewrite "sigma_scal" :dir rl) (("1" (rewrite "sigma_restrict_eq") (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (hide 3) (("1" (expand "multibs_eval_rec") (("1" (expand "product") (("1" (expand "product") (("1" (expand "multibs_eval_mono") (("1" (expand "sigma") (("1" (expand "product") (("1" (expand "sigma") (("1" (expand "product") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "v") (("2" (flatten) (("2" (skeep) (("2" (expand "product " +) (("2" (inst?) (("1" (assert) (("1" (case "NOT cf(0) *
       (sigma(0, bsdegmono(1 + v),
              LAMBDA (j: nat):
                IF j > bsdegmono(1 + v) THEN 0
                ELSE bspoly(0)(1 + v)(j) *
                      Bern(j, bsdegmono(1 + v))(X(1 + v))
                ENDIF)
         *
         product(0, v,
                 LAMBDA (i: nat):
                   sigma(0, bsdegmono(i),
                         LAMBDA (j: nat):
                           IF j > bsdegmono(i) THEN 0
                           ELSE bspoly(0)(i)(j) *
                                 Bern(j, bsdegmono(i))(X(i))
                           ENDIF))) = multibs_eval_rec(bspoly, bsdegmono, cf, 1 + v, 1, 1 + v)(cf)(X)*sigma(0, bsdegmono(1 + v),
              LAMBDA (j: nat):
                IF j > bsdegmono(1 + v) THEN 0
                ELSE bspoly(0)(1 + v)(j) *
                      Bern(j, bsdegmono(1 + v))(X(1 + v))
                ENDIF)") (("1" (assert) nil nil) ("2" (replace -1) (("2" (hide -1) (("2" (hide -1) (("2" (expand "multibs_eval_rec" + 2) (("2" (rewrite "sigma_scal" :dir rl) (("2" (rewrite "sigma_restrict_eq") (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (hide 3) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil)) nil)) nil) nil shostak)) (multibs_eval_below_mono 0 (multibs_eval_below_mono-2 "" 3790097892 ("" (skosimp*) (("" (expand "multibs_eval") (("" (rewrite "sigma_eq") (("" (hide 2) (("" (skosimp*) (("" (case "bsproduct_eval(bspoly!1(n!1), bsdegmono!1, nvars!1)(X!1)
       =bsproduct_eval(bspoly!1(n!1), bsdegmono!1, nvars!1)(Y!1)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (rewrite "sigma_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((multibs_eval const-decl "real" multi_bernstein nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (product_eq formula-decl nil product reals) (sigma def-decl "real" sigma reals) (IF const-decl "[boolean, T, T -> T]" if_def nil) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (T_low type-eq-decl nil sigma reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_high type-eq-decl nil sigma reals) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (MultiBernstein type-eq-decl nil util nil) (bsproduct_eval const-decl "real" multi_bernstein nil) (Vars type-eq-decl nil util nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (DegreeMono type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (sigma_eq formula-decl nil sigma reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak) (multibs_eval_below_mono-1 nil 3509119235 ("" (skosimp*) (("" (expand "multibs_eval") (("" (rewrite "sigma_eq") (("" (hide 2) (("" (skosimp*) (("" (case "bsproduct_eval(bspoly!1(n!1), bsdegmono!1, nvars!1)(X!1)
       =bsproduct_eval(bspoly!1(n!1), bsdegmono!1, nvars!1)(Y!1)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (rewrite "sigma_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (product_eq formula-decl nil product reals) (sigma def-decl "real" sigma reals) (Bern const-decl "real" bernstein_polynomials reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (le_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (MultiBernstein type-eq-decl nil util nil) (Vars type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (sigma_eq formula-decl nil sigma reals)) shostak)) (multibs_eval_id 0 (multibs_eval_id-2 "" 3790097893 ("" (skeep) (("" (expand "multibs_eval") (("" (decompose-equality) (("" (rewrite "sigma_restrict_eq") (("" (hide 2) (("" (decompose-equality) (("" (expand "restrict") (("" (lift-if) (("" (ground) (("" (case "bsproduct_eval(bspoly(x!2), bsdegmono, nvars)(x!1) =
       bsproduct_eval(bspolz(x!2), bsdegmono, nvars)(x!1)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (rewrite "sigma_restrict_eq") (("1" (hide 3) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((multibs_eval const-decl "real" multi_bernstein nil) (sigma_restrict_eq formula-decl nil sigma reals) (restrict const-decl "[T -> real]" sigma reals) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (x!3 skolem-const-decl "nat" multi_bernstein nil) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (restrict const-decl "[T -> real]" product reals) (product_restrict_eq formula-decl nil product reals) (IF const-decl "[boolean, T, T -> T]" if_def nil) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (Vars type-eq-decl nil util nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (Coeff type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (bsproduct_eval const-decl "real" multi_bernstein nil) (MultiBernstein type-eq-decl nil util nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak) (multibs_eval_id-1 nil 3500206292 ("" (skeep) (("" (expand "multibs_eval") (("" (decompose-equality) (("" (rewrite "sigma_restrict_eq") (("" (hide 2) (("" (decompose-equality) (("" (expand "restrict") (("" (lift-if) (("" (ground) (("" (case "bsproduct_eval(bspoly(x!2), bsdegmono, nvars)(x!1) =
       bsproduct_eval(bspolz(x!2), bsdegmono, nvars)(x!1)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (rewrite "sigma_restrict_eq") (("1" (hide 3) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma_restrict_eq formula-decl nil sigma reals) (restrict const-decl "[T -> real]" sigma reals) (restrict const-decl "[T -> real]" product reals) (product_restrict_eq formula-decl nil product reals) (Bern const-decl "real" bernstein_polynomials reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (MultiBernstein type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (Vars type-eq-decl nil util nil) (le_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals)) shostak)) (multibscoeff_id 0 (multibscoeff_id-1 nil 3509113819 ("" (skeep) (("" (expand "multibscoeff") (("" (rewrite "sigma_eq") (("" (hide 2) (("" (skosimp*) (("" (case "product(0, nvars - 1,
               LAMBDA (j: nat): bspoly(n!1)(j)(coeffmono1(j)))
       =
        product(0, nvars - 1,
                LAMBDA (j: nat): bspoly(n!1)(j)(coeffmono2(j)))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite "product_eq") (("2" (hide 2) (("2" (skosimp*) (("2" (expand "eq_below_mono?") (("2" (inst - "n!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((multibscoeff const-decl "real" multi_bernstein nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (product_eq formula-decl nil product reals) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (eq_below_mono? const-decl "bool" util nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (CoeffMono type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (product def-decl "real" product reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Coeff type-eq-decl nil util nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (sigma_eq formula-decl nil sigma reals) (real_times_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (Bern_coeffs_rel_implic 0 (Bern_coeffs_rel_implic-1 nil 3499007668 ("" (induct "v") (("1" (skeep) (("1" (expand "Bern_coeffs_rel_rec") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skolem 1 "v") (("2" (flatten) (("2" (skeep) (("2" (expand "Bern_coeffs_rel_rec" (-3 1)) (("2" (skosimp*) (("2" (inst -3 "d!1") (("2" (inst - "a" "a1" "bsdegmono" "bspoly" "cf" "coeffmono WITH [(v):=d!1]" "nvars" "rel" "terms") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (multibscoeff const-decl "real" multi_bernstein nil) (nat_induction formula-decl nil naturalnumbers nil) (Bern_coeffs_rel_rec def-decl "bool" multi_bernstein nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (CoeffMono type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (Bern_coeffs_rel_def 0 (Bern_coeffs_rel_def-2 "" 3790097894 ("" (case "FORALL (a: real, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                 cf: Coeff, nvars: posnat, rel: [[real, real] -> bool],
                                                 terms: posnat,v:nat,iggy,coeffmono:CoeffMono):(FORALL (j:below(nvars)): iggy(j) = coeffmono(j)) IMPLIES multibscoeff(bspoly, bsdegmono, cf, nvars, terms)
                                                               (coeffmono)=multibscoeff(bspoly, bsdegmono, cf, nvars, terms)
                                                               (iggy)") (("1" (label "cmlem" -1) (("1" (hide "cmlem") (("1" (case "FORALL (a: real, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                              cf: Coeff, nvars: posnat, rel: [[real, real] -> bool],
                                                              terms: posnat,v:nat,iggy:CoeffMono):le_below_mono?(nvars)(iggy,bsdegmono) and v<=nvars IMPLIES
                                                        (Bern_coeffs_rel_rec(bspoly, bsdegmono, cf, nvars, terms,v)(iggy,rel, a) IFF
                                                         (FORALL (coeffmono): le_below_mono?(nvars)(coeffmono,bsdegmono) AND (FORALL (k:nat): k>=v AND k<nvars IMPLIES iggy(k)=coeffmono(k)) IMPLIES
                                                            rel(multibscoeff(bspoly, bsdegmono, cf, nvars, terms)
                                                                            (coeffmono),
                                                                a)))") (("1" (skeep) (("1" (ground) (("1" (inst - "a" "bsdegmono" "bspoly" "cf" "nvars" "rel" "terms" "nvars" "LAMBDA (i:nat): 0") (("1" (expand "Bern_coeffs_rel") (("1" (assert) (("1" (skosimp*) (("1" (split -) (("1" (inst - "coeffmono!1") (("1" (assert) (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "a" "bsdegmono" "bspoly" "cf" "nvars" "rel" "terms" "nvars" "LAMBDA (i:nat): 0") (("2" (ground) (("1" (expand "Bern_coeffs_rel") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (inst -3 "coeffmono!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (hide -2) (("1" (ground) (("1" (skosimp*) (("1" (reveal "cmlem") (("1" (inst - "a" "bsdegmono" "bspoly" "cf" "nvars" "rel" "terms" "nvars" "iggy" "coeffmono!1") (("1" (assert) (("1" (expand "Bern_coeffs_rel_rec") (("1" (assert) (("1" (skosimp*) (("1" (inst - "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "iggy") (("2" (assert) (("2" (expand "Bern_coeffs_rel_rec") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "vv") (("2" (flatten) (("2" (skeep) (("2" (ground) (("1" (skosimp*) (("1" (expand "Bern_coeffs_rel_rec" -1) (("1" (inst - "coeffmono!1(vv)") (("1" (inst? -4) (("1" (assert) (("1" (split -) (("1" (inst - "coeffmono!1") (("1" (assert) (("1" (skosimp*) (("1" (inst - "k!1") (("1" (assert) (("1" (ground) (("1" (case "k!1 = vv") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "le_below_mono?") (("2" (skosimp*) (("2" (case "j!1 = vv") (("1" (inst - "vv") (("1" (assert) nil nil)) nil) ("2" (inst -4 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "le_below_mono?") (("2" (inst - "vv") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Bern_coeffs_rel_rec" +) (("2" (skosimp*) (("2" (inst? -2) (("2" (assert) (("2" (split -) (("1" (hide 2) (("1" (skosimp*) (("1" (inst -3 "coeffmono!1") (("1" (assert) (("1" (skosimp*) (("1" (inst -2 "k!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (expand "le_below_mono?") (("2" (skosimp*) (("2" (inst - "j!1") (("2" (case "j!1 = vv") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "multibscoeff") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "product(0, nvars - 1, LAMBDA (j: nat): bspoly(x!1)(j)(coeffmono(j)))
                         =
                          product(0, nvars - 1, LAMBDA (j: nat): bspoly(x!1)(j)(iggy(j)))") (("1" (assert) nil nil) ("2" (hide 3) (("2" (rewrite "product_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (restrict const-decl "[T -> real]" product reals) (product_restrict_eq formula-decl nil product reals) (restrict const-decl "[T -> real]" sigma reals) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (product def-decl "real" product reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (sigma_restrict_eq formula-decl nil sigma reals) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (Bern_coeffs_rel_rec def-decl "bool" multi_bernstein nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (le_below_mono? const-decl "bool" util nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Bern_coeffs_rel const-decl "bool" multi_bernstein nil) (NOT const-decl "[bool -> bool]" booleans nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (vv skolem-const-decl "nat" multi_bernstein nil) (coeffmono!1 skolem-const-decl "CoeffMono" multi_bernstein nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (DegreeMono type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (CoeffMono type-eq-decl nil util nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (multibscoeff const-decl "real" multi_bernstein nil)) shostak) (Bern_coeffs_rel_def-1 nil 3498927613 ("" (case "FORALL (a: real, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                 cf: Coeff, nvars: posnat, rel: [[real, real] -> bool],
                                                 terms: posnat,v:nat,iggy,coeffmono:CoeffMono):(FORALL (j:below(nvars)): iggy(j) = coeffmono(j)) IMPLIES multibscoeff(bspoly, bsdegmono, cf, nvars, terms)
                                                               (coeffmono)=multibscoeff(bspoly, bsdegmono, cf, nvars, terms)
                                                               (iggy)") (("1" (label "cmlem" -1) (("1" (hide "cmlem") (("1" (case "FORALL (a: real, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                              cf: Coeff, nvars: posnat, rel: [[real, real] -> bool],
                                                              terms: posnat,v:nat,iggy:CoeffMono):le_below_mono?(nvars)(iggy,bsdegmono) and v<=nvars IMPLIES
                                                        (Bern_coeffs_rel_rec(bspoly, bsdegmono, cf, nvars, terms,v)(iggy,rel, a) IFF
                                                         (FORALL (coeffmono): le_below_mono?(nvars)(coeffmono,bsdegmono) AND (FORALL (k:nat): k>=v AND k<nvars IMPLIES iggy(k)=coeffmono(k)) IMPLIES
                                                            rel(multibscoeff(bspoly, bsdegmono, cf, nvars, terms)
                                                                            (coeffmono),
                                                                a)))") (("1" (skeep) (("1" (ground) (("1" (inst - "a" "bsdegmono" "bspoly" "cf" "nvars" "rel" "terms" "nvars" "LAMBDA (i:nat): 0") (("1" (expand "Bern_coeffs_rel") (("1" (assert) (("1" (skosimp*) (("1" (split -) (("1" (inst - "coeffmono!1") (("1" (assert) (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "a" "bsdegmono" "bspoly" "cf" "nvars" "rel" "terms" "nvars" "LAMBDA (i:nat): 0") (("2" (ground) (("1" (expand "Bern_coeffs_rel") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (inst -3 "coeffmono!1") (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (hide -2) (("1" (ground) (("1" (skosimp*) (("1" (reveal "cmlem") (("1" (inst - "a" "bsdegmono" "bspoly" "cf" "nvars" "rel" "terms" "nvars" "iggy" "coeffmono!1") (("1" (assert) (("1" (expand "Bern_coeffs_rel_rec") (("1" (assert) (("1" (skosimp*) (("1" (inst - "j!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "iggy") (("2" (assert) (("2" (expand "Bern_coeffs_rel_rec") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "vv") (("2" (flatten) (("2" (skeep) (("2" (ground) (("1" (skosimp*) (("1" (expand "Bern_coeffs_rel_rec" -1) (("1" (inst - "coeffmono!1(vv)") (("1" (inst? -4) (("1" (assert) (("1" (split -) (("1" (inst - "coeffmono!1") (("1" (assert) (("1" (skosimp*) (("1" (inst - "k!1") (("1" (assert) (("1" (ground) (("1" (case "k!1 = vv") (("1" (replace -1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "le_below_mono?") (("2" (skosimp*) (("2" (case "j!1 = vv") (("1" (inst - "vv") (("1" (assert) nil nil)) nil) ("2" (inst -4 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "le_below_mono?") (("2" (inst - "vv") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "Bern_coeffs_rel_rec" +) (("2" (skosimp*) (("2" (inst? -2) (("2" (assert) (("2" (split -) (("1" (hide 2) (("1" (skosimp*) (("1" (inst -3 "coeffmono!1") (("1" (assert) (("1" (skosimp*) (("1" (inst -2 "k!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (expand "le_below_mono?") (("2" (skosimp*) (("2" (inst - "j!1") (("2" (case "j!1 = vv") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "multibscoeff") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "product(0, nvars - 1, LAMBDA (j: nat): bspoly(x!1)(j)(coeffmono(j)))
                         =
                          product(0, nvars - 1, LAMBDA (j: nat): bspoly(x!1)(j)(iggy(j)))") (("1" (assert) nil nil) ("2" (hide 3) (("2" (rewrite "product_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gt_realorder name-judgement "RealOrder" real_orders reals) (restrict const-decl "[T -> real]" product reals) (product_restrict_eq formula-decl nil product reals) (restrict const-decl "[T -> real]" sigma reals) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (product def-decl "real" product reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (sigma_restrict_eq formula-decl nil sigma reals) (le_below_mono? const-decl "bool" util nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (DegreeMono type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (CoeffMono type-eq-decl nil util nil)) shostak)) (multibs_cornerpoint_coeff 0 (multibs_cornerpoint_coeff-3 "" 3790097896 ("" (skosimp*) (("" (assert) (("" (name "Xv" "LAMBDA (i: nat):
                             IF coeffmono!1(i) = 0 THEN 0 ELSE 1 ENDIF") (("" (replace -1) (("" (flatten) (("" (expand "multibscoeff") (("" (expand "multibs_eval") (("" (rewrite "sigma_eq") (("" (hide 2) (("" (skosimp*) (("" (case "bsproduct_eval(bspoly!1(n!1), bsdegmono!1, nvars!1)(Xv) =
               product(0, nvars!1 - 1,
                       LAMBDA (j: nat): bspoly!1(n!1)(j)(coeffmono!1(j)))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "coeffmono!1(n!2)") (("1" (assert) (("1" (split -) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst -1 _ _ _ "coeffmono!1(n!2)-1") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(0, coeffmono!1(n!2) - 1,
                             LAMBDA (j: nat):
                               IF j > bsdegmono!1(n!2) THEN 0
                               ELSE bspoly!1(n!1)(n!2)(j) *
                                     Bern(j, bsdegmono!1(n!2))(Xv(n!2))
                               ENDIF)=0 AND sigma(1 + coeffmono!1(n!2), bsdegmono!1(n!2),
                              LAMBDA (j: nat):
                                IF j > bsdegmono!1(n!2) THEN 0
                                ELSE bspoly!1(n!1)(n!2)(j) *
                                      Bern(j, bsdegmono!1(n!2))(Xv(n!2))
                                ENDIF)=0") (("1" (flatten) (("1" (replace -1) (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (lift-if) (("1" (ground) (("1" (expand "corner_point?") (("1" (inst - "n!2") (("1" (assert) nil nil)) nil)) nil) ("2" (case "Bern(coeffmono!1(n!2), bsdegmono!1(n!2))(Xv(n!2))=1") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide 2) (("2" (expand "Xv" +) (("2" (lift-if) (("2" (ground) (("1" (expand "Bern") (("1" (rewrite "expt_1i") (("1" (replace -1) (("1" (expand "^") (("1" (expand "expt") (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Bern") (("2" (rewrite "expt_1i") (("2" (expand "corner_point?") (("2" (inst - "n!2") (("2" (assert) (("2" (replace -2) (("2" (assert) (("2" (expand "^") (("2" (expand "expt") (("2" (expand "C") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split) (("1" (rewrite "sigma_restrict_eq_0") (("1" (hide 2) (("1" (skosimp*) (("1" (lift-if) (("1" (ground) (("1" (expand "Bern") (("1" (expand "Xv" +) (("1" (expand "^") (("1" (expand "expt" + 1) (("1" (lift-if) (("1" (ground) (("1" (expand "corner_point?") (("1" (inst - "n!2") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sigma_restrict_eq_0") (("2" (hide 2) (("2" (skosimp*) (("2" (expand "Bern") (("2" (expand "Xv" +) (("2" (lift-if) (("2" (ground) (("1" (expand "^" + 1) (("1" (expand "expt" +) (("1" (propax) nil nil)) nil)) nil) ("2" (expand "^" + 1) (("2" (expand "expt" +) (("2" (lift-if) (("2" (ground) (("2" (expand "corner_point?") (("2" (inst - "n!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "corner_point?") (("2" (inst - "n!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((multibscoeff const-decl "real" multi_bernstein nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (sigma_eq formula-decl nil sigma reals) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (Coeff type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (Vars type-eq-decl nil util nil) (bsproduct_eval const-decl "real" multi_bernstein nil) (MultiBernstein type-eq-decl nil util nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (product def-decl "real" product reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Bern const-decl "real" bernstein_polynomials reals) (above nonempty-type-eq-decl nil integers nil) (sigma def-decl "real" sigma reals) (product_eq formula-decl nil product reals) (int_plus_int_is_int application-judgement "int" integers nil) (bsdegmono!1 skolem-const-decl "DegreeMono" multi_bernstein nil) (nvars!1 skolem-const-decl "posnat" multi_bernstein nil) (n!2 skolem-const-decl "subrange(0, nvars!1 - 1)" multi_bernstein nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (corner_point? const-decl "bool" util nil) (Xv skolem-const-decl "[nat -> uint8]" multi_bernstein nil) (expt_1i formula-decl nil exponentiation nil) (nat_exp application-judgement "nat" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posrat_exp application-judgement "posrat" exponentiation nil) (^ const-decl "real" exponentiation nil) (C const-decl "posnat" binomial reals) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (factorial_0 formula-decl nil factorial ints) (expt def-decl "real" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (int_times_even_is_even application-judgement "even_int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nat_expt application-judgement "nat" exponentiation nil) (sigma_restrict_eq_0 formula-decl nil sigma reals) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (odd_minus_even_is_odd application-judgement "odd_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (rat_exp application-judgement "rat" exponentiation nil) (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (int_exp application-judgement "int" exponentiation nil) (int_times_int_is_int application-judgement "int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (sigma_split formula-decl nil sigma reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (subrange type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (multibs_eval const-decl "real" multi_bernstein nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (exp2 def-decl "posnat" exp2 nil) (uint8 type-eq-decl nil integertypes nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (CoeffMono type-eq-decl nil util nil)) shostak) (multibs_cornerpoint_coeff-2 nil 3509117841 ("" (skosimp*) (("" (assert) (("" (name "Xv" "LAMBDA (i: nat):
                             IF coeffmono!1(i) = 0 THEN 0 ELSE 1 ENDIF") (("" (replace -1) (("" (flatten) (("" (expand "multibscoeff") (("" (expand "multibs_eval") (("" (rewrite "sigma_eq") (("" (hide 2) (("" (skosimp*) (("" (case "bsproduct_eval(bspoly!1(n!1), bsdegmono!1, nvars!1)(Xv) =
               product(0, nvars!1 - 1,
                       LAMBDA (j: nat): bspoly!1(n!1)(j)(coeffmono!1(j)))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_eq") (("1" (hide 2) (("1" (skosimp*) (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "coeffmono!1(n!2)") (("1" (assert) (("1" (split -) (("1" (replace -1) (("1" (hide -1) (("1" (lemma "sigma_split") (("1" (inst -1 _ _ _ "coeffmono!1(n!2)-1") (("1" (inst?) (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(0, coeffmono!1(n!2) - 1,
                             LAMBDA (j: nat):
                               IF j > bsdegmono!1(n!2) THEN 0
                               ELSE bspoly!1(n!1)(n!2)(j) *
                                     Bern(j, bsdegmono!1(n!2))(Xv(n!2))
                               ENDIF)=0 AND sigma(1 + coeffmono!1(n!2), bsdegmono!1(n!2),
                              LAMBDA (j: nat):
                                IF j > bsdegmono!1(n!2) THEN 0
                                ELSE bspoly!1(n!1)(n!2)(j) *
                                      Bern(j, bsdegmono!1(n!2))(Xv(n!2))
                                ENDIF)=0") (("1" (flatten) (("1" (replace -1) (("1" (hide -1) (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (lift-if) (("1" (ground) (("1" (expand "corner_point?") (("1" (inst - "n!2") (("1" (assert) nil nil)) nil)) nil) ("2" (case "Bern(coeffmono!1(n!2), bsdegmono!1(n!2))(Xv(n!2))=1") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide 2) (("2" (expand "Xv" +) (("2" (lift-if) (("2" (ground) (("1" (expand "Bern") (("1" (rewrite "expt_1i") (("1" (replace -1) (("1" (expand "^") (("1" (expand "expt") (("1" (expand "C") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "Bern") (("2" (rewrite "expt_1i") (("2" (expand "corner_point?") (("2" (inst - "n!2") (("2" (assert) (("2" (replace -2) (("2" (assert) (("2" (expand "^") (("2" (expand "expt") (("2" (expand "C") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split) (("1" (rewrite "sigma_restrict_eq_0") (("1" (hide 2) (("1" (skosimp*) (("1" (lift-if) (("1" (ground) (("1" (expand "Bern") (("1" (expand "Xv" +) (("1" (expand "^") (("1" (expand "expt" + 1) (("1" (lift-if) (("1" (ground) (("1" (expand "corner_point?") (("1" (inst - "n!2") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "sigma_restrict_eq_0") (("2" (hide 2) (("2" (skosimp*) (("2" (expand "Bern") (("2" (expand "Xv" +) (("2" (lift-if) (("2" (ground) (("1" (expand "^" + 1) (("1" (expand "expt" +) (("1" (propax) nil nil)) nil)) nil) ("2" (expand "^" + 1) (("2" (expand "expt" +) (("2" (lift-if) (("2" (ground) (("2" (expand "corner_point?") (("2" (inst - "n!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "corner_point?") (("2" (inst - "n!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sigma_eq formula-decl nil sigma reals) (Coeff type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (Vars type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (product def-decl "real" product reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (Bern const-decl "real" bernstein_polynomials reals) (sigma def-decl "real" sigma reals) (product_eq formula-decl nil product reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (corner_point? const-decl "bool" util nil) (C const-decl "posnat" binomial reals) (factorial_0 formula-decl nil factorial ints) (sigma_restrict_eq_0 formula-decl nil sigma reals) (sigma_split formula-decl nil sigma reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (CoeffMono type-eq-decl nil util nil)) nil) (multibs_cornerpoint_coeff-1 nil 3509117746 ("" (skeep) (("" (assert) (("" (name "Xv" "LAMBDA (i: nat):
                      IF coeffmon(i) = 0 THEN 0 ELSE 1 ENDIF") (("" (replace -1) (("" (flatten) (("" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak)) (forall_X_id 0 (forall_X_id-1 nil 3499949735 ("" (case "FORALL (cf: Coeff, bspoly, bspolz, bsdegmono, nvars, terms, rel, a):
               (FORALL (t: below(terms), v: below(nvars), i: upto(bsdegmono(v))):
                  bspoly(t)(v)(i) = bspolz(t)(v)(i))
                IMPLIES
                forall_X(bspoly, bsdegmono, cf, nvars, terms, rel, a) IMPLIES
                 forall_X(bspolz, bsdegmono, cf, nvars, terms, rel, a)") (("1" (skeep) (("1" (iff) (("1" (split) (("1" (inst?) (("1" (ground) nil nil)) nil) ("2" (inst?) (("2" (ground) (("2" (skeep) (("2" (inst? -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "forall_X") (("2" (skeep) (("2" (inst? -2) (("2" (assert) (("2" (lemma "multibs_eval_id") (("2" (inst -1 "bspoly" "bspolz" "bsdegmono" "cf" "nvars" "terms") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Vars type-eq-decl nil util nil) (multibs_eval_id formula-decl nil multi_bernstein nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Coeff type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (forall_X const-decl "bool" multi_bernstein nil)) shostak)) (forall_X_between_id 0 (forall_X_between_id-1 nil 3507233890 ("" (case "FORALL (cf: Coeff, amin, amax: real)
                    (bspoly, bspolz, bsdegmono, nvars, terms):
               (FORALL (t: below(terms), v: below(nvars), i: upto(bsdegmono(v))):
                  bspoly(t)(v)(i) = bspolz(t)(v)(i))
                IMPLIES
                forall_X_between(amin, amax)(bspoly, bsdegmono, cf, nvars, terms)
                 IMPLIES
                 forall_X_between(amin, amax)(bspolz, bsdegmono, cf, nvars, terms)") (("1" (skosimp*) (("1" (iff) (("1" (split) (("1" (inst?) (("1" (ground) nil nil)) nil) ("2" (inst -1 "cf!1" "amin!1" "amax!1" "bspolz!1" "bspoly!1" "bsdegmono!1" "nvars!1" "terms!1") (("2" (ground) (("2" (skeep 1) (("2" (inst? -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skosimp*) (("2" (expand "forall_X_between") (("2" (skeep) (("2" (inst? -2) (("2" (assert) (("2" (lemma "multibs_eval_id") (("2" (inst?) (("2" (inst -1 "bspolz!1") (("2" (split -1) (("1" (ground) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Vars type-eq-decl nil util nil) (multibs_eval_id formula-decl nil multi_bernstein nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Coeff type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (forall_X_between const-decl "bool" multi_bernstein nil)) nil)) (Bern_coeffs_endpoints_rel_rec_TCC1 0 (Bern_coeffs_endpoints_rel_rec_TCC1-1 nil 3499440937 ("" (skeep) (("" (assert) nil nil)) nil) nil nil (Bern_coeffs_endpoints_rel_rec subtype "list_adt[real].null" "{l: list_adt[real].list | booleans.IMPLIES(list_adt[real].cons?(l), booleans.AND(util.unitbox?(multi_bernstein.nvars)(array2list[real].list2array(0)(l)), list_props[real].length(l) = multi_bernstein.nvars))}"))) (Bern_coeffs_endpoints_rel_rec_TCC2 0 (Bern_coeffs_endpoints_rel_rec_TCC2-1 nil 3499440937 ("" (skeep) (("" (assert) nil nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (Bern_coeffs_endpoints_rel_rec subtype "util.corner_to_point(multi_bernstein.f, multi_bernstein.nvars)" "{l: list_adt[real].list | booleans.IMPLIES(list_adt[real].cons?(l), booleans.AND(util.unitbox?(multi_bernstein.nvars)(array2list[real].list2array(0)(l)), list_props[real].length(l) = multi_bernstein.nvars))}"))) (Bern_coeffs_endpoints_rel_rec_TCC3 0 (Bern_coeffs_endpoints_rel_rec_TCC3-1 nil 3503309476 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (Bern_coeffs_endpoints_rel_rec termination "multi_bernstein.Bern_coeffs_endpoints_rel_rec(multi_bernstein.bspoly, multi_bernstein.bsdegmono, multi_bernstein.cf, multi_bernstein.nvars, multi_bernstein.terms, (number_fields.-)(multi_bernstein.v, 1))" "nil"))) (Bern_coeffs_endpoints_rel_TCC1 0 (Bern_coeffs_endpoints_rel_TCC1-1 nil 3503309637 ("" (skeep) (("" (assert) nil nil)) nil) nil nil (Bern_coeffs_endpoints_rel subtype "list_adt[real].null" "{l: list_adt[real].list | booleans.IMPLIES(list_adt[real].cons?(l), booleans.AND(util.unitbox?(multi_bernstein.nvars)(array2list[real].list2array(0)(l)), list_props[real].length(l) = multi_bernstein.nvars))}"))) (Bern_coeffs_endpoints_rel_def 0 (Bern_coeffs_endpoints_rel_def-2 "" 3790097899 ("" (expand "Bern_coeffs_endpoints_rel") (("" (name "eptest?" "(LAMBDA (bsdegmono:DegreeMono,nvars): (LAMBDA (cfm:CoeffMono): (FORALL (i:below(nvars)): cfm(i)=0 OR cfm(i)=bsdegmono(i))))") (("" (skosimp*) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (case "FORALL (a: real, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                 cf: Coeff, nvars: posnat, rel: [[real, real] -> bool],
                                                 terms: posnat,v:nat,cfm:(eptest?(bsdegmono,nvars))): v<=nvars AND
                                           forall_X(bspoly, bsdegmono, cf, nvars, terms, rel, a) IMPLIES
                                            null?(Bern_coeffs_endpoints_rel_rec(bspoly,
                                                                          bsdegmono,
                                                                          cf,
                                                                          nvars,
                                                                          terms,
                                                                          v)
                                                                         (cfm, rel, a))") (("1" (inst?) (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "eptest?") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "Bern_coeffs_endpoints_rel_rec") (("1" (assert) (("1" (lift-if +) (("1" (assert) (("1" (ground) (("1" (hide 2) (("1" (name "Xnew" "LAMBDA (i:nat): IF cfm(i)=0 THEN 0 ELSE 1 ENDIF") (("1" (expand "forall_X") (("1" (inst - "Xnew") (("1" (split -) (("1" (case "multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(Xnew) = multibscoeff(bspoly, bsdegmono, cf, nvars, terms)(cfm)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "multibscoeff") (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(Xnew) =
                                                                        product(0, nvars - 1, LAMBDA (j: nat): bspoly(x!1)(j)(cfm(j)))") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval" +) (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (typepred "cfm") (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "cfm(x!2)") (("1" (assert) (("1" (case "cfm(x!2)<=bsdegmono(x!2)") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (case "sigma(1 + cfm(x!2), bsdegmono(x!2),
                                                                                                                     LAMBDA (j: nat):
                                                                                                                       IF j > bsdegmono(x!2) THEN 0
                                                                                                                       ELSE bspoly(x!1)(x!2)(j) *
                                                                                                                             Bern(j, bsdegmono(x!2))(Xnew(x!2))
                                                                                                                       ENDIF) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "cfm(x!2)-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(0, cfm(x!2) - 1,
                                                                                                                                    LAMBDA (j: nat):
                                                                                                                                      IF j > bsdegmono(x!2) THEN 0
                                                                                                                                      ELSE bspoly(x!1)(x!2)(j) * Bern(j, bsdegmono(x!2))(Xnew(x!2))
                                                                                                                                      ENDIF) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (expand "Xnew" +) (("1" (lift-if) (("1" (ground) (("1" (replace -1) (("1" (expand "Bern" +) (("1" (assert) (("1" (expand "^" +) (("1" (expand "expt" + 1) (("1" (case "FORALL (t:nat): expt(1,t) = 1") (("1" (inst - "bsdegmono(x!2)") (("1" (replace -1) (("1" (assert) (("1" (expand "C" +) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (induct "t") (("1" (expand "expt") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (expand "expt" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "cfm") (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) (("2" (replace -1) (("2" (expand "Bern" +) (("2" (expand "^" +) (("2" (expand "expt" + 1) (("2" (case "FORALL (t:nat): expt(1,t) = 1") (("1" (inst - "bsdegmono(x!2)") (("1" (replace -1) (("1" (expand "C" +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (induct "t") (("1" (expand "expt") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (expand "expt" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "sigma_restrict_eq_0") (("2" (hide 2) (("2" (skosimp*) (("2" (typepred "i!1") (("2" (expand "Xnew" +) (("2" (expand "Bern" +) (("2" (case "FORALL (t:nat): 0^(t+1)=0") (("1" (inst - "bsdegmono(x!2)-i!1-1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (induct "t") (("1" (expand "^") (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (expand "^") (("2" (expand "expt" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "sigma_restrict_eq_0") (("2" (hide 2) (("2" (skosimp*) (("2" (expand "Xnew" +) (("2" (lift-if) (("2" (ground) (("1" (expand "Bern" +) (("1" (expand "^") (("1" (expand "expt" + 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "Bern" +) (("2" (typepred "i!1") (("2" (typepred "cfm") (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "Xnew") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "vv") (("2" (flatten) (("2" (skeep) (("2" (expand "Bern_coeffs_endpoints_rel_rec" +) (("2" (lift-if) (("2" (ground) (("1" (inst?) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "eptest?") (("2" (skosimp*) (("2" (lift-if) (("2" (ground) (("2" (typepred "cfm") (("2" (expand "eptest?") (("2" (inst - "i!1") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "a" "bsdegmono" "bspoly" "cf" "nvars" "rel" "terms" "cfm WITH [(vv):=bsdegmono(vv)]") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "eptest?") (("2" (skosimp*) (("2" (lift-if) (("2" (ground) (("2" (typepred "cfm") (("2" (expand "eptest?") (("2" (inst - "i!1") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((OR const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (CoeffMono type-eq-decl nil util nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (DegreeMono type-eq-decl nil util nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (nvars skolem-const-decl "posnat" multi_bernstein nil) (cfm skolem-const-decl "(eptest?(bsdegmono, nvars))" multi_bernstein nil) (vv skolem-const-decl "nat" multi_bernstein nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (Bern const-decl "real" bernstein_polynomials reals) (above nonempty-type-eq-decl nil integers nil) (sigma def-decl "real" sigma reals) (product_restrict_eq formula-decl nil product reals) (restrict const-decl "[T -> real]" product reals) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (int_plus_int_is_int application-judgement "int" integers nil) (x!2 skolem-const-decl "nat" multi_bernstein nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (subrange type-eq-decl nil integers nil) (nat_expt application-judgement "nat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (/= const-decl "boolean" notequal nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (sigma_restrict_eq_0 formula-decl nil sigma reals) (posint_exp application-judgement "posint" exponentiation nil) (nat_exp application-judgement "nat" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (expt def-decl "real" exponentiation nil) (factorial_0 formula-decl nil factorial ints) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (C const-decl "posnat" binomial reals) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (^ const-decl "real" exponentiation nil) (Xnew skolem-const-decl "[nat -> uint8]" multi_bernstein nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_split formula-decl nil sigma reals) (restrict const-decl "[T -> real]" sigma reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (sigma_restrict_eq formula-decl nil sigma reals) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (bsproduct_eval const-decl "real" multi_bernstein nil) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (product def-decl "real" product reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (multibscoeff const-decl "real" multi_bernstein nil) (multibs_eval const-decl "real" multi_bernstein nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (uint8 type-eq-decl nil integertypes nil) (exp2 def-decl "posnat" exp2 nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (eptest? skolem-const-decl "[[DegreeMono, posnat] -> [CoeffMono -> boolean]]" multi_bernstein nil) (bsdegmono!1 skolem-const-decl "DegreeMono" multi_bernstein nil) (nvars!1 skolem-const-decl "posnat" multi_bernstein nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (forall_X const-decl "bool" multi_bernstein nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Vars type-eq-decl nil util nil) (unitbox? const-decl "bool" util nil) (list2array def-decl "T" array2list structures) (length def-decl "nat" list_props nil) (Bern_coeffs_endpoints_rel_rec def-decl "{l: list[real] |
   cons?(l) IMPLIES unitbox?(nvars)(list2array(0)(l)) AND length(l) = nvars}" multi_bernstein nil) (Bern_coeffs_endpoints_rel const-decl "{l: list[real] |
   cons?(l) IMPLIES unitbox?(nvars)(list2array(0)(l)) AND length(l) = nvars}" multi_bernstein nil)) shostak) (Bern_coeffs_endpoints_rel_def-1 nil 3499440937 ("" (expand "Bern_coeffs_endpoints_rel") (("" (name "eptest?" "(LAMBDA (bsdegmono:DegreeMono,nvars): (LAMBDA (cfm:CoeffMono): (FORALL (i:below(nvars)): cfm(i)=0 OR cfm(i)=bsdegmono(i))))") (("" (skosimp*) (("" (lift-if) (("" (split) (("1" (flatten) (("1" (case "FORALL (a: real, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                 cf: Coeff, nvars: posnat, rel: [[real, real] -> bool],
                                                 terms: posnat,v:nat,cfm:(eptest?(bsdegmono,nvars))): v<=nvars AND
                                           forall_X(bspoly, bsdegmono, cf, nvars, terms, rel, a) IMPLIES
                                            null?(Bern_coeffs_endpoints_rel_rec(bspoly,
                                                                          bsdegmono,
                                                                          cf,
                                                                          nvars,
                                                                          terms,
                                                                          v)
                                                                         (cfm, rel, a))") (("1" (inst?) (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "eptest?") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "Bern_coeffs_endpoints_rel_rec") (("1" (assert) (("1" (lift-if +) (("1" (assert) (("1" (ground) (("1" (hide 2) (("1" (name "Xnew" "LAMBDA (i:nat): IF cfm(i)=0 THEN 0 ELSE 1 ENDIF") (("1" (expand "forall_X") (("1" (inst - "Xnew") (("1" (split -) (("1" (case "multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(Xnew) = multibscoeff(bspoly, bsdegmono, cf, nvars, terms)(cfm)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (expand "multibscoeff") (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(Xnew) =
                                                                        product(0, nvars - 1, LAMBDA (j: nat): bspoly(x!1)(j)(cfm(j)))") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval" +) (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (typepred "cfm") (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "cfm(x!2)") (("1" (assert) (("1" (case "cfm(x!2)<=bsdegmono(x!2)") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (case "sigma(1 + cfm(x!2), bsdegmono(x!2),
                                                                                                                     LAMBDA (j: nat):
                                                                                                                       IF j > bsdegmono(x!2) THEN 0
                                                                                                                       ELSE bspoly(x!1)(x!2)(j) *
                                                                                                                             Bern(j, bsdegmono(x!2))(Xnew(x!2))
                                                                                                                       ENDIF) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "cfm(x!2)-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(0, cfm(x!2) - 1,
                                                                                                                                    LAMBDA (j: nat):
                                                                                                                                      IF j > bsdegmono(x!2) THEN 0
                                                                                                                                      ELSE bspoly(x!1)(x!2)(j) * Bern(j, bsdegmono(x!2))(Xnew(x!2))
                                                                                                                                      ENDIF) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (expand "Xnew" +) (("1" (lift-if) (("1" (ground) (("1" (replace -1) (("1" (expand "Bern" +) (("1" (assert) (("1" (expand "^" +) (("1" (expand "expt" + 1) (("1" (case "FORALL (t:nat): expt(1,t) = 1") (("1" (inst - "bsdegmono(x!2)") (("1" (replace -1) (("1" (assert) (("1" (expand "C" +) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (induct "t") (("1" (expand "expt") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (expand "expt" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "cfm") (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) (("2" (replace -1) (("2" (expand "Bern" +) (("2" (expand "^" +) (("2" (expand "expt" + 1) (("2" (case "FORALL (t:nat): expt(1,t) = 1") (("1" (inst - "bsdegmono(x!2)") (("1" (replace -1) (("1" (expand "C" +) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (induct "t") (("1" (expand "expt") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (expand "expt" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "sigma_restrict_eq_0") (("2" (hide 2) (("2" (skosimp*) (("2" (typepred "i!1") (("2" (expand "Xnew" +) (("2" (expand "Bern" +) (("2" (case "FORALL (t:nat): 0^(t+1)=0") (("1" (inst - "bsdegmono(x!2)-i!1-1") (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (induct "t") (("1" (expand "^") (("1" (expand "expt") (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (expand "^") (("2" (expand "expt" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "sigma_restrict_eq_0") (("2" (hide 2) (("2" (skosimp*) (("2" (expand "Xnew" +) (("2" (lift-if) (("2" (ground) (("1" (expand "Bern" +) (("1" (expand "^") (("1" (expand "expt" + 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "Bern" +) (("2" (typepred "i!1") (("2" (typepred "cfm") (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "Xnew") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "vv") (("2" (flatten) (("2" (skeep) (("2" (expand "Bern_coeffs_endpoints_rel_rec" +) (("2" (lift-if) (("2" (ground) (("1" (inst?) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "eptest?") (("2" (skosimp*) (("2" (lift-if) (("2" (ground) (("2" (typepred "cfm") (("2" (expand "eptest?") (("2" (inst - "i!1") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst - "a" "bsdegmono" "bspoly" "cf" "nvars" "rel" "terms" "cfm WITH [(vv):=bsdegmono(vv)]") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "eptest?") (("2" (skosimp*) (("2" (lift-if) (("2" (ground) (("2" (typepred "cfm") (("2" (expand "eptest?") (("2" (inst - "i!1") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((CoeffMono type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (Bern const-decl "real" bernstein_polynomials reals) (sigma def-decl "real" sigma reals) (product_restrict_eq formula-decl nil product reals) (restrict const-decl "[T -> real]" product reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (sigma_restrict_eq_0 formula-decl nil sigma reals) (factorial_0 formula-decl nil factorial ints) (C const-decl "posnat" binomial reals) (sigma_split formula-decl nil sigma reals) (restrict const-decl "[T -> real]" sigma reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (sigma_restrict_eq formula-decl nil sigma reals) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (product def-decl "real" product reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (le_realorder name-judgement "RealOrder" real_orders reals) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (Vars type-eq-decl nil util nil) (unitbox? const-decl "bool" util nil) (list2array def-decl "T" array2list structures)) shostak)) (Bern_coeffs_counterexample 0 (Bern_coeffs_counterexample-3 "" 3884309928 ("" (expand "Bern_coeffs_endpoints_rel") (("" (name "eptest?" "(LAMBDA (bsdegmono:DegreeMono,nvars): (LAMBDA (cfm:CoeffMono): (FORALL (i:below(nvars)): cfm(i)=0 OR cfm(i)=bsdegmono(i))))") (("" (case "NOT FORALL (a: real, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                            cf: Coeff, nvars: posnat, rel: [[real, real] -> bool],
                                                            terms: posnat,v:nat,cfm:(eptest?(bsdegmono,nvars))):
                                                      (NOT null?(Bern_coeffs_endpoints_rel_rec(bspoly,
                                                                                               bsdegmono,
                                                                                               cf,
                                                                                               nvars,
                                                                                               terms,
                                                                                               v)
                                                                                              (cfm,
                                                                                               rel,
                                                                                               a)))
                                                       IMPLIES
                                                       length(Bern_coeffs_endpoints_rel_rec(bspoly,
                                                                                            bsdegmono,
                                                                                            cf,
                                                                                            nvars,
                                                                                            terms,
                                                                                            v)
                                                                                           (cfm, rel, a))
                                                        = nvars") (("1" (hide-all-but (-1 1)) (("1" (skeep) (("1" (typepred "Bern_coeffs_endpoints_rel_rec(bspoly,
                                               bsdegmono,
                                               cf,
                                               nvars,
                                               terms,
                                               v)
                                              (cfm, rel, a)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (a: real, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                                                 cf: Coeff, nvars: posnat, rel: [[real, real] -> bool],
                                                                                 terms: posnat,v:nat,cfm:(eptest?(bsdegmono,nvars))):
                                                                           (NOT null?(Bern_coeffs_endpoints_rel_rec(bspoly,
                                                                                                                    bsdegmono,
                                                                                                                    cf,
                                                                                                                    nvars,
                                                                                                                    terms,
                                                                                                                    v)
                                                                                                                   (cfm,
                                                                                                                    rel,
                                                                                                                    a)))
                                                                            IMPLIES
                                                                             NOT rel(multibs_eval(bspoly, bsdegmono, cf, nvars, terms)
                                                                                                 (list2array(0)
                                                                                                       (Bern_coeffs_endpoints_rel_rec
                                                                                                        (bspoly,
                                                                                                         bsdegmono,
                                                                                                         cf,
                                                                                                         nvars,
                                                                                                         terms,
                                                                                                         v)
                                                                                                        (cfm, rel, a))),a)") (("1" (skeep) (("1" (case "FORALL (j: below(nvars)): intendpts(j)`1 AND intendpts(j)`2") (("1" (replace -1) (("1" (inst? -3) (("1" (assert) (("1" (inst? -2) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "eptest?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eptest?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (expand "Bern_coeffs_endpoints_rel_rec") (("1" (lift-if) (("1" (ground) (("1" (hide 2 3) (("1" (name "Xnew" "LAMBDA (i:nat): IF i<nvars THEN (IF cfm(i)=0 THEN 0 ELSE 1 ENDIF) ELSE 0 ENDIF") (("1" (case "list2array(0)(corner_to_point(cfm, nvars)) = Xnew") (("1" (replace -1) (("1" (hide -1) (("1" (case "multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(Xnew) = multibscoeff(bspoly, bsdegmono, cf, nvars, terms)(cfm)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide 2) (("2" (expand "multibscoeff") (("2" (expand "multibs_eval" +) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(Xnew) =
                                                                                                                                                                   product(0, nvars - 1, LAMBDA (j: nat): bspoly(x!1)(j)(cfm(j)))") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval" +) (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (typepred "cfm") (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "cfm(x!2)") (("1" (assert) (("1" (case "cfm(x!2)<=bsdegmono(x!2)") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (case "sigma(1 + cfm(x!2), bsdegmono(x!2),
                                                                                                                                                                                                                                                                  LAMBDA (j: nat):
                                                                                                                                                                                                                                                                    IF j > bsdegmono(x!2) THEN 0
                                                                                                                                                                                                                                                                    ELSE bspoly(x!1)(x!2)(j) *
                                                                                                                                                                                                                                                                          Bern(j, bsdegmono(x!2))(Xnew(x!2))
                                                                                                                                                                                                                                                                    ENDIF) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "cfm(x!2)-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(0, cfm(x!2) - 1,
                                                                                                                                                                                                                                                                                                     LAMBDA (j: nat):
                                                                                                                                                                                                                                                                                                       IF j > bsdegmono(x!2) THEN 0
                                                                                                                                                                                                                                                                                                       ELSE bspoly(x!1)(x!2)(j) * Bern(j, bsdegmono(x!2))(Xnew(x!2))
                                                                                                                                                                                                                                                                                                       ENDIF) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (expand "Xnew" +) (("1" (lift-if) (("1" (ground) (("1" (replace -1) (("1" (expand "Bern" +) (("1" (assert) (("1" (expand "^" +) (("1" (expand "expt" + 1) (("1" (lemma "expt_1i") (("1" (inst - "bsdegmono(x!2)") (("1" (assert) (("1" (expand "C" +) (("1" (assert) (("1" (expand "^" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "cfm") (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) (("2" (replace -1) (("2" (expand "Bern" +) (("2" (expand "^" +) (("2" (expand "expt" + 1) (("2" (lemma "expt_1i") (("2" (inst - "bsdegmono(x!2)") (("2" (expand "^" -1) (("2" (replace -1) (("2" (expand "C" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "sigma_restrict_eq_0") (("2" (hide 2) (("2" (skosimp*) (("2" (typepred "i!1") (("2" (expand "Xnew" +) (("2" (expand "Bern" +) (("2" (expand "^" +) (("2" (expand "expt" +) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "sigma_restrict_eq_0") (("2" (hide 2) (("2" (skosimp*) (("2" (expand "Xnew" +) (("2" (lift-if) (("2" (ground) (("1" (expand "Bern" +) (("1" (expand "^") (("1" (expand "expt" + 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "Bern" +) (("2" (typepred "i!1") (("2" (typepred "cfm") (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1 :dir rl) (("2" (decompose-equality 1) (("1" (expand "corner_to_point") (("1" (case "x!1 < nvars") (("1" (assert) (("1" (rewrite "array2list_inv[real]") nil nil)) nil) ("2" (assert) (("2" (rewrite "list2array_sound") nil nil)) nil)) nil)) nil) ("2" (inst 1 "0") nil nil)) nil)) nil) ("3" (inst 1 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "vv") (("2" (flatten) (("2" (skeep) (("2" (expand "Bern_coeffs_endpoints_rel_rec" (-2 1)) (("2" (lift-if) (("2" (ground) (("1" (inst? -4) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "cfm") (("2" (expand "eptest?") (("2" (skosimp*) (("2" (inst - "i!1") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst? -2) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "cfm") (("2" (expand "eptest?") (("2" (skosimp*) (("2" (inst - "i!1") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (inst 2 "0") nil nil)) nil)) nil)) nil) ("3" (skeep) (("3" (inst 2 "0") nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (Bern_coeffs_counterexample-2 "" 3790097902 ("" (expand "Bern_coeffs_endpoints_rel") (("" (name "eptest?" "(LAMBDA (bsdegmono:DegreeMono,nvars): (LAMBDA (cfm:CoeffMono): (FORALL (i:below(nvars)): cfm(i)=0 OR cfm(i)=bsdegmono(i))))") (("" (case "NOT FORALL (a: real, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                            cf: Coeff, nvars: posnat, rel: [[real, real] -> bool],
                                                            terms: posnat,v:nat,cfm:(eptest?(bsdegmono,nvars))):
                                                      (NOT null?(Bern_coeffs_endpoints_rel_rec(bspoly,
                                                                                               bsdegmono,
                                                                                               cf,
                                                                                               nvars,
                                                                                               terms,
                                                                                               v)
                                                                                              (cfm,
                                                                                               rel,
                                                                                               a)))
                                                       IMPLIES
                                                       length(Bern_coeffs_endpoints_rel_rec(bspoly,
                                                                                            bsdegmono,
                                                                                            cf,
                                                                                            nvars,
                                                                                            terms,
                                                                                            v)
                                                                                           (cfm, rel, a))
                                                        = nvars") (("1" (hide-all-but (-1 1)) (("1" (skeep) (("1" (typepred "Bern_coeffs_endpoints_rel_rec(bspoly,
                                               bsdegmono,
                                               cf,
                                               nvars,
                                               terms,
                                               v)
                                              (cfm, rel, a)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (a: real, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                                                 cf: Coeff, nvars: posnat, rel: [[real, real] -> bool],
                                                                                 terms: posnat,v:nat,cfm:(eptest?(bsdegmono,nvars))):
                                                                           (NOT null?(Bern_coeffs_endpoints_rel_rec(bspoly,
                                                                                                                    bsdegmono,
                                                                                                                    cf,
                                                                                                                    nvars,
                                                                                                                    terms,
                                                                                                                    v)
                                                                                                                   (cfm,
                                                                                                                    rel,
                                                                                                                    a)))
                                                                            IMPLIES
                                                                             NOT rel(multibs_eval(bspoly, bsdegmono, cf, nvars, terms)
                                                                                                 (list2array(0)
                                                                                                       (Bern_coeffs_endpoints_rel_rec
                                                                                                        (bspoly,
                                                                                                         bsdegmono,
                                                                                                         cf,
                                                                                                         nvars,
                                                                                                         terms,
                                                                                                         v)
                                                                                                        (cfm, rel, a))),a)") (("1" (skeep) (("1" (case "FORALL (j: below(nvars)): intendpts(j)`1 AND intendpts(j)`2") (("1" (replace -1) (("1" (inst? -3) (("1" (assert) (("1" (inst? -2) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "eptest?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eptest?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (expand "Bern_coeffs_endpoints_rel_rec") (("1" (lift-if) (("1" (ground) (("1" (hide 2 3) (("1" (name "Xnew" "LAMBDA (i:nat): IF i<nvars THEN (IF cfm(i)=0 THEN 0 ELSE 1 ENDIF) ELSE 0 ENDIF") (("1" (case "list2array(0)(corner_to_point(cfm, nvars)) = Xnew") (("1" (replace -1) (("1" (hide -1) (("1" (case "multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(Xnew) = multibscoeff(bspoly, bsdegmono, cf, nvars, terms)(cfm)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide 2) (("2" (expand "multibscoeff") (("2" (expand "multibs_eval" +) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(Xnew) =
                                                                                                                                                                   product(0, nvars - 1, LAMBDA (j: nat): bspoly(x!1)(j)(cfm(j)))") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval" +) (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (typepred "cfm") (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "cfm(x!2)") (("1" (assert) (("1" (case "cfm(x!2)<=bsdegmono(x!2)") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (case "sigma(1 + cfm(x!2), bsdegmono(x!2),
                                                                                                                                                                                                                                                                  LAMBDA (j: nat):
                                                                                                                                                                                                                                                                    IF j > bsdegmono(x!2) THEN 0
                                                                                                                                                                                                                                                                    ELSE bspoly(x!1)(x!2)(j) *
                                                                                                                                                                                                                                                                          Bern(j, bsdegmono(x!2))(Xnew(x!2))
                                                                                                                                                                                                                                                                    ENDIF) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "cfm(x!2)-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(0, cfm(x!2) - 1,
                                                                                                                                                                                                                                                                                                     LAMBDA (j: nat):
                                                                                                                                                                                                                                                                                                       IF j > bsdegmono(x!2) THEN 0
                                                                                                                                                                                                                                                                                                       ELSE bspoly(x!1)(x!2)(j) * Bern(j, bsdegmono(x!2))(Xnew(x!2))
                                                                                                                                                                                                                                                                                                       ENDIF) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (expand "Xnew" +) (("1" (lift-if) (("1" (ground) (("1" (replace -1) (("1" (expand "Bern" +) (("1" (assert) (("1" (expand "^" +) (("1" (expand "expt" + 1) (("1" (lemma "expt_1i") (("1" (inst - "bsdegmono(x!2)") (("1" (assert) (("1" (expand "C" +) (("1" (assert) (("1" (expand "^" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "cfm") (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) (("2" (replace -1) (("2" (expand "Bern" +) (("2" (expand "^" +) (("2" (expand "expt" + 1) (("2" (lemma "expt_1i") (("2" (inst - "bsdegmono(x!2)") (("2" (expand "^" -1) (("2" (replace -1) (("2" (expand "C" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "sigma_restrict_eq_0") (("2" (hide 2) (("2" (skosimp*) (("2" (typepred "i!1") (("2" (expand "Xnew" +) (("2" (expand "Bern" +) (("2" (expand "^" +) (("2" (expand "expt" +) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "sigma_restrict_eq_0") (("2" (hide 2) (("2" (skosimp*) (("2" (expand "Xnew" +) (("2" (lift-if) (("2" (ground) (("1" (expand "Bern" +) (("1" (expand "^") (("1" (expand "expt" + 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "Bern" +) (("2" (typepred "i!1") (("2" (typepred "cfm") (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1 :dir rl) (("2" (decompose-equality 1) (("2" (expand "corner_to_point") (("2" (case "x!1 < nvars") (("1" (assert) (("1" (rewrite "array2list_inv[real]") nil nil)) nil) ("2" (assert) (("2" (rewrite "list2array_sound") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "vv") (("2" (flatten) (("2" (skeep) (("2" (expand "Bern_coeffs_endpoints_rel_rec" (-2 1)) (("2" (lift-if) (("2" (ground) (("1" (inst? -4) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "cfm") (("2" (expand "eptest?") (("2" (skosimp*) (("2" (inst - "i!1") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst? -2) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "cfm") (("2" (expand "eptest?") (("2" (skosimp*) (("2" (inst - "i!1") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_coeffs_endpoints_rel const-decl "{l: list[real] |
   cons?(l) IMPLIES unitbox?(nvars)(list2array(0)(l)) AND length(l) = nvars}" multi_bernstein nil) (Bern_coeffs_endpoints_rel_rec def-decl "{l: list[real] |
   cons?(l) IMPLIES unitbox?(nvars)(list2array(0)(l)) AND length(l) = nvars}" multi_bernstein nil) (length def-decl "nat" list_props nil) (list2array def-decl "T" array2list structures) (unitbox? const-decl "bool" util nil) (Vars type-eq-decl nil util nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (Coeff type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (NOT const-decl "[bool -> bool]" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (nvars skolem-const-decl "posnat" multi_bernstein nil) (cfm skolem-const-decl "(eptest?(bsdegmono, nvars))" multi_bernstein nil) (vv skolem-const-decl "nat" multi_bernstein nil) (listn type-eq-decl nil listn structures) (corner_to_point const-decl "{l: listn[real](nvars) | unitbox?(nvars)(list2array(0)(l))}" util nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (product def-decl "real" product reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (<= const-decl "bool" reals nil) (bsproduct_eval const-decl "real" multi_bernstein nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (sigma_restrict_eq formula-decl nil sigma reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (restrict const-decl "[T -> real]" sigma reals) (sigma_split formula-decl nil sigma reals) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (Xnew skolem-const-decl "[nat -> uint8]" multi_bernstein nil) (^ const-decl "real" exponentiation nil) (expt_1i formula-decl nil exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (factorial_0 formula-decl nil factorial ints) (C const-decl "posnat" binomial reals) (expt def-decl "real" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nat_exp application-judgement "nat" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (sigma_restrict_eq_0 formula-decl nil sigma reals) (subrange type-eq-decl nil integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (x!2 skolem-const-decl "nat" multi_bernstein nil) (int_plus_int_is_int application-judgement "int" integers nil) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (restrict const-decl "[T -> real]" product reals) (product_restrict_eq formula-decl nil product reals) (sigma def-decl "real" sigma reals) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (multibscoeff const-decl "real" multi_bernstein nil) (array2list_inv formula-decl nil array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (list2array_sound formula-decl nil array2list structures) (IF const-decl "[boolean, T, T -> T]" if_def nil) (uint8 type-eq-decl nil integertypes nil) (exp2 def-decl "posnat" exp2 nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (nvars skolem-const-decl "posnat" multi_bernstein nil) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (eptest? skolem-const-decl "[[DegreeMono, posnat] -> [CoeffMono -> boolean]]" multi_bernstein nil) (IntervalEndpoints type-eq-decl nil util nil) (TRUE const-decl "bool" booleans nil) (multibs_eval const-decl "real" multi_bernstein nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (DegreeMono type-eq-decl nil util nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (CoeffMono type-eq-decl nil util nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil)) shostak) (Bern_coeffs_counterexample-1 nil 3499800124 ("" (expand "Bern_coeffs_endpoints_rel") (("" (name "eptest?" "(LAMBDA (bsdegmono:DegreeMono,nvars): (LAMBDA (cfm:CoeffMono): (FORALL (i:below(nvars)): cfm(i)=0 OR cfm(i)=bsdegmono(i))))") (("" (case "NOT FORALL (a: real, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                            cf: Coeff, nvars: posnat, rel: [[real, real] -> bool],
                                                            terms: posnat,v:nat,cfm:(eptest?(bsdegmono,nvars))):
                                                      (NOT null?(Bern_coeffs_endpoints_rel_rec(bspoly,
                                                                                               bsdegmono,
                                                                                               cf,
                                                                                               nvars,
                                                                                               terms,
                                                                                               v)
                                                                                              (cfm,
                                                                                               rel,
                                                                                               a)))
                                                       IMPLIES
                                                       length(Bern_coeffs_endpoints_rel_rec(bspoly,
                                                                                            bsdegmono,
                                                                                            cf,
                                                                                            nvars,
                                                                                            terms,
                                                                                            v)
                                                                                           (cfm, rel, a))
                                                        = nvars") (("1" (hide-all-but (-1 1)) (("1" (skeep) (("1" (typepred "Bern_coeffs_endpoints_rel_rec(bspoly,
                                               bsdegmono,
                                               cf,
                                               nvars,
                                               terms,
                                               v)
                                              (cfm, rel, a)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "FORALL (a: real, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                                                 cf: Coeff, nvars: posnat, rel: [[real, real] -> bool],
                                                                                 terms: posnat,v:nat,cfm:(eptest?(bsdegmono,nvars))):
                                                                           (NOT null?(Bern_coeffs_endpoints_rel_rec(bspoly,
                                                                                                                    bsdegmono,
                                                                                                                    cf,
                                                                                                                    nvars,
                                                                                                                    terms,
                                                                                                                    v)
                                                                                                                   (cfm,
                                                                                                                    rel,
                                                                                                                    a)))
                                                                            IMPLIES
                                                                             NOT rel(multibs_eval(bspoly, bsdegmono, cf, nvars, terms)
                                                                                                 (list2array(0)
                                                                                                       (Bern_coeffs_endpoints_rel_rec
                                                                                                        (bspoly,
                                                                                                         bsdegmono,
                                                                                                         cf,
                                                                                                         nvars,
                                                                                                         terms,
                                                                                                         v)
                                                                                                        (cfm, rel, a))),a)") (("1" (skeep) (("1" (case "FORALL (j: below(nvars)): intendpts(j)`1 AND intendpts(j)`2") (("1" (replace -1) (("1" (inst? -3) (("1" (assert) (("1" (inst? -2) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (expand "eptest?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "eptest?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replace 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (expand "Bern_coeffs_endpoints_rel_rec") (("1" (lift-if) (("1" (ground) (("1" (hide 2 3) (("1" (name "Xnew" "LAMBDA (i:nat): IF i<nvars THEN (IF cfm(i)=0 THEN 0 ELSE 1 ENDIF) ELSE 0 ENDIF") (("1" (case "list2array(0)(corner_to_point(cfm, nvars)) = Xnew") (("1" (replace -1) (("1" (hide -1) (("1" (case "multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(Xnew) = multibscoeff(bspoly, bsdegmono, cf, nvars, terms)(cfm)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide 2) (("2" (expand "multibscoeff") (("2" (expand "multibs_eval" +) (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(Xnew) =
                                                                                                                                                                   product(0, nvars - 1, LAMBDA (j: nat): bspoly(x!1)(j)(cfm(j)))") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval" +) (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (typepred "cfm") (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "cfm(x!2)") (("1" (assert) (("1" (case "cfm(x!2)<=bsdegmono(x!2)") (("1" (assert) (("1" (replace -2) (("1" (hide -2) (("1" (case "sigma(1 + cfm(x!2), bsdegmono(x!2),
                                                                                                                                                                                                                                                                  LAMBDA (j: nat):
                                                                                                                                                                                                                                                                    IF j > bsdegmono(x!2) THEN 0
                                                                                                                                                                                                                                                                    ELSE bspoly(x!1)(x!2)(j) *
                                                                                                                                                                                                                                                                          Bern(j, bsdegmono(x!2))(Xnew(x!2))
                                                                                                                                                                                                                                                                    ENDIF) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (lemma "sigma_split") (("1" (inst?) (("1" (inst - "cfm(x!2)-1") (("1" (assert) (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(0, cfm(x!2) - 1,
                                                                                                                                                                                                                                                                                                     LAMBDA (j: nat):
                                                                                                                                                                                                                                                                                                       IF j > bsdegmono(x!2) THEN 0
                                                                                                                                                                                                                                                                                                       ELSE bspoly(x!1)(x!2)(j) * Bern(j, bsdegmono(x!2))(Xnew(x!2))
                                                                                                                                                                                                                                                                                                       ENDIF) = 0") (("1" (replace -1) (("1" (hide -1) (("1" (assert) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (expand "Xnew" +) (("1" (lift-if) (("1" (ground) (("1" (replace -1) (("1" (expand "Bern" +) (("1" (assert) (("1" (expand "^" +) (("1" (expand "expt" + 1) (("1" (lemma "expt_1i") (("1" (inst - "bsdegmono(x!2)") (("1" (assert) (("1" (expand "C" +) (("1" (assert) (("1" (expand "^" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "cfm") (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) (("2" (replace -1) (("2" (expand "Bern" +) (("2" (expand "^" +) (("2" (expand "expt" + 1) (("2" (lemma "expt_1i") (("2" (inst - "bsdegmono(x!2)") (("2" (expand "^" -1) (("2" (replace -1) (("2" (expand "C" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "sigma_restrict_eq_0") (("2" (hide 2) (("2" (skosimp*) (("2" (typepred "i!1") (("2" (expand "Xnew" +) (("2" (expand "Bern" +) (("2" (expand "^" +) (("2" (expand "expt" +) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (rewrite "sigma_restrict_eq_0") (("2" (hide 2) (("2" (skosimp*) (("2" (expand "Xnew" +) (("2" (lift-if) (("2" (ground) (("1" (expand "Bern" +) (("1" (expand "^") (("1" (expand "expt" + 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "Bern" +) (("2" (typepred "i!1") (("2" (typepred "cfm") (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "eptest?" -1) (("2" (inst - "x!2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces -1 :dir rl) (("2" (decompose-equality 1) (("2" (expand "corner_to_point") (("2" (case "x!1 < nvars") (("1" (assert) (("1" (rewrite "array2list_inv[real]") nil nil)) nil) ("2" (assert) (("2" (rewrite "list2array_sound") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "vv") (("2" (flatten) (("2" (skeep) (("2" (expand "Bern_coeffs_endpoints_rel_rec" (-2 1)) (("2" (lift-if) (("2" (ground) (("1" (inst? -4) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "cfm") (("2" (expand "eptest?") (("2" (skosimp*) (("2" (inst - "i!1") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst? -2) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (typepred "cfm") (("2" (expand "eptest?") (("2" (skosimp*) (("2" (inst - "i!1") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((CoeffMono type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (IntervalEndpoints type-eq-decl nil util nil) (list2array_sound formula-decl nil array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (array2list_inv formula-decl nil array2list structures) (gt_realorder name-judgement "RealOrder" real_orders reals) (Bern const-decl "real" bernstein_polynomials reals) (sigma def-decl "real" sigma reals) (product_restrict_eq formula-decl nil product reals) (restrict const-decl "[T -> real]" product reals) (sigma_restrict_eq_0 formula-decl nil sigma reals) (C const-decl "posnat" binomial reals) (factorial_0 formula-decl nil factorial ints) (sigma_split formula-decl nil sigma reals) (restrict const-decl "[T -> real]" sigma reals) (le_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (sigma_restrict_eq formula-decl nil sigma reals) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (product def-decl "real" product reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (corner_to_point const-decl "{l: listn[real](nvars) | unitbox?(nvars)(list2array(0)(l))}" util nil) (listn type-eq-decl nil listn structures) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (Vars type-eq-decl nil util nil) (unitbox? const-decl "bool" util nil) (list2array def-decl "T" array2list structures)) nil)) (Bern_le 0 (Bern_le-2 "" 3790097904 ("" (skeep) (("" (rewrite "Bern_coeffs_rel_def") (("" (expand "forall_X") (("" (skosimp*) (("" (rewrite "multibs_eval_equiv") (("" (name "cfnew" "LAMBDA (i:nat): a/(terms)") (("" (name "bspolynew" "LAMBDA(i:nat)(j:nat)(k:nat): 1") (("" (case "multibs_eval_rec(bspoly, bsdegmono, cf, nvars, terms, nvars)
                                                                                                         (LAMBDA (i: nat): 0)(X!1) <= multibs_eval_rec(bspolynew, bsdegmono, cfnew, nvars, terms, nvars)
                                                                                                         (LAMBDA (i: nat): 0)(X!1) AND multibs_eval_rec(bspolynew, bsdegmono, cfnew, nvars, terms, nvars)
                                                                                                         (LAMBDA (i: nat): 0)(X!1) =a") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (split) (("1" (case "FORALL (cmo:CoeffMono,v:nat): v<=nvars AND le_below_mono?(nvars)(cmo,bsdegmono) IMPLIES multibs_eval_rec(bspoly, bsdegmono, cf, nvars, terms, v)
                                                                                                                                                (cmo)(X!1)
                                                                                                                                 <=
                                                                                                                                 multibs_eval_rec(bspolynew, bsdegmono, cfnew, nvars, terms, v)
                                                                                                                                                 (cmo)(X!1)") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "multibs_eval_rec" +) (("1" (case "product(0, nvars - 1,
                                                                                                                                                                                 LAMBDA (k: nat):
                                                                                                                                                                                   IF cmo(k) <= bsdegmono(k)
                                                                                                                                                                                     THEN Bern(cmo(k), bsdegmono(k))(X!1(k))
                                                                                                                                                                                   ELSE 1
                                                                                                                                                                                   ENDIF) >= 0") (("1" (case "multibs_eval_mono(bspoly, bsdegmono, cf, nvars, terms)(cmo)
                                                                                                                                                                                             <=
                                                                                                                                                                                             multibs_eval_mono(bspolynew, bsdegmono, cfnew, nvars, terms)(cmo)") (("1" (mult-by -1 "product(0, nvars - 1,
                                                                                                                                                                       LAMBDA (k: nat):
                                                                                                                                                                         IF cmo(k) <= bsdegmono(k)
                                                                                                                                                                           THEN Bern(cmo(k), bsdegmono(k))(X!1(k))
                                                                                                                                                                         ELSE 1
                                                                                                                                                                         ENDIF)") (("1" (hide 2) (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (expand "multibs_eval_mono") (("2" (expand "bspolynew" +) (("2" (expand "cfnew" +) (("2" (expand "multibscoeff") (("2" (inst - "cmo") (("2" (assert) (("2" (case "FORALL (j:nat): j<terms IMPLIES sigma(0, j,
                                                                                                                                           LAMBDA (i: nat):
                                                                                                                                             a / (terms) * product(0, nvars - 1, LAMBDA (j: nat): 1)) = a*((j+1)/(terms))") (("1" (inst - "terms-1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (case "FORALL (kr:nat): product(0,kr,LAMBDA (j:nat): 1) = 1") (("1" (induct "j") (("1" (assert) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (inst - "nvars-1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "j") (("2" (flatten) (("2" (assert) (("2" (expand "sigma" +) (("2" (replace -1) (("2" (inst - "nvars-1") (("2" (replace -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "kr") (("1" (expand "product") (("1" (expand "product") (("1" (propax) nil nil)) nil)) nil) ("2" (skolem 1 "kr") (("2" (flatten) (("2" (expand "product" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "FORALL (kr:nat): kr<=nvars-1 IMPLIES product(0, kr,
                                                                                                           LAMBDA (k: nat):
                                                                                                             IF cmo(k) <= bsdegmono(k)
                                                                                                               THEN Bern(cmo(k), bsdegmono(k))(X!1(k))
                                                                                                             ELSE 1
                                                                                                             ENDIF)
                                                                                                    >= 0") (("1" (inst - "nvars-1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "kr") (("1" (flatten) (("1" (expand "product") (("1" (expand "product") (("1" (lift-if) (("1" (ground) (("1" (lemma "Bern_nonnegative") (("1" (inst - "X!1(0)") (("1" (split -) (("1" (inst?) nil nil) ("2" (expand "unitbox?") (("2" (ground) (("2" (inst -8 "0") (("2" (ground) nil nil)) nil)) nil)) nil) ("3" (ground) (("3" (expand "unitbox?") (("3" (inst -8 "0") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "product" +) (("2" (lift-if) (("2" (ground) (("2" (mult-by -2 "Bern(cmo(1 + j), bsdegmono(1 + j))(X!1(1 + j))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "Bern_nonnegative") (("3" (inst - "X!1(1+j)") (("3" (expand "unitbox?") (("3" (inst -10 "1+j") (("3" (split -) (("1" (inst?) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "multibs_eval_rec" +) (("2" (rewrite "sigma_le") (("2" (hide 2) (("2" (skosimp*) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (expand "le_below_mono?") (("2" (skosimp*) (("2" (case "j!1 = j") (("1" (assert) nil nil) ("2" (inst -2 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "multibs_eval_equiv" + :dir rl) (("2" (expand "multibs_eval") (("2" (case "(LAMBDA (i: nat):
                         cfnew(i) *
                          bsproduct_eval(bspolynew(i), bsdegmono, nvars)(X!1)) = (LAMBDA (i:nat): a/terms)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (j:nat): j<terms IMPLIES sigma(0,j,(LAMBDA (i:nat): a/terms)) = (j+1)*a/terms") (("1" (inst - "terms-1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "j") (("1" (assert) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skolem 1 "j") (("2" (flatten) (("2" (assert) (("2" (expand "sigma" +) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("2" (expand "cfnew") (("2" (expand "bsproduct_eval") (("2" (expand "bspolynew") (("2" (case "(LAMBDA (i: nat):
                              sigma(0, bsdegmono(i),
                                    LAMBDA (j: nat):
                                      IF j > bsdegmono(i) THEN 0
                                      ELSE 1 * Bern(j, bsdegmono(i))(X!1(i))
                                      ENDIF)) = (LAMBDA (i:nat): 1)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (kr:nat): product(0,kr,LAMBDA (j:nat): 1) = 1") (("1" (inst - "nvars-1") (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "kr") (("1" (expand "product") (("1" (expand "product") (("1" (propax) nil nil)) nil)) nil) ("2" (skolem 1 "jj") (("2" (flatten) (("2" (expand "product" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (lemma "Bernstein_partition_of_unity") (("1" (inst - "bsdegmono(x!2)" "X!1(x!2)") (("1" (assert) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_coeffs_rel_def formula-decl nil multi_bernstein nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (DegreeMono type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (CoeffMono type-eq-decl nil util nil) (multibs_eval_rec def-decl "real" multi_bernstein nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (subrange type-eq-decl nil integers nil) (sigma_le formula-decl nil sigma reals) (int_minus_int_is_int application-judgement "int" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (product def-decl "real" product reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials reals) (cfnew skolem-const-decl "[nat -> real]" multi_bernstein nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (prod_posnat application-judgement "posnat" product_nat reals) (multibscoeff const-decl "real" multi_bernstein nil) (bspolynew skolem-const-decl "{x: [nat -> [nat -> [nat -> uint8]]] |
   FORALL (x_3: nat):
     FORALL (x_2: nat):
       FORALL (x_1: nat):
              odd?(x(x_3)(x_2)(x_1)) AND (x(x_3)(x_2)(x_1) > 0)
          AND (x(x_3)(x_2)(x_1) >= 0) AND integer_pred(x(x_3)(x_2)(x_1))
          AND rational_pred(x(x_3)(x_2)(x_1))
          AND real_pred(x(x_3)(x_2)(x_1))
          AND number_field_pred(x(x_3)(x_2)(x_1))}" multi_bernstein nil) (both_sides_times_pos_le1_imp formula-decl nil extra_real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (X!1 skolem-const-decl "Vars" multi_bernstein nil) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (cmo skolem-const-decl "CoeffMono" multi_bernstein nil) (nvars skolem-const-decl "posnat" multi_bernstein nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_times_real_is_real application-judgement "real" reals nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (multibs_eval_mono const-decl "real" multi_bernstein nil) (Bern_nonnegative formula-decl nil bernstein_polynomials reals) (unitbox? const-decl "bool" util nil) (j skolem-const-decl "nat" multi_bernstein nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_below_mono? const-decl "bool" util nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (multibs_eval const-decl "real" multi_bernstein nil) (Bernstein_partition_of_unity formula-decl nil bernstein_polynomials reals) (bsproduct_eval const-decl "real" multi_bernstein nil) (odd? const-decl "bool" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (uint8 type-eq-decl nil integertypes nil) (exp2 def-decl "posnat" exp2 nil) (< const-decl "bool" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (multibs_eval_equiv formula-decl nil multi_bernstein nil) (Vars type-eq-decl nil util nil) (forall_X const-decl "bool" multi_bernstein nil)) shostak) (Bern_le-1 nil 3499875743 ("" (skeep) (("" (rewrite "Bern_coeffs_rel_def") (("" (expand "forall_X") (("" (skosimp*) (("" (rewrite "multibs_eval_equiv") (("" (name "cfnew" "LAMBDA (i:nat): a/(terms)") (("" (name "bspolynew" "LAMBDA(i:nat)(j:nat)(k:nat): 1") (("" (case "multibs_eval_rec(bspoly, bsdegmono, cf, nvars, terms, nvars)
                                                                                                         (LAMBDA (i: nat): 0)(X!1) <= multibs_eval_rec(bspolynew, bsdegmono, cfnew, nvars, terms, nvars)
                                                                                                         (LAMBDA (i: nat): 0)(X!1) AND multibs_eval_rec(bspolynew, bsdegmono, cfnew, nvars, terms, nvars)
                                                                                                         (LAMBDA (i: nat): 0)(X!1) =a") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (split) (("1" (case "FORALL (cmo:CoeffMono,v:nat): v<=nvars AND le_below_mono?(nvars)(cmo,bsdegmono) IMPLIES multibs_eval_rec(bspoly, bsdegmono, cf, nvars, terms, v)
                                                                                                                                                (cmo)(X!1)
                                                                                                                                 <=
                                                                                                                                 multibs_eval_rec(bspolynew, bsdegmono, cfnew, nvars, terms, v)
                                                                                                                                                 (cmo)(X!1)") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "multibs_eval_rec" +) (("1" (case "product(0, nvars - 1,
                                                                                                                                                                                 LAMBDA (k: nat):
                                                                                                                                                                                   IF cmo(k) <= bsdegmono(k)
                                                                                                                                                                                     THEN Bern(cmo(k), bsdegmono(k))(X!1(k))
                                                                                                                                                                                   ELSE 1
                                                                                                                                                                                   ENDIF) >= 0") (("1" (case "multibs_eval_mono(bspoly, bsdegmono, cf, nvars, terms)(cmo)
                                                                                                                                                                                             <=
                                                                                                                                                                                             multibs_eval_mono(bspolynew, bsdegmono, cfnew, nvars, terms)(cmo)") (("1" (mult-by -1 "product(0, nvars - 1,
                                                                                                                                                                       LAMBDA (k: nat):
                                                                                                                                                                         IF cmo(k) <= bsdegmono(k)
                                                                                                                                                                           THEN Bern(cmo(k), bsdegmono(k))(X!1(k))
                                                                                                                                                                         ELSE 1
                                                                                                                                                                         ENDIF)") (("1" (hide 2) (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (expand "multibs_eval_mono") (("2" (expand "bspolynew" +) (("2" (expand "cfnew" +) (("2" (expand "multibscoeff") (("2" (inst - "cmo") (("2" (assert) (("2" (case "FORALL (j:nat): j<terms IMPLIES sigma(0, j,
                                                                                                                                           LAMBDA (i: nat):
                                                                                                                                             a / (terms) * product(0, nvars - 1, LAMBDA (j: nat): 1)) = a*((j+1)/(terms))") (("1" (inst - "terms-1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (case "FORALL (kr:nat): product(0,kr,LAMBDA (j:nat): 1) = 1") (("1" (induct "j") (("1" (assert) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (inst - "nvars-1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "j") (("2" (flatten) (("2" (assert) (("2" (expand "sigma" +) (("2" (replace -1) (("2" (inst - "nvars-1") (("2" (replace -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "kr") (("1" (expand "product") (("1" (expand "product") (("1" (propax) nil nil)) nil)) nil) ("2" (skolem 1 "kr") (("2" (flatten) (("2" (expand "product" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "FORALL (kr:nat): kr<=nvars-1 IMPLIES product(0, kr,
                                                                                                           LAMBDA (k: nat):
                                                                                                             IF cmo(k) <= bsdegmono(k)
                                                                                                               THEN Bern(cmo(k), bsdegmono(k))(X!1(k))
                                                                                                             ELSE 1
                                                                                                             ENDIF)
                                                                                                    >= 0") (("1" (inst - "nvars-1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "kr") (("1" (flatten) (("1" (expand "product") (("1" (expand "product") (("1" (lift-if) (("1" (ground) (("1" (lemma "Bern_nonnegative") (("1" (inst - "X!1(0)") (("1" (split -) (("1" (inst?) nil nil) ("2" (expand "unitbox?") (("2" (ground) (("2" (inst -8 "0") (("2" (ground) nil nil)) nil)) nil)) nil) ("3" (ground) (("3" (expand "unitbox?") (("3" (inst -8 "0") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "product" +) (("2" (lift-if) (("2" (ground) (("2" (mult-by -2 "Bern(cmo(1 + j), bsdegmono(1 + j))(X!1(1 + j))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "Bern_nonnegative") (("3" (inst - "X!1(1+j)") (("3" (expand "unitbox?") (("3" (inst -10 "1+j") (("3" (split -) (("1" (inst?) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "multibs_eval_rec" +) (("2" (rewrite "sigma_le") (("2" (hide 2) (("2" (skosimp*) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (expand "le_below_mono?") (("2" (skosimp*) (("2" (case "j!1 = j") (("1" (assert) nil nil) ("2" (inst -2 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "multibs_eval_equiv" + :dir rl) (("2" (expand "multibs_eval") (("2" (case "(LAMBDA (i: nat):
                         cfnew(i) *
                          bsproduct_eval(bspolynew(i), bsdegmono, nvars)(X!1)) = (LAMBDA (i:nat): a/terms)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (j:nat): j<terms IMPLIES sigma(0,j,(LAMBDA (i:nat): a/terms)) = (j+1)*a/terms") (("1" (inst - "terms-1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "j") (("1" (assert) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skolem 1 "j") (("2" (flatten) (("2" (assert) (("2" (expand "sigma" +) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("2" (expand "cfnew") (("2" (expand "bsproduct_eval") (("2" (expand "bspolynew") (("2" (case "(LAMBDA (i: nat):
                              sigma(0, bsdegmono(i),
                                    LAMBDA (j: nat):
                                      IF j > bsdegmono(i) THEN 0
                                      ELSE 1 * Bern(j, bsdegmono(i))(X!1(i))
                                      ENDIF)) = (LAMBDA (i:nat): 1)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (kr:nat): product(0,kr,LAMBDA (j:nat): 1) = 1") (("1" (inst - "nvars-1") (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "kr") (("1" (expand "product") (("1" (expand "product") (("1" (propax) nil nil)) nil)) nil) ("2" (skolem 1 "jj") (("2" (flatten) (("2" (expand "product" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (lemma "Bernstein_partition_of_unity") (("1" (inst - "bsdegmono(x!2)" "X!1(x!2)") (("1" (assert) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((DegreeMono type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (CoeffMono type-eq-decl nil util nil) (le_realorder name-judgement "RealOrder" real_orders reals) (sigma_le formula-decl nil sigma reals) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (product def-decl "real" product reals) (Bern const-decl "real" bernstein_polynomials reals) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (Bern_nonnegative formula-decl nil bernstein_polynomials reals) (unitbox? const-decl "bool" util nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (le_below_mono? const-decl "bool" util nil) (Bernstein_partition_of_unity formula-decl nil bernstein_polynomials reals) (Vars type-eq-decl nil util nil)) nil)) (Bern_lt 0 (Bern_lt-1 nil 3499875835 ("" (expand "Bern_coeffs_rel") (("" (case "FORALL (a: real, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                   cf: Coeff, nvars, terms: posnat,v:nat,cmo:CoeffMono):v<=nvars AND
                             Bern_coeffs_rel_rec(bspoly, bsdegmono, cf, nvars, terms, v)
                                                (cmo, <, a) IMPLIES (EXISTS (anew:real): anew<a AND Bern_coeffs_rel_rec(bspoly, bsdegmono, cf, nvars, terms, v)
                                                (cmo, <=, anew))") (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (skeep -1) (("1" (lemma "Bern_le") (("1" (inst - "anew" "bsdegmono" "bspoly" "cf" "nvars" "terms") (("1" (expand "Bern_coeffs_rel") (("1" (assert) (("1" (expand "forall_X") (("1" (skosimp*) (("1" (inst - "X!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "Bern_coeffs_rel_rec") (("1" (inst + "(multibscoeff(bspoly, bsdegmono, cf, nvars, terms)(cmo) + a)/2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skolem 1 "v") (("2" (flatten) (("2" (skeep) (("2" (expand "Bern_coeffs_rel_rec" (-3 1)) (("2" (case "FORALL (d:nat): d<=bsdegmono(v) IMPLIES (EXISTS (anew: real):FORALL (gg:nat):gg<=d IMPLIES
                                             anew < a AND
                                              Bern_coeffs_rel_rec(bspoly, bsdegmono, cf, nvars, terms, v)
                                                                 (cmo WITH [(v):=gg], <=, anew))") (("1" (inst - "bsdegmono(v)") (("1" (assert) (("1" (skeep -1) (("1" (inst + "anew") (("1" (assert) (("1" (case "anew < a") (("1" (assert) (("1" (skosimp*) (("1" (inst - "d!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst - "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "d") (("1" (assert) (("1" (flatten) (("1" (inst - "a" "bsdegmono" "bspoly" "cf" "nvars" "terms" "cmo WITH [(v):=0]") (("1" (assert) (("1" (inst -4 "0") (("1" (assert) (("1" (skosimp*) (("1" (inst + "anew!1") (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "dd") (("2" (flatten) (("2" (assert) (("2" (skosimp*) (("2" (inst - "a" "bsdegmono" "bspoly" "cf" "nvars" "terms" "cmo WITH [(v):=dd+1]") (("2" (assert) (("2" (inst -5 "dd+1") (("2" (assert) (("2" (skosimp*) (("2" (inst + "max(anew!1,anew!2)") (("2" (skosimp*) (("2" (split +) (("1" (inst - "0") (("1" (assert) (("1" (flatten) (("1" (expand "max") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "gg!1 = 1+dd") (("1" (assert) (("1" (replace -1) (("1" (lemma "Bern_coeffs_rel_implic") (("1" (inst?) (("1" (inst - "anew!2") (("1" (assert) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "gg!1") (("2" (assert) (("2" (flatten) (("2" (lemma "Bern_coeffs_rel_implic") (("2" (inst?) (("2" (inst - "anew!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((< const-decl "bool" reals nil) (Bern_coeffs_rel_rec def-decl "bool" multi_bernstein nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (CoeffMono type-eq-decl nil util nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Coeff type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Vars type-eq-decl nil util nil) (forall_X const-decl "bool" multi_bernstein nil) (Bern_le formula-decl nil multi_bernstein nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (real_plus_real_is_real application-judgement "real" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (multibscoeff const-decl "real" multi_bernstein nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (Bern_coeffs_rel_implic formula-decl nil multi_bernstein nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bern_coeffs_rel const-decl "bool" multi_bernstein nil)) nil)) (Bern_ge 0 (Bern_ge-2 "" 3790097909 ("" (skeep) (("" (rewrite "Bern_coeffs_rel_def") (("" (expand "forall_X") (("" (skosimp*) (("" (rewrite "multibs_eval_equiv") (("" (name "cfnew" "LAMBDA (i:nat): a/(terms)") (("" (name "bspolynew" "LAMBDA(i:nat)(j:nat)(k:nat): 1") (("" (case "multibs_eval_rec(bspoly, bsdegmono, cf, nvars, terms, nvars)
                                                                                                                              (LAMBDA (i: nat): 0)(X!1) >= multibs_eval_rec(bspolynew, bsdegmono, cfnew, nvars, terms, nvars)
                                                                                                                              (LAMBDA (i: nat): 0)(X!1) AND multibs_eval_rec(bspolynew, bsdegmono, cfnew, nvars, terms, nvars)
                                                                                                                              (LAMBDA (i: nat): 0)(X!1) =a") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (split) (("1" (case "FORALL (cmo:CoeffMono,v:nat): v<=nvars AND le_below_mono?(nvars)(cmo,bsdegmono) IMPLIES multibs_eval_rec(bspoly, bsdegmono, cf, nvars, terms, v)
                                                                                                                                                                                 (cmo)(X!1)
                                                                                                                                                                  >=
                                                                                                                                                                  multibs_eval_rec(bspolynew, bsdegmono, cfnew, nvars, terms, v)
                                                                                                                                                                                  (cmo)(X!1)") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "multibs_eval_rec" +) (("1" (case "product(0, nvars - 1,
                                                                                                                                                                                                                              LAMBDA (k: nat):
                                                                                                                                                                                                                                IF cmo(k) <= bsdegmono(k)
                                                                                                                                                                                                                                  THEN Bern(cmo(k), bsdegmono(k))(X!1(k))
                                                                                                                                                                                                                                ELSE 1
                                                                                                                                                                                                                                ENDIF) >= 0") (("1" (case "multibs_eval_mono(bspoly, bsdegmono, cf, nvars, terms)(cmo)
                                                                                                                                                                                                                                                >=
                                                                                                                                                                                                                                                multibs_eval_mono(bspolynew, bsdegmono, cfnew, nvars, terms)(cmo)") (("1" (mult-by -1 "product(0, nvars - 1,
                                                                                                                                                                                                                 LAMBDA (k: nat):
                                                                                                                                                                                                                   IF cmo(k) <= bsdegmono(k)
                                                                                                                                                                                                                     THEN Bern(cmo(k), bsdegmono(k))(X!1(k))
                                                                                                                                                                                                                   ELSE 1
                                                                                                                                                                                                                   ENDIF)") (("1" (hide 2) (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (expand "multibs_eval_mono") (("2" (expand "bspolynew" +) (("2" (expand "cfnew" +) (("2" (expand "multibscoeff") (("2" (inst - "cmo") (("2" (assert) (("2" (case "FORALL (j:nat): j<terms IMPLIES sigma(0, j,
                                                                                                                                                                                                    LAMBDA (i: nat):
                                                                                                                                                                                                      a / (terms) * product(0, nvars - 1, LAMBDA (j: nat): 1)) = a*((j+1)/(terms))") (("1" (inst - "terms-1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (case "FORALL (kr:nat): product(0,kr,LAMBDA (j:nat): 1) = 1") (("1" (induct "j") (("1" (assert) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (inst - "nvars-1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "j") (("2" (flatten) (("2" (assert) (("2" (expand "sigma" +) (("2" (replace -1) (("2" (inst - "nvars-1") (("2" (replace -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "kr") (("1" (expand "product") (("1" (expand "product") (("1" (propax) nil nil)) nil)) nil) ("2" (skolem 1 "kr") (("2" (flatten) (("2" (expand "product" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "FORALL (kr:nat): kr<=nvars-1 IMPLIES product(0, kr,
                                                                                                                                                              LAMBDA (k: nat):
                                                                                                                                                                IF cmo(k) <= bsdegmono(k)
                                                                                                                                                                  THEN Bern(cmo(k), bsdegmono(k))(X!1(k))
                                                                                                                                                                ELSE 1
                                                                                                                                                                ENDIF)
                                                                                                                                                       >= 0") (("1" (inst - "nvars-1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "kr") (("1" (flatten) (("1" (expand "product") (("1" (expand "product") (("1" (lift-if) (("1" (ground) (("1" (lemma "Bern_nonnegative") (("1" (inst - "X!1(0)") (("1" (split -) (("1" (inst?) nil nil) ("2" (expand "unitbox?") (("2" (ground) (("2" (inst -8 "0") (("2" (ground) nil nil)) nil)) nil)) nil) ("3" (ground) (("3" (expand "unitbox?") (("3" (inst -8 "0") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "product" +) (("2" (lift-if) (("2" (ground) (("2" (mult-by -2 "Bern(cmo(1 + j), bsdegmono(1 + j))(X!1(1 + j))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "Bern_nonnegative") (("3" (inst - "X!1(1+j)") (("3" (expand "unitbox?") (("3" (inst -10 "1+j") (("3" (split -) (("1" (inst?) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "multibs_eval_rec" +) (("2" (rewrite "sigma_ge") (("2" (hide 2) (("2" (skosimp*) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (expand "le_below_mono?") (("2" (skosimp*) (("2" (case "j!1 = j") (("1" (assert) nil nil) ("2" (inst -2 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "multibs_eval_equiv" + :dir rl) (("2" (expand "multibs_eval") (("2" (case "(LAMBDA (i: nat):
                                                          cfnew(i) *
                                                           bsproduct_eval(bspolynew(i), bsdegmono, nvars)(X!1)) = (LAMBDA (i:nat): a/terms)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (j:nat): j<terms IMPLIES sigma(0,j,(LAMBDA (i:nat): a/terms)) = (j+1)*a/terms") (("1" (inst - "terms-1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "j") (("1" (assert) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skolem 1 "j") (("2" (flatten) (("2" (assert) (("2" (expand "sigma" +) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("2" (expand "cfnew") (("2" (expand "bsproduct_eval") (("2" (expand "bspolynew") (("2" (case "(LAMBDA (i: nat):
                                                                     sigma(0, bsdegmono(i),
                                                                           LAMBDA (j: nat):
                                                                             IF j > bsdegmono(i) THEN 0
                                                                             ELSE 1 * Bern(j, bsdegmono(i))(X!1(i))
                                                                             ENDIF)) = (LAMBDA (i:nat): 1)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (kr:nat): product(0,kr,LAMBDA (j:nat): 1) = 1") (("1" (inst - "nvars-1") (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "kr") (("1" (expand "product") (("1" (expand "product") (("1" (propax) nil nil)) nil)) nil) ("2" (skolem 1 "jj") (("2" (flatten) (("2" (expand "product" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (lemma "Bernstein_partition_of_unity") (("1" (inst - "bsdegmono(x!2)" "X!1(x!2)") (("1" (assert) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_coeffs_rel_def formula-decl nil multi_bernstein nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (DegreeMono type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (CoeffMono type-eq-decl nil util nil) (multibs_eval_rec def-decl "real" multi_bernstein nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (subrange type-eq-decl nil integers nil) (sigma_ge formula-decl nil sigma reals) (int_minus_int_is_int application-judgement "int" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (product def-decl "real" product reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials reals) (cfnew skolem-const-decl "[nat -> real]" multi_bernstein nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (prod_posnat application-judgement "posnat" product_nat reals) (multibscoeff const-decl "real" multi_bernstein nil) (bspolynew skolem-const-decl "{x: [nat -> [nat -> [nat -> uint8]]] |
   FORALL (x_3: nat):
     FORALL (x_2: nat):
       FORALL (x_1: nat):
              odd?(x(x_3)(x_2)(x_1)) AND (x(x_3)(x_2)(x_1) > 0)
          AND (x(x_3)(x_2)(x_1) >= 0) AND integer_pred(x(x_3)(x_2)(x_1))
          AND rational_pred(x(x_3)(x_2)(x_1))
          AND real_pred(x(x_3)(x_2)(x_1))
          AND number_field_pred(x(x_3)(x_2)(x_1))}" multi_bernstein nil) (both_sides_times_pos_ge1_imp formula-decl nil extra_real_props nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (X!1 skolem-const-decl "Vars" multi_bernstein nil) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (cmo skolem-const-decl "CoeffMono" multi_bernstein nil) (nvars skolem-const-decl "posnat" multi_bernstein nil) (real_times_real_is_real application-judgement "real" reals nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (multibs_eval_mono const-decl "real" multi_bernstein nil) (Bern_nonnegative formula-decl nil bernstein_polynomials reals) (unitbox? const-decl "bool" util nil) (j skolem-const-decl "nat" multi_bernstein nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_below_mono? const-decl "bool" util nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (multibs_eval const-decl "real" multi_bernstein nil) (Bernstein_partition_of_unity formula-decl nil bernstein_polynomials reals) (bsproduct_eval const-decl "real" multi_bernstein nil) (odd? const-decl "bool" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (uint8 type-eq-decl nil integertypes nil) (exp2 def-decl "posnat" exp2 nil) (< const-decl "bool" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (Vars type-eq-decl nil util nil) (multibs_eval_equiv formula-decl nil multi_bernstein nil) (forall_X const-decl "bool" multi_bernstein nil)) shostak) (Bern_ge-1 nil 3499875940 ("" (skeep) (("" (rewrite "Bern_coeffs_rel_def") (("" (expand "forall_X") (("" (skosimp*) (("" (rewrite "multibs_eval_equiv") (("" (name "cfnew" "LAMBDA (i:nat): a/(terms)") (("" (name "bspolynew" "LAMBDA(i:nat)(j:nat)(k:nat): 1") (("" (case "multibs_eval_rec(bspoly, bsdegmono, cf, nvars, terms, nvars)
                                                                                                                              (LAMBDA (i: nat): 0)(X!1) >= multibs_eval_rec(bspolynew, bsdegmono, cfnew, nvars, terms, nvars)
                                                                                                                              (LAMBDA (i: nat): 0)(X!1) AND multibs_eval_rec(bspolynew, bsdegmono, cfnew, nvars, terms, nvars)
                                                                                                                              (LAMBDA (i: nat): 0)(X!1) =a") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (split) (("1" (case "FORALL (cmo:CoeffMono,v:nat): v<=nvars AND le_below_mono?(nvars)(cmo,bsdegmono) IMPLIES multibs_eval_rec(bspoly, bsdegmono, cf, nvars, terms, v)
                                                                                                                                                                                 (cmo)(X!1)
                                                                                                                                                                  >=
                                                                                                                                                                  multibs_eval_rec(bspolynew, bsdegmono, cfnew, nvars, terms, v)
                                                                                                                                                                                  (cmo)(X!1)") (("1" (inst?) (("1" (assert) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "multibs_eval_rec" +) (("1" (case "product(0, nvars - 1,
                                                                                                                                                                                                                              LAMBDA (k: nat):
                                                                                                                                                                                                                                IF cmo(k) <= bsdegmono(k)
                                                                                                                                                                                                                                  THEN Bern(cmo(k), bsdegmono(k))(X!1(k))
                                                                                                                                                                                                                                ELSE 1
                                                                                                                                                                                                                                ENDIF) >= 0") (("1" (case "multibs_eval_mono(bspoly, bsdegmono, cf, nvars, terms)(cmo)
                                                                                                                                                                                                                                                >=
                                                                                                                                                                                                                                                multibs_eval_mono(bspolynew, bsdegmono, cfnew, nvars, terms)(cmo)") (("1" (mult-by -1 "product(0, nvars - 1,
                                                                                                                                                                                                                 LAMBDA (k: nat):
                                                                                                                                                                                                                   IF cmo(k) <= bsdegmono(k)
                                                                                                                                                                                                                     THEN Bern(cmo(k), bsdegmono(k))(X!1(k))
                                                                                                                                                                                                                   ELSE 1
                                                                                                                                                                                                                   ENDIF)") (("1" (hide 2) (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (expand "multibs_eval_mono") (("2" (expand "bspolynew" +) (("2" (expand "cfnew" +) (("2" (expand "multibscoeff") (("2" (inst - "cmo") (("2" (assert) (("2" (case "FORALL (j:nat): j<terms IMPLIES sigma(0, j,
                                                                                                                                                                                                    LAMBDA (i: nat):
                                                                                                                                                                                                      a / (terms) * product(0, nvars - 1, LAMBDA (j: nat): 1)) = a*((j+1)/(terms))") (("1" (inst - "terms-1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (case "FORALL (kr:nat): product(0,kr,LAMBDA (j:nat): 1) = 1") (("1" (induct "j") (("1" (assert) (("1" (expand "sigma" +) (("1" (expand "sigma" +) (("1" (inst - "nvars-1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "j") (("2" (flatten) (("2" (assert) (("2" (expand "sigma" +) (("2" (replace -1) (("2" (inst - "nvars-1") (("2" (replace -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "kr") (("1" (expand "product") (("1" (expand "product") (("1" (propax) nil nil)) nil)) nil) ("2" (skolem 1 "kr") (("2" (flatten) (("2" (expand "product" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (case "FORALL (kr:nat): kr<=nvars-1 IMPLIES product(0, kr,
                                                                                                                                                              LAMBDA (k: nat):
                                                                                                                                                                IF cmo(k) <= bsdegmono(k)
                                                                                                                                                                  THEN Bern(cmo(k), bsdegmono(k))(X!1(k))
                                                                                                                                                                ELSE 1
                                                                                                                                                                ENDIF)
                                                                                                                                                       >= 0") (("1" (inst - "nvars-1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "kr") (("1" (flatten) (("1" (expand "product") (("1" (expand "product") (("1" (lift-if) (("1" (ground) (("1" (lemma "Bern_nonnegative") (("1" (inst - "X!1(0)") (("1" (split -) (("1" (inst?) nil nil) ("2" (expand "unitbox?") (("2" (ground) (("2" (inst -8 "0") (("2" (ground) nil nil)) nil)) nil)) nil) ("3" (ground) (("3" (expand "unitbox?") (("3" (inst -8 "0") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "product" +) (("2" (lift-if) (("2" (ground) (("2" (mult-by -2 "Bern(cmo(1 + j), bsdegmono(1 + j))(X!1(1 + j))") (("1" (assert) nil nil) ("2" (hide 2) (("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "Bern_nonnegative") (("3" (inst - "X!1(1+j)") (("3" (expand "unitbox?") (("3" (inst -10 "1+j") (("3" (split -) (("1" (inst?) nil nil) ("2" (ground) nil nil) ("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (expand "multibs_eval_rec" +) (("2" (rewrite "sigma_ge") (("2" (hide 2) (("2" (skosimp*) (("2" (inst?) (("2" (assert) (("2" (hide 1) (("2" (expand "le_below_mono?") (("2" (skosimp*) (("2" (case "j!1 = j") (("1" (assert) nil nil) ("2" (inst -2 "j!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "multibs_eval_equiv" + :dir rl) (("2" (expand "multibs_eval") (("2" (case "(LAMBDA (i: nat):
                                                          cfnew(i) *
                                                           bsproduct_eval(bspolynew(i), bsdegmono, nvars)(X!1)) = (LAMBDA (i:nat): a/terms)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (j:nat): j<terms IMPLIES sigma(0,j,(LAMBDA (i:nat): a/terms)) = (j+1)*a/terms") (("1" (inst - "terms-1") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "j") (("1" (assert) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skolem 1 "j") (("2" (flatten) (("2" (assert) (("2" (expand "sigma" +) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("2" (expand "cfnew") (("2" (expand "bsproduct_eval") (("2" (expand "bspolynew") (("2" (case "(LAMBDA (i: nat):
                                                                     sigma(0, bsdegmono(i),
                                                                           LAMBDA (j: nat):
                                                                             IF j > bsdegmono(i) THEN 0
                                                                             ELSE 1 * Bern(j, bsdegmono(i))(X!1(i))
                                                                             ENDIF)) = (LAMBDA (i:nat): 1)") (("1" (replace -1) (("1" (hide -1) (("1" (case "FORALL (kr:nat): product(0,kr,LAMBDA (j:nat): 1) = 1") (("1" (inst - "nvars-1") (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (induct "kr") (("1" (expand "product") (("1" (expand "product") (("1" (propax) nil nil)) nil)) nil) ("2" (skolem 1 "jj") (("2" (flatten) (("2" (expand "product" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (lemma "Bernstein_partition_of_unity") (("1" (inst - "bsdegmono(x!2)" "X!1(x!2)") (("1" (assert) (("1" (replace -1) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((DegreeMono type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (CoeffMono type-eq-decl nil util nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (sigma_ge formula-decl nil sigma reals) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (product def-decl "real" product reals) (Bern const-decl "real" bernstein_polynomials reals) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma def-decl "real" sigma reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (Bern_nonnegative formula-decl nil bernstein_polynomials reals) (unitbox? const-decl "bool" util nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (le_below_mono? const-decl "bool" util nil) (Bernstein_partition_of_unity formula-decl nil bernstein_polynomials reals) (Vars type-eq-decl nil util nil)) nil)) (Bern_gt 0 (Bern_gt-1 nil 3499875974 ("" (expand "Bern_coeffs_rel") (("" (case "FORALL (a: real, bsdegmono: DegreeMono, bspoly: MultiBernstein,
                                                 cf: Coeff, nvars, terms: posnat,v:nat,cmo:CoeffMono):v<=nvars AND
                                           Bern_coeffs_rel_rec(bspoly, bsdegmono, cf, nvars, terms, v)
                                                              (cmo, >, a) IMPLIES (EXISTS (anew:real): anew>a AND Bern_coeffs_rel_rec(bspoly, bsdegmono, cf, nvars, terms, v)
                                                              (cmo, >=, anew))") (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (skeep -1) (("1" (lemma "Bern_ge") (("1" (inst - "anew" "bsdegmono" "bspoly" "cf" "nvars" "terms") (("1" (expand "Bern_coeffs_rel") (("1" (assert) (("1" (expand "forall_X") (("1" (skosimp*) (("1" (inst - "X!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "v") (("1" (skeep) (("1" (expand "Bern_coeffs_rel_rec") (("1" (inst + "(multibscoeff(bspoly, bsdegmono, cf, nvars, terms)(cmo) + a)/2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skolem 1 "v") (("2" (flatten) (("2" (skeep) (("2" (expand "Bern_coeffs_rel_rec" (-3 1)) (("2" (case "FORALL (d:nat): d<=bsdegmono(v) IMPLIES (EXISTS (anew: real):FORALL (gg:nat):gg<=d IMPLIES
                                                                   anew > a AND
                                                                    Bern_coeffs_rel_rec(bspoly, bsdegmono, cf, nvars, terms, v)
                                                                                       (cmo WITH [(v):=gg], >=, anew))") (("1" (inst - "bsdegmono(v)") (("1" (assert) (("1" (skeep -1) (("1" (inst + "anew") (("1" (assert) (("1" (case "anew > a") (("1" (assert) (("1" (skosimp*) (("1" (inst - "d!1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst - "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "d") (("1" (assert) (("1" (flatten) (("1" (inst - "a" "bsdegmono" "bspoly" "cf" "nvars" "terms" "cmo WITH [(v):=0]") (("1" (assert) (("1" (inst -4 "0") (("1" (assert) (("1" (skosimp*) (("1" (inst + "anew!1") (("1" (skosimp*) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "dd") (("2" (flatten) (("2" (assert) (("2" (skosimp*) (("2" (inst - "a" "bsdegmono" "bspoly" "cf" "nvars" "terms" "cmo WITH [(v):=dd+1]") (("2" (assert) (("2" (inst -5 "dd+1") (("2" (assert) (("2" (skosimp*) (("2" (inst + "min(anew!1,anew!2)") (("2" (skosimp*) (("2" (split +) (("1" (inst - "0") (("1" (assert) (("1" (flatten) (("1" (expand "min") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "gg!1 = 1+dd") (("1" (assert) (("1" (replace -1) (("1" (lemma "Bern_coeffs_rel_implic") (("1" (inst?) (("1" (inst - "anew!2") (("1" (assert) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst - "gg!1") (("2" (assert) (("2" (flatten) (("2" (lemma "Bern_coeffs_rel_implic") (("2" (inst?) (("2" (inst - "anew!1") (("2" (assert) (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Bern_coeffs_rel_rec def-decl "bool" multi_bernstein nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (CoeffMono type-eq-decl nil util nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Coeff type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (Vars type-eq-decl nil util nil) (forall_X const-decl "bool" multi_bernstein nil) (Bern_ge formula-decl nil multi_bernstein nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (real_plus_real_is_real application-judgement "real" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (multibscoeff const-decl "real" multi_bernstein nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (Bern_coeffs_rel_implic formula-decl nil multi_bernstein nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bern_coeffs_rel const-decl "bool" multi_bernstein nil)) nil)) (Bern_rel 0 (Bern_rel-1 nil 3499876182 ("" (skeep) (("" (typepred "relreal") (("" (expand "realorder?") (("" (split) (("1" (replaces -1) (("1" (rewrite "Bern_le") nil nil)) nil) ("2" (replaces -1) (("2" (rewrite "Bern_lt") nil nil)) nil) ("3" (replaces -1) (("3" (rewrite "Bern_ge") nil nil)) nil) ("4" (replaces -1) (("4" (rewrite "Bern_gt") nil nil)) nil)) nil)) nil)) nil)) nil) ((RealOrder type-eq-decl nil real_orders reals) (realorder? const-decl "bool" real_orders reals) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (Bern_le formula-decl nil multi_bernstein nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (DegreeMono type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (TRUE const-decl "bool" booleans nil) (Bern_lt formula-decl nil multi_bernstein nil) (Bern_ge formula-decl nil multi_bernstein nil) (Bern_gt formula-decl nil multi_bernstein nil)) shostak)) (forall_X_between_minmax 0 (forall_X_between_minmax-1 nil 3509140503 ("" (skeep) (("" (expand "forall_X_between") (("" (skeep) (("" (lemma "Bern_rel") (("" (inst-cp - "amin" "bsdegmono" "bspoly" "cf" "nvars" ">=" "terms") (("" (inst - "amax" "bsdegmono" "bspoly" "cf" "nvars" "<=" "terms") (("" (case "Bern_coeffs_rel(bspoly, bsdegmono, cf, nvars, terms)(<=, amax) AND Bern_coeffs_rel(bspoly, bsdegmono, cf, nvars, terms)(>=, amin)") (("1" (flatten) (("1" (assert) (("1" (hide (-1 -2)) (("1" (expand "forall_X") (("1" (inst - "X") (("1" (inst - "X") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide (-1 -2 2)) (("2" (lemma "Bern_coeffs_rel_def") (("2" (inst-cp - "amin" "bsdegmono" "bspoly" "cf" "nvars" ">=" "terms") (("2" (inst - "amax" "bsdegmono" "bspoly" "cf" "nvars" "<=" "terms") (("2" (replaces -1) (("2" (replaces -1) (("2" (split +) (("1" (skosimp*) (("1" (inst -2 "coeffmono!1") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst -2 "coeffmono!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((forall_X_between const-decl "bool" multi_bernstein nil) (Bern_rel formula-decl nil multi_bernstein nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (<= const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (CoeffMono type-eq-decl nil util nil) (Bern_coeffs_rel_def formula-decl nil multi_bernstein nil) (Vars type-eq-decl nil util nil) (forall_X const-decl "bool" multi_bernstein nil) (Bern_coeffs_rel const-decl "bool" multi_bernstein nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (RealOrder type-eq-decl nil real_orders reals) (realorder? const-decl "bool" real_orders reals) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Coeff type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (Bern_split_left_mono_TCC1 0 (Bern_split_left_mono_TCC1-1 nil 3498411572 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (/= const-decl "boolean" notequal nil)) nil (Bern_split_left_mono subtype "multi_bernstein.k" "{i: naturalnumbers.nat | reals.<=(i, multi_bernstein.j)}"))) (Bern_split_right_mono_TCC1 0 (Bern_split_right_mono_TCC1-1 nil 3498411572 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (/= const-decl "boolean" notequal nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (Bern_split_right_mono subtype "(number_fields.-)(multi_bernstein.bsdegmono(multi_bernstein.i), multi_bernstein.j)" "nat"))) (Bern_split_right_mono_TCC2 0 (Bern_split_right_mono_TCC2-1 nil 3498411572 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (/= const-decl "boolean" notequal nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (Bern_split_right_mono subtype "multi_bernstein.k" "{i_1: naturalnumbers.nat | reals.<=(i_1, (number_fields.-)(multi_bernstein.bsdegmono(multi_bernstein.i), multi_bernstein.j))}"))) (Bern_split_right_mono_TCC3 0 (Bern_split_right_mono_TCC3-1 nil 3498411572 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (/= const-decl "boolean" notequal nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (Bern_split_right_mono subtype "(number_fields.-)(multi_bernstein.bsdegmono(multi_bernstein.i), multi_bernstein.k)" "nat"))) (Bern_split_bspoly 0 (Bern_split_bspoly-2 "" 3790097914 ("" (skeep) (("" (ground) (("1" (expand "forall_X") (("1" (skosimp*) (("1" (case "1/2<=X!1(i) AND X!1(i)<=1") (("1" (flatten) (("1" (hide -3) (("1" (name "Xnew" "LAMBDA (j:nat): IF j=i THEN (X!1(i)-1/2)*2 ELSE X!1(j) ENDIF") (("1" (inst - "Xnew") (("1" (split -) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                                                                                       Bern_split_right_mono(bspoly(k), bsdegmono)(i),
                                                                                                     bsdegmono, cf, nvars, terms)
                                                                                                    (Xnew) = multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X!1)") (("1" (assert) nil nil) ("2" (hide -1) (("2" (hide 2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_split_right_mono(bspoly(x!1), bsdegmono)(i),
                                                                                                 bsdegmono, nvars)
                                                                                                (Xnew)
                                                                                  = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(X!1)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=i") (("1" (flatten) (("1" (expand "Bern_split_right_mono") (("1" (assert) (("1" (expand "Xnew") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (lemma "Bern_subdiv_right_id") (("2" (expand "Xnew" +) (("2" (inst - "(# index:=bsdegmono(i),bern_seq := (LAMBDA (pj:upto(bsdegmono(i))): bspoly(x!1)(i)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "2 * X!1(i) - 2 * (1 / 2)") (("2" (expand "o") (("2" (expand "Bern_poly") (("2" (case "NOT (1 / 2) + 2 * (X!1(i) * (1 / 2)) -
                                                                                                                       2 * ((1 / 2) * (1 / 2)) = X!1(i)") (("1" (assert) nil nil) ("2" (replace -1) (("2" (replace -2 :dir rl) (("2" (hide -1) (("2" (hide -1) (("2" (expand "Bern_subdiv_right") (("2" (expand "Bern_split_right_mono") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (expand "unitbox?") (("2" (expand "Xnew") (("2" (skosimp*) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (inst - "j!1") (("1" (ground) nil nil)) nil) ("2" (inst - "j!1") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "0<=X!1(i) AND X!1(i)<=1/2") (("1" (name "Xnew" "LAMBDA (j:nat): IF j=i THEN 2*X!1(i) ELSE X!1(j) ENDIF") (("1" (inst - "Xnew") (("1" (split -) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                                                      Bern_split_left_mono(bspoly(k), bsdegmono)(i),
                                                                    bsdegmono, cf, nvars, terms)
                                                                   (Xnew) = multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X!1)") (("1" (assert) nil nil) ("2" (hide -1) (("2" (hide 2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_split_left_mono(bspoly(x!1), bsdegmono)(i),
                                                                         bsdegmono, nvars)
                                                                        (Xnew)
                                                          = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(X!1)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=i") (("1" (flatten) (("1" (expand "Bern_split_left_mono") (("1" (assert) (("1" (expand "Xnew") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (lemma "Bern_subdiv_left_id") (("2" (expand "Xnew" +) (("2" (inst - "(# index:=bsdegmono(i),bern_seq := (LAMBDA (pj:upto(bsdegmono(i))): bspoly(x!1)(i)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "2 * X!1(i)") (("2" (expand "o") (("2" (expand "Bern_poly") (("2" (case "NOT 2 * (X!1(i) * (1 / 2)) = X!1(i)") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (expand "Bern_subdiv_left") (("2" (expand "Bern_split_left_mono") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide -2) (("2" (hide 2) (("2" (hide 2) (("2" (expand "unitbox?") (("2" (skosimp*) (("2" (inst - "j!1") (("2" (expand "Xnew") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide -1) (("2" (expand "unitbox?") (("2" (inst - "i") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "forall_X") (("2" (skosimp*) (("2" (name "Xnew" "LAMBDA (j:nat): IF j=i THEN (1/2)*X!1(i) ELSE X!1(j) ENDIF") (("2" (inst - "Xnew") (("2" (split -) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                                              Bern_split_left_mono(bspoly(k), bsdegmono)(i),
                                                            bsdegmono, cf, nvars, terms)
                                                           (X!1) = multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(Xnew)") (("1" (assert) nil nil) ("2" (hide -1) (("2" (hide 2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_split_left_mono(bspoly(x!1), bsdegmono)(i),
                                                                 bsdegmono, nvars)
                                                                (X!1)
                                                  = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(Xnew)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=i") (("1" (flatten) (("1" (expand "Bern_split_left_mono") (("1" (assert) (("1" (expand "Xnew") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (lemma "Bern_subdiv_left_id") (("2" (expand "Xnew" +) (("2" (inst - "(# index:=bsdegmono(i),bern_seq := (LAMBDA (pj:upto(bsdegmono(i))): bspoly(x!1)(i)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "X!1(i)") (("2" (expand "o") (("2" (expand "Bern_poly") (("2" (assert) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (expand "Bern_subdiv_left") (("2" (expand "Bern_split_left_mono") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide 2) (("2" (expand "unitbox?") (("2" (skosimp*) (("2" (inst - "j!1") (("2" (expand "Xnew") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "forall_X") (("3" (skosimp*) (("3" (name "Xnew" "LAMBDA (j:nat): IF j=i THEN (X!1(i)+1)/2 ELSE X!1(j) ENDIF") (("3" (case "multibs_eval(LAMBDA (k: nat):
                                                            Bern_split_right_mono(bspoly(k), bsdegmono)(i),
                                                          bsdegmono, cf, nvars, terms)
                                                         (X!1) = multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(Xnew)") (("1" (inst - "Xnew") (("1" (split -) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                                                Bern_split_right_mono(bspoly(k), bsdegmono)(i),
                                                              bsdegmono, cf, nvars, terms)
                                                             (X!1) = multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(Xnew)") (("1" (assert) nil nil) ("2" (propax) nil nil)) nil) ("2" (hide -1) (("2" (hide 2) (("2" (hide -1) (("2" (expand "unitbox?") (("2" (skosimp*) (("2" (inst - "j!1") (("2" (expand "Xnew") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide 2) (("2" (hide -2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_split_right_mono(bspoly(x!1), bsdegmono)(i),
                                                               bsdegmono, nvars)
                                                              (X!1)
                                                = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(Xnew)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=i") (("1" (flatten) (("1" (expand "Bern_split_right_mono") (("1" (assert) (("1" (expand "Xnew") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (lemma "Bern_subdiv_right_id") (("2" (expand "Xnew" +) (("2" (inst - "(# index:=bsdegmono(i),bern_seq := (LAMBDA (pj:upto(bsdegmono(i))): bspoly(x!1)(i)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "X!1(i)") (("2" (expand "o") (("2" (case "((1 / 2) + X!1(i) * (1 / 2))=((1 + X!1(i)) / 2)") (("1" (replace -1) (("1" (hide -1) (("1" (expand "Bern_poly") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (expand "Bern_subdiv_right") (("1" (expand "Bern_split_right_mono") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (Bern_split_left_mono const-decl "real" multi_bernstein nil) (Xnew skolem-const-decl "[nat -> real]" multi_bernstein nil) (Bern_subdiv_left const-decl "Bernstein_Polynomial" bernstein_polynomials reals) (posint_exp application-judgement "posint" exponentiation nil) (Bern_subdiv_left_id formula-decl nil bernstein_polynomials reals) (real_times_real_is_real application-judgement "real" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (Bern const-decl "real" bernstein_polynomials reals) (above nonempty-type-eq-decl nil integers nil) (sigma def-decl "real" sigma reals) (product_restrict_eq formula-decl nil product reals) (restrict const-decl "[T -> real]" product reals) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (Xnew skolem-const-decl "[nat -> real]" multi_bernstein nil) (real_plus_real_is_real application-judgement "real" reals nil) (Bern_poly const-decl "[real -> real]" bernstein_polynomials reals) (Bern_subdiv_right const-decl "Bernstein_Polynomial" bernstein_polynomials reals) (O const-decl "T3" function_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posrat_times_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials reals) (Bern_subdiv_right_id formula-decl nil bernstein_polynomials reals) (real_minus_real_is_real application-judgement "real" reals nil) (restrict const-decl "[T -> real]" sigma reals) (int_minus_int_is_int application-judgement "int" integers nil) (sigma_restrict_eq formula-decl nil sigma reals) (bsproduct_eval const-decl "real" multi_bernstein nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (Bern_split_right_mono const-decl "real" multi_bernstein nil) (multibs_eval const-decl "real" multi_bernstein nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Coeff type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (unitbox? const-decl "bool" util nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Vars type-eq-decl nil util nil) (forall_X const-decl "bool" multi_bernstein nil) (Xnew skolem-const-decl "[nat -> real]" multi_bernstein nil) (Xnew skolem-const-decl "[nat -> real]" multi_bernstein nil) (real_div_nzreal_is_real application-judgement "real" reals nil)) shostak) (Bern_split_bspoly-1 nil 3500078177 ("" (skeep) (("" (ground) (("1" (expand "forall_X") (("1" (skosimp*) (("1" (case "1/2<=X!1(i) AND X!1(i)<=1") (("1" (flatten) (("1" (hide -3) (("1" (name "Xnew" "LAMBDA (j:nat): IF j=i THEN (X!1(i)-1/2)*2 ELSE X!1(j) ENDIF") (("1" (inst - "Xnew") (("1" (split -) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                                                                                       Bern_split_right_mono(bspoly(k), bsdegmono)(i),
                                                                                                     bsdegmono, cf, nvars, terms)
                                                                                                    (Xnew) = multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X!1)") (("1" (assert) nil nil) ("2" (hide -1) (("2" (hide 2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_split_right_mono(bspoly(x!1), bsdegmono)(i),
                                                                                                 bsdegmono, nvars)
                                                                                                (Xnew)
                                                                                  = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(X!1)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=i") (("1" (flatten) (("1" (expand "Bern_split_right_mono") (("1" (assert) (("1" (expand "Xnew") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (lemma "Bern_subdiv_right_id") (("2" (expand "Xnew" +) (("2" (inst - "(# index:=bsdegmono(i),bern_seq := (LAMBDA (pj:upto(bsdegmono(i))): bspoly(x!1)(i)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "2 * X!1(i) - 2 * (1 / 2)") (("2" (expand "o") (("2" (expand "Bern_poly") (("2" (case "NOT (1 / 2) + 2 * (X!1(i) * (1 / 2)) -
                                                                                                                       2 * ((1 / 2) * (1 / 2)) = X!1(i)") (("1" (assert) nil nil) ("2" (replace -1) (("2" (replace -2 :dir rl) (("2" (hide -1) (("2" (hide -1) (("2" (expand "Bern_subdiv_right") (("2" (expand "Bern_split_right_mono") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1) (("2" (expand "unitbox?") (("2" (expand "Xnew") (("2" (skosimp*) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (inst - "j!1") (("1" (ground) nil nil)) nil) ("2" (inst - "j!1") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "0<=X!1(i) AND X!1(i)<=1/2") (("1" (name "Xnew" "LAMBDA (j:nat): IF j=i THEN 2*X!1(i) ELSE X!1(j) ENDIF") (("1" (inst - "Xnew") (("1" (split -) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                                                      Bern_split_left_mono(bspoly(k), bsdegmono)(i),
                                                                    bsdegmono, cf, nvars, terms)
                                                                   (Xnew) = multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X!1)") (("1" (assert) nil nil) ("2" (hide -1) (("2" (hide 2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_split_left_mono(bspoly(x!1), bsdegmono)(i),
                                                                         bsdegmono, nvars)
                                                                        (Xnew)
                                                          = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(X!1)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=i") (("1" (flatten) (("1" (expand "Bern_split_left_mono") (("1" (assert) (("1" (expand "Xnew") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (lemma "Bern_subdiv_left_id") (("2" (expand "Xnew" +) (("2" (inst - "(# index:=bsdegmono(i),bern_seq := (LAMBDA (pj:upto(bsdegmono(i))): bspoly(x!1)(i)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "2 * X!1(i)") (("2" (expand "o") (("2" (expand "Bern_poly") (("2" (case "NOT 2 * (X!1(i) * (1 / 2)) = X!1(i)") (("1" (assert) nil nil) ("2" (replace -1) (("2" (assert) (("2" (hide -1) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (expand "Bern_subdiv_left") (("2" (expand "Bern_split_left_mono") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide -2) (("2" (hide 2) (("2" (hide 2) (("2" (expand "unitbox?") (("2" (skosimp*) (("2" (inst - "j!1") (("2" (expand "Xnew") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide -1) (("2" (expand "unitbox?") (("2" (inst - "i") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "forall_X") (("2" (skosimp*) (("2" (name "Xnew" "LAMBDA (j:nat): IF j=i THEN (1/2)*X!1(i) ELSE X!1(j) ENDIF") (("2" (inst - "Xnew") (("2" (split -) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                                              Bern_split_left_mono(bspoly(k), bsdegmono)(i),
                                                            bsdegmono, cf, nvars, terms)
                                                           (X!1) = multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(Xnew)") (("1" (assert) nil nil) ("2" (hide -1) (("2" (hide 2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_split_left_mono(bspoly(x!1), bsdegmono)(i),
                                                                 bsdegmono, nvars)
                                                                (X!1)
                                                  = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(Xnew)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=i") (("1" (flatten) (("1" (expand "Bern_split_left_mono") (("1" (assert) (("1" (expand "Xnew") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (lemma "Bern_subdiv_left_id") (("2" (expand "Xnew" +) (("2" (inst - "(# index:=bsdegmono(i),bern_seq := (LAMBDA (pj:upto(bsdegmono(i))): bspoly(x!1)(i)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "X!1(i)") (("2" (expand "o") (("2" (expand "Bern_poly") (("2" (assert) (("2" (replace -1 :dir rl) (("2" (hide -1) (("2" (expand "Bern_subdiv_left") (("2" (expand "Bern_split_left_mono") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide 2) (("2" (expand "unitbox?") (("2" (skosimp*) (("2" (inst - "j!1") (("2" (expand "Xnew") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "forall_X") (("3" (skosimp*) (("3" (name "Xnew" "LAMBDA (j:nat): IF j=i THEN (X!1(i)+1)/2 ELSE X!1(j) ENDIF") (("3" (case "multibs_eval(LAMBDA (k: nat):
                                                            Bern_split_right_mono(bspoly(k), bsdegmono)(i),
                                                          bsdegmono, cf, nvars, terms)
                                                         (X!1) = multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(Xnew)") (("1" (inst - "Xnew") (("1" (split -) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                                                Bern_split_right_mono(bspoly(k), bsdegmono)(i),
                                                              bsdegmono, cf, nvars, terms)
                                                             (X!1) = multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(Xnew)") (("1" (assert) nil nil) ("2" (propax) nil nil)) nil) ("2" (hide -1) (("2" (hide 2) (("2" (hide -1) (("2" (expand "unitbox?") (("2" (skosimp*) (("2" (inst - "j!1") (("2" (expand "Xnew") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide 2) (("2" (hide -2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_split_right_mono(bspoly(x!1), bsdegmono)(i),
                                                               bsdegmono, nvars)
                                                              (X!1)
                                                = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(Xnew)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=i") (("1" (flatten) (("1" (expand "Bern_split_right_mono") (("1" (assert) (("1" (expand "Xnew") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (lemma "Bern_subdiv_right_id") (("2" (expand "Xnew" +) (("2" (inst - "(# index:=bsdegmono(i),bern_seq := (LAMBDA (pj:upto(bsdegmono(i))): bspoly(x!1)(i)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "X!1(i)") (("2" (expand "o") (("2" (case "((1 / 2) + X!1(i) * (1 / 2))=((1 + X!1(i)) / 2)") (("1" (replace -1) (("1" (hide -1) (("1" (expand "Bern_poly") (("1" (replace -1 :dir rl) (("1" (hide -1) (("1" (expand "Bern_subdiv_right") (("1" (expand "Bern_split_right_mono") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_realorder name-judgement "RealOrder" real_orders reals) (Bern_subdiv_left const-decl "Bernstein_Polynomial" bernstein_polynomials reals) (Bern_subdiv_left_id formula-decl nil bernstein_polynomials reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (Bern const-decl "real" bernstein_polynomials reals) (sigma def-decl "real" sigma reals) (product_restrict_eq formula-decl nil product reals) (restrict const-decl "[T -> real]" product reals) (Bern_subdiv_right const-decl "Bernstein_Polynomial" bernstein_polynomials reals) (Bern_poly const-decl "[real -> real]" bernstein_polynomials reals) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials reals) (Bern_subdiv_right_id formula-decl nil bernstein_polynomials reals) (restrict const-decl "[T -> real]" sigma reals) (sigma_restrict_eq formula-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (le_realorder name-judgement "RealOrder" real_orders reals) (Coeff type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (unitbox? const-decl "bool" util nil) (Vars type-eq-decl nil util nil)) nil)) (Bern_eval_left 0 (Bern_eval_left-2 "" 3790097915 ("" (skeep) (("" (with-tccs (name "Xmid" "X WITH [(v) := 2 * X(v)]")) (("" (beta) (("" (replace -1) (("" (invoke (case "%1 = %2") (! -1 2) (! -1 1)) (("1" (hide -2) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                              Bern_split_left_mono(bspoly(k), bsdegmono)(v),
                                            bsdegmono, cf, nvars, terms)
                                           (Xmid)=multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X)") (("1" (assert) nil nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_split_left_mono(bspoly(x!1), bsdegmono)(v),
                                                 bsdegmono, nvars)
                                                (Xmid)
                                  = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(X)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=v") (("1" (flatten) (("1" (expand "Bern_split_left_mono") (("1" (assert) (("1" (expand "Xmid" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "Bern_subdiv_left_id") (("2" (expand "Xmid" +) (("2" (inst - "(# index:=bsdegmono(v),bern_seq := (LAMBDA (pj:upto(bsdegmono(v))): bspoly(x!1)(v)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "2 * X(v)") (("2" (expand "o") (("2" (expand "Bern_poly") (("2" (case "2*(X(v)*(1/2)) = X(v)") (("1" (replace -1) (("1" (hide -1) (("1" (expand "Bern_subdiv_left") (("1" (assert) (("1" (replace -1 :dir rl) (("1" (expand "Bern_split_left_mono") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Vars type-eq-decl nil util nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (sigma_restrict_eq formula-decl nil sigma reals) (bsproduct_eval const-decl "real" multi_bernstein nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_low type-eq-decl nil sigma reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (restrict const-decl "[T -> real]" sigma reals) (Bern_poly const-decl "[real -> real]" bernstein_polynomials reals) (Bern_subdiv_left const-decl "Bernstein_Polynomial" bernstein_polynomials reals) (O const-decl "T3" function_props nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (posint_exp application-judgement "posint" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials reals) (Bern_subdiv_left_id formula-decl nil bernstein_polynomials reals) (Xmid skolem-const-decl "Vars" multi_bernstein nil) (/= const-decl "boolean" notequal nil) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (restrict const-decl "[T -> real]" product reals) (product_restrict_eq formula-decl nil product reals) (sigma def-decl "real" sigma reals) (IF const-decl "[boolean, T, T -> T]" if_def nil) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (multibs_eval const-decl "real" multi_bernstein nil) (Bern_split_left_mono const-decl "real" multi_bernstein nil)) shostak) (Bern_eval_left-1 nil 3500227685 ("" (skeep) (("" (with-tccs (name "Xmid" "X WITH [(v) := 2 * X(v)]")) (("" (beta) (("" (replace -1) (("" (invoke (case "%1 = %2") (! -1 2) (! -1 1)) (("1" (hide -2) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                              Bern_split_left_mono(bspoly(k), bsdegmono)(v),
                                            bsdegmono, cf, nvars, terms)
                                           (Xmid)=multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X)") (("1" (assert) nil nil) ("2" (assert) (("2" (hide 2) (("2" (hide -2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_split_left_mono(bspoly(x!1), bsdegmono)(v),
                                                 bsdegmono, nvars)
                                                (Xmid)
                                  = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(X)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=v") (("1" (flatten) (("1" (expand "Bern_split_left_mono") (("1" (assert) (("1" (expand "Xmid" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "Bern_subdiv_left_id") (("2" (expand "Xmid" +) (("2" (inst - "(# index:=bsdegmono(v),bern_seq := (LAMBDA (pj:upto(bsdegmono(v))): bspoly(x!1)(v)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "2 * X(v)") (("2" (expand "o") (("2" (expand "Bern_poly") (("2" (case "2*(X(v)*(1/2)) = X(v)") (("1" (replace -1) (("1" (hide -1) (("1" (expand "Bern_subdiv_left") (("1" (assert) (("1" (replace -1 :dir rl) (("1" (expand "Bern_split_left_mono") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Vars type-eq-decl nil util nil) (sigma_restrict_eq formula-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (restrict const-decl "[T -> real]" sigma reals) (Bern_subdiv_left const-decl "Bernstein_Polynomial" bernstein_polynomials reals) (Bern_poly const-decl "[real -> real]" bernstein_polynomials reals) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials reals) (Bern_subdiv_left_id formula-decl nil bernstein_polynomials reals) (restrict const-decl "[T -> real]" product reals) (product_restrict_eq formula-decl nil product reals) (sigma def-decl "real" sigma reals) (Bern const-decl "real" bernstein_polynomials reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil)) nil)) (Bern_eval_left_def 0 (Bern_eval_left_def-1 nil 3506179415 ("" (lemma "Bern_eval_left") (("" (skeep) (("" (with-tccs (name "Xmid" "X WITH [(v) := 2 * X(v)]")) (("" (beta) (("" (replace -1) (("" (inst-cp - "X" "multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X)" "bsdegmono" "bspoly" "cf" "nvars" "<=" "terms" "v") (("" (inst - "X" "multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X)" "bsdegmono" "bspoly" "cf" "nvars" ">=" "terms" "v") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (multibs_eval const-decl "real" multi_bernstein nil) (<= const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (Vars type-eq-decl nil util nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (real_times_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (Bern_eval_left formula-decl nil multi_bernstein nil)) shostak)) (Bern_eval_right 0 (Bern_eval_right-2 "" 3790097917 ("" (skeep) (("" (with-tccs (name "Xmid" "X WITH [(v) := 2 * X(v) - 1]")) (("" (beta) (("" (replace -1) (("" (invoke (case "%1 = %2") (! -1 2) (! -1 1)) (("1" (hide -2) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                                     Bern_split_right_mono(bspoly(k), bsdegmono)(v),
                                                   bsdegmono, cf, nvars, terms)
                                                  (Xmid)=multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide -2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_split_right_mono(bspoly(x!1), bsdegmono)(v),
                                                          bsdegmono, nvars)
                                                         (Xmid)
                                           = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(X)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=v") (("1" (flatten) (("1" (expand "Bern_split_right_mono") (("1" (assert) (("1" (expand "Xmid" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "Bern_subdiv_right_id") (("2" (expand "Xmid" +) (("2" (inst - "(# index:=bsdegmono(v),bern_seq := (LAMBDA (pj:upto(bsdegmono(v))): bspoly(x!1)(v)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "2 * X(v)-1") (("2" (expand "o") (("2" (expand "Bern_poly") (("2" (case "2*(X(v)*(1/2)) = X(v)") (("1" (replace -1) (("1" (hide -1) (("1" (expand "Bern_subdiv_right") (("1" (assert) (("1" (replace -1 :dir rl) (("1" (expand "Bern_split_right_mono") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_minus_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Vars type-eq-decl nil util nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (Bern const-decl "real" bernstein_polynomials reals) (above nonempty-type-eq-decl nil integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (sigma def-decl "real" sigma reals) (product_restrict_eq formula-decl nil product reals) (restrict const-decl "[T -> real]" product reals) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (/= const-decl "boolean" notequal nil) (Xmid skolem-const-decl "Vars" multi_bernstein nil) (Bern_subdiv_right_id formula-decl nil bernstein_polynomials reals) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials reals) (upto nonempty-type-eq-decl nil naturalnumbers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (O const-decl "T3" function_props nil) (Bern_subdiv_right const-decl "Bernstein_Polynomial" bernstein_polynomials reals) (Bern_poly const-decl "[real -> real]" bernstein_polynomials reals) (restrict const-decl "[T -> real]" sigma reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (sigma_restrict_eq formula-decl nil sigma reals) (bsproduct_eval const-decl "real" multi_bernstein nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (real_times_real_is_real application-judgement "real" reals nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (multibs_eval const-decl "real" multi_bernstein nil) (Bern_split_right_mono const-decl "real" multi_bernstein nil)) shostak) (Bern_eval_right-1 nil 3500228236 ("" (skeep) (("" (with-tccs (name "Xmid" "X WITH [(v) := 2 * X(v) - 1]")) (("" (beta) (("" (replace -1) (("" (invoke (case "%1 = %2") (! -1 2) (! -1 1)) (("1" (hide -2) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                                     Bern_split_right_mono(bspoly(k), bsdegmono)(v),
                                                   bsdegmono, cf, nvars, terms)
                                                  (Xmid)=multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide -2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_split_right_mono(bspoly(x!1), bsdegmono)(v),
                                                          bsdegmono, nvars)
                                                         (Xmid)
                                           = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(X)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=v") (("1" (flatten) (("1" (expand "Bern_split_right_mono") (("1" (assert) (("1" (expand "Xmid" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "Bern_subdiv_right_id") (("2" (expand "Xmid" +) (("2" (inst - "(# index:=bsdegmono(v),bern_seq := (LAMBDA (pj:upto(bsdegmono(v))): bspoly(x!1)(v)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "2 * X(v)-1") (("2" (expand "o") (("2" (expand "Bern_poly") (("2" (case "2*(X(v)*(1/2)) = X(v)") (("1" (replace -1) (("1" (hide -1) (("1" (expand "Bern_subdiv_right") (("1" (assert) (("1" (replace -1 :dir rl) (("1" (expand "Bern_split_right_mono") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((Vars type-eq-decl nil util nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (Bern const-decl "real" bernstein_polynomials reals) (sigma def-decl "real" sigma reals) (product_restrict_eq formula-decl nil product reals) (restrict const-decl "[T -> real]" product reals) (Bern_subdiv_right_id formula-decl nil bernstein_polynomials reals) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials reals) (Bern_poly const-decl "[real -> real]" bernstein_polynomials reals) (Bern_subdiv_right const-decl "Bernstein_Polynomial" bernstein_polynomials reals) (restrict const-decl "[T -> real]" sigma reals) (le_realorder name-judgement "RealOrder" real_orders reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (sigma_restrict_eq formula-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (Coeff type-eq-decl nil util nil)) nil)) (Bern_eval_right_def 0 (Bern_eval_right_def-1 nil 3506179629 ("" (lemma "Bern_eval_right") (("" (skeep) (("" (inst-cp - "X" "multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X)" "bsdegmono" "bspoly" "cf" "nvars" "<=" "terms" "v") (("" (inst - "X" "multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X)" "bsdegmono" "bspoly" "cf" "nvars" ">=" "terms" "v") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (multibs_eval const-decl "real" multi_bernstein nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Coeff type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (Vars type-eq-decl nil util nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (Bern_eval_right formula-decl nil multi_bernstein nil)) shostak)) (Bernstein_sweep_TCC1 0 (Bernstein_sweep_TCC1-1 nil 3504635300 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (Bernstein_sweep subtype "(number_fields.-)(multi_bernstein.j, 1)" "nat"))) (Bernstein_sweep_TCC2 0 (Bernstein_sweep_TCC2-1 nil 3504635300 ("" (subtype-tcc) nil nil) nil nil (Bernstein_sweep termination "multi_bernstein.Bernstein_sweep(multi_bernstein.pprod, multi_bernstein.v)((number_fields.-)(multi_bernstein.p, 1))" "nil"))) (Bern_sweep_right_TCC1 0 (Bern_sweep_right_TCC1-1 nil 3504635300 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (/= const-decl "boolean" notequal nil)) nil (Bern_sweep_right subtype "(number_fields.-)(multi_bernstein.bsdegmono(multi_bernstein.i), multi_bernstein.j)" "nat"))) (Bern_sweep_eval_left 0 (Bern_sweep_eval_left-2 "" 3790097919 ("" (case "FORALL (aaa,bbb,ccc:real): aaa=ccc IMPLIES aaa*bbb=ccc*bbb") (("1" (label "multlem" -1) (("1" (hide "multlem") (("1" (skeep) (("1" (with-tccs (name "Xmid" "X WITH [(v) := 2 * X(v)]")) (("1" (beta) (("1" (replace -1) (("1" (invoke (case "%1 = %2") (! -1 2) (! -1 1)) (("1" (hide -2) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                                                                         Bern_sweep_left(bspoly(k), bsdegmono)(v),
                                                                                       bsdegmono, cf, nvars, terms)
                                                                                      (Xmid)=multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide -2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_sweep_left(bspoly(x!1), bsdegmono)(v),
                                                                                                      bsdegmono, nvars)
                                                                                                     (Xmid)
                                                                                       = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(X)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=v") (("1" (flatten) (("1" (expand "Bern_sweep_left") (("1" (assert) (("1" (expand "Xmid" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "Bern_subdiv_l_id") (("2" (expand "Xmid" +) (("2" (inst - "(# index:=bsdegmono(v),bern_seq := (LAMBDA (pj:upto(bsdegmono(v))): bspoly(x!1)(v)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "2 * X(v)") (("2" (expand "o") (("2" (expand "Bern_poly") (("2" (case "2*(X(v)*(1/2)) = X(v)") (("1" (replace -1) (("1" (expand "Bern_subdiv_l") (("1" (case "Bern_sweep((# index := bsdegmono(v),
                                                                                                                                 bern_seq
                                                                                                                                   := (LAMBDA (pj: upto(bsdegmono(v))):
                                                                                                                                         bspoly(x!1)(v)(pj)) #))
                                                                                                                             (bsdegmono(v))`index = bsdegmono(v)") (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(0, bsdegmono(v),
                                                                                                                             LAMBDA (i: nat):
                                                                                                                               IF i > bsdegmono(v) THEN 0
                                                                                                                               ELSE Bern_sweep((# index := bsdegmono(v),
                                                                                                                                                  bern_seq
                                                                                                                                                    := (LAMBDA
                                                                                                                                                        (pj: upto(bsdegmono(v))):
                                                                                                                                                        bspoly(x!1)(v)(pj)) #))
                                                                                                                                              (bsdegmono(v))`bern_seq
                                                                                                                                        (i)
                                                                                                                                     * Bern(i, bsdegmono(v))(2 * X(v))
                                                                                                                               ENDIF)=sigma(0, bsdegmono(v),
                                                                                                                             LAMBDA (j: nat):
                                                                                                                               IF j > bsdegmono(v) THEN 0
                                                                                                                               ELSE Bern_sweep_left(bspoly(x!1), bsdegmono)(v)(v)(j) *
                                                                                                                                     Bern(j, bsdegmono(v))(2 * X(v))
                                                                                                                               ENDIF)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (hide -2) (("2" (assert) (("2" (replace -1) (("2" (rewrite "sigma_eq") (("2" (hide 2) (("2" (skeep) (("2" (reveal "multlem") (("2" (rewrite "multlem") (("2" (hide "multlem") (("2" (hide 2) (("2" (expand "Bern_sweep_left") (("2" (case "FORALL (mm:nat,nn:nat): mm<=bsdegmono(v) AND nn<=bsdegmono(v) IMPLIES Bern_sweep((# index := bsdegmono(v),
                                                                                                                        bern_seq
                                                                                                                          := (LAMBDA (pj: upto(bsdegmono(v))):
                                                                                                                                bspoly(x!1)(v)(pj)) #))
                                                                                                                    (mm)`bern_seq
                                                                                                              (nn)
                                                                                                           = Bernstein_sweep(bspoly(x!1),v)(mm)(nn)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "mm") (("1" (skeep) (("1" (assert) (("1" (expand "Bernstein_sweep") (("1" (expand "Bern_sweep") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "mm") (("2" (flatten) (("2" (skeep) (("2" (assert) (("2" (expand "Bernstein_sweep" +) (("2" (expand "Bern_sweep" +) (("2" (assert) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (inst - "nn") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst-cp - "nn") (("2" (inst - "nn-1") (("1" (assert) (("1" (replace -1) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "Bern_sweep") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "Bern_sweep") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Bern_sweep") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil) ((Bern_sweep_left const-decl "Polynomial" multi_bernstein nil) (multibs_eval const-decl "real" multi_bernstein nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Coeff type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (T_low type-eq-decl nil sigma reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_high type-eq-decl nil sigma reals) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bsproduct_eval const-decl "real" multi_bernstein nil) (sigma_restrict_eq formula-decl nil sigma reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (restrict const-decl "[T -> real]" sigma reals) (Bern_poly const-decl "[real -> real]" bernstein_polynomials reals) (Bern_subdiv_l const-decl "Bernstein_Polynomial" bernstein_polynomials reals) (O const-decl "T3" function_props nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (nn skolem-const-decl "nat" multi_bernstein nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (x!1 skolem-const-decl "nat" multi_bernstein nil) (bspoly skolem-const-decl "MultiBernstein" multi_bernstein nil) (v skolem-const-decl "nat" multi_bernstein nil) (Bernstein_sweep def-decl "real" multi_bernstein nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subrange type-eq-decl nil integers nil) (sigma_eq formula-decl nil sigma reals) (Bern_sweep def-decl "{bp: Bernstein_Polynomial | bp`index = b`index}" bernstein_polynomials reals) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials reals) (Bern_subdiv_l_id formula-decl nil bernstein_polynomials reals) (Xmid skolem-const-decl "Vars" multi_bernstein nil) (/= const-decl "boolean" notequal nil) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (restrict const-decl "[T -> real]" product reals) (product_restrict_eq formula-decl nil product reals) (sigma def-decl "real" sigma reals) (IF const-decl "[boolean, T, T -> T]" if_def nil) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (Vars type-eq-decl nil util nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak) (Bern_sweep_eval_left-1 nil 3504879622 ("" (case "FORALL (aaa,bbb,ccc:real): aaa=ccc IMPLIES aaa*bbb=ccc*bbb") (("1" (label "multlem" -1) (("1" (hide "multlem") (("1" (skeep) (("1" (with-tccs (name "Xmid" "X WITH [(v) := 2 * X(v)]")) (("1" (beta) (("1" (replace -1) (("1" (invoke (case "%1 = %2") (! -1 2) (! -1 1)) (("1" (hide -2) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                                                                         Bern_sweep_left(bspoly(k), bsdegmono)(v),
                                                                                       bsdegmono, cf, nvars, terms)
                                                                                      (Xmid)=multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide -2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_sweep_left(bspoly(x!1), bsdegmono)(v),
                                                                                                      bsdegmono, nvars)
                                                                                                     (Xmid)
                                                                                       = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(X)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=v") (("1" (flatten) (("1" (expand "Bern_sweep_left") (("1" (assert) (("1" (expand "Xmid" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "Bern_subdiv_l_id") (("2" (expand "Xmid" +) (("2" (inst - "(# index:=bsdegmono(v),bern_seq := (LAMBDA (pj:upto(bsdegmono(v))): bspoly(x!1)(v)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "2 * X(v)") (("2" (expand "o") (("2" (expand "Bern_poly") (("2" (case "2*(X(v)*(1/2)) = X(v)") (("1" (replace -1) (("1" (expand "Bern_subdiv_l") (("1" (case "Bern_sweep((# index := bsdegmono(v),
                                                                                                                                 bern_seq
                                                                                                                                   := (LAMBDA (pj: upto(bsdegmono(v))):
                                                                                                                                         bspoly(x!1)(v)(pj)) #))
                                                                                                                             (bsdegmono(v))`index = bsdegmono(v)") (("1" (replace -1) (("1" (hide -1) (("1" (case "sigma(0, bsdegmono(v),
                                                                                                                             LAMBDA (i: nat):
                                                                                                                               IF i > bsdegmono(v) THEN 0
                                                                                                                               ELSE Bern_sweep((# index := bsdegmono(v),
                                                                                                                                                  bern_seq
                                                                                                                                                    := (LAMBDA
                                                                                                                                                        (pj: upto(bsdegmono(v))):
                                                                                                                                                        bspoly(x!1)(v)(pj)) #))
                                                                                                                                              (bsdegmono(v))`bern_seq
                                                                                                                                        (i)
                                                                                                                                     * Bern(i, bsdegmono(v))(2 * X(v))
                                                                                                                               ENDIF)=sigma(0, bsdegmono(v),
                                                                                                                             LAMBDA (j: nat):
                                                                                                                               IF j > bsdegmono(v) THEN 0
                                                                                                                               ELSE Bern_sweep_left(bspoly(x!1), bsdegmono)(v)(v)(j) *
                                                                                                                                     Bern(j, bsdegmono(v))(2 * X(v))
                                                                                                                               ENDIF)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (hide -2) (("2" (assert) (("2" (replace -1) (("2" (rewrite "sigma_eq") (("2" (hide 2) (("2" (skeep) (("2" (reveal "multlem") (("2" (rewrite "multlem") (("2" (hide "multlem") (("2" (hide 2) (("2" (expand "Bern_sweep_left") (("2" (case "FORALL (mm:nat,nn:nat): mm<=bsdegmono(v) AND nn<=bsdegmono(v) IMPLIES Bern_sweep((# index := bsdegmono(v),
                                                                                                                        bern_seq
                                                                                                                          := (LAMBDA (pj: upto(bsdegmono(v))):
                                                                                                                                bspoly(x!1)(v)(pj)) #))
                                                                                                                    (mm)`bern_seq
                                                                                                              (nn)
                                                                                                           = Bernstein_sweep(bspoly(x!1),v)(mm)(nn)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "mm") (("1" (skeep) (("1" (assert) (("1" (expand "Bernstein_sweep") (("1" (expand "Bern_sweep") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "mm") (("2" (flatten) (("2" (skeep) (("2" (assert) (("2" (expand "Bernstein_sweep" +) (("2" (expand "Bern_sweep" +) (("2" (assert) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (inst - "nn") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst-cp - "nn") (("2" (inst - "nn-1") (("1" (assert) (("1" (replace -1) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "Bern_sweep") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "Bern_sweep") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "Bern_sweep") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil) ((Coeff type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma_restrict_eq formula-decl nil sigma reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (restrict const-decl "[T -> real]" sigma reals) (Bern_subdiv_l const-decl "Bernstein_Polynomial" bernstein_polynomials reals) (Bern_poly const-decl "[real -> real]" bernstein_polynomials reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (sigma_eq formula-decl nil sigma reals) (Bern_sweep def-decl "{bp: Bernstein_Polynomial | bp`index = b`index}" bernstein_polynomials reals) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials reals) (Bern_subdiv_l_id formula-decl nil bernstein_polynomials reals) (restrict const-decl "[T -> real]" product reals) (product_restrict_eq formula-decl nil product reals) (sigma def-decl "real" sigma reals) (Bern const-decl "real" bernstein_polynomials reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (Vars type-eq-decl nil util nil)) nil)) (Bern_sweep_eval_right 0 (Bern_sweep_eval_right-2 "" 3790097921 ("" (case "FORALL (aaa,bbb,ccc:real): aaa=ccc IMPLIES aaa*bbb=ccc*bbb") (("1" (label "multlem" -1) (("1" (hide "multlem") (("1" (skeep) (("1" (with-tccs (name "Xmid" "X WITH [(v) := 2 * X(v) - 1]")) (("1" (beta) (("1" (replace -1) (("1" (invoke (case "%1 = %2") (! -1 2) (! -1 1)) (("1" (hide -2) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                                                                                           Bern_sweep_right(bspoly(k), bsdegmono)(v),
                                                                                                         bsdegmono, cf, nvars, terms)
                                                                                                        (Xmid)=multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide -2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_sweep_right(bspoly(x!1), bsdegmono)(v),
                                                                                                                            bsdegmono, nvars)
                                                                                                                           (Xmid)
                                                                                                             = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(X)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=v") (("1" (flatten) (("1" (expand "Bern_sweep_right") (("1" (assert) (("1" (expand "Xmid" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "Bern_subdiv_r_id") (("2" (expand "Xmid" +) (("2" (inst - "(# index:=bsdegmono(v),bern_seq := (LAMBDA (pj:upto(bsdegmono(v))): bspoly(x!1)(v)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "2 * X(v)-1") (("2" (expand "o") (("2" (expand "Bern_poly") (("2" (case "2*(X(v)*(1/2)) = X(v)") (("1" (replace -1) (("1" (expand "Bern_subdiv_r") (("1" (case "sigma(0, bsdegmono(v),
                                                      LAMBDA (i: nat):
                                                        IF i > bsdegmono(v) THEN 0
                                                        ELSE Bern_sweep((# index := bsdegmono(v),
                                                                           bern_seq
                                                                             := (LAMBDA
                                                                                 (pj: upto(bsdegmono(v))):
                                                                                 bspoly(x!1)(v)(pj)) #))
                                                                       (bsdegmono(v) - i)`bern_seq
                                                                 (bsdegmono(v))
                                                              * Bern(i, bsdegmono(v))(2 * X(v) - 1)
                                                        ENDIF) = sigma(0, bsdegmono(v),
                                                      LAMBDA (j: nat):
                                                        IF j > bsdegmono(v) THEN 0
                                                        ELSE Bern_sweep_right(bspoly(x!1), bsdegmono)(v)(v)(j) *
                                                              Bern(j, bsdegmono(v))(2 * X(v) - 1)
                                                        ENDIF)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (hide -2) (("2" (assert) (("2" (replace -1) (("2" (rewrite "sigma_eq") (("1" (hide 2) (("1" (skeep) (("1" (reveal "multlem") (("1" (rewrite "multlem") (("1" (hide "multlem") (("1" (hide 2) (("1" (expand "Bern_sweep_right") (("1" (case "FORALL (mm:nat,nn:nat): mm<=bsdegmono(v) AND nn<=bsdegmono(v) IMPLIES Bern_sweep((# index := bsdegmono(v),
                                                                                                                                                                          bern_seq
                                                                                                                                                                            := (LAMBDA (pj: upto(bsdegmono(v))):
                                                                                                                                                                                  bspoly(x!1)(v)(pj)) #))
                                                                                                                                                                      (mm)`bern_seq
                                                                                                                                                                (nn)
                                                                                                                                                             = Bernstein_sweep(bspoly(x!1),v)(mm)(nn)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "mm") (("1" (skeep) (("1" (assert) (("1" (expand "Bernstein_sweep") (("1" (expand "Bern_sweep") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "mm") (("2" (flatten) (("2" (skeep) (("2" (assert) (("2" (expand "Bernstein_sweep" +) (("2" (expand "Bern_sweep" +) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (inst - "nn") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst-cp - "nn") (("2" (inst - "nn-1") (("1" (assert) (("1" (replace -1) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "Bern_sweep") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "Bern_sweep") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (expand "Bern_sweep") (("5" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil) ((Bern_sweep_right const-decl "real" multi_bernstein nil) (multibs_eval const-decl "real" multi_bernstein nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (Coeff type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (bsproduct_eval const-decl "real" multi_bernstein nil) (sigma_restrict_eq formula-decl nil sigma reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (restrict const-decl "[T -> real]" sigma reals) (Bern_poly const-decl "[real -> real]" bernstein_polynomials reals) (Bern_subdiv_r const-decl "Bernstein_Polynomial" bernstein_polynomials reals) (O const-decl "T3" function_props nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_eq formula-decl nil sigma reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (subrange type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (Bernstein_sweep def-decl "real" multi_bernstein nil) (v skolem-const-decl "nat" multi_bernstein nil) (bspoly skolem-const-decl "MultiBernstein" multi_bernstein nil) (x!1 skolem-const-decl "nat" multi_bernstein nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (nn skolem-const-decl "nat" multi_bernstein nil) (Bern_sweep def-decl "{bp: Bernstein_Polynomial | bp`index = b`index}" bernstein_polynomials reals) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials reals) (Bern_subdiv_r_id formula-decl nil bernstein_polynomials reals) (Xmid skolem-const-decl "Vars" multi_bernstein nil) (/= const-decl "boolean" notequal nil) (bsdegmono skolem-const-decl "DegreeMono" multi_bernstein nil) (restrict const-decl "[T -> real]" product reals) (product_restrict_eq formula-decl nil product reals) (sigma def-decl "real" sigma reals) (IF const-decl "[boolean, T, T -> T]" if_def nil) (above nonempty-type-eq-decl nil integers nil) (Bern const-decl "real" bernstein_polynomials reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (Vars type-eq-decl nil util nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real_minus_real_is_real application-judgement "real" reals nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (real_times_real_is_real application-judgement "real" reals nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil)) shostak) (Bern_sweep_eval_right-1 nil 3504882524 ("" (case "FORALL (aaa,bbb,ccc:real): aaa=ccc IMPLIES aaa*bbb=ccc*bbb") (("1" (label "multlem" -1) (("1" (hide "multlem") (("1" (skeep) (("1" (with-tccs (name "Xmid" "X WITH [(v) := 2 * X(v) - 1]")) (("1" (beta) (("1" (replace -1) (("1" (invoke (case "%1 = %2") (! -1 2) (! -1 1)) (("1" (hide -2) (("1" (case "multibs_eval(LAMBDA (k: nat):
                                                                                                           Bern_sweep_right(bspoly(k), bsdegmono)(v),
                                                                                                         bsdegmono, cf, nvars, terms)
                                                                                                        (Xmid)=multibs_eval(bspoly, bsdegmono, cf, nvars, terms)(X)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (hide -2) (("2" (expand "multibs_eval") (("2" (rewrite "sigma_restrict_eq") (("2" (hide 2) (("2" (decompose-equality) (("2" (expand "restrict") (("2" (lift-if) (("2" (ground) (("2" (case "bsproduct_eval(Bern_sweep_right(bspoly(x!1), bsdegmono)(v),
                                                                                                                            bsdegmono, nvars)
                                                                                                                           (Xmid)
                                                                                                             = bsproduct_eval(bspoly(x!1), bsdegmono, nvars)(X)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "bsproduct_eval") (("2" (rewrite "product_restrict_eq") (("1" (hide 2) (("1" (decompose-equality) (("1" (expand "restrict") (("1" (lift-if) (("1" (ground) (("1" (case "x!2/=v") (("1" (flatten) (("1" (expand "Bern_sweep_right") (("1" (assert) (("1" (expand "Xmid" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -1) (("2" (hide -1) (("2" (lemma "Bern_subdiv_r_id") (("2" (expand "Xmid" +) (("2" (inst - "(# index:=bsdegmono(v),bern_seq := (LAMBDA (pj:upto(bsdegmono(v))): bspoly(x!1)(v)(pj)) #)") (("2" (decompose-equality -1) (("2" (inst - "2 * X(v)-1") (("2" (expand "o") (("2" (expand "Bern_poly") (("2" (case "2*(X(v)*(1/2)) = X(v)") (("1" (replace -1) (("1" (expand "Bern_subdiv_r") (("1" (case "sigma(0, bsdegmono(v),
                                                      LAMBDA (i: nat):
                                                        IF i > bsdegmono(v) THEN 0
                                                        ELSE Bern_sweep((# index := bsdegmono(v),
                                                                           bern_seq
                                                                             := (LAMBDA
                                                                                 (pj: upto(bsdegmono(v))):
                                                                                 bspoly(x!1)(v)(pj)) #))
                                                                       (bsdegmono(v) - i)`bern_seq
                                                                 (bsdegmono(v))
                                                              * Bern(i, bsdegmono(v))(2 * X(v) - 1)
                                                        ENDIF) = sigma(0, bsdegmono(v),
                                                      LAMBDA (j: nat):
                                                        IF j > bsdegmono(v) THEN 0
                                                        ELSE Bern_sweep_right(bspoly(x!1), bsdegmono)(v)(v)(j) *
                                                              Bern(j, bsdegmono(v))(2 * X(v) - 1)
                                                        ENDIF)") (("1" (assert) nil nil) ("2" (hide 3) (("2" (hide -2) (("2" (assert) (("2" (replace -1) (("2" (rewrite "sigma_eq") (("1" (hide 2) (("1" (skeep) (("1" (reveal "multlem") (("1" (rewrite "multlem") (("1" (hide "multlem") (("1" (hide 2) (("1" (expand "Bern_sweep_right") (("1" (case "FORALL (mm:nat,nn:nat): mm<=bsdegmono(v) AND nn<=bsdegmono(v) IMPLIES Bern_sweep((# index := bsdegmono(v),
                                                                                                                                                                          bern_seq
                                                                                                                                                                            := (LAMBDA (pj: upto(bsdegmono(v))):
                                                                                                                                                                                  bspoly(x!1)(v)(pj)) #))
                                                                                                                                                                      (mm)`bern_seq
                                                                                                                                                                (nn)
                                                                                                                                                             = Bernstein_sweep(bspoly(x!1),v)(mm)(nn)") (("1" (inst?) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "mm") (("1" (skeep) (("1" (assert) (("1" (expand "Bernstein_sweep") (("1" (expand "Bern_sweep") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "mm") (("2" (flatten) (("2" (skeep) (("2" (assert) (("2" (expand "Bernstein_sweep" +) (("2" (expand "Bern_sweep" +) (("2" (lift-if) (("2" (split 1) (("1" (flatten) (("1" (inst - "nn") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (inst-cp - "nn") (("2" (inst - "nn-1") (("1" (assert) (("1" (replace -1) (("1" (replace -2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "Bern_sweep") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "Bern_sweep") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil) ("4" (skosimp*) (("4" (assert) nil nil)) nil) ("5" (expand "Bern_sweep") (("5" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (hide 3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) nil nil)) nil) ("3" (skosimp*) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil) ((Coeff type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (MultiBernstein type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Polynomial type-eq-decl nil util nil) (T_low type-eq-decl nil sigma reals) (T_high type-eq-decl nil sigma reals) (sigma_restrict_eq formula-decl nil sigma reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (restrict const-decl "[T -> real]" sigma reals) (Bern_subdiv_r const-decl "Bernstein_Polynomial" bernstein_polynomials reals) (Bern_poly const-decl "[real -> real]" bernstein_polynomials reals) (sigma_eq formula-decl nil sigma reals) (ge_realorder name-judgement "RealOrder" real_orders reals) (Bern_sweep def-decl "{bp: Bernstein_Polynomial | bp`index = b`index}" bernstein_polynomials reals) (Bernstein_Polynomial type-eq-decl nil bernstein_polynomials reals) (Bern_subdiv_r_id formula-decl nil bernstein_polynomials reals) (restrict const-decl "[T -> real]" product reals) (product_restrict_eq formula-decl nil product reals) (sigma def-decl "real" sigma reals) (Bern const-decl "real" bernstein_polynomials reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (Vars type-eq-decl nil util nil)) nil)))
