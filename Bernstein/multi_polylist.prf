(multi_polylist (maxnum_TCC1 0 (maxnum_TCC1-1 nil 3603213169 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (maxnum subtype "multi_polylist.x" "{z: naturalnumbers.nat | booleans.AND(reals.>=(z, multi_polylist.x), booleans.AND(reals.>=(z, multi_polylist.y), (booleans.OR(z = multi_polylist.x, z = multi_polylist.y))))}"))) (maxnum_TCC2 0 (maxnum_TCC2-1 nil 3603213169 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (maxnum subtype "multi_polylist.y" "{z: naturalnumbers.nat | booleans.AND(reals.>=(z, multi_polylist.x), booleans.AND(reals.>=(z, multi_polylist.y), (booleans.OR(z = multi_polylist.x, z = multi_polylist.y))))}"))) (max_TCC1 0 (max_TCC1-1 nil 3603199783 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (maxnum const-decl "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist nil)) nil (max subtype "multi_polylist.i" "below[length[nat](ml2)]"))) (max_TCC2 0 (max_TCC2-1 nil 3603207043 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (length def-decl "nat" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (maxnum const-decl "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist nil)) nil (max subtype "multi_polylist.i" "below[length[nat](ml1)]"))) (max_TCC3 0 (max_TCC3-1 nil 3603207043 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (max subtype "multi_polylist.i" "below[length[nat](ml1)]"))) (max_TCC4 0 (max_TCC4-1 nil 3603207043 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (max subtype "multi_polylist.i" "below[length[nat](ml2)]"))) (max_TCC5 0 (max_TCC5-1 nil 3603207043 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (length def-decl "nat" list_props nil) (maxnum const-decl "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist nil)) nil (max subtype "multi_polylist.ml2" "{ml | booleans.AND(list_props[nat].length(multi_polylist.ml) = multi_polylist.maxnum(list_props[nat].length(multi_polylist.ml1), list_props[nat].length(multi_polylist.ml2)), FORALL (i: naturalnumbers.nat): booleans.IMPLIES(reals.<(i, list_props[nat].length(multi_polylist.ml)), list_props[nat].nth(multi_polylist.ml, i) = IF booleans.OR(list_adt[nat].null?(multi_polylist.ml1), reals.>=(i, list_props[nat].length(multi_polylist.ml1))) THEN list_props[nat].nth(multi_polylist.ml2, i) ELSIF booleans.OR(list_adt[nat].null?(multi_polylist.ml2), reals.>=(i, list_props[nat].length(multi_polylist.ml2))) THEN list_props[nat].nth(multi_polylist.ml1, i) ELSE multi_polylist.maxnum(list_props[nat].nth(multi_polylist.ml1, i), list_props[nat].nth(multi_polylist.ml2, i)) ENDIF))}"))) (max_TCC6 0 (max_TCC6-1 nil 3603207043 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (maxnum const-decl "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist nil)) nil (max subtype "multi_polylist.ml1" "{ml | booleans.AND(list_props[nat].length(multi_polylist.ml) = multi_polylist.maxnum(list_props[nat].length(multi_polylist.ml1), list_props[nat].length(multi_polylist.ml2)), FORALL (i: naturalnumbers.nat): booleans.IMPLIES(reals.<(i, list_props[nat].length(multi_polylist.ml)), list_props[nat].nth(multi_polylist.ml, i) = IF booleans.OR(list_adt[nat].null?(multi_polylist.ml1), reals.>=(i, list_props[nat].length(multi_polylist.ml1))) THEN list_props[nat].nth(multi_polylist.ml2, i) ELSIF booleans.OR(list_adt[nat].null?(multi_polylist.ml2), reals.>=(i, list_props[nat].length(multi_polylist.ml2))) THEN list_props[nat].nth(multi_polylist.ml1, i) ELSE multi_polylist.maxnum(list_props[nat].nth(multi_polylist.ml1, i), list_props[nat].nth(multi_polylist.ml2, i)) ENDIF))}"))) (max_TCC7 0 (max_TCC7-1 nil 3603207043 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil)) nil (max subtype "multi_polylist.ml1" "(list_adt[nat].cons?)"))) (max_TCC8 0 (max_TCC8-1 nil 3603210536 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil)) nil (max subtype "multi_polylist.ml2" "(list_adt[nat].cons?)"))) (max_TCC9 0 (max_TCC9-1 nil 3603210536 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (length def-decl "nat" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals)) nil (max termination "multi_polylist.max(list_adt[nat].cdr(multi_polylist.ml1), list_adt[nat].cdr(multi_polylist.ml2))" "nil"))) (max_TCC10 0 (max_TCC10-1 nil 3603210536 ("" (skeep) (("" (split) (("1" (expand "length" + 1) (("1" (assert) (("1" (expand "length" + 2) (("1" (expand "length" + 3) (("1" (typepred "v(cdr[nat](ml1), cdr[nat](ml2))") (("1" (replaces -2) (("1" (expand "maxnum" +) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "nth" + 1) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (expand "length" -2) (("4" (typepred "v(cdr[nat](ml1), cdr[nat](ml2))") (("4" (inst - "i-1") (("4" (assert) (("4" (lift-if) (("4" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "length" -2) (("5" (typepred "v(cdr[nat](ml1), cdr[nat](ml2))") (("5" (inst - "i-1") (("5" (assert) (("5" (lift-if) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "length" -1) (("6" (typepred "v(cdr[nat](ml1), cdr[nat](ml2))") (("6" (inst - "i-1") (("6" (assert) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (maxnum const-decl "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (length def-decl "nat" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (max subtype "list_adt[nat].cons(multi_polylist.maxnum(list_adt[nat].car(multi_polylist.ml1), list_adt[nat].car(multi_polylist.ml2)), multi_polylist.max(list_adt[nat].cdr(multi_polylist.ml1), list_adt[nat].cdr(multi_polylist.ml2)))" "{ml | booleans.AND(list_props[nat].length(multi_polylist.ml) = multi_polylist.maxnum(list_props[nat].length(multi_polylist.ml1), list_props[nat].length(multi_polylist.ml2)), FORALL (i: naturalnumbers.nat): booleans.IMPLIES(reals.<(i, list_props[nat].length(multi_polylist.ml)), list_props[nat].nth(multi_polylist.ml, i) = IF booleans.OR(list_adt[nat].null?(multi_polylist.ml1), reals.>=(i, list_props[nat].length(multi_polylist.ml1))) THEN list_props[nat].nth(multi_polylist.ml2, i) ELSIF booleans.OR(list_adt[nat].null?(multi_polylist.ml2), reals.>=(i, list_props[nat].length(multi_polylist.ml2))) THEN list_props[nat].nth(multi_polylist.ml1, i) ELSE multi_polylist.maxnum(list_props[nat].nth(multi_polylist.ml1, i), list_props[nat].nth(multi_polylist.ml2, i)) ENDIF))}"))) (max_id 0 (max_id-1 nil 3603440469 ("" (induct "ml") (("1" (grind) nil nil) ("2" (skolem 1 ("rr" "ll")) (("2" (flatten) (("2" (expand "max" +) (("2" (expand "maxnum") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (max def-decl "{ml |
   length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
    FORALL (i: nat):
      i < length(ml) IMPLIES
       nth(ml, i) =
        IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
        ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
        ELSE maxnum(nth(ml1, i), nth(ml2, i))
        ENDIF}" multi_polylist nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (maxnum const-decl "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (MonoList type-eq-decl nil multi_polylist nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil)) shostak)) (max_cdr_TCC1 0 (max_cdr_TCC1-1 nil 3603447297 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (maxnum const-decl "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist nil) (max def-decl "{ml |
   length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
    FORALL (i: nat):
      i < length(ml) IMPLIES
       nth(ml, i) =
        IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
        ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
        ELSE maxnum(nth(ml1, i), nth(ml2, i))
        ENDIF}" multi_polylist nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (max_cdr subtype "multi_polylist.max(multi_polylist.ml1, multi_polylist.ml2)" "(list_adt[nat].cons?)"))) (max_cdr 0 (max_cdr-1 nil 3603447298 ("" (case "FORALL (ml1, ml2: MonoList,r1,r2:real):
        cdr(max(cons(r1,ml1), cons(r2,ml2))) = max(cdr(cons(r1,ml1)), cdr(cons(r2,ml2)))") (("1" (skeep) (("1" (inst - "cdr(ml1)" "cdr(ml2)" "car(ml1)" "car(ml2)") (("1" (assert) (("1" (case "FORALL (l:list[nat]): (NOT null?(l)) IMPLIES l = cons(car(l),cdr(l))") (("1" (rewrite -1 :dir rl) (("1" (rewrite -1 :dir rl) nil nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (decompose-equality 2) nil nil)) nil)) nil) ("3" (assert) (("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (expand "max" + 1) (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (list_cons_extensionality formula-decl nil list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (= const-decl "[T, T -> boolean]" equalities nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (length def-decl "nat" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (maxnum const-decl "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (max def-decl "{ml |
   length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
    FORALL (i: nat):
      i < length(ml) IMPLIES
       nth(ml, i) =
        IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
        ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
        ELSE maxnum(nth(ml1, i), nth(ml2, i))
        ENDIF}" multi_polylist nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)) shostak)) (max_sym 0 (max_sym-1 nil 3603445515 ("" (induct "ml1") (("1" (grind) (("1" (expand "max" +) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (skolem 1 ("r" "l")) (("2" (flatten) (("2" (skeep) (("2" (expand "max" +) (("2" (lift-if) (("2" (ground) (("2" (case "maxnum(r,car(ml2)) = maxnum(car(ml2),r)") (("1" (replace -1) (("1" (inst - "cdr(ml2)") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "maxnum" 1) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (NOT const-decl "[bool -> bool]" booleans nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (max def-decl "{ml |
   length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
    FORALL (i: nat):
      i < length(ml) IMPLIES
       nth(ml, i) =
        IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
        ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
        ELSE maxnum(nth(ml1, i), nth(ml2, i))
        ENDIF}" multi_polylist nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (maxnum const-decl "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (MonoList type-eq-decl nil multi_polylist nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil)) shostak)) (max_assoc 0 (max_assoc-2 "" 3790098034 ("" (induct "ml") (("1" (grind) nil nil) ("2" (skolem 1 ("r" "l")) (("2" (flatten) (("2" (skeep) (("2" (expand "max" + 4) (("2" (lift-if) (("2" (ground) (("1" (expand "max" + 2) (("1" (propax) nil nil)) nil) ("2" (expand "max" + 1) (("2" (lift-if) (("2" (ground) (("1" (grind) nil nil) ("2" (expand "max" 2 1) (("2" (lift-if) (("2" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "max" + 3) (("2" (lift-if) (("2" (assert) (("2" (lemma "max_cdr") (("2" (inst - "ml1" "ml2") (("2" (assert) (("2" (replaces -1) (("2" (inst - "cdr(ml1)" "cdr(ml2)") (("2" (replace -1) (("2" (expand "maxnum") (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (ml2 skolem-const-decl "MonoList" multi_polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (max_cdr formula-decl nil multi_polylist nil) (TRUE const-decl "bool" booleans nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (max def-decl "{ml |
   length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
    FORALL (i: nat):
      i < length(ml) IMPLIES
       nth(ml, i) =
        IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
        ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
        ELSE maxnum(nth(ml1, i), nth(ml2, i))
        ENDIF}" multi_polylist nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (maxnum const-decl "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (MonoList type-eq-decl nil multi_polylist nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil)) shostak) (max_assoc-1 nil 3603446582 ("" (induct "ml") (("1" (grind) nil nil) ("2" (skolem 1 ("r" "l")) (("2" (flatten) (("2" (skeep) (("2" (expand "max" + 4) (("2" (lift-if) (("2" (ground) (("1" (expand "max" + 2) (("1" (propax) nil nil)) nil) ("2" (expand "max" + 1) (("2" (assert) (("2" (lift-if) (("2" (ground) (("1" (grind) nil nil) ("2" (expand "max" 2 1) (("2" (assert) (("2" (lift-if) (("2" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "max" + 3) (("2" (lift-if) (("2" (assert) (("2" (lemma "max_cdr") (("2" (inst - "ml1" "ml2") (("2" (assert) (("2" (replaces -1) (("2" (inst - "cdr(ml1)" "cdr(ml2)") (("2" (replace -1) (("2" (expand "maxnum") (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) nil (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (max_cdr formula-decl nil multi_polylist nil) (TRUE const-decl "bool" booleans nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (max def-decl "{ml |
   length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
    FORALL (i: nat):
      i < length(ml) IMPLIES
       nth(ml, i) =
        IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
        ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
        ELSE maxnum(nth(ml1, i), nth(ml2, i))
        ENDIF}" multi_polylist nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (maxnum const-decl "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (MonoList type-eq-decl nil multi_polylist nil) (AND const-decl "[bool, bool -> bool]" booleans nil) nil (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil)) shostak)) (varmono_TCC1 0 (varmono_TCC1-1 nil 3603021513 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals)) nil (varmono subtype "(number_fields.-)(multi_polylist.i, 1)" "nat"))) (varmono_TCC2 0 (varmono_TCC2-1 nil 3603021513 ("" (termination-tcc) nil nil) nil nil (varmono termination "multi_polylist.varmono((number_fields.-)(multi_polylist.i, 1), multi_polylist.n)" "nil"))) (monolist_eval_rec_TCC1 0 (monolist_eval_rec_TCC2-1 nil 3604179743 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (MonoList type-eq-decl nil multi_polylist nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (/= const-decl "boolean" notequal nil)) nil (monolist_eval_rec subtype "list_props[nat].nth(multi_polylist.ml, multi_polylist.k)" "{i_1: integers.int | booleans.OR(multi_polylist.xvar((number_fields.+)(multi_polylist.i, multi_polylist.k)) /= 0, reals.>=(i_1, 0))}"))) (monolist_eval_rec_TCC2 0 (monolist_eval_rec_TCC3-1 nil 3604179743 ("" (skeep) (("" (case-replace "length(ml) = 0") (("1" (grind) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (MonoList type-eq-decl nil multi_polylist nil) (real_times_real_is_real application-judgement "real" reals nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (product def-decl "real" product reals)) nil (monolist_eval_rec subtype "multi_polylist.c" "{r: reals.real | r = number_fields.*(multi_polylist.c, product[nat].product(0, (number_fields.-)(list_props[nat].length(multi_polylist.ml), 1), LAMBDA (k: naturalnumbers.nat): IF reals.<(k, list_props[nat].length(multi_polylist.ml)) THEN exponentiation.^(multi_polylist.xvar((number_fields.+)(multi_polylist.i, k)), list_props[nat].nth(multi_polylist.ml, k)) ELSE 1 ENDIF))}"))) (monolist_eval_rec_TCC3 0 (monolist_eval_rec_TCC4-1 nil 3604179743 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil)) nil (monolist_eval_rec subtype "multi_polylist.ml" "(list_adt[nat].cons?)"))) (monolist_eval_rec_TCC4 0 (monolist_eval_rec_TCC5-1 nil 3604179743 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (/= const-decl "boolean" notequal nil)) nil (monolist_eval_rec subtype "list_adt[nat].car(multi_polylist.ml)" "{i_1: integers.int | booleans.OR(multi_polylist.xvar(multi_polylist.i) /= 0, reals.>=(i_1, 0))}"))) (monolist_eval_rec_TCC5 0 (monolist_eval_rec_TCC6-1 nil 3604179743 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil (monolist_eval_rec termination "multi_polylist.monolist_eval_rec(list_adt[nat].cdr(multi_polylist.ml), number_fields.*(multi_polylist.c, exponentiation.^(multi_polylist.xvar(multi_polylist.i), list_adt[nat].car(multi_polylist.ml))), (number_fields.+)(multi_polylist.i, 1))" "nil"))) (monolist_eval_rec_TCC6 0 (monolist_eval_rec_TCC7-1 nil 3604179743 ("" (skeep) (("" (typepred "v(cdr[nat](ml), c * xvar(i) ^ car[nat](ml), i + 1)(xvar)") (("" (case "0 < length[nat](ml)") (("1" (rewrite "product_first" 2) (("1" (assert) (("1" (expand "nth" 2 1) (("1" (case "product(0, length(cdr[nat](ml)) - 1,
                LAMBDA (k: nat):
                  IF k < length(cdr[nat](ml))
                    THEN xvar(1 + k + i) ^ nth(cdr[nat](ml), k)
                  ELSE 1
                  ENDIF) = product(1, length[nat](ml) - 1,
                  LAMBDA (k: nat):
                    IF k < length[nat](ml)
                      THEN xvar(k + i) ^ nth[nat](ml, k)
                    ELSE 1
                    ENDIF)") (("1" (assert) nil nil) ("2" (hide-all-but (-1 1 2)) (("2" (expand "length" 1 3) (("2" (expand "length" 1 4) (("2" (lemma "product_shift_T[nat]") (("2" (inst -1 _ "length(cdr[nat](ml)) - 1" "0" "1") (("2" (assert) (("2" (inst?) (("1" (expand "nth" -1 2) (("1" (case-replace "(LAMBDA (i_1: nat):
                 IF 1 + i_1 < 1 + length[nat](cdr(ml))
                   THEN xvar(1 + i_1 + i) ^ nth(cdr(ml), i_1)
                 ELSE 1
                 ENDIF) = (LAMBDA (k: nat):
                IF k < length(cdr[nat](ml))
                  THEN xvar(1 + k + i) ^ nth(cdr[nat](ml), k)
                ELSE 1
                ENDIF)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (grind) nil nil)) nil) ("4" (hide-all-but 1) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (< const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (length def-decl "nat" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (product def-decl "real" product reals) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (MonoList type-eq-decl nil multi_polylist nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (product_first formula-decl nil product reals) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (ml skolem-const-decl "MonoList" multi_polylist nil) (xvar skolem-const-decl "[nat -> real]" multi_polylist nil) (i skolem-const-decl "nat" multi_polylist nil) (expt def-decl "real" exponentiation nil) (minus_int_is_int application-judgement "int" integers nil) (product_shift_T formula-decl nil product reals) (real_times_real_is_real application-judgement "real" reals nil)) nil (monolist_eval_rec subtype "multi_polylist.monolist_eval_rec(list_adt[nat].cdr(multi_polylist.ml), number_fields.*(multi_polylist.c, exponentiation.^(multi_polylist.xvar(multi_polylist.i), list_adt[nat].car(multi_polylist.ml))), (number_fields.+)(multi_polylist.i, 1))(multi_polylist.xvar)" "{r: reals.real | r = number_fields.*(multi_polylist.c, product[nat].product(0, (number_fields.-)(list_props[nat].length(multi_polylist.ml), 1), LAMBDA (k: naturalnumbers.nat): IF reals.<(k, list_props[nat].length(multi_polylist.ml)) THEN exponentiation.^(multi_polylist.xvar((number_fields.+)(multi_polylist.i, k)), list_props[nat].nth(multi_polylist.ml, k)) ELSE 1 ENDIF))}"))) (monolist_eval_prod_TCC1 0 (monolist_eval_prod_TCC1-1 nil 3603468314 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (/= const-decl "boolean" notequal nil)) nil (monolist_eval_prod subtype "list_props[nat].nth(multi_polylist.ml, multi_polylist.i)" "{i_1: integers.int | booleans.OR(multi_polylist.xvar(multi_polylist.i) /= 0, reals.>=(i_1, 0))}"))) (monolist_eval_prod 0 (monolist_eval_prod-1 nil 3603468325 ("" (skeep) (("" (expand "monolist_eval") (("" (typepred "monolist_eval_rec(ml, 1, 0)(xvar)") (("" (assert) nil nil)) nil)) nil)) nil) ((monolist_eval const-decl "real" multi_polylist nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (product def-decl "real" product reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (< const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (monolist_eval_rec def-decl "{r: real |
   r =
    c *
     product(0, length(ml) - 1,
             LAMBDA (k: nat):
               IF k < length(ml) THEN xvar(k + i) ^ nth(ml, k)
               ELSE 1
               ENDIF)}" multi_polylist nil)) shostak)) (monosum_TCC1 0 (monosum_TCC1-1 nil 3603023858 ("" (skeep*) (("" (expand "monolist_eval") (("" (expand "monolist_eval_rec" + 2) (("" (assert) nil nil)) nil)) nil)) nil) ((monolist_eval const-decl "real" multi_polylist nil) (real_times_real_is_real application-judgement "real" reals nil) (monolist_eval_rec def-decl "{r: real |
   r =
    c *
     product(0, length(ml) - 1,
             LAMBDA (k: nat):
               IF k < length(ml) THEN xvar(k + i) ^ nth(ml, k)
               ELSE 1
               ENDIF)}" multi_polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (monosum subtype "multi_polylist.ml2" "{pml2: multi_polylist.MonoList | FORALL (xvar): multi_polylist.monolist_eval(pml2)(multi_polylist.xvar) = number_fields.*(multi_polylist.monolist_eval(multi_polylist.ml1)(multi_polylist.xvar), multi_polylist.monolist_eval(multi_polylist.ml2)(multi_polylist.xvar))}"))) (monosum_TCC2 0 (monosum_TCC2-1 nil 3603023858 ("" (skeep*) (("" (expand "monolist_eval") (("" (expand "monolist_eval_rec" + 3) (("" (assert) nil nil)) nil)) nil)) nil) ((monolist_eval const-decl "real" multi_polylist nil) (real_times_real_is_real application-judgement "real" reals nil) (monolist_eval_rec def-decl "{r: real |
   r =
    c *
     product(0, length(ml) - 1,
             LAMBDA (k: nat):
               IF k < length(ml) THEN xvar(k + i) ^ nth(ml, k)
               ELSE 1
               ENDIF)}" multi_polylist nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (monosum subtype "multi_polylist.ml1" "{pml2: multi_polylist.MonoList | FORALL (xvar): multi_polylist.monolist_eval(pml2)(multi_polylist.xvar) = number_fields.*(multi_polylist.monolist_eval(multi_polylist.ml1)(multi_polylist.xvar), multi_polylist.monolist_eval(multi_polylist.ml2)(multi_polylist.xvar))}"))) (monosum_TCC3 0 (monosum_TCC3-3 "" 3604248507 ("" (skeep*) (("" (typepred "v(cdr[nat](ml1), cdr[nat](ml2))") (("" (hide -1) (("" (inst -1 "LAMBDA(i:nat):xvar(i+1)") (("" (expand "monolist_eval") (("" (expand "monolist_eval_rec" + 1) (("" (typepred "monolist_eval_rec(v(cdr[nat](ml1), cdr[nat](ml2)),
                          1 * xvar(0) ^ (car[nat](ml1) + car[nat](ml2)), 1)
                         (xvar)") (("" (replaces -1) (("" (expand "monolist_eval_rec" +) (("" (assert) (("" (typepred "monolist_eval_rec(cdr(ml1), 1 * xvar(0) ^ car(ml1), 1)(xvar)") (("" (replaces -1) (("" (typepred "monolist_eval_rec(cdr(ml2), 1 * xvar(0) ^ car(ml2), 1)(xvar)") (("" (replaces -1) (("" (case "FORALL (x:real,j,k:nat): x^(j+k) = x^j*x^k") (("1" (inst?) (("1" (replaces -1) (("1" (typepred "monolist_eval_rec(cdr[nat](ml1), 1, 0)(LAMBDA (i: nat): xvar(1 + i))") (("1" (typepred "monolist_eval_rec(cdr[nat](ml2), 1, 0)(LAMBDA (i: nat): xvar(1 + i))") (("1" (replaces (-1 -2) :dir rl) (("1" (typepred "monolist_eval_rec(v(cdr[nat](ml1), cdr[nat](ml2)), 1, 0)
                       (LAMBDA (i: nat): xvar(1 + i))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "expt_plus") (("2" (case "FORALL (j,k:nat): 0^(j+k) = 0^j*0^k") (("1" (skeep) (("1" (case "x = 0") (("1" (inst - "j" "k") (("1" (assert) nil nil)) nil) ("2" (inst - "j" "k" "x") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (case "k = 0") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (monolist_eval const-decl "real" multi_polylist nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (monolist_eval_rec def-decl "{r: real |
   r =
    c *
     product(0, length(ml) - 1,
             LAMBDA (k: nat):
               IF k < length(ml) THEN xvar(k + i) ^ nth(ml, k)
               ELSE 1
               ENDIF)}" multi_polylist nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (nat_exp application-judgement "nat" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (x skolem-const-decl "real" multi_polylist nil) (nzreal nonempty-type-eq-decl nil reals nil) (int_plus_int_is_int application-judgement "int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nat_expt application-judgement "nat" exponentiation nil) (expt def-decl "real" exponentiation nil) (expt_plus formula-decl nil exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_times_real_is_real application-judgement "real" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (product def-decl "real" product reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (monosum subtype "list_adt[nat].cons((number_fields.+)(list_adt[nat].car(multi_polylist.ml1), list_adt[nat].car(multi_polylist.ml2)), multi_polylist.monosum(list_adt[nat].cdr(multi_polylist.ml1), list_adt[nat].cdr(multi_polylist.ml2)))" "{pml2: multi_polylist.MonoList | FORALL (xvar): multi_polylist.monolist_eval(pml2)(multi_polylist.xvar) = number_fields.*(multi_polylist.monolist_eval(multi_polylist.ml1)(multi_polylist.xvar), multi_polylist.monolist_eval(multi_polylist.ml2)(multi_polylist.xvar))}"))) (meval_TCC1 0 (meval_TCC1-1 nil 3603036932 ("" (subtype-tcc) nil nil) ((MonoList type-eq-decl nil multi_polylist nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (meval subtype "multi_polylist.mpl" "(list_adt[[real, MonoList]].cons?)"))) (meval_TCC2 0 (meval_TCC2-1 nil 3603036932 ("" (termination-tcc) nil nil) ((lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (MonoList type-eq-decl nil multi_polylist nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (meval termination "multi_polylist.meval(list_adt[[real, MonoList]].cdr(multi_polylist.mpl))" "nil"))) (meval_TCC3 0 (meval_TCC3-1 nil 3603036932 ("" (subtype-tcc) nil nil) nil nil (meval subtype "multi_polylist.mpl" "(list_adt[[real, MonoList]].cons?)"))) (meval_sigma 0 (meval_sigma-2 "" 3790098043 ("" (induct "mpl") (("1" (grind) nil nil) ("2" (skolem 1 ("T" "L")) (("2" (flatten) (("2" (skeep) (("2" (inst - "xvar") (("2" (expand "meval" +) (("2" (lemma "sigma_split") (("2" (expand "length" + 1) (("2" (assert) (("2" (invoke (inst - "%1" _ _ _) (! 1 2 3)) (("2" (inst?) (("2" (inst - "0") (("2" (assert) (("2" (replaces -1) (("2" (expand "sigma" + 1) (("2" (expand "sigma" + 1) (("2" (assert) (("2" (expand "length" + 1) (("2" (expand "nth" + 3) (("2" (expand "nth" + 3) (("2" (replaces -1) (("2" (case "FORALL (k:nat): sigma(0, k,
            LAMBDA (i: nat):
              IF i < length(L)
                THEN nth(L, i)`1 * monolist_eval(nth(L, i)`2)(xvar)
              ELSE 0
              ENDIF)
       =
       sigma(1, k+1,
             LAMBDA (i: nat):
               IF i < length(cons(T, L))
                 THEN nth(cons(T, L), i)`1 *
                       monolist_eval(nth(cons(T, L), i)`2)(xvar)
               ELSE 0
               ENDIF)") (("1" (inst - "length(L)-1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "k") (("1" (assert) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "k") (("2" (flatten) (("2" (assert) (("2" (expand "sigma" +) (("2" (replaces -1 :dir rl) (("2" (assert) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_0_neg formula-decl nil sigma_nat reals) (int_plus_int_is_int application-judgement "int" integers nil) (L skolem-const-decl "list[[real, MonoList]]" multi_polylist nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (sigma_split formula-decl nil sigma reals) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (list type-decl nil list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (monolist_eval const-decl "real" multi_polylist nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (length def-decl "nat" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (meval def-decl "real" multi_polylist nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak) (meval_sigma-1 nil 3603455464 ("" (induct "mpl") (("1" (grind) nil nil) ("2" (skolem 1 ("T" "L")) (("2" (flatten) (("2" (skeep) (("2" (inst - "xvar") (("2" (expand "meval" +) (("2" (lemma "sigma_split") (("2" (expand "length" + 1) (("2" (assert) (("2" (invoke (inst - "%1" _ _ _) (! 1 2 3)) (("2" (inst?) (("2" (inst - "0") (("2" (assert) (("2" (replaces -1) (("2" (expand "sigma" + 1) (("2" (expand "sigma" + 1) (("2" (assert) (("2" (expand "length" + 1) (("2" (expand "nth" + 3) (("2" (expand "nth" + 3) (("2" (replaces -1) (("2" (case "FORALL (k:nat): sigma(0, k,
            LAMBDA (i: nat):
              IF i < length(L)
                THEN nth(L, i)`1 * monolist_eval(nth(L, i)`2)(xvar)
              ELSE 0
              ENDIF)
       =
       sigma(1, k+1,
             LAMBDA (i: nat):
               IF i < length(cons(T, L))
                 THEN nth(cons(T, L), i)`1 *
                       monolist_eval(nth(cons(T, L), i)`2)(xvar)
               ELSE 0
               ENDIF)") (("1" (inst - "length(L)-1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (hide 2) (("2" (induct "k") (("1" (assert) (("1" (expand "sigma") (("1" (expand "sigma") (("1" (assert) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 "k") (("2" (flatten) (("2" (assert) (("2" (expand "sigma" +) (("2" (replaces -1 :dir rl) (("2" (assert) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (inst + "10") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (sigma_0_neg formula-decl nil sigma_nat reals) (int_plus_int_is_int application-judgement "int" integers nil) nil (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (pred type-eq-decl nil defined_types nil) (nat_induction formula-decl nil naturalnumbers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_plus_real_is_real application-judgement "real" reals nil) (sigma_split formula-decl nil sigma reals) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (list type-decl nil list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) nil (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (monolist_eval const-decl "real" multi_polylist nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (length def-decl "nat" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (sigma def-decl "real" sigma reals) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (meval def-decl "real" multi_polylist nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak)) (degree_TCC1 0 (degree_TCC1-1 nil 3603214067 ("" (subtype-tcc) nil nil) nil nil (degree subtype "(: :)" "{ml | booleans.IMPLIES(((booleans.NOT)(list_adt[[real, MonoList]].null?(multi_polylist.mpl))), FORALL (i: naturalnumbers.below(list_props[[real, MonoList]].length(multi_polylist.mpl))): booleans.AND(multi_polylist.ml = multi_polylist.max(list_props[[real, MonoList]].nth(multi_polylist.mpl, i)`2, multi_polylist.ml), reals.>=(list_props[nat].length(multi_polylist.ml), list_props[nat].length(list_props[[real, MonoList]].nth(multi_polylist.mpl, i)`2))))}"))) (degree_TCC2 0 (degree_TCC2-1 nil 3603214067 ("" (skeep) (("" (skeep) (("" (split) (("1" (typepred "i") (("1" (case "NOT i = 0") (("1" (grind) nil nil) ("2" (replaces -1) (("2" (expand "nth") (("2" (rewrite "max_id") nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (case "NOT i = 0") (("1" (grind) nil nil) ("2" (replaces -1) (("2" (expand "nth") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (length def-decl "nat" list_props nil) (MonoList type-eq-decl nil multi_polylist nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (max_id formula-decl nil multi_polylist nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil)) nil (degree subtype "list_adt[[real, MonoList]].car(multi_polylist.mpl)`2" "{ml | booleans.IMPLIES(((booleans.NOT)(list_adt[[real, MonoList]].null?(multi_polylist.mpl))), FORALL (i: naturalnumbers.below(list_props[[real, MonoList]].length(multi_polylist.mpl))): booleans.AND(multi_polylist.ml = multi_polylist.max(list_props[[real, MonoList]].nth(multi_polylist.mpl, i)`2, multi_polylist.ml), reals.>=(list_props[nat].length(multi_polylist.ml), list_props[nat].length(list_props[[real, MonoList]].nth(multi_polylist.mpl, i)`2))))}"))) (degree_TCC3 0 (degree_TCC3-1 nil 3603214067 ("" (skeep) (("" (expand "length" + 2) (("" (assert) nil nil)) nil)) nil) ((length def-decl "nat" list_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (degree termination "multi_polylist.degree(list_adt[[real, MonoList]].cdr(multi_polylist.mpl))" "nil"))) (degree_TCC4 0 (degree_TCC4-1 nil 3603214067 ("" (skeep) (("" (skeep) (("" (typepred "v(cdr[[real, MonoList]](mpl))") (("1" (hide -1) (("1" (assert) (("1" (split) (("1" (case "i = 0") (("1" (replaces -1) (("1" (expand "nth" +) (("1" (assert) (("1" (case "FORALL (l1,l2:list[nat]): max(l1,l2) = max(l1,max(l1,l2))") (("1" (inst?) nil nil) ("2" (hide-all-but 1) (("2" (induct "l1") (("1" (grind) nil nil) ("2" (skolem 1 ("r" "l")) (("2" (flatten) (("2" (skeep) (("2" (expand "max" +) (("2" (assert) (("2" (lift-if) (("2" (lift-if) (("2" (lift-if) (("2" (ground) (("1" (expand "maxnum" +) (("1" (rewrite "max_id" +) nil nil)) nil) ("2" (case "maxnum(r, maxnum(r, car(l2))) = maxnum(r,car(l2))") (("1" (replace -1) (("1" (assert) (("1" (inst - "cdr(l2)") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (name "V" "v(cdr[[real, MonoList]](mpl))") (("2" (replace -1) (("2" (inst - "i-1") (("1" (expand "nth" +) (("1" (flatten) (("1" (assert) (("1" (rewrite "max_assoc" +) (("1" (lemma "max_sym") (("1" (inst - "nth(cdr(mpl), i - 1)`2" "car[[real, MonoList]](mpl)`2") (("1" (replace -1) (("1" (rewrite "max_assoc" + :dir rl) (("1" (lemma "max_sym") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "max(car[[real, MonoList]](mpl)`2,
               v(cdr[[real, MonoList]](mpl)))") (("2" (replace -2) (("2" (assert) (("2" (case "i = 0") (("1" (replaces -1) (("1" (expand "nth" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (inst -4 "i-1") (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil) ("2" (assert) (("2" (typepred "i") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (max_sym formula-decl nil multi_polylist nil) (max_assoc formula-decl nil multi_polylist nil) (i skolem-const-decl "below(length(mpl))" multi_polylist nil) (mpl skolem-const-decl "MultiPolyList" multi_polylist nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (max_id formula-decl nil multi_polylist nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (list_induction formula-decl nil list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (< const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (maxnum const-decl "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (max def-decl "{ml |
   length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
    FORALL (i: nat):
      i < length(ml) IMPLIES
       nth(ml, i) =
        IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
        ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
        ELSE maxnum(nth(ml1, i), nth(ml2, i))
        ENDIF}" multi_polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)) nil (degree subtype "multi_polylist.max(list_adt[[real, MonoList]].car(multi_polylist.mpl)`2, multi_polylist.degree(list_adt[[real, MonoList]].cdr(multi_polylist.mpl)))" "{ml | booleans.IMPLIES(((booleans.NOT)(list_adt[[real, MonoList]].null?(multi_polylist.mpl))), FORALL (i: naturalnumbers.below(list_props[[real, MonoList]].length(multi_polylist.mpl))): booleans.AND(multi_polylist.ml = multi_polylist.max(list_props[[real, MonoList]].nth(multi_polylist.mpl, i)`2, multi_polylist.ml), reals.>=(list_props[nat].length(multi_polylist.ml), list_props[nat].length(list_props[[real, MonoList]].nth(multi_polylist.mpl, i)`2))))}"))) (degree_zero 0 (degree_zero-1 nil 3603531482 ("" (induct "mpl") (("1" (grind) nil nil) ("2" (skolem 1 ("rp" "lmp")) (("2" (flatten) (("2" (skeep) (("2" (case "i = 0") (("1" (assert) (("1" (replaces -1) (("1" (expand "degree" -2) (("1" (lift-if) (("1" (expand "nth" 1) (("1" (ground) (("1" (hide -2) (("1" (expand "max" -1) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "max" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (inst - "i-1") (("1" (assert) (("1" (split -1) (("1" (expand "nth" +) (("1" (propax) nil nil)) nil) ("2" (expand "length" -2) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) (("2" (expand "degree" -1) (("2" (lift-if) (("2" (ground) (("1" (expand "degree" 1) (("1" (propax) nil nil)) nil) ("2" (expand "max" -1) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (i skolem-const-decl "nat" multi_polylist nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (TRUE const-decl "bool" booleans nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (list type-decl nil list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (degree def-decl "{ml |
   (NOT null?(mpl)) IMPLIES
    FORALL (i: below(length(mpl))):
      ml = max(nth(mpl, i)`2, ml) AND length(ml) >= length(nth(mpl, i)`2)}" multi_polylist nil) (max def-decl "{ml |
   length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
    FORALL (i: nat):
      i < length(ml) IMPLIES
       nth(ml, i) =
        IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
        ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
        ELSE maxnum(nth(ml1, i), nth(ml2, i))
        ENDIF}" multi_polylist nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (maxnum const-decl "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (MultiPolyList type-eq-decl nil multi_polylist nil)) shostak)) (multipoly_to_mpoly_TCC1 0 (multipoly_to_mpoly_TCC1-1 nil 3603451460 ("" (subtype-tcc) nil nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals)) nil (multipoly_to_mpoly subtype "list_props[[real, MonoList]].length(multi_polylist.mpl)" "posnat"))) (mp_simp_rec_TCC1 0 (mp_simp_rec_TCC1-1 nil 3603033743 ("" (skeep) (("" (skeep) (("" (expand "meval" +) (("" (assert) (("" (expand "meval" + 1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_plus_real_is_real application-judgement "real" reals nil) (meval def-decl "real" multi_polylist nil)) nil (mp_simp_rec subtype "list_adt[[real, MonoList]].cons((multi_polylist.thiscoeff, multi_polylist.mono), multi_polylist.ans)" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = (number_fields.+)((number_fields.+)((number_fields.+)(multi_polylist.meval(multi_polylist.ans)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.swiped)(multi_polylist.xvar)), multi_polylist.meval(multi_polylist.toswipe)(multi_polylist.xvar)), number_fields.*(multi_polylist.thiscoeff, multi_polylist.monolist_eval(multi_polylist.mono)(multi_polylist.xvar)))}"))) (mp_simp_rec_TCC2 0 (mp_simp_rec_TCC2-2 "" 3790098046 ("" (skeep) (("" (assert) (("" (flatten) (("" (replaces -3) (("" (assert) (("" (skeep) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (monolist_eval const-decl "real" multi_polylist nil) (meval def-decl "real" multi_polylist nil)) shostak (mp_simp_rec subtype "multi_polylist.ans" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = (number_fields.+)((number_fields.+)((number_fields.+)(multi_polylist.meval(multi_polylist.ans)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.swiped)(multi_polylist.xvar)), multi_polylist.meval(multi_polylist.toswipe)(multi_polylist.xvar)), number_fields.*(multi_polylist.thiscoeff, multi_polylist.monolist_eval(multi_polylist.mono)(multi_polylist.xvar)))}")) (mp_simp_rec_TCC2-1 nil 3603033743 ("" (skeep) (("" (assert) (("" (flatten) (("" (replaces -1) (("" (replaces -3) (("" (assert) (("" (skeep) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (meval def-decl "real" multi_polylist nil)) nil (mp_simp_rec subtype "multi_polylist.ans" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = (number_fields.+)((number_fields.+)((number_fields.+)(multi_polylist.meval(multi_polylist.ans)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.swiped)(multi_polylist.xvar)), multi_polylist.meval(multi_polylist.toswipe)(multi_polylist.xvar)), number_fields.*(multi_polylist.thiscoeff, multi_polylist.monolist_eval(multi_polylist.mono)(multi_polylist.xvar)))}"))) (mp_simp_rec_TCC3 0 (mp_simp_rec_TCC3-1 nil 3603033743 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (/= const-decl "boolean" notequal nil)) nil (mp_simp_rec subtype "multi_polylist.swiped" "(list_adt[[real, MonoList]].cons?)"))) (mp_simp_rec_TCC4 0 (mp_simp_rec_TCC4-1 nil 3603033743 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< def-decl "bool" ordinals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (length def-decl "nat" list_props nil) (lex2 const-decl "ordinal" lex2 nil)) nil (mp_simp_rec termination "multi_polylist.mp_simp_rec(list_adt[[real, MonoList]].null, list_adt[[real, MonoList]].cdr(multi_polylist.swiped), list_adt[[real, MonoList]].cons((multi_polylist.thiscoeff, multi_polylist.mono), multi_polylist.ans), list_adt[[real, MonoList]].car(multi_polylist.swiped)`2, list_adt[[real, MonoList]].car(multi_polylist.swiped)`1)" "nil"))) (mp_simp_rec_TCC5 0 (mp_simp_rec_TCC5-1 nil 3603033743 ("" (skeep) (("" (skeep) (("" (assert) (("" (hide 3) (("" (typepred "v(null[[real, MonoList]], cdr[[real, MonoList]](swiped),
              cons[[real, MonoList]]((thiscoeff, mono), ans),
              car[[real, MonoList]](swiped)`2,
              car[[real, MonoList]](swiped)`1)") (("" (rewrite -1) (("" (hide -1) (("" (expand "meval" + 3) (("" (expand "meval" + 2) (("" (expand "meval" + 3) (("" (expand "meval" + 2) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (MonoList type-eq-decl nil multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (meval def-decl "real" multi_polylist nil) (ordstruct type-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (monolist_eval const-decl "real" multi_polylist nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (mp_simp_rec subtype "multi_polylist.mp_simp_rec(list_adt[[real, MonoList]].null, list_adt[[real, MonoList]].cdr(multi_polylist.swiped), list_adt[[real, MonoList]].cons((multi_polylist.thiscoeff, multi_polylist.mono), multi_polylist.ans), list_adt[[real, MonoList]].car(multi_polylist.swiped)`2, list_adt[[real, MonoList]].car(multi_polylist.swiped)`1)" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = (number_fields.+)((number_fields.+)((number_fields.+)(multi_polylist.meval(multi_polylist.ans)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.swiped)(multi_polylist.xvar)), multi_polylist.meval(multi_polylist.toswipe)(multi_polylist.xvar)), number_fields.*(multi_polylist.thiscoeff, multi_polylist.monolist_eval(multi_polylist.mono)(multi_polylist.xvar)))}"))) (mp_simp_rec_TCC6 0 (mp_simp_rec_TCC6-1 nil 3603033743 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (/= const-decl "boolean" notequal nil)) nil (mp_simp_rec subtype "multi_polylist.swiped" "(list_adt[[real, MonoList]].cons?)"))) (mp_simp_rec_TCC7 0 (mp_simp_rec_TCC7-1 nil 3603033743 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< def-decl "bool" ordinals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (/= const-decl "boolean" notequal nil) (length def-decl "nat" list_props nil) (lex2 const-decl "ordinal" lex2 nil)) nil (mp_simp_rec termination "multi_polylist.mp_simp_rec(list_adt[[real, MonoList]].null, list_adt[[real, MonoList]].cdr(multi_polylist.swiped), multi_polylist.ans, list_adt[[real, MonoList]].car(multi_polylist.swiped)`2, list_adt[[real, MonoList]].car(multi_polylist.swiped)`1)" "nil"))) (mp_simp_rec_TCC8 0 (mp_simp_rec_TCC8-2 "" 3804296693 ("" (skeep*) (("" (typepred "v(null[[real, MonoList]], cdr[[real, MonoList]](swiped), ans,
                car[[real, MonoList]](swiped)`2,
                car[[real, MonoList]](swiped)`1)") (("" (rewrite -1) (("" (hide -1) (("" (expand "meval" + 3) (("" (assert) (("" (hide 1) (("" (expand "meval" + 3) (("" (flatten) (("" (assert) (("" (expand "meval" + 2) (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (mp_simp_rec subtype "multi_polylist.mp_simp_rec(list_adt[[real, MonoList]].null, list_adt[[real, MonoList]].cdr(multi_polylist.swiped), multi_polylist.ans, list_adt[[real, MonoList]].car(multi_polylist.swiped)`2, list_adt[[real, MonoList]].car(multi_polylist.swiped)`1)" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = (number_fields.+)((number_fields.+)((number_fields.+)(multi_polylist.meval(multi_polylist.ans)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.swiped)(multi_polylist.xvar)), multi_polylist.meval(multi_polylist.toswipe)(multi_polylist.xvar)), number_fields.*(multi_polylist.thiscoeff, multi_polylist.monolist_eval(multi_polylist.mono)(multi_polylist.xvar)))}")) (mp_simp_rec_TCC8-1 nil 3603033743 ("" (skeep) (("" (skeep) (("" (typepred "v(null[[real, MonoList]], cdr[[real, MonoList]](swiped), ans,
              car[[real, MonoList]](swiped)`2,
              car[[real, MonoList]](swiped)`1)") (("" (rewrite -1) (("" (hide -1) (("" (expand "meval" + 3) (("" (assert) (("" (hide 3) (("" (expand "meval" + 3) (("" (flatten) (("" (replaces -2) (("" (assert) (("" (expand "meval" + 2) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (monolist_eval const-decl "real" multi_polylist nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (lex2 const-decl "ordinal" lex2 nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (meval def-decl "real" multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (MonoList type-eq-decl nil multi_polylist nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (mp_simp_rec subtype "multi_polylist.mp_simp_rec(list_adt[[real, MonoList]].null, list_adt[[real, MonoList]].cdr(multi_polylist.swiped), multi_polylist.ans, list_adt[[real, MonoList]].car(multi_polylist.swiped)`2, list_adt[[real, MonoList]].car(multi_polylist.swiped)`1)" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = (number_fields.+)((number_fields.+)((number_fields.+)(multi_polylist.meval(multi_polylist.ans)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.swiped)(multi_polylist.xvar)), multi_polylist.meval(multi_polylist.toswipe)(multi_polylist.xvar)), number_fields.*(multi_polylist.thiscoeff, multi_polylist.monolist_eval(multi_polylist.mono)(multi_polylist.xvar)))}"))) (mp_simp_rec_TCC9 0 (mp_simp_rec_TCC9-1 nil 3603033743 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (/= const-decl "boolean" notequal nil)) nil (mp_simp_rec subtype "multi_polylist.toswipe" "(list_adt[[real, MonoList]].cons?)"))) (mp_simp_rec_TCC10 0 (mp_simp_rec_TCC10-1 nil 3603033743 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length def-decl "nat" list_props nil) (< def-decl "bool" ordinals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (/= const-decl "boolean" notequal nil) (lex2 const-decl "ordinal" lex2 nil)) nil (mp_simp_rec termination "multi_polylist.mp_simp_rec(multi_polylist.swiped, list_adt[[real, MonoList]].cdr(multi_polylist.toswipe), multi_polylist.ans, multi_polylist.mono, (number_fields.+)(list_adt[[real, MonoList]].car(multi_polylist.toswipe)`1, multi_polylist.thiscoeff))" "nil"))) (mp_simp_rec_TCC11 0 (mp_simp_rec_TCC11-1 nil 3603033743 ("" (skeep) (("" (skeep) (("" (typepred "v(swiped, cdr[[real, MonoList]](toswipe), ans, mono,
              car[[real, MonoList]](toswipe)`1 + thiscoeff)") (("" (rewrite -1) (("" (hide -1) (("" (assert) (("" (hide (2 3 4)) (("" (assert) (("" (both-sides - "monolist_eval(mono)(xvar) * thiscoeff" 2) (("" (assert) (("" (case "NOT meval(toswipe)(xvar) - monolist_eval(mono)(xvar) * thiscoeff +
        thiscoeff * monolist_eval(mono)(xvar) = meval(toswipe)(xvar)") (("1" (assert) nil nil) ("2" (replaces -1) (("2" (expand "meval" + 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (both_sides_plus1 formula-decl nil real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_minus_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (MonoList type-eq-decl nil multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (meval def-decl "real" multi_polylist nil) (ordstruct type-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (monolist_eval const-decl "real" multi_polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (mp_simp_rec subtype "multi_polylist.mp_simp_rec(multi_polylist.swiped, list_adt[[real, MonoList]].cdr(multi_polylist.toswipe), multi_polylist.ans, multi_polylist.mono, (number_fields.+)(list_adt[[real, MonoList]].car(multi_polylist.toswipe)`1, multi_polylist.thiscoeff))" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = (number_fields.+)((number_fields.+)((number_fields.+)(multi_polylist.meval(multi_polylist.ans)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.swiped)(multi_polylist.xvar)), multi_polylist.meval(multi_polylist.toswipe)(multi_polylist.xvar)), number_fields.*(multi_polylist.thiscoeff, multi_polylist.monolist_eval(multi_polylist.mono)(multi_polylist.xvar)))}"))) (mp_simp_rec_TCC12 0 (mp_simp_rec_TCC12-1 nil 3603033743 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (< def-decl "bool" ordinals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (/= const-decl "boolean" notequal nil) (length def-decl "nat" list_props nil) (lex2 const-decl "ordinal" lex2 nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (mp_simp_rec termination "multi_polylist.mp_simp_rec(list_adt[[real, MonoList]].cons(list_adt[[real, MonoList]].car(multi_polylist.toswipe), multi_polylist.swiped), list_adt[[real, MonoList]].cdr(multi_polylist.toswipe), multi_polylist.ans, multi_polylist.mono, multi_polylist.thiscoeff)" "nil"))) (mp_simp_rec_TCC13 0 (mp_simp_rec_TCC13-1 nil 3603033743 ("" (skeep) (("" (skeep) (("" (typepred "v(cons[[real, MonoList]]
                  (car[[real, MonoList]](toswipe), swiped),
              cdr[[real, MonoList]](toswipe), ans, mono, thiscoeff)") (("" (rewrite -1) (("" (hide -1) (("" (assert) (("" (hide (3 4 5)) (("" (expand "meval" + 2) (("" (expand "meval" + 2) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (MonoList type-eq-decl nil multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (meval def-decl "real" multi_polylist nil) (ordstruct type-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (monolist_eval const-decl "real" multi_polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (mp_simp_rec subtype "multi_polylist.mp_simp_rec(list_adt[[real, MonoList]].cons(list_adt[[real, MonoList]].car(multi_polylist.toswipe), multi_polylist.swiped), list_adt[[real, MonoList]].cdr(multi_polylist.toswipe), multi_polylist.ans, multi_polylist.mono, multi_polylist.thiscoeff)" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = (number_fields.+)((number_fields.+)((number_fields.+)(multi_polylist.meval(multi_polylist.ans)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.swiped)(multi_polylist.xvar)), multi_polylist.meval(multi_polylist.toswipe)(multi_polylist.xvar)), number_fields.*(multi_polylist.thiscoeff, multi_polylist.monolist_eval(multi_polylist.mono)(multi_polylist.xvar)))}"))) (mp_simp_TCC1 0 (mp_simp_TCC1-1 nil 3603028950 ("" (skeep) (("" (assert) (("" (typepred "mp_simp_rec(null[[real, MonoList]], mpl,
                         null[[real, MonoList]],
                         car[[real, MonoList]](mpl)`2, 0)") (("" (decompose-equality +) (("" (inst - "x!1") (("" (replaces -1) (("" (expand "meval" + 3) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_plus_real_is_real application-judgement "real" reals nil) (TRUE const-decl "bool" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (MonoList type-eq-decl nil multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (meval def-decl "real" multi_polylist nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (monolist_eval const-decl "real" multi_polylist nil) (mp_simp_rec def-decl "{mpl |
   FORALL (xvar: [nat -> real]):
     meval(mpl)(xvar) =
      meval(swiped)(xvar) + meval(toswipe)(xvar) + meval(ans)(xvar) +
       thiscoeff * monolist_eval(mono)(xvar)}" multi_polylist nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (mp_simp subtype "multi_polylist.mp_simp_rec(list_adt[[real, MonoList]].null, multi_polylist.mpl, list_adt[[real, MonoList]].null, list_adt[[real, MonoList]].car(multi_polylist.mpl)`2, 0)" "{mulist: multi_polylist.MultiPolyList | multi_polylist.meval(multi_polylist.mpl) = multi_polylist.meval(mulist)}"))) (mpsum_TCC1 0 (mpsum_TCC1-1 nil 3603036932 ("" (case "FORALL (mpl1: MultiPolyList, mpl2: MultiPolyList):
               meval(append[[real, MonoList]](mpl1, mpl2)) =
                (+[[nat->real]])(meval(mpl1), meval(mpl2))") (("1" (skeep) (("1" (insteep -1) (("1" (typepred "mp_simp(append[[real, MonoList]](mpl1, mpl2))") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (induct "mpl1") (("1" (expand "+") (("1" (skeep) (("1" (decompose-equality +) (("1" (expand "append") (("1" (expand "meval") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skolem 1 ("X" "L")) (("2" (flatten) (("2" (skeep) (("2" (expand "append" +) (("2" (expand "meval" + 1) (("2" (decompose-equality +) (("2" (inst - "mpl2") (("2" (decompose-equality -) (("2" (inst - "x!1") (("2" (expand "+") (("2" (expand "meval" + 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (monolist_eval const-decl "real" multi_polylist nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_times_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (list_induction formula-decl nil list_adt nil) (mp_simp const-decl "{mulist: MultiPolyList | meval(mpl) = meval(mulist)}" multi_polylist nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (list type-decl nil list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (meval def-decl "real" multi_polylist nil) (append def-decl "list[T]" list_props nil) (+ const-decl "[T -> real]" real_fun_ops reals)) nil (mpsum subtype "multi_polylist.mp_simp(list_props[[real, MonoList]].append(multi_polylist.mpl1, multi_polylist.mpl2))" "{mpl | multi_polylist.meval(multi_polylist.mpl) = (real_fun_ops[[nat -> real]].+)(multi_polylist.meval(multi_polylist.mpl1), multi_polylist.meval(multi_polylist.mpl2))}"))) (mpprod_rec_TCC1 0 (mpprod_rec_TCC1-1 nil 3603106487 ("" (grind) nil nil) ((real_times_real_is_real application-judgement "real" reals nil) (meval def-decl "real" multi_polylist nil)) nil (mpprod_rec subtype "(: :)" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = number_fields.*(multi_polylist.meval(multi_polylist.mpl1)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.mpl2)(multi_polylist.xvar))}"))) (mpprod_rec_TCC2 0 (mpprod_rec_TCC2-1 nil 3603106487 ("" (grind) nil nil) ((monolist_eval const-decl "real" multi_polylist nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (meval def-decl "real" multi_polylist nil)) nil (mpprod_rec subtype "(: :)" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = number_fields.*(multi_polylist.meval(multi_polylist.mpl1)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.mpl2)(multi_polylist.xvar))}"))) (mpprod_rec_TCC3 0 (mpprod_rec_TCC3-1 nil 3603106487 ("" (grind) nil nil) nil nil (mpprod_rec subtype "multi_polylist.mpl2" "(list_adt[[real, MonoList]].cons?)"))) (mpprod_rec_TCC4 0 (mpprod_rec_TCC4-2 "" 3758391231 ("" (skeep) (("" (skeep) (("" (expand "meval" + 1) (("" (expand "meval" + 1) (("" (expand "meval") (("" (assert) (("" (typepred "monosum(car[[real, MonoList]](mpl1)`2,
                                car[[real, MonoList]](mpl2)`2)") (("" (hide -1) (("" (rewrite -1) (("" (assert) (("" (hide -1) (("" (expand "meval" +) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_plus_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (monolist_eval const-decl "real" multi_polylist nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (monosum def-decl "{pml2: MonoList |
   FORALL (xvar: [nat -> real]):
     monolist_eval(pml2)(xvar) =
      monolist_eval(ml1)(xvar) * monolist_eval(ml2)(xvar)}" multi_polylist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (meval def-decl "real" multi_polylist nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak (mpprod_rec subtype "(: (number_fields.*(list_adt[[real, MonoList]].car(multi_polylist.mpl1)`1, list_adt[[real, MonoList]].car(multi_polylist.mpl2)`1), multi_polylist.monosum(list_adt[[real, MonoList]].car(multi_polylist.mpl1)`2, list_adt[[real, MonoList]].car(multi_polylist.mpl2)`2)) :)" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = number_fields.*(multi_polylist.meval(multi_polylist.mpl1)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.mpl2)(multi_polylist.xvar))}")) (mpprod_rec_TCC4-1 nil 3603106487 ("" (grind) nil nil) nil nil (mpprod_rec subtype "(: (number_fields.*(list_adt[[real, MonoList]].car(multi_polylist.mpl1)`1, list_adt[[real, MonoList]].car(multi_polylist.mpl2)`1), multi_polylist.monosum(list_adt[[real, MonoList]].car(multi_polylist.mpl1)`2, list_adt[[real, MonoList]].car(multi_polylist.mpl2)`2)) :)" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = number_fields.*(multi_polylist.meval(multi_polylist.mpl1)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.mpl2)(multi_polylist.xvar))}"))) (mpprod_rec_TCC5 0 (mpprod_rec_TCC5-2 "" 3758391262 ("" (termination-tcc) nil nil) ((lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) shostak (mpprod_rec termination "multi_polylist.mpprod_rec(multi_polylist.mpl1, list_adt[[real, MonoList]].cdr(multi_polylist.mpl2))" "nil")) (mpprod_rec_TCC5-1 nil 3603106487 ("" (skeep) (("" (skeep) (("" (expand "meval" + 1) (("" (expand "meval" + 1) (("" (expand "meval") (("" (assert) (("" (typepred "monosum(car[[real, MonoList]](mpl1)`2,
                              car[[real, MonoList]](mpl2)`2)") (("" (hide -1) (("" (rewrite -1) (("" (assert) (("" (hide -1) (("" (expand "meval" +) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_realorder name-judgement "RealOrder" real_orders reals)) nil (mpprod_rec termination "multi_polylist.mpprod_rec(multi_polylist.mpl1, list_adt[[real, MonoList]].cdr(multi_polylist.mpl2))" "nil"))) (mpprod_rec_TCC6 0 (mpprod_rec_TCC6-1 nil 3603106487 ("" (termination-tcc) nil nil) ((lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length def-decl "nat" list_props nil)) nil (mpprod_rec termination "multi_polylist.mpprod_rec(multi_polylist.mpl1, (: list_adt[[real, MonoList]].car(multi_polylist.mpl2) :))" "nil"))) (mpprod_rec_TCC7 0 (mpprod_rec_TCC7-1 nil 3603106487 ("" (skeep) (("" (skeep) (("" (assert) (("" (typepred "mpsum(v(mpl1, cdr[[real, MonoList]](mpl2)),
                    v(mpl1, (: car[[real, MonoList]](mpl2) :)))") (("" (replaces -1) (("" (assert) (("" (expand "+") (("" (assert) (("" (typepred "v(mpl1, cdr[[real, MonoList]](mpl2))") (("" (rewrite -1) (("" (hide -1) (("" (assert) (("" (typepred "v(mpl1, (: car[[real, MonoList]](mpl2) :))") (("" (rewrite -1) (("" (hide -1) (("" (assert) (("" (expand "meval" + 4) (("" (assert) (("" (case "meval(cdr[[real, MonoList]](mpl2))(xvar) +
              meval((: :))(xvar)
              +
               monolist_eval(car[[real, MonoList]](mpl2)`2)(xvar)
               * car[[real, MonoList]](mpl2)`1
              = meval(mpl2)(xvar)") (("1" (assert) nil nil) ("2" (hide 5) (("2" (expand "meval" + 2) (("2" (expand "meval" + 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (mpsum const-decl "{mpl | meval(mpl) = meval(mpl1) + meval(mpl2)}" multi_polylist nil) (+ const-decl "[T -> real]" real_fun_ops reals) (meval def-decl "real" multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (MonoList type-eq-decl nil multi_polylist nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_plus_real_is_real application-judgement "real" reals nil) (monolist_eval const-decl "real" multi_polylist nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (TRUE const-decl "bool" booleans nil) (real_times_real_is_real application-judgement "real" reals nil)) nil (mpprod_rec subtype "multi_polylist.mpsum(multi_polylist.mpprod_rec(multi_polylist.mpl1, list_adt[[real, MonoList]].cdr(multi_polylist.mpl2)), multi_polylist.mpprod_rec(multi_polylist.mpl1, (: list_adt[[real, MonoList]].car(multi_polylist.mpl2) :)))" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = number_fields.*(multi_polylist.meval(multi_polylist.mpl1)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.mpl2)(multi_polylist.xvar))}"))) (mpprod_rec_TCC8 0 (mpprod_rec_TCC8-2 "" 3758391383 ("" (termination-tcc) nil nil) ((lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) shostak (mpprod_rec termination "multi_polylist.mpprod_rec(list_adt[[real, MonoList]].cdr(multi_polylist.mpl1), multi_polylist.mpl2)" "nil")) (mpprod_rec_TCC8-1 nil 3603106487 ("" (skeep) (("" (skeep) (("" (assert) (("" (expand "+") (("" (typepred "mpsum(v(mpl1, cdr[[real, MonoList]](mpl2)),
                  v(mpl1, (: car[[real, MonoList]](mpl2) :)))") (("" (replaces -1) (("" (assert) (("" (expand "+") (("" (assert) (("" (typepred "v(mpl1, cdr[[real, MonoList]](mpl2))") (("" (rewrite -1) (("" (hide -1) (("" (assert) (("" (typepred "v(mpl1, (: car[[real, MonoList]](mpl2) :))") (("" (rewrite -1) (("" (hide -1) (("" (assert) (("" (expand "meval" + 4) (("" (assert) (("" (case "meval(cdr[[real, MonoList]](mpl2))(xvar) +
       meval((: :))(xvar)
       +
        monolist_eval(car[[real, MonoList]](mpl2)`2)(xvar)
        * car[[real, MonoList]](mpl2)`1
       = meval(mpl2)(xvar)") (("1" (assert) nil nil) ("2" (hide 5) (("2" (expand "meval" + 2) (("2" (expand "meval" + 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt_realorder name-judgement "RealOrder" real_orders reals)) nil (mpprod_rec termination "multi_polylist.mpprod_rec(list_adt[[real, MonoList]].cdr(multi_polylist.mpl1), multi_polylist.mpl2)" "nil"))) (mpprod_rec_TCC9 0 (mpprod_rec_TCC9-1 nil 3603106487 ("" (termination-tcc) nil nil) ((lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length def-decl "nat" list_props nil)) nil (mpprod_rec termination "multi_polylist.mpprod_rec((: list_adt[[real, MonoList]].car(multi_polylist.mpl1) :), multi_polylist.mpl2)" "nil"))) (mpprod_rec_TCC10 0 (mpprod_rec_TCC10-2 "" 3758392121 ("" (skeep) (("" (skeep) (("" (assert) (("" (hide 2) (("" (typepred "mpsum(v(cdr[[real, MonoList]](mpl1), mpl2),
                  v((: car[[real, MonoList]](mpl1) :), mpl2))") (("" (replaces -1) (("" (assert) (("" (expand "+") (("" (assert) (("" (typepred "v(cdr[[real, MonoList]](mpl1), mpl2)") (("" (rewrite -1) (("" (hide -1) (("" (typepred "v((: car[[real, MonoList]](mpl1) :), mpl2)") (("" (rewrite -1) (("" (hide -1) (("" (assert) (("" (expand "meval" + 4) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (monolist_eval const-decl "real" multi_polylist nil) (real_plus_real_is_real application-judgement "real" reals nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (MonoList type-eq-decl nil multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (meval def-decl "real" multi_polylist nil) (+ const-decl "[T -> real]" real_fun_ops reals) (mpsum const-decl "{mpl | meval(mpl) = meval(mpl1) + meval(mpl2)}" multi_polylist nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_times_real_is_real application-judgement "real" reals nil)) shostak (mpprod_rec subtype "multi_polylist.mpsum(multi_polylist.mpprod_rec(list_adt[[real, MonoList]].cdr(multi_polylist.mpl1), multi_polylist.mpl2), multi_polylist.mpprod_rec((: list_adt[[real, MonoList]].car(multi_polylist.mpl1) :), multi_polylist.mpl2))" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = number_fields.*(multi_polylist.meval(multi_polylist.mpl1)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.mpl2)(multi_polylist.xvar))}")) (mpprod_rec_TCC10-1 nil 3603106487 ("" (termination-tcc) nil nil) nil nil (mpprod_rec subtype "multi_polylist.mpsum(multi_polylist.mpprod_rec(list_adt[[real, MonoList]].cdr(multi_polylist.mpl1), multi_polylist.mpl2), multi_polylist.mpprod_rec((: list_adt[[real, MonoList]].car(multi_polylist.mpl1) :), multi_polylist.mpl2))" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = number_fields.*(multi_polylist.meval(multi_polylist.mpl1)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.mpl2)(multi_polylist.xvar))}"))) (mpprod_TCC1 0 (mpprod_TCC1-1 nil 3603041774 ("" (skeep) (("" (skeep) (("" (typepred "mp_simp(mpprod_rec(mpl1, mpl2))") (("" (replaces -1 :dir rl) (("" (typepred "mpprod_rec(mpl1, mpl2)") (("" (rewrite -1) nil nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (MonoList type-eq-decl nil multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (meval def-decl "real" multi_polylist nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (mpprod_rec def-decl "{mpl |
   FORALL (xvar: [nat -> real]):
     meval(mpl)(xvar) = meval(mpl1)(xvar) * meval(mpl2)(xvar)}" multi_polylist nil) (mp_simp const-decl "{mulist: MultiPolyList | meval(mpl) = meval(mulist)}" multi_polylist nil)) nil (mpprod subtype "multi_polylist.mp_simp(multi_polylist.mpprod_rec(multi_polylist.mpl1, multi_polylist.mpl2))" "{mpl | FORALL (xvar): multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) = number_fields.*(multi_polylist.meval(multi_polylist.mpl1)(multi_polylist.xvar), multi_polylist.meval(multi_polylist.mpl2)(multi_polylist.xvar))}"))) (mpscal_TCC1 0 (mpscal_TCC1-1 nil 3603108317 ("" (skeep) (("" (expand "length" + 2) (("" (assert) nil nil)) nil)) nil) ((length def-decl "nat" list_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (mpscal termination "multi_polylist.mpscal(multi_polylist.c, list_adt[[real, MonoList]].cdr(multi_polylist.mpl))" "nil"))) (multipolylist_eval_TCC1 0 (multipolylist_eval_TCC1-1 nil 3603453411 ("" (subtype-tcc) nil nil) ((gt_realorder name-judgement "RealOrder" real_orders reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (multipolylist_eval subtype "real_defs.max(list_props[nat].length(multi_polylist.degree(multi_polylist.mpl)), 1)" "posnat"))) (multipolylist_eval 0 (multipolylist_eval-2 "" 3744301232 ("" (skeep) (("" (case "null?(mpl)") (("1" (expand "meval" + 1) (("1" (assert) (("1" (expand "multipoly_to_mpoly" + 4) (("1" (assert) (("1" (case "length(mpl)=0") (("1" (assert) (("1" (expand "multipoly_to_mpoly" + 3) (("1" (expand "multipoly_eval") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "length(mpl)=0") (("1" (hide 2) (("1" (grind) nil nil)) nil) ("2" (rewrite "meval_sigma") (("2" (expand "multipoly_eval" + 1) (("2" (expand "multipoly_to_mpoly" + 1) (("2" (assert) (("2" (rewrite "sigma_eq") (("2" (hide 4) (("2" (skolem 1 "t") (("2" (case "monolist_eval(nth(mpl, t)`2)(xvar) =
                                                                   polyproduct_eval(multipoly_to_mpoly(mpl)`mpoly(t),
                                                                                    multipoly_to_mpoly(mpl)`mdeg,
                                                                                    max(length(degree(mpl)), 1))
                                                                                   (xvar)") (("1" (expand "multipoly_to_mpoly" + 1) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (rewrite "monolist_eval_prod") (("2" (expand "polyproduct_eval") (("2" (expand "multipoly_to_mpoly" + 2) (("2" (case "length(degree(mpl))=0") (("1" (case "degree(mpl) = null") (("1" (replace -1) (("1" (assert) (("1" (expand "max") (("1" (expand "list2array" + 1) (("1" (expand "multipoly_to_mpoly" + 1) (("1" (assert) (("1" (expand "product" + 2) (("1" (expand "product" + 2) (("1" (lemma "degree_zero") (("1" (inst?) (("1" (assert) (("1" (inst - "t") (("1" (assert) (("1" (expand "length" + 1) (("1" (expand "product" +) (("1" (expand "multipoly_to_poly" + 1) (("1" (expand "polynomial") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind :exclude "degree") nil nil)) nil)) nil) ("2" (expand "max") (("2" (assert) (("2" (case "null?(degree(mpl))") (("1" (hide 2) (("1" (grind :exclude "degree") nil nil)) nil) ("2" (invoke (name "AA" "%1") (! 3 1)) (("1" (replaces -1) (("1" (lemma "product_split[nat]") (("1" (inst?) (("1" (expand "AA") (("1" (inst - "length(nth(mpl, t)`2) - 1") (("1" (assert) (("1" (split -1) (("1" (case "FORALL (k:nat): product(length(nth(mpl, t)`2), k,
                                                                               LAMBDA (i: nat):
                                                                                 polynomial(multipoly_to_mpoly(mpl)`mpoly(t)(i),
                                                                                            list2array[nat](0)(degree(mpl))(i))
                                                                                           (xvar(i))) = 1") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1) (("1" (rewrite "product_eq[nat]") (("1" (hide 4) (("1" (skeep) (("1" (expand "multipoly_to_mpoly") (("1" (expand "polynomial") (("1" (lemma "sigma_eq_one_arg") (("1" (inst?) (("1" (inst - "nth(nth(mpl, t)`2, n)") (("1" (assert) (("1" (split -) (("1" (replaces -1) (("1" (expand "multipoly_to_poly") (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (replaces -1) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "list2array_sound[nat]") (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (lift-if) (("2" (ground) (("1" (typepred "degree(mpl)") (("1" (assert) (("1" (hide -1) (("1" (inst - "t") (("1" (flatten) (("1" (assert) (("1" (typepred "max(nth(mpl, t)`2, degree(mpl))") (("1" (inst - "n") (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (typepred "n") (("1" (hide-all-but (-2 -3)) (("1" (grind :exclude "nth") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (typepred "degree(mpl)") (("2" (assert) (("2" (inst - "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (typepred "i!1") (("3" (lift-if) (("3" (assert) (("3" (ground) (("1" (replaces -1) (("1" (expand "multipoly_to_poly") (("1" (lift-if) (("1" (ground) (("1" (typepred "n") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "multipoly_to_poly") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (ground) (("4" (expand "multipoly_to_poly") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (hide -1) (("2" (assert) (("2" (skeep) (("2" (rewrite "product_1[nat]") (("2" (hide 2) (("2" (skeep) (("2" (typepred "n") (("2" (expand "multipoly_to_mpoly") (("2" (expand "multipoly_to_poly") (("2" (expand "polynomial") (("2" (lemma "sigma_eq_one_arg") (("2" (inst?) (("2" (inst - "0") (("2" (assert) (("2" (hide 2) (("2" (skosimp*) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "degree(mpl)") (("2" (hide -1) (("2" (assert) (("2" (inst - "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (assert) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((MultiPolyList type-eq-decl nil multi_polylist nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (MonoList type-eq-decl nil multi_polylist nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nonneg_rat_max application-judgement "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil) (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs nil) (multipoly_eval const-decl "real" multi_polynomial nil) (sigma def-decl "real" sigma reals) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (multipoly_to_mpoly const-decl "MPoly" multi_polylist nil) (meval def-decl "real" multi_polylist nil) (meval_sigma formula-decl nil multi_polylist nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (le_realorder name-judgement "RealOrder" real_orders reals) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (gt_realorder name-judgement "RealOrder" real_orders reals) (sigma_eq formula-decl nil sigma reals) (numfield nonempty-type-eq-decl nil number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (< const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (monolist_eval const-decl "real" multi_polylist nil) (Coeff type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (MultiPolynomial type-eq-decl nil util nil) (posnat nonempty-type-eq-decl nil integers nil) (MPoly type-eq-decl nil MPoly nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (Vars type-eq-decl nil util nil) (polyproduct_eval const-decl "real" multi_polynomial nil) (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (maxnum const-decl "{z: nat | z >= x AND z >= y AND (z = x OR z = y)}" multi_polylist nil) (max def-decl "{ml |
   length[nat](ml) = maxnum(length[nat](ml1), length[nat](ml2)) AND
    FORALL (i: nat):
      i < length(ml) IMPLIES
       nth(ml, i) =
        IF null?(ml1) OR i >= length(ml1) THEN nth(ml2, i)
        ELSIF null?(ml2) OR i >= length(ml2) THEN nth(ml1, i)
        ELSE maxnum(nth(ml1, i), nth(ml2, i))
        ENDIF}" multi_polylist nil) (degree def-decl "{ml |
   (NOT null?(mpl)) IMPLIES
    FORALL (i: below(length(mpl))):
      ml = max(nth(mpl, i)`2, ml) AND length(ml) >= length(nth(mpl, i)`2)}" multi_polylist nil) (<= const-decl "bool" reals nil) (T_high type-eq-decl nil sigma reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T_low type-eq-decl nil sigma reals) (product def-decl "real" product reals) (degree_zero formula-decl nil multi_polylist nil) (polynomial const-decl "[real -> real]" polynomials reals) (multipoly_to_poly const-decl "real" multi_polylist nil) (list2array def-decl "T" array2list structures) (null adt-constructor-decl "(null?)" list_adt nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (product_split formula-decl nil product reals) (AA skolem-const-decl "real" multi_polylist nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (product_eq formula-decl nil product reals) (list2array_sound formula-decl nil array2list structures) (expt def-decl "real" exponentiation nil) (sigma_eq_one_arg formula-decl nil sigma reals) (product_1 formula-decl nil product reals) (sequence type-eq-decl nil sequences nil) (TRUE const-decl "bool" booleans nil) (monolist_eval_prod formula-decl nil multi_polylist nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (subrange type-eq-decl nil integers nil) (real_times_real_is_real application-judgement "real" reals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak) (multipolylist_eval-1 nil 3603454251 ("" (skeep) (("" (case "null?(mpl)") (("1" (expand "meval" + 1) (("1" (assert) (("1" (expand "multipoly_to_mpoly" + 4) (("1" (assert) (("1" (case "length(mpl)=0") (("1" (assert) (("1" (expand "multipoly_to_mpoly" + 3) (("1" (expand "multipoly_eval") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "length(mpl)=0") (("1" (hide 2) (("1" (grind) nil nil)) nil) ("2" (rewrite "meval_sigma") (("2" (expand "multipoly_eval" + 1) (("2" (expand "multipoly_to_mpoly" + 1) (("2" (assert) (("2" (rewrite "sigma_eq") (("2" (hide 4) (("2" (skolem 1 "t") (("2" (case "monolist_eval(nth(mpl, t)`2)(xvar) =
                                                        polyproduct_eval(multipoly_to_mpoly(mpl)`mpoly(t),
                                                                         multipoly_to_mpoly(mpl)`mdeg,
                                                                         max(length(degree(mpl)), 1))
                                                                        (xvar)") (("1" (expand "multipoly_to_mpoly" + 1) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (rewrite "monolist_eval_prod") (("2" (expand "polyproduct_eval") (("2" (expand "multipoly_to_mpoly" + 2) (("2" (case "length(degree(mpl))=0") (("1" (case "degree(mpl) = null") (("1" (replace -1) (("1" (assert) (("1" (expand "max") (("1" (expand "list2array" + 1) (("1" (expand "multipoly_to_mpoly" + 1) (("1" (assert) (("1" (expand "product" + 2) (("1" (expand "product" + 2) (("1" (lemma "degree_zero") (("1" (inst?) (("1" (assert) (("1" (inst - "t") (("1" (assert) (("1" (expand "length" + 1) (("1" (expand "product" +) (("1" (expand "multipoly_to_poly" + 1) (("1" (expand "polynomial") (("1" (expand "sigma") (("1" (expand "sigma") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind :exclude "degree") nil nil)) nil)) nil) ("2" (expand "max") (("2" (assert) (("2" (case "null?(degree(mpl))") (("1" (hide 2) (("1" (grind :exclude "degree") nil nil)) nil) ("2" (invoke (name "AA" "%1") (! 3 1)) (("1" (replaces -1) (("1" (lemma "product_split[nat]") (("1" (inst?) (("1" (expand "AA") (("1" (inst - "length(nth(mpl, t)`2) - 1") (("1" (assert) (("1" (split -1) (("1" (case "FORALL (k:nat): product(length(nth(mpl, t)`2), k,
                                                          LAMBDA (i: nat):
                                                            polynomial(multipoly_to_mpoly(mpl)`mpoly(t)(i),
                                                                       list2array[nat](0)(degree(mpl))(i))
                                                                      (xvar(i))) = 1") (("1" (inst?) (("1" (assert) (("1" (replaces -1) (("1" (assert) (("1" (replaces -1) (("1" (rewrite "product_eq") (("1" (hide 4) (("1" (skeep) (("1" (expand "multipoly_to_mpoly") (("1" (expand "polynomial") (("1" (lemma "sigma_eq_one_arg") (("1" (inst?) (("1" (inst - "nth(nth(mpl, t)`2, n)") (("1" (assert) (("1" (split -) (("1" (replaces -1) (("1" (expand "multipoly_to_poly") (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (replaces -1) (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "list2array_sound[nat]") (("2" (inst?) (("2" (assert) (("2" (replaces -1) (("2" (lift-if) (("2" (ground) (("1" (typepred "degree(mpl)") (("1" (assert) (("1" (hide -1) (("1" (inst - "t") (("1" (flatten) (("1" (assert) (("1" (typepred "max(nth(mpl, t)`2, degree(mpl))") (("1" (inst - "n") (("1" (assert) (("1" (lift-if) (("1" (ground) (("1" (typepred "n") (("1" (hide-all-but (-2 -3)) (("1" (grind :exclude "nth") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (typepred "degree(mpl)") (("2" (assert) (("2" (inst - "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp*) (("3" (typepred "i!1") (("3" (lift-if) (("3" (assert) (("3" (ground) (("1" (replaces -1) (("1" (assert) (("1" (expand "multipoly_to_poly") (("1" (lift-if) (("1" (ground) (("1" (typepred "n") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "multipoly_to_poly") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skosimp*) (("4" (ground) (("4" (expand "multipoly_to_poly") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (hide -1) (("2" (assert) (("2" (skeep) (("2" (rewrite "product_1") (("2" (hide 2) (("2" (skeep) (("2" (typepred "n") (("2" (expand "multipoly_to_mpoly") (("2" (expand "multipoly_to_poly") (("2" (expand "polynomial") (("2" (lemma "sigma_eq_one_arg") (("2" (inst?) (("2" (inst - "0") (("2" (assert) (("2" (hide 2) (("2" (skosimp*) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "degree(mpl)") (("2" (hide -1) (("2" (assert) (("2" (inst - "t") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (assert) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((multipoly_eval const-decl "real" multi_polynomial nil) (sigma def-decl "real" sigma reals) (lt_realorder name-judgement "RealOrder" real_orders reals) (le_realorder name-judgement "RealOrder" real_orders reals) (gt_realorder name-judgement "RealOrder" real_orders reals) (sigma_eq formula-decl nil sigma reals) (Coeff type-eq-decl nil util nil) (DegreeMono type-eq-decl nil util nil) (MultiPolynomial type-eq-decl nil util nil) (MPoly type-eq-decl nil MPoly nil) (Polynomial type-eq-decl nil util nil) (Polyproduct type-eq-decl nil util nil) (Vars type-eq-decl nil util nil) (polyproduct_eval const-decl "real" multi_polynomial nil) (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals) (product def-decl "real" product reals) (polynomial const-decl "[real -> real]" polynomials reals) (list2array def-decl "T" array2list structures) (T_high type-eq-decl nil product reals) (T_low type-eq-decl nil product reals) (product_split formula-decl nil product reals) (product_eq formula-decl nil product reals) (list2array_sound formula-decl nil array2list structures) (sigma_eq_one_arg formula-decl nil sigma reals) (product_1 formula-decl nil product reals) (ge_realorder name-judgement "RealOrder" real_orders reals)) shostak)) (multipolylist_const 0 (multipolylist_const-1 nil 3603035288 ("" (grind) nil nil) ((mpconst const-decl "MultiPolyList" multi_polylist nil) (monolist_eval_rec def-decl "{r: real |
   r =
    c *
     product(0, length(ml) - 1,
             LAMBDA (k: nat):
               IF k < length(ml) THEN xvar(k + i) ^ nth(ml, k)
               ELSE 1
               ENDIF)}" multi_polylist nil) (monolist_eval const-decl "real" multi_polylist nil) (meval def-decl "real" multi_polylist nil)) shostak)) (multipolylist_monom_TCC1 0 (multipolylist_monom_TCC1-1 nil 3603035287 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (multipolylist_monom subtype "multi_polylist.n" "{i_1: integers.int | booleans.OR(multi_polylist.xvar(multi_polylist.i) /= 0, reals.>=(i_1, 0))}"))) (multipolylist_monom 0 (multipolylist_monom-2 "" 3604251987 ("" (induct "i") (("1" (skeep) (("1" (expand "mpmonom") (("1" (expand "meval") (("1" (expand "meval") (("1" (expand "varmono") (("1" (expand "monolist_eval") (("1" (expand "monolist_eval_rec") (("1" (expand "monolist_eval_rec") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep*) (("2" (inst - "c" "n" "LAMBDA(i:nat):xvar(i+1)") (("2" (expand "mpmonom") (("2" (expand "varmono" +) (("2" (expand "meval" +) (("2" (expand "meval" + 1) (("2" (expand "meval" -) (("2" (expand "meval" - 1) (("2" (expand "monolist_eval" +) (("2" (expand "monolist_eval_rec") (("2" (expand "^" + 1) (("2" (expand "expt") (("2" (expand "monolist_eval") (("2" (typepred "monolist_eval_rec(varmono(j, n), 1, 0)(LAMBDA (i: nat): xvar(1 + i))") (("2" (typepred "monolist_eval_rec(varmono(j, n), 1, 1)(xvar)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (le_realorder name-judgement "RealOrder" real_orders reals) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (lt_realorder name-judgement "RealOrder" real_orders reals) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (T_low type-eq-decl nil product reals) (T_high type-eq-decl nil product reals) (product def-decl "real" product reals) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (expt def-decl "real" exponentiation nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (varmono def-decl "MonoList" multi_polylist nil) (monolist_eval_rec def-decl "{r: real |
   r =
    c *
     product(0, length(ml) - 1,
             LAMBDA (k: nat):
               IF k < length(ml) THEN xvar(k + i) ^ nth(ml, k)
               ELSE 1
               ENDIF)}" multi_polylist nil) (real_times_real_is_real application-judgement "real" reals nil) (monolist_eval const-decl "real" multi_polylist nil) (nat_induction formula-decl nil naturalnumbers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (mpmonom const-decl "MultiPolyList" multi_polylist nil) (meval def-decl "real" multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (MonoList type-eq-decl nil multi_polylist nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (multipolylist_var 0 (multipolylist_var-1 nil 3604151425 ("" (skeep) (("" (expand "mpvar") (("" (rewrite "multipolylist_monom") (("" (rewrite "expt_x1") nil nil)) nil)) nil)) nil) ((mpvar const-decl "MultiPolyList" multi_polylist nil) (expt_x1 formula-decl nil exponentiation nil) (real_times_real_is_real application-judgement "real" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (multipolylist_monom formula-decl nil multi_polylist nil)) shostak)) (multipolylist_varn 0 (multipolylist_varn-1 nil 3604151480 ("" (skeep) (("" (expand "mpvarn") (("" (rewrite "multipolylist_monom") (("" (assert) nil nil)) nil)) nil)) nil) ((mpvarn const-decl "MultiPolyList" multi_polylist nil) (real_times_real_is_real application-judgement "real" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (multipolylist_monom formula-decl nil multi_polylist nil)) shostak)) (multipolylist_sum 0 (multipolylist_sum-1 nil 3603108095 ("" (skeep) (("" (typepred "mpsum(mpl1,mpl2)") (("" (assert) (("" (decompose-equality -) (("" (inst - "xvar") (("" (expand "+") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mpsum const-decl "{mpl | meval(mpl) = meval(mpl1) + meval(mpl2)}" multi_polylist nil) (+ const-decl "[T -> real]" real_fun_ops reals) (meval def-decl "real" multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (MonoList type-eq-decl nil multi_polylist nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_plus_real_is_real application-judgement "real" reals nil)) shostak)) (multipolylist_prod 0 (multipolylist_prod-1 nil 3603108126 ("" (skeep) (("" (typepred "mpprod(mpl1,mpl2)") (("" (inst?) nil nil)) nil)) nil) ((mpprod const-decl "{mpl |
   FORALL (xvar: [nat -> real]):
     meval(mpl)(xvar) = meval(mpl1)(xvar) * meval(mpl2)(xvar)}" multi_polylist nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (meval def-decl "real" multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (MonoList type-eq-decl nil multi_polylist nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (multipolylist_scal 0 (multipolylist_scal-1 nil 3603108154 ("" (induct "mpl") (("1" (grind) nil nil) ("2" (skolem 1 ("X" "L")) (("2" (flatten) (("2" (skeep) (("2" (expand "mpscal" +) (("2" (expand "meval" +) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_times_real_is_real application-judgement "real" reals nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (list type-decl nil list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (mpscal def-decl "MultiPolyList" multi_polylist nil) (meval def-decl "real" multi_polylist nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (MultiPolyList type-eq-decl nil multi_polylist nil)) shostak)) (multipolylist_pow_TCC1 0 (multipolylist_pow_TCC1-1 nil 3603099886 ("" (subtype-tcc) nil nil) ((/= const-decl "boolean" notequal nil)) nil (multipolylist_pow subtype "multi_polylist.n" "{i: integers.int | booleans.OR(multi_polylist.meval(multi_polylist.mpl)(multi_polylist.xvar) /= 0, reals.>=(i, 0))}"))) (multipolylist_pow 0 (multipolylist_pow-1 nil 3603108377 ("" (induct "n") (("1" (skeep) (("1" (grind) nil nil)) nil) ("2" (skolem 1 "n") (("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (expand "mppow" +) (("2" (lift-if) (("2" (assert) (("2" (ground) (("1" (replaces -1) (("1" (assert) (("1" (expand "^" +) (("1" (expand "expt" +) (("1" (expand "expt" +) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "mpprod(mpl, mppow(mpl, n))") (("2" (rewrite -1) (("2" (hide -1) (("2" (inst?) (("2" (replaces -1) (("2" (expand "^") (("2" (expand "expt" + 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (mpprod const-decl "{mpl |
   FORALL (xvar: [nat -> real]):
     meval(mpl)(xvar) = meval(mpl1)(xvar) * meval(mpl2)(xvar)}" multi_polylist nil) (TRUE const-decl "bool" booleans nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (ge_realorder name-judgement "RealOrder" real_orders reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (expt def-decl "real" exponentiation nil) (monolist_eval const-decl "real" multi_polylist nil) (monolist_eval_rec def-decl "{r: real |
   r =
    c *
     product(0, length(ml) - 1,
             LAMBDA (k: nat):
               IF k < length(ml) THEN xvar(k + i) ^ nth(ml, k)
               ELSE 1
               ENDIF)}" multi_polylist nil) (nat_induction formula-decl nil naturalnumbers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (mppow def-decl "MultiPolyList" multi_polylist nil) (meval def-decl "real" multi_polylist nil) (= const-decl "[T, T -> boolean]" equalities nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (MonoList type-eq-decl nil multi_polylist nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (multipolylist_neg 0 (multipolylist_neg-1 nil 3603108449 ("" (skeep) (("" (expand "mpneg") (("" (rewrite "multipolylist_scal") (("" (assert) nil nil)) nil)) nil)) nil) ((mpneg const-decl "MultiPolyList" multi_polylist nil) (minus_real_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (MonoList type-eq-decl nil multi_polylist nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (multipolylist_scal formula-decl nil multi_polylist nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) shostak)) (multipolylist_minus 0 (multipolylist_minus-1 nil 3604150775 ("" (skeep) (("" (expand "mpminus") (("" (lemma "multipolylist_sum") (("" (inst?) (("" (replaces -1) (("" (lemma "multipolylist_neg") (("" (expand "mpneg") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((mpminus const-decl "MultiPolyList" multi_polylist nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (list type-decl nil list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (mpscal def-decl "MultiPolyList" multi_polylist nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (multipolylist_neg formula-decl nil multi_polylist nil) (minus_real_is_real application-judgement "real" reals nil) (real_plus_real_is_real application-judgement "real" reals nil) (real_minus_real_is_real application-judgement "real" reals nil) (mpneg const-decl "MultiPolyList" multi_polylist nil) (TRUE const-decl "bool" booleans nil) (multipolylist_sum formula-decl nil multi_polylist nil)) shostak)) (multipolylist_div 0 (multipolylist_div-1 nil 3603108470 ("" (skeep) (("" (expand "mpdiv") (("" (rewrite "multipolylist_scal") (("" (assert) nil nil)) nil)) nil)) nil) ((mpdiv const-decl "MultiPolyList" multi_polylist nil) (real_div_nzreal_is_real application-judgement "real" reals nil) (real_times_real_is_real application-judgement "real" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (MonoList type-eq-decl nil multi_polylist nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (list type-decl nil list_adt nil) (nzreal nonempty-type-eq-decl nil reals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (multipolylist_scal formula-decl nil multi_polylist nil) (nzreal_div_nzreal_is_nzreal application-judgement "nzreal" real_types nil)) shostak)) (multipolylist_sq 0 (multipolylist_sq-1 nil 3603108525 ("" (skeep) (("" (rewrite "multipolylist_prod") (("" (expand "sq") (("" (propax) nil nil)) nil)) nil)) nil) ((multipolylist_prod formula-decl nil multi_polylist nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (list type-decl nil list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (MonoList type-eq-decl nil multi_polylist nil) (MultiPolyList type-eq-decl nil multi_polylist nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_times_real_is_real application-judgement "real" reals nil) (sq const-decl "nonneg_real" sq reals)) shostak)))
