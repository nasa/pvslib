(ccg_to_mwg (indi_f_sound_all_vertex_TCC1 0 (indi_f_sound_all_vertex_TCC1-1 nil 3681485477 ("" (skeep) (("" (typepred "l") (("" (skeep) (("" (expand "vert?") (("" (expand "digraph_verts") (("" (expand "vert") (("" (inst -1 0) (("1" (expand "nth") (("1" (assert) nil nil)) nil) ("2" (hide -1 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (CCG type-eq-decl nil ccg_def nil) (FunMeasures type-eq-decl nil ccg_def nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (vert const-decl "bool" c_digraphs_def digraphs) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (l skolem-const-decl "{l: list[CallingContext[Val, Expr, Condition, NodeId]] |
   FORALL (i: below(length(l))):
     vert?(G`dg)(nth[CallingContext[Val, Expr, Condition, NodeId]](l, i))}" ccg_to_mwg nil) (G skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (indi_f_sound_all_vertex subtype "ccg_to_mwg.c" "vert[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](dg(ccg_to_mwg.G))"))) (indi_f_sound_all_vertex_TCC2 0 (indi_f_sound_all_vertex_TCC2-1 nil 3681485477 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (CallingContext type-eq-decl nil cc_def nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (get const-decl "Sign3" measures nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (PRED type-eq-decl nil defined_types nil) (gt const-decl "bool" ccg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_all_vertex subtype "ccg_to_mwg.l" "(list_adt[CallingContext[Val, Expr, Condition, NodeId]].cons?)"))) (indi_f_sound_all_vertex_TCC3 0 (indi_f_sound_all_vertex_TCC3-1 nil 3681485477 ("" (skeep) (("" (skeep) (("" (skeep) (("" (expand "vert?") (("" (expand "digraph_verts") (("" (typepred "l") (("" (expand "vert?") (("" (expand "digraph_verts") (("" (expand "vert") (("" (inst -1 "i!1 + 1") (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil) ("2" (hide-all-but (-1 1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vert? const-decl "bool" digraphs_ digraphs) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (CCG type-eq-decl nil ccg_def nil) (FunMeasures type-eq-decl nil ccg_def nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (i!1 skolem-const-decl "below(length(cdr(l)))" ccg_to_mwg nil) (l skolem-const-decl "{l: list[CallingContext[Val, Expr, Condition, NodeId]] |
   FORALL (i: below(length(l))):
     vert?(G`dg)(nth[CallingContext[Val, Expr, Condition, NodeId]](l, i))}" ccg_to_mwg nil) (G skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs)) nil (indi_f_sound_all_vertex subtype "list_adt[CallingContext[Val, Expr, Condition, NodeId]].cdr(ccg_to_mwg.l)" "{l: list_adt[CallingContext[Val, Expr, Condition, NodeId]].list | FORALL (i: naturalnumbers.below(list_props[CallingContext[Val, Expr, Condition, NodeId]].length(l))): digraphs_[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make].vert?(ccg_to_mwg.G`dg)(list_props[CallingContext[Val, Expr, Condition, NodeId]].nth(l, i))}"))) (indi_f_sound_all_vertex_TCC4 0 (indi_f_sound_all_vertex_TCC4-1 nil 3681485477 ("" (skeep) (("" (skeep) (("" (hide -) (("" (grind) nil nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil (indi_f_sound_all_vertex termination "ccg_to_mwg.indi_f_sound_all_vertex(ccg_to_mwg.G)(ccg_to_mwg.f, ccg_to_mwg.i, ccg_to_mwg.j, list_adt[CallingContext[Val, Expr, Condition, NodeId]].cdr(ccg_to_mwg.l))" "nil"))) (indi_f_sound_all_vertex_TCC5 0 (indi_f_sound_all_vertex_TCC5-1 nil 3681558704 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (below type-eq-decl nil naturalnumbers nil) (Expr formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (CallingContext type-eq-decl nil cc_def nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (MT formal-type-decl nil ccg_to_mwg nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_all_vertex subtype "ccg_to_mwg.l" "(list_adt[CallingContext[Val, Expr, Condition, NodeId]].cons?)"))) (indi_f_sound_all_vertex_correctness 0 (indi_f_sound_all_vertex_correctness-2 nil 3770211201 ("" (skolem 1 ("G" "f" "i" "j" "_")) (("" (measure-induct+ "length(l)" "l") (("" (iff) (("" (split 1) (("1" (flatten) (("1" (expand "indi_f_sound_all_vertex" 1) (("1" (prop) (("1" (inst -2 "car(x!1)") (("1" (inst -3 "cdr(x!1)") (("1" (flatten) (("1" (expand "length" -4 2) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (skeep) (("2" (typepred "x!1") (("2" (inst -1 "i!1 + 1") (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (typepred "i!1") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide -3) (("2" (inst -2 "car(x!1)") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide -1 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (inst -2 "cdr(x!1)") (("3" (expand "length" -2 2) (("3" (assert) (("3" (skeep) (("3" (case "car(x!1) = c") (("1" (inst -2 "c") (("1" (hide 2 4) (("1" (grind) nil nil)) nil)) nil) ("2" (inst -1 "c") (("2" (hide 3 5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "indi_f_sound_all_vertex" -1) (("2" (split -1) (("1" (hide -2) (("1" (skeep) (("1" (typepred "c") (("1" (hide-all-but (-2 -3)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (inst -4 "cdr(x!1)") (("2" (expand "length" -4 2) (("2" (assert) (("2" (case "car(x!1) = c") (("1" (hide -5) (("1" (replaces -1) (("1" (split 2) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (inst -4 "c") (("2" (hide-all-but (1 2 3)) (("2" (typepred "c") (("2" (hide -1) (("2" (expand "member" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((measure_induction formula-decl nil measure_induction nil) (Expr formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (CallingContext type-eq-decl nil cc_def nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (MT formal-type-decl nil ccg_to_mwg nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (wf_nat formula-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (vert type-eq-decl nil digraphs_ digraphs) (member def-decl "bool" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (Sign3 type-eq-decl nil sign3 reals) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (get const-decl "Sign3" measures nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (FunMeasure type-eq-decl nil ccg_def nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (FALSE const-decl "bool" booleans nil) (TRUE const-decl "bool" booleans nil) (indi_f_sound_all_vertex def-decl "bool" ccg_to_mwg nil) (c skolem-const-decl "{c: vert(dg(G)) | member(c, cdr(x!1))}" ccg_to_mwg nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (G skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (x!1 skolem-const-decl "{l: list[CallingContext[Val, Expr, Condition, NodeId]] |
   FORALL (i: below(length(l))): vert?(G`dg)(nth(l, i))}" ccg_to_mwg nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (i!1 skolem-const-decl "below(length(cdr(x!1)))" ccg_to_mwg nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (c skolem-const-decl "{c: vert(dg(G)) | member(c, x!1)}" ccg_to_mwg nil)) nil) (indi_f_sound_all_vertex_correctness-1 nil 3681586736 ("" (skolem 1 ("G" "f" "i" "j" "_")) (("" (measure-induct+ "length(l)" "l") (("" (iff) (("" (split 1) (("1" (flatten) (("1" (expand "indi_f_sound_all_vertex" 1) (("1" (prop) (("1" (inst -2 "car(x!1)") (("1" (inst -3 "cdr(x!1)") (("1" (flatten) (("1" (expand "length" -4 2) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (skeep) (("2" (typepred "x!1") (("2" (inst -1 "i_1 + 1") (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (typepred "i_1") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (grind) nil nil)) nil)) nil) ("2" (hide -3) (("2" (inst -2 "car(x!1)") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide -1 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (inst -2 "cdr(x!1)") (("3" (expand "length" -2 2) (("3" (assert) (("3" (skeep) (("3" (case "car(x!1) = c") (("1" (inst -2 "c") (("1" (hide 2 4) (("1" (grind) nil nil)) nil)) nil) ("2" (inst -1 "c") (("2" (hide 3 5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "indi_f_sound_all_vertex" -1) (("2" (split -1) (("1" (hide -2) (("1" (skeep) (("1" (typepred "c") (("1" (hide-all-but (-2 -3)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (inst -4 "cdr(x!1)") (("2" (expand "length" -4 2) (("2" (assert) (("2" (case "car(x!1) = c") (("1" (hide -5) (("1" (replaces -1) (("1" (split 2) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (inst -4 "c") (("2" (hide-all-but (1 2 3)) (("2" (typepred "c") (("2" (hide -1) (("2" (expand "member" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((CallingContext type-eq-decl nil cc_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (vert type-eq-decl nil digraphs_ digraphs) (Sign3 type-eq-decl nil sign3 reals) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (get const-decl "Sign3" measures nil) (FunMeasure type-eq-decl nil ccg_def nil) (gt const-decl "bool" ccg nil)) shostak)) (indi_f_sound_iter_TCC1 0 (indi_f_sound_iter_TCC1-1 nil 3681485477 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_iter subtype "(number_fields.-)(ccg_to_mwg.N, ccg_to_mwg.i)" "nat"))) (indi_f_sound_iter_TCC2 0 (indi_f_sound_iter_TCC2-1 nil 3681485477 ("" (subtype-tcc) nil nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_iter subtype "(number_fields.-)(ccg_to_mwg.N, ccg_to_mwg.z`2)" "nat"))) (indi_f_sound_iter_TCC3 0 (indi_f_sound_iter_TCC3-1 nil 3681485477 ("" (skeep) (("" (typepred "N" "z`3") (("" (grind) nil nil)) nil)) nil) ((upto nonempty-type-eq-decl nil naturalnumbers nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert type-eq-decl nil digraphs_ digraphs) (CCG type-eq-decl nil ccg_def nil) (FunMeasures type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (<= const-decl "bool" reals nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_iter subtype "(number_fields.-)(ccg_to_mwg.N, ccg_to_mwg.z`3)" "nat"))) (indi_f_sound_iter_TCC4 0 (indi_f_sound_iter_TCC4-1 nil 3681485477 ("" (subtype-tcc) nil nil) nil nil (indi_f_sound_iter subtype "(number_fields.-)(ccg_to_mwg.N, ccg_to_mwg.i)" "nat"))) (indi_f_sound_iter_TCC5 0 (indi_f_sound_iter_TCC5-1 nil 3681485477 ("" (subtype-tcc) nil nil) ((upto nonempty-type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (CallingContext type-eq-decl nil cc_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (vert type-eq-decl nil digraphs_ digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (get const-decl "Sign3" measures nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (PRED type-eq-decl nil defined_types nil) (gt const-decl "bool" ccg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_iter subtype "booleans.TRUE" "{b: booleans.bool | (FORALL (i_: naturalnumbers.below(ccg_to_mwg.N), j_: naturalnumbers.below(ccg_to_mwg.N)): booleans.IMPLIES(booleans.OR(reals.>(i_, ccg_to_mwg.i), (booleans.AND(i_ = ccg_to_mwg.i, reals.>=(j_, ccg_to_mwg.j)))), FORALL (c: digraphs_[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make].vert(dg(ccg_to_mwg.G))): booleans.AND((booleans.IMPLIES(measures[ccg_to_mwg.N].get(ccg_to_mwg.f(c))(i_, j_) = 1, ccg[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId, ccg_to_mwg.MT, ccg_to_mwg.lt, ccg_to_mwg.N, ccg_to_mwg.semantic_rel, ccg_to_mwg.eval_conds].gt(ms(ccg_to_mwg.G), c, i_, j_, booleans.FALSE))), (booleans.IMPLIES(measures[ccg_to_mwg.N].get(ccg_to_mwg.f(c))(i_, j_) = 0, ccg[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId, ccg_to_mwg.MT, ccg_to_mwg.lt, ccg_to_mwg.N, ccg_to_mwg.semantic_rel, ccg_to_mwg.eval_conds].gt(ms(ccg_to_mwg.G), c, i_, j_, booleans.TRUE)))))) = b}"))) (indi_f_sound_iter_TCC6 0 (indi_f_sound_iter_TCC6-1 nil 3681485477 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_iter subtype "(number_fields.+)(ccg_to_mwg.i, 1)" "upto(ccg_to_mwg.N)"))) (indi_f_sound_iter_TCC7 0 (indi_f_sound_iter_TCC7-1 nil 3681485477 ("" (termination-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_iter subtype "0" "upto(ccg_to_mwg.N)"))) (indi_f_sound_iter_TCC8 0 (indi_f_sound_iter_TCC8-1 nil 3681553773 ("" (skeep) (("" (assert) (("" (grind) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< def-decl "bool" ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (indi_f_sound_iter termination "ccg_to_mwg.indi_f_sound_iter(ccg_to_mwg.G)(ccg_to_mwg.f, (number_fields.+)(ccg_to_mwg.i, 1), 0)" "nil"))) (indi_f_sound_iter_TCC9 0 (indi_f_sound_iter_TCC9-1 nil 3681553773 ("" (skeep*) (("" (typepred " v(G)(f, i + 1, 0)") (("1" (replaces -1 :dir rl) (("1" (iff) (("1" (split 2) (("1" (flatten) (("1" (skeep) (("1" (inst -1 "i_" "j_") (("1" (assert) (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (split) (("1" (skeep) (("1" (inst -2 "i_" "j_") (("1" (assert) (("1" (split -2) (("1" (inst -1 "c") nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -3 "i_" "j_") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (grind) nil nil)) nil)) nil)) nil) ((- const-decl "[numfield, numfield -> numfield]" number_fields nil) (lex2 const-decl "ordinal" lex2 nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (ordinal? def-decl "bool" ordinals nil) (< def-decl "bool" ordinals nil) (ordstruct type-decl nil ordstruct_adt nil) (FALSE const-decl "bool" booleans nil) (gt const-decl "bool" ccg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (FunMeasure type-eq-decl nil ccg_def nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (get const-decl "Sign3" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (vert type-eq-decl nil digraphs_ digraphs) (CCG type-eq-decl nil ccg_def nil) (FunMeasures type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_iter subtype "ccg_to_mwg.indi_f_sound_iter(ccg_to_mwg.G)(ccg_to_mwg.f, (number_fields.+)(ccg_to_mwg.i, 1), 0)" "{b: booleans.bool | (FORALL (i_: naturalnumbers.below(ccg_to_mwg.N), j_: naturalnumbers.below(ccg_to_mwg.N)): booleans.IMPLIES(booleans.OR(reals.>(i_, ccg_to_mwg.i), (booleans.AND(i_ = ccg_to_mwg.i, reals.>=(j_, ccg_to_mwg.j)))), FORALL (c: digraphs_[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make].vert(dg(ccg_to_mwg.G))): booleans.AND((booleans.IMPLIES(measures[ccg_to_mwg.N].get(ccg_to_mwg.f(c))(i_, j_) = 1, ccg[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId, ccg_to_mwg.MT, ccg_to_mwg.lt, ccg_to_mwg.N, ccg_to_mwg.semantic_rel, ccg_to_mwg.eval_conds].gt(ms(ccg_to_mwg.G), c, i_, j_, booleans.FALSE))), (booleans.IMPLIES(measures[ccg_to_mwg.N].get(ccg_to_mwg.f(c))(i_, j_) = 0, ccg[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId, ccg_to_mwg.MT, ccg_to_mwg.lt, ccg_to_mwg.N, ccg_to_mwg.semantic_rel, ccg_to_mwg.eval_conds].gt(ms(ccg_to_mwg.G), c, i_, j_, booleans.TRUE)))))) = b}"))) (indi_f_sound_iter_TCC10 0 (indi_f_sound_iter_TCC10-1 nil 3681553773 ("" (skeep) (("" (grind) nil nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (indi_f_sound_iter subtype "ccg_to_mwg.i" "below(ccg_to_mwg.N)"))) (indi_f_sound_iter_TCC11 0 (indi_f_sound_iter_TCC11-1 nil 3681553773 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_iter subtype "ccg_to_mwg.j" "below(ccg_to_mwg.N)"))) (indi_f_sound_iter_TCC12 0 (indi_f_sound_iter_TCC12-2 "" 3804717868 ("" (skeep :preds? t) (("" (skeep :preds? t) (("" (expand "vert?") (("" (expand "digraph_verts") (("" (expand "vert") (("" (case "FORALL(l:list,i:below(length(l))): member(nth(l,i),l)") (("1" (inst?) nil nil) ("2" (hide-all-but 1) (("2" (measure-induct "length(l)" "l") (("2" (skeep) (("2" (skeep) (("2" (case "null?(x)") (("1" (hide -2) (("1" (typepred "i!2") (("1" (hide 1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "member" +) (("2" (lift-if) (("2" (assert) (("2" (flatten) (("2" (inst -1 "cdr(x)") (("2" (assert) (("2" (expand "length" -1 2) (("2" (expand "nth" 3) (("2" (assert) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (replace -1) (("1" (expand "nth" 3) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (MT formal-type-decl nil ccg_to_mwg nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (wf_nat formula-decl nil naturalnumbers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (x skolem-const-decl "list[CallingContext[Val, Expr, Condition, NodeId]]" ccg_to_mwg nil) (i!2 skolem-const-decl "below(length(x))" ccg_to_mwg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (vert const-decl "bool" c_digraphs_def digraphs) (vert? const-decl "bool" digraphs_ digraphs)) shostak (indi_f_sound_iter subtype "ccg_to_mwg.G`dg`data" "{l: list_adt[CallingContext[Val, Expr, Condition, NodeId]].list | FORALL (i: naturalnumbers.below(list_props[CallingContext[Val, Expr, Condition, NodeId]].length(l))): digraphs_[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make].vert?(ccg_to_mwg.G`dg)(list_props[CallingContext[Val, Expr, Condition, NodeId]].nth(l, i))}")) (indi_f_sound_iter_TCC12-1 nil 3681558704 ("" (skeep) (("" (typepred "i") (("" (split 1) (("1" (assert) nil nil) ("2" (typepred "j") (("2" (skeep) (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (expand "vert") (("2" (typepred "i!1") (("2" (case "FORALL(l:list,i:below(length(l))): member(nth(l,i),l)") (("1" (inst?) nil nil) ("2" (hide-all-but 1) (("2" (measure-induct "length(l)" "l") (("2" (skeep) (("2" (skeep) (("2" (case "null?(x)") (("1" (hide -2) (("1" (typepred "i!2") (("1" (hide 1) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (lift-if) (("2" (prop) (("1" (expand "member" 1) (("1" (lift-if) (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil) ("2" (inst -1 "cdr(x)") (("2" (expand "length" -1 2) (("2" (assert) (("2" (inst -1 "i!2 - 1") (("2" (expand "member" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (CallingContext type-eq-decl nil cc_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (vert const-decl "bool" c_digraphs_def digraphs) (vert? const-decl "bool" digraphs_ digraphs)) nil (indi_f_sound_iter subtype "ccg_to_mwg.G`dg`data" "{l: list_adt[CallingContext[Val, Expr, Condition, NodeId]].list | FORALL (i: naturalnumbers.below(list_props[CallingContext[Val, Expr, Condition, NodeId]].length(l))): digraphs_[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make].vert?(ccg_to_mwg.G`dg)(list_props[CallingContext[Val, Expr, Condition, NodeId]].nth(l, i))}"))) (indi_f_sound_iter_TCC13 0 (indi_f_sound_iter_TCC13-1 nil 3681574052 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_iter subtype "(number_fields.+)(ccg_to_mwg.j, 1)" "upto(ccg_to_mwg.N)"))) (indi_f_sound_iter_TCC14 0 (indi_f_sound_iter_TCC14-1 nil 3681574052 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< def-decl "bool" ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_iter termination "ccg_to_mwg.indi_f_sound_iter(ccg_to_mwg.G)(ccg_to_mwg.f, ccg_to_mwg.i, (number_fields.+)(ccg_to_mwg.j, 1))" "nil"))) (indi_f_sound_iter_TCC15 0 (indi_f_sound_iter_TCC15-2 nil 3681579865 ("" (skeep*) (("" (iff) (("" (split 3) (("1" (flatten) (("1" (split 1) (("1" (use "indi_f_sound_all_vertex_correctness") (("1" (replace -1 :hide? t :dir rl) (("1" (inst -1 "i" "j") (("1" (assert) (("1" (skeep) (("1" (inst -1 "c") nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (invoke (typepred "%1") (! 1)) (("1" (replace -1 :hide? t :dir rl) (("1" (skeep) (("1" (invoke (case "%1") (! -1 1)) (("1" (assert) (("1" (hide -2) (("1" (inst -2 "i_" "j_") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (flatten) (("2" (replace -1) (("2" (inst -3 "i_" "j_") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (case "i_ = i AND j_ = j") (("1" (flatten) (("1" (use "indi_f_sound_all_vertex_correctness") (("1" (replace -1 :hide? t :dir rl) (("1" (skeep) (("1" (inst -3 "c") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (split 1) (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)) nil) ("2" (replace -1 :hide? t) (("2" (replace -1 :hide? t) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "c") (("2" (hide-all-but (-1 1)) (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (expand "vert") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "v(G)(f, i, j+1)") (("1" (replace -1 :hide? t :dir rl) (("1" (inst -2 "i_" "j_") (("1" (split -2) (("1" (propax) nil nil) ("2" (grind-reals) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vert const-decl "bool" c_digraphs_def digraphs) (c skolem-const-decl "vert[CallingContext[Val, Expr, Condition, NodeId],
     digraph_type[CallingContext[Val, Expr, Condition, NodeId]],
     digraph_verts, digraph_edges, digraph_size, digraph_make](dg(G))" ccg_to_mwg nil) (G skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (get const-decl "Sign3" measures nil) (FunMeasure type-eq-decl nil ccg_def nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (FALSE const-decl "bool" booleans nil) (ordstruct type-decl nil ordstruct_adt nil) (< def-decl "bool" ordinals nil) (ordinal? def-decl "bool" ordinals nil) (ordinal nonempty-type-eq-decl nil ordinals nil) (lex2 const-decl "ordinal" lex2 nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (indi_f_sound_all_vertex_correctness formula-decl nil ccg_to_mwg nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CCG type-eq-decl nil ccg_def nil) (FunMeasures type-eq-decl nil ccg_def nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (i skolem-const-decl "upto(N)" ccg_to_mwg nil) (j skolem-const-decl "upto(N)" ccg_to_mwg nil) (member def-decl "bool" list_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_iter subtype "booleans.AND(ccg_to_mwg.indi_f_sound_all_vertex(ccg_to_mwg.G)(ccg_to_mwg.f, ccg_to_mwg.i, ccg_to_mwg.j, ccg_to_mwg.G`dg`data), ccg_to_mwg.indi_f_sound_iter(ccg_to_mwg.G)(ccg_to_mwg.f, ccg_to_mwg.i, (number_fields.+)(ccg_to_mwg.j, 1)))" "{b: booleans.bool | (FORALL (i_: naturalnumbers.below(ccg_to_mwg.N), j_: naturalnumbers.below(ccg_to_mwg.N)): booleans.IMPLIES(booleans.OR(reals.>(i_, ccg_to_mwg.i), (booleans.AND(i_ = ccg_to_mwg.i, reals.>=(j_, ccg_to_mwg.j)))), FORALL (c: digraphs_[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make].vert(dg(ccg_to_mwg.G))): booleans.AND((booleans.IMPLIES(measures[ccg_to_mwg.N].get(ccg_to_mwg.f(c))(i_, j_) = 1, ccg[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId, ccg_to_mwg.MT, ccg_to_mwg.lt, ccg_to_mwg.N, ccg_to_mwg.semantic_rel, ccg_to_mwg.eval_conds].gt(ms(ccg_to_mwg.G), c, i_, j_, booleans.FALSE))), (booleans.IMPLIES(measures[ccg_to_mwg.N].get(ccg_to_mwg.f(c))(i_, j_) = 0, ccg[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId, ccg_to_mwg.MT, ccg_to_mwg.lt, ccg_to_mwg.N, ccg_to_mwg.semantic_rel, ccg_to_mwg.eval_conds].gt(ms(ccg_to_mwg.G), c, i_, j_, booleans.TRUE)))))) = b}")) (indi_f_sound_iter_TCC15-1 nil 3681574052 ("" (skeep*) (("" (iff) (("" (split 3) (("1" (flatten) (("1" (split 1) (("1" (use "indi_f_sound_all_vertex_correctness") (("1" (replace -1 :hide? t :dir rl) (("1" (inst -1 "i" "j") (("1" (assert) (("1" (skeep) (("1" (inst -1 "c") nil nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) nil nil (indi_f_sound_iter subtype "booleans.AND(ccg_to_mwg.indi_f_sound_all_vertex(ccg_to_mwg.G)(ccg_to_mwg.f, ccg_to_mwg.i, ccg_to_mwg.j, ccg_to_mwg.G`dg`data), ccg_to_mwg.indi_f_sound_iter(ccg_to_mwg.G)(ccg_to_mwg.f, ccg_to_mwg.i, (number_fields.+)(ccg_to_mwg.j, 1)))" "{b: booleans.bool | (FORALL (i_: naturalnumbers.below(ccg_to_mwg.N), j_: naturalnumbers.below(ccg_to_mwg.N)): booleans.IMPLIES(booleans.OR(reals.>(i_, ccg_to_mwg.i), (booleans.AND(i_ = ccg_to_mwg.i, reals.>=(j_, ccg_to_mwg.j)))), FORALL (c: digraphs_[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make].vert(dg(ccg_to_mwg.G))): booleans.AND((booleans.IMPLIES(measures[ccg_to_mwg.N].get(ccg_to_mwg.f(c))(i_, j_) = 1, ccg[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId, ccg_to_mwg.MT, ccg_to_mwg.lt, ccg_to_mwg.N, ccg_to_mwg.semantic_rel, ccg_to_mwg.eval_conds].gt(ms(ccg_to_mwg.G), c, i_, j_, booleans.FALSE))), (booleans.IMPLIES(measures[ccg_to_mwg.N].get(ccg_to_mwg.f(c))(i_, j_) = 0, ccg[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId, ccg_to_mwg.MT, ccg_to_mwg.lt, ccg_to_mwg.N, ccg_to_mwg.semantic_rel, ccg_to_mwg.eval_conds].gt(ms(ccg_to_mwg.G), c, i_, j_, booleans.TRUE)))))) = b}"))) (indi_f_sound_iter_correctness_TCC1 0 (indi_f_sound_iter_correctness_TCC1-1 nil 3681573188 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_iter_correctness subtype "ccg_to_mwg.m" "upto(ccg_to_mwg.N)"))) (indi_f_sound_iter_correctness_TCC2 0 (indi_f_sound_iter_correctness_TCC2-1 nil 3681573188 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_sound_iter_correctness subtype "ccg_to_mwg.n" "upto(ccg_to_mwg.N)"))) (indi_f_sound_iter_correctness 0 (indi_f_sound_iter_correctness-1 nil 3681578746 ("" (skeep*) (("" (typepred "indi_f_sound_iter(G)(f, m, n)") (("" (propax) nil nil)) nil)) nil) ((indi_f_sound_iter def-decl "{b: bool |
   (FORALL (i_: below(N), j_: below(N)):
      i_ > i OR (i_ = i AND j_ >= j) IMPLIES
       FORALL (c: vert(dg(G))):
         (get(f(c))(i_, j_) = 1 IMPLIES gt(ms(G), c, i_, j_, FALSE)) AND
          (get(f(c))(i_, j_) = 0 IMPLIES gt(ms(G), c, i_, j_, TRUE)))
    = b}" ccg_to_mwg nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (FALSE const-decl "bool" booleans nil) (gt const-decl "bool" ccg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (FunMeasure type-eq-decl nil ccg_def nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (get const-decl "Sign3" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (vert type-eq-decl nil digraphs_ digraphs) (CCG type-eq-decl nil ccg_def nil) (FunMeasures type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak)) (indi_f_equiv_TCC1 0 (indi_f_equiv_TCC1-1 nil 3681485477 ("" (subtype-tcc) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_f_equiv subtype "0" "upto(ccg_to_mwg.N)"))) (indi_f_equiv 0 (indi_f_equiv-1 nil 3681563909 ("" (skeep) (("" (use "indi_f_sound_iter_correctness") (("1" (expand "indi_f_sound") (("1" (replace -1 :hide? t :dir rl) (("1" (iff) (("1" (split 1) (("1" (flatten) (("1" (skeep) (("1" (inst?) (("1" (skeep) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep*) (("2" (inst -1 "i" "j") (("2" (split -1) (("1" (inst?) nil nil) ("2" (assert) (("2" (typepred "i") (("2" (assert) (("2" (grind-reals) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ((indi_f_sound_iter_correctness formula-decl nil ccg_to_mwg nil) (below type-eq-decl nil naturalnumbers nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CCG type-eq-decl nil ccg_def nil) (FunMeasures type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (indi_f_sound const-decl "bool" ccg_to_mwg nil)) shostak)) (indi_f_sc_is_sound 0 (indi_f_sc_is_sound-2 "" 3790335086 ("" (tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (CCG type-eq-decl nil ccg_def nil) (CallingContext type-eq-decl nil cc_def nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (vert type-eq-decl nil digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (indi_f_sc const-decl "bool" ccg_to_mwg nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (indi_f_complete const-decl "bool" ccg_to_mwg nil) (vert const-decl "bool" c_digraphs_def digraphs) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (get const-decl "Sign3" measures nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (PRED type-eq-decl nil defined_types nil) (gt const-decl "bool" ccg nil) (indi_f_sound const-decl "bool" ccg_to_mwg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (indi_f_sc_is_sound subtype "ccg_to_mwg.x" "(ccg_to_mwg.indi_f_sound(ccg_to_mwg.G))")) (indi_f_sc_is_sound-1 nil 3651508167 ("" (tcc)) ((CCG type-eq-decl nil ccg_def nil) (CallingContext type-eq-decl nil cc_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (vert type-eq-decl nil digraphs_ digraphs) (Sign3 type-eq-decl nil sign3 reals) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (vert const-decl "bool" c_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (gt const-decl "bool" ccg nil)) nil (indi_f_sc_is_sound subtype "ccg_to_mwg.x" "(ccg_to_mwg.indi_f_sound(ccg_to_mwg.G))"))) (indi_f_sc_is_complete 0 (indi_f_sc_is_complete-2 "" 3790335088 ("" (tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (CCG type-eq-decl nil ccg_def nil) (CallingContext type-eq-decl nil cc_def nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (vert type-eq-decl nil digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (indi_f_sc const-decl "bool" ccg_to_mwg nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (indi_f_sound const-decl "bool" ccg_to_mwg nil) (vert const-decl "bool" c_digraphs_def digraphs) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (MT formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (PRED type-eq-decl nil defined_types nil) (gt const-decl "bool" ccg nil) (get const-decl "Sign3" measures nil) (indi_f_complete const-decl "bool" ccg_to_mwg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (indi_f_sc_is_complete subtype "ccg_to_mwg.x" "(ccg_to_mwg.indi_f_complete(ccg_to_mwg.G))")) (indi_f_sc_is_complete-1 nil 3651508183 ("" (tcc)) ((CCG type-eq-decl nil ccg_def nil) (CallingContext type-eq-decl nil cc_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (vert type-eq-decl nil digraphs_ digraphs) (Sign3 type-eq-decl nil sign3 reals) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (vert const-decl "bool" c_digraphs_def digraphs) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (gt const-decl "bool" ccg nil) (get const-decl "Sign3" measures nil)) nil (indi_f_sc_is_complete subtype "ccg_to_mwg.x" "(ccg_to_mwg.indi_f_complete(ccg_to_mwg.G))"))) (indi_func_is_sc 0 (indi_func_is_sc-1 nil 3651488020 ("" (skeep) (("" (expand "indi_f_sc") (("" (split 1) (("1" (expand "indi_f_sound") (("1" (skeep) (("1" (expand "indi_func") (("1" (split 1) (("1" (invoke (typepred "%1") (! 1 1 1 1)) (("1" (invoke (typepred "%1") (! 1 1 1 0 1)) (("1" (hide-all-but (-3 1)) (("1" (expand "eq") (("1" (inst -1 "i" "j") (("1" (replace -1 :hide? t) (("1" (lift-if 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (invoke (typepred "%1") (! 1 1 1 0 1)) (("2" (hide-all-but (-3 1)) (("2" (expand "eq") (("2" (inst -1 "i" "j") (("2" (replace -1 :hide? t) (("2" (assert) (("2" (lift-if 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "indi_func") (("2" (expand "indi_f_complete") (("2" (skeep*) (("2" (split 1) (("1" (invoke (typepred "%1") (! 1 2 1 0 1)) (("1" (hide-all-but (-3 1)) (("1" (expand "eq") (("1" (inst -1 "i_1" "j_1") (("1" (replace -1 :hide? t) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (invoke (typepred "%1") (! 1 2 1 0 1)) (("2" (hide-all-but (-3 1)) (("2" (expand "eq") (("2" (inst -1 "i_1" "j_1") (("2" (replace -1 :hide? t) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((indi_f_sc const-decl "bool" ccg_to_mwg nil) (indi_f_complete const-decl "bool" ccg_to_mwg nil) (indi_f_sound const-decl "bool" ccg_to_mwg nil) (indi_func const-decl "indi_f(G)" ccg_to_mwg nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (below type-eq-decl nil naturalnumbers nil) (TRUE const-decl "bool" booleans nil) (FALSE const-decl "bool" booleans nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CCG type-eq-decl nil ccg_def nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (gt const-decl "bool" ccg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (CallingContext type-eq-decl nil cc_def nil) (FunMeasures type-eq-decl nil ccg_def nil) (FunMeasure type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (MT formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (form_matrix const-decl "{m: Measure_Matrix | eq(m, f)}" measures nil) (eq const-decl "bool" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Measure_Mat_Fn type-eq-decl nil measures nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (indi_func_is_sc subtype "ccg_to_mwg.indi_func(ccg_to_mwg.G)" "(ccg_to_mwg.indi_f_sc(ccg_to_mwg.G))"))) (weight_TCC1 0 (weight_TCC1-2 "" 3790335090 ("" (tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (edge? const-decl "bool" digraphs_ digraphs) (MT formal-type-decl nil ccg_to_mwg nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (edge type-eq-decl nil digraphs_ digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (vert? const-decl "bool" digraphs_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (weight subtype "ccg_to_mwg.e`1" "vert[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](dg(ccg_to_mwg.G))")) (weight_TCC1-1 nil 3588004351 ("" (tcc)) ((edge? const-decl "bool" digraphs_ digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (edge type-eq-decl nil digraphs_ digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (CallingContext type-eq-decl nil cc_def nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (vert? const-decl "bool" digraphs_ digraphs)) nil (weight subtype "ccg_to_mwg.e`1" "vert[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](dg(ccg_to_mwg.G))"))) (wlist_from_edges_TCC1 0 (wlist_from_edges_TCC1-1 nil 3658257578 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (MT formal-type-decl nil ccg_to_mwg nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (edge? const-decl "bool" digraphs_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (wlist_from_edges subtype "ccg_to_mwg.e" "edge[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](dg(ccg_to_mwg.G))"))) (wlist_from_edges_TCC2 0 (wlist_from_edges_TCC2-1 nil 3658257578 ("" (use "measure_matrix_assoc") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) nil (wlist_from_edges subtype "measures[ccg_to_mwg.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(ccg_to_mwg.f)}"))) (wlist_from_edges_TCC3 0 (wlist_from_edges_TCC3-3 nil 3661858225 ("" (use "id_is_identity") (("" (assert) nil nil)) nil) ((N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_is_identity formula-decl nil measures nil)) nil (wlist_from_edges subtype "measures[ccg_to_mwg.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[ccg_to_mwg.N].*)(ccg_to_mwg.zero)}")) (wlist_from_edges_TCC3-2 nil 3658581597 ("" (skeep) (("" (split 1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (typepred "keys_no_rep?(null)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (rewrite "id_is_identity") nil nil) ("3" (rewrite "measure_matrix_assoc") nil nil) ("4" (grind) nil nil)) nil) ("4" (grind) nil nil)) nil)) nil) ((form_matrix const-decl "{m: Measure_Matrix | eq(m, f)}" measures nil) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (no_repetitions? const-decl "bool" more_list_props structures) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (CallingContext type-eq-decl nil cc_def nil) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (keys_no_rep? const-decl "{b: bool |
   b IFF
    NOT EXISTS ((k1, k2: T), (v1, v2: Weight)):
          member((k1, k2, v1), map) AND
           member((k1, k2, v2), map) AND
            (EXISTS (i, j: below(length(map))):
               i /= j AND
                nth(map, i) = (k1, k2, v1) AND nth(map, j) = (k1, k2, v2))}" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs)) nil (wlist_from_edges subtype "measures[ccg_to_mwg.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[ccg_to_mwg.N].*)(ccg_to_mwg.zero)}")) (wlist_from_edges_TCC3-1 nil 3658260033 ("" (skeep) (("" (use "no_rep_cdr[[CallingContext[Val, Expr, Condition,NodeId],
            CallingContext[Val, Expr, Condition,NodeId]]]") (("" (assert) nil nil)) nil)) nil) ((ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (is_finite const-decl "bool" finite_sets nil) (CallingContext type-eq-decl nil cc_def nil) (no_rep_cdr formula-decl nil more_list_props structures)) nil (wlist_from_edges subtype "measures[ccg_to_mwg.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[ccg_to_mwg.N].*)(ccg_to_mwg.zero)}"))) (wlist_from_edges_TCC4 0 (wlist_from_edges_TCC4-2 nil 3661858193 ("" (skeep) (("" (grind) nil nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (edge? const-decl "bool" digraphs_ digraphs) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (Expr formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (CallingContext type-eq-decl nil cc_def nil) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (NOT const-decl "[bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil)) nil (wlist_from_edges subtype "(ccg_to_mwg.k1, ccg_to_mwg.k2)" "edge[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](dg(ccg_to_mwg.G))")) (wlist_from_edges_TCC4-1 nil 3658260033 ("" (skeep) (("" (use "no_rep_cdr[[CallingContext[Val, Expr, Condition,NodeId],
                  CallingContext[Val, Expr, Condition,NodeId]]]") (("" (assert) nil nil)) nil)) nil) ((no_rep_cdr formula-decl nil more_list_props structures) (CallingContext type-eq-decl nil cc_def nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs)) nil (wlist_from_edges subtype "(ccg_to_mwg.k1, ccg_to_mwg.k2)" "edge[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](dg(ccg_to_mwg.G))"))) (wlist_from_edges_TCC5 0 (wlist_from_edges_TCC5-5 "" 3790335107 ("" (skeep) (("" (split 1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (typepred "keys_no_rep?(null)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (rewrite "id_is_identity") nil nil) ("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (grind) nil nil)) nil)) nil) ((weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (member def-decl "bool" list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (identity? const-decl "bool" operator_defs nil) (associative? const-decl "bool" operator_defs nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (keys_no_rep? const-decl "{b: bool |
   b IFF
    NOT EXISTS ((k1, k2: T), (v1, v2: Weight)):
          member((k1, k2, v1), map) AND
           member((k1, k2, v2), map) AND
            (EXISTS (i, j: below(length(map))):
               i /= j AND
                nth(map, i) = (k1, k2, v1) AND nth(map, j) = (k1, k2, v2))}" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs)) shostak (wlist_from_edges subtype "list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].null" "{l: list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].list | booleans.AND(FORALL (e: (c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G)))): booleans.IFF(list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId]]].member(e, ccg_to_mwg.es), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((e`1, e`2, ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(e)), l)), booleans.AND(more_list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].no_repetitions?(l), booleans.AND(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].keys_no_rep?(l), FORALL (k1, k2: cc_def[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId].CallingContext, v: measures[ccg_to_mwg.N].Measure_Matrix): booleans.IMPLIES(booleans.AND(c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G))(k1, k2), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((k1, k2, v), l)), v = ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(k1, k2)))))}")) (wlist_from_edges_TCC5-4 "" 3661858166 ("" (skeep) (("" (split 1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (typepred "keys_no_rep?(null)") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (rewrite "id_is_identity") nil nil) ("3" (rewrite "measure_matrix_assoc") nil nil) ("4" (grind) nil nil)) nil) ("4" (grind) nil nil)) nil)) nil) ((no_repetitions? const-decl "bool" more_list_props structures) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (CallingContext type-eq-decl nil cc_def nil) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (keys_no_rep? const-decl "{b: bool |
   b IFF
    NOT EXISTS ((k1, k2: T), (v1, v2: Weight)):
          member((k1, k2, v1), map) AND
           member((k1, k2, v2), map) AND
            (EXISTS (i, j: below(length(map))):
               i /= j AND
                nth(map, i) = (k1, k2, v1) AND nth(map, j) = (k1, k2, v2))}" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs)) nil (wlist_from_edges subtype "list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].null" "{l: list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].list | booleans.AND(FORALL (e: (c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G)))): booleans.IFF(list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId]]].member(e, ccg_to_mwg.es), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((e`1, e`2, ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(e)), l)), booleans.AND(more_list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].no_repetitions?(l), booleans.AND(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].keys_no_rep?(l), FORALL (k1, k2: cc_def[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId].CallingContext, v: measures[ccg_to_mwg.N].Measure_Matrix): booleans.IMPLIES(booleans.AND(c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G))(k1, k2), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((k1, k2, v), l)), v = ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(k1, k2)))))}")) (wlist_from_edges_TCC5-3 "" 3658581528 ("" (termination-tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (no_repetitions? const-decl "bool" more_list_props structures) (vert const-decl "bool" c_digraphs_def digraphs)) shostak (wlist_from_edges subtype "list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].null" "{l: list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].list | booleans.AND(FORALL (e: (c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G)))): booleans.IFF(list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId]]].member(e, ccg_to_mwg.es), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((e`1, e`2, ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(e)), l)), booleans.AND(more_list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].no_repetitions?(l), booleans.AND(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].keys_no_rep?(l), FORALL (k1, k2: cc_def[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId].CallingContext, v: measures[ccg_to_mwg.N].Measure_Matrix): booleans.IMPLIES(booleans.AND(c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G))(k1, k2), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((k1, k2, v), l)), v = ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(k1, k2)))))}")) (wlist_from_edges_TCC5-2 nil 3658492151 ("" (skosimp*) (("" (typepred "v!1(G!1, f!1)(es!2)") (("1" (split 1) (("1" (skosimp*) (("1" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (assert) (("1" (split -1) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (inst - "e!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (case "e!2=e!1") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (apply-extensionality 1) nil nil)) nil)) nil) ("2" (inst -2 "e!2") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "no_repetitions_append[[CallingContext,CallingContext,Measure_Matrix[N]]]") (("2" (inst -1 "(: (e!1`1,e!1`2,form_matrix[N](weight(G!1)(f!1)(e!1))) :)" "v!1(G!1,f!1)(es!2)") (("2" (expand "append" -1) (("2" (expand "append" -1) (("2" (flatten) (("2" (hide -2) (("2" (split -1) (("1" (propax) nil nil) ("2" (grind) nil nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "member" -1) (("3" (expand "member" -1) (("3" (replace -1 :hide? t) (("3" (inst?) (("3" (assert) (("3" (typepred "es!1") (("3" (hide-all-but (-6 -2 -4)) (("3" (lemma "no_repetitions_append[[CallingContext,CallingContext]]") (("3" (inst -1 "(: e!1 :)" "es!2") (("3" (assert) (("3" (flatten) (("3" (hide -1) (("3" (expand "append" -1) (("3" (expand "append" -1) (("3" (flatten) (("3" (inst -3 "e!1") (("3" (assert) (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil) ("2" (hide 2) (("2" (split 1) (("1" (use "no_rep_cdr[[CallingContext[Val, Expr, Condition,NodeId],
            CallingContext[Val, Expr, Condition,NodeId]]]") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((CallingContext type-eq-decl nil cc_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (is_finite const-decl "bool" finite_sets nil) (no_repetitions? const-decl "bool" more_list_props structures) (vert const-decl "bool" c_digraphs_def digraphs)) nil (wlist_from_edges subtype "list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].null" "{l: list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].list | booleans.AND(FORALL (e: (c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G)))): booleans.IFF(list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId]]].member(e, ccg_to_mwg.es), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((e`1, e`2, ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(e)), l)), booleans.AND(more_list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].no_repetitions?(l), booleans.AND(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].keys_no_rep?(l), FORALL (k1, k2: cc_def[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId].CallingContext, v: measures[ccg_to_mwg.N].Measure_Matrix): booleans.IMPLIES(booleans.AND(c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G))(k1, k2), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((k1, k2, v), l)), v = ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(k1, k2)))))}")) (wlist_from_edges_TCC5-1 nil 3658260033 ("" (skeep) (("" (typepred "v(G, f)(es_)") (("1" (split 1) (("1" (skeep) (("1" (expand "member" -1) (("1" (assert) (("1" (split -1) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (replace -4 :hide? t) (("2" (assert) (("2" (inst - "e_1") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil) ("2" (postpone) nil nil)) nil)) nil) nil nil (wlist_from_edges subtype "list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].null" "{l: list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].list | booleans.AND(FORALL (e: (c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G)))): booleans.IFF(list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId]]].member(e, ccg_to_mwg.es), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((e`1, e`2, ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(e)), l)), booleans.AND(more_list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].no_repetitions?(l), booleans.AND(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].keys_no_rep?(l), FORALL (k1, k2: cc_def[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId].CallingContext, v: measures[ccg_to_mwg.N].Measure_Matrix): booleans.IMPLIES(booleans.AND(c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G))(k1, k2), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((k1, k2, v), l)), v = ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(k1, k2)))))}"))) (wlist_from_edges_TCC6 0 (wlist_from_edges_TCC6-3 nil 3661858149 ("" (skeep) (("" (use "no_rep_cdr[[CallingContext[Val, Expr, Condition,NodeId],
                        CallingContext[Val, Expr, Condition,NodeId]]]") (("" (assert) nil nil)) nil)) nil) ((no_rep_cdr formula-decl nil more_list_props structures) (Expr formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (CallingContext type-eq-decl nil cc_def nil) (CCG type-eq-decl nil ccg_def nil) (FunMeasures type-eq-decl nil ccg_def nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil)) nil (wlist_from_edges subtype "ccg_to_mwg.es_" "{es: list_adt[(c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G)))].list | more_list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId]]].no_repetitions?(es)}")) (wlist_from_edges_TCC6-2 nil 3658578581 ("" (skosimp*) (("" (typepred "v1!1(G!1, f!1)(es!2)") (("1" (split 1) (("1" (skosimp*) (("1" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (assert) (("1" (split -1) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (inst - "e!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (case "e!2=e!1") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (apply-extensionality 1) nil nil)) nil)) nil) ("2" (inst -2 "e!2") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "no_repetitions_append[[CallingContext,CallingContext,Measure_Matrix[N]]]") (("2" (inst -1 "(: (e!1`1,e!1`2,form_matrix[N](weight(G!1)(f!1)(e!1))) :)" "v1!1(G!1,f!1)(es!2)") (("2" (expand "append" -1) (("2" (expand "append" -1) (("2" (flatten) (("2" (hide -2) (("2" (split -1) (("1" (propax) nil nil) ("2" (grind) nil nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "member" -1) (("3" (expand "member" -1) (("3" (replace -1 :hide? t) (("3" (inst?) (("3" (assert) (("3" (typepred "es!1") (("3" (hide-all-but (-6 -2 -4)) (("3" (lemma "no_repetitions_append[[CallingContext,CallingContext]]") (("3" (inst -1 "(: e!1 :)" "es!2") (("3" (assert) (("3" (flatten) (("3" (hide -1) (("3" (expand "append" -1) (("3" (expand "append" -1) (("3" (flatten) (("3" (inst -3 "e!1") (("3" (assert) (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "keys_no_rep?_append") (("3" (inst -1 "(: (e!1`1, e!1`2, form_matrix[N](weight(G!1)(f!1)(e!1))) :)" "v1!1(G!1, f!1)(es!2)") (("3" (expand "append" -1) (("3" (assert) (("3" (flatten -1) (("3" (hide -2) (("3" (split -1) (("1" (invoke (typepred "%1") (! 1)) (("1" (grind) nil nil) ("2" (rewrite "id_is_identity") nil nil) ("3" (rewrite "measure_matrix_assoc") nil nil) ("4" (grind) nil nil)) nil) ("2" (hide 2) (("2" (invoke (typepred "%1") (! 1)) (("1" (grind) nil nil) ("2" (rewrite "id_is_identity") nil nil) ("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep -1) (("3" (expand "member" -1) (("3" (expand "member" -1) (("3" (flatten) (("3" (replace -1 :hide? t) (("3" (replace -1 :hide? t) (("3" (hide -1) (("3" (skeep -1) (("3" (inst -5 "e!1`1" "e!1`2" "v2") (("3" (split -5) (("1" (replace -1 :hide? t) (("1" (inst? -2) (("1" (assert) (("1" (hide-all-but (-2 -5)) (("1" (typepred "es!1") (("1" (replace -4 :hide? t) (("1" (use "no_rep_cdr[[CallingContext[Val, Expr, Condition,NodeId],
            CallingContext[Val, Expr, Condition,NodeId]]]") (("1" (assert) (("1" (case "e!1=(e!1`1,e!1`2)") (("1" (replace -1 :hide? t :dir rl) (("1" (propax) nil nil)) nil) ("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "e!1") (("2" (expand "edges") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "e!1") (("2" (expand "edges") (("2" (flatten) nil nil)) nil)) nil) ("3" (typepred "e!1") (("3" (expand "edges") (("3" (flatten) nil nil)) nil)) nil) ("4" (typepred "e!1") (("4" (expand "edges") (("4" (flatten) nil nil)) nil)) nil) ("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (expand "member" -2) (("4" (case "k1 = e!1`1 AND
       k2 = e!1`2 AND v = form_matrix[N](weight(G!1)(f!1)(e!1))") (("1" (hide -3) (("1" (flatten) (("1" (case "e!1=(e!1`1,e!1`2)") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil) ("2" (split -2) (("1" (propax) nil nil) ("2" (inst -6 "k1" "k2" "v") (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (expand "edge?") (("3" (expand "digraph_edges") (("3" (expand "edges") (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split 1) (("1" (use "no_rep_cdr[[CallingContext[Val, Expr, Condition,NodeId],
            CallingContext[Val, Expr, Condition,NodeId]]]") (("1" (assert) nil nil)) nil) ("2" (replace -1 :hide? t) (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((keys_no_rep? const-decl "{b: bool |
   b IFF
    NOT EXISTS ((k1, k2: T), (v1, v2: Weight)):
          member((k1, k2, v1), map) AND
           member((k1, k2, v2), map) AND
            (EXISTS (i, j: below(length(map))):
               i /= j AND
                nth(map, i) = (k1, k2, v1) AND nth(map, j) = (k1, k2, v2))}" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (no_repetitions? const-decl "bool" more_list_props structures) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (form_matrix const-decl "{m: Measure_Matrix | eq(m, f)}" measures nil) (eq const-decl "bool" measures nil) (Measure_Mat_Fn type-eq-decl nil measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (CallingContext type-eq-decl nil cc_def nil) (keys_no_rep?_append formula-decl nil c_weighted_digraphs_def digraphs) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (no_rep_cdr formula-decl nil more_list_props structures) (no_repetitions_append formula-decl nil more_list_props structures) (vert const-decl "bool" c_digraphs_def digraphs) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures)) nil (wlist_from_edges subtype "ccg_to_mwg.es_" "{es: list_adt[(c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G)))].list | more_list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId]]].no_repetitions?(es)}")) (wlist_from_edges_TCC6-1 nil 3658578532 ("" (subtype-tcc) nil nil) nil nil (wlist_from_edges subtype "ccg_to_mwg.es_" "{es: list_adt[(c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G)))].list | more_list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId]]].no_repetitions?(es)}"))) (wlist_from_edges_TCC7 0 (wlist_from_edges_TCC7-1 nil 3661857041 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Expr formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (CallingContext type-eq-decl nil cc_def nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (MT formal-type-decl nil ccg_to_mwg nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (no_repetitions? const-decl "bool" more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (vert const-decl "bool" c_digraphs_def digraphs) (/= const-decl "boolean" notequal nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (wlist_from_edges termination "ccg_to_mwg.wlist_from_edges(ccg_to_mwg.G, ccg_to_mwg.f)(ccg_to_mwg.es_)" "nil"))) (wlist_from_edges_TCC8 0 (wlist_from_edges_TCC8-3 "" 3790335148 ("" (skosimp*) (("" (typepred "v1!1(G!1, f!1)(es!2)") (("1" (split 1) (("1" (skosimp*) (("1" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (assert) (("1" (split -1) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (inst - "e!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (case "e!2=e!1") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (apply-extensionality 1) nil nil)) nil)) nil) ("2" (inst -2 "e!2") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "no_repetitions_append[[CallingContext,CallingContext,Measure_Matrix[N]]]") (("2" (inst -1 "(: (e!1`1,e!1`2,weight(G!1)(f!1)(e!1)) :)" "v1!1(G!1,f!1)(es!2)") (("2" (expand "append" -1) (("2" (expand "append" -1) (("2" (flatten) (("2" (hide -2) (("2" (split -1) (("1" (propax) nil nil) ("2" (grind) nil nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "member" -1) (("3" (expand "member" -1) (("3" (replace -1 :hide? t) (("3" (inst?) (("3" (assert) (("3" (typepred "es!1") (("3" (hide-all-but (-6 -2 -4)) (("3" (lemma "no_repetitions_append[[CallingContext,CallingContext]]") (("3" (inst -1 "(: e!1 :)" "es!2") (("3" (assert) (("3" (flatten) (("3" (hide -1) (("3" (expand "append" -1) (("3" (expand "append" -1) (("3" (flatten) (("3" (inst -3 "e!1") (("3" (assert) (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "keys_no_rep?_append") (("3" (inst -1 "(: (e!1`1, e!1`2, weight(G!1)(f!1)(e!1)) :)" "v1!1(G!1, f!1)(es!2)") (("3" (expand "append" -1) (("3" (assert) (("3" (flatten -1) (("3" (hide -2) (("3" (split -1) (("1" (invoke (typepred "%1") (! 1)) (("1" (grind) nil nil) ("2" (rewrite "id_is_identity") nil nil) ("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("2" (hide 2) (("2" (invoke (typepred "%1") (! 1)) (("1" (grind) nil nil) ("2" (rewrite "id_is_identity") nil nil) ("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep -1) (("3" (expand "member" -1) (("3" (expand "member" -1) (("3" (flatten) (("3" (replace -1 :hide? t) (("3" (replace -1 :hide? t) (("3" (hide -1) (("3" (skeep -1) (("3" (inst -5 "e!1`1" "e!1`2" "v2") (("3" (split -5) (("1" (replace -1 :hide? t) (("1" (inst? -2) (("1" (assert) (("1" (hide-all-but (-2 -5)) (("1" (typepred "es!1") (("1" (replace -4 :hide? t) (("1" (use "no_rep_cdr[[CallingContext[Val, Expr, Condition,NodeId],
                                            CallingContext[Val, Expr, Condition,NodeId]]]") (("1" (assert) (("1" (case "e!1=(e!1`1,e!1`2)") (("1" (replace -1 :hide? t :dir rl) (("1" (propax) nil nil)) nil) ("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "e!1") (("2" (expand "edges") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "e!1") (("2" (expand "edges") (("2" (flatten) nil nil)) nil)) nil) ("3" (typepred "e!1") (("3" (expand "edges") (("3" (flatten) nil nil)) nil)) nil) ("4" (typepred "e!1") (("4" (expand "edges") (("4" (flatten) nil nil)) nil)) nil) ("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (expand "member" -2) (("4" (case "k1 = e!1`1 AND
                             k2 = e!1`2 AND v = weight(G!1)(f!1)(e!1)") (("1" (hide -3) (("1" (flatten) (("1" (case "e!1=(e!1`1,e!1`2)") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil) ("2" (split -2) (("1" (propax) nil nil) ("2" (inst -6 "k1" "k2" "v") (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (expand "edge?") (("3" (expand "digraph_edges") (("3" (expand "edges") (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split 1) (("1" (use "no_rep_cdr[[CallingContext[Val, Expr, Condition,NodeId],
                      CallingContext[Val, Expr, Condition,NodeId]]]") (("1" (assert) nil nil)) nil) ("2" (replace -1 :hide? t) (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((keys_no_rep? const-decl "{b: bool |
   b IFF
    NOT EXISTS ((k1, k2: T), (v1, v2: Weight)):
          member((k1, k2, v1), map) AND
           member((k1, k2, v2), map) AND
            (EXISTS (i, j: below(length(map))):
               i /= j AND
                nth(map, i) = (k1, k2, v1) AND nth(map, j) = (k1, k2, v2))}" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (/= const-decl "boolean" notequal nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (no_repetitions? const-decl "bool" more_list_props structures) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (indi_f type-eq-decl nil ccg_to_mwg nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (CCG type-eq-decl nil ccg_def nil) (FunMeasures type-eq-decl nil ccg_def nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (keys_no_rep?_append formula-decl nil c_weighted_digraphs_def digraphs) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (associative? const-decl "bool" operator_defs nil) (identity? const-decl "bool" operator_defs nil) (G!1 skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (e!1 skolem-const-decl "(edges[CallingContext[Val, Expr, Condition, NodeId]](dg(G!1)))" ccg_to_mwg nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (no_rep_cdr formula-decl nil more_list_props structures) (no_repetitions_append formula-decl nil more_list_props structures) (append def-decl "list[T]" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (vert const-decl "bool" c_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (wlist_from_edges subtype "list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].cons((ccg_to_mwg.e`1, ccg_to_mwg.e`2, ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(ccg_to_mwg.e)), ccg_to_mwg.wlist_from_edges(ccg_to_mwg.G, ccg_to_mwg.f)(ccg_to_mwg.es_))" "{l: list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].list | booleans.AND(FORALL (e: (c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G)))): booleans.IFF(list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId]]].member(e, ccg_to_mwg.es), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((e`1, e`2, ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(e)), l)), booleans.AND(more_list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].no_repetitions?(l), booleans.AND(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].keys_no_rep?(l), FORALL (k1, k2: cc_def[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId].CallingContext, v: measures[ccg_to_mwg.N].Measure_Matrix): booleans.IMPLIES(booleans.AND(c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G))(k1, k2), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((k1, k2, v), l)), v = ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(k1, k2)))))}")) (wlist_from_edges_TCC8-2 nil 3661857960 ("" (skosimp*) (("" (typepred "v1!1(G!1, f!1)(es!2)") (("1" (split 1) (("1" (skosimp*) (("1" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (assert) (("1" (split -1) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (inst - "e!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" -1) (("2" (assert) (("2" (split -1) (("1" (flatten) (("1" (case "e!2=e!1") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (apply-extensionality 1) nil nil)) nil)) nil) ("2" (inst -2 "e!2") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "no_repetitions_append[[CallingContext,CallingContext,Measure_Matrix[N]]]") (("2" (inst -1 "(: (e!1`1,e!1`2,weight(G!1)(f!1)(e!1)) :)" "v1!1(G!1,f!1)(es!2)") (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (flatten) (("1" (hide -2) (("1" (split -1) (("1" (propax) nil nil) ("2" (grind) nil nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "member" -1) (("3" (expand "member" -1) (("3" (replace -1 :hide? t) (("3" (inst?) (("3" (assert) (("3" (typepred "es!1") (("3" (hide-all-but (-6 -2 -4)) (("3" (lemma "no_repetitions_append[[CallingContext,CallingContext]]") (("3" (inst -1 "(: e!1 :)" "es!2") (("3" (assert) (("3" (flatten) (("3" (hide -1) (("3" (expand "append" -1) (("3" (expand "append" -1) (("3" (flatten) (("3" (inst -3 "e!1") (("3" (assert) (("3" (expand "member") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (lemma "keys_no_rep?_append") (("3" (inst -1 "(: (e!1`1, e!1`2, weight(G!1)(f!1)(e!1)) :)" "v1!1(G!1, f!1)(es!2)") (("1" (expand "append" -1) (("1" (assert) (("1" (flatten -1) (("1" (hide -2) (("1" (split -1) (("1" (invoke (typepred "%1") (! 1)) (("1" (grind) nil nil) ("2" (rewrite "id_is_identity") nil nil) ("3" (rewrite "measure_matrix_assoc") nil nil) ("4" (grind) nil nil)) nil) ("2" (hide 2) (("2" (invoke (typepred "%1") (! 1)) (("1" (grind) nil nil) ("2" (rewrite "id_is_identity") nil nil) ("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep -1) (("3" (expand "member" -1) (("3" (expand "member" -1) (("3" (flatten) (("3" (replace -1 :hide? t) (("3" (replace -1 :hide? t) (("3" (hide -1) (("3" (skeep -1) (("3" (inst -5 "e!1`1" "e!1`2" "v2") (("3" (split -5) (("1" (replace -1 :hide? t) (("1" (inst? -2) (("1" (assert) (("1" (hide-all-but (-2 -5)) (("1" (typepred "es!1") (("1" (replace -4 :hide? t) (("1" (use "no_rep_cdr[[CallingContext[Val, Expr, Condition,NodeId],
                                            CallingContext[Val, Expr, Condition,NodeId]]]") (("1" (assert) (("1" (case "e!1=(e!1`1,e!1`2)") (("1" (replace -1 :hide? t :dir rl) (("1" (propax) nil nil)) nil) ("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "e!1") (("2" (expand "edges") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "e!1") (("2" (expand "edges") (("2" (flatten) nil nil)) nil)) nil) ("3" (typepred "e!1") (("3" (expand "edges") (("3" (flatten) nil nil)) nil)) nil) ("4" (typepred "e!1") (("4" (expand "edges") (("4" (flatten) nil nil)) nil)) nil) ("5" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil) ("4" (skeep) (("4" (expand "member" -2) (("4" (case "k1 = e!1`1 AND
                             k2 = e!1`2 AND v = weight(G!1)(f!1)(e!1)") (("1" (hide -3) (("1" (flatten) (("1" (case "e!1=(e!1`1,e!1`2)") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (apply-extensionality 1) nil nil)) nil)) nil)) nil) ("2" (split -2) (("1" (propax) nil nil) ("2" (inst -6 "k1" "k2" "v") (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (expand "edge?") (("3" (expand "digraph_edges") (("3" (expand "edges") (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split 1) (("1" (use "no_rep_cdr[[CallingContext[Val, Expr, Condition,NodeId],
                      CallingContext[Val, Expr, Condition,NodeId]]]") (("1" (assert) nil nil)) nil) ("2" (replace -1 :hide? t) (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((keys_no_rep? const-decl "{b: bool |
   b IFF
    NOT EXISTS ((k1, k2: T), (v1, v2: Weight)):
          member((k1, k2, v1), map) AND
           member((k1, k2, v2), map) AND
            (EXISTS (i, j: below(length(map))):
               i /= j AND
                nth(map, i) = (k1, k2, v1) AND nth(map, j) = (k1, k2, v2))}" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (no_repetitions? const-decl "bool" more_list_props structures) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (CCG type-eq-decl nil ccg_def nil) (FunMeasures type-eq-decl nil ccg_def nil) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (CallingContext type-eq-decl nil cc_def nil) (keys_no_rep?_append formula-decl nil c_weighted_digraphs_def digraphs) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (no_rep_cdr formula-decl nil more_list_props structures) (no_repetitions_append formula-decl nil more_list_props structures) (vert const-decl "bool" c_digraphs_def digraphs)) nil (wlist_from_edges subtype "list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].cons((ccg_to_mwg.e`1, ccg_to_mwg.e`2, ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(ccg_to_mwg.e)), ccg_to_mwg.wlist_from_edges(ccg_to_mwg.G, ccg_to_mwg.f)(ccg_to_mwg.es_))" "{l: list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].list | booleans.AND(FORALL (e: (c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G)))): booleans.IFF(list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId]]].member(e, ccg_to_mwg.es), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((e`1, e`2, ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(e)), l)), booleans.AND(more_list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].no_repetitions?(l), booleans.AND(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].keys_no_rep?(l), FORALL (k1, k2: cc_def[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId].CallingContext, v: measures[ccg_to_mwg.N].Measure_Matrix): booleans.IMPLIES(booleans.AND(c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G))(k1, k2), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((k1, k2, v), l)), v = ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(k1, k2)))))}")) (wlist_from_edges_TCC8-1 nil 3661857041 ("" (subtype-tcc) nil nil) nil nil (wlist_from_edges subtype "list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].cons((ccg_to_mwg.e`1, ccg_to_mwg.e`2, ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(ccg_to_mwg.e)), ccg_to_mwg.wlist_from_edges(ccg_to_mwg.G, ccg_to_mwg.f)(ccg_to_mwg.es_))" "{l: list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].list | booleans.AND(FORALL (e: (c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G)))): booleans.IFF(list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId]]].member(e, ccg_to_mwg.es), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((e`1, e`2, ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(e)), l)), booleans.AND(more_list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].no_repetitions?(l), booleans.AND(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].keys_no_rep?(l), FORALL (k1, k2: cc_def[ccg_to_mwg.Val, ccg_to_mwg.Expr, ccg_to_mwg.Condition, ccg_to_mwg.NodeId].CallingContext, v: measures[ccg_to_mwg.N].Measure_Matrix): booleans.IMPLIES(booleans.AND(c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G))(k1, k2), list_props[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].member((k1, k2, v), l)), v = ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(k1, k2)))))}"))) (build_weights_list_TCC1 0 (build_weights_list_TCC1-1 nil 3658232171 ("" (use "measure_matrix_assoc") nil nil) ((N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) shostak (build_weights_list subtype "measures[ccg_to_mwg.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(ccg_to_mwg.f)}"))) (build_weights_list_TCC2 0 (build_weights_list_TCC2-2 nil 3658509076 ("" (use "id_is_identity") nil nil) ((N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_is_identity formula-decl nil measures nil)) nil (build_weights_list subtype "measures[ccg_to_mwg.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[ccg_to_mwg.N].*)(ccg_to_mwg.zero)}")) (build_weights_list_TCC2-1 nil 3658233140 ("" (subtype-tcc) nil nil) ((c_digraph type-eq-decl nil c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (CallingContext type-eq-decl nil cc_def nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (is_finite const-decl "bool" finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs)) nil (build_weights_list subtype "measures[ccg_to_mwg.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[ccg_to_mwg.N].*)(ccg_to_mwg.zero)}"))) (build_weights_list_TCC3 0 (build_weights_list_TCC3-2 nil 3661858512 ("" (existence-tcc) nil nil) ((id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs)) nil (build_weights_list subtype "ccg_to_mwg.e" "(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].has_key?(ccg_to_mwg.l))")) (build_weights_list_TCC3-1 nil 3661857041 ("" (subtype-tcc) nil nil) ((id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (CallingContext type-eq-decl nil cc_def nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs)) nil (build_weights_list subtype "ccg_to_mwg.e" "(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].has_key?(ccg_to_mwg.l))"))) (build_weights_list_TCC4 0 (build_weights_list_TCC4-2 nil 3661858487 ("" (skeep) (("" (split 1) (("1" (typepred "wlist_from_edges(G, f)(edges_list[CallingContext](dg(G)))") (("1" (expand "all_edges_in_map?") (("1" (skeep 1) (("1" (inst -1 "e") (("1" (typepred "edges_list[CallingContext](dg(G))") (("1" (hide -1) (("1" (inst - "e") (("1" (assert) (("1" (inst? 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "wlist_from_edges(G, f)(edges_list[CallingContext](dg(G)))") (("2" (skeep 1) (("2" (inst - "e") (("2" (typepred "edges_list[CallingContext](dg(G))") (("2" (hide -1) (("2" (inst - "e") (("2" (assert) (("2" (use "get_val_no_rep") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (Expr formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (CallingContext type-eq-decl nil cc_def nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (MT formal-type-decl nil ccg_to_mwg nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (length def-decl "nat" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (Sign3 type-eq-decl nil sign3 reals) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (indi_f type-eq-decl nil ccg_to_mwg nil) (edge? const-decl "bool" digraphs_ digraphs) (edge type-eq-decl nil digraphs_ digraphs) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (/= const-decl "boolean" notequal nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (keys_no_rep? const-decl "{b: bool |
   b IFF
    NOT EXISTS ((k1, k2: T), (v1, v2: Weight)):
          member((k1, k2, v1), map) AND
           member((k1, k2, v2), map) AND
            (EXISTS (i, j: below(length(map))):
               i /= j AND
                nth(map, i) = (k1, k2, v1) AND nth(map, j) = (k1, k2, v2))}" c_weighted_digraphs_def digraphs) (wlist_from_edges def-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   (FORALL (e: (edges(dg(G)))):
      member[[CallingContext, CallingContext]](e, es) IFF
       member((e`1, e`2, weight(G)(f)(e)), l))
    AND
    no_repetitions?(l) AND
     keys_no_rep?(l) AND
      (FORALL (k1, k2: CallingContext, v: Measure_Matrix):
         edges(dg(G))(k1, k2) AND member((k1, k2, v), l) IMPLIES
          v = weight(G)(f)(k1, k2))}" ccg_to_mwg nil) (get_val_no_rep formula-decl nil c_weighted_digraphs_def digraphs)) nil (build_weights_list subtype "ccg_to_mwg.wlist_from_edges(ccg_to_mwg.G, ccg_to_mwg.f)(c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges_list(dg(ccg_to_mwg.G)))" "{l: list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].list | booleans.AND(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].all_edges_in_map?(dg(ccg_to_mwg.G))(l), FORALL (e: (c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G)))): c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].get_value(l, e) = ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(e))}")) (build_weights_list_TCC4-1 nil 3661857041 ("" (subtype-tcc) nil nil) nil nil (build_weights_list subtype "ccg_to_mwg.wlist_from_edges(ccg_to_mwg.G, ccg_to_mwg.f)(c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges_list(dg(ccg_to_mwg.G)))" "{l: list_adt[[CallingContext[Val, Expr, Condition, NodeId], CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N]]].list | booleans.AND(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].all_edges_in_map?(dg(ccg_to_mwg.G))(l), FORALL (e: (c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G)))): c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].get_value(l, e) = ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(e))}"))) (ccg_to_mwg_TCC1 0 (ccg_to_mwg_TCC1-1 nil 3658234051 ("" (subtype-tcc) nil nil) ((CCG type-eq-decl nil ccg_def nil) (FunMeasures type-eq-decl nil ccg_def nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs)) nil (ccg_to_mwg subtype "ccg_to_mwg.e" "(c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.W)))"))) (ccg_to_mwg_TCC2 0 (ccg_to_mwg_TCC3-1 nil 3658234051 ("" (skeep) (("" (expand "make_c_wdg") (("" (skeep) (("" (expand "get_wgt") (("" (invoke (typepred "%1") (! 1 1 1)) (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil) ((make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (indi_f type-eq-decl nil ccg_to_mwg nil) (CCG type-eq-decl nil ccg_def nil) (FunMeasures type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (ccg_to_mwg subtype "c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].make_c_wdg(dg(ccg_to_mwg.G), ccg_to_mwg.build_weights_list(ccg_to_mwg.G)(ccg_to_mwg.f))" "{W: c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_type | booleans.AND(dg(W) = dg(ccg_to_mwg.G), FORALL (e: (c_digraphs_def[CallingContext[Val, Expr, Condition, NodeId]].edges(dg(ccg_to_mwg.G)))): c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].get_wgt(W, e) = ccg_to_mwg.weight(ccg_to_mwg.G)(ccg_to_mwg.f)(e))}"))) (same_edges 0 (same_edges-1 nil 3589210739 ("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (expand "ccg_to_mwg") (("" (replace -1 1 :hide? t :dir rl) (("" (assert) (("" (expand "make_c_wdg") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Expr formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (CallingContext type-eq-decl nil cc_def nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (MT formal-type-decl nil ccg_to_mwg nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (CCG type-eq-decl nil ccg_def nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (FunMeasures type-eq-decl nil ccg_def nil) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (edge type-eq-decl nil digraphs_ digraphs) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs)) shostak)) (same_verts 0 (same_verts-2 nil 3651420881 ("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (expand "ccg_to_mwg") (("" (replace -1 1 :hide? t :dir rl) (("" (expand "make_c_wdg") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Expr formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (CallingContext type-eq-decl nil cc_def nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (MT formal-type-decl nil ccg_to_mwg nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (CCG type-eq-decl nil ccg_def nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (FunMeasures type-eq-decl nil ccg_def nil) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (edge type-eq-decl nil digraphs_ digraphs) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs)) nil) (same_verts-1 nil 3589210752 ("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)" :hide? nil) (("" (assert) (("" (expand "ccg_to_mwg") (("" (decompose-equality) (("" (hide -2) (("" (assert) (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((CallingContext type-eq-decl nil cc_def nil) (Sign3 type-eq-decl nil sign3 reals) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil)) shostak)) (same_walks 0 (same_walks-2 nil 3651420896 ("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (expand "ccg_to_mwg") (("" (replace -1 1 :hide? t :dir rl) (("" (expand "make_c_wdg") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Expr formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (CallingContext type-eq-decl nil cc_def nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (MT formal-type-decl nil ccg_to_mwg nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (CCG type-eq-decl nil ccg_def nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (FunMeasures type-eq-decl nil ccg_def nil) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (edge type-eq-decl nil digraphs_ digraphs) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs)) nil) (same_walks-1 nil 3588608630 ("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)" :hide? nil) (("" (assert) (("" (prop) (("1" (expand "ccg_to_mwg") (("1" (decompose-equality -2) (("1" (hide -2) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "ccg_to_mwg") (("2" (decompose-equality -2) (("2" (hide -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((CallingContext type-eq-decl nil cc_def nil) (Sign3 type-eq-decl nil sign3 reals) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil)) shostak)) (gte_mc_to_defined_pos_TCC1 0 (gte_mc_to_defined_pos_TCC1-2 "" 3790335153 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (gte_mc_to_defined_pos subtype "ccg_to_mwg.w" "Walk[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(ccg_to_mwg.G1))")) (gte_mc_to_defined_pos_TCC1-1 nil 3589199067 ("" (tcc)) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (gte_mc_to_defined_pos subtype "ccg_to_mwg.w" "Walk[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(ccg_to_mwg.G1))"))) (gte_mc_to_defined_pos_TCC2 0 (gte_mc_to_defined_pos_TCC2-1 nil 3589199067 ("" (grind) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (gte_mc_to_defined_pos subtype "c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].get_wgt" "[[W: wgd_type[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (gte_mc_to_defined_pos_TCC3 0 (gte_mc_to_defined_pos_TCC3-2 "" 3790335158 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (gte_mc_to_defined_pos subtype "0" "below[length(mc)]")) (gte_mc_to_defined_pos_TCC3-1 nil 3589199067 ("" (tcc)) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs)) nil (gte_mc_to_defined_pos subtype "0" "below[length(mc)]"))) (gte_mc_to_defined_pos_TCC4 0 (gte_mc_to_defined_pos_TCC4-1 nil 3661857041 ("" (subtype-tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (gte_mc_to_defined_pos subtype "(number_fields.-)(length(ccg_to_mwg.w), 1)" "below[length(mc)]"))) (gte_mc_to_defined_pos 0 (gte_mc_to_defined_pos-1 nil 3589199076 ("" (auto-rewrite "finseq_appl") (("" (skolem 1 ("G" "f" "_")) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (measure-induct+ "length(w)" ("w")) (("1" (skeep) (("1" (use "defined_pos?_def") (("1" (replace -1 :hide? t) (("1" (case "length(x!1) = 1") (("1" (hide -2) (("1" (expand "wgt_walk") (("1" (expand "wgt_aux") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (use "id_def") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "defined_pos?") (("2" (expand "defined_pos_fun?") (("2" (expand "form_matfun") (("2" (lemma "wgt_walk_decomposed") (("2" (inst -1 "G1" "1" "x!1") (("2" (assert) (("2" (lemma "same_walks") (("2" (inst -1 "G" "x!1" "f") (("2" (assert) (("2" (hide -1) (("2" (replace -1) (("2" (hide -1) (("2" (inst -1 "rest(x!1)" "rest(mc)") (("1" (expand "rest" -1 1) (("1" (expand "^" -1 1) (("1" (expand "min") (("1" (split) (("1" (expand "rest") (("1" (expand "^" 1 (2 3 4)) (("1" (expand "min") (("1" (flatten) (("1" (invoke (typepred "%1") (! -3 1)) (("1" (hide -1) (("1" (replace -4) (("1" (expand "weight") (("1" (inst -1 "(x!1(0), x!1(1))") (("1" (assert) (("1" (invoke (case "form_matfun(%1) = form_matfun(%2)") (! -1 1) (! -1 2)) (("1" (hide -2) (("1" (decompose-equality -1) (("1" (assert) (("1" (inst -1 "mc`seq(0)") (("1" (decompose-equality -1) (("1" (inst -1 "mc`seq(1)") (("1" (typepred "f") (("1" (expand "indi_f_complete") (("1" (inst -1 "mc`seq(0)" "mc`seq(1)" "x!1`seq(0)") (("1" (expand "gte_mc?") (("1" (inst -3 "0") (("1" (assert) (("1" (case "get(get_wgt(G1,(x!1`seq(0), x!1`seq(1))))(mc`seq(0),mc`seq(1)) /= -1") (("1" (hide -2 -3) (("1" (flatten) (("1" (expand "wgt_walk" -2 1) (("1" (expand "wgt_aux") (("1" (expand "^" -2 1) (("1" (expand "min") (("1" (assert) (("1" (expand "^" -2 (2 4 6)) (("1" (expand "min") (("1" (expand "wgt_aux") (("1" (expand "^" -2 (1 2)) (("1" (lemma "id_is_identity") (("1" (expand "identity?") (("1" (inst -1 "get_wgt(G1,(x!1`seq(0), x!1`seq(1)))") (("1" (flatten) (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "defined_pos_mul") (("1" (inst -1 "get_wgt(G1,(x!1`seq(0), x!1`seq(1)))" "wgt_walk(G1, x!1 ^ (1, length(x!1) - 1))" "mc`seq(0)" "mc`seq(1)" "mc`seq(length(x!1) - 1)") (("1" (split -1) (("1" (lemma "defined_pos?_def") (("1" (inst? -1 :where -2) (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (use "defined_pos?_def") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("3" (lemma "defined_pos?_def") (("3" (inst? -1 :where 1) (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -5) (("2" (hide-all-but (-1 -2 1)) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "id_is_identity") nil nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide-all-but 1) (("3" (rewrite "id_is_identity") nil nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (hide-all-but (-2 1)) (("2" (expand "walk?") (("2" (flatten) (("2" (expand "verts_in?") (("2" (inst-cp -1 "0") (("2" (assert) (("2" (inst -1 "1") (("2" (assert) (("2" (inst -3 "0") (("2" (assert) (("2" (expand "edge?") (("2" (expand "digraph_edges") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 3) (("2" (lemma "gte_mc_sub_walk") (("2" (inst -1 "G" "x!1" "1" "length(x!1) - 1" "mc") (("2" (assert) (("2" (expand "rest") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 3) (("2" (expand* "rest" "^" "min") (("2" (typepred "mc") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide-all-but (-2 1 2)) (("3" (split) (("1" (expand* "rest" "^" "min") (("1" (assert) nil nil)) nil) ("2" (expand "rest") (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "id_is_identity") nil nil)) nil) ("5" (hide-all-but 1) (("5" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (same_walks formula-decl nil ccg_to_mwg nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rest const-decl "finseq" seq_extras structures) (x!1 skolem-const-decl "Walk[CallingContext[Val, Expr, Condition, NodeId],
     digraph_type[CallingContext[Val, Expr, Condition, NodeId]],
     digraph_verts, digraph_edges, digraph_size, digraph_make](dg(G))" ccg_to_mwg nil) (mc skolem-const-decl "measures_combination
    [Val, Expr, Condition, NodeId, MT, lt, N, semantic_rel, eval_conds](x!1)" ccg_to_mwg nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (^ const-decl "finseq" finite_sequences nil) (verts_in? const-decl "bool" walks_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (/= const-decl "boolean" notequal nil) (get const-decl "Sign3" measures nil) (id_is_identity formula-decl nil measures nil) (defined_pos_mul formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (Measure_Mat_Fn type-eq-decl nil measures nil) (eq const-decl "bool" measures nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (nth def-decl "T" list_props nil) (member def-decl "bool" list_props nil) (vert const-decl "bool" c_digraphs_def digraphs) (NOT const-decl "[bool -> bool]" booleans nil) (gte_mc_sub_walk formula-decl nil ccg nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (walk?_caret formula-decl nil walks_ digraphs) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (wgt_walk_decomposed formula-decl nil weighted_digraphs_ digraphs) (defined_pos_fun? const-decl "bool" measures nil) (wgt_aux def-decl "Weight" weighted_digraphs_ digraphs) (id_def formula-decl nil measures nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (defined_pos?_def formula-decl nil measures nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (defined_pos? const-decl "bool" measures nil) (identity? const-decl "bool" operator_defs nil) (associative? const-decl "bool" operator_defs nil) (gte_mc? const-decl "bool" ccg nil) (FunMeasure type-eq-decl nil ccg_def nil) (below type-eq-decl nil naturalnumbers nil) (measures_combination type-eq-decl nil ccg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (G skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (naturalnumber type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (indi_f_complete const-decl "bool" ccg_to_mwg nil) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (CCG type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil)) shostak)) (defined_pos_to_gte_mc_TCC1 0 (defined_pos_to_gte_mc_TCC1-2 "" 3790335176 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (defined_pos_to_gte_mc subtype "ccg_to_mwg.w" "Walk[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(ccg_to_mwg.G1))")) (defined_pos_to_gte_mc_TCC1-1 nil 3590504728 ("" (tcc)) ((CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (defined_pos_to_gte_mc subtype "ccg_to_mwg.w" "Walk[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(ccg_to_mwg.G1))"))) (defined_pos_to_gte_mc_TCC2 0 (defined_pos_to_gte_mc_TCC2-2 "" 3790335179 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (defined_pos_to_gte_mc subtype "c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].get_wgt" "[[W: wgd_type[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]")) (defined_pos_to_gte_mc_TCC2-1 nil 3590504728 ("" (tcc)) ((CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (defined_pos_to_gte_mc subtype "c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].get_wgt" "[[W: wgd_type[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (defined_pos_to_gte_mc_TCC3 0 (defined_pos_to_gte_mc_TCC3-1 nil 3661857041 ("" (subtype-tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (defined_pos_fun? const-decl "bool" measures nil) (defined_pos? const-decl "bool" measures nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (defined_pos_to_gte_mc subtype "ccg_to_mwg.mc" "not_empty_seq[below[N]]"))) (defined_pos_to_gte_mc 0 (defined_pos_to_gte_mc-2 "" 3790335215 ("" (auto-rewrite "finseq_appl") (("" (skolem 1 ("G" "f" "_")) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (measure-induct+ "length(w)" ("w")) (("1" (skeep) (("1" (case "length(x!1) = 1") (("1" (hide -2) (("1" (case "i = j") (("1" (expand "gte_mc?") (("1" (assert) (("1" (inst 1 "#(i)") (("1" (replace -1) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -3 2) (("2" (expand "wgt_walk") (("2" (expand "wgt_aux") (("2" (assert) (("2" (expand "defined_pos?") (("2" (expand "defined_pos_fun?") (("2" (expand "form_matfun") (("2" (use "id_def") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x!1)") (("1" (expand "rest" -1 1) (("1" (expand* "^" "min") (("1" (assert) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G1" "1" "x!1") (("1" (assert) (("1" (lemma "same_walks") (("1" (inst -1 "G" "x!1" "f") (("1" (assert) (("1" (hide -1) (("1" (replaces -1) (("1" (lemma "defined_pos_decomposition") (("1" (inst -1 "wgt_walk(G1, x!1 ^ (0, 1))" "wgt_walk(G1, x!1 ^ (1, length(x!1) - 1))" "i" "j") (("1" (assert) (("1" (skeep) (("1" (inst -3 "k" "j") (("1" (expand "rest" -3 1) (("1" (assert) (("1" (skeep) (("1" (name "mc1" "#(i) o #(k)") (("1" (lemma "gte_mc_comp") (("1" (inst -1 "G" "x!1 ^ (0, 1)" "rest(x!1)" "mc1" "mc") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, 1) o rest(rest(x!1)) = x!1") (("1" (inst 2 "mc1 o rest(mc)") (("1" (assert) (("1" (hide-all-but (-3 -7 -8 1 2)) (("1" (rewrite "first_compo") (("1" (expand "rest") (("1" (typepred "mc") (("1" (expand "rest" -1) (("1" (expand "^" -1) (("1" (expand "min") (("1" (assert) (("1" (expand* "first" "last") (("1" (assert) (("1" (expand "o" 2 2) (("1" (expand "^" 2 2) (("1" (expand* "min" "empty_seq") (("1" (case-replace "x!1`length = 2") (("1" (assert) (("1" (expand "o" -3) (("1" (expand "#") (("1" (decompose-equality -3) (("1" (decompose-equality -2) (("1" (replace -2 2 rl) (("1" (assert) (("1" (inst-cp -1 "0") (("1" (assert) (("1" (expand "o" 2) (("1" (replace -5 -7) (("1" (assert) (("1" (replaces -7) (("1" (replaces -6) (("1" (inst -1 "1") (("1" (assert) nil nil) ("2" (expand "#") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil) ("3" (expand "#") (("3" (assert) nil nil)) nil)) nil) ("2" (hide -6) (("2" (expand "#") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "#") (("3" (assert) nil nil)) nil) ("4" (expand "#") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "o" -2) (("2" (expand "# " -2) (("2" (decompose-equality -2) (("1" (replace -1 3 rl) (("1" (assert) (("1" (decompose-equality -2) (("1" (inst -1 "0") (("1" (assert) (("1" (expand "o" 3) (("1" (replace -2 3 rl) (("1" (expand "^" 3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil) ("3" (expand "#") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil) ("3" (expand "#") (("3" (assert) nil nil)) nil) ("4" (expand "#") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide -3 -4 +) (("2" (expand* "#" "o") (("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "rest") (("2" (expand "^" 1 (2 6)) (("2" (expand "min") (("2" (expand "o") (("2" (decompose-equality) (("1" (expand* "^" "min" "empty_seq") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (decompose-equality) (("1" (expand* "^" "min") (("1" (lift-if) (("1" (ground) (("1" (typepred "x!2") (("1" (expand* "^" "min") (("1" (expand "empty_seq" -1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "x!2") (("2" (expand* "^" "min") (("2" (expand "empty_seq" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "n") (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (expand* "^" "min") (("3" (ground) (("1" (lift-if) (("1" (expand "empty_seq") (("1" (ground) nil nil)) nil)) nil) ("2" (expand "empty_seq") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -8 1 2)) (("2" (expand "gte_mc?") (("2" (assert) (("2" (expand "^" 1) (("2" (invoke (typepred "%1") (! -3 1)) (("2" (hide -1) (("2" (inst -1 "(x!1(0), x!1(1))") (("1" (assert) (("1" (invoke (case "form_matfun(%1) = form_matfun(%2)") (! -1 1) (! -1 2)) (("1" (hide -2) (("1" (assert) (("1" (decompose-equality -1) (("1" (inst -1 "i") (("1" (decompose-equality -1) (("1" (inst -1 "k") (("1" (use "defined_pos?_def") (("1" (replace -1 :hide? t) (("1" (expand "wgt_walk") (("1" (expand "^" -3 2) (("1" (expand "min") (("1" (expand "wgt_aux") (("1" (assert) (("1" (expand "^" 2 (2 3)) (("1" (expand "wgt_aux") (("1" (lemma "id_is_identity") (("1" (expand "identity?") (("1" (inst -1 "get_wgt(G1,(x!1`seq(0), x!1`seq(1)))") (("1" (flatten) (("1" (replace -2) (("1" (hide -1 -2) (("1" (skeep) (("1" (typepred "i!1") (("1" (expand "^") (("1" (expand "min") (("1" (case-replace "i!1 = 0") (("1" (hide -1 -2) (("1" (assert) (("1" (expand* "#" "o") (("1" (decompose-equality -2) (("1" (decompose-equality -2) (("1" (inst-cp -1 "0") (("1" (inst -1 "1") (("1" (assert) (("1" (replace -1 1 rl) (("1" (replace -2 1 rl) (("1" (typepred "f") (("1" (expand "indi_f_sound") (("1" (inst? -1 :where 1) (("1" (typepred "get(get_wgt(G1,(x!1`seq(0), x!1`seq(1))))(i,k)") (("1" (assert) (("1" (reveal -12) (("1" (replace -8 -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (use "get_form_matrix") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide-all-but 1) (("3" (rewrite "id_is_identity") nil nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (hide-all-but (-2 1)) (("2" (expand* "walk?") (("2" (flatten) (("2" (inst -2 "0") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (expand* "last" "first") (("3" (assert) (("3" (expand "^") (("3" (expand "min") (("3" (expand "rest") (("3" (expand "^") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 -5 1)) (("4" (replaces -2) (("4" (expand* "last" "#" "o") (("4" (decompose-equality -1) (("4" (decompose-equality -2) (("4" (assert) (("4" (inst -1 "1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand* "#" "o" "^" "min") (("2" (decompose-equality -1) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide-all-but (-2 1)) (("3" (expand "rest") (("3" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil) ("4" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "rest") (("2" (rewrite "walk?_caret") (("2" (expand "^") (("2" (assert) (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "id_is_identity") nil nil)) nil) ("5" (hide-all-but 1) (("5" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rest const-decl "finseq" seq_extras structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (^ const-decl "finseq" finite_sequences nil) (wgt_walk_decomposed formula-decl nil weighted_digraphs_ digraphs) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (defined_pos_decomposition formula-decl nil measures nil) (O const-decl "finseq" finite_sequences nil) (mc1 skolem-const-decl "finseq[below[N]]" ccg_to_mwg nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (empty_seq const-decl "finseq" finite_sequences nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (k skolem-const-decl "below(N)" ccg_to_mwg nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (first_compo formula-decl nil seq_extras structures) (defined_pos?_def formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (get_form_matrix formula-decl nil measures nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (append def-decl "list[T]" list_props nil) (^ def-decl "list[T]" more_list_props structures) (form_matrix const-decl "{m: Measure_Matrix | eq(m, f)}" measures nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (get const-decl "Sign3" measures nil) (verts_in? const-decl "bool" walks_ digraphs) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (id_is_identity formula-decl nil measures nil) (Measure_Mat_Fn type-eq-decl nil measures nil) (eq const-decl "bool" measures nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (nth def-decl "T" list_props nil) (member def-decl "bool" list_props nil) (vert const-decl "bool" c_digraphs_def digraphs) (walk?_caret formula-decl nil walks_ digraphs) (gte_mc_comp formula-decl nil ccg nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (same_walks formula-decl nil ccg_to_mwg nil) (wgt_aux def-decl "Weight" weighted_digraphs_ digraphs) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (id_def formula-decl nil measures nil) (defined_pos_fun? const-decl "bool" measures nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (finite_sequence type-eq-decl nil finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (i skolem-const-decl "below(N)" ccg_to_mwg nil) (x!1 skolem-const-decl "Walk[CallingContext[Val, Expr, Condition, NodeId],
     digraph_type[CallingContext[Val, Expr, Condition, NodeId]],
     digraph_verts, digraph_edges, digraph_size, digraph_make](dg(G))" ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (gt const-decl "bool" ccg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (last const-decl "T" seq_extras structures) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (/= const-decl "boolean" notequal nil) (gte_mc? const-decl "bool" ccg nil) (FunMeasure type-eq-decl nil ccg_def nil) (measures_combination type-eq-decl nil ccg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (defined_pos? const-decl "bool" measures nil) (identity? const-decl "bool" operator_defs nil) (associative? const-decl "bool" operator_defs nil) (below type-eq-decl nil naturalnumbers nil) (G skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (wf_nat formula-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (naturalnumber type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (indi_f_sound const-decl "bool" ccg_to_mwg nil) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (CCG type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil)) shostak) (defined_pos_to_gte_mc-1 nil 3590491914 ("" (auto-rewrite "finseq_appl") (("" (skolem 1 ("G" "f" "_")) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (measure-induct+ "length(w)" ("w")) (("1" (skeep) (("1" (case "length(x!1) = 1") (("1" (hide -2) (("1" (case "i = j") (("1" (expand "gte_mc?") (("1" (assert) (("1" (inst 1 "#(i)") (("1" (replace -1) (("1" (hide -) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -3 2) (("2" (expand "wgt_walk") (("2" (expand "wgt_aux") (("2" (assert) (("2" (expand "defined_pos?") (("2" (expand "defined_pos_fun?") (("2" (expand "form_matfun") (("2" (use "id_def") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x!1)") (("1" (expand "rest" -1 1) (("1" (expand* "^" "min") (("1" (assert) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G1" "1" "x!1") (("1" (assert) (("1" (lemma "same_walks") (("1" (inst -1 "G" "x!1" "f") (("1" (assert) (("1" (hide -1) (("1" (replaces -1) (("1" (lemma "defined_pos_decomposition") (("1" (inst -1 "wgt_walk(G1, x!1 ^ (0, 1))" "wgt_walk(G1, x!1 ^ (1, length(x!1) - 1))" "i" "j") (("1" (assert) (("1" (skeep) (("1" (inst -3 "k" "j") (("1" (expand "rest" -3 1) (("1" (assert) (("1" (skeep) (("1" (name "mc1" "#(i) o #(k)") (("1" (lemma "gte_mc_comp") (("1" (inst -1 "G" "x!1 ^ (0, 1)" "rest(x!1)" "mc1" "mc") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, 1) o rest(rest(x!1)) = x!1") (("1" (inst 2 "mc1 o rest(mc)") (("1" (assert) (("1" (hide-all-but (-3 -7 -8 1 2)) (("1" (rewrite "first_compo") (("1" (expand "rest") (("1" (typepred "mc") (("1" (expand "rest" -1) (("1" (expand "^" -1) (("1" (expand "min") (("1" (assert) (("1" (expand* "first" "last") (("1" (assert) (("1" (expand "o" 2 2) (("1" (expand "^" 2 2) (("1" (expand* "min" "empty_seq") (("1" (case-replace "x!1`length = 2") (("1" (assert) (("1" (expand "o" -3) (("1" (expand "#") (("1" (decompose-equality -3) (("1" (decompose-equality -2) (("1" (replace -2 2 rl) (("1" (assert) (("1" (inst-cp -1 "0") (("1" (assert) (("1" (expand "o" 2) (("1" (replace -5 -7) (("1" (assert) (("1" (replaces -7) (("1" (replaces -6) (("1" (inst -1 "1") (("1" (assert) nil nil) ("2" (expand "#") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil) ("3" (expand "#") (("3" (assert) nil nil)) nil)) nil) ("2" (hide -6) (("2" (expand "#") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "#") (("3" (assert) nil nil)) nil) ("4" (expand "#") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "o" -2) (("2" (expand "# " -2) (("2" (decompose-equality -2) (("1" (replace -1 3 rl) (("1" (assert) (("1" (decompose-equality -2) (("1" (inst -1 "0") (("1" (assert) (("1" (expand "o" 3) (("1" (replace -2 3 rl) (("1" (expand "^" 3) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil) ("3" (expand "#") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "#") (("2" (assert) nil nil)) nil) ("3" (expand "#") (("3" (assert) nil nil)) nil) ("4" (expand "#") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide -3 -4 +) (("2" (expand* "#" "o") (("2" (decompose-equality) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "rest") (("2" (expand "^" 1 (2 6)) (("2" (expand "min") (("2" (expand "o") (("2" (decompose-equality) (("1" (expand* "^" "min" "empty_seq") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil) ("2" (decompose-equality) (("1" (expand* "^" "min") (("1" (lift-if) (("1" (ground) (("1" (typepred "x!2") (("1" (expand* "^" "min") (("1" (expand "empty_seq" -1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "x!2") (("2" (expand* "^" "min") (("2" (expand "empty_seq" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "n") (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (expand* "^" "min") (("3" (ground) (("1" (lift-if) (("1" (expand "empty_seq") (("1" (ground) nil nil)) nil)) nil) ("2" (expand "empty_seq") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -8 1 2)) (("2" (expand "gte_mc?") (("2" (assert) (("2" (expand "^" 1) (("2" (invoke (typepred "%1") (! -3 1)) (("2" (hide -1) (("2" (inst -1 "(x!1(0), x!1(1))") (("1" (assert) (("1" (invoke (case "form_matfun(%1) = form_matfun(%2)") (! -1 1) (! -1 2)) (("1" (hide -2) (("1" (assert) (("1" (decompose-equality -1) (("1" (inst -1 "i") (("1" (decompose-equality -1) (("1" (inst -1 "k") (("1" (use "defined_pos?_def") (("1" (replace -1 :hide? t) (("1" (expand "wgt_walk") (("1" (expand "^" -3 2) (("1" (expand "min") (("1" (expand "wgt_aux") (("1" (assert) (("1" (expand "^" 2 (2 3)) (("1" (expand "wgt_aux") (("1" (lemma "id_is_identity") (("1" (expand "identity?") (("1" (inst -1 "get_wgt(G1,(x!1`seq(0), x!1`seq(1)))") (("1" (flatten) (("1" (replace -2) (("1" (hide -1 -2) (("1" (skeep) (("1" (typepred "i!1") (("1" (expand "^") (("1" (expand "min") (("1" (case-replace "i!1 = 0") (("1" (hide -1 -2) (("1" (assert) (("1" (expand* "#" "o") (("1" (decompose-equality -2) (("1" (decompose-equality -2) (("1" (inst-cp -1 "0") (("1" (inst -1 "1") (("1" (assert) (("1" (replace -1 1 rl) (("1" (replace -2 1 rl) (("1" (typepred "f") (("1" (expand "indi_f_sound") (("1" (inst? -1 :where 1) (("1" (typepred "get(get_wgt(G1,(x!1`seq(0), x!1`seq(1))))(i,k)") (("1" (assert) (("1" (reveal -12) (("1" (replace -8 -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (use "get_form_matrix") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide-all-but 1) (("3" (rewrite "id_is_identity") nil nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (hide-all-but (-2 1)) (("2" (expand* "walk?") (("2" (flatten) (("2" (inst -2 "0") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (expand* "last" "first") (("3" (assert) (("3" (expand "^") (("3" (expand "min") (("3" (expand "rest") (("3" (expand "^") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-1 -5 1)) (("4" (replaces -2) (("4" (expand* "last" "#" "o") (("4" (decompose-equality -1) (("4" (decompose-equality -2) (("4" (assert) (("4" (inst -1 "1") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (expand* "#" "o" "^" "min") (("2" (decompose-equality -1) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (typepred "x!1") (("3" (hide-all-but (-2 1)) (("3" (expand "rest") (("3" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil) ("4" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "rest") (("2" (rewrite "walk?_caret") (("2" (expand "^") (("2" (assert) (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "id_is_identity") nil nil)) nil) ("5" (hide-all-but 1) (("5" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rest const-decl "finseq" seq_extras structures) (^ const-decl "finseq" finite_sequences nil) (wgt_walk_decomposed formula-decl nil weighted_digraphs_ digraphs) (defined_pos_decomposition formula-decl nil measures nil) (O const-decl "finseq" finite_sequences nil) (empty_seq const-decl "finseq" finite_sequences nil) (first_compo formula-decl nil seq_extras structures) (defined_pos?_def formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (get_form_matrix formula-decl nil measures nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (form_matrix const-decl "{m: Measure_Matrix | eq(m, f)}" measures nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (verts_in? const-decl "bool" walks_ digraphs) (id_is_identity formula-decl nil measures nil) (Measure_Mat_Fn type-eq-decl nil measures nil) (eq const-decl "bool" measures nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (vert const-decl "bool" c_digraphs_def digraphs) (walk?_caret formula-decl nil walks_ digraphs) (gte_mc_comp formula-decl nil ccg nil) (wgt_aux def-decl "Weight" weighted_digraphs_ digraphs) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (id_def formula-decl nil measures nil) (defined_pos_fun? const-decl "bool" measures nil) (finite_sequence type-eq-decl nil finite_sequences nil) (|#| const-decl "finite_sequence[T]" set2seq structures) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (gt const-decl "bool" ccg nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (last const-decl "T" seq_extras structures) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (gte_mc? const-decl "bool" ccg nil) (FunMeasure type-eq-decl nil ccg_def nil) (measures_combination type-eq-decl nil ccg nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (defined_pos? const-decl "bool" measures nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CallingContext type-eq-decl nil cc_def nil)) shostak)) (no_defined_pos_iff_no_gte_mc_TCC1 0 (no_defined_pos_iff_no_gte_mc_TCC1-2 "" 3790335217 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (no_defined_pos_iff_no_gte_mc subtype "ccg_to_mwg.w" "Walk[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(ccg_to_mwg.G1))")) (no_defined_pos_iff_no_gte_mc_TCC1-1 nil 3651507591 ("" (tcc)) ((CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (no_defined_pos_iff_no_gte_mc subtype "ccg_to_mwg.w" "Walk[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(ccg_to_mwg.G1))"))) (no_defined_pos_iff_no_gte_mc_TCC2 0 (no_defined_pos_iff_no_gte_mc_TCC2-1 nil 3661857041 ("" (subtype-tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (no_defined_pos_iff_no_gte_mc subtype "c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].get_wgt" "[[W: wgd_type[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (no_defined_pos_iff_no_gte_mc 0 (no_defined_pos_iff_no_gte_mc-2 "" 3885134051 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (prop) (("1" (skeep) (("1" (lemma "gte_mc_to_defined_pos") (("1" (inst -1 "G" "f" "w" "mc") (("1" (replace -4) (("1" (assert) (("1" (assert) (("1" (inst -2 "mc`seq(0)" "mc`seq(length(w) - 1)") nil nil)) nil)) nil)) nil) ("2" (typepred "f") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "defined_pos_to_gte_mc") (("2" (inst -1 "G" "f" "w") (("1" (replace -4) (("1" (assert) (("1" (inst -1 "i" "j") (("1" (assert) (("1" (skeep) (("1" (inst -4 "mc") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "f") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (no_defined_pos_iff_no_gte_mc-1 nil 3590515080 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (prop) (("1" (skeep) (("1" (lemma "gte_mc_to_defined_pos") (("1" (inst -1 "G" "f" "w" "mc") (("1" (replace -4) (("1" (assert) (("1" (assert) (("1" (inst -2 "mc`seq(0)" "mc`seq(length(w) - 1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "defined_pos_to_gte_mc") (("2" (inst -1 "G" "f" "w") (("2" (replace -4) (("2" (assert) (("2" (inst -1 "i" "j") (("2" (assert) (("2" (skeep) (("2" (inst -4 "mc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (defined_pos_to_gte_mc formula-decl nil ccg_to_mwg nil) (indi_f_complete const-decl "bool" ccg_to_mwg nil) (G skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (f skolem-const-decl "(indi_f_sc(G))" ccg_to_mwg nil) (measures_combination type-eq-decl nil ccg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (< const-decl "bool" reals nil) (Walk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil naturalnumbers nil) (get const-decl "Sign3" measures nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (gt const-decl "bool" ccg nil) (indi_f_sound const-decl "bool" ccg_to_mwg nil) (gte_mc? const-decl "bool" ccg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (defined_pos_fun? const-decl "bool" measures nil) (defined_pos? const-decl "bool" measures nil) (NOT const-decl "[bool -> bool]" booleans nil) (gte_mc_to_defined_pos formula-decl nil ccg_to_mwg nil) (indi_f_sc const-decl "bool" ccg_to_mwg nil) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (CCG type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil)) shostak)) (gt_mc_to_positive_pos_TCC1 0 (gt_mc_to_positive_pos_TCC1-2 "" 3790335221 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (gt_mc? const-decl "bool" ccg nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (gt_mc_to_positive_pos subtype "ccg_to_mwg.w" "Walk[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(ccg_to_mwg.G1))")) (gt_mc_to_positive_pos_TCC1-1 nil 3590501078 ("" (tcc)) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (gt_mc? const-decl "bool" ccg nil) (CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (gt_mc_to_positive_pos subtype "ccg_to_mwg.w" "Walk[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(ccg_to_mwg.G1))"))) (gt_mc_to_positive_pos_TCC2 0 (gt_mc_to_positive_pos_TCC2-2 "" 3790335224 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (gt_mc? const-decl "bool" ccg nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (gt_mc_to_positive_pos subtype "c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].get_wgt" "[[W: wgd_type[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]")) (gt_mc_to_positive_pos_TCC2-1 nil 3590501078 ("" (tcc)) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (gt_mc? const-decl "bool" ccg nil) (CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (gt_mc_to_positive_pos subtype "c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].get_wgt" "[[W: wgd_type[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (gt_mc_to_positive_pos_TCC3 0 (gt_mc_to_positive_pos_TCC3-2 "" 3790335227 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (gt_mc? const-decl "bool" ccg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (gt_mc_to_positive_pos subtype "0" "below[length(mc)]")) (gt_mc_to_positive_pos_TCC3-1 nil 3590501078 ("" (tcc)) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (gt_mc? const-decl "bool" ccg nil) (CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs)) nil (gt_mc_to_positive_pos subtype "0" "below[length(mc)]"))) (gt_mc_to_positive_pos_TCC4 0 (gt_mc_to_positive_pos_TCC4-1 nil 3661857041 ("" (subtype-tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (gt_mc? const-decl "bool" ccg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (gt_mc_to_positive_pos subtype "(number_fields.-)(length(ccg_to_mwg.w), 1)" "below[length(mc)]"))) (gt_mc_to_positive_pos 0 (gt_mc_to_positive_pos-3 nil 3631708914 ("" (auto-rewrite "finseq_appl") (("" (skosimp*) (("" (assert) (("" (flatten) (("" (expand* "positive_pos?" "gt_mc?") (("" (flatten) (("" (assert) (("" (skeep) (("" (lemma "gte_mc_to_defined_pos") (("" (inst -1 "G!1" "f!1" "w!1" "mc!1") (("" (assert) (("" (use "defined_pos?_def") (("1" (replace -1 :hide? t) (("1" (flatten) (("1" (name-replace "G1" "ccg_to_mwg(G!1)(f!1)" :hide? nil) (("1" (copy -1) (("1" (expand "ccg_to_mwg" -1) (("1" (expand "make_c_wdg") (("1" (decompose-equality -1) (("1" (hide -2) (("1" (invoke (typepred "%1") (! -2 1)) (("1" (expand "weight") (("1" (name "a" "i+1") (("1" (name "edg" "(w!1`seq(i), w!1`seq(a))") (("1" (assert) (("1" (hide -3) (("1" (inst -3 "edg") (("1" (invoke (case "form_matfun(%1) = form_matfun(%2)") (! -3 1) (! -3 2)) (("1" (hide -4) (("1" (decompose-equality -1) (("1" (case "1 = get(get_wgt(G1,(edg)))(mc!1`seq(i),mc!1`seq(1 + i))") (("1" (hide -2) (("1" (lemma "wgt_walk_decomposed") (("1" (inst-cp -1 "G1" "i" "w!1") (("1" (assert) (("1" (inst -1 "G1" "1" "w!1 ^ (i, length(w!1) - 1)") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (expand "^" -1 1) (("1" (expand "min") (("1" (expand "^" -1 6) (("1" (expand "min") (("1" (case-replace "w!1 ^ (i, length(w!1) - 1) ^ (0, 1) = w!1 ^ (i,a)") (("1" (case-replace "w!1 ^ (i, length(w!1) - 1) ^ (1, w!1`length - 1 - i)
                                                                                                                                                         = w!1 ^ (a, length(w!1) - 1)") (("1" (hide -1 -2) (("1" (replace -5 -1 rl) (("1" (replace -1) (("1" (hide -1) (("1" (expand "wgt_walk" -1 3) (("1" (expand "wgt_aux") (("1" (assert) (("1" (expand "^" -1 2) (("1" (expand "min") (("1" (expand "^" -1 (3 5 7)) (("1" (expand "min") (("1" (expand "^" -1 (3 4)) (("1" (expand "wgt_aux") (("1" (lemma "id_is_identity") (("1" (expand "identity?") (("1" (inst -1 "get_wgt(G1,(w!1`seq(i), w!1`seq(a)))") (("1" (flatten) (("1" (replace -6 -2 rl) (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "gte_mc_sub_walk") (("1" (inst-cp -1 "G!1" "w!1" "0" "i" "mc!1") (("1" (inst -1 "G!1" "w!1" "a" "length(w!1) - 1" "mc!1") (("1" (assert) (("1" (lemma "gte_mc_to_defined_pos") (("1" (inst-cp -1 "G!1" "f!1" "w!1 ^ (0, i)" "mc!1 ^ (0, i)") (("1" (inst -1 "G!1" "f!1" "w!1 ^ (a, length(w!1) - 1)" "mc!1 ^ (a, length(w!1) - 1)") (("1" (replace -10) (("1" (assert) (("1" (expand "^" -1 (2 3 4)) (("1" (expand "^" -2 (2 3 4)) (("1" (expand "min") (("1" (lemma "defined_pos?_def") (("1" (inst? -1 :where -2) (("1" (replace -1 :hide? t) (("1" (lemma "defined_pos?_def") (("1" (inst? -1 :where -3) (("1" (replace -1 :hide? t) (("1" (flatten) (("1" (name-replace "Mw1" "wgt_walk(G1, w!1 ^ (0, i))") (("1" (replace -6) (("1" (name-replace "Mw2" "wgt_walk(G1, w!1 ^ (a, length(w!1) - 1))") (("1" (replace -5) (("1" (name-replace "Medg" "get_wgt(G1,edg)") (("1" (replace -3) (("1" (hide -1 -2 -3 -5 -6 -7 -8 -9 -10 3) (("1" (name-replace "k0" "mc!1`seq(0)") (("1" (name-replace "kn" "mc!1`seq(length(w!1) - 1)") (("1" (name-replace "ki" "mc!1`seq(i)") (("1" (name-replace "kj" "mc!1`seq(a)") (("1" (lemma "positive_pos_mul") (("1" (inst-cp -1 "Mw1" "Medg * Mw2" "k0" "ki" "kn") (("1" (inst -1 "Medg" "Mw2" "ki" "kj" "kn") (("1" (expand "Plus3") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7 1 rl) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil) ("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (typepred "w!1") (("4" (hide-all-but (-2 1 -6)) (("4" (replace -2 1 rl) (("4" (hide -2) (("4" (expand "walk?") (("4" (assert) (("4" (flatten) (("4" (inst -2 "i") (("4" (assert) (("4" (expand "edge?") (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand* "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand* "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "mc!1`seq(i)") (("2" (decompose-equality -1) (("1" (inst -1 "mc!1`seq(a)") (("1" (replace -3 -1 rl) (("1" (typepred "f!1") (("1" (expand "indi_f_complete") (("1" (inst? -1) (("1" (reveal -4) (("1" (replace -7 1 :hide? t :dir rl) (("1" (replace -1 :hide? t) (("1" (use "get_form_matrix") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "w!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "id_is_identity") nil nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "measure_matrix_assoc") nil nil)) nil) ("5" (replace -4 :dir rl) (("5" (typepred "w!1") (("5" (hide-all-but (-2 1)) (("5" (expand "edg") (("5" (expand "walk?") (("5" (flatten) (("5" (inst -2 "i") (("5" (expand "a") (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide-all-but 1) (("3" (use "id_is_identity") nil nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (expand "edg") (("2" (typepred "w!1") (("2" (hide-all-but (-2 1)) (("2" (expand "a") (("2" (expand "walk?") (("2" (flatten) (("2" (inst -2 "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "a") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Expr formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (CallingContext type-eq-decl nil cc_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (MT formal-type-decl nil ccg_to_mwg nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (indi_f_complete const-decl "bool" ccg_to_mwg nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (< const-decl "bool" reals nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (measures_combination type-eq-decl nil ccg nil) (edges const-decl "bool" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (defined_pos?_def formula-decl nil measures nil) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil naturalnumbers nil) (identity? const-decl "bool" operator_defs nil) (associative? const-decl "bool" operator_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (eq const-decl "bool" measures nil) (Measure_Mat_Fn type-eq-decl nil measures nil) (get_form_matrix formula-decl nil measures nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (^ const-decl "finseq" finite_sequences nil) (walk?_caret formula-decl nil walks_ digraphs) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (wgt_aux def-decl "Weight" weighted_digraphs_ digraphs) (id_is_identity formula-decl nil measures nil) (f!1 skolem-const-decl "(indi_f_complete(G!1))" ccg_to_mwg nil) (G1 skolem-const-decl "{W: wgd_type |
   dg(W) = dg(G!1) AND
    FORALL (e: (edges(dg(G!1)))): get_wgt(W, e) = weight(G!1)(f!1)(e)}" ccg_to_mwg nil) (w!1 skolem-const-decl "Walk[CallingContext[Val, Expr, Condition, NodeId],
     digraph_type[CallingContext[Val, Expr, Condition, NodeId]],
     digraph_verts, digraph_edges, digraph_size, digraph_make](dg(G!1))" ccg_to_mwg nil) (i skolem-const-decl "below(length(w!1) - 1)" ccg_to_mwg nil) (a skolem-const-decl "posint" ccg_to_mwg nil) (measure_matrix_assoc formula-decl nil measures nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (Plus3 const-decl "Sign3" measures nil) (positive_pos_mul formula-decl nil measures nil) (gte_mc_sub_walk formula-decl nil ccg nil) (verts_in? const-decl "bool" walks_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (wgt_walk_decomposed formula-decl nil weighted_digraphs_ digraphs) (get const-decl "Sign3" measures nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (nth def-decl "T" list_props nil) (member def-decl "bool" list_props nil) (edg skolem-const-decl "[CallingContext[Val, Expr, Condition, NodeId],
 CallingContext[Val, Expr, Condition, NodeId]]" ccg_to_mwg nil) (G!1 skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (vert const-decl "bool" c_digraphs_def digraphs) (posint nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (gte_mc_to_defined_pos formula-decl nil ccg_to_mwg nil) (positive_pos? const-decl "bool" measures nil) (gt_mc? const-decl "bool" ccg nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil) (gt_mc_to_positive_pos-2 nil 3631659789 ("" (auto-rewrite "finseq_appl") (("" (skosimp*) (("" (assert) (("" (flatten) (("" (expand* "positive_pos?" "gt_mc?") (("" (flatten) (("" (assert) (("" (skeep) (("" (lemma "gte_mc_to_defined_pos") (("" (inst -1 "G!1" "w!1" "mc!1") (("" (assert) (("" (expand "defined_pos?") (("" (flatten) (("" (name-replace "G1" "ccg_to_mwg(G!1)" :hide? nil) (("" (copy -1) (("" (expand "ccg_to_mwg" -1) (("" (decompose-equality -1) (("" (expand "weight") (("" (decompose-equality -2) (("1" (name "a" "i+1") (("1" (name "edg" "(w!1`seq(i), w!1`seq(a))") (("1" (assert) (("1" (inst -3 "edg") (("1" (decompose-equality -3) (("1" (expand "indi_func") (("1" (inst -1 "mc!1`seq(i)") (("1" (decompose-equality -1) (("1" (inst -1 "mc!1`seq(a)") (("1" (replace -3 -1 rl) (("1" (assert) (("1" (lemma "wgt_walk_decomposed") (("1" (inst-cp -1 "G1" "i" "w!1") (("1" (assert) (("1" (inst -1 "G1" "1" "w!1 ^ (i, length(w!1) - 1)") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (expand "^" -1 1) (("1" (expand "min") (("1" (expand "^" -1 6) (("1" (expand "min") (("1" (case-replace "w!1 ^ (i, length(w!1) - 1) ^ (0, 1) = w!1 ^ (i,a)") (("1" (case-replace "w!1 ^ (i, length(w!1) - 1) ^ (1, w!1`length - 1 - i)
                                             = w!1 ^ (a, length(w!1) - 1)") (("1" (hide -1 -2) (("1" (replace -5 -1 rl) (("1" (replace -1) (("1" (hide -1) (("1" (expand "wgt_walk" -1 3) (("1" (expand "wgt_aux") (("1" (assert) (("1" (expand "^" -1 2) (("1" (expand "min") (("1" (expand "^" -1 (3 5 7)) (("1" (expand "min") (("1" (expand "^" -1 (3 4)) (("1" (expand "wgt_aux") (("1" (lemma "id_is_identity") (("1" (expand "identity?") (("1" (inst -1 "wgt(G1)(w!1`seq(i), w!1`seq(a))") (("1" (flatten) (("1" (replace -6 -2 rl) (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "gte_mc_sub_walk") (("1" (inst-cp -1 "G!1" "w!1" "0" "i" "mc!1") (("1" (inst -1 "G!1" "w!1" "a" "length(w!1) - 1" "mc!1") (("1" (assert) (("1" (lemma "gte_mc_to_defined_pos") (("1" (inst-cp -1 "G!1" "w!1 ^ (0, i)" "mc!1 ^ (0, i)") (("1" (inst -1 "G!1" "w!1 ^ (a, length(w!1) - 1)" "mc!1 ^ (a, length(w!1) - 1)") (("1" (replace -10) (("1" (assert) (("1" (expand "^" -1 (2 3 4)) (("1" (expand "^" -2 (2 3 4)) (("1" (expand "min") (("1" (expand "defined_pos?") (("1" (flatten) (("1" (name-replace "Mw1" "wgt_walk(G1, w!1 ^ (0, i))") (("1" (replace -6) (("1" (name-replace "Mw2" "wgt_walk(G1, w!1 ^ (a, length(w!1) - 1))") (("1" (replace -5) (("1" (name-replace "Medg" "wgt(G1)(edg)") (("1" (replace -3) (("1" (hide -1 -2 -3 -5 -6 -7 -8 -9 -10 3) (("1" (name-replace "k0" "mc!1`seq(0)") (("1" (name-replace "kn" "mc!1`seq(length(w!1) - 1)") (("1" (name-replace "ki" "mc!1`seq(i)") (("1" (name-replace "kj" "mc!1`seq(a)") (("1" (lemma "positive_pos_mul") (("1" (inst-cp -1 "Mw1" "Medg * Mw2" "k0" "ki" "kn") (("1" (inst -1 "Medg" "Mw2" "ki" "kj" "kn") (("1" (expand "MPlus") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7 1 rl) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil) ("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "w!1") (("2" (hide-all-but (-2 1 -6)) (("2" (replace -2 1 rl) (("2" (hide -2) (("2" (expand "walk?") (("2" (assert) (("2" (flatten) (("2" (inst -2 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand* "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand* "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4 1 rl) (("2" (assert) (("2" (typepred "w!1") (("2" (hide-all-but (-2 -9 1)) (("2" (expand "walk?") (("2" (flatten) (("2" (hide -2) (("2" (expand "verts_in?") (("2" (inst -1 "i") (("2" (expand "vert?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1 rl) (("2" (replace -2 1 rl) (("2" (typepred "w!1") (("2" (hide-all-but (-2 1)) (("2" (expand "walk?") (("2" (assert) (("2" (flatten) (("2" (inst -2 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1 rl) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (hide-all-but (-1 -6 1)) (("2" (expand "edge?") (("2" (expand "vert?") (("2" (typepred "dg(G!1)") (("2" (inst -1 "(x!1`1, x!1`2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((CallingContext type-eq-decl nil cc_def nil) (defined_pos? const-decl "bool" measures nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (positive_pos_mul formula-decl nil measures nil) (positive_pos? const-decl "bool" measures nil)) nil) (gt_mc_to_positive_pos-1 nil 3589734556 ("" (auto-rewrite "finseq_appl") (("" (skosimp*) (("" (assert) (("" (flatten) (("" (expand* "positive_pos?" "gt_mc?") (("" (flatten) (("" (assert) (("" (skeep) (("" (lemma "gte_mc_to_defined_pos") (("" (inst -1 "G!1" "w!1" "mc!1") (("" (assert) (("" (expand "defined_pos?") (("" (flatten) (("" (name-replace "G1" "ccg_to_mwg(G!1)" :hide? nil) (("" (copy -1) (("" (expand "ccg_to_mwg" -1) (("" (decompose-equality -1) (("" (expand "weight") (("" (decompose-equality -2) (("1" (name "a" "number_fields.+(i,1)") (("1" (name "edg" "(w!1`seq(i), w!1`seq(a))") (("1" (assert) (("1" (inst -3 "edg") (("1" (decompose-equality -3) (("1" (expand "indi_func") (("1" (inst -1 "mc!1`seq(i)") (("1" (decompose-equality -1) (("1" (inst -1 "mc!1`seq(a)") (("1" (replace -3 -1 rl) (("1" (assert) (("1" (lemma "wgt_walk_decomposed") (("1" (inst-cp -1 "G1" "i" "w!1") (("1" (assert) (("1" (inst -1 "G1" "1" "w!1 ^ (i, length(w!1) - 1)") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (expand "^" -1 1) (("1" (expand "min") (("1" (expand "^" -1 6) (("1" (expand "min") (("1" (case-replace "w!1 ^ (i, length(w!1) - 1) ^ (0, 1) = w!1 ^ (i,a)") (("1" (case-replace "w!1 ^ (i, length(w!1) - 1) ^ (1, w!1`length - 1 - i)
                                 = w!1 ^ (a, length(w!1) - 1)") (("1" (hide -1 -2) (("1" (replace -5 -1 rl) (("1" (replace -1) (("1" (hide -1) (("1" (expand "wgt_walk" -1 3) (("1" (expand "wgt_aux") (("1" (assert) (("1" (expand "^" -1 2) (("1" (expand "min") (("1" (expand "^" -1 (3 5 7)) (("1" (expand "min") (("1" (expand "^" -1 (3 4)) (("1" (expand "wgt_aux") (("1" (lemma "id_is_identity") (("1" (expand "identity?") (("1" (inst -1 "wgt(G1)(w!1`seq(i), w!1`seq(a))") (("1" (flatten) (("1" (replace -6 -2 rl) (("1" (replace -2) (("1" (hide -1 -2) (("1" (lemma "gte_mc_sub_walk") (("1" (inst-cp -1 "G!1" "w!1" "0" "i" "mc!1") (("1" (inst -1 "G!1" "w!1" "a" "length(w!1) - 1" "mc!1") (("1" (assert) (("1" (lemma "gte_mc_to_defined_pos") (("1" (inst-cp -1 "G!1" "w!1 ^ (0, i)" "mc!1 ^ (0, i)") (("1" (inst -1 "G!1" "w!1 ^ (a, length(w!1) - 1)" "mc!1 ^ (a, length(w!1) - 1)") (("1" (replace -10) (("1" (assert) (("1" (expand "^" -1 (2 3 4)) (("1" (expand "^" -2 (2 3 4)) (("1" (expand "min") (("1" (expand "defined_pos?") (("1" (flatten) (("1" (name-replace "Mw1" "wgt_walk(G1, w!1 ^ (0, i))") (("1" (replace -6) (("1" (name-replace "Mw2" "wgt_walk(G1, w!1 ^ (a, length(w!1) - 1))") (("1" (replace -5) (("1" (name-replace "Medg" "wgt(G1)(edg)") (("1" (replace -3) (("1" (hide -1 -2 -3 -5 -6 -7 -8 -9 -10 3) (("1" (name-replace "k0" "mc!1`seq(0)") (("1" (name-replace "kn" "mc!1`seq(length(w!1) - 1)") (("1" (name-replace "ki" "mc!1`seq(i)") (("1" (name-replace "kj" "mc!1`seq(a)") (("1" (lemma "positive_pos_mul") (("1" (inst-cp -1 "Mw1" "Medg * Mw2" "k0" "ki" "kn") (("1" (inst -1 "Medg" "Mw2" "ki" "kj" "kn") (("1" (expand "+") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -7 1 rl) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil) ("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "w!1") (("2" (hide-all-but (-2 1 -6)) (("2" (replace -2 1 rl) (("2" (hide -2) (("2" (expand "walk?") (("2" (assert) (("2" (flatten) (("2" (inst -2 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-6 1)) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand* "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand* "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -4 1 rl) (("2" (assert) (("2" (typepred "w!1") (("2" (hide-all-but (-2 -9 1)) (("2" (expand "walk?") (("2" (flatten) (("2" (hide -2) (("2" (expand "verts_in?") (("2" (inst -1 "i") (("2" (expand "vert?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1 rl) (("2" (replace -2 1 rl) (("2" (typepred "w!1") (("2" (hide-all-but (-2 1)) (("2" (expand "walk?") (("2" (assert) (("2" (flatten) (("2" (inst -2 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -1 1 rl) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "x!1") (("2" (hide-all-but (-1 -6 1)) (("2" (expand "edge?") (("2" (expand "vert?") (("2" (typepred "dg(G!1)") (("2" (inst -1 "(x!1`1, x!1`2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((CallingContext type-eq-decl nil cc_def nil) (defined_pos? const-decl "bool" measures nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (id_is_identity formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (positive_pos_mul formula-decl nil measures nil) (+ const-decl "Measure_Matrix" measures nil) (Sign3 type-eq-decl nil sign3 reals) (positive_pos? const-decl "bool" measures nil)) shostak)) (positive_pos_to_gt_mc_TCC1 0 (positive_pos_to_gt_mc_TCC1-2 "" 3790335277 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (get const-decl "Sign3" measures nil) (positive_pos? const-decl "bool" measures nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (gt_mc? const-decl "bool" ccg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (positive_pos_to_gt_mc subtype "ccg_to_mwg.mc" "not_empty_seq[below[N]]")) (positive_pos_to_gt_mc_TCC1-1 nil 3590516191 ("" (tcc)) ((CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (get const-decl "Sign3" measures nil) (positive_pos? const-decl "bool" measures nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (gt_mc? const-decl "bool" ccg nil)) nil (positive_pos_to_gt_mc subtype "ccg_to_mwg.mc" "not_empty_seq[below[N]]"))) (positive_pos_to_gt_mc 0 (positive_pos_to_gt_mc-4 nil 3651485087 ("" (auto-rewrite "finseq_appl") (("" (skolem 1 ("G" "f" "_")) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (measure-induct+ "length(w)" ("w")) (("1" (skeep) (("1" (case "length(x!1) = 1 OR length(x!1) = 2") (("1" (split) (("1" (hide-all-but (-1 -3)) (("1" (expand "wgt_walk") (("1" (expand "wgt_aux") (("1" (assert) (("1" (expand "positive_pos?") (("1" (use "id_def") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positive_pos?") (("2" (expand "wgt_walk" -3) (("2" (expand "wgt_aux") (("2" (replace -1) (("2" (assert) (("2" (expand "wgt_aux") (("2" (hide -2) (("2" (lemma "id_is_identity") (("2" (expand "identity?") (("2" (inst -1 "get_wgt(G1,(x!1`seq(0), x!1`seq(1)))") (("1" (flatten) (("1" (replace -2) (("1" (hide -1 -2) (("1" (expand "gt_mc?") (("1" (assert) (("1" (lemma "defined_pos_to_gte_mc") (("1" (inst -1 "G" "f" "x!1") (("1" (replace -4) (("1" (assert) (("1" (inst -1 "i" "j") (("1" (lemma "defined_pos?_def") (("1" (inst? -1 :where -2) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (expand "wgt_walk") (("1" (expand "wgt_aux") (("1" (replace -2) (("1" (assert) (("1" (skeep) (("1" (inst 1 "mc") (("1" (assert) (("1" (expand "gte_mc?") (("1" (assert) (("1" (inst -1 "0") (("1" (inst 1 "0") (("1" (assert) (("1" (invoke (typepred "%1") (! -6 1)) (("1" (hide -7) (("1" (expand "weight") (("1" (hide -1) (("1" (inst -1 "(x!1`seq(0), x!1`seq(1))") (("1" (invoke (case "form_matfun(%1) = form_matfun(%2)") (! -1 1) (! -1 2)) (("1" (hide -2) (("1" (decompose-equality -1) (("1" (inst -1 "i") (("1" (decompose-equality -1) (("1" (inst -1 "j") (("1" (reveal -3) (("1" (typepred "f") (("1" (expand "indi_f_sound") (("1" (inst? -1) (("1" (expand* "last" "first") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide-all-but 1) (("3" (use "id_is_identity") nil nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "x!1") (("2" (expand "walk?") (("2" (flatten) (("2" (inst -3 "0") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "wgt_walk_decomposed") (("2" (inst -1 "G1" "1" "x!1") (("2" (assert) (("2" (lemma "same_walks") (("2" (inst -1 "G" "x!1" "f") (("2" (assert) (("2" (hide -1) (("2" (replaces -1) (("2" (lemma "positive_pos_decomposition") (("2" (inst -1 "wgt_walk(G1, x!1 ^ (0, 1))" "wgt_walk(G1, x!1 ^ (1, length(x!1) - 1))" "i" "j") (("1" (expand "positive_pos?") (("1" (assert) (("1" (skeep) (("1" (expand "Plus3" -1) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (inst -2 "x!1 ^ (0, 1)") (("1" (assert) (("1" (expand "^" -2 1) (("1" (expand "min") (("1" (assert) (("1" (inst -2 "i" "k") (("1" (assert) (("1" (skeep) (("1" (lemma "defined_pos_to_gte_mc") (("1" (inst -1 "G" "f" "x!1 ^ (1, length(x!1) - 1)") (("1" (replace -7) (("1" (assert) (("1" (inst -1 "k" "j") (("1" (lemma "defined_pos?_def") (("1" (inst? -1 :where -2) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (skeep) (("1" (lemma "gt_mc_comp") (("1" (inst -1 "G" "x!1 ^ (0, 1)" "x!1 ^ (1, length(x!1) - 1)" "mc" "mc!1") (("1" (assert) (("1" (expand "gt_mc?" -6) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand* "last" "first") (("1" (assert) (("1" (expand "^" -1 (1 2 3)) (("1" (expand "min") (("1" (case-replace "x!1 ^ (0, 1) o rest(x!1 ^ (1, length(x!1) - 1)) = x!1") (("1" (hide -1) (("1" (inst 5 "mc o rest(mc!1)") (("1" (assert) (("1" (hide-all-but (-3 -4 -8 -9 3 4 5)) (("1" (typepred "mc" "mc!1") (("1" (expand "^") (("1" (expand "min") (("1" (expand "o") (("1" (assert) (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil) ("2" (inst -2 "x!1 ^ (1, length(x!1) - 1)") (("1" (inst -2 "k" "j") (("1" (assert) (("1" (expand "^" -2 1) (("1" (expand "min") (("1" (skeep) (("1" (lemma "defined_pos_to_gte_mc") (("1" (inst -1 "G" "f" "x!1 ^ (0, 1)") (("1" (replace -7) (("1" (assert) (("1" (inst -1 "i" "k") (("1" (lemma "defined_pos?_def") (("1" (inst? -1 :where -2) (("1" (replace -1 :hide? t) (("1" (assert) (("1" (skeep) (("1" (lemma "gt_mc_comp") (("1" (inst -1 "G" "x!1 ^ (0, 1)" "x!1 ^ (1, length(x!1) - 1)" "mc!1" "mc") (("1" (assert) (("1" (expand "gt_mc?" -6) (("1" (flatten) (("1" (assert) (("1" (expand "last" -1) (("1" (expand "first" -1) (("1" (assert) (("1" (expand "^" -1 (1 2 3)) (("1" (expand "min") (("1" (inst 5 "mc!1 o rest(mc)") (("1" (case-replace "x!1 ^ (0, 1) o rest(x!1 ^ (1, length(x!1) - 1)) = x!1") (("1" (assert) (("1" (hide-all-but (-4 -5 -9 -10 3 4 5)) (("1" (expand* "last" "first") (("1" (assert) (("1" (typepred "mc!1" "mc") (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "mc!1" "mc") (("2" (expand* "o" "rest" "^" "min") (("2" (replaces -1) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (hide-all-but 1) (("4" (rewrite "id_is_identity") nil nil)) nil) ("5" (hide-all-but 1) (("5" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((same_walks formula-decl nil ccg_to_mwg nil) (TRUE const-decl "bool" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (^ const-decl "finseq" finite_sequences nil) (Plus3 const-decl "Sign3" measures nil) (mc skolem-const-decl "measures_combination
    [Val, Expr, Condition, NodeId, MT, lt, N, semantic_rel, eval_conds](x!1
                                                                        ^
                                                                        (1,
                                                                         length
                                                                         (x!1)
                                                                         -
                                                                         1))" ccg_to_mwg nil) (mc!1 skolem-const-decl "measures_combination
    [Val, Expr, Condition, NodeId, MT, lt, N, semantic_rel, eval_conds](x!1
                                                                        ^
                                                                        (0,
                                                                         1))" ccg_to_mwg nil) (gt_mc_comp formula-decl nil ccg nil) (walk?_caret formula-decl nil walks_ digraphs) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (O const-decl "finseq" finite_sequences nil) (rest const-decl "finseq" seq_extras structures) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (positive_pos_decomposition formula-decl nil measures nil) (wgt_walk_decomposed formula-decl nil weighted_digraphs_ digraphs) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (id_def formula-decl nil measures nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (id_fun const-decl "Sign3" measures nil) (array2list_it def-decl "{l: listn(n - i) | FORALL (j: subrange(i, n - 1)): a(j) = nth(l, j - i)}" array2list structures) (array2list const-decl "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" array2list structures) (append def-decl "list[T]" list_props nil) (^ def-decl "list[T]" more_list_props structures) (form_matrix const-decl "{m: Measure_Matrix | eq(m, f)}" measures nil) (get const-decl "Sign3" measures nil) (wgt_aux def-decl "Weight" weighted_digraphs_ digraphs) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (id_is_identity formula-decl nil measures nil) (defined_pos_to_gte_mc formula-decl nil ccg_to_mwg nil) (gte_mc? const-decl "bool" ccg nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (verts_in? const-decl "bool" walks_ digraphs) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (eq const-decl "bool" measures nil) (Measure_Mat_Fn type-eq-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (nth def-decl "T" list_props nil) (member def-decl "bool" list_props nil) (x!1 skolem-const-decl "Walk[CallingContext[Val, Expr, Condition, NodeId],
     digraph_type[CallingContext[Val, Expr, Condition, NodeId]],
     digraph_verts, digraph_edges, digraph_size, digraph_make](dg(G))" ccg_to_mwg nil) (vert const-decl "bool" c_digraphs_def digraphs) (NOT const-decl "[bool -> bool]" booleans nil) (defined_pos?_def formula-decl nil measures nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (last const-decl "T" seq_extras structures) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (/= const-decl "boolean" notequal nil) (gt_mc? const-decl "bool" ccg nil) (FunMeasure type-eq-decl nil ccg_def nil) (measures_combination type-eq-decl nil ccg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (positive_pos? const-decl "bool" measures nil) (identity? const-decl "bool" operator_defs nil) (associative? const-decl "bool" operator_defs nil) (below type-eq-decl nil naturalnumbers nil) (G skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (wf_nat formula-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (naturalnumber type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (indi_f_sound const-decl "bool" ccg_to_mwg nil) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (CCG type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil)) nil) (positive_pos_to_gt_mc-3 nil 3631708943 ("" (auto-rewrite "finseq_appl") (("" (skolem 1 ("G" "_")) (("" (name-replace "G1" "ccg_to_mwg(G)" :hide? nil) (("" (assert) (("" (measure-induct+ "length(w)" ("w")) (("1" (skeep) (("1" (case "length(x!1) = 1 OR length(x!1) = 2") (("1" (split) (("1" (hide-all-but (-1 -3)) (("1" (expand* "positive_pos?" "wgt_walk" "wgt_aux") (("1" (assert) (("1" (expand "id") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positive_pos?") (("2" (expand "wgt_walk" -3) (("2" (expand "wgt_aux") (("2" (replace -1) (("2" (assert) (("2" (expand "wgt_aux") (("2" (hide -2) (("2" (lemma "id_is_identity") (("2" (expand "identity?") (("2" (inst -1 "wgt(G1)(x!1`seq(0), x!1`seq(1))") (("2" (flatten) (("2" (replace -2) (("2" (hide -1 -2) (("2" (expand "gt_mc?") (("2" (assert) (("2" (lemma "defined_pos_to_gte_mc") (("2" (inst -1 "G" "x!1") (("2" (replace -4) (("2" (assert) (("2" (inst -1 "i" "j") (("2" (expand "defined_pos?") (("2" (assert) (("2" (expand "wgt_walk") (("2" (expand "wgt_aux") (("2" (replace -2) (("2" (assert) (("2" (skeep) (("2" (inst 1 "mc") (("2" (assert) (("2" (expand "gte_mc?") (("2" (assert) (("2" (inst -1 "0") (("2" (inst 1 "0") (("2" (assert) (("2" (expand "ccg_to_mwg") (("2" (decompose-equality -6) (("2" (expand "weight") (("2" (decompose-equality -2) (("1" (inst -1 "(x!1`seq(0), x!1`seq(1))") (("1" (decompose-equality -1) (("1" (inst -1 "i") (("1" (decompose-equality -1) (("1" (inst -1 "j") (("1" (replace -7) (("1" (expand "indi_func") (("1" (expand* "last" "first") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "x!1") (("2" (expand "walk?") (("2" (expand "verts_in?") (("2" (expand "vert?") (("2" (flatten) (("2" (hide -1 -3) (("2" (inst -1 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (typepred "x!1") (("2" (expand* "walk?" "verts_in?" "vert?") (("2" (flatten) (("2" (hide -1 -3) (("2" (inst -1 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (typepred "x!1") (("2" (expand "walk?") (("2" (assert) (("2" (flatten) (("2" (hide -1 -2) (("2" (inst -1 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (typepred "x!2") (("2" (expand "edge?") (("2" (expand "vert?") (("2" (typepred "dg(G)") (("2" (inst -1 "(x!2`1, x!2`2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "wgt_walk_decomposed") (("2" (inst -1 "G1" "1" "x!1") (("2" (assert) (("2" (lemma "same_walks") (("2" (inst -1 "G" "x!1") (("2" (assert) (("2" (hide -1) (("2" (replaces -1) (("2" (lemma "positive_pos_decomposition") (("2" (inst -1 "wgt_walk(G1, x!1 ^ (0, 1))" "wgt_walk(G1, x!1 ^ (1, length(x!1) - 1))" "i" "j") (("1" (expand "positive_pos?") (("1" (assert) (("1" (skeep) (("1" (expand "Plus3" -1) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (inst -2 "x!1 ^ (0, 1)") (("1" (assert) (("1" (expand "^" -2 1) (("1" (expand "min") (("1" (assert) (("1" (inst -2 "i" "k") (("1" (assert) (("1" (skeep) (("1" (lemma "defined_pos_to_gte_mc") (("1" (inst -1 "G" "x!1 ^ (1, length(x!1) - 1)") (("1" (replace -7) (("1" (assert) (("1" (inst -1 "k" "j") (("1" (expand "defined_pos?") (("1" (skeep) (("1" (lemma "gt_mc_comp") (("1" (inst -1 "G" "x!1 ^ (0, 1)" "x!1 ^ (1, length(x!1) - 1)" "mc" "mc!1") (("1" (assert) (("1" (expand "gt_mc?" -6) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand* "last" "first") (("1" (assert) (("1" (expand "^" -1 (1 2 3)) (("1" (expand "min") (("1" (case-replace "x!1 ^ (0, 1) o rest(x!1 ^ (1, length(x!1) - 1)) = x!1") (("1" (hide -1) (("1" (inst 5 "mc o rest(mc!1)") (("1" (assert) (("1" (hide-all-but (-3 -4 -8 -9 3 4 5)) (("1" (typepred "mc" "mc!1") (("1" (expand "^") (("1" (expand "min") (("1" (expand "o") (("1" (assert) (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil) ("2" (inst -2 "x!1 ^ (1, length(x!1) - 1)") (("1" (inst -2 "k" "j") (("1" (assert) (("1" (expand "^" -2 1) (("1" (expand "min") (("1" (skeep) (("1" (lemma "defined_pos_to_gte_mc") (("1" (inst -1 "G" "x!1 ^ (0, 1)") (("1" (replace -7) (("1" (assert) (("1" (inst -1 "i" "k") (("1" (expand "defined_pos?") (("1" (skeep) (("1" (lemma "gt_mc_comp") (("1" (inst -1 "G" "x!1 ^ (0, 1)" "x!1 ^ (1, length(x!1) - 1)" "mc!1" "mc") (("1" (assert) (("1" (expand "gt_mc?" -6) (("1" (flatten) (("1" (assert) (("1" (expand "last" -1) (("1" (expand "first" -1) (("1" (assert) (("1" (expand "^" -1 (1 2 3)) (("1" (expand "min") (("1" (inst 5 "mc!1 o rest(mc)") (("1" (case-replace "x!1 ^ (0, 1) o rest(x!1 ^ (1, length(x!1) - 1)) = x!1") (("1" (assert) (("1" (hide-all-but (-4 -5 -9 -10 3 4 5)) (("1" (expand* "last" "first") (("1" (assert) (("1" (typepred "mc!1" "mc") (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "mc!1" "mc") (("2" (expand* "o" "rest" "^" "min") (("2" (replaces -1) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (typepred "y!1") (("4" (hide-all-but (-2 -5 1)) (("4" (expand "ccg_to_mwg") (("4" (decompose-equality) (("4" (hide -2) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (rewrite "id_is_identity") nil nil)) nil) ("6" (hide-all-but 1) (("6" (rewrite "measure_matrix_assoc") nil nil)) nil) ("7" (hide-all-but (-1 1)) (("7" (expand "ccg_to_mwg") (("7" (decompose-equality) (("7" (hide -2) (("7" (typepred "w!1") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Plus3 const-decl "Sign3" measures nil) (measure_matrix_assoc formula-decl nil measures nil) (positive_pos_decomposition formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (defined_pos? const-decl "bool" measures nil) (positive_pos? const-decl "bool" measures nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (Sign3 type-eq-decl nil sign3 reals) (CallingContext type-eq-decl nil cc_def nil)) nil) (positive_pos_to_gt_mc-2 nil 3631659852 ("" (auto-rewrite "finseq_appl") (("" (skolem 1 ("G" "_")) (("" (name-replace "G1" "ccg_to_mwg(G)" :hide? nil) (("" (assert) (("" (measure-induct+ "length(w)" ("w")) (("1" (skeep) (("1" (case "length(x!1) = 1 OR length(x!1) = 2") (("1" (split) (("1" (hide-all-but (-1 -3)) (("1" (expand* "positive_pos?" "wgt_walk" "wgt_aux") (("1" (assert) (("1" (expand "id") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positive_pos?") (("2" (expand "wgt_walk" -3) (("2" (expand "wgt_aux") (("2" (replace -1) (("2" (assert) (("2" (expand "wgt_aux") (("2" (hide -2) (("2" (lemma "id_is_identity") (("2" (expand "identity?") (("2" (inst -1 "wgt(G1)(x!1`seq(0), x!1`seq(1))") (("2" (flatten) (("2" (replace -2) (("2" (hide -1 -2) (("2" (expand "gt_mc?") (("2" (assert) (("2" (lemma "defined_pos_to_gte_mc") (("2" (inst -1 "G" "x!1") (("2" (replace -4) (("2" (assert) (("2" (inst -1 "i" "j") (("2" (expand "defined_pos?") (("2" (assert) (("2" (expand "wgt_walk") (("2" (expand "wgt_aux") (("2" (replace -2) (("2" (assert) (("2" (skeep) (("2" (inst 1 "mc") (("2" (assert) (("2" (expand "gte_mc?") (("2" (assert) (("2" (inst -1 "0") (("2" (inst 1 "0") (("2" (assert) (("2" (expand "ccg_to_mwg") (("2" (decompose-equality -6) (("2" (expand "weight") (("2" (decompose-equality -2) (("1" (inst -1 "(x!1`seq(0), x!1`seq(1))") (("1" (decompose-equality -1) (("1" (inst -1 "i") (("1" (decompose-equality -1) (("1" (inst -1 "j") (("1" (replace -7) (("1" (expand "indi_func") (("1" (expand* "last" "first") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "x!1") (("2" (expand "walk?") (("2" (expand "verts_in?") (("2" (expand "vert?") (("2" (flatten) (("2" (hide -1 -3) (("2" (inst -1 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (typepred "x!1") (("2" (expand* "walk?" "verts_in?" "vert?") (("2" (flatten) (("2" (hide -1 -3) (("2" (inst -1 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (typepred "x!1") (("2" (expand "walk?") (("2" (assert) (("2" (flatten) (("2" (hide -1 -2) (("2" (inst -1 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (typepred "x!2") (("2" (expand "edge?") (("2" (expand "vert?") (("2" (typepred "dg(G)") (("2" (inst -1 "(x!2`1, x!2`2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "wgt_walk_decomposed") (("2" (inst -1 "G1" "1" "x!1") (("2" (assert) (("2" (lemma "same_walks") (("2" (inst -1 "G" "x!1") (("2" (assert) (("2" (hide -1) (("2" (replaces -1) (("2" (lemma "positive_pos_decomposition") (("2" (inst -1 "wgt_walk(G1, x!1 ^ (0, 1))" "wgt_walk(G1, x!1 ^ (1, length(x!1) - 1))" "i" "j") (("1" (expand "positive_pos?") (("1" (assert) (("1" (skeep) (("1" (expand "MPlus" -1) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (inst -2 "x!1 ^ (0, 1)") (("1" (assert) (("1" (expand "^" -2 1) (("1" (expand "min") (("1" (assert) (("1" (inst -2 "i" "k") (("1" (assert) (("1" (skeep) (("1" (lemma "defined_pos_to_gte_mc") (("1" (inst -1 "G" "x!1 ^ (1, length(x!1) - 1)") (("1" (replace -7) (("1" (assert) (("1" (inst -1 "k" "j") (("1" (expand "defined_pos?") (("1" (skeep) (("1" (lemma "gt_mc_comp") (("1" (inst -1 "G" "x!1 ^ (0, 1)" "x!1 ^ (1, length(x!1) - 1)" "mc" "mc!1") (("1" (assert) (("1" (expand "gt_mc?" -6) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand* "last" "first") (("1" (assert) (("1" (expand "^" -1 (1 2 3)) (("1" (expand "min") (("1" (case-replace "x!1 ^ (0, 1) o rest(x!1 ^ (1, length(x!1) - 1)) = x!1") (("1" (hide -1) (("1" (inst 5 "mc o rest(mc!1)") (("1" (assert) (("1" (hide-all-but (-3 -4 -8 -9 3 4 5)) (("1" (typepred "mc" "mc!1") (("1" (expand "^") (("1" (expand "min") (("1" (expand "o") (("1" (assert) (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil) ("2" (inst -2 "x!1 ^ (1, length(x!1) - 1)") (("1" (inst -2 "k" "j") (("1" (assert) (("1" (expand "^" -2 1) (("1" (expand "min") (("1" (skeep) (("1" (lemma "defined_pos_to_gte_mc") (("1" (inst -1 "G" "x!1 ^ (0, 1)") (("1" (replace -7) (("1" (assert) (("1" (inst -1 "i" "k") (("1" (expand "defined_pos?") (("1" (skeep) (("1" (lemma "gt_mc_comp") (("1" (inst -1 "G" "x!1 ^ (0, 1)" "x!1 ^ (1, length(x!1) - 1)" "mc!1" "mc") (("1" (assert) (("1" (expand "gt_mc?" -6) (("1" (flatten) (("1" (assert) (("1" (expand "last" -1) (("1" (expand "first" -1) (("1" (assert) (("1" (expand "^" -1 (1 2 3)) (("1" (expand "min") (("1" (inst 5 "mc!1 o rest(mc)") (("1" (case-replace "x!1 ^ (0, 1) o rest(x!1 ^ (1, length(x!1) - 1)) = x!1") (("1" (assert) (("1" (hide-all-but (-4 -5 -9 -10 3 4 5)) (("1" (expand* "last" "first") (("1" (assert) (("1" (typepred "mc!1" "mc") (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "mc!1" "mc") (("2" (expand* "o" "rest" "^" "min") (("2" (replaces -1) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (typepred "y!1") (("4" (hide-all-but (-2 -5 1)) (("4" (expand "ccg_to_mwg") (("4" (decompose-equality) (("4" (hide -2) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (rewrite "id_is_identity") nil nil)) nil) ("6" (hide-all-but 1) (("6" (rewrite "measure_matrix_assoc") nil nil)) nil) ("7" (hide-all-but (-1 1)) (("7" (expand "ccg_to_mwg") (("7" (decompose-equality) (("7" (hide -2) (("7" (typepred "w!1") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((measure_matrix_assoc formula-decl nil measures nil) (positive_pos_decomposition formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (defined_pos? const-decl "bool" measures nil) (positive_pos? const-decl "bool" measures nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (CallingContext type-eq-decl nil cc_def nil)) nil) (positive_pos_to_gt_mc-1 nil 3590611801 ("" (auto-rewrite "finseq_appl") (("" (skolem 1 ("G" "_")) (("" (name-replace "G1" "ccg_to_mwg(G)" :hide? nil) (("" (assert) (("" (measure-induct+ "length(w)" ("w")) (("1" (skeep) (("1" (case "length(x!1) = 1 OR length(x!1) = 2") (("1" (split) (("1" (hide-all-but (-1 -3)) (("1" (expand* "positive_pos?" "wgt_walk" "wgt_aux") (("1" (assert) (("1" (expand "id") (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "positive_pos?") (("2" (expand "wgt_walk" -3) (("2" (expand "wgt_aux") (("2" (replace -1) (("2" (assert) (("2" (expand "wgt_aux") (("2" (hide -2) (("2" (lemma "id_is_identity") (("2" (expand "identity?") (("2" (inst -1 "wgt(G1)(x!1`seq(0), x!1`seq(1))") (("2" (flatten) (("2" (replace -2) (("2" (hide -1 -2) (("2" (expand "gt_mc?") (("2" (assert) (("2" (lemma "defined_pos_to_gte_mc") (("2" (inst -1 "G" "x!1") (("2" (replace -4) (("2" (assert) (("2" (inst -1 "i" "j") (("2" (expand "defined_pos?") (("2" (assert) (("2" (expand "wgt_walk") (("2" (expand "wgt_aux") (("2" (replace -2) (("2" (assert) (("2" (skeep) (("2" (inst 1 "mc") (("2" (assert) (("2" (expand "gte_mc?") (("2" (assert) (("2" (inst -1 "0") (("2" (inst 1 "0") (("2" (assert) (("2" (expand "ccg_to_mwg") (("2" (decompose-equality -6) (("2" (expand "weight") (("2" (decompose-equality -2) (("1" (inst -1 "(x!1`seq(0), x!1`seq(1))") (("1" (decompose-equality -1) (("1" (inst -1 "i") (("1" (decompose-equality -1) (("1" (inst -1 "j") (("1" (replace -7) (("1" (expand "indi_func") (("1" (expand* "last" "first") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "x!1") (("2" (expand "walk?") (("2" (expand "verts_in?") (("2" (expand "vert?") (("2" (flatten) (("2" (hide -1 -3) (("2" (inst -1 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (typepred "x!1") (("2" (expand* "walk?" "verts_in?" "vert?") (("2" (flatten) (("2" (hide -1 -3) (("2" (inst -1 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (typepred "x!1") (("2" (expand "walk?") (("2" (assert) (("2" (flatten) (("2" (hide -1 -2) (("2" (inst -1 "0") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (typepred "x!2") (("2" (expand "edge?") (("2" (expand "vert?") (("2" (typepred "dg(G)") (("2" (inst -1 "(x!2`1, x!2`2)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "wgt_walk_decomposed") (("2" (inst -1 "G1" "1" "x!1") (("2" (assert) (("2" (lemma "same_walks") (("2" (inst -1 "G" "x!1") (("2" (assert) (("2" (hide -1) (("2" (replaces -1) (("2" (lemma "positive_pos_decomposition") (("2" (inst -1 "wgt_walk(G1, x!1 ^ (0, 1))" "wgt_walk(G1, x!1 ^ (1, length(x!1) - 1))" "i" "j") (("1" (expand "positive_pos?") (("1" (assert) (("1" (skeep) (("1" (expand "+" -1) (("1" (lift-if) (("1" (assert) (("1" (ground) (("1" (inst -2 "x!1 ^ (0, 1)") (("1" (assert) (("1" (expand "^" -2 1) (("1" (expand "min") (("1" (assert) (("1" (inst -2 "i" "k") (("1" (assert) (("1" (skeep) (("1" (lemma "defined_pos_to_gte_mc") (("1" (inst -1 "G" "x!1 ^ (1, length(x!1) - 1)") (("1" (replace -7) (("1" (assert) (("1" (inst -1 "k" "j") (("1" (expand "defined_pos?") (("1" (skeep) (("1" (lemma "gt_mc_comp") (("1" (inst -1 "G" "x!1 ^ (0, 1)" "x!1 ^ (1, length(x!1) - 1)" "mc" "mc!1") (("1" (assert) (("1" (expand "gt_mc?" -6) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (expand* "last" "first") (("1" (assert) (("1" (expand "^" -1 (1 2 3)) (("1" (expand "min") (("1" (case-replace "x!1 ^ (0, 1) o rest(x!1 ^ (1, length(x!1) - 1)) = x!1") (("1" (hide -1) (("1" (inst 5 "mc o rest(mc!1)") (("1" (assert) (("1" (hide-all-but (-3 -4 -8 -9 3 4 5)) (("1" (typepred "mc" "mc!1") (("1" (expand "^") (("1" (expand "min") (("1" (expand "o") (("1" (assert) (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil) ("2" (inst -2 "x!1 ^ (1, length(x!1) - 1)") (("1" (inst -2 "k" "j") (("1" (assert) (("1" (expand "^" -2 1) (("1" (expand "min") (("1" (skeep) (("1" (lemma "defined_pos_to_gte_mc") (("1" (inst -1 "G" "x!1 ^ (0, 1)") (("1" (replace -7) (("1" (assert) (("1" (inst -1 "i" "k") (("1" (expand "defined_pos?") (("1" (skeep) (("1" (lemma "gt_mc_comp") (("1" (inst -1 "G" "x!1 ^ (0, 1)" "x!1 ^ (1, length(x!1) - 1)" "mc!1" "mc") (("1" (assert) (("1" (expand "gt_mc?" -6) (("1" (flatten) (("1" (assert) (("1" (expand "last" -1) (("1" (expand "first" -1) (("1" (assert) (("1" (expand "^" -1 (1 2 3)) (("1" (expand "min") (("1" (inst 5 "mc!1 o rest(mc)") (("1" (case-replace "x!1 ^ (0, 1) o rest(x!1 ^ (1, length(x!1) - 1)) = x!1") (("1" (assert) (("1" (hide-all-but (-4 -5 -9 -10 3 4 5)) (("1" (expand* "last" "first") (("1" (assert) (("1" (typepred "mc!1" "mc") (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "mc!1" "mc") (("2" (expand* "o" "rest" "^" "min") (("2" (replaces -1) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (typepred "y!1") (("4" (hide-all-but (-2 -5 1)) (("4" (expand "ccg_to_mwg") (("4" (decompose-equality) (("4" (hide -2) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide-all-but 1) (("5" (rewrite "id_is_identity") nil nil)) nil) ("6" (hide-all-but 1) (("6" (rewrite "measure_matrix_assoc") nil nil)) nil) ("7" (hide-all-but (-1 1)) (("7" (expand "ccg_to_mwg") (("7" (decompose-equality) (("7" (hide -2) (("7" (typepred "w!1") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((+ const-decl "Measure_Matrix" measures nil) (measure_matrix_assoc formula-decl nil measures nil) (positive_pos_decomposition formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (Sign3 type-eq-decl nil sign3 reals) (defined_pos? const-decl "bool" measures nil) (positive_pos? const-decl "bool" measures nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (CallingContext type-eq-decl nil cc_def nil)) shostak)) (no_positive_pos_no_gt_mc 0 (no_positive_pos_no_gt_mc-3 "" 3885134128 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (prop) (("1" (skeep) (("1" (lemma "gt_mc_to_positive_pos") (("1" (inst -1 "G" "f" "w" "mc") (("1" (replace -4) (("1" (assert) (("1" (assert) (("1" (inst -2 "mc`seq(0)" "mc`seq(length(w) - 1)") nil nil)) nil)) nil)) nil) ("2" (typepred "f") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "positive_pos_to_gt_mc") (("2" (inst -1 "G" "f" "w") (("1" (replace -4) (("1" (assert) (("1" (inst -1 "i" "j") (("1" (assert) (("1" (skeep) (("1" (inst -4 "mc") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "f") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (no_positive_pos_no_gt_mc-2 nil 3651486233 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (prop) (("1" (skeep) (("1" (lemma "gt_mc_to_positive_pos") (("1" (inst -1 "G" "f" "w" "mc") (("1" (replace -4) (("1" (assert) (("1" (assert) (("1" (inst -2 "mc`seq(0)" "mc`seq(length(w) - 1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "positive_pos_to_gt_mc") (("2" (inst -1 "G" "f" "w") (("2" (replace -4) (("2" (assert) (("2" (inst -1 "i" "j") (("2" (assert) (("2" (skeep) (("2" (inst -4 "mc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (positive_pos_to_gt_mc formula-decl nil ccg_to_mwg nil) (indi_f_complete const-decl "bool" ccg_to_mwg nil) (G skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (f skolem-const-decl "(indi_f_sc(G))" ccg_to_mwg nil) (measures_combination type-eq-decl nil ccg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (< const-decl "bool" reals nil) (Walk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil naturalnumbers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (get const-decl "Sign3" measures nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (gt const-decl "bool" ccg nil) (indi_f_sound const-decl "bool" ccg_to_mwg nil) (gte_mc? const-decl "bool" ccg nil) (gt_mc? const-decl "bool" ccg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (positive_pos? const-decl "bool" measures nil) (NOT const-decl "[bool -> bool]" booleans nil) (gt_mc_to_positive_pos formula-decl nil ccg_to_mwg nil) (indi_f_sc const-decl "bool" ccg_to_mwg nil) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (CCG type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil)) nil) (no_positive_pos_no_gt_mc-1 nil 3589819870 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)" :hide? nil) (("" (assert) (("" (prop) (("1" (skeep) (("1" (lemma "gt_mc_to_positive_pos") (("1" (inst -1 "G" "w" "mc") (("1" (replace -4) (("1" (assert) (("1" (assert) (("1" (inst -2 "mc`seq(0)" "mc`seq(length(w) - 1)") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "positive_pos_to_gt_mc") (("2" (inst -1 "G" "w") (("2" (replace -4) (("2" (assert) (("2" (inst -1 "i" "j") (("2" (assert) (("2" (skeep) (("2" (inst -4 "mc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (Sign3 type-eq-decl nil sign3 reals) (CallingContext type-eq-decl nil cc_def nil)) shostak)) (positive_to_gt_mc_TCC1 0 (positive_to_gt_mc_TCC1-2 "" 3790335315 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (positive_to_gt_mc subtype "ccg_to_mwg.w" "Walk[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(ccg_to_mwg.G1))")) (positive_to_gt_mc_TCC1-1 nil 3651486432 ("" (tcc)) ((CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (positive_to_gt_mc subtype "ccg_to_mwg.w" "Walk[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(ccg_to_mwg.G1))"))) (positive_to_gt_mc_TCC2 0 (positive_to_gt_mc_TCC2-2 "" 3790335317 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (positive_to_gt_mc subtype "c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].get_wgt" "[[W: wgd_type[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]")) (positive_to_gt_mc_TCC2-1 nil 3651486432 ("" (tcc)) ((CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (positive_to_gt_mc subtype "c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].get_wgt" "[[W: wgd_type[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (positive_to_gt_mc_TCC3 0 (positive_to_gt_mc_TCC3-1 nil 3661857041 ("" (subtype-tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (positive_fun? const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (positive_to_gt_mc subtype "ccg_to_mwg.mc" "not_empty_seq[below[N]]"))) (positive_to_gt_mc 0 (positive_to_gt_mc-1 nil 3651486465 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (prop) (("" (lemma "positive_pos_to_gt_mc") (("" (inst -1 "G" "f" "w") (("" (replace -2) (("" (assert) (("" (expand* "positive?" "positive_pos?") (("" (expand "form_matfun") (("" (expand "positive_fun?") (("" (skeep) (("" (inst -1 "j_1" "j_1") (("" (assert) (("" (skeep) (("" (inst 1 "mc") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((positive_pos_to_gt_mc formula-decl nil ccg_to_mwg nil) (positive_pos? const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (positive_fun? const-decl "bool" measures nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (mc skolem-const-decl "measures_combination
    [Val, Expr, Condition, NodeId, MT, lt, N, semantic_rel, eval_conds](w)" ccg_to_mwg nil) (w skolem-const-decl "Walk[CallingContext[Val, Expr, Condition, NodeId],
     digraph_type[CallingContext[Val, Expr, Condition, NodeId]],
     digraph_verts, digraph_edges, digraph_size, digraph_make](dg(G))" ccg_to_mwg nil) (G skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (measures_combination type-eq-decl nil ccg nil) (/= const-decl "boolean" notequal nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (last const-decl "T" seq_extras structures) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (indi_f_sound const-decl "bool" ccg_to_mwg nil) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (CCG type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil)) shostak)) (gt_mc_to_positive_TCC1 0 (gt_mc_to_positive_TCC1-2 "" 3790335321 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (gt_mc_to_positive subtype "ccg_to_mwg.mc" "not_empty_seq[below[N]]")) (gt_mc_to_positive_TCC1-1 nil 3651486564 ("" (tcc)) ((CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs)) nil (gt_mc_to_positive subtype "ccg_to_mwg.mc" "not_empty_seq[below[N]]"))) (gt_mc_to_positive_TCC2 0 (gt_mc_to_positive_TCC2-2 "" 3790335324 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (gt_mc? const-decl "bool" ccg nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (gt_mc_to_positive subtype "ccg_to_mwg.w" "Walk[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(ccg_to_mwg.G1))")) (gt_mc_to_positive_TCC2-1 nil 3651486564 ("" (tcc)) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (gt_mc? const-decl "bool" ccg nil) (CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (gt_mc_to_positive subtype "ccg_to_mwg.w" "Walk[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(ccg_to_mwg.G1))"))) (gt_mc_to_positive_TCC3 0 (gt_mc_to_positive_TCC3-1 nil 3661857041 ("" (subtype-tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (le const-decl "bool" ccg_def nil) (ge const-decl "bool" ccg_def nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (gt_mc? const-decl "bool" ccg nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (gt_mc_to_positive subtype "c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].get_wgt" "[[W: wgd_type[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (gt_mc_to_positive 0 (gt_mc_to_positive-1 nil 3651486565 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (prop) (("" (skeep) (("" (typepred "mc") (("" (lemma "gt_mc_to_positive_pos") (("" (inst -1 "G" "f" "w" "mc") (("" (replace -4) (("" (assert) (("" (assert) (("" (expand* "last" "first") (("" (assert) (("" (name-replace "k" "mc`seq(0)") (("" (replace -2) (("" (replace -3 -1 rl) (("" (hide-all-but (-1 1)) (("" (expand* "positive_pos?" "positive?") (("" (expand "positive_fun?") (("" (expand "form_matfun") (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gt_mc_to_positive_pos formula-decl nil ccg_to_mwg nil) (positive_fun? const-decl "bool" measures nil) (below type-eq-decl nil naturalnumbers nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (positive_pos? const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (last const-decl "T" seq_extras structures) (first const-decl "T" seq_extras structures) (not_empty_seq type-eq-decl nil seq_extras structures) (/= const-decl "boolean" notequal nil) (measures_combination type-eq-decl nil ccg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (Walk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (indi_f_complete const-decl "bool" ccg_to_mwg nil) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (CCG type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil)) shostak)) (positive_iff_gt_mc_TCC1 0 (positive_iff_gt_mc_TCC1-2 "" 3790335328 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (positive_iff_gt_mc subtype "ccg_to_mwg.w" "Walk[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(ccg_to_mwg.G1))")) (positive_iff_gt_mc_TCC1-1 nil 3590489564 ("" (tcc)) ((CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (positive_iff_gt_mc subtype "ccg_to_mwg.w" "Walk[CallingContext[Val, Expr, Condition, NodeId], digraph_type[CallingContext[Val, Expr, Condition, NodeId]], c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_verts, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_size, c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_make](c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(ccg_to_mwg.G1))"))) (positive_iff_gt_mc_TCC2 0 (positive_iff_gt_mc_TCC2-2 "" 3790335334 ("" (tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (positive_iff_gt_mc subtype "c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].get_wgt" "[[W: wgd_type[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]")) (positive_iff_gt_mc_TCC2-1 nil 3651508011 ("" (tcc)) ((CallingContext type-eq-decl nil cc_def nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs)) nil (positive_iff_gt_mc subtype "c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].get_wgt" "[[W: wgd_type[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[CallingContext[Val, Expr, Condition, NodeId]].digraph_edges(c_weighted_digraphs_def[CallingContext[Val, Expr, Condition, NodeId], Measure_Matrix[N], measures[ccg_to_mwg.N].*, measures[ccg_to_mwg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (positive_iff_gt_mc_TCC3 0 (positive_iff_gt_mc_TCC3-1 nil 3661857041 ("" (subtype-tcc) nil nil) ((CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (positive_iff_gt_mc subtype "ccg_to_mwg.mc" "not_empty_seq[below[N]]"))) (positive_iff_gt_mc 0 (positive_iff_gt_mc-2 "" 3885134187 ("" (skeep) (("" (assert) (("" (prop) (("1" (use "positive_to_gt_mc") (("1" (assert) (("1" (assert) nil nil)) nil) ("2" (typepred "f") (("2" (grind) nil nil)) nil)) nil) ("2" (use "gt_mc_to_positive") (("1" (assert) (("1" (assert) nil nil)) nil) ("2" (typepred "f") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (positive_iff_gt_mc-1 nil 3590489606 ("" (skeep) (("" (assert) (("" (prop) (("1" (use "positive_to_gt_mc") (("1" (assert) (("1" (assert) nil nil)) nil)) nil) ("2" (use "gt_mc_to_positive") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((gt_mc_to_positive formula-decl nil ccg_to_mwg nil) (positive_to_gt_mc formula-decl nil ccg_to_mwg nil) (Walk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (CCG type-eq-decl nil ccg_def nil) (FunMeasures type-eq-decl nil ccg_def nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (vert? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (indi_f_sound const-decl "bool" ccg_to_mwg nil) (G skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (indi_f_sc const-decl "bool" ccg_to_mwg nil) (f skolem-const-decl "(indi_f_sc(G))" ccg_to_mwg nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (gt_mc? const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (positive? const-decl "bool" measures nil) (positive_fun? const-decl "bool" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (indi_f_complete const-decl "bool" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (ge const-decl "bool" ccg_def nil) (le const-decl "bool" ccg_def nil) (get const-decl "Sign3" measures nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak)) (mwg_termination_to_ccg_termination 0 (mwg_termination_to_ccg_termination-2 "" 3790335336 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (expand* "mwg_termination?" "ccg_termination?") (("" (lemma "positive_to_gt_mc") (("" (prop) (("" (skeep) (("" (inst -3 "c") (("" (inst -1 "G" "f" "c") (("" (replace -2) (("" (assert) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((positive_to_gt_mc formula-decl nil ccg_to_mwg nil) (Walk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (mwg_termination? const-decl "bool" matrix_wdg nil) (ccg_termination? const-decl "bool" ccg nil) (indi_f_sound const-decl "bool" ccg_to_mwg nil) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (CCG type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil)) shostak) (mwg_termination_to_ccg_termination-1 nil 3651486968 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (expand* "mwg_termination?" "ccg_termination?") (("" (lemma "positive_to_gt_mc") (("" (prop) (("" (skeep) (("" (inst -3 "c") (("1" (inst -1 "G" "f" "c") (("1" (replace -2) (("1" (assert) (("1" (assert) nil nil)) nil)) nil) ("2" (hide -1 2) (("2" (typepred "c") (("2" (expand* "circuit?" "pre_circuit?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (typepred "c") (("2" (expand "ccg_to_mwg") (("2" (assert) (("2" (expand "make_c_wdg") (("2" (decompose-equality -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((Walk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (mwg_termination? const-decl "bool" matrix_wdg nil) (ccg_termination? const-decl "bool" ccg nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CallingContext type-eq-decl nil cc_def nil)) shostak)) (ccg_termination_to_mwg_termination 0 (ccg_termination_to_mwg_termination-2 "" 3790335337 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (expand* "mwg_termination?" "ccg_termination?") (("" (lemma "gt_mc_to_positive") (("" (prop) (("" (skeep) (("" (inst -3 "c") (("" (inst -1 "G" "f" "c") (("1" (replace -3) (("1" (assert) nil nil)) nil) ("2" (hide -2 2) (("2" (typepred "c") (("2" (expand* "circuit?" "pre_circuit?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((gt_mc_to_positive formula-decl nil ccg_to_mwg nil) (c skolem-const-decl "{c |
   circuit?
       [CallingContext[Val, Expr, Condition, NodeId],
        digraph_type[CallingContext[Val, Expr, Condition, NodeId]],
        digraph_verts, digraph_edges, digraph_size, digraph_make]
       (dg(G1), c)}" ccg_to_mwg nil) (G1 skolem-const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (f skolem-const-decl "(indi_f_complete(G))" ccg_to_mwg nil) (G skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (walk? const-decl "bool" walks_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (NOT const-decl "[bool -> bool]" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (mwg_termination? const-decl "bool" matrix_wdg nil) (ccg_termination? const-decl "bool" ccg nil) (indi_f_complete const-decl "bool" ccg_to_mwg nil) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (weight const-decl "Measure_Matrix[N]" ccg_to_mwg nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (CCG type-eq-decl nil ccg_def nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (MT formal-type-decl nil ccg_to_mwg nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" ccg_to_mwg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CallingContext type-eq-decl nil cc_def nil) (Val formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil)) shostak) (ccg_termination_to_mwg_termination-1 nil 3651487435 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (name-replace "G1" "ccg_to_mwg(G)(f)" :hide? nil) (("" (assert) (("" (expand* "mwg_termination?" "ccg_termination?") (("" (lemma "gt_mc_to_positive") (("" (prop) (("" (skeep) (("" (inst -3 "c") (("1" (inst -1 "G" "f" "c") (("1" (replace -3) (("1" (assert) nil nil)) nil) ("2" (hide -2 2) (("2" (typepred "c") (("2" (expand* "circuit?" "pre_circuit?") (("2" (assert) (("2" (flatten) (("2" (hide -1 -3 -4) (("2" (expand "ccg_to_mwg") (("2" (assert) (("2" (expand "make_c_wdg") (("2" (decompose-equality -2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (typepred "c") (("2" (expand "ccg_to_mwg") (("2" (assert) (("2" (expand "make_c_wdg") (("2" (decompose-equality -3) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((walk? const-decl "bool" walks_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (mwg_termination? const-decl "bool" matrix_wdg nil) (ccg_termination? const-decl "bool" ccg nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (CCG type-eq-decl nil ccg_def nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (CallingContext type-eq-decl nil cc_def nil)) nil)) (mwg_termination_iff_ccg_termination 0 (mwg_termination_iff_ccg_termination-2 "" 3885134229 ("" (skeep) (("" (assert) (("" (prop) (("1" (use "mwg_termination_to_ccg_termination") (("1" (assert) (("1" (assert) nil nil)) nil) ("2" (typepred "f") (("2" (grind) nil nil)) nil)) nil) ("2" (use "ccg_termination_to_mwg_termination") (("1" (assert) (("1" (assert) nil nil)) nil) ("2" (typepred "f") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (mwg_termination_iff_ccg_termination-1 nil 3612599578 ("" (skeep) (("" (assert) (("" (prop) (("1" (use "mwg_termination_to_ccg_termination") (("1" (assert) (("1" (assert) nil nil)) nil)) nil) ("2" (use "ccg_termination_to_mwg_termination") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((ccg_termination_to_mwg_termination formula-decl nil ccg_to_mwg nil) (mwg_termination_to_ccg_termination formula-decl nil ccg_to_mwg nil) (Val formal-type-decl nil ccg_to_mwg nil) (Expr formal-type-decl nil ccg_to_mwg nil) (Condition formal-type-decl nil ccg_to_mwg nil) (NodeId formal-type-decl nil ccg_to_mwg nil) (MT formal-type-decl nil ccg_to_mwg nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (lt formal-const-decl "(well_founded?[MT])" ccg_to_mwg nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" ccg_to_mwg nil) (CCG type-eq-decl nil ccg_def nil) (CallingContext type-eq-decl nil cc_def nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (FunMeasures type-eq-decl nil ccg_def nil) (vert type-eq-decl nil digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (indi_f type-eq-decl nil ccg_to_mwg nil) (indi_f_sound const-decl "bool" ccg_to_mwg nil) (G skolem-const-decl "CCG[Val, Expr, Condition, NodeId, MT, lt, N]" ccg_to_mwg nil) (indi_f_sc const-decl "bool" ccg_to_mwg nil) (f skolem-const-decl "(indi_f_sc(G))" ccg_to_mwg nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (ccg_termination? const-decl "bool" ccg nil) (gt_mc? const-decl "bool" ccg nil) (gte_mc? const-decl "bool" ccg nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (mwg_termination? const-decl "bool" matrix_wdg nil) (positive? const-decl "bool" measures nil) (positive_fun? const-decl "bool" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (ccg_to_mwg const-decl "{W: wgd_type |
   dg(W) = dg(G) AND
    FORALL (e: (edges(dg(G)))): get_wgt(W, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (build_weights_list const-decl "{l: list[[CallingContext, CallingContext, Measure_Matrix]] |
   all_edges_in_map?(dg(G))(l) AND
    FORALL (e: (edges(dg(G)))): get_value(l, e) = weight(G)(f)(e)}" ccg_to_mwg nil) (edges_list const-decl "{l: list[(edges(cd))] |
   card(edges(cd)) = length[[T, T]](l) AND
    (FORALL (e: (edges(cd))): member[[T, T]](e, l)) AND
     no_repetitions?[[T, T]](l)}" c_digraphs_def digraphs) (indi_f_complete const-decl "bool" ccg_to_mwg nil) (gt const-decl "bool" ccg nil) (semantic_rel formal-const-decl "PRED[[Expr, Val, Val]]" ccg_to_mwg nil) (eval_conds formal-const-decl "PRED[[Condition, Val]]" ccg_to_mwg nil) (ge const-decl "bool" ccg_def nil) (le const-decl "bool" ccg_def nil) (get const-decl "Sign3" measures nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak)))
