(matrix_wdg (IMP_c_weighted_digraphs_TCC1 0 (IMP_c_weighted_digraphs_TCC1-2 nil 3661593825 ("" (rewrite "measure_matrix_assoc") nil nil) ((N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_matrix_assoc formula-decl nil measures nil)) nil (IMP_c_weighted_digraphs subtype "measures[matrix_wdg.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(matrix_wdg.f)}")) (IMP_c_weighted_digraphs_TCC1-1 nil 3661593386 ("" (subtype-tcc) nil nil) nil nil (IMP_c_weighted_digraphs subtype "measures[matrix_wdg.N].*" "{f: [[Measure_Matrix[N], Measure_Matrix[N]] -> Measure_Matrix[N]] | operator_defs[Measure_Matrix[N]].associative?(matrix_wdg.f)}"))) (IMP_c_weighted_digraphs_TCC2 0 (IMP_c_weighted_digraphs_TCC2-2 nil 3661593844 ("" (rewrite "id_is_identity") nil nil) ((N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (id_is_identity formula-decl nil measures nil)) nil (IMP_c_weighted_digraphs subtype "measures[matrix_wdg.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[matrix_wdg.N].*)(matrix_wdg.zero)}")) (IMP_c_weighted_digraphs_TCC2-1 nil 3661593386 ("" (subtype-tcc) nil nil) nil nil (IMP_c_weighted_digraphs subtype "measures[matrix_wdg.N].id" "{zero: Measure_Matrix[N] | operator_defs[Measure_Matrix[N]].identity?(measures[matrix_wdg.N].*)(matrix_wdg.zero)}"))) (mwg_termination?_TCC1 0 (mwg_termination?_TCC1-1 nil 3612569072 ("" (subtype-tcc) nil nil) ((wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (circuit? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (mwg_termination? subtype "matrix_wdg.c" "Walk[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(matrix_wdg.G))"))) (mwg_termination?_TCC2 0 (mwg_termination?_TCC2-1 nil 3661593386 ("" (subtype-tcc) nil nil) ((T formal-type-decl nil matrix_wdg nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (mwg_termination? subtype "c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[matrix_wdg.T].digraph_edges(c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (double_cycle?_TCC1 0 (double_cycle?_TCC1-1 nil 3579439673 ("" (subtype-tcc) nil nil) ((prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (> const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cycle? const-decl "bool" cycles_ digraphs) (T formal-type-decl nil matrix_wdg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (rest const-decl "finseq" seq_extras structures) (O const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (double_cycle? subtype "finite_sequences[matrix_wdg.T].o(matrix_wdg.c1, seq_extras[matrix_wdg.T].rest(matrix_wdg.c2))" "prewalk[T, digraph_type[T], digraph_verts[T], digraph_edges[T], digraph_size[T], digraph_make[T]]"))) (positive_double_cycle?_TCC1 0 (positive_double_cycle?_TCC1-1 nil 3579679885 ("" (skeep :preds? t) (("" (use "edges_of_subset") (("" (split -1) (("1" (expand "digraph_edges") (("1" (expand "subset?") (("1" (expand "member") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "double_cycle?") (("2" (flatten) (("2" (expand "circuit?") (("2" (flatten) (("2" (expand "pre_circuit?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((edges_of_subset formula-decl nil walks_ digraphs) (T formal-type-decl nil matrix_wdg nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (double_cycle? const-decl "bool" matrix_wdg nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (prewalk type-eq-decl nil walks_ digraphs) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (circuit? const-decl "bool" circuits_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (member const-decl "bool" sets nil) (edges const-decl "bool" c_digraphs_def digraphs) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (edges_of const-decl "finite_set[edgetype[T]]" walks_ digraphs) (finite_set type-eq-decl nil finite_sets nil) (edgetype type-eq-decl nil digraphs_utils digraphs) (subset? const-decl "bool" sets nil)) nil (positive_double_cycle? subtype "matrix_wdg.e" "(c_digraphs_def[matrix_wdg.T].edges(dg(matrix_wdg.G)))"))) (limiting_measure?_TCC1 0 (limiting_measure?_TCC1-2 nil 3661594824 ("" (skosimp*) (("" (typepred "e!1") (("" (expand "edge?") (("" (expand "digraph_edges") (("" (case "e!1=(e!1`1,e!1`2)") (("1" (replace -1 1 :hide? t) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((edge type-eq-decl nil digraphs_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (edge? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (T formal-type-decl nil matrix_wdg nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (limiting_measure? subtype "matrix_wdg.e" "(c_digraphs_def[matrix_wdg.T].edges(dg(matrix_wdg.G)))")) (limiting_measure?_TCC1-1 nil 3658072500 ("" (skosimp*) (("" (typepred "e!1") (("" (expand "edge?") (("" (case "e!1=(e!1`1,e!1`2)") (("1" (replace -1 1 :hide? t) (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) nil nil (limiting_measure? subtype "matrix_wdg.e" "(c_digraphs_def[matrix_wdg.T].edges(dg(matrix_wdg.G)))"))) (criterion_one?_TCC1 0 (criterion_one?_TCC1-1 nil 3604069584 ("" (subtype-tcc) nil nil) ((prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (positive_double_cycle? const-decl "bool" matrix_wdg nil) (limiting_measure? const-decl "bool" matrix_wdg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (criterion_one? subtype "matrix_wdg.cy" "Walk[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(matrix_wdg.G))"))) (criterion_one?_TCC2 0 (criterion_one?_TCC2-1 nil 3661593386 ("" (subtype-tcc) nil nil) ((id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (positive_double_cycle? const-decl "bool" matrix_wdg nil) (limiting_measure? const-decl "bool" matrix_wdg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (criterion_one? subtype "c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[matrix_wdg.T].digraph_edges(c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (positive_eq_circuit_TCC1 0 (positive_eq_circuit_TCC1-1 nil 3582911550 ("" (subtype-tcc) nil nil) ((prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil matrix_wdg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (rest const-decl "finseq" seq_extras structures) (O const-decl "finseq" finite_sequences nil) (reord_prewalk const-decl "prewalk" walks_ digraphs) (eq_prewalk? const-decl "bool" walks_ digraphs) (eq_circuit? const-decl "bool" circuits_ digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (positive_eq_circuit subtype "matrix_wdg.w1" "Walk[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(matrix_wdg.G))"))) (positive_eq_circuit_TCC2 0 (positive_eq_circuit_TCC2-1 nil 3582911550 ("" (subtype-tcc) nil nil) ((T formal-type-decl nil matrix_wdg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (rest const-decl "finseq" seq_extras structures) (O const-decl "finseq" finite_sequences nil) (reord_prewalk const-decl "prewalk" walks_ digraphs) (eq_prewalk? const-decl "bool" walks_ digraphs) (eq_circuit? const-decl "bool" circuits_ digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (positive_eq_circuit subtype "c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[matrix_wdg.T].digraph_edges(c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (positive_eq_circuit_TCC3 0 (positive_eq_circuit_TCC3-1 nil 3661593386 ("" (subtype-tcc) nil nil) ((prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil matrix_wdg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (rest const-decl "finseq" seq_extras structures) (O const-decl "finseq" finite_sequences nil) (reord_prewalk const-decl "prewalk" walks_ digraphs) (eq_prewalk? const-decl "bool" walks_ digraphs) (eq_circuit? const-decl "bool" circuits_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (positive_fun? const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (positive_eq_circuit subtype "matrix_wdg.w2" "Walk[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(matrix_wdg.G))"))) (positive_eq_circuit 0 (positive_eq_circuit-1 nil 3563205706 ("" (skeep) (("" (auto-rewrite "finseq_appl") (("" (expand "eq_circuit?") (("" (flatten) (("" (expand "eq_prewalk?") (("" (split) (("1" (case-replace "w1 = w2") (("1" (hide -4 2) (("1" (expand "circuit?") (("1" (expand "pre_circuit?") (("1" (flatten) (("1" (hide -2 -5) (("1" (assert) (("1" (decompose-equality 1) (("1" (expand* "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand* "rest" "^" "min") (("2" (flatten) (("2" (decompose-equality) (("1" (case "x!1 = 0") (("1" (inst -2 "length(w1) - 2") (("1" (assert) nil nil) ("2" (expand "min") (("2" (assert) nil nil)) nil)) nil) ("2" (inst -1 "x!1 - 1") (("1" (assert) nil nil) ("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep -1) (("2" (expand "reord_prewalk") (("2" (case "length(w1) = 2") (("1" (expand "rest" -2 3) (("1" (expand "^" -2 2) (("1" (expand "min") (("1" (assert) (("1" (replace -1) (("1" (assert) (("1" (expand "^" -2 1) (("1" (rewrite "empty_o_seq") (("1" (case-replace "w1 = w2") (("1" (hide -5 2) (("1" (expand "circuit?") (("1" (expand "pre_circuit?") (("1" (flatten) (("1" (hide -3 -5) (("1" (assert) (("1" (decompose-equality 1) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand "rest") (("2" (expand "^") (("2" (expand "min") (("2" (flatten) (("2" (lift-if) (("2" (prop) (("1" (decompose-equality) (("1" (case "x!1 = 0") (("1" (inst -2 "length(w1) - 2") (("1" (assert) nil nil) ("2" (expand "min") (("2" (assert) nil nil)) nil)) nil) ("2" (inst -1 "x!1 - 1") (("1" (assert) nil nil) ("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (propax) nil nil)) nil)) nil) ("2" (decompose-equality) (("1" (case "x!1 = 0") (("1" (inst -2 "length(w1) - 2") (("1" (assert) nil nil) ("2" (expand "min") (("2" (assert) nil nil)) nil)) nil) ("2" (inst -1 "x!1 - 1") (("1" (assert) nil nil) ("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i > length(rest(w1)) - 1") (("1" (expand "^" -2 1) (("1" (assert) (("1" (rewrite "empty_o_seq") (("1" (case-replace "w1 = w2") (("1" (hide -5 3) (("1" (expand* "circuit?" "pre_circuit?") (("1" (flatten) (("1" (hide -3 -6) (("1" (assert) (("1" (decompose-equality 1) (("1" (grind) nil nil) ("2" (decompose-equality 1) (("2" (typepred "x!1") (("2" (expand* "rest" "^" "min") (("2" (flatten) (("2" (lift-if) (("2" (prop) (("1" (decompose-equality -5) (("1" (case "x!1 = 0") (("1" (inst -2 "length(w1) - 2") (("1" (assert) nil nil) ("2" (expand "min") (("2" (assert) nil nil)) nil)) nil) ("2" (inst -1 "x!1 - 1") (("1" (assert) nil nil) ("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (assert) nil nil)) nil) ("3" (expand "min") (("3" (propax) nil nil)) nil) ("4" (expand "min") (("4" (assert) nil nil)) nil)) nil) ("2" (case "i = w1`length - 1") (("1" (hide -4 1) (("1" (decompose-equality) (("1" (case "x!1 = 0") (("1" (inst -2 "length(w1) - 2") (("1" (assert) nil nil) ("2" (expand "min") (("2" (assert) nil nil)) nil)) nil) ("2" (inst -1 "x!1 - 1") (("1" (assert) nil nil) ("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (assert) nil nil)) nil) ("3" (expand "min") (("3" (propax) nil nil)) nil) ("4" (expand "min") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "rest" -1 (2 3 4)) (("2" (expand "circuit?") (("2" (flatten) (("2" (expand "rest" 1) (("2" (expand "^" 1) (("2" (assert) (("2" (expand "min") (("2" (expand "^" -1 3) (("2" (expand "min") (("2" (expand "rest") (("2" (case "w2 = w1 ^ (i, length(w1) - 1) o w1 ^ (1, i)") (("1" (hide -2) (("1" (expand "pre_circuit?") (("1" (flatten) (("1" (assert) (("1" (lemma "wgt_walk_decomposed") (("1" (copy -1) (("1" (inst -2 "G" "i" "w1") (("1" (assert) (("1" (replace -2 -10) (("1" (hide -2) (("1" (inst -1 "G" "length(w1) - i - 1" "w2") (("1" (assert) (("1" (split) (("1" (case "w2 ^ (0, length(w1) - 1 - i) = w1 ^ (i, length(w1) - 1) AND
                                                                                   w2 ^ (length(w1) - 1 - i, length(w2) - 1) =  w1 ^ (0, i)") (("1" (flatten) (("1" (replaces -1) (("1" (replaces -1) (("1" (replaces -1) (("1" (lemma "positive_commute") (("1" (inst -1 "wgt_walk(G, w1 ^ (0, i))" "wgt_walk(G, w1 ^ (i, length(w1) - 1))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3 -6 -9 4) (("2" (expand "o" -1) (("2" (decompose-equality -1) (("2" (split) (("1" (decompose-equality) (("1" (hide -2) (("1" (expand* "^" "min" "empty_seq") (("1" (assert) nil nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (decompose-equality -3) (("2" (expand* "^" "min") (("2" (assert) (("2" (inst -1 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (hide -2) (("1" (expand* "^" "min" "empty_seq") (("1" (assert) nil nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (decompose-equality -3) (("2" (expand* "^" "min") (("2" (assert) (("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -4 -7 1 2 3)) (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -6 4) (("2" (expand "o" -1) (("2" (decompose-equality -1) (("2" (decompose-equality 1) (("1" (hide -2) (("1" (expand* "o" "^" "min" "empty_seq") nil nil)) nil) ("2" (decompose-equality 1) (("2" (expand "^" -1) (("2" (expand "min") (("2" (typepred "x!1") (("2" (expand "o" 1) (("2" (expand "^" 1 (1 4)) (("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (expand "^" 1) (("1" (decompose-equality -4) (("1" (expand "^" -1) (("1" (expand "min") (("1" (case-replace "x!1 = 0") (("1" (assert) (("1" (inst -2 "length(w2) - 2") (("1" (assert) (("1" (replace -5) (("1" (assert) (("1" (expand "pre_circuit?") (("1" (flatten) (("1" (hide -6 -9) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^" 1) (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "x!1 - 1") (("1" (assert) nil nil) ("2" (expand "^" 1) (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "^" (2 -3)) (("2" (expand "min") (("2" (decompose-equality -3) (("1" (inst -1 "x!1 - 1") (("1" (assert) nil nil) ("2" (expand "min") (("2" (assert) nil nil)) nil)) nil) ("2" (hide -4) (("2" (expand* "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (rest const-decl "finseq" seq_extras structures) (NOT const-decl "[bool -> bool]" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (w1 skolem-const-decl "prewalk
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make]" matrix_wdg nil) (x!1 skolem-const-decl "below[w1`length]" matrix_wdg nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (circuit? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil matrix_wdg nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (reord_prewalk const-decl "prewalk" walks_ digraphs) (x!1 skolem-const-decl "below[w1`length]" matrix_wdg nil) (x!1 skolem-const-decl "below[w2`length]" matrix_wdg nil) (wgt_walk_decomposed formula-decl nil weighted_digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (N formal-const-decl "posnat" matrix_wdg nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (empty_seq const-decl "finseq" finite_sequences nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (positive_commute formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (walk? const-decl "bool" walks_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (identity? const-decl "bool" operator_defs nil) (associative? const-decl "bool" operator_defs nil) (TRUE const-decl "bool" booleans nil) (O const-decl "finseq" finite_sequences nil) (posint_min application-judgement "{k: posint | k <= i AND k <= j}" real_defs nil) (nzint_min application-judgement "{k: nzint | k <= i AND k <= j}" real_defs nil) (x!1 skolem-const-decl "below[w1`length]" matrix_wdg nil) (w2 skolem-const-decl "prewalk
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make]" matrix_wdg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (empty_o_seq formula-decl nil seq_extras structures) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (eq_prewalk? const-decl "bool" walks_ digraphs) (eq_circuit? const-decl "bool" circuits_ digraphs)) SHOSTAK)) (lm_defined_walks_TCC1 0 (lm_defined_walks_TCC1-1 nil 3661593386 ("" (subtype-tcc) nil nil) ((prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil matrix_wdg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (positive_double_cycle? const-decl "bool" matrix_wdg nil) (limiting_measure? const-decl "bool" matrix_wdg nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (lm_defined_walks subtype "matrix_wdg.w" "Walk[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(matrix_wdg.G))"))) (lm_defined_walks_TCC2 0 (lm_defined_walks_TCC2-1 nil 3661593386 ("" (subtype-tcc) nil nil) ((T formal-type-decl nil matrix_wdg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (positive_double_cycle? const-decl "bool" matrix_wdg nil) (limiting_measure? const-decl "bool" matrix_wdg nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (lm_defined_walks subtype "c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[matrix_wdg.T].digraph_edges(c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (lm_defined_walks 0 (lm_defined_walks-1 nil 3592839310 ("" (auto-rewrite "finseq_appl") (("" (skolem 1 ("G" "k" "_")) (("" (measure-induct+ "length(w)" ("w")) (("1" (assert) (("1" (expand "limiting_measure?") (("1" (flatten) (("1" (hide -3) (("1" (case "length(x!1) < 2 OR length(x!1) = 2") (("1" (hide -2) (("1" (split) (("1" (hide -2 -3) (("1" (expand* "wgt_walk" "wgt_aux") (("1" (assert) (("1" (use "id_def") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand* "wgt_walk" "wgt_aux") (("2" (assert) (("2" (replace -1) (("2" (assert) (("2" (expand "wgt_aux") (("2" (lemma "id_is_identity") (("2" (expand "identity?") (("2" (inst -1 "get_wgt(G,(x!1`seq(0), x!1`seq(1)))") (("1" (flatten) (("1" (replace -2) (("1" (hide -1 -2) (("1" (inst -2 "(x!1`seq(0), x!1`seq(1))") (("1" (expand "edge?") (("1" (expand "digraph_edges") (("1" (expand "walk?") (("1" (expand "edge?") (("1" (expand "digraph_edges") (("1" (flatten) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "id_is_identity") nil nil) ("3" (use "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "wgt_walk_decomposed") (("2" (inst -1 "G" "1" "x!1") (("2" (assert) (("2" (replaces -1) (("2" (inst -1 "rest(x!1)") (("1" (expand "rest") (("1" (expand "^" -1 1) (("1" (expand "min") (("1" (rewrite "walk?_caret") (("1" (expand "wgt_walk" 3 1) (("1" (expand "^" 3 2) (("1" (expand "min") (("1" (expand "wgt_aux") (("1" (assert) (("1" (expand "^" 3 (2 3)) (("1" (expand "wgt_aux") (("1" (lemma "id_is_identity") (("1" (expand "identity?") (("1" (inst -1 "get_wgt(G,(x!1`seq(0), x!1`seq(1)))") (("1" (flatten) (("1" (replace -2) (("1" (hide -1 -2) (("1" (inst -2 "(x!1`seq(0), x!1`seq(1))") (("1" (lemma "defined_pos_mul") (("1" (inst -1 "get_wgt(G,(x!1`seq(0), x!1`seq(1)))" " wgt_walk(G, x!1 ^ (1, length(x!1) - 1))" "k" "k" "k") (("1" (split -1) (("1" (lemma "defined_pos?_def") (("1" (inst? -1 :where -2) (("1" (replace -1 :hide? t) (("1" (typepred "get(get_wgt(G,(x!1`seq(0), x!1`seq(1))) *
                            wgt_walk(G, x!1 ^ (1, length(x!1) - 1)))
                          (k, k)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (use "defined_pos?_def") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (use "id_is_identity") nil nil) ("3" (use "measure_matrix_assoc") nil nil)) nil) ("3" (hide-all-but (1 -1)) (("3" (use "defined_pos?_def") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -2)) (("2" (expand "edge?") (("2" (expand "walk?") (("2" (flatten) (("2" (inst?) (("2" (expand "edge?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "id_is_identity") nil nil) ("3" (use "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 4) (("2" (expand* "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (wgt_aux def-decl "Weight" weighted_digraphs_ digraphs) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (id_def formula-decl nil measures nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (id_is_identity formula-decl nil measures nil) (edge type-eq-decl nil digraphs_ digraphs) (edge? const-decl "bool" digraphs_ digraphs) (x!1 skolem-const-decl "prewalk
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make]" matrix_wdg nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (measure_matrix_assoc formula-decl nil measures nil) (wgt_walk_decomposed formula-decl nil weighted_digraphs_ digraphs) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rest const-decl "finseq" seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (^ const-decl "finseq" finite_sequences nil) (walk?_caret formula-decl nil walks_ digraphs) (defined_pos?_def formula-decl nil measures nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (defined_pos_mul formula-decl nil measures nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (TRUE const-decl "bool" booleans nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (identity? const-decl "bool" operator_defs nil) (associative? const-decl "bool" operator_defs nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" matrix_wdg nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (below type-eq-decl nil naturalnumbers nil) (limiting_measure? const-decl "bool" matrix_wdg nil) (G skolem-const-decl "wdg" matrix_wdg nil) (k skolem-const-decl "below(N)" matrix_wdg nil) (walk? const-decl "bool" walks_ digraphs) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil matrix_wdg nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil)) (lm_positive_edge_TCC1 0 (lm_positive_edge_TCC1-2 nil 3661594901 ("" (skeep* :preds? t) (("" (use "edges_of_subset") (("" (split -1) (("1" (expand "digraph_edges") (("1" (expand "subset?") (("1" (expand "member") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "circuit?") (("2" (flatten) (("2" (expand "pre_circuit?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((edges_of_subset formula-decl nil walks_ digraphs) (T formal-type-decl nil matrix_wdg nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (prewalk type-eq-decl nil walks_ digraphs) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (circuit? const-decl "bool" circuits_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (member const-decl "bool" sets nil) (edges const-decl "bool" c_digraphs_def digraphs) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (edgetype type-eq-decl nil digraphs_utils digraphs) (finite_set type-eq-decl nil finite_sets nil) (edges_of const-decl "finite_set[edgetype[T]]" walks_ digraphs) (subset? const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (lm_positive_edge subtype "matrix_wdg.e" "(c_digraphs_def[matrix_wdg.T].edges(dg(matrix_wdg.G)))")) (lm_positive_edge_TCC1-1 nil 3592839392 ("" (subtype-tcc) nil nil) nil nil (lm_positive_edge subtype "matrix_wdg.e" "(c_digraphs_def[matrix_wdg.T].edges(dg(matrix_wdg.G)))"))) (lm_positive_edge 0 (lm_positive_edge-1 nil 3592839392 ("" (auto-rewrite "finseq_appl") (("" (skolem 1 ("G" "_" "k")) (("" (measure-induct+ "length(c)" ("c")) (("1" (lemma "cycle_o_circuit") (("1" (inst -1 "dg(G)" "x!1") (("1" (assert) (("1" (skeep) (("1" (case "cycle?(dg(G), w2)") (("1" (hide -4 -5 -7 1) (("1" (expand "limiting_measure?") (("1" (flatten) (("1" (hide -4) (("1" (inst -4 "x!1") (("1" (expand "positive_double_cycle?") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (expand "double_cycle?") (("2" (inst 1 "w1" "w2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "w2") (("2" (assert) (("2" (split) (("1" (skeep) (("1" (lemma "edges_o_walk") (("1" (inst -1 "dg(G)" "w1" "w2") (("1" (split) (("1" (lemma "eq_circuit_edges") (("1" (inst -1 "dg(G)" "x!1" "w1 o rest(w2)") (("1" (assert) (("1" (replace -1 -2 rl) (("1" (hide -1) (("1" (decompose-equality -1) (("1" (inst -1 "e") (("1" (typepred "e") (("1" (iff) (("1" (expand* "union" "member") (("1" (inst 3 "e") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand* "cycle?" "circuit?" "pre_circuit?") (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (expand* "circuit?" "pre_circuit?") (("3" (assert) nil nil)) nil)) nil) ("4" (hide-all-but (-2 -3 -4 1)) (("4" (expand* "eq_circuit?" "cycle?" "circuit?" "pre_circuit?") (("4" (assert) (("4" (flatten) (("4" (hide -1 -4 -5 -8 -9) (("4" (expand* "o" "rest" "^" "min" "last" "first") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -3 1)) (("2" (lemma "eq_circuit_length") (("2" (inst -1 "dg(G)" "x!1" "w1 o rest(w2)") (("2" (assert) (("2" (hide -2) (("2" (expand* "cycle?" "circuit?") (("2" (flatten) (("2" (hide -2 -4 -5) (("2" (expand "o ") (("2" (expand "rest") (("2" (expand "^") (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 1 3) (("2" (skosimp) (("2" (typepred "e!1") (("2" (expand* "circuit?" "pre_circuit?") (("2" (flatten) (("2" (hide -3 -4) (("2" (lemma "edges_of_subset") (("2" (inst -1 "dg(G)" "c!1") (("2" (assert) (("2" (expand* "subset?" "member" "edge?") (("2" (inst -1 "e!1") (("2" (assert) (("2" (use "id_is_identity") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 2) (("3" (skeep) (("3" (use "measure_matrix_assoc") nil nil)) nil)) nil) ("4" (hide-all-but (2 -2)) (("4" (skeep :preds? t) (("4" (expand "edges_of") (("4" (expand "finseq_appl") (("4" (expand "circuit?") (("4" (flatten) (("4" (expand "pre_circuit?") (("4" (flatten) (("4" (expand "finseq_appl") (("4" (expand "walk?") (("4" (flatten) (("4" (expand "finseq_appl") (("4" (expand "verts_in?") (("4" (expand "digraph_verts") (("4" (skeep -1) (("4" (inst-cp -2 "i") (("4" (inst -2 "i+1") (("4" (assert) (("4" (expand "edge?") (("4" (expand "digraph_edges") (("4" (expand "edges") (("4" (inst -4 "i") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((verts_in? const-decl "bool" walks_ digraphs) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (edge? const-decl "bool" digraphs_ digraphs) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (walk? const-decl "bool" walks_ digraphs) (measure_matrix_assoc formula-decl nil measures nil) (edges_of_subset formula-decl nil walks_ digraphs) (id_is_identity formula-decl nil measures nil) (subset? const-decl "bool" sets nil) (cycle_o_circuit formula-decl nil cycles_ digraphs) (w2 skolem-const-decl "prewalk
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make]" matrix_wdg nil) (w1 skolem-const-decl "prewalk
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make]" matrix_wdg nil) (positive_double_cycle? const-decl "bool" matrix_wdg nil) (x!1 skolem-const-decl "prewalk
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make]" matrix_wdg nil) (double_cycle? const-decl "bool" matrix_wdg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (eq_circuit_length formula-decl nil circuits_ digraphs) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (last const-decl "T" seq_extras structures) (first const-decl "T" seq_extras structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (eq_circuit? const-decl "bool" circuits_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (eq_circuit_edges formula-decl nil circuits_ digraphs) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (finite_union application-judgement "finite_set" set_as_list_props structures) (e skolem-const-decl "(edges_of(w2))" matrix_wdg nil) (member const-decl "bool" sets nil) (union const-decl "set" sets nil) (O const-decl "finseq" finite_sequences nil) (rest const-decl "finseq" seq_extras structures) (edges_o_walk formula-decl nil walks_ digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (identity? const-decl "bool" operator_defs nil) (associative? const-decl "bool" operator_defs nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" matrix_wdg nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (below type-eq-decl nil naturalnumbers nil) (limiting_measure? const-decl "bool" matrix_wdg nil) (G skolem-const-decl "wdg" matrix_wdg nil) (k skolem-const-decl "below(N)" matrix_wdg nil) (NOT const-decl "[bool -> bool]" booleans nil) (cycle? const-decl "bool" cycles_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (edgetype type-eq-decl nil digraphs_utils digraphs) (finite_set type-eq-decl nil finite_sets nil) (edges_of const-decl "finite_set[edgetype[T]]" walks_ digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (member def-decl "bool" list_props nil) (nth def-decl "T" list_props nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil matrix_wdg nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil)) (lm_pstv_cycles_pstv_circuits 0 (lm_pstv_cycles_pstv_circuits-3 nil 3631708058 ("" (auto-rewrite "finseq_appl") (("" (skosimp*) (("" (expand* "criterion_one?" "mwg_termination?") (("" (flatten) (("" (skosimp*) (("" (case "cycle?(dg(G!1), c!1)") (("1" (hide -2) (("1" (inst -2 "c!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide -2) (("2" (typepred "c!1") (("2" (lemma "lm_positive_edge") (("2" (inst -1 "G!1" "c!1" "k!1") (("2" (assert) (("2" (skosimp) (("2" (typepred "e!1") (("2" (expand "positive?") (("2" (hide 1) (("2" (expand "positive_fun?") (("2" (inst 1 "k!1") (("2" (lemma "wgt_walk_decomposed") (("2" (expand "edges_of") (("2" (skosimp) (("2" (assert) (("2" (inst-cp -1 "G!1" "i!1" "c!1") (("2" (assert) (("2" (expand* "circuit?" "pre_circuit?") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (replaces -2) (("2" (inst -1 "G!1" "1" "c!1 ^ (i!1, length(c!1) - 1)") (("2" (rewrite "walk?_caret") (("2" (expand "^" -1 1) (("2" (expand "min") (("2" (expand "^" -1 6) (("2" (expand "min") (("2" (name "a" "i!1+1") (("2" (assert) (("2" (case-replace "c!1^(i!1, length(c!1) - 1)^(0, 1) =c!1^(i!1, a)") (("1" (case-replace "c!1 ^ (i!1, length(c!1) - 1) ^ (1, c!1`length - 1 - i!1) = c!1^(a, length(c!1) - 1)") (("1" (hide -1 -2) (("1" (replaces -2) (("1" (lemma "positive_mult_pos") (("1" (inst -1 "wgt_walk(G!1, c!1 ^ (0, i!1))" "wgt_walk(G!1, c!1 ^ (i!1, a)) * wgt_walk(G!1, c!1 ^ (a, length(c!1) - 1))" "k!1") (("1" (split -1) (("1" (expand "form_matfun") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (expand "Plus3" 1) (("2" (lift-if) (("2" (ground) (("1" (lemma "lm_defined_walks") (("1" (inst -1 "G!1" "k!1" "c!1 ^ (0, i!1)") (("1" (assert) (("1" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil) ("2" (lemma "defined_pos_mul") (("2" (inst -1 "wgt_walk(G!1, c!1 ^ (i!1, a))" "wgt_walk(G!1, c!1 ^ (a, length(c!1) - 1))" "k!1" "k!1" "k!1") (("1" (split -1) (("1" (lemma "defined_pos?_def") (("1" (inst? -1 :where -2) (("1" (replace -1 :hide? t) (("1" (expand "/=") (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (lemma "lm_defined_walks") (("2" (inst -1 "G!1" "k!1" "c!1^(i!1, a)") (("2" (assert) (("2" (rewrite "walk?_caret") (("2" (lemma "defined_pos?_def") (("2" (inst? -1 :where 1) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "lm_defined_walks") (("3" (inst -1 "G!1" "k!1" "c!1^(a, length(c!1) - 1)") (("3" (assert) (("3" (rewrite "walk?_caret") (("3" (lemma "defined_pos?_def") (("3" (inst? -1 :where 1) (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("3" (hide 1 3) (("3" (lemma "positive_mult_pos") (("3" (inst -1 "wgt_walk(G!1, c!1 ^ (i!1, a))" "wgt_walk(G!1, c!1 ^ (a, length(c!1) - 1))" "k!1") (("1" (assert) (("1" (hide 2) (("1" (expand "Plus3" 1) (("1" (lift-if) (("1" (ground) (("1" (lemma "lm_defined_walks") (("1" (inst -1 "G!1" "k!1" "c!1 ^ (i!1, a)") (("1" (assert) (("1" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil) ("2" (lemma "lm_defined_walks") (("2" (inst -1 "G!1" "k!1" "c!1 ^ (a, length(c!1) - 1)") (("2" (assert) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2 -3 1)) (("3" (replace -1 1 rl) (("3" (hide -1) (("3" (replaces -1) (("3" (rewrite "wgt_walk_edge") (("1" (expand "^") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality) (("1" (expand* "^" "min" "empty_seq") nil nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand* "^" "min" "empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality) (("1" (expand* "^" "min" "empty_seq") nil nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand* "^" "min" "empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((circuit? const-decl "bool" circuits_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cycle? const-decl "bool" cycles_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (T formal-type-decl nil matrix_wdg nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (positive? const-decl "bool" measures nil) (positive_fun? const-decl "bool" measures nil) (wgt_walk_decomposed formula-decl nil weighted_digraphs_ digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (TRUE const-decl "bool" booleans nil) (walk?_caret formula-decl nil walks_ digraphs) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (associative? const-decl "bool" operator_defs nil) (identity? const-decl "bool" operator_defs nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (Walk type-eq-decl nil walks_ digraphs) (walk? const-decl "bool" walks_ digraphs) (wgt_walk_edge formula-decl nil weighted_digraphs_ digraphs) (defined_pos_mul formula-decl nil measures nil) (/= const-decl "boolean" notequal nil) (id_is_identity formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (defined_pos?_def formula-decl nil measures nil) (lm_defined_walks formula-decl nil matrix_wdg nil) (Plus3 const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (positive_mult_pos formula-decl nil measures nil) (posint nonempty-type-eq-decl nil integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (^ const-decl "finseq" finite_sequences nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (edges_of const-decl "finite_set[edgetype[T]]" walks_ digraphs) (finite_set type-eq-decl nil finite_sets nil) (edgetype type-eq-decl nil digraphs_utils digraphs) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lm_positive_edge formula-decl nil matrix_wdg nil) (criterion_one? const-decl "bool" matrix_wdg nil) (mwg_termination? const-decl "bool" matrix_wdg nil)) nil) (lm_pstv_cycles_pstv_circuits-2 nil 3612569136 ("" (auto-rewrite "finseq_appl") (("" (skosimp*) (("" (expand* "criterion_one?" "mwg_termination?") (("" (flatten) (("" (skosimp*) (("" (case "cycle?(dg(G!1), c!1)") (("1" (hide -2) (("1" (inst -2 "c!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide -2) (("2" (typepred "c!1") (("2" (lemma "lm_positive_edge") (("2" (inst -1 "G!1" "c!1" "k!1") (("2" (assert) (("2" (skosimp) (("2" (typepred "e!1") (("2" (expand "positive?") (("2" (hide 1) (("2" (inst 1 "k!1") (("2" (lemma "wgt_walk_decomposed") (("2" (expand "edges_of") (("2" (skosimp) (("2" (assert) (("2" (inst-cp -1 "G!1" "i!1" "c!1") (("2" (assert) (("2" (expand* "circuit?" "pre_circuit?") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (replaces -2) (("2" (inst -1 "G!1" "1" "c!1 ^ (i!1, length(c!1) - 1)") (("2" (rewrite "walk?_caret") (("2" (expand "^" -1 1) (("2" (expand "min") (("2" (expand "^" -1 6) (("2" (expand "min") (("2" (name "a" "i!1+1") (("2" (assert) (("2" (case-replace "c!1^(i!1, length(c!1) - 1)^(0, 1) =c!1^(i!1, a)") (("1" (case-replace "c!1 ^ (i!1, length(c!1) - 1) ^ (1, c!1`length - 1 - i!1) = c!1^(a, length(c!1) - 1)") (("1" (hide -1 -2) (("1" (replaces -2) (("1" (lemma "positive_mult_pos") (("1" (inst -1 "wgt_walk(G!1, c!1 ^ (0, i!1))" "wgt_walk(G!1, c!1 ^ (i!1, a)) * wgt_walk(G!1, c!1 ^ (a, length(c!1) - 1))" "k!1") (("1" (assert) (("1" (hide 2) (("1" (expand "MPlus" 1) (("1" (lift-if) (("1" (ground) (("1" (lemma "lm_defined_walks") (("1" (inst -1 "G!1" "k!1" "c!1 ^ (0, i!1)") (("1" (assert) (("1" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil) ("2" (lemma "defined_pos_mul") (("2" (inst -1 "wgt_walk(G!1, c!1 ^ (i!1, a))" "wgt_walk(G!1, c!1 ^ (a, length(c!1) - 1))" "k!1" "k!1" "k!1") (("1" (expand "defined_pos?") (("1" (typepred "(wgt_walk(G!1, c!1 ^ (i!1, a)) *
                                                                                                          wgt_walk(G!1, c!1 ^ (a, length(c!1) - 1)))
                                                                                                            (k!1)(k!1)") (("1" (assert) (("1" (hide -1 2) (("1" (split) (("1" (lemma "lm_defined_walks") (("1" (inst -1 "G!1" "k!1" "c!1^(i!1, a)") (("1" (assert) (("1" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil) ("2" (lemma "lm_defined_walks") (("2" (inst -1 "G!1" "k!1" "c!1^(a, length(c!1) - 1)") (("2" (assert) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("3" (hide 1 3) (("3" (lemma "positive_mult_pos") (("3" (inst -1 "wgt_walk(G!1, c!1 ^ (i!1, a))" "wgt_walk(G!1, c!1 ^ (a, length(c!1) - 1))" "k!1") (("1" (assert) (("1" (hide 2) (("1" (expand "MPlus" 1) (("1" (lift-if) (("1" (ground) (("1" (lemma "lm_defined_walks") (("1" (inst -1 "G!1" "k!1" "c!1 ^ (i!1, a)") (("1" (assert) (("1" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil) ("2" (lemma "lm_defined_walks") (("2" (inst -1 "G!1" "k!1" "c!1 ^ (a, length(c!1) - 1)") (("2" (assert) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2 -3 1)) (("3" (replace -1 1 rl) (("3" (hide -1) (("3" (replaces -1) (("3" (rewrite "wgt_walk_edge") (("1" (expand "^") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality) (("1" (expand* "^" "min" "empty_seq") nil nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand* "^" "min" "empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality) (("1" (expand* "^" "min" "empty_seq") nil nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand* "^" "min" "empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (lm_pstv_cycles_pstv_circuits-1 nil 3592843107 ("" (auto-rewrite "finseq_appl") (("" (skosimp*) (("" (expand "criterion_one?") (("" (flatten) (("" (skosimp) (("" (case "cycle?(dg(G!1), c!1)") (("1" (hide -2) (("1" (inst -2 "c!1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide -2) (("2" (typepred "c!1") (("2" (lemma "lm_positive_edge") (("2" (inst -1 "G!1" "c!1" "k!1") (("2" (assert) (("2" (skosimp) (("2" (typepred "e!1") (("2" (expand "positive?") (("2" (hide 1) (("2" (inst 1 "k!1") (("2" (lemma "wgt_walk_decomposed") (("2" (expand "edges_of") (("2" (skosimp) (("2" (assert) (("2" (inst-cp -1 "G!1" "i!1" "c!1") (("2" (assert) (("2" (expand* "circuit?" "pre_circuit?") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (replaces -2) (("2" (inst -1 "G!1" "1" "c!1 ^ (i!1, length(c!1) - 1)") (("2" (rewrite "walk?_caret") (("2" (expand "^" -1 1) (("2" (expand "min") (("2" (expand "^" -1 6) (("2" (expand "min") (("2" (name "a" "number_fields.+ (i!1, 1)") (("2" (assert) (("2" (case-replace "c!1^(i!1, length(c!1) - 1)^(0, 1) =c!1^(i!1, a)") (("1" (case-replace "c!1 ^ (i!1, length(c!1) - 1) ^ (1, c!1`length - 1 - i!1) = c!1^(a, length(c!1) - 1)") (("1" (hide -1 -2) (("1" (replaces -2) (("1" (lemma "positive_mult_pos") (("1" (inst -1 "wgt_walk(G!1, c!1 ^ (0, i!1))" "wgt_walk(G!1, c!1 ^ (i!1, a)) * wgt_walk(G!1, c!1 ^ (a, length(c!1) - 1))" "k!1") (("1" (assert) (("1" (hide 2) (("1" (expand "+" 1) (("1" (lift-if) (("1" (ground) (("1" (lemma "lm_defined_walks") (("1" (inst -1 "G!1" "k!1" "c!1 ^ (0, i!1)") (("1" (assert) (("1" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil) ("2" (lemma "defined_pos_mul") (("2" (inst -1 "wgt_walk(G!1, c!1 ^ (i!1, a))" "wgt_walk(G!1, c!1 ^ (a, length(c!1) - 1))" "k!1" "k!1" "k!1") (("1" (expand "defined_pos?") (("1" (typepred "(wgt_walk(G!1, c!1 ^ (i!1, a)) *
                                                                              wgt_walk(G!1, c!1 ^ (a, length(c!1) - 1)))
                                                                                (k!1)(k!1)") (("1" (assert) (("1" (hide -1 2) (("1" (split) (("1" (lemma "lm_defined_walks") (("1" (inst -1 "G!1" "k!1" "c!1^(i!1, a)") (("1" (assert) (("1" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil) ("2" (lemma "lm_defined_walks") (("2" (inst -1 "G!1" "k!1" "c!1^(a, length(c!1) - 1)") (("2" (assert) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("3" (hide 1 3) (("3" (lemma "positive_mult_pos") (("3" (inst -1 "wgt_walk(G!1, c!1 ^ (i!1, a))" "wgt_walk(G!1, c!1 ^ (a, length(c!1) - 1))" "k!1") (("1" (assert) (("1" (hide 2) (("1" (expand "+" 1) (("1" (lift-if) (("1" (ground) (("1" (lemma "lm_defined_walks") (("1" (inst -1 "G!1" "k!1" "c!1 ^ (i!1, a)") (("1" (assert) (("1" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil) ("2" (lemma "lm_defined_walks") (("2" (inst -1 "G!1" "k!1" "c!1 ^ (a, length(c!1) - 1)") (("2" (assert) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2 -3 1)) (("3" (replace -1 1 rl) (("3" (hide -1) (("3" (replaces -1) (("3" (rewrite "wgt_walk_edge") (("1" (expand "^") (("1" (propax) nil nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality) (("1" (expand* "^" "min" "empty_seq") nil nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand* "^" "min" "empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality) (("1" (expand* "^" "min" "empty_seq") nil nil) ("2" (decompose-equality) (("2" (typepred "x!1") (("2" (expand* "^" "min" "empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (limiting_labeling?_TCC1 0 (limiting_labeling?_TCC1-1 nil 3592058495 ("" (skosimp) (("" (typepred "e!1" "dg(G!1)") (("" (expand "edge?") (("" (use "edges_in_verts") (("" (split -1) (("1" (flatten) (("1" (expand* "edge?" "vert?") nil nil)) nil) ("2" (assert) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((edge type-eq-decl nil digraphs_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (edge? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (T formal-type-decl nil matrix_wdg nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (edges_in_verts formula-decl nil digraphs_abs digraphs) (concretedigraph_implements_abstractdigraph formula-decl nil cycles_ digraphs) (vert? const-decl "bool" digraphs_ digraphs)) nil (limiting_labeling? subtype "matrix_wdg.e`1" "vert[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](dg(matrix_wdg.G))"))) (limiting_labeling?_TCC2 0 (limiting_labeling?_TCC2-1 nil 3592058495 ("" (skeep) (("" (typepred "e") (("" (expand* "edge?" "vert?") (("" (use "edges_in_verts") (("" (split -1) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((edge type-eq-decl nil digraphs_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (edge? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (T formal-type-decl nil matrix_wdg nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (edges_in_verts formula-decl nil digraphs_abs digraphs) (concretedigraph_implements_abstractdigraph formula-decl nil cycles_ digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (vert? const-decl "bool" digraphs_ digraphs)) nil (limiting_labeling? subtype "matrix_wdg.e`2" "vert[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](dg(matrix_wdg.G))"))) (limiting_labeling?_TCC3 0 (limiting_labeling?_TCC3-1 nil 3592058495 ("" (skosimp*) (("" (typepred "e!1") (("" (expand "edge?") (("" (assert) nil nil)) nil)) nil)) nil) ((edge type-eq-decl nil digraphs_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (edge? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (T formal-type-decl nil matrix_wdg nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (edges const-decl "bool" c_digraphs_def digraphs)) nil (limiting_labeling? subtype "matrix_wdg.e" "(c_digraphs_def[matrix_wdg.T].edges(dg(matrix_wdg.G)))"))) (limiting_labeling?_TCC4 0 (limiting_labeling?_TCC4-1 nil 3592058495 ("" (subtype-tcc) nil nil) ((id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (limiting_labeling? subtype "matrix_wdg.c" "not_empty_seq[T]"))) (limiting_labeling?_TCC5 0 (limiting_labeling?_TCC5-1 nil 3592058495 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (first const-decl "T" seq_extras structures) (vert? const-decl "bool" digraphs_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (limiting_labeling? subtype "seq_extras[matrix_wdg.T].first(matrix_wdg.c)" "vert[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](dg(matrix_wdg.G))"))) (limiting_labeling?_TCC6 0 (limiting_labeling?_TCC6-1 nil 3592058495 ("" (subtype-tcc) nil nil) ((< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (last const-decl "T" seq_extras structures) (vert? const-decl "bool" digraphs_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (limiting_labeling? subtype "seq_extras[matrix_wdg.T].last(matrix_wdg.c)" "vert[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](dg(matrix_wdg.G))"))) (limiting_labeling?_TCC7 0 (limiting_labeling?_TCC7-1 nil 3658072500 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (limiting_labeling? subtype "matrix_wdg.c" "Walk[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(matrix_wdg.G))"))) (limiting_labeling?_TCC8 0 (limiting_labeling?_TCC8-1 nil 3661593386 ("" (subtype-tcc) nil nil) ((id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (limiting_labeling? subtype "c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[matrix_wdg.T].digraph_edges(c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (ll_defined_walks_TCC1 0 (ll_defined_walks_TCC1-1 nil 3592843505 ("" (subtype-tcc) nil nil) ((id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (first const-decl "T" seq_extras structures) (last const-decl "T" seq_extras structures) (limiting_labeling? const-decl "bool" matrix_wdg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (ll_defined_walks subtype "matrix_wdg.w" "not_empty_seq[T]"))) (ll_defined_walks_TCC2 0 (ll_defined_walks_TCC2-1 nil 3592843505 ("" (subtype-tcc) nil nil) ((prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (first const-decl "T" seq_extras structures) (last const-decl "T" seq_extras structures) (limiting_labeling? const-decl "bool" matrix_wdg nil) (vert? const-decl "bool" digraphs_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (ll_defined_walks subtype "seq_extras[matrix_wdg.T].first(matrix_wdg.w)" "vert[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](dg(matrix_wdg.G))"))) (ll_defined_walks_TCC3 0 (ll_defined_walks_TCC3-1 nil 3592843505 ("" (subtype-tcc) nil nil) ((prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (first const-decl "T" seq_extras structures) (last const-decl "T" seq_extras structures) (limiting_labeling? const-decl "bool" matrix_wdg nil) (vert? const-decl "bool" digraphs_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (ll_defined_walks subtype "seq_extras[matrix_wdg.T].last(matrix_wdg.w)" "vert[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](dg(matrix_wdg.G))"))) (ll_defined_walks_TCC4 0 (ll_defined_walks_TCC4-1 nil 3661593386 ("" (subtype-tcc) nil nil) ((prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (first const-decl "T" seq_extras structures) (last const-decl "T" seq_extras structures) (limiting_labeling? const-decl "bool" matrix_wdg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (ll_defined_walks subtype "matrix_wdg.w" "Walk[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(matrix_wdg.G))"))) (ll_defined_walks_TCC5 0 (ll_defined_walks_TCC5-1 nil 3661593386 ("" (subtype-tcc) nil nil) ((id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (first const-decl "T" seq_extras structures) (last const-decl "T" seq_extras structures) (limiting_labeling? const-decl "bool" matrix_wdg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (ll_defined_walks subtype "c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[matrix_wdg.T].digraph_edges(c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (ll_defined_walks 0 (ll_defined_walks-1 nil 3592843505 ("" (auto-rewrite "finseq_appl") (("" (skolem 1 ("G" "f" "_")) (("" (measure-induct+ "length(w)" ("w")) (("1" (name-replace "k1" "f(first(x!1))" :hide? nil) (("1" (name-replace "kn" "f(last(x!1))" :hide? nil) (("1" (case "length(x!1) = 1 OR length(x!1) = 2") (("1" (hide -4) (("1" (split) (("1" (hide -4) (("1" (expand* "last" "first" "wgt_walk" "wgt_aux") (("1" (replace -1) (("1" (assert) (("1" (use "id_def") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "last" "first" "wgt_walk" "wgt_aux" "limiting_labeling?") (("2" (replace -1) (("2" (assert) (("2" (flatten) (("2" (hide -5) (("2" (expand "wgt_aux") (("2" (lemma "id_is_identity") (("2" (expand "identity?") (("2" (inst -1 "get_wgt(G,(x!1`seq(0), x!1`seq(1)))") (("1" (flatten) (("1" (replace -2) (("1" (hide -1 -2) (("1" (inst -4 "(x!1`seq(0), x!1`seq(1))") (("1" (replace -2) (("1" (replace -3) (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (1 -4)) (("2" (expand "edge?") (("2" (expand "walk?") (("2" (expand "edge?") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "id_is_identity") nil nil) ("3" (use "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma "wgt_walk_decomposed") (("2" (inst -1 "G" "1" "x!1") (("2" (assert) (("2" (replaces -1) (("2" (inst -3 "x!1 ^ (1, length(x!1) - 1)") (("2" (rewrite "walk?_caret") (("2" (expand "^" -3 1) (("2" (expand "min") (("2" (expand* "first" "last") (("2" (assert) (("2" (expand "^" -3 (2 3 4)) (("2" (expand "min") (("2" (replace -1) (("2" (expand "limiting_labeling?") (("2" (flatten) (("2" (hide -5) (("2" (expand "wgt_walk" 3 1) (("2" (expand "^" 3 2) (("2" (expand "min") (("2" (expand "wgt_aux") (("2" (assert) (("2" (expand "^" 3 (2 3)) (("2" (expand "wgt_aux") (("2" (lemma "id_is_identity") (("2" (expand "identity?") (("2" (inst -1 "get_wgt(G,(x!1`seq(0), x!1`seq(1)))") (("1" (flatten) (("1" (replace -2) (("1" (hide -1 -2) (("1" (inst -4 "(x!1`seq(0), x!1`seq(1))") (("1" (replace -2) (("1" (lemma "defined_pos_mul") (("1" (inst -1 "get_wgt(G,(x!1`seq(0), x!1`seq(1)))" "wgt_walk(G, x!1 ^ (1, length(x!1) - 1))" "k1" "f(x!1`seq(1))" "kn") (("1" (split -1) (("1" (lemma "defined_pos?_def") (("1" (inst? -1 :where -2) (("1" (replace -1 :hide? t) (("1" (typepred "get(get_wgt(G,(x!1`seq(0), x!1`seq(1))) *
                          wgt_walk(G, x!1 ^ (1, length(x!1) - 1)))
                        (k1, kn)") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (use "defined_pos?_def") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (use "id_is_identity") nil nil) ("3" (use "measure_matrix_assoc") nil nil)) nil) ("3" (lemma "defined_pos?_def") (("3" (inst? -1 :where 1) (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -4)) (("2" (expand "edge?") (("2" (expand "walk?") (("2" (expand "edge?") (("2" (flatten) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "id_is_identity") nil nil) ("3" (use "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (hide -1 2) (("4" (expand* "walk?" "verts_in?" "vert?") (("4" (flatten) (("4" (hide -2) (("4" (expand "last") (("4" (assert) (("4" (inst -1 "w!1`length - 1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide -1 2) (("5" (expand* "walk?" "verts_in?" "vert?") (("5" (flatten) (("5" (hide -2) (("5" (expand "first") (("5" (assert) (("5" (inst -1 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((verts_in? const-decl "bool" walks_ digraphs) (wgt_aux def-decl "Weight" weighted_digraphs_ digraphs) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (odd_minus_even_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (id_def formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (edge type-eq-decl nil digraphs_ digraphs) (x!1 skolem-const-decl "prewalk
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make]" matrix_wdg nil) (edge? const-decl "bool" digraphs_ digraphs) (id_is_identity formula-decl nil measures nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (wgt_walk_decomposed formula-decl nil weighted_digraphs_ digraphs) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (defined_pos?_def formula-decl nil measures nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (defined_pos_mul formula-decl nil measures nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (walk?_caret formula-decl nil walks_ digraphs) (TRUE const-decl "bool" booleans nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (below type-eq-decl nil naturalnumbers nil) (identity? const-decl "bool" operator_defs nil) (associative? const-decl "bool" operator_defs nil) (last const-decl "T" seq_extras structures) (/= const-decl "boolean" notequal nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (wdg type-eq-decl nil matrix_wdg nil) (vert? const-decl "bool" digraphs_ digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" matrix_wdg nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (vert type-eq-decl nil digraphs_ digraphs) (vertex_labeling type-eq-decl nil matrix_wdg nil) (limiting_labeling? const-decl "bool" matrix_wdg nil) (G skolem-const-decl "wdg" matrix_wdg nil) (f skolem-const-decl "vertex_labeling(G)" matrix_wdg nil) (walk? const-decl "bool" walks_ digraphs) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil matrix_wdg nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil)) (ll_pstv_pos_circuits_TCC1 0 (ll_pstv_pos_circuits_TCC1-1 nil 3592845815 ("" (subtype-tcc) nil nil) ((id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (first const-decl "T" seq_extras structures) (last const-decl "T" seq_extras structures) (limiting_labeling? const-decl "bool" matrix_wdg nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (ll_pstv_pos_circuits subtype "matrix_wdg.c" "not_empty_seq[T]"))) (ll_pstv_pos_circuits_TCC2 0 (ll_pstv_pos_circuits_TCC2-1 nil 3592845815 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (first const-decl "T" seq_extras structures) (last const-decl "T" seq_extras structures) (limiting_labeling? const-decl "bool" matrix_wdg nil) (vert? const-decl "bool" digraphs_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (ll_pstv_pos_circuits subtype "seq_extras[matrix_wdg.T].first(matrix_wdg.c)" "vert[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](dg(matrix_wdg.G))"))) (ll_pstv_pos_circuits_TCC3 0 (ll_pstv_pos_circuits_TCC3-1 nil 3592845815 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (Sign3 type-eq-decl nil sign3 reals) (int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (T formal-type-decl nil matrix_wdg nil) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (cycle? const-decl "bool" cycles_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (first const-decl "T" seq_extras structures) (last const-decl "T" seq_extras structures) (limiting_labeling? const-decl "bool" matrix_wdg nil) (vert? const-decl "bool" digraphs_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (ll_pstv_pos_circuits subtype "seq_extras[matrix_wdg.T].last(matrix_wdg.c)" "vert[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](dg(matrix_wdg.G))"))) (ll_pstv_pos_circuits 0 (ll_pstv_pos_circuits-6 nil 3631708412 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (measure-induct+ "length(c)" ("c")) (("1" (typepred "x!1") (("1" (expand* "circuit?" "pre_circuit?" "first" "last") (("1" (assert) (("1" (flatten) (("1" (replace -3 1 rl) (("1" (name-replace "k1" "F(x!1`seq(0))" :hide? nil) (("1" (lemma "cycle_o_circuit") (("1" (inst -1 "dg(G)" "x!1") (("1" (assert) (("1" (split) (("1" (expand "limiting_labeling?") (("1" (flatten) (("1" (hide-all-but (-1 -2 -5 -9 1)) (("1" (inst -4 "x!1") (("1" (expand* "first" "last") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -9 "w2") (("2" (split) (("1" (copy -10) (("1" (expand "limiting_labeling?" -1) (("1" (flatten) (("1" (hide -1) (("1" (inst -1 "w1") (("1" (assert) (("1" (expand* "cycle?" "circuit?" "pre_circuit?") (("1" (assert) (("1" (flatten) (("1" (hide -7) (("1" (expand* "last" "first") (("1" (assert) (("1" (replace -5 -1 rl) (("1" (replace -8 -2) (("1" (copy -3) (("1" (expand "eq_circuit?" -1) (("1" (flatten) (("1" (hide -2) (("1" (expand* "circuit?" "pre_circuit?") (("1" (assert) (("1" (flatten) (("1" (hide -1) (("1" (expand "o" -1) (("1" (expand "rest" -1) (("1" (expand "^" -1) (("1" (expand "min") (("1" (replace -1 -4 rl) (("1" (name-replace "k2" "F(w1`seq(0))" :hide? nil) (("1" (lemma "eq_circuit_position") (("1" (lemma "eq_circuit_symmetric") (("1" (inst -1 "dg(G)" "x!1" "w1 o rest(w2)") (("1" (inst -2 "dg(G)" "w1 o rest(w2)" "x!1") (("1" (assert) (("1" (skeep -2) (("1" (hide -1) (("1" (typepred "i") (("1" (case "i = 0 OR (i /= 0 AND i < length(w1) - 1) OR i = length(w1) - 1 OR (i > length(w1) - 1 AND i /= length(w1 o rest(w2)) - 1) OR  i = length(w1 o rest(w2)) - 1") (("1" (split -1) (("1" (case "x!1 = w1 o w2 ^ (1, length(w2) - 1)") (("1" (hide -2 -3 -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" "x!1") (("1" (assert) (("1" (copy -2) (("1" (expand "o" -1) (("1" (decompose-equality -1) (("1" (hide -2) (("1" (expand "^" -1) (("1" (expand "min") (("1" (assert) (("1" (replace -3 -2) (("1" (case "(w1 o w2 ^ (1, length(w2) - 1)) ^ (0, length(w1) - 1) = w1 AND
                                                                                         (w1 o w2 ^ (1, length(w2) - 1)) ^ (length(w1) - 1,
                                                                                                                            length(w1 o w2 ^ (1, length(w2) - 1)) - 1) = w2") (("1" (flatten) (("1" (replace -1) (("1" (replace -2) (("1" (replace -5 -4 rl) (("1" (replace -5 -18) (("1" (expand "o" -18) (("1" (hide-all-but (-4 -6 -9 -10 -18 1)) (("1" (replaces -2) (("1" (replaces -4) (("1" (name-replace "M_x" "wgt_walk(G, x!1)") (("1" (name-replace "M_w1" "wgt_walk(G, w1)") (("1" (name-replace "M_w2" "wgt_walk(G, w2)") (("1" (lemma "positive_pos_mul") (("1" (inst -1 "M_w1" "M_w2" "k1" "k1" "k1") (("1" (assert) (("1" (hide -1 2) (("1" (expand "Plus3") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (hide-all-but (-12 -15 1)) (("1" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -11 -12 -14 -15 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -12 -15 1)) (("2" (replaces -1) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "x!1 = w1 ^ (i, length(w1) - 2) o w2 o w1 ^ (1, i)") (("1" (hide -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - i - 1" "x!1") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, length(w1) - i - 1) = w1 ^ (i, length(w1) - 1)") (("1" (case-replace "x!1 ^ (length(w1) - 1 - i, length(x!1) - 1) = w2 o w1 ^ (1,i)") (("1" (hide -1 -2) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w2) - 1" "w2 o w1 ^ (1, i)") (("1" (expand "o" -1 1) (("1" (expand "^" -1 1) (("1" (expand "min") (("1" (split -1) (("1" (case-replace "(w2 o w1 ^ (1, i)) ^ (0, length(w2) - 1) = w2") (("1" (case-replace "(w2 o w1 ^ (1, i)) ^
                                                                                                                              (length(w2) - 1, length(w2 o w1 ^ (1, i)) - 1) = w1 ^ (0, i)") (("1" (hide -1 -2) (("1" (replaces -1) (("1" (lemma "ll_defined_walks") (("1" (inst-cp -1 "G" "F" "w1 ^ (i, length(w1) - 1)") (("1" (inst -1 "G" "F" "w1 ^ (0, i)") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (rewrite "walk?_caret") (("1" (expand* "first" "last") (("1" (assert) (("1" (expand "^" -1 (2 3 4)) (("1" (expand "min") (("1" (expand "^" -2 (2 3 4)) (("1" (expand "min") (("1" (replace -14 -2 rl) (("1" (replace -7) (("1" (replace -4 -19) (("1" (expand "o" -19) (("1" (expand "^" -19) (("1" (expand "min") (("1" (replace -19) (("1" (with-tccs (name-replace "Mx" "wgt_walk(G, x!1)")) (("1" (with-tccs (name-replace "Mw1_1" "wgt_walk(G, w1 ^ (i, length(w1) - 1))")) (("1" (with-tccs (name-replace "Mw2" "wgt_walk(G, w2)")) (("1" (with-tccs (name-replace "Mw1_2" "wgt_walk(G, w1 ^ (0, i))")) (("1" (hide-all-but (-1 -2 -3 -11 2)) (("1" (lemma " positive_pos_mul") (("1" (inst -1 "Mw2" "Mw1_2" "k2" "k2" "k1") (("1" (lemma " positive_pos_mul") (("1" (inst -1 "Mw1_1" "Mw2 * Mw1_2" "k1" "k2" "k1") (("1" (assert) (("1" (hide -4 2) (("1" (expand "Plus3") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -6 -15 -18 1 2)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "^" "min") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-5 -6 -15 -18 1 2)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-14 -17 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "walk_o") (("2" (hide-all-but (-1 -7 -12 -13 -14 -15 -16 -17 1)) (("2" (inst -1 "dg(G)" "w2" "w1 ^ (0, i)") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (expand "^" -1 1) (("1" (case-replace "w1 ^ (0, i) ^ (1, length(w1 ^ (0, i)) - 1) = (w1 ^ (1, i))") (("1" (hide-all-but (-5 1)) (("1" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "^" "min") nil nil)) nil) ("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -5 -7 -13 -14 -16 -17 1 2)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -4 -13 -16 1 2)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -3 -12 -15 1 2)) (("2" (replaces -1) (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -3 -12 -15 1 2)) (("2" (replaces -3) (("2" (decompose-equality 1) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality 1) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "x!1 = w2 o w1 ^ (1, length(w1) - 1)") (("1" (hide -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w2) - 1" "x!1") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, length(w2) - 1) = w2") (("1" (case-replace "x!1 ^ (length(w2) - 1, length(x!1) - 1) = w1 ^ (0, length(w1) - 1)") (("1" (hide -1 -2) (("1" (replace -2 -17) (("1" (expand "o" -17) (("1" (hide-all-but (-1 -5 -6 -15 -8 -9 -17 1)) (("1" (replaces -3) (("1" (replaces -5) (("1" (replaces -2) (("1" (replaces -4) (("1" (with-tccs (name-replace "Mx" "wgt_walk(G, x!1)")) (("1" (case-replace "w1 ^ (0, length(w1) - 1) = w1") (("1" (name-replace "Mw1" "wgt_walk(G, w1)") (("1" (name-replace "Mw2" "wgt_walk(G, w2)") (("1" (hide -1) (("1" (lemma "positive_pos_mul") (("1" (inst -1 "Mw2" "Mw1" "k1" "k1" "k1") (("1" (assert) (("1" (hide -1 2) (("1" (expand "Plus3") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "id_is_identity") nil nil) ("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("2" (rewrite "id_is_identity") nil nil) ("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -14 -17 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -13 -16 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (replaces -1) (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -12 -15 1)) (("2" (replaces -1) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (case "x!1 = w2 ^ (i - (length(w1) - 1), length(w2) - 2) o w1 o w2 ^ (1, i - (length(w1) - 1))") (("1" (hide -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w2) - 2 - (i - length(w1))" "x!1") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, length(w1) -(2 - length(w2)) - i) =
                                                                                             w2 ^ (i - (length(w1) - 1), length(w2) - 1)") (("1" (hide -1) (("1" (case-replace "x!1 ^ (length(w1) - (2 - length(w2)) - i, length(x!1) - 1)
                                                                                                     = w1 o w2 ^ (1, i - (length(w1) - 1))") (("1" (hide -1) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" " w1 o w2 ^ (1, i - (length(w1) - 1))") (("1" (expand "o" -1 1) (("1" (expand "^" -1 1) (("1" (expand "min") (("1" (assert) (("1" (expand "o" -5) (("1" (expand "rest" -5) (("1" (expand "^" -5) (("1" (expand "min") (("1" (assert) (("1" (split -1) (("1" (case-replace "(w1 o w2 ^ (1, 1 - (length(w1) - i))) ^
                                                                                                                      (0, length(w1) - 1) = w1") (("1" (case-replace "(w1 o w2 ^ (1, 1 - (length(w1) - i))) ^
                                                                                                                              (length(w1) - 1, length(w1 o w2 ^ (1, 1 - (length(w1) - i))) - 1)
                                                                                                                             =  w2 ^ (0, 1 - (length(w1) - i))") (("1" (hide -1 -2) (("1" (replaces -1) (("1" (lemma "ll_defined_walks") (("1" (inst-cp -1 "G" "F" "w2 ^ (1 - (length(w1) - i), length(w2) - 1)") (("1" (inst -1 "G" "F" "w2 ^ (0, 1 - (length(w1) - i))") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (rewrite "walk?_caret") (("1" (expand* "first" "last") (("1" (assert) (("1" (expand "^" -1 (2 3 4)) (("1" (expand "^" -2 (2 3 4)) (("1" (expand "min") (("1" (replace -8 -2 rl) (("1" (replace -17 -1) (("1" (replace -8 -1 rl) (("1" (replace -7) (("1" (replace -4 -19) (("1" (expand "o" -19) (("1" (expand "^" -19) (("1" (expand* "min" "empty_seq") (("1" (lift-if) (("1" (assert) (("1" (expand "o" 1) (("1" (expand "rest" 1) (("1" (expand "^" 1) (("1" (expand "min") (("1" (assert) (("1" (replace -19) (("1" (name-replace "Mx" "wgt_walk(G, x!1)") (("1" (with-tccs (name-replace "Mw2_1" "wgt_walk(G, w2 ^ (1 - (length(w1) - i), length(w2) - 1))")) (("1" (with-tccs (name-replace "Mw1" "wgt_walk(G, w1)")) (("1" (with-tccs (name-replace "Mw2_2" "wgt_walk(G, w2 ^ (0, 1 - (length(w1) - i)))")) (("1" (hide-all-but (-1 -2 -3 -10 2)) (("1" (lemma "positive_pos_mul") (("1" (inst-cp -1 "Mw1" "Mw2_2" "k2" "k2" "k1") (("1" (inst -1 "Mw2_1" "Mw1 * Mw2_2" "k1" "k2" "k1") (("1" (assert) (("1" (hide -4 2) (("1" (expand "Plus3") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "id_is_identity") nil nil) ("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 1)) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -6 -15 -18 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "^" "min") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "o" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand* "o" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "walk_o") (("2" (hide-all-but (-1 -7 -12 -13 -15 -16 1)) (("2" (inst -1 "dg(G)" "w1" "w2 ^ (0, 1 - (length(w1) - i))") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (expand "^" -1 1) (("1" (case-replace "w2 ^ (0, 1 - (length(w1) - i)) ^
                                                                                                                      (1, length(w2 ^ (0, 1 - (length(w1) - i))) - 1) = w2 ^ (1, 1 - (length(w1) - i))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "^" "min") nil nil)) nil) ("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -4 -13 -16 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -4 -13 -16 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 1)) (("2" (replaces -1) (("2" (expand* "o" "rest" "^" "min" "empty_seq") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -3 -12 -15 1)) (("2" (replaces -3) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "empty_seq") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("5" (case "x!1 = w1 o w2 ^ (1, length(w2) - 1)") (("1" (hide -2 -3 -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" "x!1") (("1" (assert) (("1" (copy -2) (("1" (expand "o" -1) (("1" (decompose-equality -1) (("1" (hide -2) (("1" (expand "^" -1) (("1" (expand "min") (("1" (assert) (("1" (replace -3 -2) (("1" (case "(w1 o w2 ^ (1, length(w2) - 1)) ^ (0, length(w1) - 1) = w1 AND
                                                                                         (w1 o w2 ^ (1, length(w2) - 1)) ^ (length(w1) - 1,
                                                                                                                            length(w1 o w2 ^ (1, length(w2) - 1)) - 1) = w2") (("1" (flatten) (("1" (replace -1) (("1" (replace -2) (("1" (replace -5 -4 rl) (("1" (replace -5 -18) (("1" (expand "o" -18) (("1" (hide-all-but (-4 -6 -9 -10 -18 1)) (("1" (replaces -2) (("1" (replaces -4) (("1" (with-tccs (name-replace "M_x" "wgt_walk(G, x!1)")) (("1" (with-tccs (name-replace "M_w1" "wgt_walk(G, w1)")) (("1" (with-tccs (name-replace "M_w2" "wgt_walk(G, w2)")) (("1" (lemma "positive_pos_mul") (("1" (inst -1 "M_w1" "M_w2" "k1" "k1" "k1") (("1" (assert) (("1" (hide -1 2) (("1" (expand "Plus3") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (hide-all-but (-12 -15 1)) (("1" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -11 -12 -14 -15 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -12 -15 1)) (("2" (replaces -1) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min" "empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (flatten) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "eq_circuit_length") (("2" (inst -1 "dg(G)" "x!1" "w1 o rest(w2)") (("2" (assert) (("2" (expand* "cycle?" "circuit?") (("2" (flatten) (("2" (hide-all-but (-1 -4 1)) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (hide -1 2) (("4" (typepred "c!1") (("4" (expand* "circuit?" "pre_circuit?") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (typepred "c!1") (("5" (hide -1 -3 2) (("5" (expand* "circuit?" "pre_circuit?" "walk?" "verts_in?" "vert?" "last") (("5" (flatten) (("5" (hide -2 -3) (("5" (assert) (("5" (inst -1 "c!1`length - 1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (hide -1 2) (("6" (typepred "c!1") (("6" (expand* "circuit?" "pre_circuit?" "walk?" "verts_in?" "vert?") (("6" (flatten) (("6" (hide -3 -4) (("6" (expand "first") (("6" (assert) (("6" (inst -2 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((verts_in? const-decl "bool" walks_ digraphs) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (cycle_o_circuit formula-decl nil cycles_ digraphs) (eq_circuit? const-decl "bool" circuits_ digraphs) (rest const-decl "finseq" seq_extras structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (eq_circuit_symmetric formula-decl nil circuits_ digraphs) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (Plus3 const-decl "Sign3" measures nil) (positive_pos_mul formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (wgt_walk_decomposed formula-decl nil weighted_digraphs_ digraphs) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (walk?_caret formula-decl nil walks_ digraphs) (ll_defined_walks formula-decl nil matrix_wdg nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (walk_o formula-decl nil walks_ digraphs) (i skolem-const-decl "below[length(w1 o rest(w2))]" matrix_wdg nil) (w1 skolem-const-decl "prewalk
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make]" matrix_wdg nil) (empty_seq const-decl "finseq" finite_sequences nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (odd_minus_even_is_odd application-judgement "odd_int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (eq_circuit_position formula-decl nil circuits_ digraphs) (^ const-decl "finseq" finite_sequences nil) (int_plus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (O const-decl "finseq" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (cycle? const-decl "bool" cycles_ digraphs) (eq_circuit_length formula-decl nil circuits_ digraphs) (w2 skolem-const-decl "prewalk
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make]" matrix_wdg nil) (limiting_labeling? const-decl "bool" matrix_wdg nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (vertex_labeling type-eq-decl nil matrix_wdg nil) (vert type-eq-decl nil digraphs_ digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (get const-decl "Sign3" measures nil) (below type-eq-decl nil naturalnumbers nil) (identity? const-decl "bool" operator_defs nil) (associative? const-decl "bool" operator_defs nil) (walk? const-decl "bool" walks_ digraphs) (last const-decl "T" seq_extras structures) (G skolem-const-decl "wdg" matrix_wdg nil) (vert? const-decl "bool" digraphs_ digraphs) (/= const-decl "boolean" notequal nil) (not_empty_seq type-eq-decl nil seq_extras structures) (first const-decl "T" seq_extras structures) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (circuit? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil matrix_wdg nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil) (ll_pstv_pos_circuits-5 nil 3631659646 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (measure-induct+ "length(c)" ("c")) (("1" (typepred "x!1") (("1" (expand* "circuit?" "pre_circuit?" "first" "last") (("1" (assert) (("1" (flatten) (("1" (replace -3 1 rl) (("1" (name-replace "k1" "F(x!1`seq(0))" :hide? nil) (("1" (lemma "cycle_o_circuit") (("1" (inst -1 "dg(G)" "x!1") (("1" (assert) (("1" (split) (("1" (expand "limiting_labeling?") (("1" (flatten) (("1" (hide-all-but (-1 -2 -5 -9 1)) (("1" (inst -4 "x!1") (("1" (expand* "first" "last") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -9 "w2") (("2" (split) (("1" (copy -10) (("1" (expand "limiting_labeling?" -1) (("1" (flatten) (("1" (hide -1) (("1" (inst -1 "w1") (("1" (assert) (("1" (expand* "cycle?" "circuit?" "pre_circuit?") (("1" (assert) (("1" (flatten) (("1" (hide -7) (("1" (expand* "last" "first") (("1" (assert) (("1" (replace -5 -1 rl) (("1" (replace -8 -2) (("1" (copy -3) (("1" (expand "eq_circuit?" -1) (("1" (flatten) (("1" (hide -2) (("1" (expand* "circuit?" "pre_circuit?") (("1" (assert) (("1" (flatten) (("1" (hide -1) (("1" (expand "o" -1) (("1" (expand "rest" -1) (("1" (expand "^" -1) (("1" (expand "min") (("1" (replace -1 -4 rl) (("1" (name-replace "k2" "F(w1`seq(0))" :hide? nil) (("1" (lemma "eq_circuit_position") (("1" (lemma "eq_circuit_symmetric") (("1" (inst -1 "dg(G)" "x!1" "w1 o rest(w2)") (("1" (inst -2 "dg(G)" "w1 o rest(w2)" "x!1") (("1" (assert) (("1" (skeep -2) (("1" (hide -1) (("1" (typepred "i") (("1" (case "i = 0 OR (i /= 0 AND i < length(w1) - 1) OR i = length(w1) - 1 OR (i > length(w1) - 1 AND i /= length(w1 o rest(w2)) - 1) OR  i = length(w1 o rest(w2)) - 1") (("1" (split -1) (("1" (case "x!1 = w1 o w2 ^ (1, length(w2) - 1)") (("1" (hide -2 -3 -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" "x!1") (("1" (assert) (("1" (copy -2) (("1" (expand "o" -1) (("1" (decompose-equality -1) (("1" (hide -2) (("1" (expand "^" -1) (("1" (expand "min") (("1" (assert) (("1" (replace -3 -2) (("1" (case "(w1 o w2 ^ (1, length(w2) - 1)) ^ (0, length(w1) - 1) = w1 AND
                                                                      (w1 o w2 ^ (1, length(w2) - 1)) ^ (length(w1) - 1,
                                                                                                         length(w1 o w2 ^ (1, length(w2) - 1)) - 1) = w2") (("1" (flatten) (("1" (replace -1) (("1" (replace -2) (("1" (replace -5 -4 rl) (("1" (replace -5 -18) (("1" (expand "o" -18) (("1" (hide-all-but (-4 -6 -9 -10 -18 1)) (("1" (replaces -2) (("1" (replaces -4) (("1" (name-replace "M_x" "wgt_walk(G, x!1)") (("1" (name-replace "M_w1" "wgt_walk(G, w1)") (("1" (name-replace "M_w2" "wgt_walk(G, w2)") (("1" (lemma "positive_pos_mul") (("1" (inst -1 "M_w1" "M_w2" "k1" "k1" "k1") (("1" (assert) (("1" (hide -1 2) (("1" (expand "MPlus") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (hide-all-but (-12 -15 1)) (("1" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -11 -12 -14 -15 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -12 -15 1)) (("2" (replaces -1) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "x!1 = w1 ^ (i, length(w1) - 2) o w2 o w1 ^ (1, i)") (("1" (hide -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - i - 1" "x!1") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, length(w1) - i - 1) = w1 ^ (i, length(w1) - 1)") (("1" (case-replace "x!1 ^ (length(w1) - 1 - i, length(x!1) - 1) = w2 o w1 ^ (1,i)") (("1" (hide -1 -2) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w2) - 1" "w2 o w1 ^ (1, i)") (("1" (expand "o" -1 1) (("1" (expand "^" -1 1) (("1" (expand "min") (("1" (split -1) (("1" (case-replace "(w2 o w1 ^ (1, i)) ^ (0, length(w2) - 1) = w2") (("1" (case-replace "(w2 o w1 ^ (1, i)) ^
                                                                                                    (length(w2) - 1, length(w2 o w1 ^ (1, i)) - 1) = w1 ^ (0, i)") (("1" (hide -1 -2) (("1" (replaces -1) (("1" (lemma "ll_defined_walks") (("1" (inst-cp -1 "G" "F" "w1 ^ (i, length(w1) - 1)") (("1" (inst -1 "G" "F" "w1 ^ (0, i)") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (rewrite "walk?_caret") (("1" (expand* "first" "last") (("1" (assert) (("1" (expand "^" -1 (2 3 4)) (("1" (expand "min") (("1" (expand "^" -2 (2 3 4)) (("1" (expand "min") (("1" (replace -14 -2 rl) (("1" (replace -7) (("1" (replace -4 -19) (("1" (expand "o" -19) (("1" (expand "^" -19) (("1" (expand "min") (("1" (replace -19) (("1" (name-replace "Mx" "wgt_walk(G, x!1)") (("1" (name-replace "Mw1_1" "wgt_walk(G, w1 ^ (i, length(w1) - 1))") (("1" (name-replace "Mw2" "wgt_walk(G, w2)") (("1" (name-replace "Mw1_2" "wgt_walk(G, w1 ^ (0, i))") (("1" (hide-all-but (-1 -2 -3 -11 2)) (("1" (lemma " positive_pos_mul") (("1" (inst -1 "Mw2" "Mw1_2" "k2" "k2" "k1") (("1" (lemma " positive_pos_mul") (("1" (inst -1 "Mw1_1" "Mw2 * Mw1_2" "k1" "k2" "k1") (("1" (assert) (("1" (hide -4 2) (("1" (expand "MPlus") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -6 -15 -18 1 2)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "^" "min") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-5 -6 -15 -18 1 2)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-14 -17 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "walk_o") (("2" (hide-all-but (-1 -7 -12 -13 -14 -15 -16 -17 1)) (("2" (inst -1 "dg(G)" "w2" "w1 ^ (0, i)") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (expand "^" -1 1) (("1" (case-replace "w1 ^ (0, i) ^ (1, length(w1 ^ (0, i)) - 1) = (w1 ^ (1, i))") (("1" (hide-all-but (-5 1)) (("1" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "^" "min") nil nil)) nil) ("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -5 -7 -13 -14 -16 -17 1 2)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -4 -13 -16 1 2)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -3 -12 -15 1 2)) (("2" (replaces -1) (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -3 -12 -15 1 2)) (("2" (replaces -3) (("2" (decompose-equality 1) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality 1) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "x!1 = w2 o w1 ^ (1, length(w1) - 1)") (("1" (hide -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w2) - 1" "x!1") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, length(w2) - 1) = w2") (("1" (case-replace "x!1 ^ (length(w2) - 1, length(x!1) - 1) = w1 ^ (0, length(w1) - 1)") (("1" (hide -1 -2) (("1" (replace -2 -17) (("1" (expand "o" -17) (("1" (hide-all-but (-1 -5 -6 -15 -8 -9 -17 1)) (("1" (replaces -3) (("1" (replaces -5) (("1" (replaces -2) (("1" (replaces -4) (("1" (name-replace "Mx" "wgt_walk(G, x!1)") (("1" (case-replace "w1 ^ (0, length(w1) - 1) = w1") (("1" (name-replace "Mw1" "wgt_walk(G, w1)") (("1" (name-replace "Mw2" "wgt_walk(G, w2)") (("1" (hide -1) (("1" (lemma "positive_pos_mul") (("1" (inst -1 "Mw2" "Mw1" "k1" "k1" "k1") (("1" (assert) (("1" (hide -1 2) (("1" (expand "MPlus") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -14 -17 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -13 -16 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (replaces -1) (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -12 -15 1)) (("2" (replaces -1) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (case "x!1 = w2 ^ (i - (length(w1) - 1), length(w2) - 2) o w1 o w2 ^ (1, i - (length(w1) - 1))") (("1" (hide -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w2) - 2 - (i - length(w1))" "x!1") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, length(w1) -(2 - length(w2)) - i) =
                                                                           w2 ^ (i - (length(w1) - 1), length(w2) - 1)") (("1" (hide -1) (("1" (case-replace "x!1 ^ (length(w1) - (2 - length(w2)) - i, length(x!1) - 1)
                                                                                 = w1 o w2 ^ (1, i - (length(w1) - 1))") (("1" (hide -1) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" " w1 o w2 ^ (1, i - (length(w1) - 1))") (("1" (expand "o" -1 1) (("1" (expand "^" -1 1) (("1" (expand "min") (("1" (assert) (("1" (expand "o" -5) (("1" (expand "rest" -5) (("1" (expand "^" -5) (("1" (expand "min") (("1" (assert) (("1" (split -1) (("1" (case-replace "(w1 o w2 ^ (1, 1 - (length(w1) - i))) ^
                                                                                              (0, length(w1) - 1) = w1") (("1" (case-replace "(w1 o w2 ^ (1, 1 - (length(w1) - i))) ^
                                                                                                    (length(w1) - 1, length(w1 o w2 ^ (1, 1 - (length(w1) - i))) - 1)
                                                                                                   =  w2 ^ (0, 1 - (length(w1) - i))") (("1" (hide -1 -2) (("1" (replaces -1) (("1" (lemma "ll_defined_walks") (("1" (inst-cp -1 "G" "F" "w2 ^ (1 - (length(w1) - i), length(w2) - 1)") (("1" (inst -1 "G" "F" "w2 ^ (0, 1 - (length(w1) - i))") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (rewrite "walk?_caret") (("1" (expand* "first" "last") (("1" (assert) (("1" (expand "^" -1 (2 3 4)) (("1" (expand "^" -2 (2 3 4)) (("1" (expand "min") (("1" (replace -8 -2 rl) (("1" (replace -17 -1) (("1" (replace -8 -1 rl) (("1" (replace -7) (("1" (replace -4 -19) (("1" (expand "o" -19) (("1" (expand "^" -19) (("1" (expand* "min" "empty_seq") (("1" (lift-if) (("1" (assert) (("1" (expand "o" 1) (("1" (expand "rest" 1) (("1" (expand "^" 1) (("1" (expand "min") (("1" (assert) (("1" (replace -19) (("1" (name-replace "Mx" "wgt_walk(G, x!1)") (("1" (name-replace "Mw2_1" "wgt_walk(G, w2 ^ (1 - (length(w1) - i), length(w2) - 1))") (("1" (name-replace "Mw1" "wgt_walk(G, w1)") (("1" (name-replace "Mw2_2" "wgt_walk(G, w2 ^ (0, 1 - (length(w1) - i)))") (("1" (hide-all-but (-1 -2 -3 -10 2)) (("1" (lemma "positive_pos_mul") (("1" (inst-cp -1 "Mw1" "Mw2_2" "k2" "k2" "k1") (("1" (inst -1 "Mw2_1" "Mw1 * Mw2_2" "k1" "k2" "k1") (("1" (assert) (("1" (hide -4 2) (("1" (expand "MPlus") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (rewrite "walk?_caret") (("4" (hide-all-but (-6 -7 1)) (("4" (expand* "^" "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (rewrite "walk?_caret") (("4" (hide-all-but (-6 -7 1)) (("4" (expand* "^" "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 1)) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -6 -15 -18 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "^" "min") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "o" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand* "o" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "walk_o") (("2" (hide-all-but (-1 -7 -12 -13 -15 -16 1)) (("2" (inst -1 "dg(G)" "w1" "w2 ^ (0, 1 - (length(w1) - i))") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (expand "^" -1 1) (("1" (case-replace "w2 ^ (0, 1 - (length(w1) - i)) ^
                                                                                            (1, length(w2 ^ (0, 1 - (length(w1) - i))) - 1) = w2 ^ (1, 1 - (length(w1) - i))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "^" "min") nil nil)) nil) ("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -4 -13 -16 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -4 -13 -16 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 1)) (("2" (replaces -1) (("2" (expand* "o" "rest" "^" "min" "empty_seq") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -3 -12 -15 1)) (("2" (replaces -3) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "empty_seq") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("5" (case "x!1 = w1 o w2 ^ (1, length(w2) - 1)") (("1" (hide -2 -3 -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" "x!1") (("1" (assert) (("1" (copy -2) (("1" (expand "o" -1) (("1" (decompose-equality -1) (("1" (hide -2) (("1" (expand "^" -1) (("1" (expand "min") (("1" (assert) (("1" (replace -3 -2) (("1" (case "(w1 o w2 ^ (1, length(w2) - 1)) ^ (0, length(w1) - 1) = w1 AND
                                                                      (w1 o w2 ^ (1, length(w2) - 1)) ^ (length(w1) - 1,
                                                                                                         length(w1 o w2 ^ (1, length(w2) - 1)) - 1) = w2") (("1" (flatten) (("1" (replace -1) (("1" (replace -2) (("1" (replace -5 -4 rl) (("1" (replace -5 -18) (("1" (expand "o" -18) (("1" (hide-all-but (-4 -6 -9 -10 -18 1)) (("1" (replaces -2) (("1" (replaces -4) (("1" (name-replace "M_x" "wgt_walk(G, x!1)") (("1" (name-replace "M_w1" "wgt_walk(G, w1)") (("1" (name-replace "M_w2" "wgt_walk(G, w2)") (("1" (lemma "positive_pos_mul") (("1" (inst -1 "M_w1" "M_w2" "k1" "k1" "k1") (("1" (assert) (("1" (hide -1 2) (("1" (expand "MPlus") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (hide-all-but (-12 -15 1)) (("1" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -11 -12 -14 -15 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -12 -15 1)) (("2" (replaces -1) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min" "empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (flatten) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "eq_circuit_length") (("2" (inst -1 "dg(G)" "x!1" "w1 o rest(w2)") (("2" (assert) (("2" (expand* "cycle?" "circuit?") (("2" (flatten) (("2" (hide-all-but (-1 -4 1)) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (hide -1 2) (("4" (typepred "c!1") (("4" (expand* "circuit?" "pre_circuit?") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (hide -1 2) (("5" (typepred "c!1") (("5" (expand* "circuit?" "pre_circuit?" "walk?" "verts_in?" "vert?") (("5" (flatten) (("5" (hide -3 -4) (("5" (expand "first") (("5" (assert) (("5" (inst -2 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (typepred "c!1") (("6" (hide -1 -3 2) (("6" (expand* "circuit?" "pre_circuit?" "walk?" "verts_in?" "vert?" "last") (("6" (flatten) (("6" (hide -2 -3) (("6" (assert) (("6" (inst -1 "c!1`length - 1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (ll_pstv_pos_circuits-4 nil 3610121493 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (measure-induct+ "length(c)" ("c")) (("1" (typepred "x!1") (("1" (expand* "circuit?" "pre_circuit?" "first" "last") (("1" (assert) (("1" (flatten) (("1" (replace -3 1 rl) (("1" (name-replace "k1" "F(x!1`seq(0))" :hide? nil) (("1" (lemma "cycle_o_circuit") (("1" (inst -1 "dg(G)" "x!1") (("1" (assert) (("1" (split) (("1" (expand "limiting_labeling?") (("1" (flatten) (("1" (hide-all-but (-1 -2 -5 -9 1)) (("1" (inst -4 "x!1") (("1" (expand* "first" "last") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -9 "w2") (("2" (split) (("1" (copy -10) (("1" (expand "limiting_labeling?" -1) (("1" (flatten) (("1" (hide -1) (("1" (inst -1 "w1") (("1" (assert) (("1" (expand* "cycle?" "circuit?" "pre_circuit?") (("1" (assert) (("1" (flatten) (("1" (hide -7) (("1" (expand* "last" "first") (("1" (assert) (("1" (replace -5 -1 rl) (("1" (replace -8 -2) (("1" (copy -3) (("1" (expand "eq_circuit?" -1) (("1" (flatten) (("1" (hide -2) (("1" (expand* "circuit?" "pre_circuit?") (("1" (assert) (("1" (flatten) (("1" (hide -1) (("1" (expand "o" -1) (("1" (expand "rest" -1) (("1" (expand "^" -1) (("1" (expand "min") (("1" (replace -1 -4 rl) (("1" (name-replace "k2" "F(w1`seq(0))" :hide? nil) (("1" (lemma "eq_circuit_position") (("1" (lemma "eq_circuit_symmetric") (("1" (inst -1 "dg(G)" "x!1" "w1 o rest(w2)") (("1" (inst -2 "dg(G)" "w1 o rest(w2)" "x!1") (("1" (assert) (("1" (skeep -2) (("1" (hide -1) (("1" (typepred "i") (("1" (case "i = 0 OR (i /= 0 AND i < length(w1) - 1) OR i = length(w1) - 1 OR (i > length(w1) - 1 AND i /= length(w1 o rest(w2)) - 1) OR  i = length(w1 o rest(w2)) - 1") (("1" (split -1) (("1" (case "x!1 = w1 o w2 ^ (1, length(w2) - 1)") (("1" (hide -2 -3 -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" "x!1") (("1" (assert) (("1" (copy -2) (("1" (expand "o" -1) (("1" (decompose-equality -1) (("1" (hide -2) (("1" (expand "^" -1) (("1" (expand "min") (("1" (assert) (("1" (replace -3 -2) (("1" (case "(w1 o w2 ^ (1, length(w2) - 1)) ^ (0, length(w1) - 1) = w1 AND
                                                   (w1 o w2 ^ (1, length(w2) - 1)) ^ (length(w1) - 1,
                                                                                      length(w1 o w2 ^ (1, length(w2) - 1)) - 1) = w2") (("1" (flatten) (("1" (replace -1) (("1" (replace -2) (("1" (replace -5 -4 rl) (("1" (replace -5 -18) (("1" (expand "o" -18) (("1" (hide-all-but (-4 -6 -9 -10 -18 1)) (("1" (replaces -2) (("1" (replaces -4) (("1" (name-replace "M_x" "wgt_walk(G, x!1)") (("1" (name-replace "M_w1" "wgt_walk(G, w1)") (("1" (name-replace "M_w2" "wgt_walk(G, w2)") (("1" (lemma "positive_pos_mul") (("1" (inst -1 "M_w1" "M_w2" "k1" "k1" "k1") (("1" (assert) (("1" (hide -1 2) (("1" (expand "+") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (hide-all-but (-12 -15 1)) (("1" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -11 -12 -14 -15 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -12 -15 1)) (("2" (replaces -1) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "x!1 = w1 ^ (i, length(w1) - 2) o w2 o w1 ^ (1, i)") (("1" (hide -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - i - 1" "x!1") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, length(w1) - i - 1) = w1 ^ (i, length(w1) - 1)") (("1" (case-replace "x!1 ^ (length(w1) - 1 - i, length(x!1) - 1) = w2 o w1 ^ (1,i)") (("1" (hide -1 -2) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w2) - 1" "w2 o w1 ^ (1, i)") (("1" (expand "o" -1 1) (("1" (expand "^" -1 1) (("1" (expand "min") (("1" (split -1) (("1" (case-replace "(w2 o w1 ^ (1, i)) ^ (0, length(w2) - 1) = w2") (("1" (case-replace "(w2 o w1 ^ (1, i)) ^
                                                                          (length(w2) - 1, length(w2 o w1 ^ (1, i)) - 1) = w1 ^ (0, i)") (("1" (hide -1 -2) (("1" (replaces -1) (("1" (lemma "ll_defined_walks") (("1" (inst-cp -1 "G" "F" "w1 ^ (i, length(w1) - 1)") (("1" (inst -1 "G" "F" "w1 ^ (0, i)") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (rewrite "walk?_caret") (("1" (expand* "first" "last") (("1" (assert) (("1" (expand "^" -1 (2 3 4)) (("1" (expand "min") (("1" (expand "^" -2 (2 3 4)) (("1" (expand "min") (("1" (replace -14 -2 rl) (("1" (replace -7) (("1" (replace -4 -19) (("1" (expand "o" -19) (("1" (expand "^" -19) (("1" (expand "min") (("1" (replace -19) (("1" (name-replace "Mx" "wgt_walk(G, x!1)") (("1" (name-replace "Mw1_1" "wgt_walk(G, w1 ^ (i, length(w1) - 1))") (("1" (name-replace "Mw2" "wgt_walk(G, w2)") (("1" (name-replace "Mw1_2" "wgt_walk(G, w1 ^ (0, i))") (("1" (hide-all-but (-1 -2 -3 -11 2)) (("1" (lemma " positive_pos_mul") (("1" (inst -1 "Mw2" "Mw1_2" "k2" "k2" "k1") (("1" (lemma " positive_pos_mul") (("1" (inst -1 "Mw1_1" "Mw2 * Mw1_2" "k1" "k2" "k1") (("1" (assert) (("1" (hide -4 2) (("1" (expand "+") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -6 -15 -18 1 2)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "^" "min") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-5 -6 -15 -18 1 2)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-14 -17 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "walk_o") (("2" (hide-all-but (-1 -7 -12 -13 -14 -15 -16 -17 1)) (("2" (inst -1 "dg(G)" "w2" "w1 ^ (0, i)") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (expand "^" -1 1) (("1" (case-replace "w1 ^ (0, i) ^ (1, length(w1 ^ (0, i)) - 1) = (w1 ^ (1, i))") (("1" (hide-all-but (-5 1)) (("1" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "^" "min") nil nil)) nil) ("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -5 -7 -13 -14 -16 -17 1 2)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -4 -13 -16 1 2)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -3 -12 -15 1 2)) (("2" (replaces -1) (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -3 -12 -15 1 2)) (("2" (replaces -3) (("2" (decompose-equality 1) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality 1) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "x!1 = w2 o w1 ^ (1, length(w1) - 1)") (("1" (hide -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w2) - 1" "x!1") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, length(w2) - 1) = w2") (("1" (case-replace "x!1 ^ (length(w2) - 1, length(x!1) - 1) = w1 ^ (0, length(w1) - 1)") (("1" (hide -1 -2) (("1" (replace -2 -17) (("1" (expand "o" -17) (("1" (hide-all-but (-1 -5 -6 -15 -8 -9 -17 1)) (("1" (replaces -3) (("1" (replaces -5) (("1" (replaces -2) (("1" (replaces -4) (("1" (name-replace "Mx" "wgt_walk(G, x!1)") (("1" (case-replace "w1 ^ (0, length(w1) - 1) = w1") (("1" (name-replace "Mw1" "wgt_walk(G, w1)") (("1" (name-replace "Mw2" "wgt_walk(G, w2)") (("1" (hide -1) (("1" (lemma "positive_pos_mul") (("1" (inst -1 "Mw2" "Mw1" "k1" "k1" "k1") (("1" (assert) (("1" (hide -1 2) (("1" (expand "+") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -14 -17 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -13 -16 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (replaces -1) (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -12 -15 1)) (("2" (replaces -1) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (case "x!1 = w2 ^ (i - (length(w1) - 1), length(w2) - 2) o w1 o w2 ^ (1, i - (length(w1) - 1))") (("1" (hide -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w2) - 2 - (i - length(w1))" "x!1") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, length(w1) -(2 - length(w2)) - i) =
                                                         w2 ^ (i - (length(w1) - 1), length(w2) - 1)") (("1" (hide -1) (("1" (case-replace "x!1 ^ (length(w1) - (2 - length(w2)) - i, length(x!1) - 1)
                                                             = w1 o w2 ^ (1, i - (length(w1) - 1))") (("1" (hide -1) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" " w1 o w2 ^ (1, i - (length(w1) - 1))") (("1" (expand "o" -1 1) (("1" (expand "^" -1 1) (("1" (expand "min") (("1" (assert) (("1" (expand "o" -5) (("1" (expand "rest" -5) (("1" (expand "^" -5) (("1" (expand "min") (("1" (assert) (("1" (split -1) (("1" (case-replace "(w1 o w2 ^ (1, 1 - (length(w1) - i))) ^
                                                                      (0, length(w1) - 1) = w1") (("1" (case-replace "(w1 o w2 ^ (1, 1 - (length(w1) - i))) ^
                                                                          (length(w1) - 1, length(w1 o w2 ^ (1, 1 - (length(w1) - i))) - 1)
                                                                         =  w2 ^ (0, 1 - (length(w1) - i))") (("1" (hide -1 -2) (("1" (replaces -1) (("1" (lemma "ll_defined_walks") (("1" (inst-cp -1 "G" "F" "w2 ^ (1 - (length(w1) - i), length(w2) - 1)") (("1" (inst -1 "G" "F" "w2 ^ (0, 1 - (length(w1) - i))") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (rewrite "walk?_caret") (("1" (expand* "first" "last") (("1" (assert) (("1" (expand "^" -1 (2 3 4)) (("1" (expand "^" -2 (2 3 4)) (("1" (expand "min") (("1" (replace -8 -2 rl) (("1" (replace -17 -1) (("1" (replace -8 -1 rl) (("1" (replace -7) (("1" (replace -4 -19) (("1" (expand "o" -19) (("1" (expand "^" -19) (("1" (expand* "min" "empty_seq") (("1" (lift-if) (("1" (assert) (("1" (expand "o" 1) (("1" (expand "rest" 1) (("1" (expand "^" 1) (("1" (expand "min") (("1" (assert) (("1" (replace -19) (("1" (name-replace "Mx" "wgt_walk(G, x!1)") (("1" (name-replace "Mw2_1" "wgt_walk(G, w2 ^ (1 - (length(w1) - i), length(w2) - 1))") (("1" (name-replace "Mw1" "wgt_walk(G, w1)") (("1" (name-replace "Mw2_2" "wgt_walk(G, w2 ^ (0, 1 - (length(w1) - i)))") (("1" (hide-all-but (-1 -2 -3 -10 2)) (("1" (lemma "positive_pos_mul") (("1" (inst-cp -1 "Mw1" "Mw2_2" "k2" "k2" "k1") (("1" (inst -1 "Mw2_1" "Mw1 * Mw2_2" "k1" "k2" "k1") (("1" (assert) (("1" (hide -4 2) (("1" (expand "+") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (rewrite "walk?_caret") (("4" (hide-all-but (-6 -7 1)) (("4" (expand* "^" "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (rewrite "walk?_caret") (("4" (hide-all-but (-6 -7 1)) (("4" (expand* "^" "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 1)) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -6 -15 -18 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "^" "min") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "o" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand* "o" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "walk_o") (("2" (hide-all-but (-1 -7 -12 -13 -15 -16 1)) (("2" (inst -1 "dg(G)" "w1" "w2 ^ (0, 1 - (length(w1) - i))") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (expand "^" -1 1) (("1" (case-replace "w2 ^ (0, 1 - (length(w1) - i)) ^
                                                                  (1, length(w2 ^ (0, 1 - (length(w1) - i))) - 1) = w2 ^ (1, 1 - (length(w1) - i))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "^" "min") nil nil)) nil) ("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -4 -13 -16 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -4 -13 -16 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 1)) (("2" (replaces -1) (("2" (expand* "o" "rest" "^" "min" "empty_seq") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -3 -12 -15 1)) (("2" (replaces -3) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "empty_seq") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("5" (case "x!1 = w1 o w2 ^ (1, length(w2) - 1)") (("1" (hide -2 -3 -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" "x!1") (("1" (assert) (("1" (copy -2) (("1" (expand "o" -1) (("1" (decompose-equality -1) (("1" (hide -2) (("1" (expand "^" -1) (("1" (expand "min") (("1" (assert) (("1" (replace -3 -2) (("1" (case "(w1 o w2 ^ (1, length(w2) - 1)) ^ (0, length(w1) - 1) = w1 AND
                                                   (w1 o w2 ^ (1, length(w2) - 1)) ^ (length(w1) - 1,
                                                                                      length(w1 o w2 ^ (1, length(w2) - 1)) - 1) = w2") (("1" (flatten) (("1" (replace -1) (("1" (replace -2) (("1" (replace -5 -4 rl) (("1" (replace -5 -18) (("1" (expand "o" -18) (("1" (hide-all-but (-4 -6 -9 -10 -18 1)) (("1" (replaces -2) (("1" (replaces -4) (("1" (name-replace "M_x" "wgt_walk(G, x!1)") (("1" (name-replace "M_w1" "wgt_walk(G, w1)") (("1" (name-replace "M_w2" "wgt_walk(G, w2)") (("1" (lemma "positive_pos_mul") (("1" (inst -1 "M_w1" "M_w2" "k1" "k1" "k1") (("1" (assert) (("1" (hide -1 2) (("1" (expand "+") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (hide-all-but (-12 -15 1)) (("1" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -11 -12 -14 -15 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -12 -15 1)) (("2" (replaces -1) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min" "empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (flatten) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "eq_circuit_length") (("2" (inst -1 "dg(G)" "x!1" "w1 o rest(w2)") (("2" (assert) (("2" (expand* "cycle?" "circuit?") (("2" (flatten) (("2" (hide-all-but (-1 -4 1)) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (hide -1 2) (("4" (typepred "c!1") (("4" (expand* "circuit?" "pre_circuit?") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (hide -1 2) (("5" (typepred "c!1") (("5" (expand* "circuit?" "pre_circuit?" "walk?" "verts_in?" "vert?") (("5" (flatten) (("5" (hide -3 -4) (("5" (expand "first") (("5" (assert) (("5" (inst -2 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (typepred "c!1") (("6" (hide -1 -3 2) (("6" (expand* "circuit?" "pre_circuit?" "walk?" "verts_in?" "vert?" "last") (("6" (flatten) (("6" (hide -2 -3) (("6" (assert) (("6" (inst -1 "c!1`length - 1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (ll_pstv_pos_circuits-3 nil 3593815952 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (measure-induct+ "length(c)" ("c")) (("1" (typepred "x!1") (("1" (expand* "circuit?" "pre_circuit?" "first" "last") (("1" (assert) (("1" (flatten) (("1" (replace -3 1 rl) (("1" (name-replace "k1" "F(x!1`seq(0))" :hide? nil) (("1" (lemma "cycle_o_circuit") (("1" (inst -1 "dg(G)" "x!1") (("1" (assert) (("1" (split) (("1" (expand "limiting_labeling?") (("1" (flatten) (("1" (hide-all-but (-1 -2 -5 -9 1)) (("1" (inst -4 "x!1") (("1" (expand* "first" "last") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -9 "w2") (("2" (split) (("1" (copy -10) (("1" (expand "limiting_labeling?" -1) (("1" (flatten) (("1" (hide -1) (("1" (inst -1 "w1") (("1" (assert) (("1" (expand* "cycle?" "circuit?" "pre_circuit?") (("1" (assert) (("1" (flatten) (("1" (hide -7) (("1" (expand* "last" "first") (("1" (assert) (("1" (replace -5 -1 rl) (("1" (replace -8 -2) (("1" (copy -3) (("1" (expand "eq_circuit?" -1) (("1" (flatten) (("1" (hide -2) (("1" (expand* "circuit?" "pre_circuit?") (("1" (assert) (("1" (flatten) (("1" (hide -1) (("1" (expand "o" -1) (("1" (expand "rest" -1) (("1" (expand "^" -1) (("1" (expand "min") (("1" (replace -1 -4 rl) (("1" (name-replace "k2" "F(w1`seq(0))" :hide? nil) (("1" (lemma "eq_circuit_position") (("1" (lemma "eq_circuit_symmetric") (("1" (inst -1 "dg(G)" "x!1" "w1 o rest(w2)") (("1" (inst -2 "dg(G)" "w1 o rest(w2)" "x!1") (("1" (assert) (("1" (skeep -2) (("1" (hide -1) (("1" (typepred "i") (("1" (case "i = 0 OR (i /= 0 AND i < length(w1) - 1) OR i = length(w1) - 1 OR (i > length(w1) - 1 AND i /= length(w1 o rest(w2)) - 1) OR  i = length(w1 o rest(w2)) - 1") (("1" (split -1) (("1" (case "x!1 = w1 o w2 ^ (1, length(w2) - 1)") (("1" (hide -2 -3 -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" "x!1") (("1" (assert) (("1" (copy -2) (("1" (expand "o" -1) (("1" (decompose-equality -1) (("1" (hide -2) (("1" (expand "^" -1) (("1" (expand "min") (("1" (assert) (("1" (replace -3 -2) (("1" (case "(w1 o w2 ^ (1, length(w2) - 1)) ^ (0, length(w1) - 1) = w1 AND
                                (w1 o w2 ^ (1, length(w2) - 1)) ^ (length(w1) - 1,
                                                                   length(w1 o w2 ^ (1, length(w2) - 1)) - 1) = w2") (("1" (flatten) (("1" (replace -1) (("1" (replace -2) (("1" (replace -5 -4 rl) (("1" (replace -5 -18) (("1" (expand "o" -18) (("1" (hide-all-but (-4 -6 -9 -10 -18 1)) (("1" (replaces -2) (("1" (replaces -4) (("1" (name-replace "M_x" "wgt_walk(G, x!1)") (("1" (name-replace "M_w1" "wgt_walk(G, w1)") (("1" (name-replace "M_w2" "wgt_walk(G, w2)") (("1" (lemma "positive_mult_pos") (("1" (inst -1 "M_w1" "M_w2" "k1") (("1" (expand "+") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (hide-all-but (-12 -15 1)) (("1" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -11 -12 -14 -15 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -12 -15 1)) (("2" (replaces -1) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "x!1 = w1 ^ (i, length(w1) - 2) o w2 o w1 ^ (1, i)") (("1" (hide -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - i - 1" "x!1") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, length(w1) - i - 1) = w1 ^ (i, length(w1) - 1)") (("1" (case-replace "x!1 ^ (length(w1) - 1 - i, length(x!1) - 1) = w2 o w1 ^ (1,i)") (("1" (hide -1 -2) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w2) - 1" "w2 o w1 ^ (1, i)") (("1" (expand "o" -1 1) (("1" (expand "^" -1 1) (("1" (expand "min") (("1" (split -1) (("1" (case-replace "(w2 o w1 ^ (1, i)) ^ (0, length(w2) - 1) = w2") (("1" (case-replace "(w2 o w1 ^ (1, i)) ^
                                                (length(w2) - 1, length(w2 o w1 ^ (1, i)) - 1) = w1 ^ (0, i)") (("1" (hide -1 -2) (("1" (replaces -1) (("1" (lemma "ll_defined_walks") (("1" (inst-cp -1 "G" "F" "w1 ^ (i, length(w1) - 1)") (("1" (inst -1 "G" "F" "w1 ^ (0, i)") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (rewrite "walk?_caret") (("1" (expand* "first" "last") (("1" (assert) (("1" (expand "^" -1 (2 3 4)) (("1" (expand "min") (("1" (expand "^" -2 (2 3 4)) (("1" (expand "min") (("1" (replace -14 -2 rl) (("1" (replace -7) (("1" (replace -4 -19) (("1" (expand "o" -19) (("1" (expand "^" -19) (("1" (expand "min") (("1" (replace -19) (("1" (name-replace "Mx" "wgt_walk(G, x!1)") (("1" (name-replace "Mw1_1" "wgt_walk(G, w1 ^ (i, length(w1) - 1))") (("1" (name-replace "Mw2" "wgt_walk(G, w2)") (("1" (name-replace "Mw1_2" "wgt_walk(G, w1 ^ (0, i))") (("1" (hide-all-but (-1 -2 -3 -11 2)) (("1" (lemma " positive_pos_mul") (("1" (inst -1 "Mw2" "Mw1_2" "k2" "k2" "k1") (("1" (lemma " positive_pos_mul") (("1" (inst -1 "Mw1_1" "Mw2 * Mw1_2" "k1" "k2" "k1") (("1" (assert) (("1" (hide -4 2) (("1" (expand "+") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -6 -15 -18 1 2)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "^" "min") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-5 -6 -15 -18 1 2)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-14 -17 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "walk_o") (("2" (hide-all-but (-1 -7 -12 -13 -14 -15 -16 -17 1)) (("2" (inst -1 "dg(G)" "w2" "w1 ^ (0, i)") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (expand "^" -1 1) (("1" (case-replace "w1 ^ (0, i) ^ (1, length(w1 ^ (0, i)) - 1) = (w1 ^ (1, i))") (("1" (hide-all-but (-5 1)) (("1" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "^" "min") nil nil)) nil) ("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -5 -7 -13 -14 -16 -17 1 2)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -4 -13 -16 1 2)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -3 -12 -15 1 2)) (("2" (replaces -1) (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -3 -12 -15 1 2)) (("2" (replaces -3) (("2" (decompose-equality 1) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality 1) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "x!1 = w2 o w1 ^ (1, length(w1) - 1)") (("1" (hide -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w2) - 1" "x!1") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, length(w2) - 1) = w2") (("1" (case-replace "x!1 ^ (length(w2) - 1, length(x!1) - 1) = w1 ^ (0, length(w1) - 1)") (("1" (hide -1 -2) (("1" (replace -2 -17) (("1" (expand "o" -17) (("1" (hide-all-but (-1 -5 -6 -15 -8 -9 -17 1)) (("1" (replaces -3) (("1" (replaces -5) (("1" (replaces -2) (("1" (replaces -4) (("1" (name-replace "Mx" "wgt_walk(G, x!1)") (("1" (case-replace "w1 ^ (0, length(w1) - 1) = w1") (("1" (name-replace "Mw1" "wgt_walk(G, w1)") (("1" (name-replace "Mw2" "wgt_walk(G, w2)") (("1" (hide -1) (("1" (lemma "positive_pos_mul") (("1" (inst -1 "Mw2" "Mw1" "k1" "k1" "k1") (("1" (assert) (("1" (hide -1 2) (("1" (expand "+") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -14 -17 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -13 -16 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (replaces -1) (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -12 -15 1)) (("2" (replaces -1) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (flatten) (("4" (case "x!1 = w2 ^ (i - (length(w1) - 1), length(w2) - 2) o w1 o w2 ^ (1, i - (length(w1) - 1))") (("1" (hide -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w2) - 2 - (i - length(w1))" "x!1") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, length(w1) -(2 - length(w2)) - i) =
                                       w2 ^ (i - (length(w1) - 1), length(w2) - 1)") (("1" (hide -1) (("1" (case-replace "x!1 ^ (length(w1) - (2 - length(w2)) - i, length(x!1) - 1)
                                         = w1 o w2 ^ (1, i - (length(w1) - 1))") (("1" (hide -1) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" " w1 o w2 ^ (1, i - (length(w1) - 1))") (("1" (expand "o" -1 1) (("1" (expand "^" -1 1) (("1" (expand "min") (("1" (assert) (("1" (expand "o" -5) (("1" (expand "rest" -5) (("1" (expand "^" -5) (("1" (expand "min") (("1" (assert) (("1" (split -1) (("1" (case-replace "(w1 o w2 ^ (1, 1 - (length(w1) - i))) ^
                                              (0, length(w1) - 1) = w1") (("1" (case-replace "(w1 o w2 ^ (1, 1 - (length(w1) - i))) ^
                                                (length(w1) - 1, length(w1 o w2 ^ (1, 1 - (length(w1) - i))) - 1)
                                               =  w2 ^ (0, 1 - (length(w1) - i))") (("1" (hide -1 -2) (("1" (replaces -1) (("1" (lemma "ll_defined_walks") (("1" (inst-cp -1 "G" "F" "w2 ^ (1 - (length(w1) - i), length(w2) - 1)") (("1" (inst -1 "G" "F" "w2 ^ (0, 1 - (length(w1) - i))") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (rewrite "walk?_caret") (("1" (expand* "first" "last") (("1" (assert) (("1" (expand "^" -1 (2 3 4)) (("1" (expand "^" -2 (2 3 4)) (("1" (expand "min") (("1" (replace -8 -2 rl) (("1" (replace -17 -1) (("1" (replace -8 -1 rl) (("1" (replace -7) (("1" (replace -4 -19) (("1" (expand "o" -19) (("1" (expand "^" -19) (("1" (expand* "min" "empty_seq") (("1" (lift-if) (("1" (assert) (("1" (expand "o" 1) (("1" (expand "rest" 1) (("1" (expand "^" 1) (("1" (expand "min") (("1" (assert) (("1" (replace -19) (("1" (name-replace "Mx" "wgt_walk(G, x!1)") (("1" (name-replace "Mw2_1" "wgt_walk(G, w2 ^ (1 - (length(w1) - i), length(w2) - 1))") (("1" (name-replace "Mw1" "wgt_walk(G, w1)") (("1" (name-replace "Mw2_2" "wgt_walk(G, w2 ^ (0, 1 - (length(w1) - i)))") (("1" (hide-all-but (-1 -2 -3 -10 2)) (("1" (lemma "positive_pos_mul") (("1" (inst-cp -1 "Mw1" "Mw2_2" "k2" "k2" "k1") (("1" (inst -1 "Mw2_1" "Mw1 * Mw2_2" "k1" "k2" "k1") (("1" (assert) (("1" (hide -4 2) (("1" (expand "+") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (rewrite "walk?_caret") (("4" (hide-all-but (-6 -7 1)) (("4" (expand* "^" "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (rewrite "id_is_identity") nil nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (rewrite "walk?_caret") (("4" (hide-all-but (-6 -7 1)) (("4" (expand* "^" "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 1)) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -6 -15 -18 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "^" "min") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "o" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand* "o" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "walk_o") (("2" (hide-all-but (-1 -7 -12 -13 -15 -16 1)) (("2" (inst -1 "dg(G)" "w1" "w2 ^ (0, 1 - (length(w1) - i))") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (expand "^" -1 1) (("1" (case-replace "w2 ^ (0, 1 - (length(w1) - i)) ^
                                        (1, length(w2 ^ (0, 1 - (length(w1) - i))) - 1) = w2 ^ (1, 1 - (length(w1) - i))") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (expand* "^" "min") nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "^" "min") nil nil)) nil) ("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -4 -13 -16 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -4 -13 -16 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (assert) (("1" (lift-if) (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 1)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 1)) (("2" (replaces -1) (("2" (expand* "o" "rest" "^" "min" "empty_seq") (("2" (assert) (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1)) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -3 -12 -15 1)) (("2" (replaces -3) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (assert) (("2" (expand "empty_seq") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("5" (case "x!1 = w1 o w2 ^ (1, length(w2) - 1)") (("1" (hide -2 -3 -4) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" "x!1") (("1" (assert) (("1" (copy -2) (("1" (expand "o" -1) (("1" (decompose-equality -1) (("1" (hide -2) (("1" (expand "^" -1) (("1" (expand "min") (("1" (assert) (("1" (replace -3 -2) (("1" (case "(w1 o w2 ^ (1, length(w2) - 1)) ^ (0, length(w1) - 1) = w1 AND
                                (w1 o w2 ^ (1, length(w2) - 1)) ^ (length(w1) - 1,
                                                                   length(w1 o w2 ^ (1, length(w2) - 1)) - 1) = w2") (("1" (flatten) (("1" (replace -1) (("1" (replace -2) (("1" (replace -5 -4 rl) (("1" (replace -5 -18) (("1" (expand "o" -18) (("1" (hide-all-but (-4 -6 -9 -10 -18 1)) (("1" (replaces -2) (("1" (replaces -4) (("1" (name-replace "M_x" "wgt_walk(G, x!1)") (("1" (name-replace "M_w1" "wgt_walk(G, w1)") (("1" (name-replace "M_w2" "wgt_walk(G, w2)") (("1" (lemma "positive_pos_mul") (("1" (inst -1 "M_w1" "M_w2" "k1" "k1" "k1") (("1" (assert) (("1" (hide -1 2) (("1" (expand "+") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split 1) (("1" (hide-all-but (-12 -15 1)) (("1" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -11 -12 -14 -15 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -12 -15 1)) (("2" (replaces -1) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min" "empty_seq") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (flatten) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "eq_circuit_length") (("2" (inst -1 "dg(G)" "x!1" "w1 o rest(w2)") (("2" (assert) (("2" (expand* "cycle?" "circuit?") (("2" (flatten) (("2" (hide-all-but (-1 -4 1)) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (hide -1 2) (("4" (typepred "c!1") (("4" (expand* "circuit?" "pre_circuit?") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (hide -1 2) (("5" (typepred "c!1") (("5" (expand* "circuit?" "pre_circuit?" "walk?" "verts_in?" "vert?") (("5" (flatten) (("5" (hide -3 -4) (("5" (expand "first") (("5" (assert) (("5" (inst -2 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (typepred "c!1") (("6" (hide -1 -3 2) (("6" (expand* "circuit?" "pre_circuit?" "walk?" "verts_in?" "vert?" "last") (("6" (flatten) (("6" (hide -2 -3) (("6" (assert) (("6" (inst -1 "c!1`length - 1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (ll_pstv_pos_circuits-2 nil 3593815238 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (measure-induct+ "length(c)" ("c")) (("1" (typepred "x!1") (("1" (expand* "circuit?" "pre_circuit?" "first" "last") (("1" (assert) (("1" (flatten) (("1" (replace -3 1 rl) (("1" (name-replace "k1" "F(x!1`seq(0))" :hide? nil) (("1" (case "cycle?(dg(G),x!1)") (("1" (hide -3 -4 -6 -7) (("1" (expand "limiting_labeling?") (("1" (flatten) (("1" (hide -4) (("1" (inst -4 "x!1") (("1" (expand* "first" "last") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3) (("2" (lemma "cycle_o_circuit") (("2" (inst -1 "dg(G)" "x!1") (("2" (assert) (("2" (skeep) (("2" (inst -7 "w2") (("2" (split) (("1" (copy -8) (("1" (expand "limiting_labeling?" -1) (("1" (flatten) (("1" (hide -1) (("1" (inst -1 "w1") (("1" (assert) (("1" (expand* "cycle?" "circuit?" "pre_circuit?") (("1" (assert) (("1" (flatten) (("1" (hide -7 1) (("1" (expand* "last" "first") (("1" (assert) (("1" (replace -5 -1 rl) (("1" (replace -8 -2 rl) (("1" (copy -3) (("1" (expand "eq_circuit?" -1) (("1" (flatten) (("1" (hide -2) (("1" (expand* "circuit?" "pre_circuit?") (("1" (assert) (("1" (flatten) (("1" (hide -1) (("1" (expand "o" -1) (("1" (expand "rest" -1) (("1" (expand "^" -1) (("1" (expand "min") (("1" (hide -6 -9) (("1" (replace -8 -4) (("1" (replace -1 -4 rl) (("1" (name-replace "k2" "F(w1`seq(0))" :hide? nil) (("1" (lemma "eq_circuit_position") (("1" (lemma "eq_circuit_symmetric") (("1" (inst -1 "dg(G)" "x!1" "w1 o rest(w2)") (("1" (inst -2 "dg(G)" "w1 o rest(w2)" "x!1") (("1" (assert) (("1" (skeep -2) (("1" (hide -1) (("1" (typepred "i") (("1" (case "i = length(w1 o rest(w2)) - 1") (("1" (expand "^" -3 1) (("1" (assert) (("1" (rewrite "empty_o_seq") (("1" (replaces -1) (("1" (case-replace "(w1 o rest(w2)) ^ (0, length(w1 o rest(w2)) - 1)
                               = w1 o rest(w2)") (("1" (hide -1) (("1" (replace -2 -13) (("1" (expand "o" -13) (("1" (replace -3) (("1" (replaces -13) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" "x!1") (("1" (expand "o" -2 1) (("1" (replace -3 -2 rl) (("1" (expand "rest" -2) (("1" (expand "^" -2) (("1" (expand "min") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, length(w1) - 1) = w1") (("1" (case-replace "x!1 ^ (length(w1) - 1, length(x!1) - 1) = w2") (("1" (hide -1 -2) (("1" (replaces -1) (("1" (hide-all-but (-6 -7 1)) (("1" (lemma "positive_mult_pos") (("1" (inst -1 "wgt_walk(G, w1)" "wgt_walk(G, w2)" "k1") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -6 -11 -12 -13 -14 1)) (("2" (replaces -1) (("2" (replaces -2) (("2" (replace -3 -1 rl) (("2" (hide -3) (("2" (expand "o" 1 2) (("2" (expand "rest" 1 2) (("2" (expand "^" 1 2) (("2" (expand "min") (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -11 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "x!1") (("2" (expand* "circuit?" "pre_circuit?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i > length(w1) - 1") (("1" (case-replace "(w1 o rest(w2)) ^ (i, length(w1 o rest(w2)) - 2)
                                  = rest(w2) ^ (i - length(w1), length(rest(w2)) - 2)") (("1" (hide -1) (("1" (case-replace "(w1 o rest(w2)) ^ (0, i)
                                  = w1 o (rest(w2) ^ (0, i - length(w1)))") (("1" (hide -1) (("1" (name-replace "ww1" "rest(w2) ^ (i - length(w1), length(rest(w2)) - 2)" :hide? nil) (("1" (name-replace "ww2" "(rest(w2) ^ (0, i - length(w1)))" :hide? nil) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(ww1)" "x!1") (("1" (prop) (("1" (case-replace "x!1 ^ (length(ww1), length(x!1) - 1) = w1 o ww2") (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" "w1 o ww2") (("1" (prop) (("1" (case-replace "(w1 o ww2) ^ (0, length(w1) - 1) = w1") (("1" (hide -1 -3) (("1" (replaces -1) (("1" (replaces -1) (("1" (lemma "ll_defined_walks") (("1" (inst-cp -1 "G" "F" "x!1 ^ (0, length(ww1))") (("1" (prop) (("1" (inst -2 "G" "F" "(w1 o ww2) ^
                                                         (length(w1) - 1, length(w1 o ww2) - 1)") (("1" (prop) (("1" (expand* "first" "last") (("1" (assert) (("1" (expand "^" -1 2) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (expand "o") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (expand "o") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "o" -1 3) (("3" (case-replace "(((w1 o ww2) ^ (length(w1) - 1, length(w1 o ww2) - 1))`seq
                                                         (((w1 o ww2) ^
                                                            (length(w1) - 1, length(w1 o ww2) - 1))`length
                                                           - 1)) = last(x!1)") (("1" (hide -1) (("1" (expand "last") (("1" (assert) (("1" (replace -19 -1 rl) (("1" (replace -14 -1 rl) (("1" (replace -8 -1) (("1" (replace -18 -1) (("1" (expand "^" -2 2) (("1" (case-replace "(x!1 ^ (0, length(ww1)))`seq
                                                           ((x!1 ^ (0, length(ww1)))`length - 1) = w1`seq(0)") (("1" (hide -1) (("1" (replace -8 -2) (("1" (replace -18 -2) (("1" (hide-all-but (-1 -2 -11 4)) (("1" (lemma "positive_pos_mul") (("1" (inst -1 "wgt_walk(G, x!1 ^ (0, length(ww1)))" "measures[N].*(wgt_walk(G, w1),
                                                             wgt_walk(G, (w1 o ww2) ^ (length(w1) - 1, length(w1 o ww2) - 1)))" "k1" "k2" "k1") (("1" (expand* "defined_pos?" "positive_pos?") (("1" (hide 2) (("1" (ground) (("1" (hide -3) (("1" (lemma "positive_pos_mul") (("1" (inst -1 "wgt_walk(G, w1)" "wgt_walk(G, (w1 o ww2) ^ (length(w1) - 1, length(w1 o ww2) - 1))" "k2" "k2" "k1") (("1" (expand* "defined_pos?" "positive_pos?") nil nil) ("2" (hide -) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide -) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2 1) (("2" (lemma "positive_pos_mul") (("2" (inst -1 "wgt_walk(G, w1)" "wgt_walk(G, (w1 o ww2) ^ (length(w1) - 1, length(w1 o ww2) - 1))" "k2" "k2" "k1") (("1" (expand* "defined_pos?" "positive_pos?") nil nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -5 -6 -7 -10 -15 -17 1 2 3 4)) (("2" (replaces -5) (("2" (replace -1 1 rl) (("2" (replace -2 1 rl) (("2" (hide -1 -2) (("2" (expand* "o" "rest" "^" "min" "empty_seq") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-7 -15 1)) (("3" (replaces -1) (("3" (expand "^") (("3" (expand "o") (("3" (expand "min") (("3" (assert) (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -5 -6 -7 -10 -15 -17 1 2 3 4)) (("2" (replace -4) (("2" (replace -1 1 rl) (("2" (hide -1 -4) (("2" (expand "last") (("2" (assert) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 -5 -6 -10 -15 -17 1 2 3 4)) (("3" (replace -1 1 rl) (("3" (hide -1) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-15 1)) (("4" (expand "o") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "walk?_caret" 1) (("1" (hide-all-but 1) (("1" (expand "o") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-2 -4 -5 -8 -13 -14 -15 -16 1 3)) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (expand "rest") (("2" (expand "o" (-2 2)) (("2" (expand "^" (-2 2)) (("2" (expand "min") (("2" (name "a" "number_fields.+ (i - length(w1), 1)") (("2" (assert) (("2" (case-replace "((w2 ^ (1, w2`length - 1)) ^ (0, i - length(w1)))
                                          = (w2 ^ (0, a)) ^ (1, length(w2 ^ (0, a)) - 1)") (("1" (hide -1) (("1" (rewrite "walk_o") (("1" (hide 2) (("1" (rewrite "walk?_caret") nil nil)) nil) ("2" (hide 2) (("2" (expand "^" 1) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand "^" 1) (("3" (expand "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality 1) (("1" (expand* "^" "min") nil nil) ("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "^" "min") nil nil)) nil) ("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-14 1)) (("3" (expand "o") (("3" (assert) nil nil)) nil)) nil) ("4" (hide-all-but (-14 1)) (("4" (expand "o") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-14 1)) (("2" (expand "o") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -21) (("2" (hide-all-but (-1 -7 1)) (("2" (rewrite "walk?_caret") (("2" (hide -1 2) (("2" (replaces -1) (("2" (expand "o") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-16 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") (("1" (lift-if) (("1" (assert) (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (expand ">=") (("2" (assert) (("2" (expand "<=") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "o") (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but (-3 -5 -6 -9 -14 -15 -16 -17 1 2)) (("3" (replace -1 1 rl) (("3" (hide -1) (("3" (name "a" "number_fields.+ (i - length(w1), 1)") (("3" (assert) (("3" (case-replace " (rest(w2) ^ (0, i - length(w1))) = (w2 ^ (0, a)) ^ (1, length(w2 ^ (0, a)) - 1)") (("1" (hide -1) (("1" (rewrite "walk_o") (("1" (hide 2) (("1" (replace -1 1 rl) (("1" (rewrite "walk?_caret") (("1" (hide 2) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (replace -1 1 rl) (("3" (hide -1) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -4 -5 -6 -8 -9 -13 -14 -15 -16 1 2)) (("2" (replaces -5) (("2" (replace -1 1 rl) (("2" (replace -2 1 rl) (("2" (hide -1 -2) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil) ("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil) ("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil) ("4" (expand* "o" "rest" "^" "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -13 -18 1)) (("2" (replaces -1) (("2" (expand "o") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (reveal -17) (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -12 1)) (("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1 2)) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -11 -13 1 2)) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -13 1 2)) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2 1 2)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (assert) nil nil)) nil)) nil) ("2" (case-replace "(w1 o rest(w2)) ^ (i, length(w1 o rest(w2)) - 2) o
                                 (w1 o rest(w2)) ^ (0, i)
                               = (w1 ^ (i, length(w1) - 2)) o w2 o (w1 ^ (1,i))") (("1" (hide -1) (("1" (lemma "wgt_walk_decomposed") (("1" (inst-cp -1 "G" "length(w1) - i - 1" "x!1") (("1" (case-replace "x!1 ^ (length(w1) - i - 1, length(x!1) - 1) = w2 o (w1 ^ (1, i))") (("1" (hide -1) (("1" (case-replace "x!1 ^ (0, length(w1) - i - 1) = w1 ^ (i, length(w1) - 1)") (("1" (hide -1) (("1" (inst -1 "G" "length(w2) - 1" "w2 o (w1 ^ (1, i))") (("1" (case-replace "(w2 o (w1 ^ (1, i))) ^ (0, length(w2) - 1) = w2") (("1" (case-replace "(w2 o (w1 ^ (1, i))) ^
                                               (length(w2) - 1, length(w2 o (w1 ^ (1, i))) - 1) = w1 ^ (0, i)") (("1" (hide -1 -2) (("1" (split -2) (("1" (split -2) (("1" (replaces -1) (("1" (lemma "ll_defined_walks") (("1" (inst -1 "G" "F" " w1 ^ (i, length(w1) - 1)") (("1" (assert) (("1" (split) (("1" (expand* "first" "last") (("1" (assert) (("1" (expand "^" -1 (2 4)) (("1" (expand "min") (("1" (expand "^" -1 2) (("1" (replace -11 -1 rl) (("1" (replace -5 -1) (("1" (case-replace "w1`seq(i) = x!1`seq(0)") (("1" (hide -1) (("1" (replace -15 -1) (("1" (lemma "ll_defined_walks") (("1" (inst -1 "G" "F" "w1 ^ (0, i)") (("1" (assert) (("1" (split) (("1" (expand* "last" "first") (("1" (assert) (("1" (expand "^" -1 (2 4)) (("1" (expand "min") (("1" (replace -6 -1) (("1" (expand "^" -1 2) (("1" (case-replace "w1`seq(i) = x!1`seq(0)") (("1" (hide -1) (("1" (replace -16 -1) (("1" (replaces -3) (("1" (hide-all-but (-1 -2 -9 3)) (("1" (lemma "positive_pos_mul") (("1" (inst -1 "wgt_walk(G, w2)" "wgt_walk(G, w1 ^ (0, i))" "k2" "k2" "k1") (("1" (expand* "defined_pos?" "positive_pos?") (("1" (typepred "wgt_walk(G, w1 ^ (0, i))(k2)(k1)") (("1" (assert) (("1" (hide -1 -3 -5) (("1" (lemma "positive_pos_mul") (("1" (inst -1 "wgt_walk(G, w1 ^ (i, length(w1) - 1))" "measures[N].*(wgt_walk(G, w2), wgt_walk(G, w1 ^ (0, i)))" "k1" "k2" "k1") (("1" (expand* "defined_pos?" "positive_pos?") nil nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -5 -8 -13 -15 -18 1 2 3)) (("2" (replaces -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -7 -12 -14 1 2 3)) (("2" (replaces -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -6 -11 -13 1 2 3)) (("2" (grind) nil nil)) nil) ("3" (hide -1 -3 -4 -7 -8 -9 -14 -15 -16 -17 4) (("3" (lemma "walk_o") (("3" (inst -1 "dg(G)" "w2" "w1 ^ (0, i)") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (expand "^" -1 1) (("1" (case-replace "w1 ^ (0, i) ^ (1, length(w1 ^ (0, i)) - 1) = (w1 ^ (1, i))") (("1" (hide -1 2) (("1" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (hide -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -6 -11 -13 1 2 3)) (("2" (replaces -2) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (ground) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (reveal -37) (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -7 -8 -12 -13 -14 -15 1 2 3)) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (grind) nil nil)) nil) ("2" (expand* "o" "rest" "^" "min" "empty_seq") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand* "o" "rest" "^" "min" "empty_seq") (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 -8 -13 -15 1 2 3)) (("3" (expand* "o" "rest" "^" "min" "empty_seq") (("3" (assert) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -7 -12 -14 1 2 3)) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min" "empty_seq") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-13 1)) (("2" (expand "o") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -6 -7 -11 -12 -13 -14 1 2 3)) (("2" (replaces -2) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 -12 -14 1 2 3)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -6 -7 -11 -12 -13 -14 1 2 3)) (("2" (replaces -2) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 -7 -12 -14 1 2 3)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -5 -10 -12 1 2 3)) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -4 -5 -9 -10 -11 -12 1 2 3)) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (lift-if) (("1" (ground) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "eq_circuit_length") (("2" (inst -1 "dg(G)" "x!1" "w1 o rest(w2)") (("2" (assert) (("2" (hide-all-but (-1 -3 -4 1)) (("2" (expand* "cycle?" "circuit?") (("2" (flatten) (("2" (hide -2 -4 -5) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (hide -1 2) (("4" (typepred "c!1") (("4" (expand* "circuit?" "pre_circuit?") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (hide -1 2) (("5" (typepred "c!1") (("5" (expand* "circuit?" "pre_circuit?" "walk?" "verts_in?" "vert?") (("5" (flatten) (("5" (hide -3 -4) (("5" (expand "first") (("5" (assert) (("5" (inst -2 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (typepred "c!1") (("6" (hide -1 -3 2) (("6" (expand* "circuit?" "pre_circuit?" "walk?" "verts_in?" "vert?" "last") (("6" (flatten) (("6" (hide -2 -3) (("6" (assert) (("6" (inst -1 "c!1`length - 1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (ll_pstv_pos_circuits-1 nil 3592845815 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (measure-induct+ "length(c)" ("c")) (("1" (typepred "x!1") (("1" (expand* "circuit?" "pre_circuit?" "first" "last") (("1" (assert) (("1" (flatten) (("1" (replace -3 1 rl) (("1" (name-replace "k1" "F(x!1`seq(0))" :hide? nil) (("1" (case "cycle?(dg(G),x!1)") (("1" (hide -3 -4 -6 -7) (("1" (expand "limiting_labeling?") (("1" (flatten) (("1" (hide -4) (("1" (inst -4 "x!1") (("1" (expand* "first" "last") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3) (("2" (lemma "cycle_o_circuit") (("2" (inst -1 "dg(G)" "x!1") (("2" (assert) (("2" (skeep) (("2" (inst -7 "w2") (("2" (split) (("1" (copy -8) (("1" (expand "limiting_labeling?" -1) (("1" (flatten) (("1" (hide -1) (("1" (inst -1 "w1") (("1" (assert) (("1" (expand* "cycle?" "circuit?" "pre_circuit?") (("1" (assert) (("1" (flatten) (("1" (hide -7 1) (("1" (expand* "last" "first") (("1" (assert) (("1" (replace -5 -1 rl) (("1" (replace -8 -2 rl) (("1" (copy -3) (("1" (expand "eq_circuit?" -1) (("1" (flatten) (("1" (hide -2) (("1" (expand* "circuit?" "pre_circuit?") (("1" (assert) (("1" (flatten) (("1" (hide -1) (("1" (expand "o" -1) (("1" (expand "rest" -1) (("1" (expand "^" -1) (("1" (expand "min") (("1" (hide -6 -9) (("1" (replace -8 -4) (("1" (replace -1 -4 rl) (("1" (name-replace "k2" "F(w1`seq(0))" :hide? nil) (("1" (lemma "eq_circuit_position") (("1" (lemma "eq_circuit_symmetric") (("1" (inst -1 "dg(G)" "x!1" "w1 o rest(w2)") (("1" (inst -2 "dg(G)" "w1 o rest(w2)" "x!1") (("1" (assert) (("1" (skeep -2) (("1" (hide -1) (("1" (typepred "i") (("1" (case "i = length(w1 o rest(w2)) - 1") (("1" (expand "^" -3 1) (("1" (assert) (("1" (rewrite "empty_o_seq") (("1" (replaces -1) (("1" (case-replace "(w1 o rest(w2)) ^ (0, length(w1 o rest(w2)) - 1) 
                     = w1 o rest(w2)") (("1" (hide -1) (("1" (replace -2 -13) (("1" (expand "o" -13) (("1" (replace -3) (("1" (replaces -13) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" "x!1") (("1" (expand "o" -2 1) (("1" (replace -3 -2 rl) (("1" (expand "rest" -2) (("1" (expand "^" -2) (("1" (expand "min") (("1" (assert) (("1" (split) (("1" (case-replace "x!1 ^ (0, length(w1) - 1) = w1") (("1" (case-replace "x!1 ^ (length(w1) - 1, length(x!1) - 1) = w2") (("1" (hide -1 -2) (("1" (replaces -1) (("1" (hide-all-but (-6 -7 1)) (("1" (lemma "positive_mult_pos") (("1" (inst -1 "wgt_walk(G, w1)" "wgt_walk(G, w2)" "k1") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -6 -11 -12 -13 -14 1)) (("2" (replaces -1) (("2" (replaces -2) (("2" (replace -3 -1 rl) (("2" (hide -3) (("2" (expand "o" 1 2) (("2" (expand "rest" 1 2) (("2" (expand "^" 1 2) (("2" (expand "min") (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -11 1)) (("2" (replaces -1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "x!1") (("2" (expand* "circuit?" "pre_circuit?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") nil nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i > length(w1) - 1") (("1" (case-replace "(w1 o rest(w2)) ^ (i, length(w1 o rest(w2)) - 2)
                      = rest(w2) ^ (i - length(w1), length(rest(w2)) - 2)") (("1" (hide -1) (("1" (case-replace "(w1 o rest(w2)) ^ (0, i) 
                    = w1 o (rest(w2) ^ (0, i - length(w1)))") (("1" (hide -1) (("1" (name-replace "ww1" "rest(w2) ^ (i - length(w1), length(rest(w2)) - 2)" :hide? nil) (("1" (name-replace "ww2" "(rest(w2) ^ (0, i - length(w1)))" :hide? nil) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(ww1)" "x!1") (("1" (prop) (("1" (case-replace "x!1 ^ (length(ww1), length(x!1) - 1) = w1 o ww2") (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "length(w1) - 1" "w1 o ww2") (("1" (prop) (("1" (case-replace "(w1 o ww2) ^ (0, length(w1) - 1) = w1") (("1" (hide -1 -3) (("1" (replaces -1) (("1" (replaces -1) (("1" (lemma "ll_defined_walks") (("1" (inst-cp -1 "G" "F" "x!1 ^ (0, length(ww1))") (("1" (prop) (("1" (inst -2 "G" "F" "(w1 o ww2) ^
                           (length(w1) - 1, length(w1 o ww2) - 1)") (("1" (prop) (("1" (expand* "first" "last") (("1" (assert) (("1" (expand "^" -1 2) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (expand "o") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but -1) (("2" (expand "o") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "o" -1 3) (("3" (case-replace "(((w1 o ww2) ^ (length(w1) - 1, length(w1 o ww2) - 1))`seq
                     (((w1 o ww2) ^
                        (length(w1) - 1, length(w1 o ww2) - 1))`length
                       - 1)) = last(x!1)") (("1" (hide -1) (("1" (expand "last") (("1" (assert) (("1" (replace -19 -1 rl) (("1" (replace -14 -1 rl) (("1" (replace -8 -1) (("1" (replace -18 -1) (("1" (expand "^" -2 2) (("1" (case-replace "(x!1 ^ (0, length(ww1)))`seq
                     ((x!1 ^ (0, length(ww1)))`length - 1) = w1`seq(0)") (("1" (hide -1) (("1" (replace -8 -2) (("1" (replace -18 -2) (("1" (hide-all-but (-1 -2 -11 4)) (("1" (lemma "positive_pos_mul") (("1" (inst -1 "wgt_walk(G, x!1 ^ (0, length(ww1)))" "measures[N].*(wgt_walk(G, w1),
                     wgt_walk(G, (w1 o ww2) ^ (length(w1) - 1, length(w1 o ww2) - 1)))" "k1" "k2" "k1") (("1" (expand* "defined_pos?" "positive_pos?") (("1" (hide 2) (("1" (ground) (("1" (hide -3) (("1" (lemma "positive_pos_mul") (("1" (inst -1 "wgt_walk(G, w1)" "wgt_walk(G, (w1 o ww2) ^ (length(w1) - 1, length(w1 o ww2) - 1))" "k2" "k2" "k1") (("1" (expand* "defined_pos?" "positive_pos?") nil nil) ("2" (hide -) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide -) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2 1) (("2" (lemma "positive_pos_mul") (("2" (inst -1 "wgt_walk(G, w1)" "wgt_walk(G, (w1 o ww2) ^ (length(w1) - 1, length(w1 o ww2) - 1))" "k2" "k2" "k1") (("1" (expand* "defined_pos?" "positive_pos?") nil nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -5 -6 -7 -10 -15 -17 1 2 3 4)) (("2" (replaces -5) (("2" (replace -1 1 rl) (("2" (replace -2 1 rl) (("2" (hide -1 -2) (("2" (expand* "o" "rest" "^" "min" "empty_seq") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-7 -15 1)) (("3" (replaces -1) (("3" (expand "^") (("3" (expand "o") (("3" (expand "min") (("3" (assert) (("3" (lift-if) (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -5 -6 -7 -10 -15 -17 1 2 3 4)) (("2" (replace -4) (("2" (replace -1 1 rl) (("2" (hide -1 -4) (("2" (expand "last") (("2" (assert) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-3 -5 -6 -10 -15 -17 1 2 3 4)) (("3" (replace -1 1 rl) (("3" (hide -1) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide-all-but (-15 1)) (("4" (expand "o") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "walk?_caret" 1) (("1" (hide-all-but 1) (("1" (expand "o") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-2 -4 -5 -8 -13 -14 -15 -16 1 3)) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (expand "rest") (("2" (expand "o" (-2 2)) (("2" (expand "^" (-2 2)) (("2" (expand "min") (("2" (name "a" "number_fields.+ (i - length(w1), 1)") (("2" (assert) (("2" (case-replace "((w2 ^ (1, w2`length - 1)) ^ (0, i - length(w1)))
      = (w2 ^ (0, a)) ^ (1, length(w2 ^ (0, a)) - 1)") (("1" (hide -1) (("1" (rewrite "walk_o") (("1" (hide 2) (("1" (rewrite "walk?_caret") nil nil)) nil) ("2" (hide 2) (("2" (expand "^" 1) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (expand "^" 1) (("3" (expand "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality 1) (("1" (expand* "^" "min") nil nil) ("2" (replace -1 1 rl) (("2" (hide -1) (("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "^" "min") nil nil)) nil) ("2" (expand* "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-14 1)) (("3" (expand "o") (("3" (assert) nil nil)) nil)) nil) ("4" (hide-all-but (-14 1)) (("4" (expand "o") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-14 1)) (("2" (expand "o") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal -21) (("2" (hide-all-but (-1 -7 1)) (("2" (rewrite "walk?_caret") (("2" (hide -1 2) (("2" (replaces -1) (("2" (expand "o") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-16 1)) (("2" (decompose-equality) (("1" (expand* "o" "^" "min") (("1" (lift-if) (("1" (assert) (("1" (expand ">=") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "^" "min") (("2" (expand ">=") (("2" (assert) (("2" (expand "<=") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (expand "o") (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but (-3 -5 -6 -9 -14 -15 -16 -17 1 2)) (("3" (replace -1 1 rl) (("3" (hide -1) (("3" (name "a" "number_fields.+ (i - length(w1), 1)") (("3" (assert) (("3" (case-replace " (rest(w2) ^ (0, i - length(w1))) = (w2 ^ (0, a)) ^ (1, length(w2 ^ (0, a)) - 1)") (("1" (hide -1) (("1" (rewrite "walk_o") (("1" (hide 2) (("1" (replace -1 1 rl) (("1" (rewrite "walk?_caret") (("1" (hide 2) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (expand "^") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (replace -1 1 rl) (("3" (hide -1) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -4 -5 -6 -8 -9 -13 -14 -15 -16 1 2)) (("2" (replaces -5) (("2" (replace -1 1 rl) (("2" (replace -2 1 rl) (("2" (hide -1 -2) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil) ("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil) ("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil) ("4" (expand* "o" "rest" "^" "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 -13 -18 1)) (("2" (replaces -1) (("2" (expand "o") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (reveal -17) (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -12 1)) (("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1 2)) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -11 -13 1 2)) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min") nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 1)) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -13 1 2)) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (expand* "o" "rest" "^" "min") (("1" (assert) nil nil)) nil)) nil) ("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil) ("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 -2 1 2)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil) ("4" (hide-all-but (-1 1)) (("4" (assert) nil nil)) nil)) nil) ("2" (case-replace "(w1 o rest(w2)) ^ (i, length(w1 o rest(w2)) - 2) o
                     (w1 o rest(w2)) ^ (0, i)
                   = (w1 ^ (i, length(w1) - 2)) o w2 o (w1 ^ (1,i))") (("1" (hide -1) (("1" (lemma "wgt_walk_decomposed") (("1" (inst-cp -1 "G" "length(w1) - i" "x!1") (("1" (case-replace "x!1 ^ (length(w1) - i, length(x!1) - 1) = w2 o (w1 ^ (1, i))") (("1" (hide -1) (("1" (case-replace "x!1 ^ (0, length(w1) - i) = w1 ^ (i, length(w1) - 1)") (("1" (hide -1) (("1" (inst -1 "G" "length(w2) - 1" "w2 o (w1 ^ (1, i))") (("1" (case-replace "(w2 o (w1 ^ (1, i))) ^ (0, length(w2) - 1) = w2") (("1" (case-replace "(w2 o (w1 ^ (1, i))) ^
                       (length(w2) - 1, length(w2 o (w1 ^ (1, i))) - 1) = w1 ^ (0, i)") (("1" (hide -1 -2) (("1" (split -2) (("1" (split -2) (("1" (replaces -1) (("1" (lemma "ll_defined_walks") (("1" (inst -1 "G" "F" " w1 ^ (i, length(w1) - 1)") (("1" (assert) (("1" (split) (("1" (expand* "first" "last") (("1" (assert) (("1" (expand "^" -1 (2 4)) (("1" (expand "min") (("1" (expand "^" -1 2) (("1" (replace -11 -1 rl) (("1" (replace -5 -1) (("1" (case-replace "w1`seq(i) = x!1`seq(0)") (("1" (hide -1) (("1" (replace -15 -1) (("1" (lemma "ll_defined_walks") (("1" (inst -1 "G" "F" "w1 ^ (0, i)") (("1" (assert) (("1" (split) (("1" (expand* "last" "first") (("1" (assert) (("1" (expand "^" -1 (2 4)) (("1" (expand "min") (("1" (replace -6 -1) (("1" (expand "^" -1 2) (("1" (case-replace "w1`seq(i) = x!1`seq(0)") (("1" (hide -1) (("1" (replace -16 -1) (("1" (replaces -3) (("1" (hide-all-but (-1 -2 -9 3)) (("1" (lemma "positive_pos_mul") (("1" (inst -1 "wgt_walk(G, w2)" "wgt_walk(G, w1 ^ (0, i))" "k2" "k2" "k1") (("1" (expand* "defined_pos?" "positive_pos?") (("1" (typepred "wgt_walk(G, w1 ^ (0, i))(k2)(k1)") (("1" (assert) (("1" (hide -1 -3 -5) (("1" (lemma "positive_pos_mul") (("1" (inst -1 "wgt_walk(G, w1 ^ (i, length(w1) - 1))" "measures[N].*(wgt_walk(G, w2), wgt_walk(G, w1 ^ (0, i)))" "k1" "k2" "k1") (("1" (expand* "defined_pos?" "positive_pos?") nil nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -5 -8 -13 -15 -18 1 2 3)) (("2" (replaces -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -7 -12 -14 1 2 3)) (("2" (replaces -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "walk?_caret") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -6 -11 -13 1 2 3)) (("2" (grind) nil nil)) nil) ("3" (hide -1 -3 -4 -7 -8 -9 -14 -15 -16 -17 4) (("3" (lemma "walk_o") (("3" (inst -1 "dg(G)" "w2" "w1 ^ (0, i)") (("1" (assert) (("1" (rewrite "walk?_caret") (("1" (expand "^" -1 1) (("1" (case-replace "w1 ^ (0, i) ^ (1, length(w1 ^ (0, i)) - 1) = (w1 ^ (1, i))") (("1" (hide -1 2) (("1" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil) ("2" (hide -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3 -6 -11 -13 1 2 3)) (("2" (replaces -2) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) (("2" (lift-if) (("2" (ground) (("2" (lift-if) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (reveal -37) (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-4 -7 -8 -12 -13 -14 -15 1 2 3)) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (decompose-equality) (("1" (typepred "x!2") (("1" (grind) nil nil)) nil) ("2" (expand* "o" "rest" "^" "min" "empty_seq") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand* "o" "rest" "^" "min" "empty_seq") (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (-4 -8 -13 -15 1 2 3)) (("3" (expand* "o" "rest" "^" "min" "empty_seq") (("3" (assert) (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -7 -12 -14 1 2 3)) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (expand* "o" "rest" "^" "min" "empty_seq") (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-13 1)) (("2" (expand "o") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -6 -7 -11 -12 -13 -14 1 2 3)) (("2" (postpone) nil nil)) nil) ("3" (hide-all-but (-3 -12 -14 1 2 3)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 -6 -7 -11 -12 -13 -14 1 2 3)) (("2" (postpone) nil nil)) nil) ("3" (hide-all-but (-3 -7 -12 -14 1 2 3)) (("3" (expand* "o" "rest" "^" "min") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -5 -10 -12 1 2 3)) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -4 -5 -9 -10 -11 -12 1 2 3)) (("2" (decompose-equality) (("1" (expand* "o" "rest" "^" "min" "empty_seq") (("1" (lift-if) (("1" (ground) (("1" (lift-if) (("1" (ground) nil nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (typepred "x!2") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "eq_circuit_length") (("2" (inst -1 "dg(G)" "x!1" "w1 o rest(w2)") (("2" (assert) (("2" (hide-all-but (-1 -3 -4 1)) (("2" (expand* "cycle?" "circuit?") (("2" (flatten) (("2" (hide -2 -4 -5) (("2" (expand* "o" "rest" "^" "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (rewrite "id_is_identity") nil nil)) nil) ("3" (hide-all-but 1) (("3" (rewrite "measure_matrix_assoc") nil nil)) nil) ("4" (hide -1 2) (("4" (typepred "c!1") (("4" (expand* "circuit?" "pre_circuit?") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (hide -1 2) (("5" (typepred "c!1") (("5" (expand* "circuit?" "pre_circuit?" "walk?" "verts_in?" "vert?") (("5" (flatten) (("5" (hide -3 -4) (("5" (expand "first") (("5" (assert) (("5" (inst -2 "0") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (typepred "c!1") (("6" (hide -1 -3 2) (("6" (expand* "circuit?" "pre_circuit?" "walk?" "verts_in?" "vert?" "last") (("6" (flatten) (("6" (hide -2 -3) (("6" (assert) (("6" (inst -1 "c!1`length - 1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil)) (ll_pstv_circuits 0 (ll_pstv_circuits-2 nil 3612569262 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (expand* "criterion_two?" "mwg_termination?") (("" (skeep -1) (("" (skosimp) (("" (typepred "c!1") (("" (expand* "circuit?" "pre_circuit?") (("" (flatten) (("" (hide -1 -2 -4) (("" (assert) (("" (lemma " ll_pstv_pos_circuits") (("" (inst -1 "G" "F") (("" (assert) (("" (inst -1 "c!1") (("" (expand* "last" "first") (("" (assert) (("" (replace -2 -1 rl) (("" (hide -2) (("" (name-replace "k1" "F(c!1`seq(0))") (("" (expand "positive?") (("" (expand "positive_fun?") (("" (inst?) (("" (expand "form_matfun") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (circuit? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil matrix_wdg nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (vertex_labeling type-eq-decl nil matrix_wdg nil) (< const-decl "bool" reals nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (positive? const-decl "bool" measures nil) (below type-eq-decl nil naturalnumbers nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (positive_fun? const-decl "bool" measures nil) (last const-decl "T" seq_extras structures) (first const-decl "T" seq_extras structures) (ll_pstv_pos_circuits formula-decl nil matrix_wdg nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (criterion_two? const-decl "bool" matrix_wdg nil) (mwg_termination? const-decl "bool" matrix_wdg nil)) nil) (ll_pstv_circuits-1 nil 3592846747 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (expand "criterion_two?") (("" (skeep -1) (("" (skosimp) (("" (typepred "c!1") (("" (expand* "circuit?" "pre_circuit?") (("" (flatten) (("" (hide -1 -2 -4) (("" (assert) (("" (lemma " ll_pstv_pos_circuits") (("" (inst -1 "G" "F") (("" (assert) (("" (inst -1 "c!1") (("" (expand* "last" "first") (("" (assert) (("" (replace -2 -1 rl) (("" (hide -2) (("" (name-replace "k1" "F(c!1`seq(0))") (("" (expand "positive?") (("" (inst 1 "k1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil SHOSTAK)) (circuit_length_reduce_TCC1 0 (circuit_length_reduce_TCC1-1 nil 3631661476 ("" (subtype-tcc) nil nil) ((prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil matrix_wdg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (circuit_length_reduce subtype "matrix_wdg.c" "Walk[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(matrix_wdg.G))"))) (circuit_length_reduce_TCC2 0 (circuit_length_reduce_TCC2-1 nil 3631661476 ("" (skeep) (("" (use "vert_is_finite") (("" (assert) nil nil)) nil)) nil) ((vert_is_finite formula-decl nil digraphs_abs digraphs) (T formal-type-decl nil matrix_wdg nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs)) nil (circuit_length_reduce subtype "c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[matrix_wdg.T].digraph_edges(c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (circuit_length_reduce_TCC3 0 (circuit_length_reduce_TCC3-1 nil 3631661476 ("" (skeep) (("" (use "vert_is_finite") (("" (assert) nil nil)) nil)) nil) ((vert_is_finite formula-decl nil digraphs_abs digraphs) (T formal-type-decl nil matrix_wdg nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (vert_finite formula-decl nil c_digraphs_def digraphs)) nil (circuit_length_reduce subtype "c_digraphs_def[matrix_wdg.T].vert(dg(matrix_wdg.G))" "finite_set[T]"))) (circuit_length_reduce_TCC4 0 (circuit_length_reduce_TCC4-1 nil 3657010233 ("" (subtype-tcc) nil nil) ((T formal-type-decl nil matrix_wdg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (/= const-decl "boolean" notequal nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (circuit_length_reduce subtype "2" "{i: integers.int | booleans.OR(matrix_wdg.N /= 0, reals.>=(i, 0))}"))) (circuit_length_reduce_TCC5 0 (circuit_length_reduce_TCC5-1 nil 3661593386 ("" (subtype-tcc) nil nil) ((prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (T formal-type-decl nil matrix_wdg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (^ const-decl "real" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (circuit_length_reduce subtype "matrix_wdg.cc" "Walk[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(matrix_wdg.G))"))) (circuit_length_reduce 0 (circuit_length_reduce-2 "" 3885252485 ("" (skeep) (("" (case "EXISTS(i:nat, (j:nat | i<j AND j<length(c)-1)): seq(c)(i) = seq(c)(j) AND wgt_walk(G, c^(0,i)) = wgt_walk(G, c^(0,j))") (("1" (skeep) (("1" (name "C" "c^(0,i) o c^(j+1, length(c)-1) ") (("1" (case "length(C)<length(c)") (("1" (case "circuit?(dg(G), C)") (("1" (lemma "wgt_comp_rest") (("1" (inst -1 "G" "c^(0,i)" "c^(j,length(c)-1)") (("1" (ground) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "j" "c") (("1" (ground) (("1" (replace -7 -1 :dir rl) (("1" (replaces -1 -2 :dir rl) (("1" (replaces -8) (("1" (case "rest(c ^ (j, length(c) - 1)) = c ^ (1 + j, length(c) - 1)") (("1" (replaces -1) (("1" (replaces -4) (("1" (inst 1 "C") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "rest") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "^" -1) (("1" (expand "min") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide (1 3)) (("2" (hide -1) (("2" (hide (-1 -2 -3 -4 -5 -6)) (("2" (case "(c^(j,length(c)-1))`length = length(c)-j ") (("1" (replace -1) (("1" (expand "^" 1 2) (("1" (replace -1) (("1" (ground) (("1" (expand "min") (("1" (expand "^" 1 2) (("1" (split 1) (("1" (expand "min") (("1" (propax) nil nil)) nil) ("2" (decompose-equality 1) (("1" (expand "^") (("1" (propax) nil nil)) nil) ("2" (expand "^") (("2" (expand "min") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "min") (("3" (ground) nil nil)) nil) ("4" (expand "^") (("4" (expand "min") (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "^") (("2" (expand "min") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "circuit?") (("2" (expand "pre_circuit?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "last") (("2" (expand "first") (("2" (expand "finseq_appl") (("2" (expand "^") (("2" (expand "min") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "walk?_caret") (("2" (inst -1 "dg(G)" "j" "length(c)-1" "c") (("2" (ground) (("1" (expand "^") (("1" (expand "min") (("1" (ground) nil nil)) nil)) nil) ("2" (expand "^") (("2" (expand "min") (("2" (ground) nil nil)) nil)) nil) ("3" (expand "circuit?") (("3" (expand "pre_circuit?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "circuit?") (("2" (hide 2) (("2" (ground) (("1" (expand "pre_circuit?") (("1" (lemma "walk?_cut") (("1" (inst -1 "dg(G)" "c" "seq(c)(0)" "seq(c)(0)" "i" "j") (("1" (assert) (("1" (expand "finseq_appl") (("1" (replace -3 -1) (("1" (split -1) (("1" (expand "walk_from?") (("1" (expand "from?") (("1" (flatten) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "walk_from?") (("2" (expand "from?") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "C") (("2" (expand "o ") (("2" (expand "^") (("2" (expand "min") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (ground) (("3" (expand "C") (("3" (expand "o ") (("3" (expand "^") (("3" (expand "min") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (ground) (("2" (expand "C") (("2" (expand "o ") (("2" (expand "^") (("2" (expand "min") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "SEQ" " (# length := length(c)-1, seq:= LAMBDA(x:below(length(c)-1)): (seq(c)(x), wgt_walk(G,c^(0,x))) #)") (("1" (hide 2) (("1" (lemma "cartesian_bijection") (("1" (inst -1 "3 ^ (N ^ 2)" "card(vert(dg(G)))") (("1" (lemma "card_measure_matrices") (("1" (lemma "card_bij[T]") (("1" (inst -1 "card(vert(dg(G)))" "vert(dg(G))") (("1" (flatten) (("1" (lemma "card_bij[Measure_Matrix[N]]") (("1" (inst -1 "3 ^ (N ^ 2)" "fullset[Measure_Matrix[N]]") (("1" (flatten) (("1" (hide -2) (("1" (ground) (("1" (skolem -1 "MMf") (("1" (skolem -2 "Vf") (("1" (case "LET CPF = LAMBDA( ver:vert(dg(G)), mm:Measure_Matrix[N]): (Vf(ver), MMf(mm)) IN
                                                                     bijective?(CPF)") (("1" (skolem -5 "CPG") (("1" (skoletin) (("1" (case "bijective?(CPG o CPF)") (("1" (name "F" "CPG o CPF") (("1" (replace -1 -2) (("1" (hide (-3 -4 -5 -6 -7 -8)) (("1" (lemma "card_bij[[vert(dg(G)), Measure_Matrix[N]]]") (("1" (inst -1 "card(vert(dg(G))) * 3 ^ (N ^ 2)" "fullset[[vert(dg(G)), Measure_Matrix[N]]]") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (lemma "seq_pigeon_hole[[vert(dg(G)), Measure_Matrix[N]], fullset[[vert(dg(G)), Measure_Matrix[N]]]]") (("1" (inst -1 "SEQ") (("1" (replace -2) (("1" (ground) (("1" (skeep) (("1" (case "i<j") (("1" (inst 2 "i" "j") (("1" (expand "finseq_appl") (("1" (expand "SEQ") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (inst 3 "j" "i") (("1" (expand "finseq_appl") (("1" (expand "SEQ") (("1" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("1" (skeep) (("1" (expand "SEQ") (("1" (propax) nil nil)) nil)) nil) ("2" (skeep) (("2" (expand "SEQ") (("2" (ground) (("1" (expand "circuit?") (("1" (expand "pre_circuit?") (("1" (flatten) (("1" (expand "walk?") (("1" (flatten) (("1" (expand "verts_in?") (("1" (inst -5 "x1") (("1" (expand "vert?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "circuit?") (("2" (expand "pre_circuit?") (("2" (expand "walk?") (("2" (ground) (("2" (expand "verts_in?") (("2" (inst -5 "x1") (("2" (ground) (("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "F") (("2" (expand "restrict") (("2" (expand "bijective?" 1) (("2" (split 1) (("1" (expand "injective?") (("1" (skeep) (("1" (expand "bijective?" -3) (("1" (flatten) (("1" (expand "injective?") (("1" (inst -3 "x1" "x2") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skeep) (("2" (expand "bijective?") (("2" (flatten) (("2" (expand "surjective?") (("2" (inst -3 "y") (("2" (skeep) (("2" (inst 1 "x") (("2" (ground) (("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_finite") (("2" (inst 1 "card(vert(dg(G))) * 3 ^ (N ^ 2)" "F") (("2" (expand "restrict") (("2" (expand "injective?") (("2" (skeep) (("2" (expand "bijective?") (("2" (flatten) (("2" (expand "injective?") (("2" (inst -3 "x1" "x2") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "composition_bijective[[vert(dg(G)), Measure_Matrix[N]], [below(card(vert(dg(G)))), below(3^(N^2))], below(card(vert(dg(G))) * 3 ^ (N ^ 2))]") (("2" (inst -1 "CPF" "CPG") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skoletin) (("2" (expand "bijective?" 1) (("2" (split 1) (("1" (expand "injective?") (("1" (skeep) (("1" (expand "CPF") (("1" (flatten) (("1" (expand "bijective?") (("1" (expand "injective?") (("1" (flatten) (("1" (inst -4 "x1`2" "x2`2") (("1" (inst -6 "x1`1" "x2`1") (("1" (ground) (("1" (hide-all-but (-1 -2 1)) (("1" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skeep) (("2" (expand "bijective?") (("2" (flatten) (("2" (expand "surjective?") (("2" (typepred "y`1") (("2" (typepred "y`2") (("2" (inst -5 "y`2") (("2" (inst -7 "y`1") (("2" (skeep) (("2" (skeep) (("2" (inst 1 "(x!1, x)") (("1" (ground) (("1" (ground) (("1" (decompose-equality 1) (("1" (expand "CPF") (("1" (propax) nil nil)) nil) ("2" (expand "CPF") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (ground) (("3" (expand "fullset") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (skeep) (("4" (typepred "ver") (("4" (expand "vert?") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil)) nil) ("3" (skeep) (("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil)) nil) ("4" (skeep) (("4" (lemma "walk?_caret") (("4" (inst -1 "dg(G)" "0" "x" "c") (("4" (expand "circuit?") (("4" (expand "pre_circuit?") (("4" (ground) (("4" (expand "^") (("4" (expand "min") (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide 2) (("3" (ground) (("1" (expand "^") (("1" (ground) (("1" (expand "min") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (lemma "walk?_caret") (("2" (inst -1 "dg(G)" "0" "j" "c") (("2" (ground) (("2" (expand "circuit?") (("2" (expand "pre_circuit?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (lemma "id_is_identity") (("4" (propax) nil nil)) nil)) nil) ("5" (skeep) (("5" (lemma "measure_matrix_assoc") (("5" (propax) nil nil)) nil)) nil) ("6" (skeep) (("6" (ground) (("1" (expand "^") (("1" (expand "min") (("1" (ground) nil nil)) nil)) nil) ("2" (lemma "walk?_caret") (("2" (inst -1 "dg(G)" "0" "i" "c") (("2" (ground) (("2" (expand "circuit?") (("2" (expand "pre_circuit?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((^ const-decl "finseq" finite_sequences nil) (wdg type-eq-decl nil matrix_wdg nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil matrix_wdg nil) (below type-eq-decl nil nat_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (associative? const-decl "bool" operator_defs nil) (identity? const-decl "bool" operator_defs nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (O const-decl "finseq" finite_sequences nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (circuit? const-decl "bool" circuits_ digraphs) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (c skolem-const-decl "prewalk
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make]" matrix_wdg nil) (i skolem-const-decl "nat" matrix_wdg nil) (j skolem-const-decl "{j: nat | i < j AND j < length(c) - 1}" matrix_wdg nil) (G skolem-const-decl "wdg" matrix_wdg nil) (last const-decl "T" seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (first const-decl "T" seq_extras structures) (wgt_walk_decomposed formula-decl nil weighted_digraphs_ digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (rest const-decl "finseq" seq_extras structures) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (<= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (posint_exp application-judgement "posint" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (walk?_caret formula-decl nil walks_ digraphs) (wgt_comp_rest formula-decl nil weighted_digraphs_ digraphs) (C skolem-const-decl "finseq[T]" matrix_wdg nil) (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (below type-eq-decl nil naturalnumbers nil) (from? const-decl "bool" walks_ digraphs) (walk_from? const-decl "bool" walks_ digraphs) (walk?_cut formula-decl nil walks_ digraphs) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (vert const-decl "bool" c_digraphs_def digraphs) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (/= const-decl "boolean" notequal nil) (card_bij formula-decl nil finite_sets nil) (fullset const-decl "set" sets nil) (vert? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (composition_bijective formula-decl nil func_composition finite_sets) (restrict const-decl "R" restrict nil) (surjective? const-decl "bool" functions nil) (x skolem-const-decl "[vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
      digraph_make](dg(G)),
 Measure_Matrix[N]]" matrix_wdg nil) (injective? const-decl "bool" functions nil) (seq_pigeon_hole formula-decl nil seq_pigeon structures) (verts_in? const-decl "bool" walks_ digraphs) (i skolem-const-decl "below(length(SEQ))" matrix_wdg nil) (j skolem-const-decl "below(length(SEQ))" matrix_wdg nil) (SEQ skolem-const-decl "[# length: int, seq: [below(length(c) - 1) -> [T, Measure_Matrix[N]]] #]" matrix_wdg nil) (O const-decl "T3" function_props nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (CPF skolem-const-decl "[[vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
       digraph_make](dg(G)),
  Measure_Matrix[N]] ->
   [below[card(vert(dg(G)))], below[3 ^ (N ^ 2)]]]" matrix_wdg nil) (NOT const-decl "[bool -> bool]" booleans nil) (x!1 skolem-const-decl "(vert(dg(G)))" matrix_wdg nil) (card_measure_matrices formula-decl nil measures nil) (cartesian_bijection formula-decl nil fun_below_props sets_aux) (posnat_expt application-judgement "posnat" exponentiation nil) (rat_times_rat_is_rat application-judgement "rat" rationals nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil)) SHOSTAK) (circuit_length_reduce-1 nil 3631661950 ("" (skeep) (("" (case "EXISTS(i:nat, (j:nat | i<j AND j<length(c)-1)): seq(c)(i) = seq(c)(j) AND wgt_walk(G, c^(0,i)) = wgt_walk(G, c^(0,j))") (("1" (skeep) (("1" (name "C" "c^(0,i) o c^(j+1, length(c)-1) ") (("1" (case "length(C)<length(c)") (("1" (case "circuit?(dg(G), C)") (("1" (lemma "wgt_comp_rest") (("1" (inst -1 "G" "c^(0,i)" "c^(j,length(c)-1)") (("1" (ground) (("1" (lemma "wgt_walk_decomposed") (("1" (inst -1 "G" "j" "c") (("1" (ground) (("1" (replace -7 -1 :dir rl) (("1" (replaces -1 -2 :dir rl) (("1" (replaces -8) (("1" (case "rest(c ^ (j, length(c) - 1)) = c ^ (1 + j, length(c) - 1)") (("1" (replaces -1) (("1" (replaces -4) (("1" (inst 1 "C") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "rest") (("2" (lift-if 1) (("2" (split 1) (("1" (flatten) (("1" (expand "^" -1) (("1" (expand "min") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide (1 3)) (("2" (hide -1) (("2" (hide (-1 -2 -3 -4 -5 -6)) (("2" (case "(c^(j,length(c)-1))`length = length(c)-j ") (("1" (replace -1) (("1" (expand "^" 1 2) (("1" (replace -1) (("1" (ground) (("1" (expand "min") (("1" (expand "^" 1 2) (("1" (split 1) (("1" (expand "min") (("1" (propax) nil nil)) nil) ("2" (decompose-equality 1) (("1" (expand "^") (("1" (propax) nil nil)) nil) ("2" (expand "^") (("2" (expand "min") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "min") (("3" (ground) nil nil)) nil) ("4" (expand "^") (("4" (expand "min") (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "^") (("2" (expand "min") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "circuit?") (("2" (expand "pre_circuit?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "last") (("2" (expand "first") (("2" (expand "finseq_appl") (("2" (expand "^") (("2" (expand "min") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "walk?_caret") (("2" (inst -1 "dg(G)" "j" "length(c)-1" "c") (("2" (ground) (("1" (expand "^") (("1" (expand "min") (("1" (ground) nil nil)) nil)) nil) ("2" (expand "^") (("2" (expand "min") (("2" (ground) nil nil)) nil)) nil) ("3" (expand "circuit?") (("3" (expand "pre_circuit?") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "circuit?") (("2" (hide 2) (("2" (ground) (("1" (expand "pre_circuit?") (("1" (lemma "walk?_cut") (("1" (inst -1 "dg(G)" "c" "seq(c)(0)" "seq(c)(0)" "i" "j") (("1" (assert) (("1" (expand "finseq_appl") (("1" (replace -3 -1) (("1" (split -1) (("1" (expand "walk_from?") (("1" (expand "from?") (("1" (flatten) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (expand "walk_from?") (("2" (expand "from?") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "C") (("2" (expand "o ") (("2" (expand "^") (("2" (expand "min") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (ground) (("3" (expand "C") (("3" (expand "o ") (("3" (expand "^") (("3" (expand "min") (("3" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (ground) (("2" (expand "C") (("2" (expand "o ") (("2" (expand "^") (("2" (expand "min") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name "SEQ" " (# length := length(c)-1, seq:= LAMBDA(x:below(length(c)-1)): (seq(c)(x), wgt_walk(G,c^(0,x))) #)") (("1" (hide 2) (("1" (lemma "cartesian_bijection") (("1" (inst -1 "3 ^ (N ^ 2)" "card(vert(dg(G)))") (("1" (lemma "card_measure_matrices") (("1" (lemma "card_bij[T]") (("1" (inst -1 "card(vert(dg(G)))" "vert(dg(G))") (("1" (flatten) (("1" (lemma "card_bij[Measure_Matrix[N]]") (("1" (inst -1 "3 ^ (N ^ 2)" "fullset[Measure_Matrix[N]]") (("1" (flatten) (("1" (hide -2) (("1" (ground) (("1" (skolem -1 "MMf") (("1" (skolem -2 "Vf") (("1" (case "LET CPF = LAMBDA( ver:vert(dg(G)), mm:Measure_Matrix[N]): (Vf(ver), MMf(mm)) IN
                                                                     bijective?(CPF)") (("1" (skolem -5 "CPG") (("1" (skoletin) (("1" (case "bijective?(CPG o CPF)") (("1" (name "F" "CPG o CPF") (("1" (replace -1 -2) (("1" (hide (-3 -4 -5 -6 -7 -8)) (("1" (lemma "card_bij[[vert(dg(G)), Measure_Matrix[N]]]") (("1" (inst -1 "card(vert(dg(G))) * 3 ^ (N ^ 2)" "fullset[[vert(dg(G)), Measure_Matrix[N]]]") (("1" (flatten) (("1" (hide -1) (("1" (split -1) (("1" (lemma "seq_pigeon_hole[[vert(dg(G)), Measure_Matrix[N]], fullset[[vert(dg(G)), Measure_Matrix[N]]]]") (("1" (inst -1 "SEQ") (("1" (replace -2) (("1" (ground) (("1" (skeep) (("1" (case "i<j") (("1" (inst 2 "i" "j") (("1" (expand "finseq_appl") (("1" (expand "SEQ") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (inst 3 "j" "i") (("1" (expand "finseq_appl") (("1" (expand "SEQ") (("1" (ground) nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("1" (skeep) (("1" (expand "SEQ") (("1" (propax) nil nil)) nil)) nil) ("2" (skeep) (("2" (expand "SEQ") (("2" (ground) (("1" (expand "circuit?") (("1" (expand "pre_circuit?") (("1" (flatten) (("1" (expand "walk?") (("1" (flatten) (("1" (expand "verts_in?") (("1" (inst -5 "x1") (("1" (expand "vert?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "circuit?") (("2" (expand "pre_circuit?") (("2" (expand "walk?") (("2" (ground) (("2" (expand "verts_in?") (("2" (inst -5 "x1") (("2" (ground) (("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "F") (("2" (expand "restrict") (("2" (expand "bijective?" 1) (("2" (split 1) (("1" (expand "injective?") (("1" (skeep) (("1" (expand "bijective?" -3) (("1" (flatten) (("1" (expand "injective?") (("1" (inst -3 "x1" "x2") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skeep) (("2" (expand "bijective?") (("2" (flatten) (("2" (expand "surjective?") (("2" (inst -3 "y") (("2" (skeep) (("2" (inst 1 "x") (("2" (ground) (("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_finite") (("2" (inst 1 "card(vert(dg(G))) * 3 ^ (N ^ 2)" "F") (("2" (expand "restrict") (("2" (expand "injective?") (("2" (skeep) (("2" (expand "bijective?") (("2" (flatten) (("2" (expand "injective?") (("2" (inst -3 "x1" "x2") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "composition_bijective[[vert(dg(G)), Measure_Matrix[N]], [below(card(vert(dg(G)))), below(3^(N^2))], below(card(vert(dg(G))) * 3 ^ (N ^ 2))]") (("2" (inst -1 "CPF" "CPG") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skoletin) (("2" (expand "bijective?" 1) (("2" (split 1) (("1" (expand "injective?") (("1" (skeep) (("1" (expand "CPF") (("1" (flatten) (("1" (expand "bijective?") (("1" (expand "injective?") (("1" (flatten) (("1" (inst -4 "x1`2" "x2`2") (("1" (inst -6 "x1`1" "x2`1") (("1" (ground) (("1" (hide-all-but (-1 -2 1)) (("1" (decompose-equality 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "surjective?") (("2" (skeep) (("2" (expand "bijective?") (("2" (flatten) (("2" (expand "surjective?") (("2" (typepred "y`1") (("2" (typepred "y`2") (("2" (inst -5 "y`2") (("2" (inst -7 "y`1") (("2" (skeep) (("2" (skeep) (("2" (inst 1 "(x!1, x)") (("1" (ground) (("1" (ground) (("1" (decompose-equality 1) (("1" (expand "CPF") (("1" (propax) nil nil)) nil) ("2" (expand "CPF") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (ground) (("3" (expand "fullset") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (skeep) (("4" (typepred (ver)) (("4" (expand "vert?") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil)) nil) ("3" (skeep) (("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil)) nil) ("4" (skeep) (("4" (lemma "walk?_caret") (("4" (inst -1 "dg(G)" "0" "x" "c") (("4" (expand "circuit?") (("4" (expand "pre_circuit?") (("4" (ground) (("4" (expand "^") (("4" (expand "min") (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide 2) (("3" (ground) (("1" (expand "^") (("1" (ground) (("1" (expand "min") (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (lemma "walk?_caret") (("2" (inst -1 "dg(G)" "0" "j" "c") (("2" (ground) (("2" (expand "circuit?") (("2" (expand "pre_circuit?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (lemma "id_is_identity") (("4" (propax) nil nil)) nil)) nil) ("5" (skeep) (("5" (lemma "measure_matrix_assoc") (("5" (propax) nil nil)) nil)) nil) ("6" (skeep) (("6" (ground) (("1" (expand "^") (("1" (expand "min") (("1" (ground) nil nil)) nil)) nil) ("2" (lemma "walk?_caret") (("2" (inst -1 "dg(G)" "0" "i" "c") (("2" (ground) (("2" (expand "circuit?") (("2" (expand "pre_circuit?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq type-eq-decl nil finite_sequences nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (prewalk type-eq-decl nil walks_ digraphs) (Sign3 type-eq-decl nil sign3 reals) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (^ const-decl "finseq" finite_sequences nil) (O const-decl "finseq" finite_sequences nil) (circuit? const-decl "bool" circuits_ digraphs) (last const-decl "T" seq_extras structures) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (first const-decl "T" seq_extras structures) (wgt_walk_decomposed formula-decl nil weighted_digraphs_ digraphs) (rest const-decl "finseq" seq_extras structures) (pre_circuit? const-decl "bool" circuits_ digraphs) (walk?_caret formula-decl nil walks_ digraphs) (wgt_comp_rest formula-decl nil weighted_digraphs_ digraphs) (from? const-decl "bool" walks_ digraphs) (walk_from? const-decl "bool" walks_ digraphs) (walk?_cut formula-decl nil walks_ digraphs) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (finite_set type-eq-decl nil finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (vert const-decl "bool" c_digraphs_def digraphs) (card_bij formula-decl nil finite_sets nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (composition_bijective formula-decl nil func_composition finite_sets) (seq_pigeon_hole formula-decl nil seq_pigeon structures) (verts_in? const-decl "bool" walks_ digraphs) (card_measure_matrices formula-decl nil measures nil) (cartesian_bijection formula-decl nil fun_below_props sets_aux)) SHOSTAK)) (circuit_length_bounded 0 (circuit_length_bounded-2 "" 3885252521 ("" (skolem 1 ("G" "m" "_" "_")) (("" (induct "n" 1 "NAT_induction") (("1" (skeep) (("1" (skeep) (("1" (lemma "circuit_length_reduce") (("1" (inst -1 "G" "m" "c") (("1" (ground) (("1" (skeep -1) (("1" (inst -4 "length(cc)") (("1" (ground) (("1" (inst -1 "cc") (("1" (ground) (("1" (flip-ineq 1) (("1" (inst 1 "cc") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (lemma "id_is_identity") (("2" (skeep) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (lemma "measure_matrix_assoc") (("3" (skeep) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (expand "circuit?") (("4" (expand "pre_circuit?") (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (lemma "id_is_identity") (("5" (propax) nil nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (lemma "measure_matrix_assoc") (("6" (propax) nil nil)) nil)) nil)) nil) ("7" (skeep) (("7" (expand "circuit?") (("7" (expand "pre_circuit?") (("7" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (walk? const-decl "bool" walks_ digraphs) (G skolem-const-decl "wdg" matrix_wdg nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (circuit? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil matrix_wdg nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (associative? const-decl "bool" operator_defs nil) (identity? const-decl "bool" operator_defs nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (vert const-decl "bool" c_digraphs_def digraphs) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (m skolem-const-decl "Measure_Matrix[N]" matrix_wdg nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (vert_finite formula-decl nil c_digraphs_def digraphs) (pred type-eq-decl nil defined_types nil) (<= const-decl "bool" reals nil) (NAT_induction formula-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (circuit_length_reduce formula-decl nil matrix_wdg nil) (id_is_identity formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (pre_circuit? const-decl "bool" circuits_ digraphs)) SHOSTAK) (circuit_length_bounded-1 nil 3631662041 ("" (skolem 1 ("G" "m" "_" "_")) (("" (induct "n" 1 nat_induction) (("1" (skeep) (("1" (skeep) (("1" (lemma "circuit_length_reduce") (("1" (inst -1 "G" "m" "c") (("1" (ground) (("1" (skeep -1) (("1" (inst -4 "length(cc)") (("1" (ground) (("1" (inst -1 "cc") (("1" (ground) (("1" (flip-ineq 1) (("1" (inst 1 "cc") (("1" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (lemma "id_is_identity") (("2" (skeep) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (lemma "measure_matrix_assoc") (("3" (skeep) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (expand "circuit?") (("4" (expand "pre_circuit?") (("4" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (lemma "id_is_identity") (("5" (propax) nil nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (lemma "measure_matrix_assoc") (("6" (propax) nil nil)) nil)) nil)) nil) ("7" (skeep) (("7" (expand "circuit?") (("7" (expand "pre_circuit?") (("7" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((vert_finite formula-decl nil c_digraphs_def digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (circuit? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (finseq type-eq-decl nil finite_sequences nil) (id_is_identity formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (pre_circuit? const-decl "bool" circuits_ digraphs)) SHOSTAK)) (bounded_circuits_pstv_TCC1 0 (bounded_circuits_pstv_TCC1-1 nil 3631661476 ("" (skeep) (("" (assert) nil nil)) nil) ((vert_finite formula-decl nil c_digraphs_def digraphs) (T formal-type-decl nil matrix_wdg nil)) nil (bounded_circuits_pstv subtype "c_digraphs_def[matrix_wdg.T].vert(dg(matrix_wdg.G))" "finite_set[T]"))) (bounded_circuits_pstv_TCC2 0 (bounded_circuits_pstv_TCC2-1 nil 3657010233 ("" (subtype-tcc) nil nil) ((T formal-type-decl nil matrix_wdg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (bounded_circuits_pstv subtype "2" "{i: integers.int | booleans.OR(matrix_wdg.N /= 0, reals.>=(i, 0))}"))) (bounded_circuits_pstv 0 (bounded_circuits_pstv-2 nil 3659955175 ("" (expand "mwg_termination?") (("" (skeep) (("" (skeep) (("" (lemma "circuit_length_bounded") (("" (inst -1 "G" "wgt_walk(G,c)" "c" "length(c)") (("1" (ground) (("1" (skeep) (("1" (inst -4 "cc") (("1" (replaces -2) nil nil) ("2" (ground) nil nil)) nil)) nil) ("2" (inst -1 "c") nil nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (circuit_length_bounded formula-decl nil matrix_wdg nil) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (G skolem-const-decl "wdg" matrix_wdg nil) (cc skolem-const-decl "prewalk
    [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make]" matrix_wdg nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_set type-eq-decl nil finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (vert const-decl "bool" c_digraphs_def digraphs) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (circuit? const-decl "bool" circuits_ digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (T formal-type-decl nil matrix_wdg nil) (identity? const-decl "bool" operator_defs nil) (id const-decl "Measure_Matrix" measures nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (int nonempty-type-eq-decl nil integers nil) (Sign3 type-eq-decl nil sign3 reals) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" matrix_wdg nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (associative? const-decl "bool" operator_defs nil) (* const-decl "Measure_Matrix" measures nil) (mwg_termination? const-decl "bool" matrix_wdg nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_exp application-judgement "posint" exponentiation nil)) nil) (bounded_circuits_pstv-1 nil 3631662068 ("" (skeep) (("" (skeep) (("" (lemma "circuit_length_bounded") (("" (inst -1 "G" "wgt_walk(G,c)" "c" "length(c)") (("1" (ground) (("1" (skeep) (("1" (inst -4 "cc") (("1" (replaces -2) nil nil) ("2" (ground) nil nil)) nil)) nil) ("2" (inst -1 "c") nil nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) nil SHOSTAK)) (lower_bounding_sets_TCC1 0 (lower_bounding_sets_TCC1-1 nil 3659954443 ("" (assert) nil nil) ((T formal-type-decl nil matrix_wdg nil) (vert_finite formula-decl nil c_digraphs_def digraphs)) nil (lower_bounding_sets subtype "c_digraphs_def[matrix_wdg.T].vert(dg(matrix_wdg.G))" "finite_set[T]"))) (lower_bounding_sets_TCC2 0 (lower_bounding_sets_TCC2-1 nil 3659954443 ("" (subtype-tcc) nil nil) ((T formal-type-decl nil matrix_wdg nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (/= const-decl "boolean" notequal nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (lower_bounding_sets subtype "2" "{i: integers.int | booleans.OR(matrix_wdg.N /= 0, reals.>=(i, 0))}"))) (lower_bounding_sets_TCC3 0 (lower_bounding_sets_TCC3-1 nil 3659954443 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (vert? const-decl "bool" digraphs_ digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (vert type-eq-decl nil digraphs_ digraphs) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (finite_set type-eq-decl nil finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (circuit? const-decl "bool" circuits_ digraphs) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (positive_fun? const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (T formal-type-decl nil matrix_wdg nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (posint_exp application-judgement "posint" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (lower_bounding_sets subtype "matrix_wdg.c" "Walk[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(matrix_wdg.G))"))) (lower_bounding_sets_TCC4 0 (lower_bounding_sets_TCC4-1 nil 3661593386 ("" (subtype-tcc) nil nil) ((N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (positive_fun? const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (T formal-type-decl nil matrix_wdg nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (lower_bounding_sets subtype "c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[matrix_wdg.T].digraph_edges(c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (lower_bounding_sets 0 (lower_bounding_sets-1 nil 3659954544 ("" (skeep) (("" (skeep) (("" (lemma "bounded_circuits_pstv") (("" (inst?) (("" (assert) (("" (hide 2) (("" (skolem! 1) (("" (name "v1" "c!1(0)") (("" (inst -2 "v1") (("1" (inst -2 "c!1") (("1" (skeep) (("1" (expand "positive?") (("1" (expand "positive_fun?") (("1" (skeep) (("1" (inst 1 "j") (("1" (expand "<=") (("1" (expand "le") (("1" (inst - "j" "j") (("1" (ground) (("1" (replaces -3) (("1" (lemma "sign3_id") (("1" (inst - "form_matfun(wgt_walk(G, c!1))(j)(j)") (("1" (replaces -1 1 :dir rl) (("1" (lemma "sign3_eq_1") (("1" (inst - "form_matfun(wgt_walk(G, c!1))(j)(j)") (("1" (ground) nil nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "id_is_identity") (("2" (propax) nil nil)) nil) ("3" (lemma "measure_matrix_assoc") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "c!1") (("2" (expand "circuit_at?") (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "vert?") (("2" (expand "finseq_appl") (("2" (typepred "c!1") (("2" (expand "circuit?") (("2" (expand "pre_circuit?") (("2" (expand "walk?") (("2" (flatten) (("2" (expand "verts_in?") (("2" (inst -2 "0") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (T formal-type-decl nil matrix_wdg nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" matrix_wdg nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (vert const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (circuit? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pre_circuit? const-decl "bool" circuits_ digraphs) (int_minus_int_is_int application-judgement "int" integers nil) (verts_in? const-decl "bool" walks_ digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (circuit_at? const-decl "bool" circuits_ digraphs) (c!1 skolem-const-decl "{c |
   circuit?(dg(G), c) AND length(c) <= 1 + card(vert(dg(G))) * 3 ^ (N ^ 2)}" matrix_wdg nil) (positive? const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (TRUE const-decl "bool" booleans nil) (associative? const-decl "bool" operator_defs nil) (identity? const-decl "bool" operator_defs nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (eq const-decl "bool" measures nil) (Measure_Mat_Fn type-eq-decl nil measures nil) (sign3_eq_1 formula-decl nil sign3 reals) (measure_matrix_assoc formula-decl nil measures nil) (id_is_identity formula-decl nil measures nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (sign3_id formula-decl nil sign3 reals) (le const-decl "bool" measures nil) (below type-eq-decl nil naturalnumbers nil) (positive_fun? const-decl "bool" measures nil) (NOT const-decl "[bool -> bool]" booleans nil) (vert type-eq-decl nil digraphs_ digraphs) (v1 skolem-const-decl "T" matrix_wdg nil) (G skolem-const-decl "wdg" matrix_wdg nil) (vert? const-decl "bool" digraphs_ digraphs) (bounded_circuits_pstv formula-decl nil matrix_wdg nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil)) (CircBound_TCC1 0 (CircBound_TCC1-1 nil 3659954443 ("" (skeep) (("" (use "vert_is_finite") (("" (assert) nil nil)) nil)) nil) ((vert_is_finite formula-decl nil digraphs_abs digraphs) (T formal-type-decl nil matrix_wdg nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs)) nil (CircBound subtype "2" "{i: integers.int | booleans.OR(matrix_wdg.N /= 0, reals.>=(i, 0))}"))) (BoundingSets_TCC1 0 (BoundingSets_TCC1-1 nil 3659954443 ("" (subtype-tcc) nil nil) ((below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (cycle? const-decl "bool" cycles_ digraphs) (/= const-decl "boolean" notequal nil) (circuit? const-decl "bool" circuits_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (cycle_at? const-decl "bool" cycles_ digraphs) (upto nonempty-type-eq-decl nil naturalnumbers nil) (CircBound const-decl "posnat" matrix_wdg nil) (<= const-decl "bool" reals nil) (circuit_at? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (vert type-eq-decl nil digraphs_ digraphs) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (vert? const-decl "bool" digraphs_ digraphs) (NOT const-decl "[bool -> bool]" booleans nil) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (positive_fun? const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (T formal-type-decl nil matrix_wdg nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (vert const-decl "bool" c_digraphs_def digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (verts_in? const-decl "bool" walks_ digraphs) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edges const-decl "bool" c_digraphs_def digraphs) (edge? const-decl "bool" digraphs_ digraphs) (walk? const-decl "bool" walks_ digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (BoundingSets subtype "matrix_wdg.cc" "Walk[matrix_wdg.T, digraph_type[T], c_digraphs_imp[matrix_wdg.T].digraph_verts, c_digraphs_imp[matrix_wdg.T].digraph_edges, c_digraphs_imp[matrix_wdg.T].digraph_size, c_digraphs_imp[matrix_wdg.T].digraph_make](c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(matrix_wdg.G))"))) (BoundingSets_TCC2 0 (BoundingSets_TCC2-1 nil 3661593386 ("" (subtype-tcc) nil nil) ((N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (get const-decl "Sign3" measures nil) (form_matfun const-decl "{f | eq(m, f)}" measures nil) (positive_fun? const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (T formal-type-decl nil matrix_wdg nil) (vert const-decl "bool" c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (BoundingSets subtype "c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].get_wgt" "[[W: wgd_type[T, Measure_Matrix[N], measures[N].*, measures[N].id], (c_digraphs_imp[matrix_wdg.T].digraph_edges(c_weighted_digraphs_def[matrix_wdg.T, Measure_Matrix[N], measures[matrix_wdg.N].*, measures[matrix_wdg.N].id].wgd_dg(W)))] -> Measure_Matrix[N]]"))) (bounding_steps_iter_TCC1 0 (bounding_steps_iter_TCC1-1 nil 3659954443 ("" (skeep) (("" (typepred "S`1") (("" (grind) nil nil)) nil)) nil) ((BoundingSets type-eq-decl nil matrix_wdg nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (member def-decl "bool" list_props nil) (cycle_at? const-decl "bool" cycles_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (upto nonempty-type-eq-decl nil naturalnumbers nil) (CircBound const-decl "posnat" matrix_wdg nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (T formal-type-decl nil matrix_wdg nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (size const-decl "nat" c_digraphs_def digraphs) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (bounding_steps_iter subtype "(number_fields.-)(matrix_wdg.CircBound(matrix_wdg.G), matrix_wdg.S`1)" "naturalnumber"))) (bounding_steps_iter_TCC2 0 (bounding_steps_iter_TCC2-3 "" 3885934739 ("" (skeep) (("" (typepred "F") (("" (inst?) (("" (inst?) (("" (splash) (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak (bounding_steps_iter termination "matrix_wdg.bounding_steps_iter(matrix_wdg.G, matrix_wdg.F(matrix_wdg.S), matrix_wdg.F)" "nil")) (bounding_steps_iter_TCC2-2 nil 3659957460 ("" (skeep) (("" (typepred (f)) (("" (inst?) (("" (inst?) (("" (splash) (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((BoundingStepsFun type-eq-decl nil matrix_wdg nil) (BoundingSets type-eq-decl nil matrix_wdg nil) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (member def-decl "bool" list_props nil) (cycle_at? const-decl "bool" cycles_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (upto nonempty-type-eq-decl nil naturalnumbers nil) (CircBound const-decl "posnat" matrix_wdg nil) (wdg type-eq-decl nil matrix_wdg nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (N formal-const-decl "posnat" matrix_wdg nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (length def-decl "nat" list_props nil) (Sign3 type-eq-decl nil sign3 reals) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (T formal-type-decl nil matrix_wdg nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil)) nil (bounding_steps_iter termination "matrix_wdg.bounding_steps_iter(matrix_wdg.G, matrix_wdg.F(matrix_wdg.S), matrix_wdg.F)" "nil")) (bounding_steps_iter_TCC2-1 nil 3659954443 ("" (termination-tcc) nil nil) nil nil (bounding_steps_iter termination "matrix_wdg.bounding_steps_iter(matrix_wdg.G, matrix_wdg.F(matrix_wdg.S), matrix_wdg.F)" "nil"))) (bounding_steps_iter_def 0 (bounding_steps_iter_def-2 "" 3885252661 ("" (case " FORALL (G: wdg, n: upto(CircBound(G)),  (S: BoundingSets(G) | S`1 = CircBound(G)-n), F: BoundingStepsFun(G)):
                      bounding_steps_iter(G, S, F) IMPLIES mwg_termination?(G)") (("1" (skeep) (("1" (inst - "G" "CircBound(G)-S`1" "S" "F") (("1" (ground) nil nil) ("2" (typepred "S`1") (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skolem 1 ("G" "_" "_" "F")) (("2" (induct "n" 1 "NAT_induction") (("1" (typepred "n!1") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (case "j=0") (("1" (hide -2) (("1" (skeep) (("1" (lemma "lower_bounding_sets") (("1" (inst - "G") (("1" (expand "bounding_steps_iter") (("1" (ground) (("1" (hide 2) (("1" (typepred "(S)") (("1" (inst + "S`3") (("1" (ground) (("1" (skeep) (("1" (inst?) (("1" (skeep) (("1" (inst -1 "c") (("1" (typepred "c") (("1" (expand "CircBound") (("1" (case "size(dg(G)) = card[T](vert(dg(G)))") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (assert) (("2" (use "size_def") (("2" (expand "digraph_size") (("2" (expand "restrict") (("2" (expand "digraph_verts") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "bounding_steps_iter" -3) (("2" (split -3) (("1" (propax) nil nil) ("2" (simplify -1) (("2" (flatten -1) (("2" (split -2) (("1" (typepred "S") (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (typepred "F") (("2" (inst -1 "S`1" "S") (("2" (split -1) (("1" (expand "bounding_steps_iter") (("1" (ground) (("1" (lemma "lower_bounding_sets") (("1" (inst - "G") (("1" (ground) (("1" (inst 1 "F(S)`3") (("1" (typepred "F(S)") (("1" (ground) (("1" (hide -6) (("1" (skeep) (("1" (inst? -) (("1" (skeep) (("1" (inst? -) (("1" (typepred "c") (("1" (expand "CircBound") (("1" (ground) (("1" (case "size(dg(G)) = card[T](vert(dg(G)))") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (use "size_def") (("2" (expand "digraph_size") (("2" (expand "restrict") (("2" (expand "digraph_verts") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "CircBound(G) - F(S)`1") (("1" (typepred "F(S)`1") (("1" (ground) (("1" (inst - "F(S)") nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (typepred "cc") (("5" (expand "circuit_at?") (("5" (expand "circuit?") (("5" (expand "pre_circuit?") (("5" (expand "cycle_at?") (("5" (expand "cycle?") (("5" (expand "circuit?") (("5" (expand "pre_circuit?") (("5" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((G skolem-const-decl "wdg" matrix_wdg nil) (associative? const-decl "bool" operator_defs nil) (identity? const-decl "bool" operator_defs nil) (pred type-eq-decl nil defined_types nil) (NAT_induction formula-decl nil naturalnumbers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (vert const-decl "bool" c_digraphs_def digraphs) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (v skolem-const-decl "vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" matrix_wdg nil) (c skolem-const-decl "{c |
   circuit_at?(dg(G), c, v) AND
    length(c) <= 1 + card[T](vert(dg(G))) * 3 ^ (N ^ 2)}" matrix_wdg nil) (j skolem-const-decl "nat" matrix_wdg nil) (S skolem-const-decl "{S: BoundingSets(G) | S`1 = CircBound(G) - j}" matrix_wdg nil) (size_def formula-decl nil digraphs_abs digraphs) (restrict const-decl "R" restrict nil) (concretedigraph_implements_abstractdigraph formula-decl nil cycles_ digraphs) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (size const-decl "nat" c_digraphs_def digraphs) (lower_bounding_sets formula-decl nil matrix_wdg nil) (S skolem-const-decl "{S: BoundingSets(G) | S`1 = CircBound(G) - j}" matrix_wdg nil) (F skolem-const-decl "BoundingStepsFun(G)" matrix_wdg nil) (c skolem-const-decl "{c |
   circuit_at?(dg(G), c, v) AND
    length(c) <= 1 + card[T](vert(dg(G))) * 3 ^ (N ^ 2)}" matrix_wdg nil) (v skolem-const-decl "vert[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](dg(G))" matrix_wdg nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (id_is_identity formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (circuit? const-decl "bool" circuits_ digraphs) (cycle? const-decl "bool" cycles_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (S skolem-const-decl "BoundingSets(G)" matrix_wdg nil) (G skolem-const-decl "wdg" matrix_wdg nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (T formal-type-decl nil matrix_wdg nil) (digraph_type type-eq-decl nil c_digraphs_imp digraphs) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (cdigraph const-decl "bool" c_digraphs_def digraphs) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (Sign3 type-eq-decl nil sign3 reals) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (N formal-const-decl "posnat" matrix_wdg nil) (listn type-eq-decl nil listn structures) (Measure_Matrix type-eq-decl nil measures nil) (* const-decl "Measure_Matrix" measures nil) (id const-decl "Measure_Matrix" measures nil) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (wdg type-eq-decl nil matrix_wdg nil) (<= const-decl "bool" reals nil) (CircBound const-decl "posnat" matrix_wdg nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (vert? const-decl "bool" digraphs_ digraphs) (vert type-eq-decl nil digraphs_ digraphs) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (prewalk type-eq-decl nil walks_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (cycle_at? const-decl "bool" cycles_ digraphs) (member def-decl "bool" list_props nil) (positive? const-decl "bool" measures nil) (<= const-decl "bool" measures nil) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (BoundingSets type-eq-decl nil matrix_wdg nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (BoundingStepsFun type-eq-decl nil matrix_wdg nil) (bounding_steps_iter def-decl "bool" matrix_wdg nil) (mwg_termination? const-decl "bool" matrix_wdg nil)) SHOSTAK) (bounding_steps_iter_def-1 nil 3659956934 ("" (case " FORALL (G: wdg, n: upto(CircBound(G)),  (S: BoundingSets(G) | S`1 = CircBound(G)-n), F: BoundingStepsFun(G)):
                      bounding_steps_iter(G, S, F) IMPLIES mwg_termination?(G)") (("1" (skeep) (("1" (inst - "G" "CircBound(G)-S`1" "S" "F") (("1" (ground) nil nil) ("2" (typepred "S`1") (("2" (ground) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skolem 1 ("G" "_" "_" "F")) (("2" (induct "n" 1 nat_induction) (("1" (typepred "n!1") (("1" (propax) nil nil)) nil) ("2" (skeep) (("2" (case "j=0") (("1" (hide -2) (("1" (skeep) (("1" (lemma "lower_bounding_sets") (("1" (inst - "G") (("1" (expand "bounding_steps_iter") (("1" (ground) (("1" (hide 2) (("1" (typepred "(S)") (("1" (inst + "S`3") (("1" (ground) (("1" (skeep) (("1" (inst?) (("1" (skeep) (("1" (inst -1 "c") (("1" (typepred "c") (("1" (expand "CircBound") (("1" (case "size(dg(G)) = card[T](vert(dg(G)))") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (assert) (("2" (use "size_def") (("2" (expand "digraph_size") (("2" (expand "restrict") (("2" (expand "digraph_verts") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "bounding_steps_iter" -3) (("2" (split -3) (("1" (propax) nil nil) ("2" (simplify -1) (("2" (flatten -1) (("2" (split -2) (("1" (typepred (s)) (("1" (ground) nil nil)) nil) ("2" (flatten) (("2" (typepred (f)) (("2" (inst -1 "S`1" "S") (("2" (split -1) (("1" (expand "bounding_steps_iter") (("1" (ground) (("1" (lemma "lower_bounding_sets") (("1" (inst - "G") (("1" (ground) (("1" (inst 1 "F(S)`3") (("1" (typepred "F(S)") (("1" (ground) (("1" (hide -6) (("1" (skeep) (("1" (inst? -) (("1" (skeep) (("1" (inst? -) (("1" (typepred (c)) (("1" (expand "CircBound") (("1" (ground) (("1" (case "size(dg(G)) = card[T](vert(dg(G)))") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil) ("2" (hide-all-but 1) (("2" (use "size_def") (("2" (expand "digraph_size") (("2" (expand "restrict") (("2" (expand "digraph_verts") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -4 "CircBound(G) - F(S)`1") (("1" (typepred "F(S)`1") (("1" (ground) (("1" (inst - "F(S)") nil nil)) nil)) nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (skeep) (("3" (skeep) (("3" (lemma "id_is_identity") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (skeep) (("4" (lemma "measure_matrix_assoc") (("4" (propax) nil nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (skeep) (("5" (skeep) (("5" (typepred (cc)) (("5" (expand "circuit_at?") (("5" (expand "circuit?") (("5" (expand "pre_circuit?") (("5" (expand "cycle_at?") (("5" (expand "cycle?") (("5" (expand "circuit?") (("5" (expand "pre_circuit?") (("5" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_set type-eq-decl nil finite_sets nil) (Card const-decl "nat" finite_sets nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (vert const-decl "bool" c_digraphs_def digraphs) (size_def formula-decl nil digraphs_abs digraphs) (concretedigraph_implements_abstractdigraph formula-decl nil cycles_ digraphs) (size const-decl "nat" c_digraphs_def digraphs) (id_is_identity formula-decl nil measures nil) (measure_matrix_assoc formula-decl nil measures nil) (circuit? const-decl "bool" circuits_ digraphs) (cycle? const-decl "bool" cycles_ digraphs) (pre_circuit? const-decl "bool" circuits_ digraphs) (wgt_walk const-decl "Weight" weighted_digraphs_ digraphs) (make_c_wdg const-decl "wgd_type" c_weighted_digraphs_def digraphs) (get_value def-decl "Weight" c_weighted_digraphs_def digraphs) (has_key? const-decl "bool" c_weighted_digraphs_def digraphs) (get_wgt const-decl "Weight" c_weighted_digraphs_def digraphs) (edges const-decl "bool" c_digraphs_def digraphs) (c_digraph type-eq-decl nil c_digraphs_def digraphs) (Walk type-eq-decl nil walks_ digraphs) (wgd_dg const-decl "[wgd_type -> digraph_type]" c_weighted_digraphs_def digraphs) (walk? const-decl "bool" walks_ digraphs) (wgd_type type-eq-decl nil c_weighted_digraphs_def digraphs) (<= const-decl "bool" measures nil) (positive? const-decl "bool" measures nil) (cycle_at? const-decl "bool" cycles_ digraphs) (circuit_at? const-decl "bool" circuits_ digraphs) (prewalk type-eq-decl nil walks_ digraphs) (finseq type-eq-decl nil finite_sequences nil) (vert type-eq-decl nil digraphs_ digraphs) (vert? const-decl "bool" digraphs_ digraphs) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph_type]" c_digraphs_imp digraphs) (is_finite const-decl "bool" finite_sets nil) (digraph_size const-decl "[digraph_type -> nat]" c_digraphs_imp digraphs) (digraph_edges const-decl "[digraph_type -> [T, T -> bool]]" c_digraphs_imp digraphs) (digraph_verts const-decl "[digraph_type -> [T -> bool]]" c_digraphs_imp digraphs) (all_edges_in_map? const-decl "bool" c_weighted_digraphs_def digraphs) (id const-decl "Measure_Matrix" measures nil) (* const-decl "Measure_Matrix" measures nil) (Measure_Matrix type-eq-decl nil measures nil) (listn type-eq-decl nil listn structures) (Sign3 type-eq-decl nil sign3 reals) (cdigraph const-decl "bool" c_digraphs_def digraphs) (ComputableDigraph type-eq-decl nil c_digraphs_def digraphs) (digraph_type type-eq-decl nil c_digraphs_imp digraphs)) nil)))
