(|measures| (|get_TCC1| 0 (|get_TCC1-1| |nil| 3653416765 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|get| SUBTYPE "measures.i" "below[length[listn[Sign3](N)](m)]"))) (|get_TCC2| 0 (|get_TCC2-1| |nil| 3653416765 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (< CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL)) NIL (|get| SUBTYPE "measures.j" "below[length[Sign3](nth[listn[Sign3](N)](m, i))]"))) (|form_matrix_TCC1| 0 (|form_matrix_TCC1-1| |nil| 3653424979 ("" (SKEEP) (("" (USE "length_appendn[Sign3]") (("" (ASSERT) NIL NIL)) NIL)) NIL) ((|length_appendn| FORMULA-DECL NIL |more_list_props| |structures|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL)) NIL (|form_matrix| SUBTYPE "more_list_props[Sign3].^((: -1 :), measures.N)" "listn[Sign3](measures.N)"))) (|form_matrix_TCC2| 0 (|form_matrix_TCC2-1| |nil| 3653424979 ("" (SKEEP) (("" (INST 1 "(: Undefined :)^N") (("" (USE "length_appendn[Sign3]") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (^ DEF-DECL "list[T]" |more_list_props| |structures|) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|length_appendn| FORMULA-DECL NIL |more_list_props| |structures|)) NIL (|form_matrix| EXISTENCE "" "listn[Sign3](measures.N)"))) (|form_matrix_TCC3| 0 (|form_matrix_TCC3-1| |nil| 3653424979 ("" (EXPAND "eq") (("" (SKEEP*) (("" (EXPAND "get") (("" (INVOKE (TYPEPRED "%1") (! 1 1 1 1)) (("1" (INST?) (("1" (REPLACE -3 :DIR RL :HIDE? T) (("1" (INVOKE (TYPEPRED "%1") (! 1 1 1)) (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (INST 1 "(: Undefined :)^N") (("2" (USE "length_appendn[Sign3]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (USE "length_appendn[Sign3]") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (< CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|array2list| CONST-DECL "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" |array2list| |structures|) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (^ DEF-DECL "list[T]" |more_list_props| |structures|) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|length_appendn| FORMULA-DECL NIL |more_list_props| |structures|) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|get| CONST-DECL "Sign3" |measures| NIL) (|eq| CONST-DECL "bool" |measures| NIL)) NIL (|form_matrix| SUBTYPE "array2list[listn[Sign3](measures.N)].array2list(measures.N)(LAMBDA (k: naturalnumbers.nat): IF reals.<(k, measures.N) THEN array2list[Sign3].array2list(measures.N)(LAMBDA (p: naturalnumbers.nat): IF reals.<(p, measures.N) THEN measures.f(k)(p) ELSE -1 ENDIF) ELSE more_list_props[Sign3].^((: -1 :), measures.N) ENDIF)" "{m: measures.Measure_Matrix | measures.eq(m, measures.f)}"))) (|form_matfun_TCC1| 0 (|form_matfun_TCC1-1| |nil| 3653468924 ("" (SUBTYPE-TCC) NIL NIL) ((|get| CONST-DECL "Sign3" |measures| NIL) (|eq| CONST-DECL "bool" |measures| NIL)) NIL (|form_matfun| SUBTYPE "LAMBDA (i) (j): measures.get(measures.m)(measures.i, measures.j)" "{f | measures.eq(measures.m, measures.f)}"))) (|matrix_fun_idemp| 0 (|matrix_fun_idemp-2| |nil| 3653730861 ("" (SKEEP) (("" (USE "nth_extensionality[listn[Sign3](N)]") (("" (ASSERT) (("" (HIDE 2) (("" (SKOLEM 1 "i") (("" (USE "nth_extensionality[Sign3]") (("" (ASSERT) (("" (HIDE 2) (("" (SKOLEM 1 "j") (("" (TYPEPRED "form_matrix(form_matfun(m))") (("" (HIDE -1 -2) (("" (EXPAND "eq") (("" (EXPAND "get") (("" (INST?) (("" (REPLACE -1 :HIDE? T) (("" (TYPEPRED "form_matfun(m)") (("" (EXPAND "eq") (("" (EXPAND "get") (("" (INST?) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|nth_extensionality| FORMULA-DECL NIL |more_list_props| |structures|) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|form_matrix| CONST-DECL "{m: Measure_Matrix | eq(m, f)}" |measures| NIL) (|eq| CONST-DECL "bool" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|get| CONST-DECL "Sign3" |measures| NIL)) NIL) (|matrix_fun_idemp-1| |nil| 3653470211 ("" (SKEEP) (("" (USE "nth_extensionality_1[listn[Sign3](N)]") (("" (ASSERT) (("" (HIDE 2) (("" (SKOLEM 1 "i") (("" (USE "nth_extensionality_1[Sign3]") (("" (ASSERT) (("" (HIDE 2) (("" (SKOLEM 1 "j") (("" (TYPEPRED "form_matrix(form_matfun(m))") (("" (HIDE -1 -2) (("" (EXPAND "eq") (("" (EXPAND "get") (("" (INST?) (("" (REPLACE -1 :HIDE? T) (("" (TYPEPRED "form_matfun(m)") (("" (EXPAND "eq") (("" (EXPAND "get") (("" (INST?) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|fun_matrix_idemp| 0 (|fun_matrix_idemp-1| |nil| 3653470500 ("" (SKEEP) (("" (DECOMPOSE-EQUALITY) (("" (DECOMPOSE-EQUALITY) (("" (TYPEPRED "form_matfun(form_matrix(f))") (("" (EXPAND "eq") (("" (EXPAND "get") (("" (INST?) (("" (REPLACE -1 :HIDE? T :DIR RL) (("" (TYPEPRED "form_matrix(f)") (("" (HIDE -1 -2) (("" (EXPAND "eq") (("" (EXPAND "get") (("" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|form_matrix| CONST-DECL "{m: Measure_Matrix | eq(m, f)}" |measures| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|eq| CONST-DECL "bool" |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|get| CONST-DECL "Sign3" |measures| NIL)) SHOSTAK)) (|get_form_matrix| 0 (|get_form_matrix-1| |nil| 3653837389 ("" (SKEEP) (("" (TYPEPRED "form_matrix(f)") (("" (HIDE -1) (("" (EXPAND "eq") (("" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|form_matrix| CONST-DECL "{m: Measure_Matrix | eq(m, f)}" |measures| NIL) (|eq| CONST-DECL "bool" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) SHOSTAK)) (|max__TCC1| 0 (|max__TCC1-1| |nil| 3653480863 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|max_| SUBTYPE "0" "below(measures.n)"))) (|max__TCC2| 0 (|max__TCC2-1| |nil| 3653480863 ("" (SKEEP*) (("" (SPLIT 1) (("1" (SKEEP :PREDS? T) (("1" (GRIND) NIL NIL)) NIL) ("2" (INST 1 "0") NIL NIL)) NIL)) NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL)) NIL (|max_| SUBTYPE "measures.f(0)" "{t: sign3.Sign3 | booleans.AND(FORALL (i: naturalnumbers.below(measures.n)): reals.<=(measures.f(i), t), EXISTS (j: naturalnumbers.below(measures.n)): measures.f(j) = t)}"))) (|max__TCC3| 0 (|max__TCC3-1| |nil| 3653480863 ("" (SUBTYPE-TCC) NIL NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|max_| SUBTYPE "(number_fields.-)(measures.n, 1)" "below(measures.n)"))) (|max__TCC4| 0 (|max__TCC4-1| |nil| 3653480863 ("" (SKEEP) (("" (SKEEP) (("" (TYPEPRED "next") (("" (SPLIT 2) (("1" (SKEEP 1 :PREDS? T) (("1" (CASE "i = n-1") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP -3) (("2" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (<= CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|max_| SUBTYPE "measures.next" "{t: sign3.Sign3 | booleans.AND(FORALL (i: naturalnumbers.below(measures.n)): reals.<=(measures.f(i), t), EXISTS (j: naturalnumbers.below(measures.n)): measures.f(j) = t)}"))) (|max__TCC5| 0 (|max__TCC5-1| |nil| 3653480863 ("" (SKEEP*) (("" (SPLIT 3) (("1" (TYPEPRED "next") (("1" (SKEEP 1 :PREDS? T) (("1" (CASE "i = n-1") (("1" (ASSERT) NIL NIL) ("2" (INST -3 "i") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST?) NIL NIL)) NIL)) NIL) ((|i| SKOLEM-CONST-DECL "below(n)" |measures| NIL) (|n| SKOLEM-CONST-DECL "posnat" |measures| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (<= CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|max_| SUBTYPE "measures.f((number_fields.-)(measures.n, 1))" "{t: sign3.Sign3 | booleans.AND(FORALL (i: naturalnumbers.below(measures.n)): reals.<=(measures.f(i), t), EXISTS (j: naturalnumbers.below(measures.n)): measures.f(j) = t)}"))) (|max__TCC6| 0 (|max__TCC6-1| |nil| 3653481754 ("" (SUBTYPE-TCC) NIL NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|max_| SUBTYPE "measures.i" "below(measures.n)"))) (|max__TCC7| 0 (|max__TCC7-1| |nil| 3653481754 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|max_| SUBTYPE "(number_fields.-)(measures.n, 1)" "posnat"))) (|max__TCC8| 0 (|max__TCC8-1| |nil| 3653481754 ("" (TERMINATION-TCC) NIL NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|max_| TERMINATION "measures.max_((number_fields.-)(measures.n, 1))" "NIL"))) (|id_def| 0 (|id_def-1| |nil| 3653837454 ("" (SKEEP) (("" (EXPAND "id") (("" (USE "get_form_matrix") (("" (REPLACES -1) (("" (EXPAND "id_fun") (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|id| CONST-DECL "Measure_Matrix" |measures| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|get_form_matrix| FORMULA-DECL NIL |measures| NIL) (|id_fun| CONST-DECL "Sign3" |measures| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) SHOSTAK)) (|add_commute| 0 (|add_commute-1| |nil| 3575740263 ("" (SKEEP) (("" (GRIND) NIL NIL)) NIL) ((|Plus3| CONST-DECL "Sign3" |measures| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK)) (|add_assoc| 0 (|add_assoc-1| |nil| 3575739351 ("" (SKEEP) (("" (GRIND) NIL NIL)) NIL) ((|Plus3| CONST-DECL "Sign3" |measures| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK)) (|add_measures_positive| 0 (|add_measures_positive-1| |nil| 3631552760 ("" (GRIND) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|Plus3| CONST-DECL "Sign3" |measures| NIL)) SHOSTAK)) (|id_on_measures| 0 (|id_on_measures-1| |nil| 3588610057 ("" (SKEEP) (("" (EXPAND "Plus3") (("" (LIFT-IF) (("" (GROUND) (("1" (TYPEPRED "x") (("1" (ASSERT) NIL NIL)) NIL) ("2" (TYPEPRED "x") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|Plus3| CONST-DECL "Sign3" |measures| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) SHOSTAK)) (|card_prep| 0 (|card_prep-5| "" 3885252749 ("" (EXPAND "is_finite") (("" (INST 1 "(3^N)^N" "_") (("1" (LEMMA "funset_bijection") (("1" (CASE "EXISTS (g:[[below(N)->[below(N)->Sign3]]->below((3^N)^N)]): bijective?(g)") (("1" (SKEEP -1) (("1" (EXPAND "bijective?" -1) (("1" (FLATTEN) (("1" (INST 1 "LAMBDA(M: (fullset[Measure_Matrix])): g(LAMBDA(i: below(N))(j: below(N)): get(M)(i,j))") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (INST? -1 :WHERE -4) (("1" (ASSERT) (("1" (EXPAND "get") (("1" (HIDE-ALL-BUT (-1 1)) (("1" (DECOMPOSE-EQUALITY -1) (("1" (USE "nth_extensionality[listn[Sign3](N)]") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST -1 "n") (("1" (DECOMPOSE-EQUALITY -1) (("1" (USE "nth_extensionality[Sign3]") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "EXISTS (h: [[below(N)-> Sign3]->below(3^N)]): bijective?(h)") (("1" (SKEEP -1) (("1" (CASE "LET G = LAMBDA (gg:[below(N) -> [below(N) -> Sign3]]): LAMBDA (n:below(N)): h(gg(n)) IN bijective?(G) ") (("1" (INST -3 "3^N" "N") (("1" (SKOLEM -3 "H") (("1" (SKOLETIN) (("1" (INST 1 "H o G") (("1" (LEMMA "composition_bijective[[below(N)->[below(N)->Sign3]],[below(N)->below(3^N)], below((3^N)^N)]") (("1" (INST -1 "G" "H") NIL NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?" 1) (("2" (SPLIT 1) (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (EXPAND "G" -1) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (TYPEPRED "x!1") (("1" (FLATTEN) (("1" (DECOMPOSE-EQUALITY -2) (("1" (INST -1 "x!1") (("1" (INST -4 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "surjective?") (("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[[below(N)->Sign3], below(3^N)]") (("2" (INST -1 "h") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "hh") (("2" (INST 1 "LAMBDA (n:below(N)): hh(y(n))") (("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "G") (("2" (EXPAND "inverse?") (("2" (INST -1 "y(x!1)") (("2" (GROUND) (("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -4 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "LET (p: [below(3)-> Sign3]) = LAMBDA (s:below(3)): s-1 IN bijective?(p)") (("1" (SKOLETIN) (("1" (INST -3 "3" "N") (("1" (SKEEP) (("1" (CASE "LET (F:[[below(N)->below(3)]->[below(N)->Sign3]]) = LAMBDA (T:[below(N)->below(3)]): LAMBDA (s:below(N)): p(T(s))  IN bijective?(F)") (("1" (LEMMA "bijective_inverse_exists[[below(N)->below(3)],[below(N)-> Sign3]]") (("1" (SKOLETIN) (("1" (INST -3 "F") (("1" (LEMMA "bij_inv_is_bij_alt[[below(N)->below(3)],[below(N)-> Sign3]]") (("1" (EXPAND "exists1") (("1" (FLATTEN) (("1" (SKOLEM -4 "FF") (("1" (INST -1 "F" "FF") (("1" (INST 1 "LAMBDA (row:[below(N)->Sign3]): f(FF(row))") (("1" (CASE "LET H = o(f,FF) in bijective?(H)") (("1" (EXPAND "o") (("1" (PROPAX) NIL NIL)) NIL) ("2" (GROUND) (("2" (LEMMA "composition_bijective[[below(N)->Sign3],[below(N)->below(3)], below(3^N)]") (("2" (INST -1 "FF" "f") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "bijective?" 1) (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (SPLIT) (("1" (SKEEP) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (DECOMPOSE-EQUALITY -1) (("1" (INST -1 "x!1") (("1" (INST -2 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[below(3), Sign3]") (("2" (INST -1 "p") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "q") (("2" (INST 1 "LAMBDA(s:below(N)): q(y(s))") (("2" (EXPAND "inverse?") (("2" (DECOMPOSE-EQUALITY 1) (("2" (INST -1 "y(x!1)") (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -3 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) (("3" (EXPAND "p") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?") (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (HIDE -2) (("2" (GROUND) (("1" (SKEEP) (("1" (GROUND) (("1" (EXPAND "p") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (INST 1 "IF y=-1 THEN 0 ELSIF y=0 THEN 1 ELSE 2 ENDIF") (("2" (EXPAND "p") (("2" (GROUND) (("2" (LIFT-IF 1) (("2" (GROUND) (("2" (TYPEPRED "y") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED "N") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "N") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|card_prep-4| "" 3790335031 ("" (EXPAND "is_finite") (("" (INST 1 "(3^N)^N" "_") (("1" (LEMMA "funset_bijection") (("1" (CASE "EXISTS (g:[[below(N)->[below(N)->Sign3]]->below((3^N)^N)]): bijective?(g)") (("1" (SKEEP -1) (("1" (EXPAND "bijective?" -1) (("1" (FLATTEN) (("1" (INST 1 "LAMBDA(M: (fullset[Measure_Matrix])): g(LAMBDA(i: below(N))(j: below(N)): get(M)(i,j))") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (INST? -1 :WHERE -4) (("1" (ASSERT) (("1" (EXPAND "get") (("1" (HIDE-ALL-BUT (-1 1)) (("1" (DECOMPOSE-EQUALITY -1) (("1" (USE "nth_extensionality[listn[Sign3](N)]") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST -1 "n") (("1" (DECOMPOSE-EQUALITY -1) (("1" (USE "nth_extensionality[Sign3]") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "EXISTS (h: [[below(N)-> Sign3]->below(3^N)]): bijective?(h)") (("1" (SKEEP -1) (("1" (CASE "LET G = LAMBDA (gg:[below(N) -> [below(N) -> Sign3]]): LAMBDA (n:below(N)): h(gg(n)) IN bijective?(G) ") (("1" (INST -3 "3^N" "N") (("1" (SKOLEM -3 "H") (("1" (SKOLETIN) (("1" (INST 1 "H o G") (("1" (LEMMA "composition_bijective[[below(N)->[below(N)->Sign3]],[below(N)->below(3^N)], below((3^N)^N)]") (("1" (INST -1 "G" "H") NIL NIL) ("2" (FLATTEN) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?" 1) (("2" (SPLIT 1) (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (EXPAND "G" -1) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (TYPEPRED (X!1)) (("1" (FLATTEN) (("1" (DECOMPOSE-EQUALITY -2) (("1" (INST -1 "x!1") (("1" (INST -4 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "surjective?") (("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[[below(N)->Sign3], below(3^N)]") (("2" (INST -1 "h") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "hh") (("2" (INST 1 "LAMBDA (n:below(N)): hh(y(n))") (("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "G") (("2" (EXPAND "inverse?") (("2" (INST -1 "y(x!1)") (("2" (GROUND) (("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -4 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "LET (p: [below(3)-> Sign3]) = LAMBDA (s:below(3)): s-1 IN bijective?(p)") (("1" (SKOLETIN) (("1" (INST -3 "3" "N") (("1" (SKEEP) (("1" (CASE "LET (F:[[below(N)->below(3)]->[below(N)->Sign3]]) = LAMBDA (T:[below(N)->below(3)]): LAMBDA (s:below(N)): p(T(s))  IN bijective?(F)") (("1" (LEMMA "bijective_inverse_exists[[below(N)->below(3)],[below(N)-> Sign3]]") (("1" (SKOLETIN) (("1" (INST -3 "F") (("1" (LEMMA "bij_inv_is_bij_alt[[below(N)->below(3)],[below(N)-> Sign3]]") (("1" (EXPAND "exists1") (("1" (FLATTEN) (("1" (SKOLEM -4 "FF") (("1" (INST -1 "F" "FF") (("1" (INST 1 "LAMBDA (row:[below(N)->Sign3]): f(FF(row))") (("1" (CASE "LET H = o(f,FF) in bijective?(H)") (("1" (EXPAND "o") (("1" (PROPAX) NIL NIL)) NIL) ("2" (GROUND) (("2" (LEMMA "composition_bijective[[below(N)->Sign3],[below(N)->below(3)], below(3^N)]") (("2" (INST -1 "FF" "f") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "bijective?" 1) (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (SPLIT) (("1" (SKEEP) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (DECOMPOSE-EQUALITY -1) (("1" (INST -1 "x!1") (("1" (INST -2 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[below(3), Sign3]") (("2" (INST -1 "p") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "q") (("2" (INST 1 "LAMBDA(s:below(N)): q(y(s))") (("2" (EXPAND "inverse?") (("2" (DECOMPOSE-EQUALITY 1) (("2" (INST -1 "y(x!1)") (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -3 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) (("3" (EXPAND "p") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?") (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (HIDE -2) (("2" (GROUND) (("1" (SKEEP) (("1" (GROUND) (("1" (EXPAND "p") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (INST 1 "IF y=-1 THEN 0 ELSIF y=0 THEN 1 ELSE 2 ENDIF") (("2" (EXPAND "p") (("2" (GROUND) (("2" (LIFT-IF 1) (("2" (GROUND) (("2" (TYPEPRED (Y)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED (N)) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (N)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) ((|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (^ CONST-DECL "real" |exponentiation| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|posint_exp| APPLICATION-JUDGEMENT "posint" |exponentiation| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|bijective?| CONST-DECL "bool" |functions| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|fullset| CONST-DECL "set" |sets| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|get| CONST-DECL "Sign3" |measures| NIL) (|nth_extensionality| FORMULA-DECL NIL |more_list_props| |structures|) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|injective?| CONST-DECL "bool" |functions| NIL) (O CONST-DECL "T3" |function_props| NIL) (H SKOLEM-CONST-DECL "[[below[N] -> below[3 ^ N]] -> below[3 ^ N ^ N]]" |measures| NIL) (G SKOLEM-CONST-DECL "[[below(N) -> [below(N) -> Sign3]] -> [below(N) -> below(3 ^ N)]]" |measures| NIL) (|composition_bijective| JUDGEMENT-TCC NIL |function_props| NIL) (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (G SKOLEM-CONST-DECL "[[below(N) -> [below(N) -> Sign3]] -> [below(N) -> below(3 ^ N)]]" |measures| NIL) (|h| SKOLEM-CONST-DECL "[[below(N) -> Sign3] -> below(3 ^ N)]" |measures| NIL) (|inverse?| CONST-DECL "bool" |function_inverse_def| NIL) (|exists1| CONST-DECL "bool" |exists1| NIL) (|bijective_inverse_exists| FORMULA-DECL NIL |function_inverse_def| NIL) (|surjective?| CONST-DECL "bool" |functions| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|bij_inv_is_bij_alt| FORMULA-DECL NIL |function_inverse_def| NIL) (FF SKOLEM-CONST-DECL "[[below(N) -> Sign3] -> [below(N) -> below(3)]]" |measures| NIL) (F SKOLEM-CONST-DECL "[[below(N) -> below(3)] -> [below(N) -> int]]" |measures| NIL) (|p| SKOLEM-CONST-DECL "[below(3) -> int]" |measures| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|p| SKOLEM-CONST-DECL "[below(3) -> int]" |measures| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|funset_bijection| FORMULA-DECL NIL |fun_below_props| |sets_aux|) (|is_finite| CONST-DECL "bool" |finite_sets| NIL)) SHOSTAK) (|card_prep-3| |nil| 3653730960 ("" (EXPAND "is_finite") (("" (INST 1 "(3^N)^N" "_") (("1" (LEMMA "funset_bijection") (("1" (CASE "EXISTS (g:[[below(N)->[below(N)->Sign3]]->below((3^N)^N)]): bijective?(g)") (("1" (SKEEP -1) (("1" (EXPAND "bijective?" -1) (("1" (FLATTEN) (("1" (INST 1 "LAMBDA(M: (fullset[Measure_Matrix])): g(LAMBDA(i: below(N))(j: below(N)): get(M)(i,j))") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (INST? -1 :WHERE -4) (("1" (ASSERT) (("1" (EXPAND "get") (("1" (HIDE-ALL-BUT (-1 1)) (("1" (DECOMPOSE-EQUALITY -1) (("1" (USE "nth_extensionality[listn[Sign3](N)]") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST -1 "n") (("1" (DECOMPOSE-EQUALITY -1) (("1" (USE "nth_extensionality[Sign3]") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "EXISTS (h: [[below(N)-> Sign3]->below(3^N)]): bijective?(h)") (("1" (SKEEP -1) (("1" (CASE "LET G = LAMBDA (gg:[below(N) -> [below(N) -> Sign3]]): LAMBDA (n:below(N)): h(gg(n)) IN bijective?(G) ") (("1" (INST -3 "3^N" "N") (("1" (SKOLEM -3 "H") (("1" (SKOLETIN) (("1" (INST 1 "H o G") (("1" (LEMMA "composition_bijective[[below(N)->[below(N)->Sign3]],[below(N)->below(3^N)], below((3^N)^N)]") (("1" (INST -1 "G" "H") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?" 1) (("2" (SPLIT 1) (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (EXPAND "G" -1) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (TYPEPRED (X!1)) (("1" (FLATTEN) (("1" (DECOMPOSE-EQUALITY -2) (("1" (INST -1 "x!1") (("1" (INST -4 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "surjective?") (("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[[below(N)->Sign3], below(3^N)]") (("2" (INST -1 "h") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "hh") (("2" (INST 1 "LAMBDA (n:below(N)): hh(y(n))") (("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "G") (("2" (EXPAND "inverse?") (("2" (INST -1 "y(x!1)") (("2" (GROUND) (("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -4 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "LET (p: [below(3)-> Sign3]) = LAMBDA (s:below(3)): s-1 IN bijective?(p)") (("1" (SKOLETIN) (("1" (INST -3 "3" "N") (("1" (SKEEP) (("1" (CASE "LET (F:[[below(N)->below(3)]->[below(N)->Sign3]]) = LAMBDA (T:[below(N)->below(3)]): LAMBDA (s:below(N)): p(T(s))  IN bijective?(F)") (("1" (LEMMA "bijective_inverse_exists[[below(N)->below(3)],[below(N)-> Sign3]]") (("1" (SKOLETIN) (("1" (INST -3 "F") (("1" (LEMMA "bij_inv_is_bij_alt[[below(N)->below(3)],[below(N)-> Sign3]]") (("1" (EXPAND "exists1") (("1" (FLATTEN) (("1" (SKOLEM -4 "FF") (("1" (INST -1 "F" "FF") (("1" (INST 1 "LAMBDA (row:[below(N)->Sign3]): f(FF(row))") (("1" (CASE "LET H = o(f,FF) in bijective?(H)") (("1" (EXPAND "o") (("1" (PROPAX) NIL NIL)) NIL) ("2" (GROUND) (("2" (LEMMA "composition_bijective[[below(N)->Sign3],[below(N)->below(3)], below(3^N)]") (("2" (INST -1 "FF" "f") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "bijective?" 1) (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (SPLIT) (("1" (SKEEP) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (DECOMPOSE-EQUALITY -1) (("1" (INST -1 "x!1") (("1" (INST -2 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[below(3), Sign3]") (("2" (INST -1 "p") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "q") (("2" (INST 1 "LAMBDA(s:below(N)): q(y(s))") (("2" (EXPAND "inverse?") (("2" (DECOMPOSE-EQUALITY 1) (("2" (INST -1 "y(x!1)") (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -3 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) (("3" (EXPAND "p") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?") (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (HIDE -2) (("2" (GROUND) (("1" (SKEEP) (("1" (GROUND) (("1" (EXPAND "p") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (INST 1 "IF y=-1 THEN 0 ELSIF y=0 THEN 1 ELSE 2 ENDIF") (("2" (EXPAND "p") (("2" (GROUND) (("2" (LIFT-IF 1) (("2" (GROUND) (("2" (TYPEPRED (Y)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED (N)) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (N)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) NIL NIL) (|card_prep-2| |nil| 3631661261 ("" (EXPAND "is_finite") (("" (INST 1 "(3^N)^N" "_") (("1" (LEMMA "funset_bijection") (("1" (CASE "EXISTS (g:[[below(N)->[below(N)->Sign3]]->below((3^N)^N)]): bijective?(g)") (("1" (SKEEP -1) (("1" (EXPAND "bijective?" -1) (("1" (FLATTEN) (("1" (INST 1 "LAMBDA(M: (fullset[Measure_Matrix])): g(LAMBDA(i: below(N))(j: below(N)): get(M)(i,j))") (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (INST? -1 :WHERE -4) (("1" (ASSERT) (("1" (EXPAND "get") (("1" (HIDE-ALL-BUT (-1 1)) (("1" (DECOMPOSE-EQUALITY -1) (("1" (USE "nth_extensionality_1[listn[Sign3](N)]") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST -1 "n") (("1" (DECOMPOSE-EQUALITY -1) (("1" (USE "nth_extensionality_1[Sign3]") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "EXISTS (h: [[below(N)-> Sign3]->below(3^N)]): bijective?(h)") (("1" (SKEEP -1) (("1" (CASE "LET G = LAMBDA (gg:[below(N) -> [below(N) -> Sign3]]): LAMBDA (n:below(N)): h(gg(n)) IN bijective?(G) ") (("1" (INST -3 "3^N" "N") (("1" (SKOLEM -3 "H") (("1" (SKOLETIN) (("1" (INST 1 "H o G") (("1" (LEMMA "composition_bijective[[below(N)->[below(N)->Sign3]],[below(N)->below(3^N)], below((3^N)^N)]") (("1" (INST -1 "G" "H") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?" 1) (("2" (SPLIT 1) (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (EXPAND "G" -1) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (TYPEPRED (X!1)) (("1" (FLATTEN) (("1" (DECOMPOSE-EQUALITY -2) (("1" (INST -1 "x!1") (("1" (INST -4 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "surjective?") (("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[[below(N)->Sign3], below(3^N)]") (("2" (INST -1 "h") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "hh") (("2" (INST 1 "LAMBDA (n:below(N)): hh(y(n))") (("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "G") (("2" (EXPAND "inverse?") (("2" (INST -1 "y(x!1)") (("2" (GROUND) (("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -4 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "LET (p: [below(3)-> Sign3]) = LAMBDA (s:below(3)): s-1 IN bijective?(p)") (("1" (SKOLETIN) (("1" (INST -3 "3" "N") (("1" (SKEEP) (("1" (CASE "LET (F:[[below(N)->below(3)]->[below(N)->Sign3]]) = LAMBDA (T:[below(N)->below(3)]): LAMBDA (s:below(N)): p(T(s))  IN bijective?(F)") (("1" (LEMMA "bijective_inverse_exists[[below(N)->below(3)],[below(N)-> Sign3]]") (("1" (SKOLETIN) (("1" (INST -3 "F") (("1" (LEMMA "bij_inv_is_bij_alt[[below(N)->below(3)],[below(N)-> Sign3]]") (("1" (EXPAND "exists1") (("1" (FLATTEN) (("1" (SKOLEM -4 "FF") (("1" (INST -1 "F" "FF") (("1" (INST 1 "LAMBDA (row:[below(N)->Sign3]): f(FF(row))") (("1" (CASE "LET H = o(f,FF) in bijective?(H)") (("1" (EXPAND "o") (("1" (PROPAX) NIL NIL)) NIL) ("2" (GROUND) (("2" (LEMMA "composition_bijective[[below(N)->Sign3],[below(N)->below(3)], below(3^N)]") (("2" (INST -1 "FF" "f") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "bijective?" 1) (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (SPLIT) (("1" (SKEEP) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (DECOMPOSE-EQUALITY -1) (("1" (INST -1 "x!1") (("1" (INST -2 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[below(3), Sign3]") (("2" (INST -1 "p") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "q") (("2" (INST 1 "LAMBDA(s:below(N)): q(y(s))") (("2" (EXPAND "inverse?") (("2" (DECOMPOSE-EQUALITY 1) (("2" (INST -1 "y(x!1)") (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -3 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) (("3" (EXPAND "p") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?") (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (HIDE -2) (("2" (GROUND) (("1" (SKEEP) (("1" (GROUND) (("1" (EXPAND "p") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (INST 1 "IF y=-1 THEN 0 ELSIF y=0 THEN 1 ELSE 2 ENDIF") (("2" (EXPAND "p") (("2" (GROUND) (("2" (LIFT-IF 1) (("2" (GROUND) (("2" (TYPEPRED (Y)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED (N)) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (N)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) NIL NIL) (|card_prep-1| |nil| 3631015162 ("" (EXPAND "is_finite") (("" (INST 1 "(3^N)^N" "_") (("1" (LEMMA "funset_bijection") (("1" (CASE "EXISTS (g:[[below(N)->[below(N)->measures]]->below((3^N)^N)]): bijective?(g)") (("1" (SKEEP -1) (("1" (EXPAND "bijective?" -1) (("1" (FLATTEN) (("1" (INST 1 "g") (("1" (EXPAND "restrict") (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (TYPEPRED (N)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "EXISTS (h: [[below(N)-> measures]->below(3^N)]): bijective?(h)") (("1" (SKEEP -1) (("1" (CASE "LET G = LAMBDA (gg:[below(N) -> [below(N) -> measures]]): LAMBDA (n:below(N)): h(gg(n)) IN bijective?(G) ") (("1" (INST -3 "3^N" "N") (("1" (SKOLEM -3 "H") (("1" (SKOLETIN) (("1" (INST 1 "H o G") (("1" (LEMMA "composition_bijective[[below(N)->[below(N)->measures]],[below(N)->below(3^N)], below((3^N)^N)]") (("1" (INST -1 "G" "H") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?" 1) (("2" (SPLIT 1) (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (EXPAND "G" -1) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (TYPEPRED (X!1)) (("1" (FLATTEN) (("1" (DECOMPOSE-EQUALITY -2) (("1" (INST -1 "x!1") (("1" (INST -4 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "surjective?") (("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[[below(N)->measures], below(3^N)]") (("2" (INST -1 "h") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "hh") (("2" (INST 1 "LAMBDA (n:below(N)): hh(y(n))") (("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "G") (("2" (EXPAND "inverse?") (("2" (INST -1 "y(x!1)") (("2" (GROUND) (("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -4 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "LET (p: [below(3)-> measures]) = LAMBDA (s:below(3)): s-1 IN bijective?(p)") (("1" (SKOLETIN) (("1" (INST -3 "3" "N") (("1" (SKEEP) (("1" (CASE "LET (F:[[below(N)->below(3)]->[below(N)->measures]]) = LAMBDA (T:[below(N)->below(3)]): LAMBDA (s:below(N)): p(T(s))  IN bijective?(F)") (("1" (LEMMA "bijective_inverse_exists[[below(N)->below(3)],[below(N)-> measures]]") (("1" (SKOLETIN) (("1" (INST -3 "F") (("1" (LEMMA "bij_inv_is_bij_alt[[below(N)->below(3)],[below(N)-> measures]]") (("1" (EXPAND "exists1") (("1" (FLATTEN) (("1" (SKOLEM -4 "FF") (("1" (INST -1 "F" "FF") (("1" (INST 1 "LAMBDA (row:[below(N)->measures]): f(FF(row))") (("1" (CASE "LET H = o(f,FF) in bijective?(H)") (("1" (EXPAND "o") (("1" (PROPAX) NIL NIL)) NIL) ("2" (GROUND) (("2" (LEMMA "composition_bijective[[below(N)->measures],[below(N)->below(3)], below(3^N)]") (("2" (INST -1 "FF" "f") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "bijective?" 1) (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (SPLIT) (("1" (SKEEP) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (DECOMPOSE-EQUALITY -1) (("1" (INST -1 "x!1") (("1" (INST -2 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[below(3), measures]") (("2" (INST -1 "p") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "q") (("2" (INST 1 "LAMBDA(s:below(N)): q(y(s))") (("2" (EXPAND "inverse?") (("2" (DECOMPOSE-EQUALITY 1) (("2" (INST -1 "y(x!1)") (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -3 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) (("3" (EXPAND "p") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?") (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (HIDE -2) (("2" (GROUND) (("1" (SKEEP) (("1" (GROUND) (("1" (EXPAND "p") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (INST 1 "IF y=-1 THEN 0 ELSIF y=0 THEN 1 ELSE 2 ENDIF") (("2" (EXPAND "p") (("2" (GROUND) (("2" (LIFT-IF 1) (("2" (GROUND) (("2" (TYPEPRED (Y)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED (N)) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED (N)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|card_measure_matrices_TCC1| 0 (|card_measure_matrices_TCC1-1| |nil| 3631015109 ("" (LEMMA "card_prep") (("" (PROPAX) NIL NIL)) NIL) ((|card_prep| FORMULA-DECL NIL |measures| NIL)) NIL (|card_measure_matrices| SUBTYPE "sets[Measure_Matrix].fullset" "finite_set[Measure_Matrix]"))) (|card_measure_matrices_TCC2| 0 (|card_measure_matrices_TCC2-1| |nil| 3631015109 ("" (SUBTYPE-TCC) NIL NIL) ((/= CONST-DECL "boolean" |notequal| NIL)) NIL (|card_measure_matrices| SUBTYPE "2" "{i: integers.int | booleans.OR(measures.N /= 0, reals.>=(i, 0))}"))) (|card_measure_matrices| 0 (|card_measure_matrices-4| "" 3885252816 ("" (REWRITE "expt_x2") (("" (REWRITE "expt_times") (("" (CASE "EXISTS (g:[[below(N)->[below(N)->Sign3]]->below((3^N)^N)]): bijective?(g)") (("1" (SKEEP) (("1" (LEMMA "card_bij[Measure_Matrix]") (("1" (INST -1 "(3^N)^N" "fullset[Measure_Matrix]") (("1" (FLATTEN) (("1" (HIDE -1) (("1" (CASE "EXISTS (G: [(fullset[Measure_Matrix])->[below(N)->[below(N)->Sign3]]]): bijective?(G)") (("1" (SKEEP -1) (("1" (SPLIT -2) (("1" (PROPAX) NIL NIL) ("2" (LEMMA "composition_bijective[(fullset[Measure_Matrix]),[below(N)->[below(N)->Sign3]], below((3^N)^N)]") (("2" (INST -1 "G" "g") (("2" (INST 1 "g o G") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (INST 1 "LAMBDA(M: (fullset[Measure_Matrix])): LAMBDA(i:below(N))(j: below(N)): get(M)(i,j)") (("2" (EXPAND "bijective?") (("2" (SPLIT 1) (("1" (EXPAND "injective?") (("1" (SKOLEM 1 ("M1" "M2")) (("1" (FLATTEN) (("1" (EXPAND "get") (("1" (DECOMPOSE-EQUALITY -1) (("1" (USE "nth_extensionality[listn[Sign3](N)]") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST -1 "n") (("1" (DECOMPOSE-EQUALITY -1) (("1" (USE "nth_extensionality[Sign3]") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "surjective?") (("2" (SKOLEM 1 "f_") (("2" (INST 1 "array2list[listn[Sign3](N)](N)(LAMBDA (k:nat): IF k < N THEN
                                       array2list[Sign3](N)(LAMBDA (p:nat): IF p<N THEN f_(k)(p) ELSE Undefined ENDIF)
                         	      ELSE (:Undefined:)^N ENDIF)") (("1" (WITH-TCCS (DECOMPOSE-EQUALITY)) (("1" (WITH-TCCS (DECOMPOSE-EQUALITY)) (("1" (EXPAND "get") (("1" (WITH-TCCS (TYPEPRED "array2list[listn[Sign3](N)]
                                                            (N)
                                                            (LAMBDA (k: nat):
                                                               IF k < N
                                                                 THEN array2list[Sign3]
                                                                          (N)(LAMBDA (p: nat): IF p < N THEN f_(k)(p) ELSE -1 ENDIF)
                                                               ELSE (: -1 :) ^ N
                                                               ENDIF)")) (("1" (INST?) (("1" (REPLACE -3 :DIR RL :HIDE? T) (("1" (TYPEPRED "array2list[Sign3](N)(LAMBDA (p: nat): IF p < N THEN f_(x!1)(p) ELSE -1 ENDIF)") (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "fullset") (("2" (PROPAX) NIL NIL)) NIL) ("3" (USE "length_appendn[Sign3]") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (USE "length_appendn[Sign3]") (("2" (ASSERT) (("2" (HIDE 2) (("2" (LEMMA "funset_bijection") (("2" (CASE "EXISTS (h: [[below(N)-> Sign3]->below(3^N)]): bijective?(h)") (("1" (SKEEP -1) (("1" (CASE "LET G = LAMBDA (gg:[below(N) -> [below(N) -> Sign3]]): LAMBDA (n:below(N)): h(gg(n)) IN bijective?(G) ") (("1" (INST -3 "3^N" "N") (("1" (SKOLEM -3 "H") (("1" (SKOLETIN) (("1" (INST 1 "H o G") (("1" (LEMMA "composition_bijective[[below(N)->[below(N)->Sign3]],[below(N)->below(3^N)], below((3^N)^N)]") (("1" (INST -1 "G" "H") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?" 1) (("2" (SPLIT 1) (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (EXPAND "G" -1) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (TYPEPRED "x!1") (("1" (FLATTEN) (("1" (DECOMPOSE-EQUALITY -2) (("1" (INST -1 "x!1") (("1" (INST -4 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "surjective?") (("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[[below(N)->Sign3], below(3^N)]") (("2" (INST -1 "h") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "hh") (("2" (INST 1 "LAMBDA (n:below(N)): hh(y(n))") (("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "G") (("2" (EXPAND "inverse?") (("2" (INST -1 "y(x!1)") (("2" (GROUND) (("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -4 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "LET (p: [below(3)-> Sign3]) = LAMBDA (s:below(3)): s-1 IN bijective?(p)") (("1" (SKOLETIN) (("1" (INST -3 "3" "N") (("1" (SKEEP) (("1" (CASE "LET (F:[[below(N)->below(3)]->[below(N)->Sign3]]) = LAMBDA (T:[below(N)->below(3)]): LAMBDA (s:below(N)): p(T(s))  IN bijective?(F)") (("1" (LEMMA "bijective_inverse_exists[[below(N)->below(3)],[below(N)-> Sign3]]") (("1" (SKOLETIN) (("1" (INST -3 "F") (("1" (LEMMA "bij_inv_is_bij_alt[[below(N)->below(3)],[below(N)-> Sign3]]") (("1" (EXPAND "exists1") (("1" (FLATTEN) (("1" (SKOLEM -4 "FF") (("1" (INST -1 "F" "FF") (("1" (INST 1 "LAMBDA (row:[below(N)->Sign3]): f(FF(row))") (("1" (CASE "LET H = o(f,FF) in bijective?(H)") (("1" (EXPAND "o") (("1" (PROPAX) NIL NIL)) NIL) ("2" (GROUND) (("2" (LEMMA "composition_bijective[[below(N)->Sign3],[below(N)->below(3)], below(3^N)]") (("2" (INST -1 "FF" "f") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "bijective?" 1) (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (SPLIT) (("1" (SKEEP) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (DECOMPOSE-EQUALITY -1) (("1" (INST -1 "x!1") (("1" (INST -2 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[below(3), Sign3]") (("2" (INST -1 "p") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "q") (("2" (INST 1 "LAMBDA(s:below(N)): q(y(s))") (("2" (EXPAND "inverse?") (("2" (DECOMPOSE-EQUALITY 1) (("2" (INST -1 "y(x!1)") (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -3 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) (("3" (EXPAND "p") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?") (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (HIDE -2) (("2" (GROUND) (("1" (SKEEP) (("1" (GROUND) (("1" (EXPAND "p") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (INST 1 "IF y=-1 THEN 0 ELSIF y=0 THEN 1 ELSE 2 ENDIF") (("2" (EXPAND "p") (("2" (GROUND) (("2" (LIFT-IF 1) (("2" (GROUND) (("2" (TYPEPRED "y") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|card_measure_matrices-3| |nil| 3653731302 ("" (REWRITE "expt_x2") (("" (REWRITE "expt_times") (("" (CASE "EXISTS (g:[[below(N)->[below(N)->Sign3]]->below((3^N)^N)]): bijective?(g)") (("1" (SKEEP) (("1" (LEMMA "card_bij[Measure_Matrix]") (("1" (INST -1 "(3^N)^N" "fullset[Measure_Matrix]") (("1" (FLATTEN) (("1" (HIDE -1) (("1" (CASE "EXISTS (G: [(fullset[Measure_Matrix])->[below(N)->[below(N)->Sign3]]]): bijective?(G)") (("1" (SKEEP -1) (("1" (SPLIT -2) (("1" (PROPAX) NIL NIL) ("2" (LEMMA "composition_bijective[(fullset[Measure_Matrix]),[below(N)->[below(N)->Sign3]], below((3^N)^N)]") (("2" (INST -1 "G" "g") (("2" (INST 1 "g o G") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (INST 1 "LAMBDA(M: (fullset[Measure_Matrix])): LAMBDA(i:below(N))(j: below(N)): get(M)(i,j)") (("2" (EXPAND "bijective?") (("2" (SPLIT 1) (("1" (EXPAND "injective?") (("1" (SKOLEM 1 ("M1" "M2")) (("1" (FLATTEN) (("1" (EXPAND "get") (("1" (DECOMPOSE-EQUALITY -1) (("1" (USE "nth_extensionality[listn[Sign3](N)]") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST -1 "n") (("1" (DECOMPOSE-EQUALITY -1) (("1" (USE "nth_extensionality[Sign3]") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "surjective?") (("2" (SKOLEM 1 "f_") (("2" (INST 1 "array2list[listn[Sign3](N)](N)(LAMBDA (k:nat): IF k < N THEN
                                       array2list[Sign3](N)(LAMBDA (p:nat): IF p<N THEN f_(k)(p) ELSE Undefined ENDIF)
                         	      ELSE (:Undefined:)^N ENDIF)") (("1" (WITH-TCCS (DECOMPOSE-EQUALITY)) (("1" (WITH-TCCS (DECOMPOSE-EQUALITY)) (("1" (EXPAND "get") (("1" (WITH-TCCS (TYPEPRED "array2list[listn[Sign3](N)]
                                                            (N)
                                                            (LAMBDA (k: nat):
                                                               IF k < N
                                                                 THEN array2list[Sign3]
                                                                          (N)(LAMBDA (p: nat): IF p < N THEN f_(k)(p) ELSE -1 ENDIF)
                                                               ELSE (: -1 :) ^ N
                                                               ENDIF)")) (("1" (INST?) (("1" (REPLACE -3 :DIR RL :HIDE? T) (("1" (TYPEPRED "array2list[Sign3](N)(LAMBDA (p: nat): IF p < N THEN f_(x!1)(p) ELSE -1 ENDIF)") (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "fullset") (("2" (PROPAX) NIL NIL)) NIL) ("3" (INST 1 "(: Undefined :)^N") (("3" (USE "length_appendn[Sign3]") (("3" (ASSERT) NIL NIL)) NIL)) NIL) ("4" (SKEEP) (("4" (USE "length_appendn[Sign3]") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (LEMMA "funset_bijection") (("2" (CASE "EXISTS (h: [[below(N)-> Sign3]->below(3^N)]): bijective?(h)") (("1" (SKEEP -1) (("1" (CASE "LET G = LAMBDA (gg:[below(N) -> [below(N) -> Sign3]]): LAMBDA (n:below(N)): h(gg(n)) IN bijective?(G) ") (("1" (INST -3 "3^N" "N") (("1" (SKOLEM -3 "H") (("1" (SKOLETIN) (("1" (INST 1 "H o G") (("1" (LEMMA "composition_bijective[[below(N)->[below(N)->Sign3]],[below(N)->below(3^N)], below((3^N)^N)]") (("1" (INST -1 "G" "H") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?" 1) (("2" (SPLIT 1) (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (EXPAND "G" -1) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (TYPEPRED (X!1)) (("1" (FLATTEN) (("1" (DECOMPOSE-EQUALITY -2) (("1" (INST -1 "x!1") (("1" (INST -4 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "surjective?") (("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[[below(N)->Sign3], below(3^N)]") (("2" (INST -1 "h") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "hh") (("2" (INST 1 "LAMBDA (n:below(N)): hh(y(n))") (("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "G") (("2" (EXPAND "inverse?") (("2" (INST -1 "y(x!1)") (("2" (GROUND) (("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -4 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "LET (p: [below(3)-> Sign3]) = LAMBDA (s:below(3)): s-1 IN bijective?(p)") (("1" (SKOLETIN) (("1" (INST -3 "3" "N") (("1" (SKEEP) (("1" (CASE "LET (F:[[below(N)->below(3)]->[below(N)->Sign3]]) = LAMBDA (T:[below(N)->below(3)]): LAMBDA (s:below(N)): p(T(s))  IN bijective?(F)") (("1" (LEMMA "bijective_inverse_exists[[below(N)->below(3)],[below(N)-> Sign3]]") (("1" (SKOLETIN) (("1" (INST -3 "F") (("1" (LEMMA "bij_inv_is_bij_alt[[below(N)->below(3)],[below(N)-> Sign3]]") (("1" (EXPAND "exists1") (("1" (FLATTEN) (("1" (SKOLEM -4 "FF") (("1" (INST -1 "F" "FF") (("1" (INST 1 "LAMBDA (row:[below(N)->Sign3]): f(FF(row))") (("1" (CASE "LET H = o(f,FF) in bijective?(H)") (("1" (EXPAND "o") (("1" (PROPAX) NIL NIL)) NIL) ("2" (GROUND) (("2" (LEMMA "composition_bijective[[below(N)->Sign3],[below(N)->below(3)], below(3^N)]") (("2" (INST -1 "FF" "f") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "bijective?" 1) (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (SPLIT) (("1" (SKEEP) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (DECOMPOSE-EQUALITY -1) (("1" (INST -1 "x!1") (("1" (INST -2 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[below(3), Sign3]") (("2" (INST -1 "p") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "q") (("2" (INST 1 "LAMBDA(s:below(N)): q(y(s))") (("2" (EXPAND "inverse?") (("2" (DECOMPOSE-EQUALITY 1) (("2" (INST -1 "y(x!1)") (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -3 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) (("3" (EXPAND "p") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?") (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (HIDE -2) (("2" (GROUND) (("1" (SKEEP) (("1" (GROUND) (("1" (EXPAND "p") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (INST 1 "IF y=-1 THEN 0 ELSIF y=0 THEN 1 ELSE 2 ENDIF") (("2" (EXPAND "p") (("2" (GROUND) (("2" (LIFT-IF 1) (("2" (GROUND) (("2" (TYPEPRED (Y)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|posint_exp| APPLICATION-JUDGEMENT "posint" |exponentiation| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|expt_times| FORMULA-DECL NIL |exponentiation| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nzreal| NONEMPTY-TYPE-EQ-DECL NIL |reals| NIL) (|card| CONST-DECL "{n: nat | n = Card(S)}" |finite_sets| NIL) (|Card| CONST-DECL "nat" |finite_sets| NIL) (H SKOLEM-CONST-DECL "[[below[N] -> below[3 ^ N]] -> below[3 ^ N ^ N]]" |measures| NIL) (G SKOLEM-CONST-DECL "[[below(N) -> [below(N) -> Sign3]] -> [below(N) -> below(3 ^ N)]]" |measures| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (G SKOLEM-CONST-DECL "[[below(N) -> [below(N) -> Sign3]] -> [below(N) -> below(3 ^ N)]]" |measures| NIL) (|h| SKOLEM-CONST-DECL "[[below(N) -> Sign3] -> below(3 ^ N)]" |measures| NIL) (|inverse?| CONST-DECL "bool" |function_inverse_def| NIL) (|exists1| CONST-DECL "bool" |exists1| NIL) (|bijective_inverse_exists| FORMULA-DECL NIL |function_inverse_def| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|bij_inv_is_bij_alt| FORMULA-DECL NIL |function_inverse_def| NIL) (FF SKOLEM-CONST-DECL "[[below(N) -> Sign3] -> [below(N) -> below(3)]]" |measures| NIL) (F SKOLEM-CONST-DECL "[[below(N) -> below(3)] -> [below(N) -> int]]" |measures| NIL) (|p| SKOLEM-CONST-DECL "[below(3) -> int]" |measures| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|p| SKOLEM-CONST-DECL "[below(3) -> int]" |measures| NIL) (|funset_bijection| FORMULA-DECL NIL |fun_below_props| |sets_aux|) (|set| TYPE-EQ-DECL NIL |sets| NIL) (|is_finite| CONST-DECL "bool" |finite_sets| NIL) (|finite_set| TYPE-EQ-DECL NIL |finite_sets| NIL) (|fullset| CONST-DECL "set" |sets| NIL) (|surjective?| CONST-DECL "bool" |functions| NIL) (|cons| ADT-CONSTRUCTOR-DECL "[[T, list] -> (cons?)]" |list_adt| NIL) (|cons?| ADT-RECOGNIZER-DECL "[list -> boolean]" |list_adt| NIL) (^ DEF-DECL "list[T]" |more_list_props| |structures|) (|f_| SKOLEM-CONST-DECL "[below(N) -> [below(N) -> Sign3]]" |measures| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|array2list| CONST-DECL "{l: listn(n) | FORALL (i: below(n)): a(i) = nth(l, i)}" |array2list| |structures|) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|id| CONST-DECL "(bijective?[T, T])" |identity| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|length_singleton| FORMULA-DECL NIL |more_list_props| |structures|) (|length_appendn| FORMULA-DECL NIL |more_list_props| |structures|) (|injective?| CONST-DECL "bool" |functions| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|nth| DEF-DECL "T" |list_props| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nth_extensionality| FORMULA-DECL NIL |more_list_props| |structures|) (|get| CONST-DECL "Sign3" |measures| NIL) (|composition_bijective| JUDGEMENT-TCC NIL |function_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (O CONST-DECL "T3" |function_props| NIL) (|g| SKOLEM-CONST-DECL "[[below(N) -> [below(N) -> Sign3]] -> below((3 ^ N) ^ N)]" |measures| NIL) (G SKOLEM-CONST-DECL "[(fullset[Measure_Matrix]) -> [below(N) -> [below(N) -> Sign3]]]" |measures| NIL) (|card_bij| FORMULA-DECL NIL |finite_sets| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (^ CONST-DECL "real" |exponentiation| NIL) (|bijective?| CONST-DECL "bool" |functions| NIL) (|posint_times_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|expt_x2| FORMULA-DECL NIL |exponentiation| NIL)) NIL) (|card_measure_matrices-2| |nil| 3631661308 ("" (REWRITE "expt_x2") (("" (REWRITE "expt_times") (("" (CASE "EXISTS (g:[[below(N)->[below(N)->Sign3]]->below((3^N)^N)]): bijective?(g)") (("1" (SKEEP) (("1" (LEMMA "card_bij[Measure_Matrix]") (("1" (INST -1 "(3^N)^N" "fullset[Measure_Matrix]") (("1" (FLATTEN) (("1" (HIDE -1) (("1" (CASE "EXISTS (G: [(fullset[Measure_Matrix])->[below(N)->[below(N)->Sign3]]]): bijective?(G)") (("1" (SKEEP -1) (("1" (SPLIT -2) (("1" (PROPAX) NIL NIL) ("2" (LEMMA "composition_bijective[(fullset[Measure_Matrix]),[below(N)->[below(N)->Sign3]], below((3^N)^N)]") (("2" (INST -1 "G" "g") (("2" (INST 1 "g o G") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (INST 1 "LAMBDA(M: (fullset[Measure_Matrix])): LAMBDA(i:below(N))(j: below(N)): get(M)(i,j)") (("2" (EXPAND "bijective?") (("2" (SPLIT 1) (("1" (EXPAND "injective?") (("1" (SKOLEM 1 ("M1" "M2")) (("1" (FLATTEN) (("1" (EXPAND "get") (("1" (DECOMPOSE-EQUALITY -1) (("1" (USE "nth_extensionality_1[listn[Sign3](N)]") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST -1 "n") (("1" (DECOMPOSE-EQUALITY -1) (("1" (USE "nth_extensionality_1[Sign3]") (("1" (ASSERT) (("1" (SKEEP) (("1" (INST?) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "surjective?") (("2" (SKOLEM 1 "f_") (("2" (INST 1 "array2list[listn[Sign3](N)](N)(LAMBDA (k:nat): IF k < N THEN
              array2list[Sign3](N)(LAMBDA (p:nat): IF p<N THEN f_(k)(p) ELSE Undefined ENDIF)
	      ELSE (:Undefined:)^N ENDIF)") (("1" (DECOMPOSE-EQUALITY) (("1" (DECOMPOSE-EQUALITY) (("1" (EXPAND "get") (("1" (TYPEPRED "array2list[listn[Sign3](N)]
                  (N)
                  (LAMBDA (k: nat):
                     IF k < N
                       THEN array2list[Sign3]
                                (N)(LAMBDA (p: nat): IF p < N THEN f_(k)(p) ELSE -1 ENDIF)
                     ELSE (: -1 :) ^ N
                     ENDIF)") (("1" (INST?) (("1" (REPLACE -3 :DIR RL :HIDE? T) (("1" (TYPEPRED "array2list[Sign3](N)(LAMBDA (p: nat): IF p < N THEN f_(x!1)(p) ELSE -1 ENDIF)") (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (USE "length_appendn[Sign3]") (("1" (ASSERT) NIL NIL) ("2" (EXPAND "every") (("2" (EXPAND "every") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (SKEEP) (("3" (HIDE-ALL-BUT 2) (("3" (USE "length_appendn[Sign3]") (("1" (ASSERT) (("1" (EXPAND "every") (("1" (EXPAND "every") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "every") (("2" (EXPAND "every") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (USE "length_appendn[Sign3]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (USE "length_appendn[Sign3]") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "fullset") (("2" (PROPAX) NIL NIL)) NIL) ("3" (USE "length_appendn[Sign3]") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (LEMMA "funset_bijection") (("2" (CASE "EXISTS (h: [[below(N)-> Sign3]->below(3^N)]): bijective?(h)") (("1" (SKEEP -1) (("1" (CASE "LET G = LAMBDA (gg:[below(N) -> [below(N) -> Sign3]]): LAMBDA (n:below(N)): h(gg(n)) IN bijective?(G) ") (("1" (INST -3 "3^N" "N") (("1" (SKOLEM -3 "H") (("1" (SKOLETIN) (("1" (INST 1 "H o G") (("1" (LEMMA "composition_bijective[[below(N)->[below(N)->Sign3]],[below(N)->below(3^N)], below((3^N)^N)]") (("1" (INST -1 "G" "H") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?" 1) (("2" (SPLIT 1) (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (EXPAND "G" -1) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (TYPEPRED (X!1)) (("1" (FLATTEN) (("1" (DECOMPOSE-EQUALITY -2) (("1" (INST -1 "x!1") (("1" (INST -4 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "surjective?") (("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[[below(N)->Sign3], below(3^N)]") (("2" (INST -1 "h") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "hh") (("2" (INST 1 "LAMBDA (n:below(N)): hh(y(n))") (("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "G") (("2" (EXPAND "inverse?") (("2" (INST -1 "y(x!1)") (("2" (GROUND) (("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -4 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "LET (p: [below(3)-> Sign3]) = LAMBDA (s:below(3)): s-1 IN bijective?(p)") (("1" (SKOLETIN) (("1" (INST -3 "3" "N") (("1" (SKEEP) (("1" (CASE "LET (F:[[below(N)->below(3)]->[below(N)->Sign3]]) = LAMBDA (T:[below(N)->below(3)]): LAMBDA (s:below(N)): p(T(s))  IN bijective?(F)") (("1" (LEMMA "bijective_inverse_exists[[below(N)->below(3)],[below(N)-> Sign3]]") (("1" (SKOLETIN) (("1" (INST -3 "F") (("1" (LEMMA "bij_inv_is_bij_alt[[below(N)->below(3)],[below(N)-> Sign3]]") (("1" (EXPAND "exists1") (("1" (FLATTEN) (("1" (SKOLEM -4 "FF") (("1" (INST -1 "F" "FF") (("1" (INST 1 "LAMBDA (row:[below(N)->Sign3]): f(FF(row))") (("1" (CASE "LET H = o(f,FF) in bijective?(H)") (("1" (EXPAND "o") (("1" (PROPAX) NIL NIL)) NIL) ("2" (GROUND) (("2" (LEMMA "composition_bijective[[below(N)->Sign3],[below(N)->below(3)], below(3^N)]") (("2" (INST -1 "FF" "f") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "bijective?" 1) (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (SPLIT) (("1" (SKEEP) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (DECOMPOSE-EQUALITY -1) (("1" (INST -1 "x!1") (("1" (INST -2 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[below(3), Sign3]") (("2" (INST -1 "p") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "q") (("2" (INST 1 "LAMBDA(s:below(N)): q(y(s))") (("2" (EXPAND "inverse?") (("2" (DECOMPOSE-EQUALITY 1) (("2" (INST -1 "y(x!1)") (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -3 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) (("3" (EXPAND "p") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?") (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (HIDE -2) (("2" (GROUND) (("1" (SKEEP) (("1" (GROUND) (("1" (EXPAND "p") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (INST 1 "IF y=-1 THEN 0 ELSIF y=0 THEN 1 ELSE 2 ENDIF") (("2" (EXPAND "p") (("2" (GROUND) (("2" (LIFT-IF 1) (("2" (GROUND) (("2" (TYPEPRED (Y)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL) (|card_measure_matrices-1| |nil| 3631033652 ("" (REWRITE "expt_x2") (("" (REWRITE "expt_times") (("" (CASE "EXISTS (g:[[below(N)->[below(N)->measures]]->below((3^N)^N)]): bijective?(g)") (("1" (SKEEP) (("1" (LEMMA "card_bij[Measure_Matrix]") (("1" (INST -1 "(3^N)^N" "fullset[Measure_Matrix]") (("1" (FLATTEN) (("1" (HIDE -1) (("1" (CASE "EXISTS (G: [(fullset[Measure_Matrix])->[below(N)->[below(N)->measures]]]): bijective?(G)") (("1" (SKEEP -1) (("1" (SPLIT -2) (("1" (PROPAX) NIL NIL) ("2" (LEMMA "composition_bijective[(fullset[Measure_Matrix]),[below(N)->[below(N)->measures]], below((3^N)^N)]") (("2" (INST -1 "G" "g") (("2" (INST 1 "g o G") NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST 1 "LAMBDA (s:(fullset[Measure_Matrix])): s") (("2" (HIDE-ALL-BUT 1) (("2" (EXPAND "bijective?") (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (GROUND) (("1" (SKEEP) NIL NIL) ("2" (SKEEP) (("2" (INST 1 "y") (("2" (EXPAND "fullset") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (LEMMA "funset_bijection") (("2" (CASE "EXISTS (h: [[below(N)-> measures]->below(3^N)]): bijective?(h)") (("1" (SKEEP -1) (("1" (CASE "LET G = LAMBDA (gg:[below(N) -> [below(N) -> measures]]): LAMBDA (n:below(N)): h(gg(n)) IN bijective?(G) ") (("1" (INST -3 "3^N" "N") (("1" (SKOLEM -3 "H") (("1" (SKOLETIN) (("1" (INST 1 "H o G") (("1" (LEMMA "composition_bijective[[below(N)->[below(N)->measures]],[below(N)->below(3^N)], below((3^N)^N)]") (("1" (INST -1 "G" "H") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?" 1) (("2" (SPLIT 1) (("1" (EXPAND "injective?") (("1" (SKEEP) (("1" (EXPAND "G" -1) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (TYPEPRED (X!1)) (("1" (FLATTEN) (("1" (DECOMPOSE-EQUALITY -2) (("1" (INST -1 "x!1") (("1" (INST -4 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "surjective?") (("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[[below(N)->measures], below(3^N)]") (("2" (INST -1 "h") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "hh") (("2" (INST 1 "LAMBDA (n:below(N)): hh(y(n))") (("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "G") (("2" (EXPAND "inverse?") (("2" (INST -1 "y(x!1)") (("2" (GROUND) (("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -4 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (CASE "LET (p: [below(3)-> measures]) = LAMBDA (s:below(3)): s-1 IN bijective?(p)") (("1" (SKOLETIN) (("1" (INST -3 "3" "N") (("1" (SKEEP) (("1" (CASE "LET (F:[[below(N)->below(3)]->[below(N)->measures]]) = LAMBDA (T:[below(N)->below(3)]): LAMBDA (s:below(N)): p(T(s))  IN bijective?(F)") (("1" (LEMMA "bijective_inverse_exists[[below(N)->below(3)],[below(N)-> measures]]") (("1" (SKOLETIN) (("1" (INST -3 "F") (("1" (LEMMA "bij_inv_is_bij_alt[[below(N)->below(3)],[below(N)-> measures]]") (("1" (EXPAND "exists1") (("1" (FLATTEN) (("1" (SKOLEM -4 "FF") (("1" (INST -1 "F" "FF") (("1" (INST 1 "LAMBDA (row:[below(N)->measures]): f(FF(row))") (("1" (CASE "LET H = o(f,FF) in bijective?(H)") (("1" (EXPAND "o") (("1" (PROPAX) NIL NIL)) NIL) ("2" (GROUND) (("2" (LEMMA "composition_bijective[[below(N)->measures],[below(N)->below(3)], below(3^N)]") (("2" (INST -1 "FF" "f") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (EXPAND "bijective?" 1) (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (SPLIT) (("1" (SKEEP) (("1" (EXPAND "bijective?") (("1" (EXPAND "injective?") (("1" (DECOMPOSE-EQUALITY 1) (("1" (DECOMPOSE-EQUALITY -1) (("1" (INST -1 "x!1") (("1" (INST -2 "x1(x!1)" "x2(x!1)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "bijective_inverse_exists[below(3), measures]") (("2" (INST -1 "p") (("2" (EXPAND "exists1") (("2" (FLATTEN) (("2" (SKOLEM -1 "q") (("2" (INST 1 "LAMBDA(s:below(N)): q(y(s))") (("2" (EXPAND "inverse?") (("2" (DECOMPOSE-EQUALITY 1) (("2" (INST -1 "y(x!1)") (("2" (SPLIT -1) (("1" (PROPAX) NIL NIL) ("2" (EXPAND "bijective?") (("2" (EXPAND "surjective?") (("2" (FLATTEN) (("2" (INST -3 "y(x!1)") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) (("3" (EXPAND "p") (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOLETIN) (("2" (EXPAND "bijective?") (("2" (EXPAND "injective?") (("2" (EXPAND "surjective?") (("2" (HIDE -2) (("2" (GROUND) (("1" (SKEEP) (("1" (GROUND) (("1" (EXPAND "p") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (INST 1 "IF y=-1 THEN 0 ELSIF y=0 THEN 1 ELSE 2 ENDIF") (("2" (EXPAND "p") (("2" (GROUND) (("2" (LIFT-IF 1) (("2" (GROUND) (("2" (TYPEPRED (Y)) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|matrices_fun_order| 0 (|matrices_fun_order-1| |nil| 3653473324 ("" (EXPAND "partial_order?") (("" (SPLIT 1) (("1" (EXPAND "preorder?") (("1" (SPLIT 1) (("1" (EXPAND "reflexive?") (("1" (SKEEP) (("1" (GROUND) (("1" (EXPAND "le") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "transitive?") (("2" (SKEEP) (("2" (EXPAND "le") (("2" (SKEEP) (("2" (INST?) (("2" (INST?) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "antisymmetric?") (("2" (SKEEP) (("2" (EXPAND "le") (("2" (DECOMPOSE-EQUALITY 1) (("2" (DECOMPOSE-EQUALITY 1) (("2" (INST?) (("2" (INST?) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|le| CONST-DECL "bool" |measures| NIL) (|reflexive?| CONST-DECL "bool" |relations| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|transitive?| CONST-DECL "bool" |relations| NIL) (|preorder?| CONST-DECL "bool" |orders| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|antisymmetric?| CONST-DECL "bool" |relations| NIL) (|partial_order?| CONST-DECL "bool" |orders| NIL)) NIL)) (|matrices_order| 0 (|matrices_order-2| |nil| 3653731328 ("" (EXPAND "<=") (("" (USE "matrices_fun_order") (("" (EXPAND "partial_order?") (("" (EXPAND "preorder?") (("" (FLATTEN) (("" (SPLIT 1) (("1" (EXPAND "reflexive?") (("1" (SKEEP) (("1" (INST?) NIL NIL)) NIL)) NIL) ("2" (EXPAND "transitive?") (("2" (SKEEP) (("2" (INST? -4 :WHERE 1) (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "antisymmetric?") (("3" (SKEEP) (("3" (INST?) (("3" (ASSERT) (("3" (HIDE-ALL-BUT (-5 1)) (("3" (TYPEPRED "form_matfun(x)") (("3" (EXPAND "eq") (("3" (EXPAND "get") (("3" (TYPEPRED "form_matfun(y)") (("3" (EXPAND "eq") (("3" (EXPAND "get") (("3" (USE "nth_extensionality[listn[Sign3](N)]") (("3" (ASSERT) (("3" (HIDE 2) (("3" (SKOLEM 1 "i") (("3" (USE "nth_extensionality[Sign3]") (("3" (ASSERT) (("3" (SKOLEM 1 "j") (("3" (INST?) (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|matrices_fun_order| FORMULA-DECL NIL |measures| NIL) (|preorder?| CONST-DECL "bool" |orders| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|eq| CONST-DECL "bool" |measures| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|reflexive?| CONST-DECL "bool" |relations| NIL) (|transitive?| CONST-DECL "bool" |relations| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|get| CONST-DECL "Sign3" |measures| NIL) (|nth_extensionality| FORMULA-DECL NIL |more_list_props| |structures|) (|nth| DEF-DECL "T" |list_props| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|antisymmetric?| CONST-DECL "bool" |relations| NIL) (|partial_order?| CONST-DECL "bool" |orders| NIL) (<= CONST-DECL "bool" |measures| NIL)) NIL) (|matrices_order-1| |nil| 3629651071 ("" (EXPAND "<=") (("" (USE "matrices_fun_order") (("" (EXPAND "partial_order?") (("" (EXPAND "preorder?") (("" (FLATTEN) (("" (SPLIT 1) (("1" (EXPAND "reflexive?") (("1" (SKEEP) (("1" (INST?) NIL NIL)) NIL)) NIL) ("2" (EXPAND "transitive?") (("2" (SKEEP) (("2" (INST? -4 :WHERE 1) (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "antisymmetric?") (("3" (SKEEP) (("3" (INST?) (("3" (ASSERT) (("3" (HIDE-ALL-BUT (-5 1)) (("3" (TYPEPRED "form_matfun(x)") (("3" (EXPAND "eq") (("3" (EXPAND "get") (("3" (TYPEPRED "form_matfun(y)") (("3" (EXPAND "eq") (("3" (EXPAND "get") (("3" (USE "nth_extensionality_1[listn[Sign3](N)]") (("3" (ASSERT) (("3" (HIDE 2) (("3" (SKOLEM 1 "i") (("3" (USE "nth_extensionality_1[Sign3]") (("3" (ASSERT) (("3" (SKOLEM 1 "j") (("3" (INST?) (("3" (INST?) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|mult_fun_left_preserves_order| 0 (|mult_fun_left_preserves_order-1| |nil| 3653471697 ("" (SKEEP) (("" (EXPAND "le") (("" (SKEEP) (("" (EXPAND "mult") (("" (INST -1 "_" "j") (("" (CASE "FORALL (k:below(N)): Plus3(f(i)(k),f1(k)(j))<= Plus3(f(i)(k),f2(k)(j))") (("1" (TYPEPRED "max(LAMBDA (k: below(N)): Plus3(f(i)(k) , f1(k)(j))) ") (("1" (SKEEP -3) (("1" (REPLACES -3 :DIR RL) (("1" (HIDE -1) (("1" (HIDE -1) (("1" (INST -1 "j_1") (("1" (TYPEPRED "max(LAMBDA (k: below(N)): Plus3(f(i)(k) , f2(k)(j))) ") (("1" (HIDE -1) (("1" (INST -1 "j_1") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKEEP) (("2" (INST -1 "k") (("2" (GROUND) (("2" (EXPAND "Plus3" 1 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "Plus3") (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (EXPAND "Plus3") (("1" (LIFT-IF 1) (("1" (SPLIT) (("1" (FLATTEN) (("1" (GROUND) (("1" (REPLACES -1) (("1" (TYPEPRED "f1(k)(j)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES -1) (("2" (TYPEPRED "f2(k)(j)") (("2" (GROUND) (("2" (REPLACES -1) (("2" (EXPAND "Plus3") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) (("2" (TYPEPRED "f(i)(k)") (("2" (GROUND) (("2" (TYPEPRED "f1(k)(j)") (("2" (GROUND) (("2" (REPLACES -1) (("2" (REPLACES -1) (("2" (EXPAND "Plus3") (("2" (LIFT-IF) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|le| CONST-DECL "bool" |measures| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|Plus3| CONST-DECL "Sign3" |measures| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (<= CONST-DECL "bool" |reals| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|max| CONST-DECL "{t: Sign3 | (FORALL i: f(i) <= t) AND (EXISTS j: f(j) = t)}" |measures| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) NIL)) (|mult_left_preserves_order| 0 (|mult_left_preserves_order-2| |nil| 3631282752 ("" (SKEEP) (("" (EXPAND "*") (("" (EXPAND "<=") (("" (USE "fun_matrix_idemp") (("" (REPLACE -1 :HIDE? T) (("" (USE "fun_matrix_idemp") (("" (REPLACE -1 :HIDE? T) (("" (USE "mult_fun_left_preserves_order") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((* CONST-DECL "Measure_Matrix" |measures| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|eq| CONST-DECL "bool" |measures| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|fun_matrix_idemp| FORMULA-DECL NIL |measures| NIL) (|mult_fun_left_preserves_order| FORMULA-DECL NIL |measures| NIL) (<= CONST-DECL "bool" |measures| NIL)) NIL) (|mult_left_preserves_order-1| |nil| 3630950036 ("" (SKEEP) (("" (EXPAND "<=") (("" (SKEEP) (("" (EXPAND "*") (("" (INST -1 "_" "j") (("" (CASE "FORALL (k:below(N)): n(i)(k)+m1(k)(j)<= n(i)(k)+m2(k)(j)") (("1" (TYPEPRED "max(LAMBDA (k: below(N)): (n(i)(k) + m1(k)(j))) ") (("1" (SKEEP -3) (("1" (REPLACES -3 :DIR RL) (("1" (HIDE -1) (("1" (HIDE -1) (("1" (INST -1 "jj") (("1" (TYPEPRED "max(LAMBDA (k: below(N)): (n(i)(k) + m2(k)(j))) ") (("1" (HIDE -1) (("1" (INST -1 "jj") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKEEP) (("2" (INST -1 "k") (("2" (GROUND) (("2" (EXPAND "+ " 1 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "+ ") (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (EXPAND "+ ") (("1" (LIFT-IF 1) (("1" (SPLIT) (("1" (FLATTEN) (("1" (GROUND) (("1" (REPLACES -1) (("1" (TYPEPRED "m1(k)(j)") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES -1) (("2" (TYPEPRED "m2(k)(j)") (("2" (GROUND) (("2" (REPLACES -1) (("2" (GROUND) (("2" (EXPAND "+ ") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GROUND) (("2" (TYPEPRED "n(i)(k)") (("2" (GROUND) (("2" (TYPEPRED "m1(k)(j)") (("2" (GROUND) (("2" (REPLACES -1) (("2" (REPLACES -1) (("2" (EXPAND "+ ") (("2" (GROUND) (("2" (LIFT-IF) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|mult_fun_right_preserves_order| 0 (|mult_fun_right_preserves_order-1| |nil| 3653472078 ("" (SKEEP) (("" (EXPAND "le") (("" (SKEEP) (("" (EXPAND "mult") (("" (INST -1 "i" "_") (("" (CASE "FORALL (k:below(N)): Plus3(f1(i)(k),f(k)(j))<= Plus3(f2(i)(k),f(k)(j))") (("1" (TYPEPRED "max(LAMBDA (k: below(N)): Plus3(f1(i)(k) , f(k)(j))) ") (("1" (SKEEP -3) (("1" (REPLACES -3 :DIR RL) (("1" (HIDE -1) (("1" (HIDE -1) (("1" (INST -1 "j_1") (("1" (TYPEPRED "max(LAMBDA (k: below(N)): Plus3(f2(i)(k) , f(k)(j))) ") (("1" (HIDE -1) (("1" (INST -1 "j_1") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKEEP) (("2" (INST -1 "k") (("2" (GROUND) (("2" (EXPAND "Plus3" 1 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "Plus3") (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (TYPEPRED "f2(i)(k)") (("1" (GROUND) (("1" (REPLACES -1) (("1" (EXPAND "Plus3") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES -1) (("2" (EXPAND "Plus3") (("2" (LIFT-IF 1) (("2" (GROUND) (("2" (REPLACES -1) (("2" (TYPEPRED "f1(i)(k)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (TYPEPRED "f(k)(j)") (("2" (GROUND) (("2" (TYPEPRED "f1(i)(k)") (("2" (GROUND) (("2" (REPLACES -1) (("2" (REPLACES -1) (("2" (EXPAND "Plus3") (("2" (LIFT-IF) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|le| CONST-DECL "bool" |measures| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|Plus3| CONST-DECL "Sign3" |measures| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (<= CONST-DECL "bool" |reals| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|max| CONST-DECL "{t: Sign3 | (FORALL i: f(i) <= t) AND (EXISTS j: f(j) = t)}" |measures| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) NIL)) (|mult_right_preserves_order| 0 (|mult_right_preserves_order-2| |nil| 3631282838 ("" (SKEEP) (("" (EXPAND "*") (("" (EXPAND "<=") (("" (USE "fun_matrix_idemp") (("" (REPLACE -1 :HIDE? T) (("" (USE "fun_matrix_idemp") (("" (REPLACE -1 :HIDE? T) (("" (USE "mult_fun_right_preserves_order") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((* CONST-DECL "Measure_Matrix" |measures| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|eq| CONST-DECL "bool" |measures| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|fun_matrix_idemp| FORMULA-DECL NIL |measures| NIL) (|mult_fun_right_preserves_order| FORMULA-DECL NIL |measures| NIL) (<= CONST-DECL "bool" |measures| NIL)) NIL) (|mult_right_preserves_order-1| |nil| 3630952352 ("" (SKEEP) (("" (EXPAND "<=") (("" (SKEEP) (("" (EXPAND "*") (("" (INST -1 "i" "_") (("" (CASE "FORALL (k:below(N)): m1(i)(k)+n(k)(j)<= m2(i)(k)+n(k)(j)") (("1" (TYPEPRED "max(LAMBDA (k: below(N)): (m1(i)(k) + n(k)(j))) ") (("1" (SKEEP -3) (("1" (REPLACES -3 :DIR RL) (("1" (HIDE -1) (("1" (HIDE -1) (("1" (INST -1 "jj") (("1" (TYPEPRED "max(LAMBDA (k: below(N)): (m2(i)(k) + n(k)(j))) ") (("1" (HIDE -1) (("1" (INST -1 "jj") (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKEEP) (("2" (INST -1 "k") (("2" (GROUND) (("2" (EXPAND "+ " 1 1) (("2" (LIFT-IF 1) (("2" (SPLIT 1) (("1" (FLATTEN) (("1" (EXPAND "+ ") (("1" (GROUND) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (SPLIT 3) (("1" (FLATTEN) (("1" (SPLIT -1) (("1" (REPLACES -1) (("1" (TYPEPRED "m2(i)(k)") (("1" (GROUND) (("1" (REPLACES -1) (("1" (EXPAND "+ ") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES -1) (("2" (EXPAND "+ ") (("2" (LIFT-IF 1) (("2" (GROUND) (("2" (REPLACES -1) (("2" (TYPEPRED "m1(i)(k)") (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (TYPEPRED "n(k)(j)") (("2" (GROUND) (("2" (TYPEPRED "m1(i)(k)") (("2" (GROUND) (("2" (REPLACES -1) (("2" (REPLACES -1) (("2" (EXPAND "+ ") (("2" (GROUND) (("2" (LIFT-IF) (("2" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|id_fun_is_identity| 0 (|id_fun_is_identity-1| |nil| 3653468598 ("" (EXPAND "identity?") (("" (SKOSIMP) (("" (SPLIT) (("1" (DECOMPOSE-EQUALITY) (("1" (DECOMPOSE-EQUALITY) (("1" (EXPAND* "mult" "id_fun") (("1" (NAME-REPLACE "A" "LAMBDA (k: below(N)):
                    Plus3(x!1(x!2)(k) , IF k = x!3 THEN 0 ELSE -1 ENDIF)" :HIDE? NIL) (("1" (DECOMPOSE-EQUALITY) (("1" (TYPEPRED "max(A)") (("1" (HIDE -1) (("1" (CASE "max(A) = A(x!3)") (("1" (INST -4 "x!3") (("1" (EXPAND "Plus3" -4) (("1" (LIFT-IF) (("1" (GROUND) (("1" (TYPEPRED "x!1(x!2)(x!3)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOSIMP) (("2" (INST -1 "x!3") (("2" (CASE "j!1 = x!3") (("1" (ASSERT) NIL NIL) ("2" (INST -3 "j!1") (("2" (ASSERT) (("2" (EXPAND "Plus3" -3) (("2" (EXPAND "<=") (("2" (TYPEPRED "A(x!3)") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (DECOMPOSE-EQUALITY) (("2" (EXPAND* "mult" "id_fun") (("2" (NAME-REPLACE "A" "LAMBDA (k: below(N)):
                    Plus3(IF x!2 = k THEN 0 ELSE -1 ENDIF , x!1(k)(x!3))" :HIDE? NIL) (("2" (DECOMPOSE-EQUALITY) (("2" (TYPEPRED "max(A)") (("2" (HIDE -1) (("2" (CASE "max(A) = A(x!2)") (("1" (INST -4 "x!2") (("1" (EXPAND "Plus3" -4) (("1" (LIFT-IF) (("1" (GROUND) (("1" (TYPEPRED "x!1(x!2)(x!3)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOSIMP) (("2" (INST -1 "x!2") (("2" (CASE "j!1 = x!2") (("1" (ASSERT) NIL NIL) ("2" (INST -3 "j!1") (("2" (ASSERT) (("2" (EXPAND "Plus3" -3) (("2" (TYPEPRED "A(x!2)") (("2" (EXPAND "<=") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|id_fun| CONST-DECL "Sign3" |measures| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (<= CONST-DECL "bool" |reals| NIL) (|max| CONST-DECL "{t: Sign3 | (FORALL i: f(i) <= t) AND (EXISTS j: f(j) = t)}" |measures| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|Plus3| CONST-DECL "Sign3" |measures| NIL) (|identity?| CONST-DECL "bool" |operator_defs| NIL)) NIL)) (|id_is_identity| 0 (|id_is_identity-2| |nil| 3631282959 ("" (EXPAND "identity?") (("" (SKEEP) (("" (USE "id_fun_is_identity") (("" (EXPAND "identity?") (("" (INST -1 "form_matfun(x)") (("" (EXPAND "*") (("" (FLATTEN) (("" (EXPAND "id") (("" (USE "fun_matrix_idemp") (("" (REPLACE -1 :HIDE? T) (("" (REPLACE -1 :HIDE? T) (("" (REPLACE -1 :HIDE? T) (("" (USE "matrix_fun_idemp") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((* CONST-DECL "Measure_Matrix" |measures| NIL) (|id| CONST-DECL "Measure_Matrix" |measures| NIL) (|matrix_fun_idemp| FORMULA-DECL NIL |measures| NIL) (|id_fun| CONST-DECL "Sign3" |measures| NIL) (|fun_matrix_idemp| FORMULA-DECL NIL |measures| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|eq| CONST-DECL "bool" |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|id_fun_is_identity| FORMULA-DECL NIL |measures| NIL) (|identity?| CONST-DECL "bool" |operator_defs| NIL)) NIL) (|id_is_identity-1| |nil| 3562867672 ("" (EXPAND "identity?") (("" (SKOSIMP) (("" (SPLIT) (("1" (DECOMPOSE-EQUALITY) (("1" (DECOMPOSE-EQUALITY) (("1" (EXPAND* "*" "id") (("1" (NAME-REPLACE "A" "LAMBDA (k: below(N)):
            (x!1(x!2)(k) + IF k = x!3 THEN 0 ELSE -1 ENDIF)" :HIDE? NIL) (("1" (DECOMPOSE-EQUALITY) (("1" (TYPEPRED "max(A)") (("1" (HIDE -1) (("1" (CASE "max(A) = A(x!3)") (("1" (INST -4 "x!3") (("1" (EXPAND "+" -4) (("1" (LIFT-IF) (("1" (GROUND) (("1" (TYPEPRED "x!1(x!2)(x!3)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOSIMP) (("2" (INST -1 "x!3") (("2" (CASE "jj!1 = x!3") (("1" (ASSERT) NIL NIL) ("2" (INST -3 "jj!1") (("2" (ASSERT) (("2" (EXPAND "+" -3) (("2" (EXPAND "<=") (("2" (TYPEPRED "A(x!3)") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (DECOMPOSE-EQUALITY) (("2" (EXPAND* "*" "id") (("2" (NAME-REPLACE "A" "LAMBDA (k: below(N)):
            (IF x!2 = k THEN 0 ELSE -1 ENDIF + x!1(k)(x!3))" :HIDE? NIL) (("2" (DECOMPOSE-EQUALITY) (("2" (TYPEPRED "max(A)") (("1" (HIDE -1) (("1" (CASE "max(A) = A(x!2)") (("1" (INST -4 "x!2") (("1" (EXPAND "+" -4) (("1" (LIFT-IF) (("1" (GROUND) (("1" (TYPEPRED "x!1(x!2)(x!3)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (SKOSIMP) (("2" (INST -1 "x!2") (("2" (CASE "jj!1 = x!2") (("1" (ASSERT) NIL NIL) ("2" (INST -3 "jj!1") (("2" (ASSERT) (("2" (EXPAND "+" -3) (("2" (TYPEPRED "A(x!2)") (("2" (EXPAND "<=") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|max_add| 0 (|max_add-2| |nil| 3570287683 ("" (GRIND) (("1" (TYPEPRED "max(LAMBDA (i: below(N)): -1)") (("1" (ASSERT) NIL NIL)) NIL) ("2" (TYPEPRED "max_(N)(A!1)") (("2" (HIDE -1 -3 -4) (("2" (TYPEPRED "max_(N)(LAMBDA (i: below(N)): IF A!1(i) = -1 THEN -1 ELSE 1 ENDIF)") (("2" (HIDE -1) (("2" (SKEEP -2) (("2" (INST -3 "j") (("2" (TYPEPRED "A!1(j)") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE 1) (("3" (TYPEPRED "max_(N)(A!1)") (("3" (HIDE -1) (("3" (SKEEP -2) (("3" (TYPEPRED "max(LAMBDA (i: below(N)): IF A!1(i) = -1 THEN -1 ELSE 1 ENDIF)") (("3" (INST -2 "j") (("3" (ASSERT) (("3" (NAME-REPLACE "AA" "max(LAMBDA (i: below(N)): IF A!1(i) = -1 THEN -1 ELSE 1 ENDIF)") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (TYPEPRED "max_(N)(LAMBDA (i: below(N)):
                     IF A!1(i) = -1 THEN -1 ELSIF A!1(i) = 1 THEN 1 ELSE 0 ENDIF)") (("4" (NAME-REPLACE "AA" "max_(N)(LAMBDA (i: below(N)):
                     IF A!1(i) = -1 THEN -1 ELSIF A!1(i) = 1 THEN 1 ELSE 0 ENDIF)") (("4" (TYPEPRED "max_(N)(A!1)") (("4" (SKEEP -6) (("4" (HIDE -1 -3 -4 -5) (("4" (INST -1 "j") (("4" (ASSERT) (("4" (TYPEPRED "A!1(j)") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (HIDE 1 2) (("5" (TYPEPRED "max_(N)(A!1)") (("5" (TYPEPRED "max_(N)(LAMBDA (i: below(N)):
                     IF A!1(i) = -1 THEN -1 ELSIF A!1(i) = 1 THEN 1 ELSE 0 ENDIF)") (("5" (NAME-REPLACE "AA" "max_(N)(LAMBDA (i: below(N)):
                     IF A!1(i) = -1 THEN -1 ELSIF A!1(i) = 1 THEN 1 ELSE 0 ENDIF)") (("5" (HIDE -4 -3 -5) (("5" (SKEEP -3) (("5" (INST -2 "j") (("5" (ASSERT) (("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (HIDE 1 2) (("6" (TYPEPRED "max_(N)(A!1)") (("6" (ASSERT) (("6" (HIDE 1 2) (("6" (TYPEPRED "max_(N)(LAMBDA (i: below(N)):
                     IF A!1(i) = -1 THEN -1 ELSIF A!1(i) = 1 THEN 1 ELSE 0 ENDIF)") (("6" (NAME-REPLACE "AA" "max_(N)(LAMBDA (i: below(N)):
                     IF A!1(i) = -1 THEN -1 ELSIF A!1(i) = 1 THEN 1 ELSE 0 ENDIF)") (("6" (SKEEP -6) (("6" (INST -2 "j") (("6" (ASSERT) (("6" (ASSERT) (("6" (SKEEP -3) (("6" (LIFT-IF) (("6" (ASSERT) (("6" (PROP) (("6" (INST -5 "j!1") (("6" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|exp2| DEF-DECL "posnat" |exp2| NIL) (|uint8| TYPE-EQ-DECL NIL |integertypes| NIL) (|max_| DEF-DECL "{t: Sign3 |
   (FORALL (i: below(n)): f(i) <= t) AND (EXISTS (j: below(n)): f(j) = t)}" |measures| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (<= CONST-DECL "bool" |reals| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|Plus3| CONST-DECL "Sign3" |measures| NIL) (|max| CONST-DECL "{t: Sign3 | (FORALL i: f(i) <= t) AND (EXISTS j: f(j) = t)}" |measures| NIL)) NIL) (|max_add-1| |nil| 3570287581 ("" (POSTPONE) NIL NIL) NIL SHOSTAK)) (|measure_matrix_fun_assoc| 0 (|measure_matrix_fun_assoc-1| |nil| 3653472448 ("" (EXPAND "associative?") (("" (SKEEP) (("" (DECOMPOSE-EQUALITY) (("" (DECOMPOSE-EQUALITY) (("" (EXPAND "mult" 1 (1 3)) (("" (TYPEPRED "max(LAMBDA (k: below(N)): (Plus3((mult(x,y))(x!1)(k) , z(k)(x!2))))") (("" (NAME-REPLACE "XY_Z" "max(LAMBDA (k: below(N)): (Plus3((mult(x,y))(x!1)(k) , z(k)(x!2))))") (("" (TYPEPRED " max(LAMBDA (k: below(N)): (Plus3(x(x!1)(k) , mult(y,z)(k)(x!2))))") (("" (NAME-REPLACE "X_YZ" "max(LAMBDA (k: below(N)): (Plus3(x(x!1)(k) , mult(y,z)(k)(x!2))))") (("" (SKOLEM -3 "Kx_yz") (("" (SKOLEM -6 "Kxy_z") (("" (HIDE -1 -4) (("" (EXPAND "mult" (-2 -4)) (("" (LEMMA "max_add") (("" (INST-CP -1 "LAMBDA (k: below(N)): (Plus3(x(x!1)(k) , y(k)(Kxy_z)))" "z(Kxy_z)(x!2)") (("" (INST -1 "LAMBDA (k: below(N)): (Plus3(y(Kx_yz)(k) , z(k)(x!2)))" "x(x!1)(Kx_yz)") (("" (REPLACE -2 -6) (("" (CASE-REPLACE "Plus3(x(x!1)(Kx_yz) ,
                  max(LAMBDA (k: below(N)): Plus3(y(Kx_yz)(k) , z(k)(x!2)))) = max(LAMBDA (i: below(N)): Plus3(Plus3(y(Kx_yz)(i) , z(i)(x!2)) , x(x!1)(Kx_yz)))") (("1" (HIDE -1 -2 -3) (("1" (TYPEPRED "max(LAMBDA (i: below(N)): Plus3(Plus3(y(Kx_yz)(i) , z(i)(x!2)) , x(x!1)(Kx_yz)))") (("1" (NAME-REPLACE "YZ" "max(LAMBDA (i: below(N)): Plus3(Plus3(y(Kx_yz)(i) , z(i)(x!2)) , x(x!1)(Kx_yz)))") (("1" (TYPEPRED "max(LAMBDA (i: below(N)): Plus3(Plus3(x(x!1)(i) , y(i)(Kxy_z)) , z(Kxy_z)(x!2)))") (("1" (NAME-REPLACE "XY" "max(LAMBDA (i: below(N)): Plus3(Plus3(x(x!1)(i) , y(i)(Kxy_z)) , z(Kxy_z)(x!2)))") (("1" (SKOLEM -3 "kxy") (("1" (SKOLEM -6 "kyz") (("1" (GROUND) (("1" (REPLACES -1) (("1" (REPLACES -1) (("1" (EXPAND "mult" -5) (("1" (INST -5 "kxy") (("1" (LEMMA "max_add") (("1" (INST -1 "LAMBDA (k: below(N)): Plus3(y(kxy)(k) , z(k)(x!2))" "x(x!1)(kxy)") (("1" (CASE-REPLACE "Plus3(x(x!1)(kxy) , max(LAMBDA (k: below(N)): Plus3(y(kxy)(k) , z(k)(x!2)))) = max(LAMBDA (i: below(N)): Plus3(Plus3(y(kxy)(i) , z(i)(x!2)) , x(x!1)(kxy)))") (("1" (HIDE -1 -2) (("1" (TYPEPRED "max(LAMBDA (i: below(N)): Plus3(Plus3(y(kxy)(i) , z(i)(x!2)) , x(x!1)(kxy)))") (("1" (ASSERT) (("1" (HIDE -3) (("1" (INST -2 "Kxy_z") (("1" (HIDE-ALL-BUT (-1 -2 -4)) (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES -1) (("2" (REPLACES -1) (("2" (EXPAND "mult" -5) (("2" (INST -5 "kxy") (("2" (LEMMA "max_add") (("2" (INST -1 "LAMBDA (k: below(N)): Plus3(y(kxy)(k) , z(k)(x!2))" "x(x!1)(kxy)") (("2" (CASE-REPLACE "Plus3(x(x!1)(kxy) , max(LAMBDA (k: below(N)): Plus3(y(kxy)(k) , z(k)(x!2)))) = max(LAMBDA (i: below(N)): Plus3(Plus3(y(kxy)(i) , z(i)(x!2)) , x(x!1)(kxy)))") (("1" (HIDE -1 -2) (("1" (TYPEPRED "max(LAMBDA (i: below(N)): Plus3(Plus3(y(kxy)(i) , z(i)(x!2)) , x(x!1)(kxy)))") (("1" (ASSERT) (("1" (HIDE -3) (("1" (INST -2 "Kxy_z") (("1" (HIDE-ALL-BUT (-1 -2 -4)) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES -1) (("3" (REPLACES -1) (("3" (EXPAND "mult" -7) (("3" (INST -7 "kyz") (("3" (LEMMA "max_add") (("3" (INST -1 "LAMBDA (k: below(N)): Plus3(x(x!1)(k) , y(k)(kyz))" "z(kyz)(x!2)") (("3" (REPLACES -1) (("3" (TYPEPRED "max(LAMBDA (i: below(N)): Plus3(Plus3(x(x!1)(i) , y(i)(kyz)) , z(kyz)(x!2)))") (("3" (ASSERT) (("3" (HIDE -3) (("3" (INST -2 "Kx_yz") (("3" (HIDE-ALL-BUT (-1 -2 -6)) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACES -1) (("4" (REPLACES -1) (("4" (EXPAND "mult" -7) (("4" (INST -7 "kyz") (("4" (LEMMA "max_add") (("4" (INST -1 "LAMBDA (k: below(N)): Plus3(x(x!1)(k) , y(k)(kyz))" "z(kyz)(x!2)") (("4" (REPLACES -1) (("4" (TYPEPRED "max(LAMBDA (i: below(N)): Plus3(Plus3(x(x!1)(i) , y(i)(kyz)) , z(kyz)(x!2)))") (("4" (ASSERT) (("4" (HIDE -3) (("4" (INST -2 "Kx_yz") (("4" (HIDE-ALL-BUT (-1 -2 -6)) (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (REPLACES -1) (("5" (REPLACES -1) (("5" (EXPAND "mult" -7) (("5" (INST -7 "kyz") (("5" (LEMMA "max_add") (("5" (INST -1 "LAMBDA (k: below(N)): Plus3(x(x!1)(k) , y(k)(kyz))" "z(kyz)(x!2)") (("5" (REPLACES -1) (("5" (TYPEPRED "max(LAMBDA (i: below(N)): Plus3(Plus3(x(x!1)(i) , y(i)(kyz)) , z(kyz)(x!2)))") (("5" (ASSERT) (("5" (HIDE -3) (("5" (INST -2 "Kx_yz") (("5" (HIDE-ALL-BUT (-1 -2 -6)) (("5" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (REPLACES -1) (("6" (REPLACE -1 :HIDE? T) (("6" (EXPAND "mult" -5) (("6" (INST -5 "kxy") (("6" (LEMMA "max_add") (("6" (INST -1 "LAMBDA (k: below(N)): Plus3(y(kxy)(k) , z(k)(x!2))" "x(x!1)(kxy)") (("6" (CASE-REPLACE "Plus3(x(x!1)(kxy) , max(LAMBDA (k: below(N)): Plus3(y(kxy)(k) , z(k)(x!2)))) = max(LAMBDA (i: below(N)): Plus3(Plus3(y(kxy)(i) , z(i)(x!2)) , x(x!1)(kxy)))") (("1" (HIDE -1 -2) (("1" (TYPEPRED "max(LAMBDA (i: below(N)): Plus3(Plus3(y(kxy)(i) , z(i)(x!2)) , x(x!1)(kxy)))") (("1" (ASSERT) (("1" (HIDE -3) (("1" (INST -2 "Kxy_z") (("1" (HIDE-ALL-BUT (-1 -2 -4)) (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|Plus3| CONST-DECL "Sign3" |measures| NIL) (|max| CONST-DECL "{t: Sign3 | (FORALL i: f(i) <= t) AND (EXISTS j: f(j) = t)}" |measures| NIL) (<= CONST-DECL "bool" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|max_add| FORMULA-DECL NIL |measures| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|associative?| CONST-DECL "bool" |operator_defs| NIL)) NIL)) (|measure_matrix_assoc| 0 (|measure_matrix_assoc-3| |nil| 3631280026 ("" (EXPAND "*") (("" (EXPAND "associative?") (("" (SKEEP) (("" (USE "measure_matrix_fun_assoc") (("" (EXPAND "associative?") (("" (USE "fun_matrix_idemp") (("" (REPLACE -1 :HIDE? T) (("" (USE "fun_matrix_idemp") (("" (REPLACE -1 :HIDE? T) (("" (INST?) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|associative?| CONST-DECL "bool" |operator_defs| NIL) (|measure_matrix_fun_assoc| FORMULA-DECL NIL |measures| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|eq| CONST-DECL "bool" |measures| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|fun_matrix_idemp| FORMULA-DECL NIL |measures| NIL) (* CONST-DECL "Measure_Matrix" |measures| NIL)) NIL) (|measure_matrix_assoc-2| |nil| 3572774815 ("" (EXPAND "associative?") (("" (SKEEP) (("" (DECOMPOSE-EQUALITY) (("" (DECOMPOSE-EQUALITY) (("" (EXPAND "*" 1 (2 3)) (("" (TYPEPRED "max(LAMBDA (k: below(N)): ((x * y)(x!1)(k) + z(k)(x!2)))") (("" (NAME-REPLACE "XY_Z" "max(LAMBDA (k: below(N)): ((x * y)(x!1)(k) + z(k)(x!2)))") (("" (TYPEPRED " max(LAMBDA (k: below(N)): (x(x!1)(k) + (y * z)(k)(x!2)))") (("" (NAME-REPLACE "X_YZ" "max(LAMBDA (k: below(N)): (x(x!1)(k) + (y * z)(k)(x!2)))") (("" (SKOLEM -3 "Kx_yz") (("" (SKOLEM -6 "Kxy_z") (("" (HIDE -1 -4) (("" (EXPAND "*" (-2 -4)) (("" (LEMMA "max_add") (("" (INST-CP -1 "LAMBDA (k: below(N)): (x(x!1)(k) + y(k)(Kxy_z))" "z(Kxy_z)(x!2)") (("" (INST -1 "LAMBDA (k: below(N)): (y(Kx_yz)(k) + z(k)(x!2))" "x(x!1)(Kx_yz)") (("" (REPLACE -2 -6) (("" (CASE-REPLACE "(x(x!1)(Kx_yz) +
          max(LAMBDA (k: below(N)): (y(Kx_yz)(k) + z(k)(x!2)))) = max(LAMBDA (i: below(N)): (y(Kx_yz)(i) + z(i)(x!2)) + x(x!1)(Kx_yz))") (("1" (HIDE -1 -2 -3) (("1" (TYPEPRED "max(LAMBDA (i: below(N)): (y(Kx_yz)(i) + z(i)(x!2)) + x(x!1)(Kx_yz))") (("1" (NAME-REPLACE "YZ" "max(LAMBDA (i: below(N)): (y(Kx_yz)(i) + z(i)(x!2)) + x(x!1)(Kx_yz))") (("1" (TYPEPRED "max(LAMBDA (i: below(N)): (x(x!1)(i) + y(i)(Kxy_z)) + z(Kxy_z)(x!2))") (("1" (NAME-REPLACE "XY" "max(LAMBDA (i: below(N)): (x(x!1)(i) + y(i)(Kxy_z)) + z(Kxy_z)(x!2))") (("1" (SKOLEM -3 "kxy") (("1" (SKOLEM -6 "kyz") (("1" (GROUND) (("1" (REPLACES -1) (("1" (REPLACES -1) (("1" (EXPAND "*" -5) (("1" (INST -5 "kxy") (("1" (LEMMA "max_add") (("1" (INST -1 "LAMBDA (k: below(N)): (y(kxy)(k) + z(k)(x!2))" "x(x!1)(kxy)") (("1" (CASE-REPLACE "x(x!1)(kxy) + max(LAMBDA (k: below(N)): (y(kxy)(k) + z(k)(x!2))) = max(LAMBDA (i: below(N)): (y(kxy)(i) + z(i)(x!2)) + x(x!1)(kxy))") (("1" (HIDE -1 -2) (("1" (TYPEPRED "max(LAMBDA (i: below(N)): (y(kxy)(i) + z(i)(x!2)) + x(x!1)(kxy))") (("1" (ASSERT) (("1" (HIDE -3) (("1" (INST -2 "Kxy_z") (("1" (HIDE-ALL-BUT (-1 -2 -4)) (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES -1) (("2" (REPLACES -1) (("2" (EXPAND "*" -5) (("2" (INST -5 "kxy") (("2" (LEMMA "max_add") (("2" (INST -1 "LAMBDA (k: below(N)): (y(kxy)(k) + z(k)(x!2))" "x(x!1)(kxy)") (("2" (CASE-REPLACE "(x(x!1)(kxy) + max(LAMBDA (k: below(N)): (y(kxy)(k) + z(k)(x!2)))) = max(LAMBDA (i: below(N)): (y(kxy)(i) + z(i)(x!2)) + x(x!1)(kxy))") (("1" (HIDE -1 -2) (("1" (TYPEPRED "max(LAMBDA (i: below(N)): (y(kxy)(i) + z(i)(x!2)) + x(x!1)(kxy))") (("1" (ASSERT) (("1" (HIDE -3) (("1" (INST -2 "Kxy_z") (("1" (HIDE-ALL-BUT (-1 -2 -4)) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACES -1) (("3" (REPLACES -1) (("3" (EXPAND "*" -7) (("3" (INST -7 "kyz") (("3" (LEMMA "max_add") (("3" (INST -1 "LAMBDA (k: below(N)): (x(x!1)(k) + y(k)(kyz))" "z(kyz)(x!2)") (("3" (REPLACES -1) (("3" (TYPEPRED "max(LAMBDA (i: below(N)): (x(x!1)(i) + y(i)(kyz)) + z(kyz)(x!2))") (("3" (ASSERT) (("3" (HIDE -3) (("3" (INST -2 "Kx_yz") (("3" (HIDE-ALL-BUT (-1 -2 -6)) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (REPLACES -1) (("4" (REPLACES -1) (("4" (EXPAND "*" -7) (("4" (INST -7 "kyz") (("4" (LEMMA "max_add") (("4" (INST -1 "LAMBDA (k: below(N)): (x(x!1)(k) + y(k)(kyz))" "z(kyz)(x!2)") (("4" (REPLACES -1) (("4" (TYPEPRED "max(LAMBDA (i: below(N)): (x(x!1)(i) + y(i)(kyz)) + z(kyz)(x!2))") (("4" (ASSERT) (("4" (HIDE -3) (("4" (INST -2 "Kx_yz") (("4" (HIDE-ALL-BUT (-1 -2 -6)) (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (REPLACES -1) (("5" (REPLACES -1) (("5" (EXPAND "*" -7) (("5" (INST -7 "kyz") (("5" (LEMMA "max_add") (("5" (INST -1 "LAMBDA (k: below(N)): (x(x!1)(k) + y(k)(kyz))" "z(kyz)(x!2)") (("5" (REPLACES -1) (("5" (TYPEPRED "max(LAMBDA (i: below(N)): (x(x!1)(i) + y(i)(kyz)) + z(kyz)(x!2))") (("5" (ASSERT) (("5" (HIDE -3) (("5" (INST -2 "Kx_yz") (("5" (HIDE-ALL-BUT (-1 -2 -6)) (("5" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("6" (REPLACES -1) (("6" (REPLACES -1) (("6" (EXPAND "*" -5) (("6" (INST -5 "kxy") (("6" (LEMMA "max_add") (("6" (INST -1 "LAMBDA (k: below(N)): (y(kxy)(k) + z(k)(x!2))" "x(x!1)(kxy)") (("6" (CASE-REPLACE "x(x!1)(kxy) + max(LAMBDA (k: below(N)): (y(kxy)(k) + z(k)(x!2))) = max(LAMBDA (i: below(N)): (y(kxy)(i) + z(i)(x!2)) + x(x!1)(kxy))") (("1" (HIDE -1 -2) (("1" (TYPEPRED "max(LAMBDA (i: below(N)): (y(kxy)(i) + z(i)(x!2)) + x(x!1)(kxy))") (("1" (ASSERT) (("1" (HIDE -3) (("1" (INST -2 "Kxy_z") (("1" (HIDE-ALL-BUT (-1 -2 -4)) (("1" (REPLACES -1) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 1)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL) (|measure_matrix_assoc-1| |nil| 3572772046 ("" (EXPAND "associative?") (("" (SKEEP) (("" (DECOMPOSE-EQUALITY) (("" (DECOMPOSE-EQUALITY) (("" (EXPAND "*" 1 (2 3)) (("" (TYPEPRED "max(LAMBDA (k: below(N)): ((x * y)(x!1)(k) + z(k)(x!2)))") (("" (NAME-REPLACE "XY_Z" "max(LAMBDA (k: below(N)): ((x * y)(x!1)(k) + z(k)(x!2)))") (("" (TYPEPRED " max(LAMBDA (k: below(N)): (x(x!1)(k) + (y * z)(k)(x!2)))") (("" (NAME-REPLACE "X_YZ" "max(LAMBDA (k: below(N)): (x(x!1)(k) + (y * z)(k)(x!2)))") (("" (SKOLEM -3 "Kx_yz") (("" (SKOLEM -6 "Kxy_z") (("" (HIDE -1 -4) (("" (EXPAND "*" (-2 -4)) (("" (LEMMA "max_add") (("" (INST-CP -1 "LAMBDA (k: below(N)): (x(x!1)(k) + y(k)(Kxy_z))" "z(Kxy_z)(x!2)") (("" (INST -1 "LAMBDA (k: below(N)): (y(Kx_yz)(k) + z(k)(x!2))" "x(x!1)(Kx_yz)") (("" (REPLACE -2 -6) (("" (CASE-REPLACE "(x(x!1)(Kx_yz) +
          max(LAMBDA (k: below(N)): (y(Kx_yz)(k) + z(k)(x!2)))) = max(LAMBDA (i: below(N)): (y(Kx_yz)(i) + z(i)(x!2)) + x(x!1)(Kx_yz))") (("1" (HIDE -1 -2 -3) (("1" (TYPEPRED "max(LAMBDA (i: below(N)): (y(Kx_yz)(i) + z(i)(x!2)) + x(x!1)(Kx_yz))") (("1" (NAME-REPLACE "YZ" "max(LAMBDA (i: below(N)): (y(Kx_yz)(i) + z(i)(x!2)) + x(x!1)(Kx_yz))") (("1" (TYPEPRED "max(LAMBDA (i: below(N)): (x(x!1)(i) + y(i)(Kxy_z)) + z(Kxy_z)(x!2))") (("1" (NAME-REPLACE "XY" "max(LAMBDA (i: below(N)): (x(x!1)(i) + y(i)(Kxy_z)) + z(Kxy_z)(x!2))") (("1" (SKOLEM -3 "kxy") (("1" (SKOLEM -6 "kyz") (("1" (REPLACES -8) (("1" (REPLACES -9) (("1" (EXPAND "*") (("1" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|defined_pos?_def| 0 (|defined_pos?_def-1| |nil| 3653837506 ("" (SKEEP) (("" (EXPAND "defined_pos?") (("" (EXPAND "defined_pos_fun?") (("" (TYPEPRED "form_matfun(m)") (("" (EXPAND "eq") (("" (ASSERT) (("" (INST?) (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|defined_pos?| CONST-DECL "bool" |measures| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (< CONST-DECL "bool" |reals| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|eq| CONST-DECL "bool" |measures| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|defined_pos_fun?| CONST-DECL "bool" |measures| NIL)) SHOSTAK)) (|positive_mult_fun| 0 (|positive_mult_fun-2| |nil| 3653482501 ("" (SKEEP) (("" (PROP) (("1" (EXPAND "positive_fun?") (("1" (SKEEP) (("1" (EXPAND "mult") (("1" (TYPEPRED "max(LAMBDA (k: below(N)): Plus3(f1(j)(k) , f2(k)(j)))") (("1" (HIDE -1 -2) (("1" (SKEEP) (("1" (REPLACES -2) (("1" (INST 1 "j" "j_1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (EXPAND "positive_fun?") (("2" (EXPAND "mult") (("2" (INST 1 "j") (("2" (TYPEPRED "max(LAMBDA (k: below(N)): Plus3(f1(j)(k) , f2(k)(j)))") (("2" (HIDE -3) (("2" (INST -2 "k") (("2" (REPLACES -3) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (<= CONST-DECL "bool" |reals| NIL) (|max| CONST-DECL "{t: Sign3 | (FORALL i: f(i) <= t) AND (EXISTS j: f(j) = t)}" |measures| NIL) (|Plus3| CONST-DECL "Sign3" |measures| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|positive_fun?| CONST-DECL "bool" |measures| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL) (|positive_mult_fun-1| |nil| 3653474771 ("" (SKEEP) (("" (PROP) (("1" (EXPAND "positive?") (("1" (SKEEP) (("1" (EXPAND "mult") (("1" (TYPEPRED "max(LAMBDA (k: below(N)): Plus3(f1(j)(k) , f2(k)(j)))") (("1" (HIDE -1 -2) (("1" (SKEEP) (("1" (REPLACES -2) (("1" (INST 1 "j" "jj") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (EXPAND "positive?") (("2" (EXPAND "mult") (("2" (INST 1 "j") (("2" (TYPEPRED "max(LAMBDA (k: below(N)): Plus3(f1(j)(k) , f2(k)(j)))") (("2" (HIDE -3) (("2" (INST -2 "k") (("2" (REPLACES -3) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL)) (|positive_multiplication| 0 (|positive_multiplication-3| |nil| 3631283018 ("" (SKEEP) (("" (EXPAND "*") (("" (USE "positive_mult_fun") (("" (EXPAND "positive?" 1) (("" (USE "fun_matrix_idemp") (("" (REPLACE -1 :HIDE? T) (("" (ASSERT) (("" (GROUND) (("1" (HIDE-ALL-BUT (-3 1)) (("1" (SKEEP) (("1" (TYPEPRED "form_matfun(m1)") (("1" (EXPAND "eq") (("1" (INST? -1) (("1" (INST? 1) (("1" (REPLACE -1 :HIDE? T) (("1" (TYPEPRED "form_matfun(m2)") (("1" (EXPAND "eq") (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 2)) (("2" (SKEEP) (("2" (TYPEPRED "form_matfun(m1)") (("2" (EXPAND "eq") (("2" (INST? -1) (("2" (INST? 1) (("2" (REPLACE -1 :HIDE? T) (("2" (TYPEPRED "form_matfun(m2)") (("2" (EXPAND "eq") (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((* CONST-DECL "Measure_Matrix" |measures| NIL) (|positive?| CONST-DECL "bool" |measures| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|fun_matrix_idemp| FORMULA-DECL NIL |measures| NIL) (|positive_mult_fun| FORMULA-DECL NIL |measures| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|eq| CONST-DECL "bool" |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) NIL) (|positive_multiplication-2| |nil| 3575901626 ("" (SKEEP) (("" (PROP) (("1" (EXPAND "positive?") (("1" (SKEEP) (("1" (EXPAND "*") (("1" (TYPEPRED "max(LAMBDA (k: below(N)): (m1(j)(k) + m2(k)(j)))") (("1" (HIDE -1 -2) (("1" (SKEEP) (("1" (REPLACES -2) (("1" (INST 1 "j" "jj") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (EXPAND "positive?") (("2" (EXPAND "*") (("2" (INST 1 "j") (("2" (TYPEPRED "max(LAMBDA (k: below(N)): (m1(j)(k) + m2(k)(j)))") (("2" (HIDE -3) (("2" (INST -2 "k") (("2" (REPLACES -3) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL) (|positive_multiplication-1| |nil| 3563705220 ("" (SKEEP) (("" (PROP) (("1" (EXPAND* "positive?" "positive?") (("1" (SKEEP -1) (("1" (EXPAND "*") (("1" (NAME-REPLACE "A" "LAMBDA (k: below(N)): (m1(j)(k) + m2(k)(j))" :HIDE? NIL) (("1" (TYPEPRED "max(A)") (("1" (ASSERT) (("1" (SKEEP -3) (("1" (INST 1 "j" "jj") (("1" (SPLIT) (("1" (FLATTEN) (("1" (REPLACE -4 -3 RL) (("1" (ASSERT) (("1" (REPLACE -4) (("1" (EXPAND "+" -3) (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -4 -3 RL) (("2" (ASSERT) (("2" (REPLACE -4) (("2" (EXPAND "+" -3) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (REPLACE -4 -3 RL) (("3" (ASSERT) (("3" (REPLACE -4) (("3" (EXPAND "+" -3) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND* "positive?" "positive?") (("2" (SKEEP -1) (("2" (INST 3 "j") (("2" (EXPAND "*") (("2" (NAME-REPLACE "A" "LAMBDA (k: below(N)): (m1(j)(k) + m2(k)(j))" :HIDE? NIL) (("2" (SPLIT) (("1" (TYPEPRED "max(A)") (("1" (ASSERT) (("1" (SPLIT) (("1" (HIDE -3) (("1" (INST -2 "k") (("1" (REPLACE -4 -2 RL) (("1" (ASSERT) (("1" (REPLACE -4) (("1" (EXPAND "+" -2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST -2 "k") (("2" (ASSERT) (("2" (REPLACE -5 -2 RL) (("2" (ASSERT) (("2" (REPLACE -5) (("2" (EXPAND "+" -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "max(A)") (("2" (ASSERT) (("2" (HIDE -3) (("2" (SPLIT) (("1" (INST -2 "k") (("1" (REPLACE -4 -2 RL) (("1" (ASSERT) (("1" (REPLACE -4) (("1" (EXPAND "+" -2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST -2 "k") (("2" (REPLACE -4 -2 RL) (("2" (ASSERT) (("2" (REPLACE -4) (("2" (EXPAND "+" -2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|positive_commute| 0 (|positive_commute-1| |nil| 3572298174 ("" (SKEEP) (("" (REWRITE "positive_multiplication") (("" (REWRITE "positive_multiplication") (("" (SKEEP) (("" (INST 1 "k" "j") (("" (REWRITE "add_commute") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|positive_multiplication| FORMULA-DECL NIL |measures| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|add_commute| FORMULA-DECL NIL |measures| NIL) (|get| CONST-DECL "Sign3" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL)) SHOSTAK)) (|positive_mult_fun_pos| 0 (|positive_mult_fun_pos-1| |nil| 3653475586 ("" (SKEEP) (("" (EXPAND "mult") (("" (NAME-REPLACE "M" "max(LAMBDA (k_1: below(N)): Plus3(f1(k)(k_1) , f2(k_1)(k)))") (("" (TYPEPRED "M") (("" (HIDE -3) (("" (INST -2 "k") (("" (EXPAND "Plus3") (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (NIL APPLICATION-JUDGEMENT "above(n)" |exp2| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|Plus3| CONST-DECL "Sign3" |measures| NIL) (|max| CONST-DECL "{t: Sign3 | (FORALL i: f(i) <= t) AND (EXISTS j: f(j) = t)}" |measures| NIL) (<= CONST-DECL "bool" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) NIL)) (|positive_mult_pos| 0 (|positive_mult_pos-1| |nil| 3579628915 ("" (SKEEP) (("" (EXPAND "*") (("" (USE "positive_mult_fun_pos") (("" (TYPEPRED "form_matrix(mult(form_matfun(m1), form_matfun(m2)))") (("" (HIDE -1 -2) (("" (EXPAND "eq") (("" (INST? -1) (("" (REPLACE -1 :HIDE? T) (("" (ASSERT) (("" (HIDE 2) (("" (EXPAND "form_matfun") (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((* CONST-DECL "Measure_Matrix" |measures| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|form_matrix| CONST-DECL "{m: Measure_Matrix | eq(m, f)}" |measures| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|positive_mult_fun_pos| FORMULA-DECL NIL |measures| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|eq| CONST-DECL "bool" |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK)) (|positive_sum_fun| 0 (|positive_sum_fun-1| |nil| 3653475979 ("" (SKEEP) (("" (EXPAND* "positive_fun?" "positive?") (("" (SKOSIMP) (("" (EXPAND "sum") (("" (EXPAND "Plus3") (("" (LIFT-IF) (("" (GROUND) (("1" (INST 3 "j!1") NIL NIL) ("2" (INST 4 "j!1") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|positive_fun?| CONST-DECL "bool" |measures| NIL) (|sum| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|Plus3| CONST-DECL "Sign3" |measures| NIL)) NIL)) (|positive_sum| 0 (|positive_sum-1| |nil| 3572272345 ("" (SKEEP) (("" (EXPAND "positive?") (("" (EXPAND "+ ") (("" (USE "fun_matrix_idemp") (("" (REPLACE -1 :HIDE? T) (("" (USE "positive_sum_fun") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|positive?| CONST-DECL "bool" |measures| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|sum| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|eq| CONST-DECL "bool" |measures| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|fun_matrix_idemp| FORMULA-DECL NIL |measures| NIL) (|positive_sum_fun| FORMULA-DECL NIL |measures| NIL) (+ CONST-DECL "Measure_Matrix" |measures| NIL)) SHOSTAK)) (|positive_sum_fun_positive_mult_fun| 0 (|positive_sum_fun_positive_mult_fun-2| |nil| 3653482680 ("" (SKEEP) (("" (REWRITE "positive_mult_fun") (("" (EXPAND "positive_fun?") (("" (SKEEP) (("" (EXPAND "sum" -1) (("" (INST 1 "j" "j") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|positive_mult_fun| FORMULA-DECL NIL |measures| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|sum| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|positive_fun?| CONST-DECL "bool" |measures| NIL)) NIL) (|positive_sum_fun_positive_mult_fun-1| |nil| 3653476141 ("" (SKEEP) (("" (REWRITE "positive_mult_fun") (("" (EXPAND "positive?") (("" (SKEEP) (("" (EXPAND "sum" -1) (("" (INST 1 "j" "j") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL)) (|positive_sum_positive_mult| 0 (|positive_sum_positive_mult-1| |nil| 3564275031 ("" (SKEEP) (("" (EXPAND "*") (("" (EXPAND "+ ") (("" (EXPAND "positive?") (("" (USE "fun_matrix_idemp") (("" (REPLACE -1 :HIDE? T) (("" (USE "fun_matrix_idemp") (("" (REPLACE -1 :HIDE? T) (("" (USE "positive_sum_fun_positive_mult_fun") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((* CONST-DECL "Measure_Matrix" |measures| NIL) (|positive?| CONST-DECL "bool" |measures| NIL) (|positive_sum_fun_positive_mult_fun| FORMULA-DECL NIL |measures| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|fun_matrix_idemp| FORMULA-DECL NIL |measures| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|eq| CONST-DECL "bool" |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|sum| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (+ CONST-DECL "Measure_Matrix" |measures| NIL)) SHOSTAK)) (|compatible_is_positive| 0 (|compatible_is_positive-2| |nil| 3575927794 ("" (SKEEP) (("" (EXPAND "compatible?") (("" (REWRITE "positive_multiplication") (("" (SKEEP) (("" (INST 1 "j" "j") NIL NIL)) NIL)) NIL)) NIL)) NIL) ((|compatible?| CONST-DECL "bool" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|positive_multiplication| FORMULA-DECL NIL |measures| NIL)) NIL) (|compatible_is_positive-1| |nil| 3572299450 ("" (SKEEP) (("" (REWRITE "positive_multiplication") (("" (EXPAND "compatible?") (("" (SKEEP) (("" (EXPAND "*" -1) (("" (TYPEPRED "max(LAMBDA (k: below(N)): (m3(j)(k) + m1(k)(j)))") (("" (NAME-REPLACE "M_31" "max(LAMBDA (k: below(N)): (m3(j)(k) + m1(k)(j)))") (("" (HIDE -1 -2) (("" (SKOLEM -1 "k") (("" (INST 1 "k" "j") (("" (REPLACE -1 -2 RL) (("" (HIDE -1) (("" (EXPAND "*" 1) (("" (TYPEPRED "max(LAMBDA (k_1: below(N)): (m1(k)(k_1) + m2(k_1)(j)))") (("" (NAME-REPLACE "M_12" "max(LAMBDA (k_1: below(N)): (m1(k)(k_1) + m2(k_1)(j)))") (("" (HIDE -3) (("" (INST -2 "j") (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|compatible_positive_grafting| 0 (|compatible_positive_grafting-1| |nil| 3575927827 ("" (SKEEP) (("" (REWRITE "positive_multiplication") (("" (LEMMA "compatible_is_positive") (("" (INST -1 "m2" "m3*m1") (("" (ASSERT) (("" (HIDE -2) (("" (LEMMA "measure_matrix_assoc") (("" (EXPAND "associative?") (("" (INST -1 "m2" "m3" "m1") (("" (REPLACE -1 -2 RL) (("" (HIDE -1) (("" (LEMMA "positive_commute") (("" (INST -1 "m2 * m3" "m1") (("" (ASSERT) (("" (HIDE -2) (("" (LEMMA "measure_matrix_assoc") (("" (EXPAND "associative?") (("" (INST -1 "m1" "m2" "m3") (("" (REPLACE -1 -2 RL) (("" (HIDE -1) (("" (REWRITE "positive_multiplication") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|positive_multiplication| FORMULA-DECL NIL |measures| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (* CONST-DECL "Measure_Matrix" |measures| NIL) (|associative?| CONST-DECL "bool" |operator_defs| NIL) (|positive_commute| FORMULA-DECL NIL |measures| NIL) (|measure_matrix_assoc| FORMULA-DECL NIL |measures| NIL) (|compatible_is_positive| FORMULA-DECL NIL |measures| NIL)) SHOSTAK)) (|defined_pos_mul_fun| 0 (|defined_pos_mul_fun-1| |nil| 3653476476 ("" (SKEEP) (("" (EXPAND "defined_pos_fun?") (("" (FLATTEN) (("" (EXPAND "mult") (("" (TYPEPRED "max(LAMBDA (k_1: below(N)): Plus3(f1(i)(k_1) , f2(k_1)(k)))") (("" (HIDE -1 -3) (("" (INST -1 "j") (("" (REPLACE -2 -1) (("" (HIDE -2) (("" (EXPAND "Plus3") (("" (ASSERT) (("" (LIFT-IF) (("" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|defined_pos_fun?| CONST-DECL "bool" |measures| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|Plus3| CONST-DECL "Sign3" |measures| NIL) (|max| CONST-DECL "{t: Sign3 | (FORALL i: f(i) <= t) AND (EXISTS j: f(j) = t)}" |measures| NIL) (<= CONST-DECL "bool" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) NIL)) (|defined_pos_mul| 0 (|defined_pos_mul-1| |nil| 3589198898 ("" (SKEEP) (("" (EXPAND "defined_pos?") (("" (USE "defined_pos_mul_fun") (("" (ASSERT) (("" (EXPAND "*") (("" (USE "fun_matrix_idemp") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|defined_pos?| CONST-DECL "bool" |measures| NIL) (|fun_matrix_idemp| FORMULA-DECL NIL |measures| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (* CONST-DECL "Measure_Matrix" |measures| NIL) (|defined_pos_mul_fun| FORMULA-DECL NIL |measures| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|eq| CONST-DECL "bool" |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|length| DEF-DECL "nat" |list_props| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) NIL)) (|defined_pos_decomp_fun| 0 (|defined_pos_decomp_fun-1| |nil| 3653476731 ("" (SKEEP) (("" (PROP) (("1" (EXPAND "defined_pos_fun?") (("1" (EXPAND "mult") (("1" (NAME-REPLACE "M" "max(LAMBDA (k: below(N)): Plus3(f1(i)(k),f2(k)(j)))") (("1" (TYPEPRED "M") (("1" (HIDE -1 -2) (("1" (SKEEP) (("1" (INST 2 "j_1") (("1" (EXPAND "Plus3") (("1" (LIFT-IF) (("1" (ASSERT) (("1" (GROUND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (EXPAND "defined_pos_fun?") (("2" (FLATTEN) (("2" (EXPAND "mult") (("2" (NAME-REPLACE "M" "max(LAMBDA (k: below(N)): Plus3(f1(i)(k),f2(k)(j)))") (("2" (TYPEPRED "M") (("2" (HIDE -1 -3) (("2" (INST -1 "k") (("2" (EXPAND "Plus3") (("2" (ASSERT) (("2" (LIFT-IF) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|Plus3| CONST-DECL "Sign3" |measures| NIL) (|max| CONST-DECL "{t: Sign3 | (FORALL i: f(i) <= t) AND (EXISTS j: f(j) = t)}" |measures| NIL) (<= CONST-DECL "bool" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|defined_pos_fun?| CONST-DECL "bool" |measures| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL)) NIL)) (|defined_pos_decomposition| 0 (|defined_pos_decomposition-1| |nil| 3590507616 ("" (SKEEP) (("" (EXPAND "*") (("" (EXPAND "defined_pos?") (("" (USE "fun_matrix_idemp") (("" (REPLACE -1 :HIDE? T) (("" (USE "defined_pos_decomp_fun") NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((* CONST-DECL "Measure_Matrix" |measures| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|eq| CONST-DECL "bool" |measures| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|fun_matrix_idemp| FORMULA-DECL NIL |measures| NIL) (|defined_pos_decomp_fun| FORMULA-DECL NIL |measures| NIL) (|defined_pos?| CONST-DECL "bool" |measures| NIL)) SHOSTAK)) (|positive_pos_mul_fun| 0 (|positive_pos_mul_fun-1| |nil| 3653477299 ("" (SKEEP) (("" (EXPAND "mult") (("" (NAME-REPLACE "M" "max(LAMBDA (k_1: below(N)): Plus3(f1(i)(k_1) , f2(k_1)(k)))") (("" (TYPEPRED "M") (("" (ASSERT) (("" (HIDE -3) (("" (INST -2 "j") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (|Plus3| CONST-DECL "Sign3" |measures| NIL) (|max| CONST-DECL "{t: Sign3 | (FORALL i: f(i) <= t) AND (EXISTS j: f(j) = t)}" |measures| NIL) (<= CONST-DECL "bool" |reals| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL)) NIL)) (|positive_pos_mul| 0 (|positive_pos_mul-1| |nil| 3589236009 ("" (SKEEP) (("" (EXPAND "*") (("" (TYPEPRED "form_matrix(mult(form_matfun(m1), form_matfun(m2)))") (("" (HIDE -1 -2) (("" (EXPAND "eq") (("" (INST?) (("" (REPLACE -1 :HIDE? T) (("" (LEMMA "positive_pos_mul_fun") (("" (INST? -1 :WHERE 1) (("" (INST -1 "j") (("" (ASSERT) (("" (HIDE 2) (("" (EXPAND "form_matfun") (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((* CONST-DECL "Measure_Matrix" |measures| NIL) (|positive_pos_mul_fun| FORMULA-DECL NIL |measures| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|form_matrix| CONST-DECL "{m: Measure_Matrix | eq(m, f)}" |measures| NIL) (|eq| CONST-DECL "bool" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) SHOSTAK)) (|positive_pos_decomp_fun| 0 (|positive_pos_decomp_fun-1| |nil| 3653477791 ("" (SKEEP) (("" (PROP) (("1" (EXPAND "mult") (("1" (NAME-REPLACE "M" "max(LAMBDA (k: below(N)): Plus3(f1(i)(k),f2(k)(j)))") (("1" (TYPEPRED "M") (("1" (HIDE -1 -2) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "mult") (("2" (NAME-REPLACE "M" "max(LAMBDA (k: below(N)): Plus3(f1(i)(k),f2(k)(j)))") (("2" (TYPEPRED "M") (("2" (HIDE -3) (("2" (SKEEP) (("2" (INST -2 "k") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (<= CONST-DECL "bool" |reals| NIL) (|max| CONST-DECL "{t: Sign3 | (FORALL i: f(i) <= t) AND (EXISTS j: f(j) = t)}" |measures| NIL) (|Plus3| CONST-DECL "Sign3" |measures| NIL) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL)) (|positive_pos_decomposition| 0 (|positive_pos_decomposition-1| |nil| 3590612558 ("" (SKEEP) (("" (EXPAND "*") (("" (TYPEPRED "form_matrix(mult(form_matfun(m1), form_matfun(m2)))") (("" (HIDE -1 -2) (("" (EXPAND "eq") (("" (INST?) (("" (REPLACE -1 :HIDE? T) (("" (USE "positive_pos_decomp_fun") (("" (EXPAND "form_matfun") (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((* CONST-DECL "Measure_Matrix" |measures| NIL) (|positive_pos_decomp_fun| FORMULA-DECL NIL |measures| NIL) (|form_matfun| CONST-DECL "{f | eq(m, f)}" |measures| NIL) (|mult| CONST-DECL "Measure_Mat_Fn" |measures| NIL) (|form_matrix| CONST-DECL "{m: Measure_Matrix | eq(m, f)}" |measures| NIL) (|eq| CONST-DECL "bool" |measures| NIL) (|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|Measure_Matrix| TYPE-EQ-DECL NIL |measures| NIL) (|listn| TYPE-EQ-DECL NIL |listn| |structures|) (|Measure_Mat_Fn| TYPE-EQ-DECL NIL |measures| NIL) (N FORMAL-CONST-DECL "posnat" |measures| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|length| DEF-DECL "nat" |list_props| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|Sign3| TYPE-EQ-DECL NIL |sign3| |reals|) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|every| ADT-DEF-DECL "boolean" |list_adt| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL)) SHOSTAK)))
