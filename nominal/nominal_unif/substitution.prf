(substitution
 (subs_TCC1 0
  (subs_TCC1-1 nil 3626013275 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (variable type-eq-decl nil nominal_term nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term_adt nil))
   nil))
 (subs_TCC2 0
  (subs_TCC2-1 nil 3626013275 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (variable type-eq-decl nil nominal_term nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term_adt nil))
   nil))
 (subs_TCC3 0
  (subs_TCC3-1 nil 3626013275 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (variable type-eq-decl nil nominal_term nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term_adt nil))
   nil))
 (subs_TCC4 0
  (subs_TCC4-1 nil 3626013275 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (variable type-eq-decl nil nominal_term nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term_adt nil))
   nil))
 (subs_perm_comm 0
  (subs_perm_comm-2 nil 3745916610
   ("" (induct "t")
    (("1" (grind) nil nil)
     ("2" (grind) (("2" (rewrite "ext_append" 1) nil nil)) nil)
     ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ext_append formula-decl nil nominal_term nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (ext def-decl "term" nominal_term nil)
    (subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   nil)
  (subs_perm_comm-1 nil 3626014664
   ("" (induct t)
    (("1" (grind) nil nil)
     ("2" (grind) (("2" (rewrite ext_append 1) nil nil)) nil)
     ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ext_append formula-decl nil nominal_term nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (ext def-decl "term" nominal_term nil)
    (subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   shostak))
 (Subs_TCC1 0
  (Subs_TCC1-1 nil 3626013275 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil))
   nil))
 (Subs_perm_comm 0
  (Subs_perm_comm-2 nil 3745916678
   ("" (induct "sigma")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("sg" "tail"))
      (("2" (prop)
        (("2" (skeep)
          (("2" (expand "Subs" 1)
            (("2" (inst -1 "pi" "t")
              (("2" (replaces -1)
                (("2"
                  (lemma "subs_perm_comm"
                   ("X" "sg`1" "s" "sg`2" "pi" "pi" "t"
                    "Subs(tail)(t)"))
                  (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subs_perm_comm formula-decl nil substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (ext def-decl "term" nominal_term nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil))
   nil)
  (Subs_perm_comm-1 nil 3626013277
   ("" (induct sigma)
    (("1" (grind) nil nil)
     ("2" (skolem 1 (sg tail))
      (("2" (prop)
        (("2" (skeep)
          (("2" (expand Subs 1)
            (("2" (inst -1 pi t)
              (("2" (replaces -1)
                (("2"
                  (lemma subs_perm_comm
                   (X "sg`1" s "sg`2" pi pi t "Subs(tail)(t)"))
                  (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subs_perm_comm formula-decl nil substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (ext def-decl "term" nominal_term nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil))
   shostak))
 (Subs_atom 0
  (Subs_atom-2 nil 3745916698
   ("" (induct "sigma") (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (subs def-decl "term" substitution nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (at adt-constructor-decl "[atom -> (atom?)]" term_adt nil)
    (atom? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil))
   nil)
  (Subs_atom-1 nil 3629442004
   ("" (induct sigma) (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (subs def-decl "term" substitution nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (at adt-constructor-decl "[atom -> (atom?)]" term_adt nil)
    (atom? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil))
   shostak))
 (Subs_unit 0
  (Subs_unit-2 nil 3745916723
   ("" (induct "sigma") (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((subs def-decl "term" substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (unit adt-constructor-decl "(unit?)" term_adt nil)
    (unit? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil))
   nil)
  (Subs_unit-1 nil 3629443077
   ("" (induct sigma) (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((subs def-decl "term" substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (unit adt-constructor-decl "(unit?)" term_adt nil)
    (unit? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil))
   shostak))
 (Subs_pair 0
  (Subs_pair-2 nil 3745916744
   ("" (induct "sigma") (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (subs def-decl "term" substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (pair adt-constructor-decl "[[term, term] -> (pair?)]" term_adt
     nil)
    (pair? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil))
   nil)
  (Subs_pair-1 nil 3627981658
   ("" (induct sigma) (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (subs def-decl "term" substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (pair adt-constructor-decl "[[term, term] -> (pair?)]" term_adt
     nil)
    (pair? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil))
   shostak))
 (Subs_abs 0
  (Subs_abs-2 nil 3745916770
   ("" (induct "sigma") (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (subs def-decl "term" substitution nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (abs adt-constructor-decl "[[atom, term] -> (abs?)]" term_adt nil)
    (abs? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil))
   nil)
  (Subs_abs-1 nil 3629443153
   ("" (induct sigma) (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (subs def-decl "term" substitution nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (abs adt-constructor-decl "[[atom, term] -> (abs?)]" term_adt nil)
    (abs? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil))
   shostak))
 (Subs_app 0
  (Subs_app-2 nil 3745916838
   ("" (induct "sigma") (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (subs def-decl "term" substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (app adt-constructor-decl "[[symbol, term] -> (app?)]" term_adt
     nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil))
   nil)
  (Subs_app-1 nil 3629443251
   ("" (induct sigma) (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (subs def-decl "term" substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (app adt-constructor-decl "[[symbol, term] -> (app?)]" term_adt
     nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil))
   shostak))
 (Subs_append 0
  (Subs_append-2 nil 3745916856
   ("" (induct "sigma") (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (append def-decl "list[T]" list_props nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil))
   nil)
  (Subs_append-1 nil 3627993564
   ("" (induct sigma) (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (append def-decl "list[T]" list_props nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil))
   shostak))
 (Subs_ord 0
  (Subs_ord-2 nil 3745916913
   ("" (induct "sigma")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("head" "tail"))
      (("2" (prop)
        (("2" (skeep)
          (("2" (expand "Subs" 2)
            (("2" (inst -1 "t")
              (("2" (assert)
                (("2" (replace -1 2 rl)
                  (("2" (case "susp?(Subs(tail)(t))")
                    (("1" (expand "ord" -2)
                      (("1" (assert)
                        (("1" (lift-if) (("1" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (hide -1)
                      (("2" (expand "ord" 3 2)
                        (("2" (lift-if)
                          (("2" (expand* "subs" "ord")
                            (("2" (prop) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subs def-decl "term" substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (Subs def-decl "term" substitution nil)
    (ord const-decl "upto(5)" term_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil))
   nil)
  (Subs_ord-1 nil 3630315396
   ("" (induct sigma)
    (("1" (grind) nil nil)
     ("2" (skolem 1 (head tail))
      (("2" (prop)
        (("2" (skeep)
          (("2" (expand Subs 2)
            (("2" (inst -1 t)
              (("2" (assert)
                (("2" (replace -1 2 rl)
                  (("2" (case "susp?(Subs(tail)(t))")
                    (("1" (expand ord -2)
                      (("1" (assert)
                        (("1" (lift-if) (("1" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (hide -1)
                      (("2" (expand ord 3 2)
                        (("2" (lift-if)
                          (("2" (expand* subs ord)
                            (("2" (prop) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subs def-decl "term" substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (Subs def-decl "term" substitution nil)
    (ord const-decl "upto(5)" term_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil))
   shostak))
 (Subs_fresh 0
  (Subs_fresh-2 nil 3745917031
   ("" (induct "t")
    (("1" (skeep*) (("1" (rewrite "Subs_atom") nil nil)) nil)
     ("2" (skeep*)
      (("2" (expand "fresh?") (("2" (propax) nil nil)) nil)) nil)
     ("3" (skeep*)
      (("3" (expand "fresh?" 1) (("3" (propax) nil nil)) nil)) nil)
     ("4" (skeep*)
      (("4" (rewrite "Subs_pair")
        (("4" (expand "fresh?" (-3 1))
          (("4" (expand "x")
            (("4" (prop)
              (("1" (inst -3 "a" "sigma") (("1" (assert) nil nil)) nil)
               ("2" (inst -4 "a" "sigma") (("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (rewrite "Subs_abs")
        (("5" (expand "fresh?" (-2 1))
          (("5" (prop)
            (("5" (inst -2 "a" "sigma") (("5" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (rewrite "Subs_app")
        (("6" (expand "fresh?" (-2 1))
          (("6" (inst -1 "a" "sigma") (("6" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((Subs_app formula-decl nil substitution nil)
    (Subs_abs formula-decl nil substitution nil)
    (x const-decl "[fresh_context, bool]" freshness nil)
    (Subs_pair formula-decl nil substitution nil)
    (Subs_atom formula-decl nil substitution nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (Subs def-decl "term" substitution nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (fresh_context type-eq-decl nil freshness nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   nil)
  (Subs_fresh-1 nil 3630743747
   ("" (induct t)
    (("1" (skeep*) (("1" (rewrite Subs_atom) nil nil)) nil)
     ("2" (skeep*) (("2" (expand fresh?) (("2" (propax) nil nil)) nil))
      nil)
     ("3" (skeep*)
      (("3" (expand fresh? 1) (("3" (propax) nil nil)) nil)) nil)
     ("4" (skeep*)
      (("4" (rewrite Subs_pair)
        (("4" (expand fresh? (-3 1))
          (("4" (expand x)
            (("4" (prop)
              (("1" (inst -3 a sigma) (("1" (assert) nil nil)) nil)
               ("2" (inst -4 a sigma) (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (rewrite Subs_abs)
        (("5" (expand fresh? (-2 1))
          (("5" (prop)
            (("5" (inst -2 a sigma) (("5" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (rewrite Subs_app)
        (("6" (expand fresh? (-2 1))
          (("6" (inst -1 a sigma) (("6" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((Subs_app formula-decl nil substitution nil)
    (Subs_abs formula-decl nil substitution nil)
    (x const-decl "[fresh_context, bool]" freshness nil)
    (Subs_pair formula-decl nil substitution nil)
    (Subs_atom formula-decl nil substitution nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (Subs def-decl "term" substitution nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (fresh_context type-eq-decl nil freshness nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   shostak))
 (fresh_subs_TCC1 0
  (fresh_subs_TCC1-1 nil 3626077798 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil))
   nil))
 (fresh_subs_character 0
  (fresh_subs_character-2 nil 3745917071
   ("" (induct "Nabla")
    (("1" (grind) nil nil)
     ("2" (grind)
      (("1" (reveal -1)
        (("1" (inst -1 "ax!1") (("1" (assert) nil nil)) nil)) nil)
       ("2" (reveal -1)
        (("2" (inst -1 "ax!1") (("2" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (fresh def-decl "bool" freshness nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fresh_subs def-decl "bool" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   nil)
  (fresh_subs_character-1 nil 3630407976
   ("" (induct Nabla)
    (("1" (grind) nil nil)
     ("2" (grind)
      (("1" (reveal -1)
        (("1" (inst -1 ax!1) (("1" (assert) nil nil)) nil)) nil)
       ("2" (reveal -1)
        (("2" (inst -1 ax!1) (("2" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (fresh def-decl "bool" freshness nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fresh_subs def-decl "bool" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   shostak))
 (fresh_subs_append_context 0
  (fresh_subs_append_context-2 nil 3745917092
   ("" (induct "Nabla1") (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (append def-decl "list[T]" list_props nil)
    (fresh_subs def-decl "bool" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   nil)
  (fresh_subs_append_context-1 nil 3630657441
   ("" (induct Nabla1) (("1" (grind) nil nil) ("2" (grind) nil nil))
    nil)
   ((list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (append def-decl "list[T]" list_props nil)
    (fresh_subs def-decl "bool" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   shostak))
 (fresh_subs_weakening 0
  (fresh_subs_weakening-2 nil 3745917178
   ("" (induct "Delta")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("ax" "Delta"))
      (("2" (prop)
        (("2" (skeep)
          (("2" (expand "fresh_subs" (-2 1))
            (("2" (flatten)
              (("2" (inst -1 "Nabla1" "Nabla2" "sigma")
                (("2" (assert)
                  (("2" (prop)
                    (("2"
                      (lemma "fresh_weakening"
                       ("Delta" "Nabla1" "Nabla" "Nabla2" "a" "ax`1"
                        "t" "Subs(sigma)((: :) * ax`2)"))
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (fresh_weakening formula-decl nil freshness nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (member def-decl "bool" list_props nil)
    (fresh_subs def-decl "bool" substitution nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   nil)
  (fresh_subs_weakening-1 nil 3630931319
   ("" (induct Delta)
    (("1" (grind) nil nil)
     ("2" (skolem 1 (ax Delta))
      (("2" (prop)
        (("2" (skeep)
          (("2" (expand fresh_subs (-2 1))
            (("2" (flatten)
              (("2" (inst -1 Nabla1 Nabla2 sigma)
                (("2" (assert)
                  (("2" (prop)
                    (("2"
                      (lemma fresh_weakening
                       (Delta Nabla1 Nabla Nabla2 a "ax`1" t
                        "Subs(sigma)((: :) * ax`2)"))
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (fresh_weakening formula-decl nil freshness nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (member def-decl "bool" list_props nil)
    (fresh_subs def-decl "bool" substitution nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   shostak))
 (fresh_subs?_TCC1 0
  (fresh_subs?_TCC1-1 nil 3627027468 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil))
   nil))
 (fresh_subs?_null 0
  (fresh_subs?_null-2 nil 3745917229
   ("" (induct "Delta")
    (("1" (grind) nil nil)
     ("2" (grind) (("2" (decompose-equality 1) nil nil)) nil))
    nil)
   ((x const-decl "[fresh_context, bool]" freshness nil)
    (append def-decl "list[T]" list_props nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (act def-decl "atom" atoms nil)
    (reverse def-decl "list[T]" list_props nil)
    (Subs def-decl "term" substitution nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   nil)
  (fresh_subs?_null-1 nil 3629444098
   ("" (induct Delta)
    (("1" (grind) nil nil)
     ("2" (grind) (("2" (decompose-equality 1) nil nil)) nil))
    nil)
   ((x const-decl "[fresh_context, bool]" freshness nil)
    (append def-decl "list[T]" list_props nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (act def-decl "atom" atoms nil)
    (reverse def-decl "list[T]" list_props nil)
    (Subs def-decl "term" substitution nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   shostak))
 (fresh_subs?_character 0
  (fresh_subs?_character-2 nil 3745917302
   ("" (induct "Delta")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("ax" "tail"))
      (("2" (prop)
        (("2" (skeep)
          (("2" (expand "fresh_subs?" 1)
            (("2" (inst -1 "sigma")
              (("2" (iff)
                (("2" (flatten)
                  (("2" (split 1)
                    (("1" (flatten)
                      (("1" (skeep)
                        (("1" (expand "x")
                          (("1" (hide -4)
                            (("1" (prop)
                              (("1"
                                (expand "member" -4)
                                (("1"
                                  (split)
                                  (("1"
                                    (decompose-equality -1)
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (inst -2 "a" "X")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide -1)
                      (("2" (prop)
                        (("1" (expand "x")
                          (("1" (prop)
                            (("1" (inst -2 "ax`1" "ax`2")
                              (("1"
                                (assert)
                                (("1"
                                  (expand "member")
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skeep)
                          (("2" (inst -2 "a" "X")
                            (("2" (expand "member" -2)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((x const-decl "[fresh_context, bool]" freshness nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   nil)
  (fresh_subs?_character-1 nil 3630744502
   ("" (induct Delta)
    (("1" (grind) nil nil)
     ("2" (skolem 1 (ax tail))
      (("2" (prop)
        (("2" (skeep)
          (("2" (expand fresh_subs? 1)
            (("2" (inst -1 sigma)
              (("2" (iff)
                (("2" (flatten)
                  (("2" (split 1)
                    (("1" (flatten)
                      (("1" (skeep)
                        (("1" (expand x)
                          (("1" (hide -4)
                            (("1" (prop)
                              (("1"
                                (expand member -4)
                                (("1"
                                  (split)
                                  (("1"
                                    (decompose-equality -1)
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (inst -2 a X)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide -1)
                      (("2" (prop)
                        (("1" (expand x)
                          (("1" (prop)
                            (("1" (inst -2 "ax`1" "ax`2")
                              (("1"
                                (assert)
                                (("1"
                                  (expand member)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skeep)
                          (("2" (inst -2 a X)
                            (("2" (expand member -2)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((x const-decl "[fresh_context, bool]" freshness nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   shostak))
 (fresh_subs?_append_context 0
  (fresh_subs?_append_context-2 nil 3745917358
   ("" (induct "Delta")
    (("1" (grind)
      (("1" (expand "fresh_subs?")
        (("1" (lift-if)
          (("1" (prop)
            (("1" (assert) nil nil)
             ("2" (expand "x")
              (("2" (lift-if)
                (("2" (assert) (("2" (prop) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 ("ax" "Delta"))
      (("2" (prop)
        (("2" (skeep)
          (("2" (expand "append" 1)
            (("2" (expand "fresh_subs?" 1 (1 2))
              (("2" (inst -1 "Nabla" "sigma")
                (("2" (replaces -1)
                  (("2" (expand "x")
                    (("2" (grind)
                      (("2" (rewrite "append_assoc") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (append_assoc formula-decl nil list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (x const-decl "[fresh_context, bool]" freshness nil)
    (append def-decl "list[T]" list_props nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   nil)
  (fresh_subs?_append_context-1 nil 3629455222
   ("" (induct Delta)
    (("1" (grind)
      (("1" (expand fresh_subs?)
        (("1" (lift-if)
          (("1" (prop)
            (("1" (assert) nil nil)
             ("2" (expand x)
              (("2" (lift-if)
                (("2" (assert) (("2" (prop) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 (ax Delta))
      (("2" (prop)
        (("2" (skeep)
          (("2" (expand append 1)
            (("2" (expand fresh_subs? 1 (1 2))
              (("2" (inst -1 Nabla sigma)
                (("2" (replaces -1)
                  (("2" (expand x)
                    (("2" (grind)
                      (("2" (rewrite append_assoc) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (append_assoc formula-decl nil list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (x const-decl "[fresh_context, bool]" freshness nil)
    (append def-decl "list[T]" list_props nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   shostak))
 (fresh_subs?_is_fresh 0
  (fresh_subs?_is_fresh-2 nil 3745917492
   ("" (induct "Delta")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skolem 1 ("head" "tail"))
      (("3" (prop)
        (("3" (skeep*)
          (("3" (expand "fresh_subs?" (-2 1))
            (("3" (expand "x")
              (("3" (prop)
                (("3" (assert)
                  (("3" (expand "member" -6)
                    (("3" (split)
                      (("1" (decompose-equality -1)
                        (("1" (replace -1 -3 rl)
                          (("1" (replace -2 -3 rl)
                            (("1" (replace -2 1 rl)
                              (("1"
                                (replace -1 1 rl)
                                (("1"
                                  (lemma
                                   "fresh?_is_fresh"
                                   ("Delta"
                                    "fresh?(a, Subs(sigma)((: :) * X))`1"
                                    "a"
                                    "a"
                                    "t"
                                    "Subs(sigma)((: :) * X)"))
                                  (("1"
                                    (assert)
                                    (("1"
                                      (lemma
                                       "fresh_weakening"
                                       ("Delta"
                                        "fresh?(a, Subs(sigma)((: :) * X))`1"
                                        "Nabla"
                                        "append(fresh?(a, Subs(sigma)((: :) * X))`1,fresh_subs?(sigma, tail)`1)"
                                        "a"
                                        "a"
                                        "t"
                                        "Subs(sigma)((: :) * X)"))
                                      (("1"
                                        (assert)
                                        (("1"
                                          (skeep)
                                          (("1"
                                            (rewrite "append_member")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (inst -6 "sigma")
                        (("2" (assert)
                          (("2" (inst -6 "a" "X")
                            (("2"
                              (lemma "fresh_weakening"
                               ("Delta"
                                "fresh_subs?(sigma, tail)`1"
                                "Nabla"
                                "append(fresh?(head`1, Subs(sigma)((: :) * head`2))`1, fresh_subs?(sigma, tail)`1)"
                                "a"
                                "a"
                                "t"
                                "Subs(sigma)((: :) * X)"))
                              (("2"
                                (assert)
                                (("2"
                                  (assert)
                                  (("2"
                                    (skeep)
                                    (("2"
                                      (rewrite "append_member")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((x const-decl "[fresh_context, bool]" freshness nil)
    (fresh?_is_fresh formula-decl nil freshness nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (fresh_weakening formula-decl nil freshness nil)
    (append def-decl "list[T]" list_props nil)
    (append_member formula-decl nil structure_extra nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (fresh def-decl "bool" freshness nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   nil)
  (fresh_subs?_is_fresh-1 nil 3629436872
   ("" (induct Delta)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skolem 1 (head tail))
      (("3" (prop)
        (("3" (skeep*)
          (("3" (expand fresh_subs? (-2 1))
            (("3" (expand x)
              (("3" (prop)
                (("3" (assert)
                  (("3" (expand member -6)
                    (("3" (split)
                      (("1" (decompose-equality -1)
                        (("1" (replace -1 -3 rl)
                          (("1" (replace -2 -3 rl)
                            (("1" (replace -2 1 rl)
                              (("1"
                                (replace -1 1 rl)
                                (("1"
                                  (lemma
                                   fresh?_is_fresh
                                   (Delta
                                    "fresh?(a, Subs(sigma)((: :) * X))`1"
                                    a
                                    a
                                    t
                                    "Subs(sigma)((: :) * X)"))
                                  (("1"
                                    (assert)
                                    (("1"
                                      (lemma
                                       fresh_weakening
                                       (Delta
                                        "fresh?(a, Subs(sigma)((: :) * X))`1"
                                        Nabla
                                        "append(fresh?(a, Subs(sigma)((: :) * X))`1,fresh_subs?(sigma, tail)`1)"
                                        a
                                        a
                                        t
                                        "Subs(sigma)((: :) * X)"))
                                      (("1"
                                        (assert)
                                        (("1"
                                          (skeep)
                                          (("1"
                                            (rewrite append_member)
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (inst -6 sigma)
                        (("2" (assert)
                          (("2" (inst -6 a X)
                            (("2"
                              (lemma fresh_weakening
                               (Delta
                                "fresh_subs?(sigma, tail)`1"
                                Nabla
                                "append(fresh?(head`1, Subs(sigma)((: :) * head`2))`1, fresh_subs?(sigma, tail)`1)"
                                a
                                a
                                t
                                "Subs(sigma)((: :) * X)"))
                              (("2"
                                (assert)
                                (("2"
                                  (assert)
                                  (("2"
                                    (skeep)
                                    (("2"
                                      (rewrite append_member)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((x const-decl "[fresh_context, bool]" freshness nil)
    (fresh?_is_fresh formula-decl nil freshness nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (fresh_weakening formula-decl nil freshness nil)
    (append def-decl "list[T]" list_props nil)
    (append_member formula-decl nil structure_extra nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (fresh def-decl "bool" freshness nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   shostak))
 (fresh_subs?_is_fresh2 0
  (fresh_subs?_is_fresh2-2 nil 3745917647
   ("" (induct "t")
    (("1" (grind) nil nil)
     ("2" (grind)
      (("2" (rewrite "Subs_atom")
        (("2" (expand "fresh") (("2" (propax) nil nil)) nil)) nil))
      nil)
     ("3" (skolem 1 ("pi" "X"))
      (("3" (skeep)
        (("3" (expand "fresh" -2)
          (("3"
            (lemma "Subs_perm_comm"
             ("sigma" "sigma" "pi" "pi" "t" "(::)*X"))
            (("3" (expand "ext" -1 1)
              (("3" (rewrite "append_null")
                (("3" (replaces -1)
                  (("3" (rewrite "ext_reverse_fresh")
                    (("3"
                      (lemma "fresh_subs?_is_fresh"
                       ("Delta" "Delta" "sigma" "sigma"))
                      (("3" (assert)
                        (("3" (assert)
                          (("3" (inst -1 "act(reverse(pi))(a)" X)
                            (("3" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (grind)
      (("4" (rewrite "Subs_unit")
        (("4" (expand "fresh") (("4" (propax) nil nil)) nil)) nil))
      nil)
     ("5" (skeep*)
      (("5" (rewrite "Subs_pair")
        (("5" (expand "fresh" (-4 1))
          (("5" (inst -1 "Delta" "a" "sigma")
            (("5" (inst -2 "Delta" "a" "sigma")
              (("5" (flatten) (("5" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (rewrite "Subs_abs")
        (("6" (expand "fresh" (-3 1))
          (("6" (split -3)
            (("1" (assert) nil nil)
             ("2" (prop)
              (("2" (inst -2 "Delta" "a" "sigma")
                (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (grind)
      (("7" (rewrite "Subs_app")
        (("7" (expand "fresh" 1) (("7" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((Subs_app formula-decl nil substitution nil)
    (Subs_abs formula-decl nil substitution nil)
    (Subs_pair formula-decl nil substitution nil)
    (Subs_unit formula-decl nil substitution nil)
    (ext def-decl "term" nominal_term nil)
    (fresh_subs?_is_fresh formula-decl nil substitution nil)
    (act def-decl "atom" atoms nil)
    (reverse def-decl "list[T]" list_props nil)
    (ext_reverse_fresh formula-decl nil freshness nil)
    (append_null formula-decl nil list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs_perm_comm formula-decl nil substitution nil)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Subs_atom formula-decl nil substitution nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (Subs def-decl "term" substitution nil)
    (fresh def-decl "bool" freshness nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (fresh_context type-eq-decl nil freshness nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   nil)
  (fresh_subs?_is_fresh2-1 nil 3629441846
   ("" (induct t)
    (("1" (grind) nil nil)
     ("2" (grind)
      (("2" (rewrite Subs_atom)
        (("2" (expand fresh) (("2" (propax) nil nil)) nil)) nil))
      nil)
     ("3" (skolem 1 (pi X))
      (("3" (skeep)
        (("3" (expand fresh -2)
          (("3" (lemma Subs_perm_comm (sigma sigma pi pi t "(::)*X"))
            (("3" (expand ext -1 1)
              (("3" (rewrite append_null)
                (("3" (replaces -1)
                  (("3" (rewrite ext_reverse_fresh)
                    (("3"
                      (lemma fresh_subs?_is_fresh
                       (Delta Delta sigma sigma))
                      (("3" (assert)
                        (("3" (assert)
                          (("3" (inst -1 "act(reverse(pi))(a)" X)
                            (("3" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (grind)
      (("4" (rewrite Subs_unit)
        (("4" (expand fresh) (("4" (propax) nil nil)) nil)) nil))
      nil)
     ("5" (skeep*)
      (("5" (rewrite Subs_pair)
        (("5" (expand fresh (-4 1))
          (("5" (inst -1 Delta a sigma)
            (("5" (inst -2 Delta a sigma)
              (("5" (flatten) (("5" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (rewrite Subs_abs)
        (("6" (expand fresh (-3 1))
          (("6" (split -3)
            (("1" (assert) nil nil)
             ("2" (prop)
              (("2" (inst -2 Delta a sigma) (("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (grind)
      (("7" (rewrite Subs_app)
        (("7" (expand fresh 1) (("7" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((Subs_app formula-decl nil substitution nil)
    (Subs_abs formula-decl nil substitution nil)
    (Subs_pair formula-decl nil substitution nil)
    (Subs_unit formula-decl nil substitution nil)
    (ext def-decl "term" nominal_term nil)
    (fresh_subs?_is_fresh formula-decl nil substitution nil)
    (act def-decl "atom" atoms nil)
    (reverse def-decl "list[T]" list_props nil)
    (ext_reverse_fresh formula-decl nil freshness nil)
    (append_null formula-decl nil list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs_perm_comm formula-decl nil substitution nil)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Subs_atom formula-decl nil substitution nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (Subs def-decl "term" substitution nil)
    (fresh def-decl "bool" freshness nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (fresh_context type-eq-decl nil freshness nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   shostak))
 (fresh_subs?_is_fresh3 0
  (fresh_subs?_is_fresh3-2 nil 3745917861
   ("" (induct "t")
    (("1" (grind)
      (("1" (rewrite "Subs_atom") (("1" (grind) nil nil)) nil)
       ("2" (rewrite "Subs_atom") (("2" (grind) nil nil)) nil))
      nil)
     ("2" (skolem 1 ("pi" "X"))
      (("2" (skeep)
        (("2" (expand "fresh?" 1 (2 3))
          (("2" (expand "x")
            (("2" (rewrite "append_null")
              (("2"
                (lemma "ext_reverse_fresh?"
                 ("a" "a" "pi" "pi" "t" "Subs(sigma)(null * X)"))
                (("2"
                  (lemma "Subs_perm_comm"
                   ("pi" "pi" "sigma" "sigma" "t" "null * X"))
                  (("2" (expand* "fresh_subs?" "x")
                    (("2" (expand "ext" -1 1)
                      (("2" (rewrite "append_null")
                        (("2" (replaces -1)
                          (("2" (replace -1 1 rl)
                            (("2" (expand "fresh_subs?")
                              (("2"
                                (rewrite "append_null")
                                (("2"
                                  (lift-if)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (prop)
                                      (("2"
                                        (hide -1)
                                        (("2"
                                          (lemma
                                           "not_fresh_is_null"
                                           ("a"
                                            "a"
                                            "t"
                                            "ext(pi)(Subs(sigma)(null * X))"))
                                          (("2"
                                            (assert)
                                            (("2"
                                              (decompose-equality 2)
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (grind)
      (("3" (rewrite "Subs_unit") (("3" (grind) nil nil)) nil)) nil)
     ("4" (skeep*)
      (("4" (rewrite "Subs_pair")
        (("4" (expand "fresh?" 1)
          (("4" (inst -1 "a" "sigma")
            (("4" (inst -2 "a" "sigma")
              (("4" (replaces -1)
                (("4" (replaces -1)
                  (("4" (expand "x" 1 (5 6))
                    (("4" (lift-if)
                      (("4" (prop)
                        (("1" (rewrite "fresh_subs?_append_context")
                          (("1" (expand "x")
                            (("1" (grind)
                              (("1"
                                (rewrite "append_null")
                                (("1"
                                  (rewrite "append_null")
                                  (("1"
                                    (rewrite "append_null")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "x") (("2" (assert) nil nil))
                          nil)
                         ("3" (expand "x") (("3" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (rewrite "Subs_abs")
        (("5" (expand "fresh?" 1)
          (("5" (lift-if)
            (("5" (prop)
              (("1" (hide -2) (("1" (grind) nil nil)) nil)
               ("2" (inst -1 "a" "sigma") nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (rewrite "Subs_app")
        (("6" (expand "fresh?" 1) (("6" (inst -1 "a" "sigma") nil nil))
          nil))
        nil))
      nil))
    nil)
   ((Subs_app formula-decl nil substitution nil)
    (Subs_abs formula-decl nil substitution nil)
    (fresh_subs?_append_context formula-decl nil substitution nil)
    (Subs_pair formula-decl nil substitution nil)
    (Subs_unit formula-decl nil substitution nil)
    (append_null formula-decl nil list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (act def-decl "atom" atoms nil)
    (reverse def-decl "list[T]" list_props nil)
    (Subs_perm_comm formula-decl nil substitution nil)
    (ext def-decl "term" nominal_term nil)
    (not_fresh_is_null formula-decl nil freshness nil)
    (FALSE const-decl "bool" booleans nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (ext_reverse_fresh? formula-decl nil freshness nil)
    (append def-decl "list[T]" list_props nil)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Subs_atom formula-decl nil substitution nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (x const-decl "[fresh_context, bool]" freshness nil)
    (Subs def-decl "term" substitution nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (fresh_context type-eq-decl nil freshness nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   nil)
  (fresh_subs?_is_fresh3-1 nil 3629458760
   ("" (induct t)
    (("1" (grind)
      (("1" (rewrite Subs_atom) (("1" (grind) nil nil)) nil)
       ("2" (rewrite Subs_atom) (("2" (grind) nil nil)) nil))
      nil)
     ("2" (skolem 1 (pi X))
      (("2" (skeep)
        (("2" (expand fresh? 1 (2 3))
          (("2" (expand x)
            (("2" (rewrite append_null)
              (("2"
                (lemma ext_reverse_fresh?
                 (a a pi pi t "Subs(sigma)(null * X)"))
                (("2"
                  (lemma Subs_perm_comm
                   (pi pi sigma sigma t "null * X"))
                  (("2" (expand* fresh_subs? x)
                    (("2" (expand ext -1 1)
                      (("2" (rewrite append_null)
                        (("2" (replaces -1)
                          (("2" (replace -1 1 rl)
                            (("2" (expand fresh_subs?)
                              (("2"
                                (rewrite append_null)
                                (("2"
                                  (lift-if)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (prop)
                                      (("2"
                                        (hide -1)
                                        (("2"
                                          (lemma
                                           not_fresh_is_null
                                           (a
                                            a
                                            t
                                            "ext(pi)(Subs(sigma)(null * X))"))
                                          (("2"
                                            (assert)
                                            (("2"
                                              (decompose-equality 2)
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (grind)
      (("3" (rewrite Subs_unit) (("3" (grind) nil nil)) nil)) nil)
     ("4" (skeep*)
      (("4" (rewrite Subs_pair)
        (("4" (expand fresh? 1)
          (("4" (inst -1 a sigma)
            (("4" (inst -2 a sigma)
              (("4" (replaces -1)
                (("4" (replaces -1)
                  (("4" (expand x 1 (5 6))
                    (("4" (lift-if)
                      (("4" (prop)
                        (("1" (rewrite fresh_subs?_append_context)
                          (("1" (expand x)
                            (("1" (grind)
                              (("1"
                                (rewrite append_null)
                                (("1"
                                  (rewrite append_null)
                                  (("1" (rewrite append_null) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand x) (("2" (assert) nil nil)) nil)
                         ("3" (expand x) (("3" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (rewrite Subs_abs)
        (("5" (expand fresh? 1)
          (("5" (lift-if)
            (("5" (prop)
              (("1" (hide -2) (("1" (grind) nil nil)) nil)
               ("2" (inst -1 a sigma) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (rewrite Subs_app)
        (("6" (expand fresh? 1) (("6" (inst -1 a sigma) nil nil)) nil))
        nil))
      nil))
    nil)
   ((Subs_app formula-decl nil substitution nil)
    (Subs_abs formula-decl nil substitution nil)
    (fresh_subs?_append_context formula-decl nil substitution nil)
    (Subs_pair formula-decl nil substitution nil)
    (Subs_unit formula-decl nil substitution nil)
    (append_null formula-decl nil list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (act def-decl "atom" atoms nil)
    (reverse def-decl "list[T]" list_props nil)
    (Subs_perm_comm formula-decl nil substitution nil)
    (ext def-decl "term" nominal_term nil)
    (not_fresh_is_null formula-decl nil freshness nil)
    (FALSE const-decl "bool" booleans nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (ext_reverse_fresh? formula-decl nil freshness nil)
    (append def-decl "list[T]" list_props nil)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Subs_atom formula-decl nil substitution nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (x const-decl "[fresh_context, bool]" freshness nil)
    (Subs def-decl "term" substitution nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (fresh_context type-eq-decl nil freshness nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   shostak))
 (fresh_subs?_append 0
  (fresh_subs?_append-2 nil 3745918047
   ("" (induct "Delta")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("ax" "Delta"))
      (("2" (prop)
        (("2" (induct "sigma")
          (("1" (skeep)
            (("1" (expand "fresh_subs?" 1 (1 3 4))
              (("1" (expand "append" 1)
                (("1" (rewrite "fresh_subs?_null")
                  (("1" (expand "x" 1 (1 4))
                    (("1" (lift-if)
                      (("1" (prop)
                        (("1" (expand "x" 1 2)
                          (("1" (assert)
                            (("1" (expand "x" 1)
                              (("1" (rewrite "append_null") nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "x" 2) (("2" (propax) nil nil))
                          nil)
                         ("3" (expand "x" 2) (("3" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem 1 ("sig" "Sigma"))
            (("2" (prop)
              (("2" (skeep)
                (("2" (inst -2 "gamma" "cons(sig, Sigma)")
                  (("2" (expand "fresh_subs?" 1 (1 3 4))
                    (("2" (replaces -2)
                      (("2" (expand "x" 1 4)
                        (("2" (lift-if)
                          (("2" (assert)
                            (("2" (prop)
                              (("1"
                                (rewrite "fresh_subs?_append_context")
                                (("1"
                                  (expand "x" 1 5)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (rewrite "Subs_append")
                                      (("1"
                                        (rewrite
                                         "fresh_subs?_is_fresh3"
                                         1)
                                        (("1"
                                          (hide -3)
                                          (("1"
                                            (grind)
                                            (("1"
                                              (rewrite "append_null")
                                              (("1"
                                                (rewrite "append_null")
                                                (("1"
                                                  (rewrite
                                                   "append_null")
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (rewrite "Subs_append")
                                (("2"
                                  (rewrite "fresh_subs?_is_fresh3" 2)
                                  (("2"
                                    (hide -1)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (hide -1)
                                (("3" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (fresh_subs?_null formula-decl nil substitution nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (Subs def-decl "term" substitution nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (append_null formula-decl nil list_props nil)
    (Subs_append formula-decl nil substitution nil)
    (fresh_subs?_is_fresh3 formula-decl nil substitution nil)
    (fresh_subs?_append_context formula-decl nil substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (x const-decl "[fresh_context, bool]" freshness nil)
    (append def-decl "list[T]" list_props nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   nil)
  (fresh_subs?_append-1 nil 3629445015
   ("" (induct Delta)
    (("1" (grind) nil nil)
     ("2" (skolem 1 (ax Delta))
      (("2" (prop)
        (("2" (induct sigma)
          (("1" (skeep)
            (("1" (expand fresh_subs? 1 (1 3 4))
              (("1" (expand append 1)
                (("1" (rewrite fresh_subs?_null)
                  (("1" (expand x 1 (1 4))
                    (("1" (lift-if)
                      (("1" (prop)
                        (("1" (expand x 1 2)
                          (("1" (assert)
                            (("1" (expand x 1)
                              (("1" (rewrite append_null) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand x 2) (("2" (propax) nil nil))
                          nil)
                         ("3" (expand x 2) (("3" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem 1 (sig Sigma))
            (("2" (prop)
              (("2" (skeep)
                (("2" (inst -2 gamma "cons(sig, Sigma)")
                  (("2" (expand fresh_subs? 1 (1 3 4))
                    (("2" (replaces -2)
                      (("2" (expand x 1 4)
                        (("2" (lift-if)
                          (("2" (assert)
                            (("2" (prop)
                              (("1"
                                (rewrite fresh_subs?_append_context)
                                (("1"
                                  (expand x 1 5)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (rewrite Subs_append)
                                      (("1"
                                        (rewrite
                                         fresh_subs?_is_fresh3
                                         1)
                                        (("1"
                                          (hide -3)
                                          (("1"
                                            (grind)
                                            (("1"
                                              (rewrite append_null)
                                              (("1"
                                                (rewrite append_null)
                                                (("1"
                                                  (rewrite append_null)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (rewrite Subs_append)
                                (("2"
                                  (rewrite fresh_subs?_is_fresh3 2)
                                  (("2"
                                    (hide -1)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (hide -1)
                                (("3" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (fresh_subs?_null formula-decl nil substitution nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (Subs def-decl "term" substitution nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (append_null formula-decl nil list_props nil)
    (Subs_append formula-decl nil substitution nil)
    (fresh_subs?_is_fresh3 formula-decl nil substitution nil)
    (fresh_subs?_append_context formula-decl nil substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (x const-decl "[fresh_context, bool]" freshness nil)
    (append def-decl "list[T]" list_props nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   shostak))
 (fresh_subs?_alpha_aux 0
  (fresh_subs?_alpha_aux-2 nil 3745918241
   ("" (induct "t")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skolem 1 ("pi" "X"))
      (("3" (skeep*)
        (("3" (expand "alpha" -2)
          (("3" (flatten)
            (("3"
              (lemma "subs_perm_comm"
               ("X" "X_1" "s" "u" "pi" "pi" "t" "(::)*X"))
              (("3"
                (lemma "subs_perm_comm"
                 ("X" "X_1" "s" "u" "pi" "p(s)" "t" "(::)*V(s)"))
                (("3" (expand "ext" -1 1)
                  (("3" (expand "ext" -2 1)
                    (("3" (rewrite "append_null")
                      (("3" (rewrite "append_null")
                        (("3" (replaces -2)
                          (("3"
                            (case "subs(X_1, u)(s) = subs(X_1, u)((p(s) * V(s)))")
                            (("1" (replaces -1)
                              (("1"
                                (replaces -1)
                                (("1"
                                  (replace -3 1 rl)
                                  (("1"
                                    (rewrite "alpha_fresh_invariance")
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (lemma
                                         "fresh_subs?_is_fresh"
                                         ("Delta"
                                          "Delta"
                                          "sigma"
                                          "(:(X_1,u):)"))
                                        (("1"
                                          (assert)
                                          (("1"
                                            (inst -1 "a" "X")
                                            (("1"
                                              (inst -5 "a")
                                              (("1"
                                                (expand* "Subs" "Subs")
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but (-3 1))
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skolem 1 ("a" "t"))
      (("6" (prop)
        (("6" (skeep)
          (("6" (expand "alpha" -3)
            (("6" (prop)
              (("1" (expand "subs" 1)
                (("1" (assert)
                  (("1" (expand "alpha" 1)
                    (("1" (inst -3 "Delta" "X" "body(s)" "u")
                      (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "subs" 2)
                (("2" (assert)
                  (("2" (expand "alpha" 2)
                    (("2"
                      (inst -3 "Delta" "X"
                       "ext((:(a,abstr(s)):))(body(s))" "u")
                      (("2" (rewrite "subs_perm_comm")
                        (("2" (assert)
                          (("2"
                            (lemma "fresh_subs?_is_fresh2"
                             ("Delta" "Delta" "a" "a" "t" "body(s)"
                              "sigma" "(:(X,u):)"))
                            (("2" (expand* "Subs" "Subs") nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (grind) nil nil))
    nil)
   ((arg adt-accessor-decl "[(app?) -> term]" term_adt nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (body adt-accessor-decl "[(abs?) -> term]" term_adt nil)
    (abs? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (abstr adt-accessor-decl "[(abs?) -> atom]" term_adt nil)
    (fresh_subs?_is_fresh2 formula-decl nil substitution nil)
    (term1 adt-accessor-decl "[(pair?) -> term]" term_adt nil)
    (pair? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (term2 adt-accessor-decl "[(pair?) -> term]" term_adt nil)
    (subs_perm_comm formula-decl nil substitution nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (ext def-decl "term" nominal_term nil)
    (append_null formula-decl nil list_props nil)
    (Subs def-decl "term" substitution nil)
    (set type-eq-decl nil sets nil)
    (ds const-decl "set[atom]" atoms nil)
    (fresh_subs?_is_fresh formula-decl nil substitution nil)
    (alpha_fresh_invariance formula-decl nil alpha_equivalence nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V adt-accessor-decl "[(susp?) -> variable]" term_adt nil)
    (p adt-accessor-decl "[(susp?) -> perm]" term_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (subs def-decl "term" substitution nil)
    (alpha def-decl "bool" alpha_equivalence nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fresh_context type-eq-decl nil freshness nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   nil)
  (fresh_subs?_alpha_aux-1 nil 3629189079
   ("" (induct t)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skolem 1 (pi X))
      (("3" (skeep*)
        (("3" (expand alpha -2)
          (("3" (flatten)
            (("3" (lemma subs_perm_comm (X X_1 s u pi pi t "(::)*X"))
              (("3"
                (lemma subs_perm_comm
                 (X X_1 s u pi "p(s)" t "(::)*V(s)"))
                (("3" (expand ext -1 1)
                  (("3" (expand ext -2 1)
                    (("3" (rewrite append_null)
                      (("3" (rewrite append_null)
                        (("3" (replaces -2)
                          (("3"
                            (case "subs(X_1, u)(s) = subs(X_1, u)((p(s) * V(s)))")
                            (("1" (replaces -1)
                              (("1"
                                (replaces -1)
                                (("1"
                                  (replace -3 1 rl)
                                  (("1"
                                    (rewrite alpha_fresh_invariance)
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (lemma
                                         fresh_subs?_is_fresh
                                         (Delta
                                          Delta
                                          sigma
                                          "(:(X_1,u):)"))
                                        (("1"
                                          (assert)
                                          (("1"
                                            (inst -1 a X)
                                            (("1"
                                              (inst -5 a)
                                              (("1"
                                                (expand* Subs Subs)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but (-3 1))
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (skolem 1 (a t))
      (("6" (prop)
        (("6" (skeep)
          (("6" (expand alpha -3)
            (("6" (prop)
              (("1" (expand subs 1)
                (("1" (assert)
                  (("1" (expand alpha 1)
                    (("1" (inst -3 Delta X "body(s)" u)
                      (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (expand subs 2)
                (("2" (assert)
                  (("2" (expand alpha 2)
                    (("2"
                      (inst -3 Delta X "ext((:(a,abstr(s)):))(body(s))"
                       u)
                      (("2" (rewrite subs_perm_comm)
                        (("2" (assert)
                          (("2"
                            (lemma fresh_subs?_is_fresh2
                             (Delta Delta a a t "body(s)" sigma
                              "(:(X,u):)"))
                            (("2" (expand* Subs Subs) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (grind) nil nil))
    nil)
   ((arg adt-accessor-decl "[(app?) -> term]" term_adt nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (body adt-accessor-decl "[(abs?) -> term]" term_adt nil)
    (abs? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (abstr adt-accessor-decl "[(abs?) -> atom]" term_adt nil)
    (fresh_subs?_is_fresh2 formula-decl nil substitution nil)
    (term1 adt-accessor-decl "[(pair?) -> term]" term_adt nil)
    (pair? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (term2 adt-accessor-decl "[(pair?) -> term]" term_adt nil)
    (subs_perm_comm formula-decl nil substitution nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (ext def-decl "term" nominal_term nil)
    (append_null formula-decl nil list_props nil)
    (Subs def-decl "term" substitution nil)
    (set type-eq-decl nil sets nil)
    (ds const-decl "set[atom]" atoms nil)
    (fresh_subs?_is_fresh formula-decl nil substitution nil)
    (alpha_fresh_invariance formula-decl nil alpha_equivalence nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (V adt-accessor-decl "[(susp?) -> variable]" term_adt nil)
    (p adt-accessor-decl "[(susp?) -> perm]" term_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (subs def-decl "term" substitution nil)
    (alpha def-decl "bool" alpha_equivalence nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fresh_context type-eq-decl nil freshness nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   shostak))
 (fresh_subs?_alpha 0
  (fresh_subs?_alpha-2 nil 3745918339
   ("" (induct "sigma")
    (("1" (grind) nil nil)
     ("2" (grind)
      (("2" (rewrite "fresh_subs?_null") (("2" (assert) nil nil)) nil))
      nil)
     ("3" (skolem 1 (head tail))
      (("3" (prop)
        (("3" (skeep)
          (("3" (expand "Subs" 1)
            (("3"
              (case "cons(head,tail) = append(cons(head,null),tail)")
              (("1" (replaces -1)
                (("1" (rewrite "fresh_subs?_append")
                  (("1" (expand "x" -2)
                    (("1" (prop)
                      (("1" (expand "x")
                        (("1" (assert)
                          (("1" (inst -3 "Delta" "s" "t")
                            (("1" (assert)
                              (("1"
                                (lemma
                                 "fresh_subs?_alpha_aux"
                                 ("X"
                                  "head`1"
                                  "u"
                                  "head`2"
                                  "t"
                                  "Subs(tail)(t)"
                                  "s"
                                  "Subs(tail)(s)"
                                  "Delta"
                                  "fresh_subs?(tail, Delta)`1"))
                                (("1"
                                  (rewrite "append_null")
                                  (("1"
                                    (case
                                     "(: (head`1, head`2) :) = cons(head, null)")
                                    (("1"
                                      (replaces -1)
                                      (("1" (assert) nil nil))
                                      nil)
                                     ("2"
                                      (decompose-equality 1)
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "append" 1)
                (("2" (expand "append" 1) (("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (fresh_subs?_append formula-decl nil substitution nil)
    (append_null formula-decl nil list_props nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (fresh_subs?_alpha_aux formula-decl nil substitution nil)
    (x const-decl "[fresh_context, bool]" freshness nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (fresh_subs?_null formula-decl nil substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (Subs def-decl "term" substitution nil)
    (alpha def-decl "bool" alpha_equivalence nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fresh_context type-eq-decl nil freshness nil)
    (Sub type-eq-decl nil substitution nil))
   nil)
  (fresh_subs?_alpha-1 nil 3629186321
   ("" (induct sigma)
    (("1" (grind) nil nil)
     ("2" (grind)
      (("2" (rewrite fresh_subs?_null) (("2" (assert) nil nil)) nil))
      nil)
     ("3" (skolem 1 (head tail))
      (("3" (prop)
        (("3" (skeep)
          (("3" (expand Subs 1)
            (("3"
              (case "cons(head,tail) = append(cons(head,null),tail)")
              (("1" (replaces -1)
                (("1" (rewrite fresh_subs?_append)
                  (("1" (expand x -2)
                    (("1" (prop)
                      (("1" (expand x)
                        (("1" (assert)
                          (("1" (inst -3 Delta s t)
                            (("1" (assert)
                              (("1"
                                (lemma
                                 fresh_subs?_alpha_aux
                                 (X
                                  "head`1"
                                  u
                                  "head`2"
                                  t
                                  "Subs(tail)(t)"
                                  s
                                  "Subs(tail)(s)"
                                  Delta
                                  "fresh_subs?(tail, Delta)`1"))
                                (("1"
                                  (rewrite append_null)
                                  (("1"
                                    (case
                                     "(: (head`1, head`2) :) = cons(head, null)")
                                    (("1"
                                      (replaces -1)
                                      (("1" (assert) nil nil))
                                      nil)
                                     ("2"
                                      (decompose-equality 1)
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand append 1)
                (("2" (expand append 1) (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (fresh_subs?_append formula-decl nil substitution nil)
    (append_null formula-decl nil list_props nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (fresh_subs?_alpha_aux formula-decl nil substitution nil)
    (x const-decl "[fresh_context, bool]" freshness nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (fresh_subs?_null formula-decl nil substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (variable type-eq-decl nil nominal_term nil)
    (atom type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (Subs def-decl "term" substitution nil)
    (alpha def-decl "bool" alpha_equivalence nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fresh_context type-eq-decl nil freshness nil)
    (Sub type-eq-decl nil substitution nil))
   shostak))
 (fresh_subs?_complete 0
  (fresh_subs?_complete-2 nil 3745918418
   ("" (induct "Nabla")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep*)
      (("3" (expand "fresh_subs?" 1)
        (("3" (expand "fresh_subs" -2)
          (("3" (expand "x")
            (("3" (flatten)
              (("3" (lift-if)
                (("3"
                  (lemma "fresh?_complete"
                   ("Delta" "Delta" "a" "cons1_var`1" "t"
                    "Subs(sigma)((: :) * cons1_var`2)"))
                  (("3" (inst -2 "Delta" "sigma")
                    (("3" (assert)
                      (("3" (assert)
                        (("3" (flatten)
                          (("3" (assert)
                            (("3" (skeep)
                              (("3"
                                (rewrite "append_member")
                                (("3"
                                  (split)
                                  (("1"
                                    (inst -3 "a" "X")
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (inst -5 "a" "X")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (fresh?_complete formula-decl nil freshness nil)
    (append_member formula-decl nil structure_extra nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (x const-decl "[fresh_context, bool]" freshness nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (member def-decl "bool" list_props nil)
    (fresh_subs def-decl "bool" substitution nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   nil)
  (fresh_subs?_complete-1 nil 3630822824
   ("" (induct Nabla)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep*)
      (("3" (expand fresh_subs? 1)
        (("3" (expand fresh_subs -2)
          (("3" (expand x)
            (("3" (flatten)
              (("3" (lift-if)
                (("3"
                  (lemma fresh?_complete
                   (Delta Delta a "cons1_var`1" t
                    "Subs(sigma)((: :) * cons1_var`2)"))
                  (("3" (inst -2 Delta sigma)
                    (("3" (assert)
                      (("3" (assert)
                        (("3" (flatten)
                          (("3" (assert)
                            (("3" (skeep)
                              (("3"
                                (rewrite append_member)
                                (("3"
                                  (split)
                                  (("1"
                                    (inst -3 a X)
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (inst -5 a X)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (fresh?_complete formula-decl nil freshness nil)
    (append_member formula-decl nil structure_extra nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (x const-decl "[fresh_context, bool]" freshness nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (member def-decl "bool" list_props nil)
    (fresh_subs def-decl "bool" substitution nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   shostak))
 (fresh_subs?_is_fresh_subs 0
  (fresh_subs?_is_fresh_subs-2 nil 3745918506
   ("" (skeep)
    (("" (assert)
      (("" (flatten)
        (("" (rewrite "fresh_subs_character")
          (("" (skeep)
            ((""
              (lemma "fresh_subs?_is_fresh2"
               ("sigma" "sigma" "Delta" "Nabla" "a" "ax`1" "t"
                "(: :) * ax`2"))
              (("" (assert)
                (("" (assert)
                  (("" (expand "fresh" 1)
                    (("" (expand* "reverse" "act")
                      (("" (case "ax = (ax`1, ax`2)")
                        (("1" (replace -1 -3) (("1" (propax) nil nil))
                          nil)
                         ("2" (decompose-equality 1) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fresh_subs_character formula-decl nil substitution nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (list type-decl nil list_adt nil)
    (fresh_context type-eq-decl nil freshness nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (fresh_subs?_is_fresh2 formula-decl nil substitution nil)
    (act def-decl "atom" atoms nil)
    (reverse def-decl "list[T]" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (fresh def-decl "bool" freshness nil))
   nil)
  (fresh_subs?_is_fresh_subs-1 nil 3630930960
   ("" (skeep)
    (("" (assert)
      (("" (flatten)
        (("" (rewrite fresh_subs_character)
          (("" (skeep)
            ((""
              (lemma fresh_subs?_is_fresh2
               (sigma sigma Delta Nabla a "ax`1" t "(: :) * ax`2"))
              (("" (assert)
                (("" (assert)
                  (("" (expand fresh 1)
                    (("" (expand* reverse act)
                      (("" (case "ax = (ax`1, ax`2)")
                        (("1" (replace -1 -3) (("1" (propax) nil nil))
                          nil)
                         ("2" (decompose-equality 1) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fresh_subs_character formula-decl nil substitution nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (list type-decl nil list_adt nil)
    (fresh_context type-eq-decl nil freshness nil)
    (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (fresh_subs?_is_fresh2 formula-decl nil substitution nil)
    (act def-decl "atom" atoms nil)
    (reverse def-decl "list[T]" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (fresh def-decl "bool" freshness nil))
   shostak))
 (fresh_subs_o_fresh_subs? 0
  (fresh_subs_o_fresh_subs?-2 nil 3745918859
   ("" (induct "Nabla")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("ax" "Nabla"))
      (("2" (prop)
        (("2" (skeep)
          (("2" (expand "fresh_subs?" 1)
            (("2" (expand "x")
              (("2" (lift-if)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (expand "fresh_subs" 1 1)
                      (("1" (rewrite "fresh_subs_append_context")
                        (("1" (inst -3 "Delta" "gamma" "sigma")
                          (("1" (iff 1)
                            (("1" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (hide -2 -4 -5)
                                      (("1"
                                        (rewrite "Subs_append")
                                        (("1"
                                          (lemma
                                           "fresh?_complete"
                                           ("Delta"
                                            "Delta"
                                            "a"
                                            "ax`1"
                                            "t"
                                            "Subs(sigma)(Subs(gamma)((: :) * ax`2))"))
                                          (("1"
                                            (assert)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (lemma
                                                   "fresh_subs?_is_fresh3"
                                                   ("a"
                                                    "ax`1"
                                                    "sigma"
                                                    "sigma"
                                                    "t"
                                                    "Subs(gamma)((: :) * ax`2)"))
                                                  (("1"
                                                    (expand "x")
                                                    (("1"
                                                      (rewrite
                                                       "append_null")
                                                      (("1"
                                                        (lift-if)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (prop)
                                                            (("1"
                                                              (replaces
                                                               -2)
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (lemma
                                                                   "fresh_subs?_is_fresh_subs"
                                                                   ("sigma"
                                                                    "sigma"
                                                                    "Nabla"
                                                                    "fresh?(ax`1, Subs(gamma)((: :) * ax`2))`1"))
                                                                  (("1"
                                                                    (lemma
                                                                     "fresh_subs_weakening"
                                                                     ("Delta"
                                                                      "fresh?(ax`1, Subs(gamma)((: :) * ax`2))`1"
                                                                      "Nabla2"
                                                                      "Delta"
                                                                      "sigma"
                                                                      "sigma"
                                                                      "Nabla1"
                                                                      "fresh_subs?(sigma, fresh?(ax`1, Subs(gamma)((: :) * ax`2))`1)`1"))
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (assert)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (hide -2 -4 -5)
                                      (("2"
                                        (rewrite "Subs_append")
                                        (("2"
                                          (lemma
                                           "fresh_subs?_complete"
                                           ("Delta"
                                            "Delta"
                                            "sigma"
                                            "sigma"
                                            "Nabla"
                                            "fresh?(ax`1, Subs(gamma)((: :) * ax`2))`1"))
                                          (("2"
                                            (assert)
                                            (("2"
                                              (flatten)
                                              (("2"
                                                (lemma
                                                 "fresh_subs?_is_fresh3"
                                                 ("sigma"
                                                  "sigma"
                                                  "a"
                                                  "ax`1"
                                                  "t"
                                                  "Subs(gamma)((: :) * ax`2)"))
                                                (("2"
                                                  (expand "x")
                                                  (("2"
                                                    (rewrite
                                                     "append_null")
                                                    (("2"
                                                      (lift-if)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (lemma
                                                           "fresh?_is_fresh"
                                                           ("Delta"
                                                            "fresh?(ax`1, Subs(sigma)(Subs(gamma)((: :) * ax`2)))`1"
                                                            "a"
                                                            "ax`1"
                                                            "t"
                                                            "Subs(sigma)(Subs(gamma)((: :) * ax`2))"))
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (lemma
                                                               "fresh_weakening"
                                                               ("Nabla"
                                                                "Delta"
                                                                "Delta"
                                                                "fresh?(ax`1, Subs(sigma)(Subs(gamma)((: :) * ax`2)))`1"
                                                                "a"
                                                                "ax`1"
                                                                "t"
                                                                "Subs(sigma)(Subs(gamma)((: :) * ax`2))"))
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (split)
                                                                  (("1"
                                                                    (replace
                                                                     -2
                                                                     1)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (propax)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (expand "fresh_subs" 2)
                      (("2" (flatten)
                        (("2" (rewrite "Subs_append")
                          (("2"
                            (lemma "fresh?_complete"
                             ("Delta" "Delta" "a" "ax`1" "t"
                              "Subs(sigma)(Subs(gamma)((: :) * ax`2))"))
                            (("2" (assert)
                              (("2"
                                (assert)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (lemma
                                     "Subs_fresh"
                                     ("a"
                                      "ax`1"
                                      "sigma"
                                      "sigma"
                                      "t"
                                      "Subs(gamma)((: :) * ax`2)"))
                                    (("2"
                                      (assert)
                                      (("2"
                                        (rewrite
                                         "fresh_subs?_character")
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (rewrite
                                             "fresh_subs_character"
                                             -6)
                                            (("2"
                                              (inst -6 "(a, X)")
                                              (("2"
                                                (rewrite "Subs_append")
                                                (("2"
                                                  (lemma
                                                   "fresh?_complete"
                                                   ("Delta"
                                                    "Delta"
                                                    "a"
                                                    "a"
                                                    "t"
                                                    "Subs(sigma)(Subs(gamma)((: :) * X))"))
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (flatten)
                                                        (("2"
                                                          (lemma
                                                           "Subs_fresh"
                                                           ("a"
                                                            "a"
                                                            "sigma"
                                                            "sigma"
                                                            "t"
                                                            "Subs(gamma)((: :) * X)"))
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((x const-decl "[fresh_context, bool]" freshness nil)
    (fresh?_complete formula-decl nil freshness nil)
    (fresh_subs?_is_fresh3 formula-decl nil substitution nil)
    (append_null formula-decl nil list_props nil)
    (fresh_subs?_is_fresh_subs formula-decl nil substitution nil)
    (fresh_subs_weakening formula-decl nil substitution nil)
    (Subs_append formula-decl nil substitution nil)
    (fresh_subs?_complete formula-decl nil substitution nil)
    (fresh?_is_fresh formula-decl nil freshness nil)
    (fresh_weakening formula-decl nil freshness nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (fresh_subs_append_context formula-decl nil substitution nil)
    (fresh_subs_character formula-decl nil substitution nil)
    (fresh_subs?_character formula-decl nil substitution nil)
    (Subs_fresh formula-decl nil substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (append def-decl "list[T]" list_props nil)
    (fresh_subs def-decl "bool" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   nil)
  (fresh_subs_o_fresh_subs?-1 nil 3630845349
   ("" (induct Nabla)
    (("1" (grind) nil nil)
     ("2" (skolem 1 (ax Nabla))
      (("2" (prop)
        (("2" (skeep)
          (("2" (expand fresh_subs? 1)
            (("2" (expand x)
              (("2" (lift-if)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (expand fresh_subs 1 1)
                      (("1" (rewrite fresh_subs_append_context)
                        (("1" (inst -3 Delta gamma sigma)
                          (("1" (iff 1)
                            (("1" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (hide -2 -4 -5)
                                      (("1"
                                        (rewrite Subs_append)
                                        (("1"
                                          (lemma
                                           fresh?_complete
                                           (Delta
                                            Delta
                                            a
                                            "ax`1"
                                            t
                                            "Subs(sigma)(Subs(gamma)((: :) * ax`2))"))
                                          (("1"
                                            (assert)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (lemma
                                                   fresh_subs?_is_fresh3
                                                   (a
                                                    "ax`1"
                                                    sigma
                                                    sigma
                                                    t
                                                    "Subs(gamma)((: :) * ax`2)"))
                                                  (("1"
                                                    (expand x)
                                                    (("1"
                                                      (rewrite
                                                       append_null)
                                                      (("1"
                                                        (lift-if)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (prop)
                                                            (("1"
                                                              (replaces
                                                               -2)
                                                              (("1"
                                                                (assert)
                                                                (("1"
                                                                  (lemma
                                                                   fresh_subs?_is_fresh_subs
                                                                   (sigma
                                                                    sigma
                                                                    Nabla
                                                                    "fresh?(ax`1, Subs(gamma)((: :) * ax`2))`1"))
                                                                  (("1"
                                                                    (lemma
                                                                     fresh_subs_weakening
                                                                     (Delta
                                                                      "fresh?(ax`1, Subs(gamma)((: :) * ax`2))`1"
                                                                      Nabla2
                                                                      Delta
                                                                      sigma
                                                                      sigma
                                                                      Nabla1
                                                                      "fresh_subs?(sigma, fresh?(ax`1, Subs(gamma)((: :) * ax`2))`1)`1"))
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (assert)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (hide -2 -4 -5)
                                      (("2"
                                        (rewrite Subs_append)
                                        (("2"
                                          (lemma
                                           fresh_subs?_complete
                                           (Delta
                                            Delta
                                            sigma
                                            sigma
                                            Nabla
                                            "fresh?(ax`1, Subs(gamma)((: :) * ax`2))`1"))
                                          (("2"
                                            (assert)
                                            (("2"
                                              (flatten)
                                              (("2"
                                                (lemma
                                                 fresh_subs?_is_fresh3
                                                 (sigma
                                                  sigma
                                                  a
                                                  "ax`1"
                                                  t
                                                  "Subs(gamma)((: :) * ax`2)"))
                                                (("2"
                                                  (expand x)
                                                  (("2"
                                                    (rewrite
                                                     append_null)
                                                    (("2"
                                                      (lift-if)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (lemma
                                                           fresh?_is_fresh
                                                           (Delta
                                                            "fresh?(ax`1, Subs(sigma)(Subs(gamma)((: :) * ax`2)))`1"
                                                            a
                                                            "ax`1"
                                                            t
                                                            "Subs(sigma)(Subs(gamma)((: :) * ax`2))"))
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (lemma
                                                               fresh_weakening
                                                               (Nabla
                                                                Delta
                                                                Delta
                                                                "fresh?(ax`1, Subs(sigma)(Subs(gamma)((: :) * ax`2)))`1"
                                                                a
                                                                "ax`1"
                                                                t
                                                                "Subs(sigma)(Subs(gamma)((: :) * ax`2))"))
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (split)
                                                                  (("1"
                                                                    (replace
                                                                     -2
                                                                     1)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (propax)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (expand fresh_subs 2)
                      (("2" (flatten)
                        (("2" (rewrite Subs_append)
                          (("2"
                            (lemma fresh?_complete
                             (Delta Delta a "ax`1" t
                              "Subs(sigma)(Subs(gamma)((: :) * ax`2))"))
                            (("2" (assert)
                              (("2"
                                (assert)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (lemma
                                     Subs_fresh
                                     (a
                                      "ax`1"
                                      sigma
                                      sigma
                                      t
                                      "Subs(gamma)((: :) * ax`2)"))
                                    (("2"
                                      (assert)
                                      (("2"
                                        (rewrite fresh_subs?_character)
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (rewrite
                                             fresh_subs_character
                                             -6)
                                            (("2"
                                              (inst -6 "(a, X)")
                                              (("2"
                                                (rewrite Subs_append)
                                                (("2"
                                                  (lemma
                                                   fresh?_complete
                                                   (Delta
                                                    Delta
                                                    a
                                                    a
                                                    t
                                                    "Subs(sigma)(Subs(gamma)((: :) * X))"))
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (flatten)
                                                        (("2"
                                                          (lemma
                                                           Subs_fresh
                                                           (a
                                                            a
                                                            sigma
                                                            sigma
                                                            t
                                                            "Subs(gamma)((: :) * X)"))
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((x const-decl "[fresh_context, bool]" freshness nil)
    (fresh?_complete formula-decl nil freshness nil)
    (fresh_subs?_is_fresh3 formula-decl nil substitution nil)
    (append_null formula-decl nil list_props nil)
    (fresh_subs?_is_fresh_subs formula-decl nil substitution nil)
    (fresh_subs_weakening formula-decl nil substitution nil)
    (Subs_append formula-decl nil substitution nil)
    (fresh_subs?_complete formula-decl nil substitution nil)
    (fresh?_is_fresh formula-decl nil freshness nil)
    (fresh_weakening formula-decl nil freshness nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (fresh? def-decl "[fresh_context, bool]" freshness nil)
    (fresh_subs_append_context formula-decl nil substitution nil)
    (fresh_subs_character formula-decl nil substitution nil)
    (fresh_subs?_character formula-decl nil substitution nil)
    (Subs_fresh formula-decl nil substitution nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (fresh_subs? def-decl "[fresh_context, bool]" substitution nil)
    (append def-decl "list[T]" list_props nil)
    (fresh_subs def-decl "bool" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil)
    (fresh_context type-eq-decl nil freshness nil)
    (list type-decl nil list_adt nil))
   shostak))
 (not_occurs_subs_invariance 0
  (not_occurs_subs_invariance-2 nil 3745918910
   ("" (induct "t")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (occurs def-decl "bool" nominal_term nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   nil)
  (not_occurs_subs_invariance-1 nil 3627028059
   ("" (induct t)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (occurs def-decl "bool" nominal_term nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   shostak))
 (Vars_subs_subset 0
  (Vars_subs_subset-2 nil 3745918943
   ("" (skolem 1 ("X" "_" "t"))
    (("" (induct "s")
      (("1" (grind) nil nil)
       ("2" (grind) (("2" (rewrite "ext_preserves_Vars") nil nil)) nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (occurs def-decl "bool" nominal_term nil)
    (set type-eq-decl nil sets nil)
    (subset? const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Vars def-decl "finite_set[variable]" nominal_term nil)
    (subs def-decl "term" substitution nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (variable type-eq-decl nil nominal_term nil)
    (perm type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (atom type-eq-decl nil atoms nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (term_induction formula-decl nil term_adt nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (ext_preserves_Vars formula-decl nil nominal_term nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (singleton const-decl "(singleton?)" sets nil)
    (union const-decl "set" sets nil))
   nil)
  (Vars_subs_subset-1 nil 3627038574
   ("" (skolem 1 (X "_" t))
    (("" (induct s)
      (("1" (grind) nil nil)
       ("2" (grind) (("2" (rewrite ext_preserves_Vars) nil nil)) nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (occurs def-decl "bool" nominal_term nil)
    (set type-eq-decl nil sets nil)
    (subset? const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Vars def-decl "finite_set[variable]" nominal_term nil)
    (subs def-decl "term" substitution nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (variable type-eq-decl nil nominal_term nil)
    (perm type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (atom type-eq-decl nil atoms nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (term_induction formula-decl nil term_adt nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (ext_preserves_Vars formula-decl nil nominal_term nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (singleton const-decl "(singleton?)" sets nil)
    (union const-decl "set" sets nil))
   shostak))
 (Vars_union 0
  (Vars_union-2 nil 3745919063
   ("" (skolem 1 ("X" "_" "t"))
    (("" (induct "s")
      (("1" (grind) nil nil)
       ("2" (grind)
        (("2" (rewrite "ext_preserves_Vars")
          (("2" (expand* "singleton" "union" "remove" "member")
            (("2" (decompose-equality)
              (("2" (iff)
                (("2" (rewrite "Vars_occurs") (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil)
       ("4" (grind)
        (("1" (hide-all-but 2)
          (("1" (expand* "union" "remove")
            (("1" (decompose-equality)
              (("1" (iff) (("1" (grind) nil nil)) nil)) nil))
            nil))
          nil)
         ("2" (lemma "Vars_occurs" ("X" "X" "t" "pair2_var!1"))
          (("2" (assert)
            (("2" (rewrite "not_occurs_subs_invariance" 4)
              (("2" (hide-all-but (1 4))
                (("2" (expand* "union" "remove")
                  (("2" (decompose-equality)
                    (("2" (iff) (("2" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (rewrite "not_occurs_subs_invariance" 3)
          (("3" (lemma "Vars_occurs" ("X" "X" "t" "pair1_var!1"))
            (("3" (assert)
              (("3" (hide-all-but (1 4))
                (("3" (expand* "union" "remove")
                  (("3" (decompose-equality)
                    (("3" (iff) (("3" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (occurs def-decl "bool" nominal_term nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Vars def-decl "finite_set[variable]" nominal_term nil)
    (subs def-decl "term" substitution nil)
    (remove const-decl "set" sets nil)
    (Vars const-decl "finite_set[variable]" substitution nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (variable type-eq-decl nil nominal_term nil)
    (perm type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (atom type-eq-decl nil atoms nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (term_induction formula-decl nil term_adt nil)
    (ext_preserves_Vars formula-decl nil nominal_term nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (Vars_occurs formula-decl nil nominal_term nil)
    (singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (nonempty_finite_union2 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_remove application-judgement "finite_set" finite_sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (not_occurs_subs_invariance formula-decl nil substitution nil)
    (finite_union application-judgement "finite_set" finite_sets nil))
   nil)
  (Vars_union-1 nil 3627039855
   ("" (skolem 1 (X "_" t))
    (("" (induct s)
      (("1" (grind) nil nil)
       ("2" (grind)
        (("2" (rewrite ext_preserves_Vars)
          (("2" (expand* singleton union remove member)
            (("2" (decompose-equality)
              (("2" (iff)
                (("2" (rewrite Vars_occurs) (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil)
       ("4" (grind)
        (("1" (hide-all-but 2)
          (("1" (expand* union remove)
            (("1" (decompose-equality)
              (("1" (iff) (("1" (grind) nil nil)) nil)) nil))
            nil))
          nil)
         ("2" (lemma Vars_occurs (X X t "pair2_var!1"))
          (("2" (assert)
            (("2" (rewrite not_occurs_subs_invariance 4)
              (("2" (hide-all-but (1 4))
                (("2" (expand* union remove)
                  (("2" (decompose-equality)
                    (("2" (iff) (("2" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (rewrite not_occurs_subs_invariance 3)
          (("3" (lemma Vars_occurs (X X t "pair1_var!1"))
            (("3" (assert)
              (("3" (hide-all-but (1 4))
                (("3" (expand* union remove)
                  (("3" (decompose-equality)
                    (("3" (iff) (("3" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((term type-decl nil term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (occurs def-decl "bool" nominal_term nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Vars def-decl "finite_set[variable]" nominal_term nil)
    (subs def-decl "term" substitution nil)
    (remove const-decl "set" sets nil)
    (Vars const-decl "finite_set[variable]" substitution nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (variable type-eq-decl nil nominal_term nil)
    (perm type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (atom type-eq-decl nil atoms nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (term_induction formula-decl nil term_adt nil)
    (ext_preserves_Vars formula-decl nil nominal_term nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (Vars_occurs formula-decl nil nominal_term nil)
    (singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (nonempty_finite_union2 application-judgement
     "non_empty_finite_set" finite_sets nil)
    (finite_remove application-judgement "finite_set" finite_sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (not_occurs_subs_invariance formula-decl nil substitution nil)
    (finite_union application-judgement "finite_set" finite_sets nil))
   shostak))
 (Subs_unif_Vars_subset 0
  (Subs_unif_Vars_subset-2 nil 3745919244
   ("" (skolem 1 ("s" "t" "u" "w" "_"))
    (("" (induct "gamma")
      (("1" (grind) nil nil)
       ("2" (skolem 1 ("head" "tail"))
        (("2" (flatten)
          (("2" (expand "Subs" 1)
            (("2" (case "head = (head`1, head`2)")
              (("1" (typepred "head")
                (("1" (replaces -2)
                  (("1" (expand "Vars_in")
                    (("1" (case "NOT occurs(head`1, Subs(tail)(w))")
                      (("1" (rewrite "not_occurs_subs_invariance")
                        (("1"
                          (case "NOT occurs(head`1, Subs(tail)(t))")
                          (("1" (rewrite not_occurs_subs_invariance)
                            nil nil)
                           ("2"
                            (lemma "Vars_union"
                             ("X" "head`1" "s" "Subs(tail)(t)" "t"
                              "head`2"))
                            (("2" (assert)
                              (("2"
                                (expand "Vars" (-4 3))
                                (("2"
                                  (expand "Vars" -3 2)
                                  (("2"
                                    (expand "Vars" -1 2)
                                    (("2"
                                      (replaces -1)
                                      (("2"
                                        (expand*
                                         "subset?"
                                         "union"
                                         "remove"
                                         "member")
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (inst -2 "x")
                                            (("2"
                                              (inst -4 "x")
                                              (("2" (prop) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2"
                        (lemma "Vars_union"
                         ("X" "head`1" "s" "Subs(tail)(w)" "t"
                          "head`2"))
                        (("2"
                          (lemma "Vars_union"
                           ("X" "head`1" "s" "Subs(tail)(t)" "t"
                            "head`2"))
                          (("2" (assert)
                            (("2" (expand "Vars" -1 2)
                              (("2"
                                (expand "Vars" -2 2)
                                (("2"
                                  (expand "Vars" -4 2)
                                  (("2"
                                    (expand "Vars" (-5 2))
                                    (("2"
                                      (replaces -2)
                                      (("2"
                                        (split -1)
                                        (("1"
                                          (replaces -1)
                                          (("1"
                                            (expand*
                                             "subset?"
                                             "union"
                                             "remove"
                                             "member")
                                            (("1"
                                              (skeep)
                                              (("1"
                                                (inst -2 "x")
                                                (("1"
                                                  (inst -4 "x")
                                                  (("1"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (rewrite
                                           "not_occurs_subs_invariance")
                                          (("2"
                                            (expand*
                                             "subset?"
                                             "union"
                                             "remove"
                                             "member")
                                            (("2"
                                              (skeep)
                                              (("2"
                                                (inst -2 "x")
                                                (("2"
                                                  (inst -4 "x")
                                                  (("2"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (decompose-equality 1) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every adt-def-decl "boolean" list_adt nil)
    (Subs_unif type-eq-decl nil substitution nil)
    (set type-eq-decl nil sets nil)
    (subset? const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Vars const-decl "finite_set[variable]" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (Subs def-decl "term" substitution nil)
    (union const-decl "set" sets nil)
    (occurs def-decl "bool" nominal_term nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Vars_in const-decl "bool" substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list_induction formula-decl nil list_adt nil)
    (member const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (remove const-decl "set" sets nil)
    (Vars_union formula-decl nil substitution nil)
    (not_occurs_subs_invariance formula-decl nil substitution nil))
   nil)
  (Subs_unif_Vars_subset-1 nil 3627124932
   ("" (skolem 1 (s t u w "_"))
    (("" (induct gamma)
      (("1" (grind) nil nil)
       ("2" (skolem 1 (head tail))
        (("2" (flatten)
          (("2" (expand Subs 1)
            (("2" (case "head = (head`1, head`2)")
              (("1" (typepred head)
                (("1" (replaces -2)
                  (("1" (expand Vars_in)
                    (("1" (case "NOT occurs(head`1, Subs(tail)(w))")
                      (("1" (rewrite not_occurs_subs_invariance)
                        (("1"
                          (case "NOT occurs(head`1, Subs(tail)(t))")
                          (("1" (rewrite not_occurs_subs_invariance)
                            nil nil)
                           ("2"
                            (lemma Vars_union
                             (X "head`1" s "Subs(tail)(t)" t "head`2"))
                            (("2" (assert)
                              (("2"
                                (expand Vars (-4 3))
                                (("2"
                                  (expand Vars -3 2)
                                  (("2"
                                    (expand Vars -1 2)
                                    (("2"
                                      (replaces -1)
                                      (("2"
                                        (expand*
                                         subset?
                                         union
                                         remove
                                         member)
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (inst -2 x)
                                            (("2"
                                              (inst -4 x)
                                              (("2" (prop) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2"
                        (lemma Vars_union
                         (X "head`1" s "Subs(tail)(w)" t "head`2"))
                        (("2"
                          (lemma Vars_union
                           (X "head`1" s "Subs(tail)(t)" t "head`2"))
                          (("2" (assert)
                            (("2" (expand Vars -1 2)
                              (("2"
                                (expand Vars -2 2)
                                (("2"
                                  (expand Vars -4 2)
                                  (("2"
                                    (expand Vars (-5 2))
                                    (("2"
                                      (replaces -2)
                                      (("2"
                                        (split -1)
                                        (("1"
                                          (replaces -1)
                                          (("1"
                                            (expand*
                                             subset?
                                             union
                                             remove
                                             member)
                                            (("1"
                                              (skeep)
                                              (("1"
                                                (inst -2 x)
                                                (("1"
                                                  (inst -4 x)
                                                  (("1"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (rewrite
                                           not_occurs_subs_invariance)
                                          (("2"
                                            (expand*
                                             subset?
                                             union
                                             remove
                                             member)
                                            (("2"
                                              (skeep)
                                              (("2"
                                                (inst -2 x)
                                                (("2"
                                                  (inst -4 x)
                                                  (("2"
                                                    (prop)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (decompose-equality 1) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Subs_unif type-eq-decl nil substitution nil)
    (set type-eq-decl nil sets nil)
    (subset? const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Vars const-decl "finite_set[variable]" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (Subs def-decl "term" substitution nil)
    (union const-decl "set" sets nil)
    (occurs def-decl "bool" nominal_term nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Vars_in const-decl "bool" substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list_induction formula-decl nil list_adt nil)
    (member const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (remove const-decl "set" sets nil)
    (Vars_union formula-decl nil substitution nil)
    (not_occurs_subs_invariance formula-decl nil substitution nil))
   shostak))
 (Subs_unif_Vars_decrease 0
  (Subs_unif_Vars_decrease-2 nil 3745919600
   ("" (skosimp)
    (("" (expand "Id")
      (("" (expand "Subs")
        (("" (assert)
          (("" (name-replace "head" "car(gamma!1)")
            (("" (name-replace "tail" "cdr(gamma!1)")
              (("" (case "head = (head`1,head`2)")
                (("1" (replaces -1)
                  (("1" (typepred "head")
                    (("1" (expand "Vars_in")
                      (("1" (flatten)
                        (("1"
                          (lemma "Subs_unif_Vars_subset"
                           ("u" "u!1" "s" "s!1" "t" "t!1" "w" "w!1"
                            "gamma" "tail"))
                          (("1" (expand "Vars" (-1 3))
                            (("1"
                              (lemma "Vars_occurs"
                               ("X" "head`1" "t" "Subs(tail)(w!1)"))
                              (("1"
                                (lemma
                                 "Vars_occurs"
                                 ("X" "head`1" "t" "Subs(tail)(t!1)"))
                                (("1"
                                  (lemma
                                   "Vars_occurs"
                                   ("X" "head`1" "t" "s!1"))
                                  (("1"
                                    (lemma
                                     "Vars_occurs"
                                     ("X" "head`1" "t" "u!1"))
                                    (("1"
                                      (expand "Vars" -6 2)
                                      (("1"
                                        (case
                                         "subset?(union(Vars(subs(head`1, head`2)(Subs(tail)(w!1))),Vars(subs(head`1, head`2)(Subs(tail)(t!1)))),
                                        remove(head`1, union(union(Vars(u!1), Vars(s!1)), union(Vars(w!1), Vars(t!1)))))")
                                        (("1"
                                          (lemma
                                           "card_subset"
                                           ("A"
                                            "union(Vars(subs(head`1, head`2)(Subs(tail)(w!1))),
                                           Vars(subs(head`1, head`2)(Subs(tail)(t!1))))"
                                            "B"
                                            "remove(head`1, union(union(Vars(u!1), Vars(s!1)),
                                                  union(Vars(w!1), Vars(t!1))))"))
                                          (("1"
                                            (rewrite "card_remove")
                                            (("1"
                                              (expand
                                               "union"
                                               -1
                                               (9 10))
                                              (("1"
                                                (expand "member")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (prop)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide 4)
                                          (("2"
                                            (lemma
                                             "Vars_union"
                                             ("X"
                                              "head`1"
                                              "t"
                                              "head`2"
                                              "s"
                                              "Subs(tail)(w!1)"))
                                            (("2"
                                              (lemma
                                               "Vars_union"
                                               ("X"
                                                "head`1"
                                                "t"
                                                "head`2"
                                                "s"
                                                "Subs(tail)(t!1)"))
                                              (("2"
                                                (case
                                                 "occurs(head`1, Subs(tail)(t!1))")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (replaces -2)
                                                    (("1"
                                                      (case
                                                       "occurs(head`1, Subs(tail)(w!1))")
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (replaces -3)
                                                          (("1"
                                                            (hide-all-but
                                                             (-6 -7 1))
                                                            (("1"
                                                              (expand*
                                                               "subset?"
                                                               "union"
                                                               "remove"
                                                               "member")
                                                              (("1"
                                                                (skeep)
                                                                (("1"
                                                                  (inst
                                                                   -2
                                                                   "x")
                                                                  (("1"
                                                                    (inst
                                                                     -3
                                                                     "x")
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (rewrite
                                                         "not_occurs_subs_invariance")
                                                        (("2"
                                                          (hide-all-but
                                                           (-6
                                                            -7
                                                            -8
                                                            1
                                                            2))
                                                          (("2"
                                                            (expand*
                                                             "remove"
                                                             "union"
                                                             "subset?"
                                                             "member")
                                                            (("2"
                                                              (skeep)
                                                              (("2"
                                                                (inst
                                                                 -3
                                                                 "x_1")
                                                                (("2"
                                                                  (inst
                                                                   -4
                                                                   "x_1")
                                                                  (("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (rewrite
                                                   "not_occurs_subs_invariance")
                                                  (("2"
                                                    (case
                                                     "occurs(head`1, Subs(tail)(w!1))")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (replaces -3)
                                                        (("1"
                                                          (hide-all-but
                                                           (-5 -6 2 3))
                                                          (("1"
                                                            (expand*
                                                             "union"
                                                             "remove"
                                                             "subset?"
                                                             "member")
                                                            (("1"
                                                              (skeep)
                                                              (("1"
                                                                (inst
                                                                 -2
                                                                 "x_1")
                                                                (("1"
                                                                  (inst
                                                                   -3
                                                                   "x_1")
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (rewrite
                                                       "not_occurs_subs_invariance")
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (hide-all-but
                                                           (-5
                                                            -6
                                                            3
                                                            4
                                                            5))
                                                          (("2"
                                                            (expand*
                                                             "remove"
                                                             "union"
                                                             "subset?"
                                                             "member")
                                                            (("2"
                                                              (skeep)
                                                              (("2"
                                                                (inst
                                                                 -2
                                                                 "x_1")
                                                                (("2"
                                                                  (inst
                                                                   -3
                                                                   "x_1")
                                                                  (("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (decompose-equality 1) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Id const-decl "Sub" substitution nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (Subs_unif_Vars_subset formula-decl nil substitution nil)
    (Vars_occurs formula-decl nil nominal_term nil)
    (Sub type-eq-decl nil substitution nil)
    (/= const-decl "boolean" notequal nil)
    (not_occurs_subs_invariance formula-decl nil substitution nil)
    (Vars_union formula-decl nil substitution nil)
    (card_subset formula-decl nil finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (card_remove formula-decl nil finite_sets nil)
    (remove const-decl "set" sets nil)
    (subs def-decl "term" substitution nil)
    (Vars def-decl "finite_set[variable]" nominal_term nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (union const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (finite_remove application-judgement "finite_set" finite_sets nil)
    (Vars const-decl "finite_set[variable]" substitution nil)
    (Subs_unif type-eq-decl nil substitution nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (occurs def-decl "bool" nominal_term nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Vars_in const-decl "bool" substitution nil)
    (every adt-def-decl "boolean" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Subs def-decl "term" substitution nil))
   nil)
  (Subs_unif_Vars_decrease-1 nil 3627047767
   ("" (skosimp)
    (("" (expand Id)
      (("" (expand Subs)
        (("" (assert)
          (("" (name-replace head "car(gamma!1)")
            (("" (name-replace tail "cdr(gamma!1)")
              (("" (case "head = (head`1,head`2)")
                (("1" (replaces -1)
                  (("1" (typepred head)
                    (("1" (expand Vars_in)
                      (("1" (flatten)
                        (("1"
                          (lemma Subs_unif_Vars_subset
                           (u u!1 s s!1 t t!1 w w!1 gamma tail))
                          (("1" (expand Vars (-1 3))
                            (("1"
                              (lemma Vars_occurs
                               (X "head`1" t "Subs(tail)(w!1)"))
                              (("1"
                                (lemma
                                 Vars_occurs
                                 (X "head`1" t "Subs(tail)(t!1)"))
                                (("1"
                                  (lemma
                                   Vars_occurs
                                   (X "head`1" t "s!1"))
                                  (("1"
                                    (lemma
                                     Vars_occurs
                                     (X "head`1" t "u!1"))
                                    (("1"
                                      (expand Vars -6 2)
                                      (("1"
                                        (case
                                         "subset?(union(Vars(subs(head`1, head`2)(Subs(tail)(w!1))),Vars(subs(head`1, head`2)(Subs(tail)(t!1)))),
                               remove(head`1, union(union(Vars(u!1), Vars(s!1)), union(Vars(w!1), Vars(t!1)))))")
                                        (("1"
                                          (lemma
                                           card_subset
                                           (A
                                            "union(Vars(subs(head`1, head`2)(Subs(tail)(w!1))),
                                    Vars(subs(head`1, head`2)(Subs(tail)(t!1))))"
                                            B
                                            "remove(head`1, union(union(Vars(u!1), Vars(s!1)),
                                           union(Vars(w!1), Vars(t!1))))"))
                                          (("1"
                                            (rewrite card_remove)
                                            (("1"
                                              (expand union -1 (9 10))
                                              (("1"
                                                (expand member)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (prop)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide 4)
                                          (("2"
                                            (lemma
                                             Vars_union
                                             (X
                                              "head`1"
                                              t
                                              "head`2"
                                              s
                                              "Subs(tail)(w!1)"))
                                            (("2"
                                              (lemma
                                               Vars_union
                                               (X
                                                "head`1"
                                                t
                                                "head`2"
                                                s
                                                "Subs(tail)(t!1)"))
                                              (("2"
                                                (case
                                                 "occurs(head`1, Subs(tail)(t!1))")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (replaces -2)
                                                    (("1"
                                                      (case
                                                       "occurs(head`1, Subs(tail)(w!1))")
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (replaces -3)
                                                          (("1"
                                                            (hide-all-but
                                                             (-6 -7 1))
                                                            (("1"
                                                              (expand*
                                                               subset?
                                                               union
                                                               remove
                                                               member)
                                                              (("1"
                                                                (skeep)
                                                                (("1"
                                                                  (inst
                                                                   -2
                                                                   x)
                                                                  (("1"
                                                                    (inst
                                                                     -3
                                                                     x)
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (rewrite
                                                         not_occurs_subs_invariance)
                                                        (("2"
                                                          (hide-all-but
                                                           (-6
                                                            -7
                                                            -8
                                                            1
                                                            2))
                                                          (("2"
                                                            (expand*
                                                             remove
                                                             union
                                                             subset?
                                                             member)
                                                            (("2"
                                                              (skeep)
                                                              (("2"
                                                                (inst
                                                                 -3
                                                                 x_1)
                                                                (("2"
                                                                  (inst
                                                                   -4
                                                                   x_1)
                                                                  (("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (rewrite
                                                   not_occurs_subs_invariance)
                                                  (("2"
                                                    (case
                                                     "occurs(head`1, Subs(tail)(w!1))")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (replaces -3)
                                                        (("1"
                                                          (hide-all-but
                                                           (-5 -6 2 3))
                                                          (("1"
                                                            (expand*
                                                             union
                                                             remove
                                                             subset?
                                                             member)
                                                            (("1"
                                                              (skeep)
                                                              (("1"
                                                                (inst
                                                                 -2
                                                                 x_1)
                                                                (("1"
                                                                  (inst
                                                                   -3
                                                                   x_1)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (rewrite
                                                       not_occurs_subs_invariance)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (hide-all-but
                                                           (-5
                                                            -6
                                                            3
                                                            4
                                                            5))
                                                          (("2"
                                                            (expand*
                                                             remove
                                                             union
                                                             subset?
                                                             member)
                                                            (("2"
                                                              (skeep)
                                                              (("2"
                                                                (inst
                                                                 -2
                                                                 x_1)
                                                                (("2"
                                                                  (inst
                                                                   -3
                                                                   x_1)
                                                                  (("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (decompose-equality 1) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Id const-decl "Sub" substitution nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (Subs_unif_Vars_subset formula-decl nil substitution nil)
    (Vars_occurs formula-decl nil nominal_term nil)
    (Sub type-eq-decl nil substitution nil)
    (/= const-decl "boolean" notequal nil)
    (not_occurs_subs_invariance formula-decl nil substitution nil)
    (Vars_union formula-decl nil substitution nil)
    (card_subset formula-decl nil finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (card_remove formula-decl nil finite_sets nil)
    (remove const-decl "set" sets nil)
    (subs def-decl "term" substitution nil)
    (Vars def-decl "finite_set[variable]" nominal_term nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (union const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (finite_remove application-judgement "finite_set" finite_sets nil)
    (Vars const-decl "finite_set[variable]" substitution nil)
    (Subs_unif type-eq-decl nil substitution nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (occurs def-decl "bool" nominal_term nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Vars_in const-decl "bool" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Subs def-decl "term" substitution nil))
   shostak))
 (Subs_unif_append 0
  (Subs_unif_append-2 nil 3745920142
   ("" (skolem 1 ("s" "t" "u" "w" "sigma" "_"))
    (("" (induct "gamma")
      (("1" (grind)
        (("1" (typepred "sigma")
          (("1" (expand "Vars_in")
            (("1" (rewrite "every_nth")
              (("1" (rewrite "every_nth")
                (("1" (skeep)
                  (("1" (inst -1 "i")
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (split 2)
                          (("1" (skeep)
                            (("1" (inst -2 "x")
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (flatten)
                            (("2" (split)
                              (("1" (propax) nil nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skolem 1 ("head" "tail"))
        (("2" (prop)
          (("2" (expand "append" 1)
            (("2" (expand "every" 1)
              (("2" (assert)
                (("2" (typepred "head")
                  (("2" (hide -2)
                    (("2" (expand "Vars_in")
                      (("2"
                        (lemma "Subs_unif_Vars_subset"
                         ("u" "u" "s" "s" "w" "t" "t" "w" "gamma"
                          "sigma"))
                        (("2" (expand "Vars" -1 (2 3))
                          (("2" (expand "Vars" 2 2)
                            (("2" (expand "Vars" 2 (2 3))
                              (("2"
                                (expand "occurs" 2)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (expand*
                                     "subset?"
                                     "union"
                                     "member")
                                    (("2"
                                      (split 2)
                                      (("1"
                                        (skeep)
                                        (("1"
                                          (inst -3 "x")
                                          (("1"
                                            (inst -2 "x")
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (expand "Vars" -1 1)
                                          (("2"
                                            (expand* "union" "member")
                                            (("2"
                                              (inst -1 "head`1")
                                              (("2"
                                                (rewrite "Vars_occurs")
                                                (("2"
                                                  (rewrite
                                                   "Vars_occurs")
                                                  (("2"
                                                    (rewrite
                                                     "Vars_occurs")
                                                    (("2"
                                                      (rewrite
                                                       "Vars_occurs")
                                                      (("2"
                                                        (rewrite
                                                         "Vars_occurs")
                                                        (("2"
                                                          (rewrite
                                                           "Vars_occurs")
                                                          (("2"
                                                            (split -3)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pair? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (pair adt-constructor-decl "[[term, term] -> (pair?)]" term_adt
     nil)
    (append def-decl "list[T]" list_props nil)
    (Subs_unif type-eq-decl nil substitution nil)
    (occurs def-decl "bool" nominal_term nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (Subs def-decl "term" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (Vars_in const-decl "bool" substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list_induction formula-decl nil list_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every_nth formula-decl nil list_props nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Vars def-decl "finite_set[variable]" nominal_term nil)
    (Vars const-decl "finite_set[variable]" substitution nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (Vars_occurs formula-decl nil nominal_term nil)
    (Subs_unif_Vars_subset formula-decl nil substitution nil))
   nil)
  (Subs_unif_append-1 nil 3627825506
   ("" (skolem 1 (s t u w sigma "_"))
    (("" (induct gamma)
      (("1" (grind)
        (("1" (typepred sigma)
          (("1" (expand Vars_in)
            (("1" (rewrite every_nth)
              (("1" (rewrite every_nth)
                (("1" (skeep)
                  (("1" (inst -1 i)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (split 2)
                          (("1" (skeep)
                            (("1" (inst -2 x) (("1" (assert) nil nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (split)
                              (("1" (propax) nil nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skolem 1 ("head" "tail"))
        (("2" (prop)
          (("2" (expand append 1)
            (("2" (expand every 1)
              (("2" (assert)
                (("2" (typepred head)
                  (("2" (hide -2)
                    (("2" (expand Vars_in)
                      (("2"
                        (lemma Subs_unif_Vars_subset
                         (u u s s w t t w gamma sigma))
                        (("2" (expand Vars -1 (2 3))
                          (("2" (expand Vars 2 2)
                            (("2" (expand Vars 2 (2 3))
                              (("2"
                                (expand occurs 2)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (expand* subset? union member)
                                    (("2"
                                      (split 2)
                                      (("1"
                                        (skeep)
                                        (("1"
                                          (inst -3 x)
                                          (("1"
                                            (inst -2 x)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (expand Vars -1 1)
                                          (("2"
                                            (expand* union member)
                                            (("2"
                                              (inst -1 "head`1")
                                              (("2"
                                                (rewrite Vars_occurs)
                                                (("2"
                                                  (rewrite Vars_occurs)
                                                  (("2"
                                                    (rewrite
                                                     Vars_occurs)
                                                    (("2"
                                                      (rewrite
                                                       Vars_occurs)
                                                      (("2"
                                                        (rewrite
                                                         Vars_occurs)
                                                        (("2"
                                                          (rewrite
                                                           Vars_occurs)
                                                          (("2"
                                                            (split -3)
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pair? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (pair adt-constructor-decl "[[term, term] -> (pair?)]" term_adt
     nil)
    (append def-decl "list[T]" list_props nil)
    (Subs_unif type-eq-decl nil substitution nil)
    (occurs def-decl "bool" nominal_term nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Subs def-decl "term" substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (Vars_in const-decl "bool" substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list_induction formula-decl nil list_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (every_nth formula-decl nil list_props nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Vars def-decl "finite_set[variable]" nominal_term nil)
    (Vars const-decl "finite_set[variable]" substitution nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (Vars_occurs formula-decl nil nominal_term nil)
    (Subs_unif_Vars_subset formula-decl nil substitution nil))
   shostak))
 (Subs_atom2 0
  (Subs_atom2-2 nil 3745920190
   ("" (induct "s")
    (("1" (skeep*) (("1" (rewrite "Subs_atom") nil nil)) nil)
     ("2" (skeep*) nil nil)
     ("3" (skeep*) (("3" (rewrite "Subs_unit") nil nil)) nil)
     ("4" (skeep*)
      (("4" (rewrite "Subs_pair") (("4" (assert) nil nil)) nil)) nil)
     ("5" (skeep*)
      (("5" (rewrite "Subs_abs") (("5" (assert) nil nil)) nil)) nil)
     ("6" (skeep*)
      (("6" (rewrite "Subs_app") (("6" (assert) nil nil)) nil)) nil))
    nil)
   ((Subs_app formula-decl nil substitution nil)
    (Subs_abs formula-decl nil substitution nil)
    (Subs_pair formula-decl nil substitution nil)
    (Subs_unit formula-decl nil substitution nil)
    (Subs_atom formula-decl nil substitution nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (at adt-constructor-decl "[atom -> (atom?)]" term_adt nil)
    (atom? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   nil)
  (Subs_atom2-1 nil 3630306142
   ("" (induct s)
    (("1" (skeep*) (("1" (rewrite Subs_atom) nil nil)) nil)
     ("2" (skeep*) nil nil)
     ("3" (skeep*) (("3" (rewrite Subs_unit) nil nil)) nil)
     ("4" (skeep*)
      (("4" (rewrite Subs_pair) (("4" (assert) nil nil)) nil)) nil)
     ("5" (skeep*)
      (("5" (rewrite Subs_abs) (("5" (assert) nil nil)) nil)) nil)
     ("6" (skeep*)
      (("6" (rewrite Subs_app) (("6" (assert) nil nil)) nil)) nil))
    nil)
   ((Subs_app formula-decl nil substitution nil)
    (Subs_abs formula-decl nil substitution nil)
    (Subs_pair formula-decl nil substitution nil)
    (Subs_unit formula-decl nil substitution nil)
    (Subs_atom formula-decl nil substitution nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (at adt-constructor-decl "[atom -> (atom?)]" term_adt nil)
    (atom? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   shostak))
 (Subs_unit2 0
  (Subs_unit2-2 nil 3745920246
   ("" (induct "s")
    (("1" (skeep*) (("1" (rewrite "Subs_atom") nil nil)) nil)
     ("2" (skeep*) nil nil) ("3" (skeep*) nil nil)
     ("4" (skeep*)
      (("4" (rewrite "Subs_pair") (("4" (assert) nil nil)) nil)) nil)
     ("5" (skeep*)
      (("5" (rewrite "Subs_abs") (("5" (assert) nil nil)) nil)) nil)
     ("6" (skeep*)
      (("6" (rewrite "Subs_app") (("6" (assert) nil nil)) nil)) nil))
    nil)
   ((Subs_app formula-decl nil substitution nil)
    (Subs_abs formula-decl nil substitution nil)
    (Subs_pair formula-decl nil substitution nil)
    (Subs_atom formula-decl nil substitution nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (unit adt-constructor-decl "(unit?)" term_adt nil)
    (unit? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   nil)
  (Subs_unit2-1 nil 3630306272
   ("" (induct s)
    (("1" (skeep*) (("1" (rewrite Subs_atom) nil nil)) nil)
     ("2" (skeep*) nil nil) ("3" (skeep*) nil nil)
     ("4" (skeep*)
      (("4" (rewrite Subs_pair) (("4" (assert) nil nil)) nil)) nil)
     ("5" (skeep*)
      (("5" (rewrite Subs_abs) (("5" (assert) nil nil)) nil)) nil)
     ("6" (skeep*)
      (("6" (rewrite Subs_app) (("6" (assert) nil nil)) nil)) nil))
    nil)
   ((Subs_app formula-decl nil substitution nil)
    (Subs_abs formula-decl nil substitution nil)
    (Subs_pair formula-decl nil substitution nil)
    (Subs_atom formula-decl nil substitution nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (unit adt-constructor-decl "(unit?)" term_adt nil)
    (unit? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   shostak))
 (Subs_depth 0
  (Subs_depth-2 nil 3745920421
   ("" (induct "t")
    (("1" (skeep*) (("1" (expand* "Vars" "emptyset" "member") nil nil))
      nil)
     ("2" (skeep*)
      (("2" (expand* "Vars" "singleton" "member")
        (("2"
          (lemma "Subs_perm_comm"
           ("sigma" "sigma" "pi" "pi" "t" "(::)*X"))
          (("2"
            (lemma "Subs_perm_comm"
             ("sigma" "sigma" "pi" "times1_var" "t" "(::)*times2_var"))
            (("2" (expand "ext" -1 1)
              (("2" (expand "ext" -2 1)
                (("2" (rewrite "append_null")
                  (("2" (rewrite "append_null")
                    (("2" (replaces -1)
                      (("2" (replaces -1)
                        (("2" (rewrite "ext_preserves_depth")
                          (("2" (rewrite "ext_preserves_depth")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep) (("3" (expand* "Vars" "emptyset" "member") nil nil))
      nil)
     ("4" (skeep*)
      (("4" (rewrite "Subs_pair")
        (("4" (expand "depth" 1 2)
          (("4" (expand "max")
            (("4" (expand "Vars" -3)
              (("4" (expand "union")
                (("4" (expand "member" -3 1)
                  (("4" (inst -1 "X" "pi" "sigma")
                    (("4" (inst -2 "X" "pi" "sigma")
                      (("4" (lift-if)
                        (("4" (split -3)
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (rewrite "Subs_abs")
        (("5" (expand "depth" 1 2)
          (("5" (expand "Vars" -2)
            (("5" (inst -1 "X" "pi" "sigma") (("5" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (rewrite "Subs_app")
        (("6" (expand "depth" 1 2)
          (("6" (expand "Vars" -2)
            (("6" (inst -1 "X" "pi" "sigma") (("6" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Subs_app formula-decl nil substitution nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (Subs_abs formula-decl nil substitution nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (union const-decl "set" sets nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (Subs_pair formula-decl nil substitution nil)
    (Subs_perm_comm formula-decl nil substitution nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (ext def-decl "term" nominal_term nil)
    (append_null formula-decl nil list_props nil)
    (ext_preserves_depth formula-decl nil nominal_term nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (depth def-decl "nat" nominal_term nil)
    (<= const-decl "bool" reals nil)
    (Vars def-decl "finite_set[variable]" nominal_term nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   nil)
  (Subs_depth-1 nil 3630307872
   ("" (induct t)
    (("1" (skeep*) (("1" (expand* Vars emptyset member) nil nil)) nil)
     ("2" (skeep*)
      (("2" (expand* Vars singleton member)
        (("2" (lemma Subs_perm_comm (sigma sigma pi pi t "(::)*X"))
          (("2"
            (lemma Subs_perm_comm
             (sigma sigma pi "times1_var" t "(::)*times2_var"))
            (("2" (expand ext -1 1)
              (("2" (expand ext -2 1)
                (("2" (rewrite append_null)
                  (("2" (rewrite append_null)
                    (("2" (replaces -1)
                      (("2" (replaces -1)
                        (("2" (rewrite ext_preserves_depth)
                          (("2" (rewrite ext_preserves_depth)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep) (("3" (expand* Vars emptyset member) nil nil)) nil)
     ("4" (skeep*)
      (("4" (rewrite Subs_pair)
        (("4" (expand depth 1 2)
          (("4" (expand max)
            (("4" (expand Vars -3)
              (("4" (expand union)
                (("4" (expand member -3 1)
                  (("4" (inst -1 X pi sigma)
                    (("4" (inst -2 X pi sigma)
                      (("4" (lift-if)
                        (("4" (split -3)
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (rewrite Subs_abs)
        (("5" (expand depth 1 2)
          (("5" (expand Vars -2)
            (("5" (inst -1 X pi sigma) (("5" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (rewrite Subs_app)
        (("6" (expand depth 1 2)
          (("6" (expand Vars -2)
            (("6" (inst -1 X pi sigma) (("6" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Subs_app formula-decl nil substitution nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (Subs_abs formula-decl nil substitution nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (union const-decl "set" sets nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (Subs_pair formula-decl nil substitution nil)
    (Subs_perm_comm formula-decl nil substitution nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (ext def-decl "term" nominal_term nil)
    (append_null formula-decl nil list_props nil)
    (ext_preserves_depth formula-decl nil nominal_term nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (singleton const-decl "(singleton?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (depth def-decl "nat" nominal_term nil)
    (<= const-decl "bool" reals nil)
    (Vars def-decl "finite_set[variable]" nominal_term nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   shostak))
 (Subs_depth_not_susp 0
  (Subs_depth_not_susp-2 nil 3745920543
   ("" (skeep*)
    (("" (expand* "Vars" "emptyset")
      (("" (lift-if)
        (("" (prop)
          (("1" (expand "member") (("1" (propax) nil nil)) nil)
           ("2" (expand "member") (("2" (propax) nil nil)) nil)
           ("3" (case "pair(term1(t), term2(t)) = t")
            (("1" (replace -1 5 rl)
              (("1" (rewrite "Subs_pair")
                (("1" (expand "depth" 5 2)
                  (("1" (expand "max")
                    (("1" (expand "union")
                      (("1" (expand "member" -3 1)
                        (("1"
                          (lemma "Subs_depth"
                           ("X" "X" "sigma" "sigma" "pi" "pi"))
                          (("1" (lift-if)
                            (("1" (split -4)
                              (("1"
                                (inst -2 "term1(t)")
                                (("1" (assert) nil nil))
                                nil)
                               ("2"
                                (inst -2 "term2(t)")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (decompose-equality 1) nil nil))
            nil)
           ("4" (case "abs(abstr(t), body(t)) = t")
            (("1" (replace -1 6 rl)
              (("1" (rewrite "Subs_abs")
                (("1" (expand "depth" 6 2)
                  (("1"
                    (lemma "Subs_depth"
                     ("X" "X" "pi" "pi" "sigma" "sigma" "t" "body(t)"))
                    (("1" (assert) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (decompose-equality 1) nil nil))
            nil)
           ("5" (case "app(sym(t), arg(t)) = t")
            (("1" (replace -1 7 rl)
              (("1" (rewrite "Subs_app")
                (("1" (expand "depth" 7 2)
                  (("1"
                    (lemma "Subs_depth"
                     ("X" "X" "pi" "pi" "sigma" "sigma" "t" "arg(t)"))
                    (("1" (assert) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (decompose-equality 1) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((emptyset const-decl "set" sets nil)
    (Vars def-decl "finite_set[variable]" nominal_term nil)
    (member const-decl "bool" sets nil)
    (term_pair_extensionality formula-decl nil term_adt nil)
    (depth def-decl "nat" nominal_term nil)
    (union const-decl "set" sets nil)
    (Subs_depth formula-decl nil substitution nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (Subs_pair formula-decl nil substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" term_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (variable type-eq-decl nil nominal_term nil)
    (pair? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (pair adt-constructor-decl "[[term, term] -> (pair?)]" term_adt
     nil)
    (term1 adt-accessor-decl "[(pair?) -> term]" term_adt nil)
    (term2 adt-accessor-decl "[(pair?) -> term]" term_adt nil)
    (term_abs_extensionality formula-decl nil term_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (Subs_abs formula-decl nil substitution nil)
    (abs? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (abs adt-constructor-decl "[[atom, term] -> (abs?)]" term_adt nil)
    (abstr adt-accessor-decl "[(abs?) -> atom]" term_adt nil)
    (body adt-accessor-decl "[(abs?) -> term]" term_adt nil)
    (term_app_extensionality formula-decl nil term_adt nil)
    (Subs_app formula-decl nil substitution nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (app adt-constructor-decl "[[symbol, term] -> (app?)]" term_adt
     nil)
    (sym adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (arg adt-accessor-decl "[(app?) -> term]" term_adt nil))
   nil)
  (Subs_depth_not_susp-1 nil 3630308863
   ("" (skeep*)
    (("" (expand* Vars emptyset)
      (("" (lift-if)
        (("" (prop)
          (("1" (expand member) (("1" (propax) nil nil)) nil)
           ("2" (expand member) (("2" (propax) nil nil)) nil)
           ("3" (case "pair(term1(t), term2(t)) = t")
            (("1" (replace -1 5 rl)
              (("1" (rewrite Subs_pair)
                (("1" (expand depth 5 2)
                  (("1" (expand max)
                    (("1" (expand union)
                      (("1" (expand member -3 1)
                        (("1"
                          (lemma Subs_depth (X X sigma sigma pi pi))
                          (("1" (lift-if)
                            (("1" (split -4)
                              (("1"
                                (inst -2 "term1(t)")
                                (("1" (assert) nil nil))
                                nil)
                               ("2"
                                (inst -2 "term2(t)")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (decompose-equality 1) nil nil))
            nil)
           ("4" (case "abs(abstr(t), body(t)) = t")
            (("1" (replace -1 6 rl)
              (("1" (rewrite Subs_abs)
                (("1" (expand depth 6 2)
                  (("1"
                    (lemma Subs_depth
                     (X X pi pi sigma sigma t "body(t)"))
                    (("1" (assert) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (decompose-equality 1) nil nil))
            nil)
           ("5" (case "app(sym(t), arg(t)) = t")
            (("1" (replace -1 7 rl)
              (("1" (rewrite Subs_app)
                (("1" (expand depth 7 2)
                  (("1"
                    (lemma Subs_depth
                     (X X pi pi sigma sigma t "arg(t)"))
                    (("1" (assert) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (decompose-equality 1) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((emptyset const-decl "set" sets nil)
    (Vars def-decl "finite_set[variable]" nominal_term nil)
    (member const-decl "bool" sets nil)
    (term_pair_extensionality formula-decl nil term_adt nil)
    (depth def-decl "nat" nominal_term nil)
    (union const-decl "set" sets nil)
    (Subs_depth formula-decl nil substitution nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (Subs_pair formula-decl nil substitution nil)
    (Sub type-eq-decl nil substitution nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (term type-decl nil term_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (variable type-eq-decl nil nominal_term nil)
    (pair? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (pair adt-constructor-decl "[[term, term] -> (pair?)]" term_adt
     nil)
    (term1 adt-accessor-decl "[(pair?) -> term]" term_adt nil)
    (term2 adt-accessor-decl "[(pair?) -> term]" term_adt nil)
    (term_abs_extensionality formula-decl nil term_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (Subs_abs formula-decl nil substitution nil)
    (abs? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (abs adt-constructor-decl "[[atom, term] -> (abs?)]" term_adt nil)
    (abstr adt-accessor-decl "[(abs?) -> atom]" term_adt nil)
    (body adt-accessor-decl "[(abs?) -> term]" term_adt nil)
    (term_app_extensionality formula-decl nil term_adt nil)
    (Subs_app formula-decl nil substitution nil)
    (app? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (app adt-constructor-decl "[[symbol, term] -> (app?)]" term_adt
     nil)
    (sym adt-accessor-decl "[(app?) -> symbol]" term_adt nil)
    (arg adt-accessor-decl "[(app?) -> term]" term_adt nil))
   shostak))
 (alpha_Subs_Vars 0
  (alpha_Subs_Vars-2 nil 3745920595
   ("" (skeep*)
    ((""
      (lemma "Subs_depth_not_susp"
       ("X" "X" "pi" "pi" "sigma" "sigma" "t" "t"))
      ((""
        (lemma "alpha_depth"
         ("Delta" "Delta" "t" "Subs(sigma)(t)" "s"
          "Subs(sigma)(pi * X)"))
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Subs_depth_not_susp formula-decl nil substitution nil)
    (alpha_depth formula-decl nil alpha_equivalence nil)
    (fresh_context type-eq-decl nil freshness nil)
    (Subs def-decl "term" substitution nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil))
   nil)
  (alpha_Subs_Vars-1 nil 3630223414
   ("" (skeep*)
    (("" (lemma Subs_depth_not_susp (X X pi pi sigma sigma t t))
      ((""
        (lemma alpha_depth
         (Delta Delta t "Subs(sigma)(t)" s "Subs(sigma)(pi * X)"))
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((Sub type-eq-decl nil substitution nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (atom type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Subs_depth_not_susp formula-decl nil substitution nil)
    (alpha_depth formula-decl nil alpha_equivalence nil)
    (fresh_context type-eq-decl nil freshness nil)
    (Subs def-decl "term" substitution nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil))
   shostak))
 (alpha_Subs_ord 0
  (alpha_Subs_ord-2 nil 3745920695
   ("" (skeep)
    (("" (case "susp?(s)")
      (("1" (case "p(s) * V(s) = s")
        (("1" (replace -1 -3 rl)
          (("1"
            (lemma "alpha_Subs_Vars"
             ("X" "V(s)" "pi" "p(s)" "sigma" "sigma" "Delta" "Delta"
              "t" "t"))
            (("1" (assert) nil nil)) nil))
          nil)
         ("2" (rewrite "term_times_eta") nil nil)
         ("3" (propax) nil nil))
        nil)
       ("2" (hide 3)
        (("2" (lemma "Subs_ord" ("sigma" "sigma" "t" "t"))
          (("2" (lemma "Subs_ord" ("sigma" "sigma" "t" "s"))
            (("2" (assert)
              (("2" (expand "alpha")
                (("2" (lift-if)
                  (("2" (expand "ord" -1 1)
                    (("2" (expand "ord" -2 1)
                      (("2" (prop)
                        (("1" (assert) nil nil) ("2" (assert) nil nil)
                         ("3" (assert) nil nil) ("4" (assert) nil nil)
                         ("5" (assert) nil nil) ("6" (assert) nil nil)
                         ("7" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (variable type-eq-decl nil nominal_term nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (atom type-eq-decl nil atoms nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (term_times_eta formula-decl nil term_adt nil)
    (alpha_Subs_Vars formula-decl nil substitution nil)
    (fresh_context type-eq-decl nil freshness nil)
    (Sub type-eq-decl nil substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (p adt-accessor-decl "[(susp?) -> perm]" term_adt nil)
    (V adt-accessor-decl "[(susp?) -> variable]" term_adt nil)
    (Subs_ord formula-decl nil substitution nil)
    (ord const-decl "upto(5)" term_adt nil)
    (alpha def-decl "bool" alpha_equivalence nil))
   nil)
  (alpha_Subs_ord-1 nil 3630310927
   ("" (skeep)
    (("" (case "susp?(s)")
      (("1" (case "p(s) * V(s) = s")
        (("1" (replace -1 -3 rl)
          (("1"
            (lemma alpha_Subs_Vars
             (X "V(s)" pi "p(s)" sigma sigma Delta Delta t t))
            (("1" (assert) nil nil)) nil))
          nil)
         ("2" (rewrite "term_times_eta") nil nil)
         ("3" (propax) nil nil))
        nil)
       ("2" (hide 3)
        (("2" (lemma Subs_ord (sigma sigma t t))
          (("2" (lemma Subs_ord (sigma sigma t s))
            (("2" (assert)
              (("2" (expand alpha)
                (("2" (lift-if)
                  (("2" (expand ord -1 1)
                    (("2" (expand ord -2 1)
                      (("2" (prop)
                        (("1" (assert) nil nil) ("2" (assert) nil nil)
                         ("3" (assert) nil nil) ("4" (assert) nil nil)
                         ("5" (assert) nil nil) ("6" (assert) nil nil)
                         ("7" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (variable type-eq-decl nil nominal_term nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil)
    (symbol type-eq-decl nil nominal_term nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (perm type-eq-decl nil atoms nil) (list type-decl nil list_adt nil)
    (atom type-eq-decl nil atoms nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (term_times_eta formula-decl nil term_adt nil)
    (alpha_Subs_Vars formula-decl nil substitution nil)
    (fresh_context type-eq-decl nil freshness nil)
    (Sub type-eq-decl nil substitution nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (p adt-accessor-decl "[(susp?) -> perm]" term_adt nil)
    (V adt-accessor-decl "[(susp?) -> variable]" term_adt nil)
    (Subs_ord formula-decl nil substitution nil)
    (ord const-decl "upto(5)" term_adt nil)
    (alpha def-decl "bool" alpha_equivalence nil))
   shostak))
 (alpha_Subs_invariance 0
  (alpha_Subs_invariance-2 nil 3745920839
   ("" (induct "t")
    (("1" (skeep*)
      (("1" (rewrite "Subs_atom")
        (("1" (rewrite "Subs_atom")
          (("1" (expand "alpha" 1) (("1" (propax) nil nil)) nil)) nil))
        nil))
      nil)
     ("2" (skeep*)
      (("2"
        (case "times1_var * times2_var = ext(times1_var)((::)*times2_var)")
        (("1" (replaces -1)
          (("1" (rewrite "Subs_perm_comm")
            (("1" (rewrite "Subs_perm_comm")
              (("1" (inst -1 "times2_var")
                (("1" (rewrite "ext_preserves_alpha") nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (expand "ext") (("2" (rewrite "append_null") nil nil))
          nil))
        nil))
      nil)
     ("3" (skeep)
      (("3" (rewrite "Subs_unit")
        (("3" (rewrite "Subs_unit")
          (("3" (expand "alpha" 1) (("3" (propax) nil nil)) nil)) nil))
        nil))
      nil)
     ("4" (skeep*)
      (("4" (rewrite "Subs_pair")
        (("4" (rewrite "Subs_pair")
          (("4" (expand "alpha" 1)
            (("4" (inst -1 "Delta" "gamma" "sigma")
              (("4" (inst -2 "Delta" "gamma" "sigma")
                (("4" (prop) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (rewrite "Subs_abs")
        (("5" (rewrite "Subs_abs")
          (("5" (expand "alpha" 1)
            (("5" (inst -1 "Delta" "gamma" "sigma")
              (("5" (prop) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (rewrite "Subs_app")
        (("6" (rewrite "Subs_app")
          (("6" (expand "alpha" 1)
            (("6" (inst -1 "Delta" "gamma" "sigma")
              (("6" (prop) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Subs_app formula-decl nil substitution nil)
    (Subs_abs formula-decl nil substitution nil)
    (Subs_pair formula-decl nil substitution nil)
    (Subs_unit formula-decl nil substitution nil)
    (append_null formula-decl nil list_props nil)
    (ext_preserves_alpha formula-decl nil alpha_equivalence nil)
    (Subs_perm_comm formula-decl nil substitution nil)
    (ext def-decl "term" nominal_term nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Subs_atom formula-decl nil substitution nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (alpha def-decl "bool" alpha_equivalence nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (fresh_context type-eq-decl nil freshness nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" term_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   nil)
  (alpha_Subs_invariance-1 nil 3630397827
   ("" (induct t)
    (("1" (skeep*)
      (("1" (rewrite Subs_atom)
        (("1" (rewrite Subs_atom)
          (("1" (expand alpha 1) (("1" (propax) nil nil)) nil)) nil))
        nil))
      nil)
     ("2" (skeep*)
      (("2"
        (case "times1_var * times2_var = ext(times1_var)((::)*times2_var)")
        (("1" (replaces -1)
          (("1" (rewrite Subs_perm_comm)
            (("1" (rewrite Subs_perm_comm)
              (("1" (inst -1 "times2_var")
                (("1" (rewrite ext_preserves_alpha) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (expand ext) (("2" (rewrite append_null) nil nil)) nil))
        nil))
      nil)
     ("3" (skeep)
      (("3" (rewrite Subs_unit)
        (("3" (rewrite Subs_unit)
          (("3" (expand alpha 1) (("3" (propax) nil nil)) nil)) nil))
        nil))
      nil)
     ("4" (skeep*)
      (("4" (rewrite Subs_pair)
        (("4" (rewrite Subs_pair)
          (("4" (expand alpha 1)
            (("4" (inst -1 Delta gamma sigma)
              (("4" (inst -2 Delta gamma sigma) (("4" (prop) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (rewrite Subs_abs)
        (("5" (rewrite Subs_abs)
          (("5" (expand alpha 1)
            (("5" (inst -1 Delta gamma sigma) (("5" (prop) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (rewrite Subs_app)
        (("6" (rewrite Subs_app)
          (("6" (expand alpha 1)
            (("6" (inst -1 Delta gamma sigma) (("6" (prop) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Subs_app formula-decl nil substitution nil)
    (Subs_abs formula-decl nil substitution nil)
    (Subs_pair formula-decl nil substitution nil)
    (Subs_unit formula-decl nil substitution nil)
    (append_null formula-decl nil list_props nil)
    (ext_preserves_alpha formula-decl nil alpha_equivalence nil)
    (Subs_perm_comm formula-decl nil substitution nil)
    (ext def-decl "term" nominal_term nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Subs_atom formula-decl nil substitution nil)
    (term_induction formula-decl nil term_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (atom type-eq-decl nil atoms nil)
    (list type-decl nil list_adt nil) (perm type-eq-decl nil atoms nil)
    (variable type-eq-decl nil nominal_term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (symbol type-eq-decl nil nominal_term nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (* adt-constructor-decl "[[perm, variable] -> (susp?)]" term_adt
       nil)
    (susp? adt-recognizer-decl "[term -> boolean]" term_adt nil)
    (Subs def-decl "term" substitution nil)
    (alpha def-decl "bool" alpha_equivalence nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Sub type-eq-decl nil substitution nil)
    (fresh_context type-eq-decl nil freshness nil)
    (TRUE const-decl "bool" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (term type-decl nil term_adt nil))
   shostak)))

