(measure_theory
 (null_set?_TCC1 0
  (null_set?_TCC1-1 nil 3390731916 ("" (subtype-tcc) nil nil)
   ((m formal-const-decl "measure_type" measure_theory nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (S formal-const-decl "sigma_algebra" measure_theory nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil measure_theory nil)
    (mu_fin? const-decl "bool" measure_props nil)
    (measurable_set? const-decl "bool" measure_space_def nil))
   nil
   (null_set? subtype "measure_theory.X"
    "{m1: (measure_theory.S) | measure_props[measure_theory.T, measure_theory.S, measure_theory.m].mu_fin?(m1)}")))
 (null_set_TCC1 0
  (null_set_TCC1-1 nil 3390722475
   ("" (expand "null_set?")
    (("" (typepred "m")
      (("" (expand "measure?")
        (("" (flatten)
          (("" (expand "mu_fin?")
            (("" (expand "mu")
              (("" (assert)
                (("" (expand "measure_empty?")
                  (("" (replace -1)
                    (("" (assert)
                      (("" (typepred "S")
                        (("" (expand "sigma_algebra?")
                          (("" (expand "subset_algebra_empty?")
                            (("" (flatten)
                              (("" (expand "measurable_set?")
                                (("" (propax) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((m formal-const-decl "measure_type" measure_theory nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (S formal-const-decl "sigma_algebra" measure_theory nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (T formal-type-decl nil measure_theory nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (mu const-decl "nnreal" measure_props nil)
    (measure_empty? const-decl "bool" generalized_measure_def nil)
    (measurable_set? const-decl "bool" measure_space_def nil)
    (subset_algebra_empty? const-decl "bool" subset_algebra_def nil)
    (mu_fin? const-decl "bool" measure_props nil)
    (null_set? const-decl "bool" measure_theory nil)
    (subset_algebra_emptyset name-judgement "(S)" measure_theory nil)
    (finite_emptyset name-judgement "finite_set[T]" countable_setofsets
     sets_aux)
    (finite_emptyset name-judgement "finite_set[T]" countable_props sets_aux)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil (null_set subtype "sets[measure_theory.T].emptyset" "null_set")))
 (negligible_TCC1 0
  (negligible_TCC1-1 nil 3390722475
   ("" (expand "negligible_set?")
    (("" (inst + "emptyset[T]")
      (("" (rewrite "null_set_TCC1") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((T formal-type-decl nil measure_theory nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil) (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)
    (subset_algebra_emptyset name-judgement "(S)" measure_theory nil)
    (finite_emptyset name-judgement "finite_set[T]" countable_setofsets
     sets_aux)
    (finite_emptyset name-judgement "finite_set[T]" countable_props sets_aux)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (null_set_TCC1 subtype-tcc nil measure_theory nil)
    (negligible_set? const-decl "bool" measure_theory nil))
   nil (negligible subtype "sets[measure_theory.T].emptyset" "negligible")))
 (negligible_iff_measurable_null 0
  (negligible_iff_measurable_null-1 nil 3390726086
   ("" (expand "negligible_set?")
    (("" (skosimp*)
      (("" (split)
        (("1" (skosimp*)
          (("1" (expand "null_set?")
            (("1" (flatten)
              (("1" (assert)
                (("1" (lemma "m_monotone" ("a" "X!1" "b" "X!2"))
                  (("1" (assert)
                    (("1" (assert)
                      (("1" (expand "x_le")
                        (("1" (expand "mu_fin?")
                          (("1" (expand "mu")
                            (("1" (replace -3)
                              (("1" (replace -4)
                                (("1" (flatten) (("1" (assert) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (expand "null_set?")
            (("2" (flatten)
              (("2" (assert)
                (("2" (inst + "X!1")
                  (("2" (assert)
                    (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null_set? const-decl "bool" measure_theory nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (x_le const-decl "bool" extended_nnreal extended_nnreal)
    (mu const-decl "nnreal" measure_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (mu_fin? const-decl "bool" measure_props nil)
    (m_monotone formula-decl nil measure_props nil)
    (set type-eq-decl nil sets nil)
    (measurable_set? const-decl "bool" measure_space_def nil)
    (measurable_set nonempty-type-eq-decl nil measure_space_def nil)
    (T formal-type-decl nil measure_theory nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S formal-const-decl "sigma_algebra" measure_theory nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (m formal-const-decl "measure_type" measure_theory nil)
    (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)
    (negligible_set? const-decl "bool" measure_theory nil))
   shostak))
 (null_is_negligible 0
  (null_is_negligible-1 nil 3390722475 ("" (judgement-tcc) nil nil)
   ((null_set nonempty-type-eq-decl nil measure_theory nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (S formal-const-decl "sigma_algebra" measure_theory nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil measure_theory nil)
    (measurable_set? const-decl "bool" measure_space_def nil)
    (m formal-const-decl "measure_type" measure_theory nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (mu_fin? const-decl "bool" measure_props nil)
    (mu const-decl "nnreal" measure_props nil)
    (null_set? const-decl "bool" measure_theory nil)
    (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)
    (negligible_set? const-decl "bool" measure_theory nil))
   nil (null_is_negligible subtype "measure_theory.x" "negligible")))
 (null_emptyset 0
  (null_emptyset-1 nil 3395639293
   ("" (expand "null_set?")
    (("" (typepred "m")
      (("" (typepred "S")
        (("" (expand "measure?")
          (("" (expand "sigma_algebra?")
            (("" (flatten)
              (("" (expand "subset_algebra_empty?")
                (("" (expand "measure_empty?")
                  (("" (expand "mu_fin?")
                    (("" (expand "mu")
                      (("" (replace -4)
                        (("" (expand "measurable_set?")
                          (("" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((m formal-const-decl "measure_type" measure_theory nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (S formal-const-decl "sigma_algebra" measure_theory nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (T formal-type-decl nil measure_theory nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (measure_empty? const-decl "bool" generalized_measure_def nil)
    (mu const-decl "nnreal" measure_props nil)
    (measurable_set? const-decl "bool" measure_space_def nil)
    (mu_fin? const-decl "bool" measure_props nil)
    (subset_algebra_empty? const-decl "bool" subset_algebra_def nil)
    (null_set? const-decl "bool" measure_theory nil)
    (subset_algebra_emptyset name-judgement "(S)" measure_theory nil)
    (finite_emptyset name-judgement "finite_set[T]" countable_setofsets
     sets_aux)
    (finite_emptyset name-judgement "finite_set[T]" countable_props sets_aux)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil (null_emptyset subtype "sets[measure_theory.T].emptyset" "null_set")))
 (null_union 0
  (null_union-1 nil 3509948281
   ("" (skosimp)
    (("" (typepred "N2!1")
      (("" (typepred "N1!1")
        (("" (expand "null_set?")
          (("" (flatten)
            (("" (lemma "m_union" ("a" "N1!1" "b" "N2!1"))
              (("" (expand "x_add")
                (("" (expand "x_le")
                  (("" (expand "mu_fin?")
                    (("" (expand "mu")
                      (("" (assert)
                        (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (set type-eq-decl nil sets nil)
    (T formal-type-decl nil measure_theory nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (measurable_union application-judgement "measurable_set[T, S]"
     measure_theory nil)
    (m formal-const-decl "measure_type" measure_theory nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (S formal-const-decl "sigma_algebra" measure_theory nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (measurable_set nonempty-type-eq-decl nil measure_space_def nil)
    (measurable_set? const-decl "bool" measure_space_def nil)
    (m_union formula-decl nil measure_props nil)
    (x_le const-decl "bool" extended_nnreal extended_nnreal)
    (mu const-decl "nnreal" measure_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal" real_types
     nil)
    (mu_fin? const-decl "bool" measure_props nil)
    (x_add const-decl "extended_nnreal" extended_nnreal extended_nnreal))
   nil
   (null_union subtype
    "sets[measure_theory.T].union(measure_theory.N1, measure_theory.N2)"
    "null_set")))
 (null_intersection 0
  (null_intersection-1 nil 3509948281
   ("" (skosimp)
    (("" (typepred "N2!1")
      (("" (typepred "N1!1")
        (("" (expand "null_set?")
          (("" (flatten)
            (("" (expand "mu")
              (("" (expand "mu_fin?")
                ((""
                  (lemma "m_monotone"
                   ("a" "intersection[T](N1!1, N2!1)" "b" "N1!1"))
                  (("" (split)
                    (("1" (expand "x_le")
                      (("1" (assert)
                        (("1" (flatten) (("1" (assert) nil nil)) nil)) nil))
                      nil)
                     ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (set type-eq-decl nil sets nil)
    (T formal-type-decl nil measure_theory nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (measurable_intersection application-judgement "measurable_set"
     measure_theory nil)
    (mu const-decl "nnreal" measure_props nil)
    (m formal-const-decl "measure_type" measure_theory nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (S formal-const-decl "sigma_algebra" measure_theory nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (intersection const-decl "set" sets nil)
    (measurable_set nonempty-type-eq-decl nil measure_space_def nil)
    (measurable_set? const-decl "bool" measure_space_def nil)
    (m_monotone formula-decl nil measure_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (x_le const-decl "bool" extended_nnreal extended_nnreal)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)
    (mu_fin? const-decl "bool" measure_props nil))
   nil
   (null_intersection subtype
    "sets[measure_theory.T].intersection(measure_theory.N1, measure_theory.N2)"
    "null_set")))
 (null_difference 0
  (null_difference-1 nil 3509948281
   ("" (skosimp)
    (("" (lemma "m_monotone" ("a" "difference[T](N1!1, N2!1)" "b" "N1!1"))
      (("" (typepred "N1!1")
        (("" (typepred "N2!1")
          (("" (split)
            (("1" (expand "null_set?")
              (("1" (expand "x_le")
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (expand "mu_fin?")
                      (("1" (expand "mu")
                        (("1" (assert)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((m formal-const-decl "measure_type" measure_theory nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (S formal-const-decl "sigma_algebra" measure_theory nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil measure_theory nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (difference const-decl "set" sets nil)
    (measurable_set nonempty-type-eq-decl nil measure_space_def nil)
    (measurable_set? const-decl "bool" measure_space_def nil)
    (set type-eq-decl nil sets nil)
    (m_monotone formula-decl nil measure_props nil)
    (measurable_difference application-judgement "measurable_set[T, S]"
     measure_theory nil)
    (x_le const-decl "bool" extended_nnreal extended_nnreal)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (mu const-decl "nnreal" measure_props nil)
    (mu_fin? const-decl "bool" measure_props nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   nil
   (null_difference subtype
    "sets[measure_theory.T].difference(measure_theory.N1, measure_theory.N2)"
    "null_set")))
 (null_IUnion 0
  (null_IUnion-1 nil 3509948281
   ("" (skosimp)
    (("" (typepred "m")
      (("" (lemma "disjoint_IUnion[T]" ("A" "NS!1"))
        (("" (skosimp)
          (("" (replace -5)
            (("" (case "forall (n:nat): null_set?(B!1(n))")
              (("1" (hide -3 -4 -5 -6)
                (("1" (expand "measure?")
                  (("1" (flatten)
                    (("1" (expand "measure_countably_additive?")
                      (("1" (expand "null_set?")
                        (("1" (expand "mu_fin?")
                          (("1" (expand "mu")
                            (("1" (assert)
                              (("1" (rewrite "measurable_IUnion")
                                (("1" (inst -4 "B!1")
                                  (("1" (expand "x_eq")
                                    (("1" (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (expand "o ")
                                          (("1"
                                            (expand "x_sum")
                                            (("1"
                                              (case-replace
                                               "FORALL (i:nat): m(B!1(i))`1")
                                              (("1"
                                                (case-replace
                                                 "series(LAMBDA i: m(B!1(i))`2)=lambda (n:nat): 0")
                                                (("1"
                                                  (hide -1 -2 -3 -4 -5)
                                                  (("1"
                                                    (case-replace
                                                     "convergence_sequences.convergent?(LAMBDA (n: nat): 0)")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (lemma
                                                         "convergence_sequences.limit_lemma"
                                                         ("v"
                                                          "LAMBDA (n: nat): 0"))
                                                        (("1"
                                                          (replace -4)
                                                          (("1"
                                                            (hide-all-but
                                                             (-1 1))
                                                            (("1"
                                                              (expand
                                                               "convergence")
                                                              (("1"
                                                                (typepred
                                                                 "m(IUnion(B!1))`2")
                                                                (("1"
                                                                  (name-replace
                                                                   "BB"
                                                                   "m(IUnion(B!1))`2")
                                                                  (("1"
                                                                    (expand
                                                                     ">="
                                                                     -1)
                                                                    (("1"
                                                                      (expand
                                                                       "<="
                                                                       -1)
                                                                      (("1"
                                                                        (split)
                                                                        (("1"
                                                                          (inst
                                                                           -
                                                                           "BB")
                                                                          (("1"
                                                                            (skosimp)
                                                                            (("1"
                                                                              (inst
                                                                               -
                                                                               "n!1")
                                                                              (("1"
                                                                                (assert)
                                                                                (("1"
                                                                                  (grind)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (hide-all-but 1)
                                                      (("2"
                                                        (expand "convergent?")
                                                        (("2"
                                                          (inst + "0")
                                                          (("2"
                                                            (expand
                                                             "convergence")
                                                            (("2"
                                                              (skosimp)
                                                              (("2"
                                                                (inst + "0")
                                                                (("2"
                                                                  (skosimp)
                                                                  (("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide-all-but (-1 -2 1))
                                                  (("2"
                                                    (apply-extensionality
                                                     :hide?
                                                     t)
                                                    (("1"
                                                      (expand "series")
                                                      (("1"
                                                        (case-replace
                                                         "(LAMBDA (i:nat): m(B!1(i))`2) = lambda (i:nat): 0")
                                                        (("1"
                                                          (rewrite
                                                           "sigma_zero[nat]")
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (apply-extensionality
                                                           :hide?
                                                           t)
                                                          (("1"
                                                            (inst -2 "x!2")
                                                            (("1"
                                                              (flatten)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (skosimp)
                                                            (("2"
                                                              (inst -2 "i!1")
                                                              (("2"
                                                                (flatten)
                                                                (("2"
                                                                  (expand
                                                                   "measurable_set?")
                                                                  (("2"
                                                                    (propax)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (skosimp)
                                                          (("3"
                                                            (inst -2 "i!1")
                                                            (("3"
                                                              (flatten)
                                                              (("3"
                                                                (expand
                                                                 "measurable_set?")
                                                                (("3"
                                                                  (propax)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (skosimp)
                                                      (("2"
                                                        (inst -2 "i!1")
                                                        (("2"
                                                          (expand
                                                           "measurable_set?")
                                                          (("2"
                                                            (flatten)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (skosimp)
                                                  (("3"
                                                    (inst -2 "i!1")
                                                    (("3"
                                                      (flatten)
                                                      (("3"
                                                        (expand
                                                         "measurable_set?")
                                                        (("3"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (replace 1)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (skosimp)
                                                    (("2"
                                                      (inst - "i!1")
                                                      (("2"
                                                        (flatten)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (skosimp)
                                                (("3"
                                                  (inst - "i!1")
                                                  (("3"
                                                    (flatten)
                                                    (("3"
                                                      (expand
                                                       "measurable_set?")
                                                      (("3" (propax) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "disjoint_indexed_measurable?")
                                    (("2" (skolem + "n!1")
                                      (("2"
                                        (inst - "n!1")
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (expand "measurable_set?")
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (skolem + "n!1")
                                  (("2" (inst - "n!1")
                                    (("2" (flatten) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2 -5)
                (("2" (induct "n")
                  (("1" (replace -3) (("1" (assert) nil nil)) nil)
                   ("2" (skosimp)
                    (("2" (inst -5 "j!1")
                      (("2" (inst -3 "j!1")
                        (("2" (replace -3 * rl)
                          (("2"
                            (lemma "null_difference"
                             ("N1" "NS!1(j!1+1)" "N2" "IUnion(j!1, B!1)"))
                            (("1" (replace -6 -1 rl) (("1" (propax) nil nil))
                              nil)
                             ("2" (replace -3)
                              (("2" (hide-all-but 1)
                                (("2"
                                  (case "forall (n:nat): null_set?(IUnion(n, NS!1))")
                                  (("1" (inst - "j!1") nil nil)
                                   ("2" (hide 2)
                                    (("2" (induct "n")
                                      (("1"
                                        (rewrite "IUnion_0_def")
                                        (("1" (assert) nil nil))
                                        nil)
                                       ("2"
                                        (skosimp)
                                        (("2"
                                          (rewrite "IUnion_n_def" 1)
                                          (("2"
                                            (rewrite "null_union")
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((m formal-const-decl "measure_type" measure_theory nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (S formal-const-decl "sigma_algebra" measure_theory nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (T formal-type-decl nil measure_theory nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (null_difference judgement-tcc nil measure_theory nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IUnion const-decl "set[T]" nat_indexed_sets sets_aux)
    (null_union judgement-tcc nil measure_theory nil)
    (posint_plus_nnint_is_posint application-judgement "posint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (IUnion_n_def formula-decl nil nat_indexed_sets sets_aux)
    (IUnion_0_def formula-decl nil nat_indexed_sets sets_aux)
    (mu const-decl "nnreal" measure_props nil)
    (x_eq const-decl "bool" extended_nnreal extended_nnreal)
    (x_sum const-decl "extended_nnreal" extended_nnreal extended_nnreal)
    (series const-decl "sequence[real]" series series)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (convergence const-decl "bool" convergence_sequences analysis)
    (<= const-decl "bool" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (> const-decl "bool" reals nil)
    (BB skolem-const-decl "nnreal" measure_theory nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (limit_lemma formula-decl nil convergence_sequences analysis)
    (convergent? const-decl "bool" convergence_sequences analysis)
    (sigma_zero formula-decl nil sigma reals)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (T_high type-eq-decl nil sigma reals) (T_low type-eq-decl nil sigma reals)
    (sigma_nnreal application-judgement "nnreal" sigma_nat reals)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (O const-decl "T3" function_props nil)
    (disjoint_indexed_measurable nonempty-type-eq-decl nil
     generalized_measure_def nil)
    (disjoint_indexed_measurable? const-decl "bool" generalized_measure_def
     nil)
    (B!1 skolem-const-decl "sequence[set[T]]" measure_theory nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (measurable_IUnion judgement-tcc nil measure_space_def nil)
    (measurable_set? const-decl "bool" measure_space_def nil)
    (measurable_set nonempty-type-eq-decl nil measure_space_def nil)
    (mu_fin? const-decl "bool" measure_props nil)
    (measure_countably_additive? const-decl "bool" generalized_measure_def
     nil)
    (sigma_algebra_IUnion_rew application-judgement "(S)" measure_theory nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (sequence type-eq-decl nil sequences nil) (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (disjoint_IUnion formula-decl nil nat_indexed_sets sets_aux))
   nil
   (null_IUnion subtype
    "indexed_sets[nat, measure_theory.T].IUnion(measure_theory.NS)"
    "null_set")))
 (null_Union 0
  (null_Union-1 nil 3423545392
   ("" (skosimp)
    (("" (lemma "Union_IUnion" ("XS" "Z!1"))
      (("" (assert)
        (("" (skosimp)
          (("" (replace -1)
            (("" (rewrite "null_IUnion")
              (("" (hide -1 -4 2)
                (("" (skolem + ("n!1"))
                  (("" (inst - "n!1")
                    (("" (split -1)
                      (("1" (rewrite "emptyset_is_empty?")
                        (("1" (replace -1)
                          (("1" (rewrite "null_emptyset") nil nil)) nil))
                        nil)
                       ("2" (expand "every")
                        (("2" (inst - "YS!1(n!1)") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil measure_theory nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Union_IUnion formula-decl nil countable_indexed_sets sets_aux)
    (null_IUnion judgement-tcc nil measure_theory nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (null_set? const-decl "bool" measure_theory nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (sequence type-eq-decl nil sequences nil)
    (every const-decl "bool" sets nil)
    (n!1 skolem-const-decl "nat" measure_theory nil)
    (YS!1 skolem-const-decl "sequence[set[T]]" measure_theory nil)
    (Z!1 skolem-const-decl "setofsets[T]" measure_theory nil)
    (emptyset_is_empty? formula-decl nil sets_lemmas nil)
    (subset_algebra_emptyset name-judgement "(S)" measure_theory nil)
    (null_emptyset name-judgement "null_set" measure_theory nil)
    (finite_emptyset name-judgement "finite_set[T]" countable_setofsets
     sets_aux)
    (finite_emptyset name-judgement "finite_set[T]" countable_props sets_aux)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (null_emptyset judgement-tcc nil measure_theory nil)
    (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])"
     sets_lemmas nil))
   shostak))
 (negligible_union 0
  (negligible_union-1 nil 3509948281
   ("" (skosimp)
    (("" (typepred "E2!1")
      (("" (typepred "E1!1")
        (("" (expand "negligible_set?")
          (("" (skosimp*)
            (("" (inst + "union(X!1,X!2)")
              (("" (rewrite "null_union")
                (("" (hide -1 -3)
                  (("" (expand "subset?")
                    (("" (skosimp)
                      (("" (inst - "x!1")
                        (("" (inst - "x!1") (("" (grind) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((negligible nonempty-type-eq-decl nil measure_theory nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (set type-eq-decl nil sets nil)
    (T formal-type-decl nil measure_theory nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (null_union judgement-tcc nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil))
   nil
   (negligible_union subtype
    "sets[measure_theory.T].union(measure_theory.E1, measure_theory.E2)"
    "negligible")))
 (negligible_intersection 0
  (negligible_intersection-1 nil 3509948281
   ("" (skosimp)
    (("" (typepred "E2!1")
      (("" (typepred "E1!1")
        (("" (expand "negligible_set?")
          (("" (skosimp*)
            (("" (inst + "X!1")
              (("" (assert)
                (("" (hide -1 -3)
                  (("" (expand "subset?")
                    (("" (skosimp)
                      (("" (inst - "x!1")
                        (("" (inst - "x!1") (("" (grind) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((negligible nonempty-type-eq-decl nil measure_theory nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (set type-eq-decl nil sets nil)
    (T formal-type-decl nil measure_theory nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   nil
   (negligible_intersection subtype
    "sets[measure_theory.T].intersection(measure_theory.E1, measure_theory.E2)"
    "negligible")))
 (negligible_IUnion 0
  (negligible_IUnion-1 nil 3509948281
   ("" (skosimp)
    (("" (case "forall (n:nat): exists N: subset?(ES!1(n),N)")
      (("1" (expand "negligible_set?")
        (("1"
          (name "NNS"
                "lambda (n:nat): choose[null_set]({ N | subset?(ES!1(n),N)})")
          (("1" (lemma "null_IUnion" ("NS" "NNS"))
            (("1" (inst + "IUnion(NNS)")
              (("1" (assert)
                (("1" (hide -2)
                  (("1" (expand "subset?" 1)
                    (("1" (skosimp)
                      (("1" (expand "member")
                        (("1" (expand "IUnion")
                          (("1" (hide -1)
                            (("1" (skosimp)
                              (("1" (inst + "i!1")
                                (("1" (expand "NNS")
                                  (("1"
                                    (lemma "choose_member[null_set]"
                                     ("a" "{N | subset?(ES!1(i!1), N)}"))
                                    (("1" (split)
                                      (("1"
                                        (expand "member")
                                        (("1"
                                          (expand "subset?" -1 1)
                                          (("1"
                                            (expand "member")
                                            (("1"
                                              (inst - "x!1")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide 1)
                                        (("2"
                                          (expand "empty?")
                                          (("2"
                                            (inst -2 "i!1")
                                            (("2"
                                              (skosimp)
                                              (("2"
                                                (inst - "N!1")
                                                (("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skosimp)
            (("2" (inst - "n!1")
              (("2" (skosimp)
                (("2" (expand "nonempty?")
                  (("2" (expand "empty?")
                    (("2" (inst - "N!1") (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (skosimp)
          (("2" (typepred "ES!1(n!1)")
            (("2" (expand "negligible_set?")
              (("2" (skosimp) (("2" (inst + "X!1") nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (X!1 skolem-const-decl "set[T]" measure_theory nil)
    (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (NNS skolem-const-decl "[n: nat -> ({N | subset?(ES!1(n), N)})]"
     measure_theory nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (empty? const-decl "bool" sets nil)
    (choose_member formula-decl nil sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (null_IUnion application-judgement "null_set" measure_theory nil)
    (null_IUnion judgement-tcc nil measure_theory nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil measure_theory nil)
    (set type-eq-decl nil sets nil)
    (null_set? const-decl "bool" measure_theory nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (subset? const-decl "bool" sets nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (sequence type-eq-decl nil sequences nil))
   nil
   (negligible_IUnion subtype
    "indexed_sets[nat, measure_theory.T].IUnion(measure_theory.ES)"
    "negligible")))
 (negligible_Union 0
  (negligible_Union-1 nil 3423653542
   ("" (skosimp)
    (("" (lemma "Union_IUnion" ("XS" "Z!1"))
      (("" (assert)
        (("" (skosimp)
          (("" (replace -1)
            (("" (rewrite "negligible_IUnion")
              (("" (hide -1 -4 2)
                (("" (skolem + ("n!1"))
                  (("" (inst - "n!1")
                    (("" (split -1)
                      (("1" (rewrite "emptyset_is_empty?")
                        (("1" (replace -1)
                          (("1" (hide -1 -2)
                            (("1" (expand "negligible_set?")
                              (("1" (inst + "emptyset[T]")
                                (("1" (grind) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "every")
                        (("2" (inst - "YS!1(n!1)") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil measure_theory nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Union_IUnion formula-decl nil countable_indexed_sets sets_aux)
    (negligible_IUnion judgement-tcc nil measure_theory nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (sequence type-eq-decl nil sequences nil)
    (every const-decl "bool" sets nil)
    (n!1 skolem-const-decl "nat" measure_theory nil)
    (YS!1 skolem-const-decl "sequence[set[T]]" measure_theory nil)
    (Z!1 skolem-const-decl "setofsets[T]" measure_theory nil)
    (emptyset_is_empty? formula-decl nil sets_lemmas nil)
    (subset_algebra_emptyset name-judgement "(S)" measure_theory nil)
    (null_emptyset name-judgement "null_set" measure_theory nil)
    (finite_emptyset name-judgement "finite_set[T]" countable_setofsets
     sets_aux)
    (finite_emptyset name-judgement "finite_set[T]" countable_props sets_aux)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (Union_surjective name-judgement "(surjective?[setofsets[T], set[T]])"
     sets_lemmas nil))
   shostak))
 (negligible_subset 0
  (negligible_subset-1 nil 3395735108
   ("" (skosimp)
    (("" (typepred "E!1")
      (("" (expand "negligible_set?")
        (("" (skosimp)
          (("" (inst + "X!2")
            (("" (assert)
              (("" (hide -1)
                (("" (expand "subset?")
                  (("" (skosimp)
                    (("" (inst - "x!1")
                      (("" (inst - "x!1") (("" (assert) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((negligible nonempty-type-eq-decl nil measure_theory nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (set type-eq-decl nil sets nil)
    (T formal-type-decl nil measure_theory nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil))
   shostak))
 (ae_eq_equivalence 0
  (ae_eq_equivalence-2 "" 3789903778
   ("" (expand "equivalence?")
    (("" (split)
      (("1" (expand "reflexive?")
        (("1" (expand "ae_eq?")
          (("1" (expand "pointwise_ae?")
            (("1" (expand "ae?")
              (("1" (expand "fullset")
                (("1" (expand "ae_in?")
                  (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "symmetric?")
        (("2" (expand "ae_eq?")
          (("2" (expand "pointwise_ae?")
            (("2" (expand "ae?")
              (("2" (expand "fullset")
                (("2" (expand "ae_in?")
                  (("2" (skosimp*)
                    (("2" (inst + "E!1")
                      (("2" (skosimp)
                        (("2" (inst - "x!2") (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (expand "transitive?")
        (("3" (expand "ae_eq?")
          (("3" (expand "pointwise_ae?")
            (("3" (expand "ae?")
              (("3" (expand "fullset")
                (("3" (expand "ae_in?")
                  (("3" (skosimp*)
                    (("3" (inst + "union(E!1,E!2)")
                      (("3" (skosimp)
                        (("3" (inst - "x!2")
                          (("3" (inst - "x!2") (("3" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((transitive? const-decl "bool" relations nil)
    (union const-decl "set" sets nil)
    (negligible_union application-judgement "negligible" measure_theory nil)
    (symmetric? const-decl "bool" relations nil)
    (TRUE const-decl "bool" booleans nil)
    (T formal-type-decl nil measure_theory nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (reflexive? const-decl "bool" relations nil)
    (pointwise_ae? const-decl "bool" measure_theory nil)
    (fullset const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (ae? const-decl "bool" measure_theory nil)
    (subset_algebra_fullset name-judgement "(S)" measure_theory nil)
    (measurable_fullset name-judgement "measurable_set[T, S]" measure_theory
     nil)
    (ae_eq? const-decl "bool" measure_theory nil)
    (equivalence? const-decl "bool" relations nil))
   shostak)
  (ae_eq_equivalence-1 nil 3453089848
   ("" (expand "equivalence?")
    (("" (split)
      (("1" (expand "reflexive?")
        (("1" (expand "ae_eq?")
          (("1" (expand "restrict")
            (("1" (expand "pointwise_ae?")
              (("1" (expand "ae?")
                (("1" (expand "fullset")
                  (("1" (expand "ae_in?")
                    (("1" (expand "member") (("1" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "symmetric?")
        (("2" (expand "ae_eq?")
          (("2" (expand "restrict")
            (("2" (expand "pointwise_ae?")
              (("2" (expand "ae?")
                (("2" (expand "fullset")
                  (("2" (expand "ae_in?")
                    (("2" (skosimp*)
                      (("2" (inst + "E!1")
                        (("2" (skosimp)
                          (("2" (inst - "x!2") (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (expand "transitive?")
        (("3" (expand "ae_eq?")
          (("3" (expand "restrict")
            (("3" (expand "pointwise_ae?")
              (("3" (expand "ae?")
                (("3" (expand "fullset")
                  (("3" (expand "ae_in?")
                    (("3" (skosimp*)
                      (("3" (inst + "union(E!1,E!2)")
                        (("3" (skosimp)
                          (("3" (inst - "x!2")
                            (("3" (inst - "x!2") (("3" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil) (fullset const-decl "set" sets nil)
    (reflexive? const-decl "bool" relations nil)
    (set type-eq-decl nil sets nil)
    (symmetric? const-decl "bool" relations nil)
    (union const-decl "set" sets nil)
    (transitive? const-decl "bool" relations nil)
    (equivalence? const-decl "bool" relations nil))
   shostak))
 (ae_le_reflexive 0
  (ae_le_reflexive-1 nil 3453089826
   ("" (expand "reflexive?")
    (("" (expand "ae_le?")
      (("" (expand "pointwise_ae?")
        (("" (expand "ae?")
          (("" (expand "fullset")
            (("" (expand "ae_in?")
              (("" (expand "member") (("" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ae_le? const-decl "bool" measure_theory nil)
    (measurable_fullset name-judgement "measurable_set[T, S]" measure_theory
     nil)
    (subset_algebra_fullset name-judgement "(S)" measure_theory nil)
    (ae? const-decl "bool" measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (member const-decl "bool" sets nil) (fullset const-decl "set" sets nil)
    (pointwise_ae? const-decl "bool" measure_theory nil)
    (reflexive? const-decl "bool" relations nil))
   shostak))
 (ae_le_antisymmetric 0
  (ae_le_antisymmetric-2 "" 3789903779
   ("" (expand "ae_le?")
    (("" (expand "ae_eq?")
      (("" (expand "pointwise_ae?")
        (("" (expand "ae?")
          (("" (expand "fullset")
            (("" (expand "ae_in?")
              (("" (skosimp*)
                (("" (inst + "union(E!1,E!2)")
                  (("" (skosimp)
                    (("" (inst - "x!1")
                      (("" (inst - "x!1") (("" (grind) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ae_eq? const-decl "bool" measure_theory nil)
    (measurable_fullset name-judgement "measurable_set[T, S]" measure_theory
     nil)
    (subset_algebra_fullset name-judgement "(S)" measure_theory nil)
    (ae? const-decl "bool" measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (negligible_union application-judgement "negligible" measure_theory nil)
    (union const-decl "set" sets nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil measure_theory nil)
    (TRUE const-decl "bool" booleans nil) (member const-decl "bool" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (fullset const-decl "set" sets nil)
    (pointwise_ae? const-decl "bool" measure_theory nil)
    (ae_le? const-decl "bool" measure_theory nil))
   shostak)
  (ae_le_antisymmetric-1 nil 3453089720
   ("" (expand "ae_le?")
    (("" (expand "ae_eq?")
      (("" (expand "pointwise_ae?")
        (("" (expand "restrict")
          (("" (expand "ae?")
            (("" (expand "fullset")
              (("" (expand "ae_in?")
                (("" (skosimp*)
                  (("" (inst + "union(E!1,E!2)")
                    (("" (skosimp)
                      (("" (inst - "x!1")
                        (("" (inst - "x!1") (("" (grind) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((union const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (member const-decl "bool" sets nil) (fullset const-decl "set" sets nil))
   shostak))
 (ae_le_transitive 0
  (ae_le_transitive-1 nil 3453089782
   ("" (expand "transitive?")
    (("" (expand "ae_le?")
      (("" (expand "pointwise_ae?")
        (("" (expand "ae?")
          (("" (expand "fullset")
            (("" (expand "ae_in?")
              (("" (skosimp*)
                (("" (inst + "union(E!1,E!2)")
                  (("" (skosimp)
                    (("" (inst - "x!2")
                      (("" (inst - "x!2") (("" (grind) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ae_le? const-decl "bool" measure_theory nil)
    (measurable_fullset name-judgement "measurable_set[T, S]" measure_theory
     nil)
    (subset_algebra_fullset name-judgement "(S)" measure_theory nil)
    (ae? const-decl "bool" measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (negligible_union application-judgement "negligible" measure_theory nil)
    (union const-decl "set" sets nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil measure_theory nil)
    (TRUE const-decl "bool" booleans nil) (member const-decl "bool" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (fullset const-decl "set" sets nil)
    (pointwise_ae? const-decl "bool" measure_theory nil)
    (transitive? const-decl "bool" relations nil))
   shostak))
 (ae_convergence_cauchy 0
  (ae_convergence_cauchy-1 nil 3395638376
   ("" (skosimp)
    (("" (expand "ae_cauchy?")
      (("" (expand "ae_convergence?")
        (("" (expand "fullset")
          (("" (expand "ae_convergence_in?")
            (("" (expand "ae_cauchy_in?")
              (("" (expand "ae_in?")
                (("" (skosimp)
                  (("" (inst + "E!1")
                    (("" (skosimp)
                      (("" (inst - "x!1")
                        (("" (assert)
                          (("" (hide 1)
                            (("" (rewrite "metric_convergence_def" *)
                              (("" (expand "cauchy?")
                                (("" (skosimp)
                                  (("" (expand "metric_converges_to")
                                    (("" (expand "ball")
                                      ((""
                                        (expand "member")
                                        ((""
                                          (inst - "r!1/2")
                                          ((""
                                            (skosimp)
                                            ((""
                                              (inst + "n!1")
                                              ((""
                                                (skosimp)
                                                ((""
                                                  (inst-cp - "i!1")
                                                  ((""
                                                    (inst - "j!1")
                                                    ((""
                                                      (assert)
                                                      (("" (grind) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ae_cauchy? const-decl "bool" measure_theory nil)
    (fullset const-decl "set" sets nil)
    (ae_cauchy_in? const-decl "bool" measure_theory nil)
    (member const-decl "bool" sets nil)
    (metric_convergence_def formula-decl nil metric_space metric_space)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sequence type-eq-decl nil sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (ball const-decl "set[T]" metric_space_def metric_space)
    (posreal_div_posreal_is_posreal application-judgement "posreal" real_types
     nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (metric_converges_to const-decl "bool" metric_space_def metric_space)
    (cauchy? const-decl "bool" metric_space_def metric_space)
    (TRUE const-decl "bool" booleans nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (ae_convergence_in? const-decl "bool" measure_theory nil)
    (ae_convergence? const-decl "bool" measure_theory nil))
   shostak))
 (ae_convergence_eq 0
  (ae_convergence_eq-2 "" 3789903784
   ("" (skosimp)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "ae_convergence?")
          (("1" (expand "ae_eq?")
            (("1" (expand "pointwise_ae?")
              (("1" (expand "ae?")
                (("1" (expand "fullset")
                  (("1" (expand "ae_convergence_in?")
                    (("1" (expand "ae_in?")
                      (("1" (skosimp*)
                        (("1" (inst + "union(E!1,E!2)")
                          (("1" (skosimp)
                            (("1" (inst - "x!1")
                              (("1" (inst - "x!1")
                                (("1" (expand "union")
                                  (("1" (expand "member")
                                    (("1" (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (lemma
                                           "hausdorff_convergence.unique_limit"
                                           ("u"
                                            "LAMBDA n: F!1(n)(x!1)"
                                            "l1"
                                            "f!1(x!1)"
                                            "l2"
                                            "g!1(x!1)"))
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "ae_eq?")
          (("2" (expand "ae_convergence?")
            (("2" (expand "ae_convergence_in?")
              (("2" (expand "pointwise_ae?")
                (("2" (expand "ae?")
                  (("2" (expand "fullset")
                    (("2" (expand "ae_in?")
                      (("2" (skosimp*)
                        (("2" (inst + "union(E!1,E!2)")
                          (("2" (skosimp)
                            (("2" (inst - "x!1")
                              (("2" (inst - "x!1")
                                (("2" (expand "union")
                                  (("2" (expand "member")
                                    (("2" (flatten) (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ae_eq? const-decl "bool" measure_theory nil)
    (measurable_fullset name-judgement "measurable_set[T, S]" measure_theory
     nil)
    (subset_algebra_fullset name-judgement "(S)" measure_theory nil)
    (ae? const-decl "bool" measure_theory nil)
    (ae_convergence_in? const-decl "bool" measure_theory nil)
    (member const-decl "bool" sets nil)
    (unique_limit formula-decl nil hausdorff_convergence topology)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sequence type-eq-decl nil sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil) (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (TRUE const-decl "bool" booleans nil)
    (T formal-type-decl nil measure_theory nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (union const-decl "set" sets nil)
    (negligible_union application-judgement "negligible" measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (fullset const-decl "set" sets nil)
    (pointwise_ae? const-decl "bool" measure_theory nil)
    (ae_convergence? const-decl "bool" measure_theory nil))
   shostak)
  (ae_convergence_eq-1 nil 3395638591
   ("" (skosimp)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "ae_convergence?")
          (("1" (expand "ae_eq?")
            (("1" (expand "restrict")
              (("1" (expand "pointwise_ae?")
                (("1" (expand "ae?")
                  (("1" (expand "fullset")
                    (("1" (expand "ae_convergence_in?")
                      (("1" (expand "ae_in?")
                        (("1" (skosimp*)
                          (("1" (inst + "union(E!1,E!2)")
                            (("1" (skosimp)
                              (("1" (inst - "x!1")
                                (("1" (inst - "x!1")
                                  (("1" (expand "union")
                                    (("1" (expand "member")
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (lemma
                                             "hausdorff_convergence.unique_limit"
                                             ("u"
                                              "LAMBDA n: F!1(n)(x!1)"
                                              "l1"
                                              "f!1(x!1)"
                                              "l2"
                                              "g!1(x!1)"))
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "ae_eq?")
          (("2" (expand "restrict")
            (("2" (expand "ae_convergence?")
              (("2" (expand "ae_convergence_in?")
                (("2" (expand "pointwise_ae?")
                  (("2" (expand "ae?")
                    (("2" (expand "fullset")
                      (("2" (expand "ae_in?")
                        (("2" (skosimp*)
                          (("2" (inst + "union(E!1,E!2)")
                            (("2" (skosimp)
                              (("2" (inst - "x!1")
                                (("2" (inst - "x!1")
                                  (("2" (expand "union")
                                    (("2" (expand "member")
                                      (("2"
                                        (flatten)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fullset const-decl "set" sets nil) (union const-decl "set" sets nil)
    (set type-eq-decl nil sets nil)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (setofsets type-eq-decl nil sets nil)
    (sequence type-eq-decl nil sequences nil)
    (unique_limit formula-decl nil hausdorff_convergence topology)
    (member const-decl "bool" sets nil))
   shostak))
 (ae_eq_convergence 0
  (ae_eq_convergence-3 "" 3789903784
   ("" (skosimp)
    (("" (expand "ae_convergence?")
      ((""
        (case "exists NS: forall n,x: (NOT NS(n)(x)) => F!1(n)(x)=G!1(n)(x)")
        (("1" (hide -3)
          (("1" (expand "fullset")
            (("1" (expand "ae_convergence_in?")
              (("1" (expand "ae_in?")
                (("1" (skosimp*)
                  (("1" (typepred "E!1")
                    (("1" (expand "negligible_set?")
                      (("1" (skosimp)
                        (("1" (inst + "union(X!1,IUnion(NS!1))")
                          (("1" (skosimp)
                            (("1" (expand "union")
                              (("1" (expand "member")
                                (("1" (flatten)
                                  (("1" (inst - "x!1")
                                    (("1" (expand "subset?")
                                      (("1"
                                        (inst - "x!1")
                                        (("1"
                                          (expand "member")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (rewrite
                                               "metric_convergence_def"
                                               *)
                                              (("1"
                                                (rewrite
                                                 "metric_convergence_def"
                                                 *)
                                                (("1"
                                                  (expand
                                                   "metric_converges_to")
                                                  (("1"
                                                    (expand "ball")
                                                    (("1"
                                                      (expand "member")
                                                      (("1"
                                                        (skosimp)
                                                        (("1"
                                                          (inst -3 "r!1")
                                                          (("1"
                                                            (skosimp)
                                                            (("1"
                                                              (inst + "n!1")
                                                              (("1"
                                                                (skosimp)
                                                                (("1"
                                                                  (inst
                                                                   -3
                                                                   "i!1")
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (inst
                                                                       -
                                                                       "i!1"
                                                                       "x!1")
                                                                      (("1"
                                                                        (expand
                                                                         "IUnion")
                                                                        (("1"
                                                                          (inst
                                                                           +
                                                                           "i!1")
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2" (rewrite "negligible_union")
                              (("2" (rewrite "null_is_negligible") nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide -1 2)
          (("2"
            (case "FORALL n: EXISTS N: forall x: (NOT N(x)) => F!1(n)(x) = G!1(n)(x)")
            (("1" (hide -2)
              (("1"
                (inst +
                 "lambda n: choose({N | FORALL x: (NOT N(x)) => F!1(n)(x) = G!1(n)(x)})")
                (("1" (skosimp)
                  (("1"
                    (lemma "choose_member"
                     ("a"
                      "{N | FORALL x: (NOT N(x)) => F!1(n!1)(x) = G!1(n!1)(x)}"))
                    (("1" (split -1)
                      (("1" (expand "member")
                        (("1" (inst - "x!1")
                          (("1" (replace 1 -1) (("1" (propax) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (hide 1)
                        (("2" (inst - "n!1")
                          (("2" (skosimp)
                            (("2" (expand "empty?")
                              (("2" (expand "member")
                                (("2" (inst - "N!1") nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skosimp)
                  (("2" (inst - "n!1")
                    (("2" (skosimp)
                      (("2" (expand "nonempty?")
                        (("2" (expand "empty?")
                          (("2" (expand "member")
                            (("2" (inst - "N!1") nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (skosimp)
                (("2" (inst - "n!1")
                  (("2" (expand "ae_eq?")
                    (("2" (expand "pointwise_ae?")
                      (("2" (expand "ae?")
                        (("2" (expand "fullset")
                          (("2" (expand "ae_in?")
                            (("2" (skosimp)
                              (("2" (typepred "E!1")
                                (("2" (expand "negligible_set?")
                                  (("2" (skosimp)
                                    (("2" (inst + "X!1")
                                      (("2"
                                        (skosimp)
                                        (("2"
                                          (inst - "x!1")
                                          (("2"
                                            (expand "subset?")
                                            (("2"
                                              (inst - "x!1")
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ae_convergence? const-decl "bool" measure_theory nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sequence type-eq-decl nil sequences nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (set type-eq-decl nil sets nil)
    (T formal-type-decl nil measure_theory nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fullset const-decl "set" sets nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (null_IUnion application-judgement "null_set" measure_theory nil)
    (union const-decl "set" sets nil)
    (X!1 skolem-const-decl "set[T]" measure_theory nil)
    (IUnion const-decl "set[T]" indexed_sets nil)
    (NS!1 skolem-const-decl "sequence[null_set]" measure_theory nil)
    (subset? const-decl "bool" sets nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (metric_convergence_def formula-decl nil metric_space metric_space)
    (metric_converges_to const-decl "bool" metric_space_def metric_space)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ball const-decl "set[T]" metric_space_def metric_space)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (TRUE const-decl "bool" booleans nil) (member const-decl "bool" sets nil)
    (negligible_union judgement-tcc nil measure_theory nil)
    (null_is_negligible judgement-tcc nil measure_theory nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (ae_convergence_in? const-decl "bool" measure_theory nil)
    (pointwise_ae? const-decl "bool" measure_theory nil)
    (X!1 skolem-const-decl "set[T]" measure_theory nil)
    (ae? const-decl "bool" measure_theory nil)
    (ae_eq? const-decl "bool" measure_theory nil)
    (G!1 skolem-const-decl "sequence[[T -> real]]" measure_theory nil)
    (F!1 skolem-const-decl "sequence[[T -> real]]" measure_theory nil)
    (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil)
    (choose_member formula-decl nil sets_lemmas nil)
    (empty? const-decl "bool" sets nil))
   shostak)
  (ae_eq_convergence-2 "" 3758920390
   ("" (skosimp)
    (("" (expand "ae_convergence?")
      ((""
        (case "exists NS: forall n,x: (NOT NS(n)(x)) => F!1(n)(x)=G!1(n)(x)")
        (("1" (hide -3)
          (("1" (expand "fullset")
            (("1" (expand "ae_convergence_in?")
              (("1" (expand "ae_in?")
                (("1" (skosimp*)
                  (("1" (typepred "E!1")
                    (("1" (expand "negligible_set?")
                      (("1" (skosimp)
                        (("1" (inst + "union(X!1,IUnion(NS!1))")
                          (("1" (skosimp)
                            (("1" (expand "union")
                              (("1" (expand "member")
                                (("1" (flatten)
                                  (("1" (inst - "x!1")
                                    (("1" (expand "subset?")
                                      (("1"
                                        (inst - "x!1")
                                        (("1"
                                          (expand "member")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (rewrite
                                               "metric_convergence_def"
                                               *)
                                              (("1"
                                                (rewrite
                                                 "metric_convergence_def"
                                                 *)
                                                (("1"
                                                  (expand
                                                   "metric_converges_to")
                                                  (("1"
                                                    (expand "ball")
                                                    (("1"
                                                      (expand "member")
                                                      (("1"
                                                        (skosimp)
                                                        (("1"
                                                          (inst -3 "r!1")
                                                          (("1"
                                                            (skosimp)
                                                            (("1"
                                                              (inst + "n!1")
                                                              (("1"
                                                                (skosimp)
                                                                (("1"
                                                                  (inst
                                                                   -3
                                                                   "i!1")
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (inst
                                                                       -
                                                                       "i!1"
                                                                       "x!1")
                                                                      (("1"
                                                                        (expand
                                                                         "IUnion")
                                                                        (("1"
                                                                          (inst
                                                                           +
                                                                           "i!1")
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide-all-but 1)
                                                  (("2" (grind) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2" (rewrite "negligible_union")
                              (("2" (rewrite "null_is_negligible") nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide -1 2)
          (("2"
            (case "FORALL n: EXISTS N: forall x: (NOT N(x)) => F!1(n)(x) = G!1(n)(x)")
            (("1" (hide -2)
              (("1"
                (inst +
                 "lambda n: choose({N | FORALL x: (NOT N(x)) => F!1(n)(x) = G!1(n)(x)})")
                (("1" (skosimp)
                  (("1"
                    (lemma "choose_member"
                     ("a"
                      "{N | FORALL x: (NOT N(x)) => F!1(n!1)(x) = G!1(n!1)(x)}"))
                    (("1" (split -1)
                      (("1" (expand "member")
                        (("1" (inst - "x!1")
                          (("1" (replace 1 -1) (("1" (propax) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (hide 1)
                        (("2" (inst - "n!1")
                          (("2" (skosimp)
                            (("2" (expand "empty?")
                              (("2" (expand "member")
                                (("2" (inst - "N!1") nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skosimp)
                  (("2" (inst - "n!1")
                    (("2" (skosimp)
                      (("2" (expand "nonempty?")
                        (("2" (expand "empty?")
                          (("2" (expand "member")
                            (("2" (inst - "N!1") nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (skosimp)
                (("2" (inst - "n!1")
                  (("2" (expand "ae_eq?")
                    (("2" (expand "pointwise_ae?")
                      (("2" (expand "ae?")
                        (("2" (expand "fullset")
                          (("2" (expand "ae_in?")
                            (("2" (skosimp)
                              (("2" (typepred "E!1")
                                (("2" (expand "negligible_set?")
                                  (("2" (skosimp)
                                    (("2" (inst + "X!1")
                                      (("2"
                                        (skosimp)
                                        (("2"
                                          (inst - "x!1")
                                          (("2"
                                            (expand "subset?")
                                            (("2"
                                              (inst - "x!1")
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((empty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil)
    (nonempty? const-decl "bool" sets nil) (union const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (metric_convergence_def formula-decl nil metric_space metric_space)
    (metric_converges_to const-decl "bool" metric_space_def metric_space)
    (ball const-decl "set[T]" metric_space_def metric_space)
    (member const-decl "bool" sets nil) (fullset const-decl "set" sets nil)
    (set type-eq-decl nil sets nil) (sequence type-eq-decl nil sequences nil))
   shostak)
  (ae_eq_convergence-1 nil 3395676012
   ("" (skosimp)
    (("" (expand "ae_convergence?")
      ((""
        (case "exists NS: forall n,x: (NOT NS(n)(x)) => F!1(n)(x)=G!1(n)(x)")
        (("1" (hide -3)
          (("1" (expand "fullset")
            (("1" (expand "ae_convergence_in?")
              (("1" (expand "ae_in?")
                (("1" (skosimp*)
                  (("1" (typepred "E!1")
                    (("1" (expand "negligible_set?")
                      (("1" (skosimp)
                        (("1" (inst + "union(X!1,IUnion(NS!1))")
                          (("1" (skosimp)
                            (("1" (expand "union")
                              (("1" (expand "member")
                                (("1" (flatten)
                                  (("1" (inst - "x!1")
                                    (("1" (expand "subset?")
                                      (("1"
                                        (inst - "x!1")
                                        (("1"
                                          (expand "member")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (rewrite
                                               "metric_convergence_def"
                                               *)
                                              (("1"
                                                (rewrite
                                                 "metric_convergence_def"
                                                 *)
                                                (("1"
                                                  (expand
                                                   "metric_converges_to")
                                                  (("1"
                                                    (expand "ball")
                                                    (("1"
                                                      (expand "member")
                                                      (("1"
                                                        (skosimp)
                                                        (("1"
                                                          (inst -3 "r!1")
                                                          (("1"
                                                            (skosimp)
                                                            (("1"
                                                              (inst + "n!1")
                                                              (("1"
                                                                (skosimp)
                                                                (("1"
                                                                  (inst
                                                                   -3
                                                                   "i!1")
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (inst
                                                                       -
                                                                       "i!1"
                                                                       "x!1")
                                                                      (("1"
                                                                        (expand
                                                                         "IUnion")
                                                                        (("1"
                                                                          (inst
                                                                           +
                                                                           "i!1")
                                                                          (("1"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2" (rewrite "negligible_union")
                              (("2" (rewrite "null_is_negligible") nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide -1 2)
          (("2"
            (case "FORALL n: EXISTS N: forall x: (NOT N(x)) => F!1(n)(x) = G!1(n)(x)")
            (("1" (hide -2)
              (("1"
                (inst +
                 "lambda n: choose({N | FORALL x: (NOT N(x)) => F!1(n)(x) = G!1(n)(x)})")
                (("1" (skosimp)
                  (("1"
                    (lemma "choose_member"
                     ("a"
                      "{N | FORALL x: (NOT N(x)) => F!1(n!1)(x) = G!1(n!1)(x)}"))
                    (("1" (split -1)
                      (("1" (expand "member")
                        (("1" (inst - "x!1")
                          (("1" (replace 1 -1) (("1" (propax) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (hide 1)
                        (("2" (inst - "n!1")
                          (("2" (skosimp)
                            (("2" (expand "empty?")
                              (("2" (expand "member")
                                (("2" (inst - "N!1") nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skosimp)
                  (("2" (inst - "n!1")
                    (("2" (skosimp)
                      (("2" (expand "nonempty?")
                        (("2" (expand "empty?")
                          (("2" (expand "member")
                            (("2" (inst - "N!1") nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (skosimp)
                (("2" (inst - "n!1")
                  (("2" (expand "ae_eq?")
                    (("2" (expand "restrict")
                      (("2" (expand "pointwise_ae?")
                        (("2" (expand "ae?")
                          (("2" (expand "fullset")
                            (("2" (expand "ae_in?")
                              (("2" (skosimp)
                                (("2" (typepred "E!1")
                                  (("2" (expand "negligible_set?")
                                    (("2" (skosimp)
                                      (("2"
                                        (inst + "X!1")
                                        (("2"
                                          (skosimp)
                                          (("2"
                                            (inst - "x!1")
                                            (("2"
                                              (expand "subset?")
                                              (("2"
                                                (inst - "x!1")
                                                (("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sequence type-eq-decl nil sequences nil) (set type-eq-decl nil sets nil)
    (fullset const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (metric? const-decl "bool" metric_def metric_space)
    (ball const-decl "set[T]" metric_space_def metric_space)
    (metric_converges_to const-decl "bool" metric_space_def metric_space)
    (metric_induced_topology_is_second_countable name-judgement
     "second_countable" real_topology metric_space)
    (metric_zero? const-decl "bool" metric_def metric_space)
    (metric_symmetric? const-decl "bool" metric_def metric_space)
    (metric_triangle? const-decl "bool" metric_def metric_space)
    (metric_convergence_def formula-decl nil metric_space metric_space)
    (subset? const-decl "bool" sets nil) (union const-decl "set" sets nil)
    (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil)
    (empty? const-decl "bool" sets nil))
   shostak)))

