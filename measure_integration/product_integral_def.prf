(product_integral_def
 (mu_TCC1 0
  (mu_TCC1-1 nil 3458545281
   ("" (typepred "S1")
    (("" (expand "sigma_algebra?")
      (("" (expand "subset_algebra_empty?")
        (("" (flatten) (("" (expand "member") (("" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (subset_algebra_empty? const-decl "bool" subset_algebra_def nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil))
   nil
   (mu assuming
    "generalized_measure_def[product_integral_def.T1, product_integral_def.S1].generalized_measure_def"
    "S_empty: ASSUMPTION generalized_measure_def.S(sets[generalized_measure_def.T].emptyset)")))
 (nu_TCC1 0
  (nu_TCC1-1 nil 3458545281
   ("" (typepred "S2")
    (("" (expand "sigma_algebra?")
      (("" (flatten)
        (("" (expand "subset_algebra_empty?")
          (("" (expand "member") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((subset_algebra_empty? const-decl "bool" subset_algebra_def nil)
    (member const-decl "bool" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil))
   nil
   (nu assuming
    "generalized_measure_def[product_integral_def.T2, product_integral_def.S2].generalized_measure_def"
    "S_empty: ASSUMPTION generalized_measure_def.S(sets[generalized_measure_def.T].emptyset)")))
 (integrable1_TCC1 0
  (integrable1_TCC1-1 nil 3431150732
   ("" (expand "integrable1?")
    (("" (inst + "emptyset[T1]" "lambda x: 0")
      (("1" (skosimp)
        (("1" (hide 1)
          (("1" (rewrite "integrable_zero")
            (("1" (rewrite "integral_zero") nil nil)) nil))
          nil))
        nil)
       ("2" (rewrite "integrable_zero") nil nil))
      nil))
    nil)
   ((nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (integrable_zero formula-decl nil integral nil)
    (integral_zero formula-decl nil integral nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (emptyset const-decl "set" sets nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (set type-eq-decl nil sets nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (integrable? const-decl "bool" integral nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countable_props sets_aux)
    (finite_emptyset name-judgement "finite_set[T]" countable_setofsets
     sets_aux)
    (finite_emptyset name-judgement "finite_set[T]" sigma_countable sigma_set)
    (subset_algebra_emptyset name-judgement "(S)" product_integral_def nil)
    (null_emptyset name-judgement "null_set" product_integral_def nil)
    (integrable1? const-decl "bool" product_integral_def nil))
   nil (integrable1 subtype "(LAMBDA x, y: 0)" "integrable1")))
 (integrable2_TCC1 0
  (integrable2_TCC1-1 nil 3431150732
   ("" (expand "integrable2?")
    (("" (inst + "emptyset[T2]" "lambda y: 0")
      (("1" (skosimp)
        (("1" (hide 1)
          (("1" (rewrite "integrable_zero")
            (("1" (rewrite "integral_zero") nil nil)) nil))
          nil))
        nil)
       ("2" (rewrite "integrable_zero") nil nil))
      nil))
    nil)
   ((mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (integrable_zero formula-decl nil integral nil)
    (integral_zero formula-decl nil integral nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (emptyset const-decl "set" sets nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (set type-eq-decl nil sets nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (integrable? const-decl "bool" integral nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[T]" countable_props sets_aux)
    (finite_emptyset name-judgement "finite_set[T]" countable_setofsets
     sets_aux)
    (finite_emptyset name-judgement "finite_set[T]" sigma_countable sigma_set)
    (subset_algebra_emptyset name-judgement "(S)" product_integral_def nil)
    (null_emptyset name-judgement "null_set" product_integral_def nil)
    (integrable2? const-decl "bool" product_integral_def nil))
   nil (integrable2 subtype "(LAMBDA x, y: 0)" "integrable2")))
 (integrable1_zero 0
  (integrable1_zero-1 nil 3458969271
   ("" (lemma "integrable1_TCC1") (("" (propax) nil nil)) nil)
   ((integrable1_TCC1 subtype-tcc nil product_integral_def nil)) shostak))
 (integrable1_add 0
  (integrable1_add-1 nil 3458969501
   ("" (skosimp)
    (("" (typepred "h1!1")
      (("" (typepred "g1!1")
        (("" (expand "integrable1?")
          (("" (skosimp*)
            (("" (expand "member")
              (("" (inst + "union(N1!1,N1!2)" "f!1+f!2")
                (("" (skosimp)
                  (("" (inst - "x!1")
                    (("" (inst - "x!1")
                      (("" (expand "union")
                        (("" (expand "member")
                          (("" (flatten)
                            (("" (assert)
                              (("" (flatten)
                                (("" (expand "+" 3)
                                  ((""
                                    (lemma "integrable_add"
                                     ("f1" "LAMBDA y: g1!1(x!1, y)" "f2"
                                      "LAMBDA y: h1!1(x!1, y)"))
                                    (("1" (expand "+" -1)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (lemma
                                           "integral_add"
                                           ("f1"
                                            "LAMBDA y: g1!1(x!1, y)"
                                            "f2"
                                            "LAMBDA y: h1!1(x!1, y)"))
                                          (("1"
                                            (expand "+")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil)
                                     ("3" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable1 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable1? const-decl "bool" product_integral_def nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (integrable_add judgement-tcc nil integral nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (integral_add formula-decl nil integral nil)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (union const-decl "set" sets nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil) (set type-eq-decl nil sets nil)
    (null_union application-judgement "null_set[T1, S1, mu]"
     product_integral_def nil)
    (integrable_add application-judgement "integrable" product_integral_def
     nil))
   nil
   (integrable1_add subtype
    "(real_fun_ops[[product_integral_def.T1, product_integral_def.T2]].+)(product_integral_def.g1, product_integral_def.h1)"
    "integrable1")))
 (integrable1_scal 0
  (integrable1_scal-1 nil 3458969296
   ("" (skosimp)
    (("" (typepred "h1!1")
      (("" (expand "integrable1?")
        (("" (skosimp)
          (("" (inst + "N1!1" "c!1*f!1")
            (("" (skosimp)
              (("" (inst - "x!1")
                (("" (assert)
                  (("" (flatten)
                    (("" (hide 1)
                      ((""
                        (lemma "integrable_scal"
                         ("c" "c!1" "f" "LAMBDA y: h1!1(x!1, y)"))
                        (("1"
                          (lemma "integral_scal"
                           ("c" "c!1" "f" "LAMBDA y: h1!1(x!1, y)"))
                          (("1" (expand "*") (("1" (assert) nil nil)) nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable1 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable1? const-decl "bool" product_integral_def nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (integrable_scal judgement-tcc nil integral nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (integral_scal formula-decl nil integral nil)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil) (set type-eq-decl nil sets nil)
    (integrable_scal application-judgement "integrable" product_integral_def
     nil))
   shostak
   (integrable1_scal subtype
    "real_fun_ops[[product_integral_def.T1, product_integral_def.T2]].*(product_integral_def.c, product_integral_def.h1)"
    "integrable1")))
 (integrable1_opp 0
  (integrable1_opp-1 nil 3458969501
   ("" (skosimp)
    (("" (lemma "integrable1_scal" ("h1" "h1!1" "c" "-1"))
      (("" (expand "*")
        (("" (expand "-")
          ((""
            (case-replace
             "(LAMBDA (x: [T1, T2]): -1 * h1!1(x))=(LAMBDA (x: [T1, T2]): -h1!1(x))")
            (("" (apply-extensionality :hide? t) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable1 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable1? const-decl "bool" product_integral_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (integrable1_scal judgement-tcc nil product_integral_def nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (real_times_real_is_real application-judgement "real" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[T -> real]" real_fun_ops reals))
   nil
   (integrable1_opp subtype
    "(real_fun_ops[[product_integral_def.T1, product_integral_def.T2]].-)(product_integral_def.h1)"
    "integrable1")))
 (integrable1_diff 0
  (integrable1_diff-1 nil 3458969501
   ("" (skosimp)
    (("" (lemma "integrable1_opp" ("h1" "h1!1"))
      (("" (lemma "integrable1_add" ("g1" "g1!1" "h1" "-h1!1"))
        ((""
          (case-replace
           "((+[[T1, T2]])(g1!1, -h1!1))=((-[[T1, T2]])(g1!1, h1!1))")
          (("" (apply-extensionality :hide? t)
            (("" (expand "+") (("" (expand "-") (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable1 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable1? const-decl "bool" product_integral_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (integrable1_opp judgement-tcc nil product_integral_def nil)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (integrable1_add application-judgement "integrable1" product_integral_def
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (integrable1_opp application-judgement "integrable1" product_integral_def
     nil)
    (integrable1_add judgement-tcc nil product_integral_def nil)
    (- const-decl "[T -> real]" real_fun_ops reals))
   nil
   (integrable1_diff subtype
    "(real_fun_ops[[product_integral_def.T1, product_integral_def.T2]].-)(product_integral_def.g1, product_integral_def.h1)"
    "integrable1")))
 (integrable2_zero 0
  (integrable2_zero-1 nil 3458970055 ("" (rewrite "integrable2_TCC1") nil nil)
   ((integrable2_TCC1 subtype-tcc nil product_integral_def nil)) shostak))
 (integrable2_add 0
  (integrable2_add-1 nil 3458970054
   ("" (skosimp)
    (("" (typepred "h2!1")
      (("" (typepred "g2!1")
        (("" (expand "integrable2?")
          (("" (skosimp*)
            (("" (inst + "union(N2!1,N2!2)" "g!1+g!2")
              (("" (skosimp)
                (("" (inst - "y!1")
                  (("" (inst - "y!1")
                    (("" (expand "union")
                      (("" (assert)
                        (("" (flatten)
                          (("" (assert)
                            (("" (flatten)
                              (("" (expand "+")
                                ((""
                                  (lemma "integrable_add"
                                   ("f1" "LAMBDA x: g2!1(x, y!1)" "f2"
                                    "LAMBDA x: h2!1(x, y!1)"))
                                  (("1"
                                    (lemma "integral_add"
                                     ("f1" "LAMBDA x: g2!1(x, y!1)" "f2"
                                      "LAMBDA x: h2!1(x, y!1)"))
                                    (("1" (expand "+")
                                      (("1" (assert) nil nil)) nil))
                                    nil)
                                   ("2" (propax) nil nil)
                                   ("3" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable2 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable2? const-decl "bool" product_integral_def nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (integrable_add application-judgement "integrable" product_integral_def
     nil)
    (null_union application-judgement "null_set[T2, S2, nu]"
     product_integral_def nil)
    (set type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (null_set? const-decl "bool" measure_theory nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (union const-decl "set" sets nil)
    (integrable? const-decl "bool" integral nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (integral_add formula-decl nil integral nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (integrable_add judgement-tcc nil integral nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (member const-decl "bool" sets nil))
   nil
   (integrable2_add subtype
    "(real_fun_ops[[product_integral_def.T1, product_integral_def.T2]].+)(product_integral_def.g2, product_integral_def.h2)"
    "integrable2")))
 (integrable2_scal 0
  (integrable2_scal-1 nil 3458970054
   ("" (skosimp)
    (("" (typepred "h2!1")
      (("" (expand "integrable2?")
        (("" (skosimp)
          (("" (inst + "N2!1" "c!1*g!1")
            (("" (skosimp)
              (("" (inst - "y!1")
                (("" (assert)
                  (("" (flatten)
                    ((""
                      (lemma "integrable_scal"
                       ("c" "c!1" "f" "LAMBDA x: h2!1(x, y!1)"))
                      (("1"
                        (lemma "integral_scal"
                         ("c" "c!1" "f" "LAMBDA x: h2!1(x, y!1)"))
                        (("1" (expand "*") (("1" (assert) nil nil)) nil)) nil)
                       ("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable2 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable2? const-decl "bool" product_integral_def nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (integral_scal formula-decl nil integral nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (integrable_scal judgement-tcc nil integral nil)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil) (set type-eq-decl nil sets nil)
    (integrable_scal application-judgement "integrable" product_integral_def
     nil))
   nil
   (integrable2_scal subtype
    "real_fun_ops[[product_integral_def.T1, product_integral_def.T2]].*(product_integral_def.c, product_integral_def.h2)"
    "integrable2")))
 (integrable2_opp 0
  (integrable2_opp-1 nil 3458970054
   ("" (skosimp)
    (("" (lemma "integrable2_scal" ("h2" "h2!1" "c" "-1"))
      (("" (expand "*")
        (("" (expand "-")
          ((""
            (case-replace
             "(LAMBDA (x: [T1, T2]): -1 * h2!1(x))=(LAMBDA (x: [T1, T2]): -h2!1(x))")
            (("" (apply-extensionality :hide? t) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable2 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable2? const-decl "bool" product_integral_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (integrable2_scal judgement-tcc nil product_integral_def nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (real_times_real_is_real application-judgement "real" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[T -> real]" real_fun_ops reals))
   nil
   (integrable2_opp subtype
    "(real_fun_ops[[product_integral_def.T1, product_integral_def.T2]].-)(product_integral_def.h2)"
    "integrable2")))
 (integrable2_diff 0
  (integrable2_diff-1 nil 3458970054
   ("" (skosimp)
    (("" (lemma "integrable2_opp" ("h2" "h2!1"))
      (("" (lemma "integrable2_add" ("g2" "g2!1" "h2" "-h2!1"))
        ((""
          (case-replace
           "((+[[T1, T2]])(g2!1, -h2!1))=((-[[T1, T2]])(g2!1, h2!1))")
          (("" (apply-extensionality :hide? t)
            (("" (expand "+") (("" (expand "-") (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable2 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable2? const-decl "bool" product_integral_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (integrable2_opp judgement-tcc nil product_integral_def nil)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (integrable2_add application-judgement "integrable2" product_integral_def
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (integrable2_opp application-judgement "integrable2" product_integral_def
     nil)
    (integrable2_add judgement-tcc nil product_integral_def nil)
    (- const-decl "[T -> real]" real_fun_ops reals))
   nil
   (integrable2_diff subtype
    "(real_fun_ops[[product_integral_def.T1, product_integral_def.T2]].-)(product_integral_def.g2, product_integral_def.h2)"
    "integrable2")))
 (null_integrable1_TCC1 0
  (null_integrable1_TCC1-1 nil 3458969029
   ("" (skosimp)
    (("" (expand "nonempty?")
      (("" (expand "empty?")
        (("" (typepred "h1!1")
          (("" (expand "integrable1?")
            (("" (skosimp)
              (("" (expand "member") (("" (inst -2 "(N1!1,f!1)") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonempty? const-decl "bool" sets nil)
    (integrable1 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable1? const-decl "bool" product_integral_def nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (set type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (null_set? const-decl "bool" measure_theory nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (integrable? const-decl "bool" integral nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil))
   nil
   (null_integrable1 subtype
    "{(N1, f) | FORALL x: booleans.=>((booleans.NOT)(sets[product_integral_def.T1].member(product_integral_def.x, product_integral_def.N1)), booleans.AND(integral[product_integral_def.T2, product_integral_def.S2, product_integral_def.nu].integrable?(LAMBDA y: product_integral_def.h1(product_integral_def.x, product_integral_def.y)), integral[product_integral_def.T2, product_integral_def.S2, product_integral_def.nu].integral(LAMBDA y: product_integral_def.h1(product_integral_def.x, product_integral_def.y)) = product_integral_def.f(product_integral_def.x)))}"
    "(sets[[null_set[T1, S1, mu], integrable[T1, S1, mu]]].nonempty?)")))
 (null_integrable2_TCC1 0
  (null_integrable2_TCC1-1 nil 3458969029
   ("" (skosimp)
    (("" (typepred "h2!1")
      (("" (expand "integrable2?")
        (("" (skosimp)
          (("" (expand "nonempty?")
            (("" (expand "empty?")
              (("" (inst -2 "(N2!1,g!1)")
                (("" (expand "member") (("" (propax) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable2 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable2? const-decl "bool" product_integral_def nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil) (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil))
   nil
   (null_integrable2 subtype
    "{(N2, g) | FORALL y: booleans.=>((booleans.NOT)(sets[product_integral_def.T2].member(product_integral_def.y, product_integral_def.N2)), booleans.AND(integral[product_integral_def.T1, product_integral_def.S1, product_integral_def.mu].integrable?(LAMBDA x: product_integral_def.h2(product_integral_def.x, product_integral_def.y)), integral[product_integral_def.T1, product_integral_def.S1, product_integral_def.mu].integral(LAMBDA x: product_integral_def.h2(product_integral_def.x, product_integral_def.y)) = product_integral_def.g(product_integral_def.y)))}"
    "(sets[[null_set[T2, S2, nu], integrable[T2, S2, nu]]].nonempty?)")))
 (null_integral1_def 0
  (null_integral1_def-1 nil 3458973205
   ("" (skosimp)
    (("" (expand "null_integrable1")
      ((""
        (case "nonempty?({(N1,f) |
                 FORALL x:
                   NOT member(x, N1) =>
                    integrable?(LAMBDA y: h1!1(x, y)) AND
                     integral(LAMBDA y: h1!1(x, y)) = f(x)})")
        (("1"
          (lemma "choose_member"
           ("a" "{(N1,f) |
                 FORALL x:
                   NOT member(x, N1) =>
                    integrable?(LAMBDA y: h1!1(x, y)) AND
                     integral(LAMBDA y: h1!1(x, y)) = f(x)}"))
          (("1" (expand "nonempty?")
            (("1" (assert)
              (("1" (replace -2 -1 rl)
                (("1" (hide -2 1)
                  (("1" (inst - "x!1") (("1" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide-all-but 1)
          (("2" (typepred "h1!1")
            (("2" (expand "nonempty?")
              (("2" (expand "integrable1?")
                (("2" (skosimp)
                  (("2" (expand "empty?")
                    (("2" (inst -2 "(N1!2,f!2)")
                      (("2" (expand "member") (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null_integrable1 const-decl
     "[null_set[T1, S1, mu], integrable[T1, S1, mu]]" product_integral_def
     nil)
    (integral const-decl "real" integral nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (integrable1 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable1? const-decl "bool" product_integral_def nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty? const-decl "bool" sets nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil) (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (choose_member formula-decl nil sets_lemmas nil)
    (empty? const-decl "bool" sets nil))
   shostak))
 (null_integral2_def 0
  (null_integral2_def-1 nil 3458973437
   ("" (skosimp)
    (("" (expand "null_integrable2")
      ((""
        (case "nonempty?({(N2,g) |
                 FORALL y:
                   NOT member(y, N2) =>
                    integrable?(LAMBDA x: h2!1(x, y)) AND
                     integral(LAMBDA x: h2!1(x, y)) = g(y)})")
        (("1"
          (lemma "choose_member"
           ("a" "{(N2,g) |
                   FORALL y:
                     NOT member(y, N2) =>
                      integrable?(LAMBDA x: h2!1(x, y)) AND
                       integral(LAMBDA x: h2!1(x, y)) = g(y)}"))
          (("1" (expand "nonempty?")
            (("1" (assert)
              (("1" (replace -2 * rl)
                (("1" (inst - "y!1") (("1" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil)
         ("2" (hide-all-but 1)
          (("2" (typepred "h2!1")
            (("2" (expand "integrable2?")
              (("2" (skosimp)
                (("2" (expand "nonempty?")
                  (("2" (expand "empty?")
                    (("2" (inst -2 "(N2!2,g!2)")
                      (("2" (expand "member") (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null_integrable2 const-decl
     "[null_set[T2, S2, nu], integrable[T2, S2, nu]]" product_integral_def
     nil)
    (integral const-decl "real" integral nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (integrable2 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable2? const-decl "bool" product_integral_def nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty? const-decl "bool" sets nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil) (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (choose_member formula-decl nil sets_lemmas nil)
    (empty? const-decl "bool" sets nil))
   shostak))
 (integral1_TCC1 0
  (integral1_TCC1-1 nil 3458972704
   ("" (skosimp)
    (("" (name "DRL" "null_integrable1(h1!1)")
      (("" (replace -1)
        (("" (assert)
          (("" (name "NN" "DRL`1")
            (("" (name "FF" "DRL`2")
              ((""
                (lemma "null_integral1_def" ("N1" "NN" "f" "FF" "h1" "h1!1"))
                (("" (assert)
                  (("" (typepred "FF")
                    ((""
                      (lemma "indefinite_integrable[T1, S1, mu]"
                       ("E" "complement(NN)" "f" "FF"))
                      (("" (expand "complement")
                        (("" (expand "phi")
                          (("" (expand "member")
                            (("" (expand "*")
                              (("" (expand "FF")
                                (("" (expand "NN")
                                  ((""
                                    (case-replace "(LAMBDA (x: T1):
                    IF NOT DRL`1(x) THEN 1 ELSE 0 ENDIF * DRL`2(x))=(LAMBDA x: IF DRL`1(x) THEN 0 ELSE DRL`2(x) ENDIF)")
                                    (("" (apply-extensionality :hide? t)
                                      ((""
                                        (lift-if)
                                        (("" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null_integrable1 const-decl
     "[null_set[T1, S1, mu], integrable[T1, S1, mu]]" product_integral_def
     nil)
    (integrable1 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable1? const-decl "bool" product_integral_def nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil) (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (member const-decl "bool" sets nil)
    (subset_algebra_complement application-judgement "(S)" measure_def nil)
    (indefinite_integrable formula-decl nil integral nil)
    (measurable_set? const-decl "bool" measure_space_def nil)
    (measurable_set nonempty-type-eq-decl nil measure_space_def nil)
    (complement const-decl "set" sets nil)
    (phi const-decl "nat" measure_space nil)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (NN skolem-const-decl "null_set[T1, S1, mu]" product_integral_def nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (FF skolem-const-decl "integrable[T1, S1, mu]" product_integral_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null_integral1_def formula-decl nil product_integral_def nil))
   nil
   (integral1 subtype
    "LAMBDA x: LET (N1, f) = product_integral_def.null_integrable1(product_integral_def.h1) IN IF sets[product_integral_def.T1].member(product_integral_def.x, product_integral_def.N1) THEN 0 ELSE product_integral_def.f(product_integral_def.x) ENDIF"
    "integrable[T1, S1, mu]")))
 (integral2_TCC1 0
  (integral2_TCC1-1 nil 3458972704
   ("" (skosimp)
    (("" (lemma "null_integral2_def" ("h2" "h2!1"))
      (("" (name "DRL" "null_integrable2(h2!1)")
        (("" (replace -1)
          (("" (name "NN" "DRL`1")
            (("" (name "GG" "DRL`2")
              (("" (inst - "NN" "GG" "_")
                (("" (assert)
                  (("" (replace -1)
                    (("" (replace -2)
                      ((""
                        (lemma "indefinite_integrable[T2, S2, nu]"
                         ("E" "complement(NN)" "f" "GG"))
                        (("" (expand "complement")
                          (("" (expand "phi")
                            (("" (expand "member")
                              (("" (expand "*")
                                ((""
                                  (case-replace
                                   "(LAMBDA (x: T2): IF NOT NN(x) THEN 1 ELSE 0 ENDIF * GG(x))=(LAMBDA y: IF NN(y) THEN 0 ELSE GG(y) ENDIF)")
                                  (("" (apply-extensionality :hide? t)
                                    (("" (lift-if) (("" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable2 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable2? const-decl "bool" product_integral_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (null_integral2_def formula-decl nil product_integral_def nil)
    (member const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (phi const-decl "nat" measure_space nil)
    (complement const-decl "set" sets nil)
    (measurable_set nonempty-type-eq-decl nil measure_space_def nil)
    (measurable_set? const-decl "bool" measure_space_def nil)
    (indefinite_integrable formula-decl nil integral nil)
    (subset_algebra_complement application-judgement "(S)" measure_def nil)
    (set type-eq-decl nil sets nil) (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (null_set? const-decl "bool" measure_theory nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (integrable? const-decl "bool" integral nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null_integrable2 const-decl
     "[null_set[T2, S2, nu], integrable[T2, S2, nu]]" product_integral_def
     nil))
   nil
   (integral2 subtype
    "LAMBDA y: LET (N2, g) = product_integral_def.null_integrable2(product_integral_def.h2) IN IF sets[product_integral_def.T2].member(product_integral_def.y, product_integral_def.N2) THEN 0 ELSE product_integral_def.g(product_integral_def.y) ENDIF"
    "integrable[T2, S2, nu]")))
 (integral1_zero 0
  (integral1_zero-1 nil 3458973878
   ("" (apply-extensionality :hide? t)
    (("1" (expand "integral1")
      (("1" (expand "member")
        (("1" (lemma "null_integral1_def" ("h1" "LAMBDA x, y: 0"))
          (("1"
            (inst - "null_integrable1(LAMBDA x, y: 0)`1"
             "null_integrable1(LAMBDA x, y: 0)`2" "x!1")
            (("1" (expand "member")
              (("1" (case-replace "null_integrable1(LAMBDA x, y: 0)`1(x!1)")
                (("1" (assert)
                  (("1" (split)
                    (("1" (flatten)
                      (("1" (rewrite "integral_zero") (("1" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (decompose-equality)
                        (("2" (rewrite "integrable1_zero") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (rewrite "integrable1_zero") nil nil))
            nil)
           ("2" (rewrite "integrable1_zero") nil nil))
          nil))
        nil))
      nil)
     ("2" (rewrite "integrable1_zero") nil nil))
    nil)
   ((T1 formal-type-decl nil product_integral_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (integral1 const-decl "integrable[T1, S1, mu]" product_integral_def nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (integrable1 nonempty-type-eq-decl nil product_integral_def nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (integrable1? const-decl "bool" product_integral_def nil)
    (member const-decl "bool" sets nil)
    (null_integral1_def formula-decl nil product_integral_def nil)
    (set type-eq-decl nil sets nil)
    (null_set? const-decl "bool" measure_theory nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_integrable1 const-decl
     "[null_set[T1, S1, mu], integrable[T1, S1, mu]]" product_integral_def
     nil)
    (integrable1_zero formula-decl nil product_integral_def nil)
    (integral_zero formula-decl nil integral nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil))
   shostak))
 (integral1_add 0
  (integral1_add-2 "" 3789904375
   ("" (skosimp)
    (("" (expand "ae_eq?")
      (("" (expand "pointwise_ae?")
        (("" (expand "ae?")
          (("" (expand "fullset")
            (("" (expand "ae_in?")
              (("" (expand "member")
                (("" (expand "integral1")
                  (("" (expand "member")
                    (("" (name "NN3" "null_integrable1(h1!1)`1")
                      (("" (name "NN2" "null_integrable1(g1!1)`1")
                        (("" (name "NN1" "null_integrable1(g1!1+h1!1)`1")
                          (("" (inst + "union(NN1,union(NN2,NN3))")
                            (("" (skosimp)
                              (("" (expand "union")
                                (("" (expand "member")
                                  (("" (flatten)
                                    (("" (replace -1)
                                      ((""
                                        (replace -2)
                                        ((""
                                          (replace -3)
                                          ((""
                                            (expand "+" 4 2)
                                            ((""
                                              (assert)
                                              ((""
                                                (name
                                                 "FF3"
                                                 "null_integrable1(h1!1)`2")
                                                ((""
                                                  (name
                                                   "FF2"
                                                   "null_integrable1(g1!1)`2")
                                                  ((""
                                                    (name
                                                     "FF1"
                                                     "null_integrable1(g1!1+h1!1)`2")
                                                    ((""
                                                      (replace -1)
                                                      ((""
                                                        (replace -2)
                                                        ((""
                                                          (replace -3)
                                                          ((""
                                                            (lemma
                                                             "null_integral1_def"
                                                             ("h1"
                                                              "h1!1"
                                                              "f"
                                                              "FF3"
                                                              "N1"
                                                              "NN3"
                                                              "x"
                                                              "x!1"))
                                                            ((""
                                                              (assert)
                                                              ((""
                                                                (flatten)
                                                                ((""
                                                                  (lemma
                                                                   "null_integral1_def"
                                                                   ("h1"
                                                                    "g1!1"
                                                                    "f"
                                                                    "FF2"
                                                                    "N1"
                                                                    "NN2"
                                                                    "x"
                                                                    "x!1"))
                                                                  ((""
                                                                    (assert)
                                                                    ((""
                                                                      (flatten)
                                                                      ((""
                                                                        (lemma
                                                                         "null_integral1_def"
                                                                         ("h1"
                                                                          "g1!1+h1!1"
                                                                          "f"
                                                                          "FF1"
                                                                          "N1"
                                                                          "NN1"
                                                                          "x"
                                                                          "x!1"))
                                                                        ((""
                                                                          (assert)
                                                                          ((""
                                                                            (flatten)
                                                                            ((""
                                                                              (replace
                                                                               -2
                                                                               *
                                                                               rl)
                                                                              ((""
                                                                                (replace
                                                                                 -4
                                                                                 *
                                                                                 rl)
                                                                                ((""
                                                                                  (replace
                                                                                   -6
                                                                                   *
                                                                                   rl)
                                                                                  ((""
                                                                                    (lemma
                                                                                     "integral_add[T2,S2,nu]"
                                                                                     ("f1"
                                                                                      "LAMBDA y: g1!1(x!1, y)"
                                                                                      "f2"
                                                                                      "LAMBDA y: h1!1(x!1, y)"))
                                                                                    ((""
                                                                                      (expand
                                                                                       "+"
                                                                                       4)
                                                                                      ((""
                                                                                        (expand
                                                                                         "+"
                                                                                         -1)
                                                                                        ((""
                                                                                          (propax)
                                                                                          nil
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ae_eq? const-decl "bool" measure_theory nil)
    (subset_algebra_fullset name-judgement "(S1)" product_integral_def nil)
    (measurable_fullset name-judgement "measurable_set[T1, S1]"
     product_integral_def nil)
    (ae? const-decl "bool" measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (integral1 const-decl "integrable[T1, S1, mu]" product_integral_def nil)
    (null_integrable1 const-decl
     "[null_set[T1, S1, mu], integrable[T1, S1, mu]]" product_integral_def
     nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (integrable1 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable1? const-decl "bool" product_integral_def nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (integrable1_add application-judgement "integrable1" product_integral_def
     nil)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (integral_add formula-decl nil integral nil)
    (TRUE const-decl "bool" booleans nil)
    (null_integral1_def formula-decl nil product_integral_def nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (union const-decl "set" sets nil)
    (null_union application-judgement "null_set[T1, S1, mu]"
     product_integral_def nil)
    (member const-decl "bool" sets nil) (fullset const-decl "set" sets nil)
    (pointwise_ae? const-decl "bool" measure_theory nil))
   shostak)
  (integral1_add-1 nil 3458971378
   ("" (skosimp)
    (("" (expand "ae_eq?")
      (("" (expand "restrict")
        (("" (expand "pointwise_ae?")
          (("" (expand "ae?")
            (("" (expand "fullset")
              (("" (expand "ae_in?")
                (("" (expand "member")
                  (("" (expand "integral1")
                    (("" (expand "member")
                      (("" (name "NN3" "null_integrable1(h1!1)`1")
                        (("" (name "NN2" "null_integrable1(g1!1)`1")
                          (("" (name "NN1" "null_integrable1(g1!1+h1!1)`1")
                            (("" (inst + "union(NN1,union(NN2,NN3))")
                              (("" (skosimp)
                                (("" (expand "union")
                                  (("" (expand "member")
                                    (("" (flatten)
                                      ((""
                                        (replace -1)
                                        ((""
                                          (replace -2)
                                          ((""
                                            (replace -3)
                                            ((""
                                              (expand "+" 4 2)
                                              ((""
                                                (assert)
                                                ((""
                                                  (name
                                                   "FF3"
                                                   "null_integrable1(h1!1)`2")
                                                  ((""
                                                    (name
                                                     "FF2"
                                                     "null_integrable1(g1!1)`2")
                                                    ((""
                                                      (name
                                                       "FF1"
                                                       "null_integrable1(g1!1+h1!1)`2")
                                                      ((""
                                                        (replace -1)
                                                        ((""
                                                          (replace -2)
                                                          ((""
                                                            (replace -3)
                                                            ((""
                                                              (lemma
                                                               "null_integral1_def"
                                                               ("h1"
                                                                "h1!1"
                                                                "f"
                                                                "FF3"
                                                                "N1"
                                                                "NN3"
                                                                "x"
                                                                "x!1"))
                                                              ((""
                                                                (assert)
                                                                ((""
                                                                  (flatten)
                                                                  ((""
                                                                    (lemma
                                                                     "null_integral1_def"
                                                                     ("h1"
                                                                      "g1!1"
                                                                      "f"
                                                                      "FF2"
                                                                      "N1"
                                                                      "NN2"
                                                                      "x"
                                                                      "x!1"))
                                                                    ((""
                                                                      (assert)
                                                                      ((""
                                                                        (flatten)
                                                                        ((""
                                                                          (lemma
                                                                           "null_integral1_def"
                                                                           ("h1"
                                                                            "g1!1+h1!1"
                                                                            "f"
                                                                            "FF1"
                                                                            "N1"
                                                                            "NN1"
                                                                            "x"
                                                                            "x!1"))
                                                                          ((""
                                                                            (assert)
                                                                            ((""
                                                                              (flatten)
                                                                              ((""
                                                                                (replace
                                                                                 -2
                                                                                 *
                                                                                 rl)
                                                                                ((""
                                                                                  (replace
                                                                                   -4
                                                                                   *
                                                                                   rl)
                                                                                  ((""
                                                                                    (replace
                                                                                     -6
                                                                                     *
                                                                                     rl)
                                                                                    ((""
                                                                                      (lemma
                                                                                       "integral_add[T2,S2,nu]"
                                                                                       ("f1"
                                                                                        "LAMBDA y: g1!1(x!1, y)"
                                                                                        "f2"
                                                                                        "LAMBDA y: h1!1(x!1, y)"))
                                                                                      ((""
                                                                                        (expand
                                                                                         "+"
                                                                                         4)
                                                                                        ((""
                                                                                          (expand
                                                                                           "+"
                                                                                           -1)
                                                                                          ((""
                                                                                            (propax)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ae_eq? const-decl "bool" measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil) (set type-eq-decl nil sets nil)
    (integral_add formula-decl nil integral nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (fullset const-decl "set" sets nil)
    (pointwise_ae? const-decl "bool" measure_theory nil))
   shostak))
 (integral1_scal 0
  (integral1_scal-2 "" 3789904376
   ("" (skosimp)
    (("" (typepred "h1!1")
      (("" (lemma "integrable1_scal" ("c" "c!1" "h1" "h1!1"))
        (("" (expand "integral1")
          (("" (expand "member")
            (("" (name "NN2" "null_integrable1(c!1 * h1!1)`1")
              (("" (name "NN1" "null_integrable1(h1!1)`1")
                (("" (replace -1)
                  (("" (replace -2)
                    (("" (name "FF2" "null_integrable1(c!1 * h1!1)`2")
                      (("" (name "FF1" "null_integrable1(h1!1)`2")
                        (("" (replace -1)
                          (("" (replace -2)
                            (("" (expand "ae_eq?")
                              (("" (expand "pointwise_ae?")
                                (("" (expand "ae?")
                                  (("" (expand "fullset")
                                    (("" (expand "ae_in?")
                                      ((""
                                        (expand "member")
                                        ((""
                                          (inst + "union(NN1,NN2)")
                                          ((""
                                            (skosimp)
                                            ((""
                                              (expand "union")
                                              ((""
                                                (expand "member")
                                                ((""
                                                  (flatten)
                                                  ((""
                                                    (expand "*" 3)
                                                    ((""
                                                      (assert)
                                                      ((""
                                                        (lemma
                                                         "null_integral1_def"
                                                         ("h1"
                                                          "h1!1"
                                                          "N1"
                                                          "NN1"
                                                          "f"
                                                          "FF1"
                                                          "x"
                                                          "x!1"))
                                                        ((""
                                                          (assert)
                                                          ((""
                                                            (flatten)
                                                            ((""
                                                              (lemma
                                                               "null_integral1_def"
                                                               ("h1"
                                                                "c!1*h1!1"
                                                                "N1"
                                                                "NN2"
                                                                "f"
                                                                "FF2"
                                                                "x"
                                                                "x!1"))
                                                              ((""
                                                                (assert)
                                                                ((""
                                                                  (flatten)
                                                                  ((""
                                                                    (replace
                                                                     -2
                                                                     3
                                                                     rl)
                                                                    ((""
                                                                      (replace
                                                                       -4
                                                                       3
                                                                       rl)
                                                                      ((""
                                                                        (expand
                                                                         "*"
                                                                         3)
                                                                        ((""
                                                                          (lemma
                                                                           "integral_scal[T2,S2,nu]"
                                                                           ("c"
                                                                            "c!1"
                                                                            "f"
                                                                            "LAMBDA y: h1!1(x!1, y)"))
                                                                          ((""
                                                                            (expand
                                                                             "*")
                                                                            ((""
                                                                              (propax)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable1 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable1? const-decl "bool" product_integral_def nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (integral1 const-decl "integrable[T1, S1, mu]" product_integral_def nil)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (null_integrable1 const-decl
     "[null_set[T1, S1, mu], integrable[T1, S1, mu]]" product_integral_def
     nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (integrable1_scal application-judgement "integrable1" product_integral_def
     nil)
    (ae_eq? const-decl "bool" measure_theory nil)
    (subset_algebra_fullset name-judgement "(S1)" product_integral_def nil)
    (measurable_fullset name-judgement "measurable_set[T1, S1]"
     product_integral_def nil)
    (ae? const-decl "bool" measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (null_union application-judgement "null_set[T1, S1, mu]"
     product_integral_def nil)
    (union const-decl "set" sets nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (integral_scal formula-decl nil integral nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (TRUE const-decl "bool" booleans nil)
    (null_integral1_def formula-decl nil product_integral_def nil)
    (fullset const-decl "set" sets nil)
    (pointwise_ae? const-decl "bool" measure_theory nil)
    (member const-decl "bool" sets nil)
    (integrable1_scal judgement-tcc nil product_integral_def nil))
   shostak)
  (integral1_scal-1 nil 3458971293
   ("" (skosimp)
    (("" (typepred "h1!1")
      (("" (lemma "integrable1_scal" ("c" "c!1" "h1" "h1!1"))
        (("" (expand "integral1")
          (("" (expand "member")
            (("" (name "NN2" "null_integrable1(c!1 * h1!1)`1")
              (("" (name "NN1" "null_integrable1(h1!1)`1")
                (("" (replace -1)
                  (("" (replace -2)
                    (("" (name "FF2" "null_integrable1(c!1 * h1!1)`2")
                      (("" (name "FF1" "null_integrable1(h1!1)`2")
                        (("" (replace -1)
                          (("" (replace -2)
                            (("" (expand "ae_eq?")
                              (("" (expand "restrict")
                                (("" (expand "pointwise_ae?")
                                  (("" (expand "ae?")
                                    (("" (expand "fullset")
                                      ((""
                                        (expand "ae_in?")
                                        ((""
                                          (expand "member")
                                          ((""
                                            (inst + "union(NN1,NN2)")
                                            ((""
                                              (skosimp)
                                              ((""
                                                (expand "union")
                                                ((""
                                                  (expand "member")
                                                  ((""
                                                    (flatten)
                                                    ((""
                                                      (expand "*" 3)
                                                      ((""
                                                        (assert)
                                                        ((""
                                                          (lemma
                                                           "null_integral1_def"
                                                           ("h1"
                                                            "h1!1"
                                                            "N1"
                                                            "NN1"
                                                            "f"
                                                            "FF1"
                                                            "x"
                                                            "x!1"))
                                                          ((""
                                                            (assert)
                                                            ((""
                                                              (flatten)
                                                              ((""
                                                                (lemma
                                                                 "null_integral1_def"
                                                                 ("h1"
                                                                  "c!1*h1!1"
                                                                  "N1"
                                                                  "NN2"
                                                                  "f"
                                                                  "FF2"
                                                                  "x"
                                                                  "x!1"))
                                                                ((""
                                                                  (assert)
                                                                  ((""
                                                                    (flatten)
                                                                    ((""
                                                                      (replace
                                                                       -2
                                                                       3
                                                                       rl)
                                                                      ((""
                                                                        (replace
                                                                         -4
                                                                         3
                                                                         rl)
                                                                        ((""
                                                                          (expand
                                                                           "*"
                                                                           3)
                                                                          ((""
                                                                            (lemma
                                                                             "integral_scal[T2,S2,nu]"
                                                                             ("c"
                                                                              "c!1"
                                                                              "f"
                                                                              "LAMBDA y: h1!1(x!1, y)"))
                                                                            ((""
                                                                              (expand
                                                                               "*")
                                                                              ((""
                                                                                (propax)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_set? const-decl "bool" measure_theory nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil) (set type-eq-decl nil sets nil)
    (ae_eq? const-decl "bool" measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (union const-decl "set" sets nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (integral_scal formula-decl nil integral nil)
    (fullset const-decl "set" sets nil)
    (pointwise_ae? const-decl "bool" measure_theory nil)
    (member const-decl "bool" sets nil))
   shostak))
 (integral1_opp 0
  (integral1_opp-1 nil 3458975022
   ("" (skosimp)
    (("" (lemma "integral1_scal" ("c" "-1" "h1" "h1!1"))
      (("" (case-replace "-1 * h1!1=-h1!1")
        (("1" (assert)
          (("1" (expand "-") (("1" (expand "*") (("1" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (hide-all-but 1)
          (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable1 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable1? const-decl "bool" product_integral_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (integral1_scal formula-decl nil product_integral_def nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (integrable1_opp application-judgement "integrable1" product_integral_def
     nil)
    (integrable1_scal application-judgement "integrable1" product_integral_def
     nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (integrable_scal application-judgement "integrable" product_integral_def
     nil)
    (integrable_opp application-judgement "integrable" product_integral_def
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (integral1_diff 0
  (integral1_diff-2 "" 3789904381
   ("" (skosimp)
    (("" (lemma "integral1_opp" ("h1" "h1!1"))
      (("" (lemma "integral1_add" ("g1" "g1!1" "h1" "-h1!1"))
        (("" (lemma "ae_eq_equivalence[T1,S1,mu]")
          (("" (expand "equivalence?")
            (("" (expand "transitive?")
              (("" (flatten)
                (("" (case-replace "g1!1 + -h1!1=g1!1 - h1!1")
                  (("1" (hide -1)
                    (("1" (name-replace "LHS" "integral1(g1!1 - h1!1)")
                      (("1"
                        (inst - "LHS" "integral1(g1!1) + integral1(-h1!1)"
                         "integral1(g1!1) - integral1(h1!1)")
                        (("1" (assert)
                          (("1" (hide-all-but (1 -4))
                            (("1" (expand "ae_eq?")
                              (("1" (expand "pointwise_ae?")
                                (("1" (expand "ae?")
                                  (("1" (expand "fullset")
                                    (("1" (expand "ae_in?")
                                      (("1"
                                        (skosimp)
                                        (("1"
                                          (inst + "E!1")
                                          (("1"
                                            (skosimp)
                                            (("1"
                                              (inst - "x!1")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand "+")
                                                  (("1"
                                                    (expand "-")
                                                    (("1" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but 1)
                    (("2" (apply-extensionality :hide? t)
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable1 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable1? const-decl "bool" product_integral_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (integral1_opp formula-decl nil product_integral_def nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (ae_eq_equivalence formula-decl nil measure_theory nil)
    (transitive? const-decl "bool" relations nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (pointwise_ae? const-decl "bool" measure_theory nil)
    (fullset const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (TRUE const-decl "bool" booleans nil) (set type-eq-decl nil sets nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (ae? const-decl "bool" measure_theory nil)
    (measurable_fullset name-judgement "measurable_set[T1, S1]"
     product_integral_def nil)
    (subset_algebra_fullset name-judgement "(S1)" product_integral_def nil)
    (ae_eq? const-decl "bool" measure_theory nil)
    (integrable_add application-judgement "integrable" product_integral_def
     nil)
    (integrable_opp application-judgement "integrable" product_integral_def
     nil)
    (integrable_diff application-judgement "integrable" product_integral_def
     nil)
    (integrable? const-decl "bool" integral nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integral1 const-decl "integrable[T1, S1, mu]" product_integral_def nil)
    (integrable1_add application-judgement "integrable1" product_integral_def
     nil)
    (integrable1_diff application-judgement "integrable1" product_integral_def
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (equivalence? const-decl "bool" relations nil)
    (integrable1_opp application-judgement "integrable1" product_integral_def
     nil)
    (integral1_add formula-decl nil product_integral_def nil)
    (- const-decl "[T -> real]" real_fun_ops reals))
   shostak)
  (integral1_diff-1 nil 3458975116
   ("" (skosimp)
    (("" (lemma "integral1_opp" ("h1" "h1!1"))
      (("" (lemma "integral1_add" ("g1" "g1!1" "h1" "-h1!1"))
        (("" (lemma "ae_eq_equivalence[T1,S1,mu]")
          (("" (expand "equivalence?")
            (("" (expand "transitive?")
              (("" (flatten)
                (("" (case-replace "g1!1 + -h1!1=g1!1 - h1!1")
                  (("1" (hide -1)
                    (("1" (name-replace "LHS" "integral1(g1!1 - h1!1)")
                      (("1"
                        (inst - "LHS" "integral1(g1!1) + integral1(-h1!1)"
                         "integral1(g1!1) - integral1(h1!1)")
                        (("1" (assert)
                          (("1" (hide-all-but (1 -4))
                            (("1" (expand "ae_eq?")
                              (("1" (expand "restrict")
                                (("1" (expand "pointwise_ae?")
                                  (("1" (expand "ae?")
                                    (("1" (expand "fullset")
                                      (("1"
                                        (expand "ae_in?")
                                        (("1"
                                          (skosimp)
                                          (("1"
                                            (inst + "E!1")
                                            (("1"
                                              (skosimp)
                                              (("1"
                                                (inst - "x!1")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (expand "+")
                                                    (("1"
                                                      (expand "-")
                                                      (("1" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but 1)
                    (("2" (apply-extensionality :hide? t)
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (ae_eq_equivalence formula-decl nil measure_theory nil)
    (transitive? const-decl "bool" relations nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (ae_eq? const-decl "bool" measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil)
    (fullset const-decl "set" sets nil)
    (pointwise_ae? const-decl "bool" measure_theory nil)
    (equivalence? const-decl "bool" relations nil))
   shostak))
 (integral2_zero 0
  (integral2_zero-1 nil 3458975861
   ("" (lemma "integrable2_zero")
    (("" (apply-extensionality :hide? t)
      (("" (expand "integral2")
        (("" (expand "member")
          (("" (lift-if)
            (("" (prop)
              ((""
                (lemma "null_integral2_def"
                 ("N2" "null_integrable2(LAMBDA x, y: 0)`1" "g"
                  "null_integrable2(LAMBDA x, y: 0)`2" "h2" "LAMBDA x, y: 0"
                  "y" "x!1"))
                (("" (assert)
                  (("" (split)
                    (("1" (flatten)
                      (("1" (rewrite "integral_zero") (("1" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (decompose-equality) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T2 formal-type-decl nil product_integral_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (integral2 const-decl "integrable[T2, S2, nu]" product_integral_def nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (integrable2 nonempty-type-eq-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (integrable2? const-decl "bool" product_integral_def nil)
    (member const-decl "bool" sets nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (integral_zero formula-decl nil integral nil)
    (null_integral2_def formula-decl nil product_integral_def nil)
    (set type-eq-decl nil sets nil)
    (null_set? const-decl "bool" measure_theory nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (null_integrable2 const-decl
     "[null_set[T2, S2, nu], integrable[T2, S2, nu]]" product_integral_def
     nil)
    (integrable2_zero formula-decl nil product_integral_def nil))
   shostak))
 (integral2_add 0
  (integral2_add-2 "" 3789904382
   ("" (skosimp)
    (("" (expand "ae_eq?")
      (("" (expand "pointwise_ae?")
        (("" (expand "ae?")
          (("" (expand "fullset")
            (("" (expand "ae_in?")
              (("" (expand "member")
                (("" (expand "+" 1 2)
                  (("" (expand "integral2")
                    (("" (expand "member")
                      (("" (name "NN3" "null_integrable2(h2!1)`1")
                        (("" (name "NN2" "null_integrable2(g2!1)`1")
                          (("" (name "NN1" "null_integrable2(g2!1+h2!1)`1")
                            (("" (replace -1)
                              (("" (replace -2)
                                (("" (replace -3)
                                  (("" (name "GG3" "null_integrable2(h2!1)`2")
                                    ((""
                                      (name "GG2" "null_integrable2(g2!1)`2")
                                      ((""
                                        (name
                                         "GG1"
                                         "null_integrable2(g2!1+h2!1)`2")
                                        ((""
                                          (replace -1)
                                          ((""
                                            (replace -2)
                                            ((""
                                              (replace -3)
                                              ((""
                                                (inst
                                                 +
                                                 "union(NN1,union(NN2,NN3))")
                                                ((""
                                                  (skosimp)
                                                  ((""
                                                    (expand "union")
                                                    ((""
                                                      (expand "member")
                                                      ((""
                                                        (flatten)
                                                        ((""
                                                          (assert)
                                                          ((""
                                                            (lemma
                                                             "null_integral2_def"
                                                             ("h2"
                                                              "h2!1"
                                                              "N2"
                                                              "NN3"
                                                              "g"
                                                              "GG3"
                                                              "y"
                                                              "x!1"))
                                                            ((""
                                                              (lemma
                                                               "null_integral2_def"
                                                               ("h2"
                                                                "g2!1"
                                                                "N2"
                                                                "NN2"
                                                                "g"
                                                                "GG2"
                                                                "y"
                                                                "x!1"))
                                                              ((""
                                                                (lemma
                                                                 "null_integral2_def"
                                                                 ("h2"
                                                                  "g2!1+h2!1"
                                                                  "N2"
                                                                  "NN1"
                                                                  "g"
                                                                  "GG1"
                                                                  "y"
                                                                  "x!1"))
                                                                ((""
                                                                  (assert)
                                                                  ((""
                                                                    (flatten)
                                                                    ((""
                                                                      (replace
                                                                       -2
                                                                       4
                                                                       rl)
                                                                      ((""
                                                                        (replace
                                                                         -4
                                                                         4
                                                                         rl)
                                                                        ((""
                                                                          (replace
                                                                           -6
                                                                           4
                                                                           rl)
                                                                          ((""
                                                                            (lemma
                                                                             "integral_add[T1,S1,mu]"
                                                                             ("f1"
                                                                              "LAMBDA x: g2!1(x, x!1)"
                                                                              "f2"
                                                                              "LAMBDA x: h2!1(x, x!1)"))
                                                                            (("1"
                                                                              (expand
                                                                               "+")
                                                                              (("1"
                                                                                (propax)
                                                                                nil
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (propax)
                                                                              nil
                                                                              nil)
                                                                             ("3"
                                                                              (propax)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ae_eq? const-decl "bool" measure_theory nil)
    (subset_algebra_fullset name-judgement "(S2)" product_integral_def nil)
    (measurable_fullset name-judgement "measurable_set[T2, S2]"
     product_integral_def nil)
    (ae? const-decl "bool" measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (integral_add formula-decl nil integral nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (TRUE const-decl "bool" booleans nil)
    (null_integral2_def formula-decl nil product_integral_def nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (union const-decl "set" sets nil)
    (null_union application-judgement "null_set[T2, S2, nu]"
     product_integral_def nil)
    (integrable2_add application-judgement "integrable2" product_integral_def
     nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (integrable2? const-decl "bool" product_integral_def nil)
    (integrable2 nonempty-type-eq-decl nil product_integral_def nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (null_set? const-decl "bool" measure_theory nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (integrable? const-decl "bool" integral nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (null_integrable2 const-decl
     "[null_set[T2, S2, nu], integrable[T2, S2, nu]]" product_integral_def
     nil)
    (integral2 const-decl "integrable[T2, S2, nu]" product_integral_def nil)
    (member const-decl "bool" sets nil) (fullset const-decl "set" sets nil)
    (pointwise_ae? const-decl "bool" measure_theory nil))
   shostak)
  (integral2_add-1 nil 3458976028
   ("" (skosimp)
    (("" (expand "ae_eq?")
      (("" (expand "restrict")
        (("" (expand "pointwise_ae?")
          (("" (expand "ae?")
            (("" (expand "fullset")
              (("" (expand "ae_in?")
                (("" (expand "member")
                  (("" (expand "+" 1 2)
                    (("" (expand "integral2")
                      (("" (expand "member")
                        (("" (name "NN3" "null_integrable2(h2!1)`1")
                          (("" (name "NN2" "null_integrable2(g2!1)`1")
                            (("" (name "NN1" "null_integrable2(g2!1+h2!1)`1")
                              (("" (replace -1)
                                (("" (replace -2)
                                  (("" (replace -3)
                                    ((""
                                      (name "GG3" "null_integrable2(h2!1)`2")
                                      ((""
                                        (name
                                         "GG2"
                                         "null_integrable2(g2!1)`2")
                                        ((""
                                          (name
                                           "GG1"
                                           "null_integrable2(g2!1+h2!1)`2")
                                          ((""
                                            (replace -1)
                                            ((""
                                              (replace -2)
                                              ((""
                                                (replace -3)
                                                ((""
                                                  (inst
                                                   +
                                                   "union(NN1,union(NN2,NN3))")
                                                  ((""
                                                    (skosimp)
                                                    ((""
                                                      (expand "union")
                                                      ((""
                                                        (expand "member")
                                                        ((""
                                                          (flatten)
                                                          ((""
                                                            (assert)
                                                            ((""
                                                              (lemma
                                                               "null_integral2_def"
                                                               ("h2"
                                                                "h2!1"
                                                                "N2"
                                                                "NN3"
                                                                "g"
                                                                "GG3"
                                                                "y"
                                                                "x!1"))
                                                              ((""
                                                                (lemma
                                                                 "null_integral2_def"
                                                                 ("h2"
                                                                  "g2!1"
                                                                  "N2"
                                                                  "NN2"
                                                                  "g"
                                                                  "GG2"
                                                                  "y"
                                                                  "x!1"))
                                                                ((""
                                                                  (lemma
                                                                   "null_integral2_def"
                                                                   ("h2"
                                                                    "g2!1+h2!1"
                                                                    "N2"
                                                                    "NN1"
                                                                    "g"
                                                                    "GG1"
                                                                    "y"
                                                                    "x!1"))
                                                                  ((""
                                                                    (assert)
                                                                    ((""
                                                                      (flatten)
                                                                      ((""
                                                                        (replace
                                                                         -2
                                                                         4
                                                                         rl)
                                                                        ((""
                                                                          (replace
                                                                           -4
                                                                           4
                                                                           rl)
                                                                          ((""
                                                                            (replace
                                                                             -6
                                                                             4
                                                                             rl)
                                                                            ((""
                                                                              (lemma
                                                                               "integral_add[T1,S1,mu]"
                                                                               ("f1"
                                                                                "LAMBDA x: g2!1(x, x!1)"
                                                                                "f2"
                                                                                "LAMBDA x: h2!1(x, x!1)"))
                                                                              (("1"
                                                                                (expand
                                                                                 "+")
                                                                                (("1"
                                                                                  (propax)
                                                                                  nil
                                                                                  nil))
                                                                                nil)
                                                                               ("2"
                                                                                (propax)
                                                                                nil
                                                                                nil)
                                                                               ("3"
                                                                                (propax)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ae_eq? const-decl "bool" measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (integral_add formula-decl nil integral nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (union const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (null_set? const-decl "bool" measure_theory nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (integrable? const-decl "bool" integral nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (member const-decl "bool" sets nil) (fullset const-decl "set" sets nil)
    (pointwise_ae? const-decl "bool" measure_theory nil))
   shostak))
 (integral2_scal 0
  (integral2_scal-2 "" 3789904383
   ("" (skosimp)
    (("" (typepred "h2!1")
      (("" (lemma "integrable2_scal" ("c" "c!1" "h2" "h2!1"))
        (("" (expand "integral2")
          (("" (expand "member")
            (("" (expand "ae_eq?")
              (("" (expand "pointwise_ae?")
                (("" (expand "ae?")
                  (("" (expand "fullset")
                    (("" (expand "ae_in?")
                      (("" (expand "member")
                        (("" (expand "*" 1 3)
                          (("" (name "NN2" "null_integrable2(h2!1)`1")
                            (("" (name "NN1" "null_integrable2(c!1*h2!1)`1")
                              (("" (name "GG2" "null_integrable2(h2!1)`2")
                                ((""
                                  (name "GG1" "null_integrable2(c!1*h2!1)`2")
                                  (("" (replace -1)
                                    (("" (replace -2)
                                      ((""
                                        (replace -3)
                                        ((""
                                          (replace -4)
                                          ((""
                                            (inst + "union(NN1,NN2)")
                                            ((""
                                              (skosimp)
                                              ((""
                                                (expand "union")
                                                ((""
                                                  (expand "member")
                                                  ((""
                                                    (flatten)
                                                    ((""
                                                      (assert)
                                                      ((""
                                                        (lemma
                                                         "null_integral2_def"
                                                         ("h2"
                                                          "h2!1"
                                                          "g"
                                                          "GG2"
                                                          "N2"
                                                          "NN2"
                                                          "y"
                                                          "x!1"))
                                                        ((""
                                                          (lemma
                                                           "null_integral2_def"
                                                           ("h2"
                                                            "c!1*h2!1"
                                                            "g"
                                                            "GG1"
                                                            "N2"
                                                            "NN1"
                                                            "y"
                                                            "x!1"))
                                                          ((""
                                                            (assert)
                                                            ((""
                                                              (flatten)
                                                              ((""
                                                                (replace
                                                                 -2
                                                                 3
                                                                 rl)
                                                                ((""
                                                                  (replace
                                                                   -4
                                                                   3
                                                                   rl)
                                                                  ((""
                                                                    (lemma
                                                                     "integral_scal[T1,S1,mu]"
                                                                     ("c"
                                                                      "c!1"
                                                                      "f"
                                                                      "LAMBDA x: h2!1(x, x!1)"))
                                                                    (("1"
                                                                      (expand
                                                                       "*")
                                                                      (("1"
                                                                        (propax)
                                                                        nil
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (propax)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable2 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable2? const-decl "bool" product_integral_def nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (integral2 const-decl "integrable[T2, S2, nu]" product_integral_def nil)
    (ae_eq? const-decl "bool" measure_theory nil)
    (subset_algebra_fullset name-judgement "(S2)" product_integral_def nil)
    (measurable_fullset name-judgement "measurable_set[T2, S2]"
     product_integral_def nil)
    (ae? const-decl "bool" measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (integrable2_scal application-judgement "integrable2" product_integral_def
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (integral_scal formula-decl nil integral nil)
    (S1 formal-const-decl "sigma_algebra[T1]" product_integral_def nil)
    (mu formal-const-decl "measure_type[T1, S1]" product_integral_def nil)
    (TRUE const-decl "bool" booleans nil)
    (null_integral2_def formula-decl nil product_integral_def nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (union const-decl "set" sets nil)
    (null_union application-judgement "null_set[T2, S2, nu]"
     product_integral_def nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (null_set? const-decl "bool" measure_theory nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (integrable? const-decl "bool" integral nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (null_integrable2 const-decl
     "[null_set[T2, S2, nu], integrable[T2, S2, nu]]" product_integral_def
     nil)
    (fullset const-decl "set" sets nil)
    (pointwise_ae? const-decl "bool" measure_theory nil)
    (member const-decl "bool" sets nil)
    (integrable2_scal judgement-tcc nil product_integral_def nil))
   shostak)
  (integral2_scal-1 nil 3458977056
   ("" (skosimp)
    (("" (typepred "h2!1")
      (("" (lemma "integrable2_scal" ("c" "c!1" "h2" "h2!1"))
        (("" (expand "integral2")
          (("" (expand "member")
            (("" (expand "ae_eq?")
              (("" (expand "restrict")
                (("" (expand "pointwise_ae?")
                  (("" (expand "ae?")
                    (("" (expand "fullset")
                      (("" (expand "ae_in?")
                        (("" (expand "member")
                          (("" (expand "*" 1 3)
                            (("" (name "NN2" "null_integrable2(h2!1)`1")
                              (("" (name "NN1" "null_integrable2(c!1*h2!1)`1")
                                (("" (name "GG2" "null_integrable2(h2!1)`2")
                                  ((""
                                    (name "GG1"
                                          "null_integrable2(c!1*h2!1)`2")
                                    (("" (replace -1)
                                      ((""
                                        (replace -2)
                                        ((""
                                          (replace -3)
                                          ((""
                                            (replace -4)
                                            ((""
                                              (inst + "union(NN1,NN2)")
                                              ((""
                                                (skosimp)
                                                ((""
                                                  (expand "union")
                                                  ((""
                                                    (expand "member")
                                                    ((""
                                                      (flatten)
                                                      ((""
                                                        (assert)
                                                        ((""
                                                          (lemma
                                                           "null_integral2_def"
                                                           ("h2"
                                                            "h2!1"
                                                            "g"
                                                            "GG2"
                                                            "N2"
                                                            "NN2"
                                                            "y"
                                                            "x!1"))
                                                          ((""
                                                            (lemma
                                                             "null_integral2_def"
                                                             ("h2"
                                                              "c!1*h2!1"
                                                              "g"
                                                              "GG1"
                                                              "N2"
                                                              "NN1"
                                                              "y"
                                                              "x!1"))
                                                            ((""
                                                              (assert)
                                                              ((""
                                                                (flatten)
                                                                ((""
                                                                  (replace
                                                                   -2
                                                                   3
                                                                   rl)
                                                                  ((""
                                                                    (replace
                                                                     -4
                                                                     3
                                                                     rl)
                                                                    ((""
                                                                      (lemma
                                                                       "integral_scal[T1,S1,mu]"
                                                                       ("c"
                                                                        "c!1"
                                                                        "f"
                                                                        "LAMBDA x: h2!1(x, x!1)"))
                                                                      (("1"
                                                                        (expand
                                                                         "*")
                                                                        (("1"
                                                                          (propax)
                                                                          nil
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (propax)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ae_eq? const-decl "bool" measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (integral_scal formula-decl nil integral nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (union const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (null_set? const-decl "bool" measure_theory nil)
    (null_set nonempty-type-eq-decl nil measure_theory nil)
    (integrable? const-decl "bool" integral nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (fullset const-decl "set" sets nil)
    (pointwise_ae? const-decl "bool" measure_theory nil)
    (member const-decl "bool" sets nil))
   shostak))
 (integral2_opp 0
  (integral2_opp-1 nil 3458976664
   ("" (skosimp)
    (("" (lemma "integral2_scal" ("h2" "h2!1" "c" "-1"))
      (("" (case-replace "-1 * h2!1=-h2!1")
        (("1" (expand "*") (("1" (expand "-") (("1" (assert) nil nil)) nil))
          nil)
         ("2" (apply-extensionality :hide? t)
          (("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((integrable2 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable2? const-decl "bool" product_integral_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (integral2_scal formula-decl nil product_integral_def nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (integrable2_opp application-judgement "integrable2" product_integral_def
     nil)
    (integrable2_scal application-judgement "integrable2" product_integral_def
     nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (integrable_opp application-judgement "integrable" product_integral_def
     nil)
    (integrable_scal application-judgement "integrable" product_integral_def
     nil))
   shostak))
 (integral2_diff 0
  (integral2_diff-2 "" 3789904385
   ("" (skosimp)
    (("" (lemma "integral2_opp" ("h2" "h2!1"))
      (("" (lemma "integral2_add" ("g2" "g2!1" "h2" "-h2!1"))
        (("" (case-replace "g2!1 + -h2!1=g2!1 - h2!1")
          (("1" (hide -1)
            (("1" (lemma "ae_eq_equivalence[T2,S2,nu]")
              (("1" (expand "equivalence?")
                (("1" (flatten)
                  (("1" (expand "transitive?")
                    (("1"
                      (inst - "integral2(g2!1 - h2!1)"
                       "integral2(g2!1) + integral2(-h2!1)"
                       "integral2(g2!1) - integral2(h2!1)")
                      (("1" (assert)
                        (("1" (hide-all-but (-4 1))
                          (("1" (expand "ae_eq?")
                            (("1" (expand "pointwise_ae?")
                              (("1" (expand "ae?")
                                (("1" (expand "fullset")
                                  (("1" (expand "ae_in?")
                                    (("1" (skosimp)
                                      (("1"
                                        (inst + "E!1")
                                        (("1"
                                          (skosimp)
                                          (("1"
                                            (inst - "x!1")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (expand "-")
                                                (("1"
                                                  (expand "+")
                                                  (("1" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide-all-but 1)
            (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable2 nonempty-type-eq-decl nil product_integral_def nil)
    (integrable2? const-decl "bool" product_integral_def nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (T2 formal-type-decl nil product_integral_def nil)
    (T1 formal-type-decl nil product_integral_def nil)
    (integral2_opp formula-decl nil product_integral_def nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (equivalence? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (integrable_diff application-judgement "integrable" product_integral_def
     nil)
    (integrable_opp application-judgement "integrable" product_integral_def
     nil)
    (integrable_add application-judgement "integrable" product_integral_def
     nil)
    (ae_eq? const-decl "bool" measure_theory nil)
    (subset_algebra_fullset name-judgement "(S2)" product_integral_def nil)
    (measurable_fullset name-judgement "measurable_set[T2, S2]"
     product_integral_def nil)
    (ae? const-decl "bool" measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (set type-eq-decl nil sets nil) (TRUE const-decl "bool" booleans nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (member const-decl "bool" sets nil) (fullset const-decl "set" sets nil)
    (pointwise_ae? const-decl "bool" measure_theory nil)
    (integrable? const-decl "bool" integral nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integral2 const-decl "integrable[T2, S2, nu]" product_integral_def nil)
    (ae_eq_equivalence formula-decl nil measure_theory nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S2 formal-const-decl "sigma_algebra[T2]" product_integral_def nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (nu formal-const-decl "measure_type[T2, S2]" product_integral_def nil)
    (integrable2_add application-judgement "integrable2" product_integral_def
     nil)
    (integrable2_diff application-judgement "integrable2" product_integral_def
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (integrable2_opp application-judgement "integrable2" product_integral_def
     nil)
    (integral2_add formula-decl nil product_integral_def nil)
    (- const-decl "[T -> real]" real_fun_ops reals))
   shostak)
  (integral2_diff-1 nil 3458976830
   ("" (skosimp)
    (("" (lemma "integral2_opp" ("h2" "h2!1"))
      (("" (lemma "integral2_add" ("g2" "g2!1" "h2" "-h2!1"))
        (("" (case-replace "g2!1 + -h2!1=g2!1 - h2!1")
          (("1" (hide -1)
            (("1" (lemma "ae_eq_equivalence[T2,S2,nu]")
              (("1" (expand "equivalence?")
                (("1" (flatten)
                  (("1" (expand "transitive?")
                    (("1"
                      (inst - "integral2(g2!1 - h2!1)"
                       "integral2(g2!1) + integral2(-h2!1)"
                       "integral2(g2!1) - integral2(h2!1)")
                      (("1" (assert)
                        (("1" (hide-all-but (-4 1))
                          (("1" (expand "ae_eq?")
                            (("1" (expand "restrict")
                              (("1" (expand "pointwise_ae?")
                                (("1" (expand "ae?")
                                  (("1" (expand "fullset")
                                    (("1" (expand "ae_in?")
                                      (("1"
                                        (skosimp)
                                        (("1"
                                          (inst + "E!1")
                                          (("1"
                                            (skosimp)
                                            (("1"
                                              (inst - "x!1")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand "-")
                                                  (("1"
                                                    (expand "+")
                                                    (("1" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide-all-but 1)
            (("2" (apply-extensionality :hide? t) (("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (ae_eq_equivalence formula-decl nil measure_theory nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (pointwise_ae? const-decl "bool" measure_theory nil)
    (fullset const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (negligible_set? const-decl "bool" measure_theory nil)
    (negligible nonempty-type-eq-decl nil measure_theory nil)
    (ae_in? const-decl "bool" measure_theory nil)
    (ae_eq? const-decl "bool" measure_theory nil)
    (transitive? const-decl "bool" relations nil)
    (equivalence? const-decl "bool" relations nil))
   shostak)))

