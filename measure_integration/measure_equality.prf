(measure_equality
 (measure_eq_isf? 0
  (measure_eq_isf?-1 nil 3459229994
   (""
    (case "FORALL (f: [T -> real], mu, nu: measure_type[T, S]):
        (FORALL E: x_eq(mu(E), nu(E))) & isf?[T, S, mu](f) => isf?[T, S, nu](f)")
    (("1" (skosimp)
      (("1" (inst-cp - "f!1" "mu!1" "nu!1")
        (("1" (inst - "f!1" "nu!1" "mu!1")
          (("1" (replace -3)
            (("1" (split 1)
              (("1" (propax) nil nil)
               ("2" (flatten)
                (("2" (assert)
                  (("2" (hide-all-but (-3 2))
                    (("2" (skosimp)
                      (("2" (inst - "E!1")
                        (("2" (expand "x_eq")
                          (("2" (flatten)
                            (("2" (assert)
                              (("2" (flatten) (("2" (assert) nil nil)) nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (skolem + ("_" "mu!1" "nu!1"))
        (("2" (case-replace "(FORALL E: x_eq(mu!1(E), nu!1(E)))")
          (("1" (case "forall (f:isf[T, S, mu!1]): isf?[T, S, nu!1](f)")
            (("1" (skosimp) (("1" (inst - "f!1") nil nil)) nil)
             ("2" (hide 2)
              (("2" (skosimp)
                (("2" (typepred "f!1")
                  (("2"
                    (lemma "isf_induction[T, S, mu!1]"
                     ("P" "isf?[T, S, nu!1]"))
                    (("2" (expand "restrict")
                      (("2" (inst - "f!1")
                        (("2" (assert)
                          (("2" (hide 2)
                            (("2" (rewrite "isf_zero[T,S,nu!1]")
                              (("2" (skosimp)
                                (("2" (typepred "E!1")
                                  (("2" (inst - "E!1")
                                    (("1" (rewrite "isf_add[T,S,nu!1]" 1)
                                      (("1"
                                        (hide 2)
                                        (("1"
                                          (rewrite "isf_scal[T,S,nu!1]" 1)
                                          (("1"
                                            (hide 2)
                                            (("1"
                                              (rewrite "isf_phi[T,S,nu!1]" 1)
                                              (("1"
                                                (hide 2)
                                                (("1"
                                                  (expand "mu_fin?")
                                                  (("1"
                                                    (expand "x_eq")
                                                    (("1"
                                                      (flatten)
                                                      (("1" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (expand "measurable_set?")
                                      (("2" (propax) nil nil)) nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert)
            (("2" (replace 1 2) (("2" (hide 1) (("2" (skosimp) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((isf? const-decl "bool" isf nil)
    (x_eq const-decl "bool" extended_nnreal extended_nnreal)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (S formal-const-decl "sigma_algebra" measure_equality nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (T formal-type-decl nil measure_equality nil)
    (isf nonempty-type-eq-decl nil isf nil)
    (mu!1 skolem-const-decl "measure_type[T, S]" measure_equality nil)
    (f!1 skolem-const-decl "[T -> real]" measure_equality nil)
    (isf_induction formula-decl nil isf nil)
    (pred type-eq-decl nil defined_types nil)
    (restrict const-decl "R" restrict nil)
    (isf_phi application-judgement "isf" integral nil)
    (phi const-decl "nat" measure_space nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (isf_add judgement-tcc nil isf nil) (isf_scal judgement-tcc nil isf nil)
    (isf_phi judgement-tcc nil isf nil)
    (E!1 skolem-const-decl "(mu_fin?)" measure_equality nil)
    (mu_fin? const-decl "bool" measure_props nil)
    (measurable_set nonempty-type-eq-decl nil measure_space_def nil)
    (measurable_set? const-decl "bool" measure_space_def nil)
    (set type-eq-decl nil sets nil) (isf_zero formula-decl nil isf nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak))
 (measure_eq_isf_TCC1 0
  (measure_eq_isf_TCC1-1 nil 3459230996
   ("" (skosimp)
    (("" (assert)
      (("" (lemma "measure_eq_isf?" ("mu" "mu!1" "nu" "nu!1" "f" "f!1"))
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((measure_eq_isf? formula-decl nil measure_equality nil)
    (T formal-type-decl nil measure_equality nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S formal-const-decl "sigma_algebra" measure_equality nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil))
   nil (measure_eq_isf subtype "measure_equality.f" "isf[T, S, mu]")))
 (measure_eq_isf_TCC2 0
  (measure_eq_isf_TCC2-1 nil 3459230996
   ("" (skosimp)
    (("" (assert)
      (("" (lemma "measure_eq_isf?" ("mu" "mu!1" "nu" "nu!1" "f" "f!1"))
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((measure_eq_isf? formula-decl nil measure_equality nil)
    (T formal-type-decl nil measure_equality nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S formal-const-decl "sigma_algebra" measure_equality nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil))
   nil (measure_eq_isf subtype "measure_equality.f" "isf[T, S, nu]")))
 (measure_eq_isf 0
  (measure_eq_isf-1 nil 3459230997
   ("" (skolem + ("_" "mu!1" "nu!1"))
    (("" (case-replace "FORALL E: x_eq(mu!1(E), nu!1(E))")
      (("1"
        (case "forall (f:isf[T, S, mu!1]): isf_integral[T, S, mu!1](f) = isf_integral[T, S, nu!1](f)")
        (("1" (skosimp)
          (("1" (split -3)
            (("1" (inst - "f!1") nil nil)
             ("2"
              (lemma "measure_eq_isf?" ("mu" "mu!1" "nu" "nu!1" "f" "f!1"))
              (("2" (assert)
                (("2" (split)
                  (("1" (inst - "f!1") nil nil) ("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (skosimp)
            (("2"
              (lemma "isf_induction[T,S,mu!1]"
               ("P"
                "lambda (f:isf[T, S, mu!1]): isf_integral[T, S, mu!1](f) = isf_integral[T, S, nu!1](f)"))
              (("2" (inst - "f!1")
                (("2" (assert)
                  (("2" (hide 2)
                    (("2" (rewrite "isf_integral_zero[T, S, mu!1]")
                      (("2" (rewrite "isf_integral_zero[T, S, nu!1]")
                        (("2" (skosimp)
                          (("2" (rewrite "isf_integral_add[T, S, nu!1]")
                            (("1" (rewrite "isf_integral_add[T, S, mu!1]")
                              (("1" (replace -1)
                                (("1" (assert)
                                  (("1" (hide -1)
                                    (("1"
                                      (rewrite
                                       "isf_integral_scal[T, S, mu!1]")
                                      (("1"
                                        (rewrite
                                         "isf_integral_scal[T, S, nu!1]")
                                        (("1"
                                          (rewrite
                                           "isf_integral_phi[T,S,mu!1]")
                                          (("1"
                                            (rewrite
                                             "isf_integral_phi[T,S,nu!1]")
                                            (("1"
                                              (inst - "E!1")
                                              (("1"
                                                (expand "x_eq")
                                                (("1"
                                                  (expand "mu")
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (typepred "E!1")
                                                      (("1"
                                                        (expand "mu_fin?")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (typepred "E!1")
                                              (("2"
                                                (expand "mu_fin?")
                                                (("2"
                                                  (inst - "E!1")
                                                  (("2"
                                                    (expand "x_eq")
                                                    (("2"
                                                      (flatten)
                                                      (("2" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (rewrite "isf_phi[T, S, nu!1]")
                                          (("2"
                                            (typepred "E!1")
                                            (("2"
                                              (expand "mu_fin?")
                                              (("2"
                                                (inst - "E!1")
                                                (("2"
                                                  (expand "x_eq")
                                                  (("2"
                                                    (flatten)
                                                    (("2" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (rewrite "isf_scal[T, S, mu!1]") nil nil))
                              nil)
                             ("2" (rewrite "isf_scal[T, S, nu!1]")
                              (("2" (rewrite "isf_phi[T, S, nu!1]")
                                (("2" (typepred "E!1")
                                  (("2" (expand "mu_fin?")
                                    (("2" (inst - "E!1")
                                      (("2"
                                        (expand "x_eq")
                                        (("2"
                                          (flatten)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (skosimp)
          (("3" (lemma "measure_eq_isf?" ("mu" "mu!1" "nu" "nu!1" "f" "f!1"))
            (("3" (assert) nil nil)) nil))
          nil))
        nil)
       ("2" (replace 1 2) (("2" (hide 1) (("2" (skosimp) nil nil)) nil)) nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (isf_induction formula-decl nil isf nil)
    (isf_integral_zero formula-decl nil isf nil)
    (isf_phi application-judgement "isf" integral nil)
    (isf_integral_add formula-decl nil isf nil)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (set type-eq-decl nil sets nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (phi const-decl "nat" measure_space nil)
    (measurable_set? const-decl "bool" measure_space_def nil)
    (measurable_set nonempty-type-eq-decl nil measure_space_def nil)
    (mu_fin? const-decl "bool" measure_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (isf_integral_scal formula-decl nil isf nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (mu const-decl "nnreal" measure_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (isf_integral_phi formula-decl nil isf nil)
    (isf_phi judgement-tcc nil isf nil) (isf_scal judgement-tcc nil isf nil)
    (measure_eq_isf? formula-decl nil measure_equality nil)
    (isf? const-decl "bool" isf nil) (isf nonempty-type-eq-decl nil isf nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (isf_integral const-decl "real" isf nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (x_eq const-decl "bool" extended_nnreal extended_nnreal)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (S formal-const-decl "sigma_algebra" measure_equality nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil measure_equality nil))
   shostak))
 (measure_eq_nn_integrable? 0
  (measure_eq_nn_integrable?-1 nil 3459232122
   (""
    (case "FORALL (g: [T -> nnreal], mu, nu: measure_type[T, S]):
        (FORALL E: x_eq(mu(E), nu(E)))&nn_integrable?[T, S, mu](g) => nn_integrable?[T, S, nu](g)")
    (("1" (skosimp)
      (("1" (split 1)
        (("1" (flatten)
          (("1" (inst - "g!1" "mu!1" "nu!1") (("1" (assert) nil nil)) nil))
          nil)
         ("2" (flatten)
          (("2" (inst - "g!1" "nu!1" "mu!1")
            (("2" (assert)
              (("2" (hide-all-but (-2 2))
                (("2" (skosimp)
                  (("2" (inst - "E!1")
                    (("2" (expand "x_eq")
                      (("2" (flatten)
                        (("2" (assert)
                          (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (skosimp)
        (("2" (expand "nn_integrable?")
          (("2" (skosimp)
            (("2" (inst + "u!1")
              (("1" (assert)
                (("1" (expand "o ")
                  (("1"
                    (case-replace
                     "(LAMBDA (n: nat): isf_integral[T,S,mu!1](u!1(n)))=LAMBDA (n: nat): isf_integral[T,S,nu!1](u!1(n))")
                    (("1" (apply-extensionality :hide? t)
                      (("1" (hide -3 2 -2)
                        (("1" (typepred "u!1(x!1)")
                          (("1"
                            (lemma "measure_eq_isf"
                             ("mu" "mu!1" "nu" "nu!1" "f" "u!1(x!1)"))
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (skosimp)
                        (("2" (typepred "u!1(n!1)")
                          (("2"
                            (lemma "measure_eq_isf?"
                             ("nu" "nu!1" "mu" "mu!1" "f" "u!1(n!1)"))
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skosimp)
                      (("2"
                        (lemma "measure_eq_isf?"
                         ("nu" "nu!1" "mu" "mu!1" "f" "u!1(n!1)"))
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (typepred "u!1")
                (("2" (expand "increasing_nn_isf?")
                  (("2" (assert)
                    (("2" (skolem + "n!1")
                      (("2" (typepred "u!1(n!1)")
                        (("2" (expand "nn_isf?")
                          (("2" (assert)
                            (("2" (split)
                              (("1"
                                (lemma "measure_eq_isf?"
                                 ("mu" "mu!1" "nu" "nu!1" "f" "u!1(n!1)"))
                                (("1" (assert) nil nil)) nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nn_integrable? const-decl "bool" nn_integral nil)
    (x_eq const-decl "bool" extended_nnreal extended_nnreal)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (S formal-const-decl "sigma_algebra" measure_equality nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (T formal-type-decl nil measure_equality nil)
    (u!1 skolem-const-decl "increasing_nn_isf[T, S, mu!1]" measure_equality
     nil)
    (increasing_nn_isf nonempty-type-eq-decl nil nn_integral nil)
    (increasing_nn_isf? const-decl "bool" nn_integral nil)
    (sequence type-eq-decl nil sequences nil)
    (nn_isf nonempty-type-eq-decl nil nn_integral nil)
    (nn_isf? const-decl "bool" nn_integral nil)
    (isf nonempty-type-eq-decl nil isf nil)
    (mu!1 skolem-const-decl "measure_type[T, S]" measure_equality nil)
    (isf? const-decl "bool" isf nil)
    (nu!1 skolem-const-decl "measure_type[T, S]" measure_equality nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (O const-decl "T3" function_props nil)
    (isf_integral const-decl "real" isf nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (measure_eq_isf formula-decl nil measure_equality nil)
    (measure_eq_isf? formula-decl nil measure_equality nil))
   shostak))
 (measure_eq_nn_integral_TCC1 0
  (measure_eq_nn_integral_TCC1-1 nil 3459232044
   ("" (skosimp)
    (("" (split)
      (("1" (propax) nil nil)
       ("2"
        (lemma "measure_eq_nn_integrable?"
         ("mu" "mu!1" "nu" "nu!1" "g" "g!1"))
        (("2" (assert) nil nil)) nil))
      nil))
    nil)
   ((measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (S formal-const-decl "sigma_algebra" measure_equality nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (T formal-type-decl nil measure_equality nil)
    (measure_eq_nn_integrable? formula-decl nil measure_equality nil))
   nil
   (measure_eq_nn_integral subtype "measure_equality.g"
    "nn_integrable[T, S, mu]")))
 (measure_eq_nn_integral_TCC2 0
  (measure_eq_nn_integral_TCC2-1 nil 3459232044
   ("" (skosimp)
    (("" (assert)
      ((""
        (lemma "measure_eq_nn_integrable?"
         ("mu" "mu!1" "nu" "nu!1" "g" "g!1"))
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((measure_eq_nn_integrable? formula-decl nil measure_equality nil)
    (T formal-type-decl nil measure_equality nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S formal-const-decl "sigma_algebra" measure_equality nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil))
   nil
   (measure_eq_nn_integral subtype "measure_equality.g"
    "nn_integrable[T, S, nu]")))
 (measure_eq_nn_integral 0
  (measure_eq_nn_integral-1 nil 3459232639
   (""
    (case "FORALL (g: [T -> nnreal], mu, nu: measure_type[T, S]):
        (FORALL E: x_eq(mu(E), nu(E))) AND
         nn_integrable?[T, S, mu](g)
         => (nn_integral[T, S, mu](g) = nn_integral[T, S, nu](g))")
    (("1" (skosimp)
      (("1" (split -3)
        (("1" (inst - "g!1" "mu!1" "nu!1") (("1" (assert) nil nil)) nil)
         ("2"
          (lemma "measure_eq_nn_integrable?"
           ("mu" "mu!1" "nu" "nu!1" "g" "g!1"))
          (("2" (assert)
            (("2" (replace -4 -1)
              (("2" (inst - "g!1" "mu!1" "nu!1") (("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (skosimp)
        (("2"
          (lemma "measure_eq_nn_integrable?"
           ("mu" "mu!1" "nu" "nu!1" "g" "g!1"))
          (("2" (assert)
            (("2" (split)
              (("1" (lemma "nn_integral_def[T,S,nu!1]" ("f" "g!1"))
                (("1" (lemma "nn_integral_def[T,S,mu!1]" ("f" "g!1"))
                  (("1" (skosimp*)
                    (("1" (name-replace "LHS" "nn_integral[T, S, mu!1](g!1)")
                      (("1"
                        (name-replace "RHS" "nn_integral[T, S, nu!1](g!1)")
                        (("1"
                          (lemma "nn_convergence[T,S,mu!1]"
                           ("u1" "u!1" "u2" "u!2" "f" "g!1"))
                          (("1" (replace -2)
                            (("1" (replace -4)
                              (("1" (split -1)
                                (("1" (flatten)
                                  (("1"
                                    (case-replace
                                     "isf_integral[T, S, nu!1] o u!2 = isf_integral[T, S, mu!1] o u!2")
                                    (("1" (hide -1)
                                      (("1"
                                        (lemma
                                         "hausdorff_convergence.limit_def"
                                         ("v"
                                          "isf_integral[T, S, mu!1] o u!2"
                                          "l"
                                          "RHS"))
                                        (("1"
                                          (assert)
                                          (("1"
                                            (replace -1)
                                            (("1"
                                              (lemma
                                               "hausdorff_convergence.limit_def"
                                               ("v"
                                                "isf_integral[T, S, mu!1] o u!1"
                                                "l"
                                                "LHS"))
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (apply-extensionality :hide? t)
                                      (("2"
                                        (hide 2)
                                        (("2"
                                          (expand "o ")
                                          (("2"
                                            (lemma
                                             "measure_eq_isf?"
                                             ("mu"
                                              "mu!1"
                                              "nu"
                                              "nu!1"
                                              "f"
                                              "u!2(x!1)"))
                                            (("2"
                                              (assert)
                                              (("2"
                                                (split)
                                                (("1"
                                                  (lemma
                                                   "measure_eq_isf"
                                                   ("mu"
                                                    "mu!1"
                                                    "nu"
                                                    "nu!1"
                                                    "f"
                                                    "u!2(x!1)"))
                                                  (("1" (assert) nil nil))
                                                  nil)
                                                 ("2" (propax) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (expand "convergent?")
                                  (("2" (inst + "LHS") nil nil)) nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but (-6 1))
                            (("2" (typepred "u!2")
                              (("2" (expand "increasing_nn_isf?")
                                (("2" (replace -1)
                                  (("2" (skosimp)
                                    (("2" (typepred "u!2(x1!1)")
                                      (("2"
                                        (expand "nn_isf?")
                                        (("2"
                                          (replace -2)
                                          (("2"
                                            (lemma
                                             "measure_eq_isf?"
                                             ("mu"
                                              "mu!1"
                                              "nu"
                                              "nu!1"
                                              "f"
                                              "u!2(x1!1)"))
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skosimp)
        (("3"
          (lemma "measure_eq_nn_integrable?"
           ("nu" "nu!1" "mu" "mu!1" "g" "g!1"))
          (("3" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((nn_integral const-decl "nnreal" nn_integral nil)
    (nn_integrable nonempty-type-eq-decl nil nn_integral nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nn_integrable? const-decl "bool" nn_integral nil)
    (x_eq const-decl "bool" extended_nnreal extended_nnreal)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (S formal-const-decl "sigma_algebra" measure_equality nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (T formal-type-decl nil measure_equality nil)
    (measure_eq_nn_integrable? formula-decl nil measure_equality nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (isf_integral const-decl "real" isf nil)
    (O const-decl "T3" function_props nil)
    (metric_induced_topology const-decl "setofsets[T]" metric_space_def
     metric_space)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (convergent type-eq-decl nil topological_convergence topology)
    (convergent? const-decl "bool" topological_convergence topology)
    (limit_def formula-decl nil hausdorff_convergence topology)
    (measure_eq_isf? formula-decl nil measure_equality nil)
    (measure_eq_isf formula-decl nil measure_equality nil)
    (nn_convergence formula-decl nil nn_integral nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (isf? const-decl "bool" isf nil) (isf nonempty-type-eq-decl nil isf nil)
    (nn_isf? const-decl "bool" nn_integral nil)
    (nn_isf nonempty-type-eq-decl nil nn_integral nil)
    (sequence type-eq-decl nil sequences nil)
    (increasing_nn_isf? const-decl "bool" nn_integral nil)
    (increasing_nn_isf nonempty-type-eq-decl nil nn_integral nil)
    (nn_integral_def formula-decl nil nn_integral nil))
   shostak))
 (measure_eq_integrable? 0
  (measure_eq_integrable?-1 nil 3459234013
   ("" (skosimp)
    (("" (rewrite "integrable_pm_def[T, S, mu!1]")
      (("" (rewrite "integrable_pm_def[T, S, nu!1]")
        ((""
          (lemma "measure_eq_nn_integrable?"
           ("nu" "nu!1" "mu" "mu!1" "g" "plus(f!1)"))
          ((""
            (lemma "measure_eq_nn_integrable?"
             ("nu" "nu!1" "mu" "mu!1" "g" "minus(f!1)"))
            (("" (replace -3)
              (("" (assert)
                (("" (split 1)
                  (("1" (flatten)
                    (("1" (assert)
                      (("1"
                        (lemma "nn_integrable_is_nn_integrable[T, S, mu!1]"
                         ("f" "plus(f!1)"))
                        (("1" (split -1)
                          (("1" (assert)
                            (("1"
                              (lemma
                               "nn_integrable_is_nn_integrable[T, S, mu!1]"
                               ("f" "minus(f!1)"))
                              (("1" (split)
                                (("1" (assert)
                                  (("1" (hide-all-but (-5 -7 1))
                                    (("1"
                                      (lemma
                                       "nn_integrable_is_integrable[T,S,nu!1]")
                                      (("1"
                                        (inst-cp - "minus(f!1)")
                                        (("1"
                                          (inst - "plus(f!1)")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (hide-all-but 1) (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2"
                      (lemma "nn_integrable_is_nn_integrable[T, S, nu!1]"
                       ("f" "minus(f!1)"))
                      (("1"
                        (lemma "nn_integrable_is_nn_integrable[T, S, nu!1]"
                         ("f" "plus(f!1)"))
                        (("1" (split)
                          (("1" (split)
                            (("1" (assert)
                              (("1"
                                (lemma
                                 "nn_integrable_is_integrable[T,S,mu!1]")
                                (("1" (inst-cp - "minus(f!1)")
                                  (("1" (inst - "plus(f!1)")
                                    (("1" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but 1) (("2" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil)
                       ("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((integrable_pm_def formula-decl nil integral nil)
    (T formal-type-decl nil measure_equality nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (S formal-const-decl "sigma_algebra" measure_equality nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil) (nnreal type-eq-decl nil real_types nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (measure? const-decl "bool" generalized_measure_def nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (plus const-decl "[T -> nnreal]" real_fun_ops_aux reals)
    (measure_eq_nn_integrable? formula-decl nil measure_equality nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (integrable? const-decl "bool" integral nil)
    (nn_integrable_is_nn_integrable formula-decl nil integral nil)
    (nn_integrable nonempty-type-eq-decl nil nn_integral nil)
    (nn_integrable? const-decl "bool" nn_integral nil)
    (nn_integrable_is_integrable judgement-tcc nil integral nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus const-decl "[T -> nnreal]" real_fun_ops_aux reals))
   shostak))
 (measure_eq_integral_TCC1 0
  (measure_eq_integral_TCC1-1 nil 3459233920
   ("" (skosimp)
    (("" (lemma "measure_eq_integrable?" ("nu" "nu!1" "mu" "mu!1" "f" "f!1"))
      (("" (assert)
        (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (S formal-const-decl "sigma_algebra" measure_equality nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (T formal-type-decl nil measure_equality nil)
    (measure_eq_integrable? formula-decl nil measure_equality nil))
   nil
   (measure_eq_integral subtype "measure_equality.f" "integrable[T, S, mu]")))
 (measure_eq_integral_TCC2 0
  (measure_eq_integral_TCC2-1 nil 3459233920
   ("" (skosimp)
    (("" (lemma "measure_eq_integrable?" ("nu" "nu!1" "mu" "mu!1" "f" "f!1"))
      (("" (assert)
        (("" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (S formal-const-decl "sigma_algebra" measure_equality nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (T formal-type-decl nil measure_equality nil)
    (measure_eq_integrable? formula-decl nil measure_equality nil))
   nil
   (measure_eq_integral subtype "measure_equality.f" "integrable[T, S, nu]")))
 (measure_eq_integral 0
  (measure_eq_integral-1 nil 3459234384
   (""
    (case "FORALL (f: [T -> real], mu, nu: measure_type[T, S]):
        (FORALL E: x_eq(mu(E), nu(E))) AND integrable?[T, S, mu](f)
         => (integral[T, S, mu](f) = integral[T, S, nu](f))")
    (("1" (skosimp)
      (("1" (split -3)
        (("1" (inst - "f!1" "mu!1" "nu!1") (("1" (assert) nil nil)) nil)
         ("2"
          (lemma "measure_eq_integrable?" ("mu" "mu!1" "nu" "nu!1" "f" "f!1"))
          (("2" (assert)
            (("2" (split -1)
              (("1" (inst - "f!1" "mu!1" "nu!1") (("1" (assert) nil nil)) nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (skosimp)
        (("2" (rewrite "integral_pm[T, S, mu!1]")
          (("2" (rewrite "integral_pm[T, S, nu!1]")
            (("2"
              (lemma "measure_eq_integrable?"
               ("mu" "mu!1" "nu" "nu!1" "f" "f!1"))
              (("2" (assert)
                (("2" (replace -2)
                  (("2" (rewrite "integrable_pm_def[T, S, nu!1]")
                    (("2" (rewrite "integrable_pm_def[T, S, mu!1]")
                      (("2" (flatten)
                        (("2"
                          (lemma "nn_integrable_is_nn_integrable[T,S,mu!1]")
                          (("2" (inst-cp - "plus(f!1)")
                            (("2" (inst - "minus(f!1)")
                              (("2"
                                (lemma
                                 "nn_integrable_is_nn_integrable[T,S,nu!1]")
                                (("2" (inst-cp - "plus(f!1)")
                                  (("2" (inst - "minus(f!1)")
                                    (("2"
                                      (case-replace
                                       "FORALL (x: T): minus(f!1)(x) >= 0")
                                      (("1"
                                        (case-replace
                                         "FORALL (x: T): plus(f!1)(x) >= 0")
                                        (("1"
                                          (rewrite "integral_nn[T,S,mu!1]")
                                          (("1"
                                            (rewrite "integral_nn[T,S,mu!1]")
                                            (("1"
                                              (rewrite
                                               "integral_nn[T,S,nu!1]")
                                              (("1"
                                                (rewrite
                                                 "integral_nn[T,S,nu!1]")
                                                (("1"
                                                  (lemma
                                                   "measure_eq_nn_integral"
                                                   ("mu"
                                                    "mu!1"
                                                    "nu"
                                                    "nu!1"
                                                    "g"
                                                    "plus(f!1)"))
                                                  (("1"
                                                    (lemma
                                                     "measure_eq_nn_integral"
                                                     ("mu"
                                                      "mu!1"
                                                      "nu"
                                                      "nu!1"
                                                      "g"
                                                      "minus(f!1)"))
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (replace -11)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide-all-but 1)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide-all-but 1)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skosimp)
        (("3"
          (lemma "measure_eq_integrable?" ("mu" "mu!1" "nu" "nu!1" "f" "f!1"))
          (("3" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((integral const-decl "real" integral nil)
    (integrable nonempty-type-eq-decl nil integral nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (integrable? const-decl "bool" integral nil)
    (x_eq const-decl "bool" extended_nnreal extended_nnreal)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (measure_type nonempty-type-eq-decl nil generalized_measure_def nil)
    (measure? const-decl "bool" generalized_measure_def nil)
    (extended_nnreal nonempty-type-eq-decl nil extended_nnreal
     extended_nnreal)
    (nnreal type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil)
    (S formal-const-decl "sigma_algebra" measure_equality nil)
    (sigma_algebra nonempty-type-eq-decl nil subset_algebra_def nil)
    (sigma_algebra? const-decl "bool" subset_algebra_def nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (T formal-type-decl nil measure_equality nil)
    (measure_eq_integrable? formula-decl nil measure_equality nil)
    (integrable_pm_def formula-decl nil integral nil)
    (plus const-decl "[T -> nnreal]" real_fun_ops_aux reals)
    (measure_eq_nn_integral formula-decl nil measure_equality nil)
    (integral_nn formula-decl nil integral nil)
    (nn_integrable? const-decl "bool" nn_integral nil)
    (nn_integrable nonempty-type-eq-decl nil nn_integral nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus const-decl "[T -> nnreal]" real_fun_ops_aux reals)
    (nn_integrable_is_nn_integrable formula-decl nil integral nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (integral_pm formula-decl nil integral nil))
   shostak)))

