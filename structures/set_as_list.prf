(set_as_list (empty_sl_is_empty 0 (empty_sl_is_empty-1 nil 3591613697 ("" (skosimp*) (("" (split) (("1" (skosimp*) (("1" (expand "empty_sl?") (("1" (rewrite -1) (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (generalize "l!1" l) (("2" (induct l) (("1" (expand "empty_sl?") (("1" (propax) nil nil)) nil) ("2" (skosimp*) (("2" (inst -2 "cons1_var!1") (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((empty_sl? const-decl "bool" set_as_list nil) (member def-decl "bool" list_props nil) (list_induction formula-decl nil list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil)) shostak)) (subset_sl?_TCC1 0 (subset_sl?_TCC1-1 nil 3569678532 ("" (skeep) (("" (rewrite -1) (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil)) nil (subset_sl? subtype "booleans.TRUE" "{b: booleans.bool | booleans.IFF(b, FORALL x: booleans.=>(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))}"))) (subset_sl?_TCC2 0 (subset_sl?_TCC2-1 nil 3569678532 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil (subset_sl? termination "set_as_list.subset_sl?(set_as_list.q, set_as_list.l2)" "nil"))) (subset_sl?_TCC3 0 (subset_sl?_TCC3-1 nil 3569678532 ("" (skeep) (("" (typepred "v(q, l2)") (("1" (split 1) (("1" (skosimp*) (("1" (assert) (("1" (rewrite -6) (("1" (expand "member" -3) (("1" (inst -4 "x!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (assert) (("2" (inst-cp -1 "a") (("2" (rewrite -5) (("2" (expand "member" -2 1) (("2" (assert) (("2" (skosimp*) (("2" (expand "member" -1 1) (("2" (inst -1 "x!1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite -1) (("2" (expand <<) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (subset_sl? subtype "booleans.AND(list_props[set_as_list.T].member(set_as_list.a, set_as_list.l2), set_as_list.subset_sl?(set_as_list.q, set_as_list.l2))" "{b: booleans.bool | booleans.IFF(b, FORALL x: booleans.=>(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))}"))) (add_sl_TCC1 0 (add_sl_TCC1-1 nil 3569678532 ("" (skosimp*) (("" (expand "nonempty_sl?") (("" (expand "empty_sl?") (("" (rewrite -1) (("" (expand "member" 1 2) (("" (expand "member" 1) (("" (expand "member" 1) (("" (assert) (("" (skosimp*) (("" (split 1) (("1" (ground) nil nil) ("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonempty_sl? const-decl "bool" set_as_list nil) (member def-decl "bool" list_props nil) (empty_sl? const-decl "bool" set_as_list nil)) nil (add_sl subtype "(: set_as_list.x :)" "{ll: (set_as_list.nonempty_sl?) | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.OR(set_as_list.x = set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}"))) (add_sl_TCC2 0 (add_sl_TCC2-2 "" 3803615429 ("" (skeep) (("" (rewrite -1) (("" (split 1) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "member" 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) nil shostak (add_sl subtype "set_as_list.l" "{ll: (set_as_list.nonempty_sl?) | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.OR(set_as_list.x = set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}")) (add_sl_TCC2-1 nil 3569678532 ("" (skeep) (("" (rewrite -2) (("" (split 1) (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "member" 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil) (nonempty_sl? const-decl "bool" set_as_list nil) (empty_sl? const-decl "bool" set_as_list nil)) nil (add_sl subtype "set_as_list.l" "{ll: (set_as_list.nonempty_sl?) | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.OR(set_as_list.x = set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}"))) (add_sl_TCC3 0 (add_sl_TCC3-1 nil 3569678532 ("" (skeep) (("" (rewrite -1) (("" (expand <<) (("" (propax) nil nil)) nil)) nil)) nil) ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil (add_sl termination "set_as_list.add_sl(set_as_list.x, set_as_list.q)" "nil"))) (add_sl_TCC4 0 (add_sl_TCC4-1 nil 3569679497 ("" (skeep) (("" (ground) (("1" (grind) nil nil) ("2" (typepred "v(x, q)") (("1" (skeep) (("1" (expand "member" 1 1) (("1" (inst -2 "y") (("1" (rewrite -2) (("1" (rewrite -3) (("1" (hide -2) (("1" (expand "member" 1 2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite -1) (("2" (expand <<) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((empty_sl? const-decl "bool" set_as_list nil) (nonempty_sl? const-decl "bool" set_as_list nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil set_as_list nil) (list type-decl nil list_adt nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil)) nil (add_sl subtype "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.add_sl(set_as_list.x, set_as_list.q))" "{ll: (set_as_list.nonempty_sl?) | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.OR(set_as_list.x = set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}"))) (remove_sl_TCC1 0 (remove_sl_TCC1-1 nil 3569678532 ("" (skeep) (("" (rewrite -1) (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil)) nil (remove_sl subtype "list_adt[set_as_list.T].null" "{ll: list_adt[set_as_list.T].list | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.AND(set_as_list.x /= set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}"))) (remove_sl_TCC2 0 (remove_sl_TCC2-1 nil 3569678532 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil (remove_sl termination "set_as_list.remove_sl(set_as_list.x, set_as_list.q)" "nil"))) (remove_sl_TCC3 0 (remove_sl_TCC3-1 nil 3569678532 ("" (skeep) (("" (skeep) (("" (typepred "v(x, q)") (("" (inst -1 "y") (("" (rewrite -3) (("" (expand "member" 1 2) (("" (rewrite -1) (("" (hide -1) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil set_as_list nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil)) nil (remove_sl subtype "set_as_list.remove_sl(set_as_list.x, set_as_list.q)" "{ll: list_adt[set_as_list.T].list | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.AND(set_as_list.x /= set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}"))) (remove_sl_TCC4 0 (remove_sl_TCC4-1 nil 3569678532 ("" (skeep) (("" (skeep) (("" (typepred "v(x, q)") (("" (inst -1 "y") (("" (rewrite -2) (("" (expand "member" 2) (("" (rewrite -1) (("" (hide -1) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil set_as_list nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil)) nil (remove_sl subtype "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.remove_sl(set_as_list.x, set_as_list.q))" "{ll: list_adt[set_as_list.T].list | FORALL y: booleans.IFF(list_props[set_as_list.T].member(set_as_list.y, ll), (booleans.AND(set_as_list.x /= set_as_list.y, list_props[set_as_list.T].member(set_as_list.y, set_as_list.l))))}"))) (equal_sl_TCC1 0 (equal_sl_TCC1-1 nil 3569678532 ("" (skeep) (("" (typepred "subset_sl?(l1, l2)") (("" (typepred "subset_sl?(l2, l1)") (("" (grind) nil nil)) nil)) nil)) nil) ((subset_sl? def-decl "{b: bool | b IFF FORALL x: member(x, l1) => member(x, l2)}" set_as_list nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil (equal_sl subtype "booleans.AND(set_as_list.subset_sl?(set_as_list.l1, set_as_list.l2), set_as_list.subset_sl?(set_as_list.l2, set_as_list.l1))" "{b: booleans.bool | booleans.IFF(b, FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))}"))) (strict_subset_sl?_TCC1 0 (strict_subset_sl?_TCC1-1 nil 3569678532 ("" (skeep) (("" (expand "equal_sl") (("" (grind) nil nil)) nil)) nil) ((equal_sl const-decl "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}" set_as_list nil)) nil (strict_subset_sl? subtype "booleans.&(set_as_list.subset_sl?(set_as_list.l1, set_as_list.l2), (booleans.NOT)(set_as_list.subset_sl?(set_as_list.l2, set_as_list.l1)))" "{b: booleans.bool | booleans.IFF(b, booleans.&(set_as_list.subset_sl?(set_as_list.l1, set_as_list.l2), (booleans.NOT)(set_as_list.equal_sl(set_as_list.l2, set_as_list.l1))))}"))) (union_sl_TCC1 0 (union_sl_TCC1-1 nil 3569678532 ("" (skeep) (("" (rewrite -1) (("" (expand "member" 1 2) (("" (propax) nil nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil)) nil (union_sl subtype "set_as_list.l2" "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.OR(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}"))) (union_sl_TCC2 0 (union_sl_TCC2-1 nil 3569678532 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil (union_sl termination "set_as_list.union_sl(set_as_list.q, set_as_list.l2)" "nil"))) (union_sl_TCC3 0 (union_sl_TCC3-1 nil 3569678532 ("" (skeep) (("" (skeep) (("" (typepred "v(q, l2)") (("" (typepred "add_sl(a, v(q, l2))") (("" (rewrite -4) (("" (inst -2 "x") (("" (inst -3 "x") (("" (rewrite -2) (("" (rewrite -3) (("" (expand "member" 1 3) (("" (assert) (("" (hide -1 -2 -3) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((add_sl def-decl "{ll: (nonempty_sl?) | FORALL y: member(y, ll) IFF (x = y OR member(y, l))}" set_as_list nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonempty_sl? const-decl "bool" set_as_list nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil set_as_list nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil)) nil (union_sl subtype "set_as_list.add_sl(set_as_list.a, set_as_list.union_sl(set_as_list.q, set_as_list.l2))" "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.OR(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}"))) (intersection_sl_TCC1 0 (intersection_sl_TCC1-1 nil 3569678532 ("" (skosimp*) (("" (rewrite -1) (("" (expand "member" 1 (1 2)) (("" (propax) nil nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil)) nil (intersection_sl subtype "list_adt[set_as_list.T].null" "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}"))) (intersection_sl_TCC2 0 (intersection_sl_TCC2-2 "" 3803615612 ("" (skeep) (("" (skeep) (("" (typepred "v(q, l2)") (("" (expand "member" 1 1) (("" (inst -1 "x") (("" (rewrite -1) (("" (hide -1) (("" (rewrite -1) (("" (expand "member" 1 3) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (intersection_sl subtype "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.intersection_sl(set_as_list.q, set_as_list.l2))" "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}")) (intersection_sl_TCC2-1 nil 3569678532 ("" (skeep) (("" (skeep) (("" (typepred "v(q, l2)") (("" (expand "member" 1 1) (("" (inst -1 "x") (("" (rewrite -1) (("" (hide -1) (("" (rewrite -2) (("" (expand "member" 1 3) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil set_as_list nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil)) nil (intersection_sl subtype "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.intersection_sl(set_as_list.q, set_as_list.l2))" "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}"))) (intersection_sl_TCC3 0 (intersection_sl_TCC3-1 nil 3569678532 ("" (skeep) (("" (skeep) (("" (typepred "v(q, l2)") (("" (rewrite -2) (("" (inst -1 "x") (("" (rewrite -1) (("" (hide -1) (("" (expand "member" 2 3) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil set_as_list nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil)) nil (intersection_sl subtype "set_as_list.intersection_sl(set_as_list.q, set_as_list.l2)" "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2))))}"))) (difference_sl_TCC1 0 (difference_sl_TCC1-1 nil 3569678532 ("" (skeep) (("" (skeep) (("" (rewrite -1) (("" (expand "member" 1) (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil)) nil (difference_sl subtype "list_adt[set_as_list.T].null" "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), (booleans.NOT)(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))))}"))) (difference_sl_TCC2 0 (difference_sl_TCC2-2 "" 3803615743 ("" (skeep) (("" (skeep) (("" (typepred "v(q, l2)") (("" (rewrite -2) (("" (inst -1 "x") (("" (rewrite -1) (("" (hide -1) (("" (expand "member" 1 3) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (difference_sl subtype "set_as_list.difference_sl(set_as_list.q, set_as_list.l2)" "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), (booleans.NOT)(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))))}")) (difference_sl_TCC2-1 nil 3569678532 ("" (skeep) (("" (skeep) (("" (typepred "v(q, l2)") (("" (rewrite -3) (("" (inst -1 "x") (("" (rewrite -1) (("" (hide -1) (("" (expand "member" 1 3) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil set_as_list nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil)) nil (difference_sl subtype "set_as_list.difference_sl(set_as_list.q, set_as_list.l2)" "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), (booleans.NOT)(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))))}"))) (difference_sl_TCC3 0 (difference_sl_TCC3-1 nil 3569678532 ("" (skeep) (("" (skeep) (("" (typepred "v(q, l2)") (("" (inst -1 "x") (("" (rewrite -2) (("" (expand "member" 2 (1 2)) (("" (rewrite -1) (("" (hide -1) (("" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil set_as_list nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (member def-decl "bool" list_props nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil)) nil (difference_sl subtype "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.difference_sl(set_as_list.q, set_as_list.l2))" "{ll: list_adt[set_as_list.T].list | FORALL x: booleans.IFF(list_props[set_as_list.T].member(set_as_list.x, ll), (booleans.AND(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l1), (booleans.NOT)(list_props[set_as_list.T].member(set_as_list.x, set_as_list.l2)))))}"))) (list2set_TCC1 0 (list2set_TCC1-1 nil 3569678532 ("" (skeep) (("" (rewrite -1) (("" (expand "member" 1) (("" (ground) (("" (expand "emptyset") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" set_as_list nil) (emptyset const-decl "set" sets nil) (member def-decl "bool" list_props nil)) nil (list2set subtype "sets[set_as_list.T].emptyset" "{s: finite_sets[set_as_list.T].finite_set | s = {x | list_props[set_as_list.T].member(set_as_list.x, set_as_list.l)}}"))) (list2set_TCC2 0 (list2set_TCC2-1 nil 3569678532 ("" (skeep) (("" (expand "add") (("" (typepred "v(q)") (("1" (rewrite -3) (("1" (expand "member" 1 2) (("1" (rewrite -2) (("1" (expand "member" 1 1) (("1" (assert) (("1" (lemma "extensionality[T]") (("1" (inst? -1) (("1" (split -1) (("1" (propax) nil nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "member" 1 (1 3)) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite -1) (("2" (expand <<) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((add const-decl "(nonempty?)" sets nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (extensionality formula-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil set_as_list nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (list type-decl nil list_adt nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (finite_set type-eq-decl nil finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (member def-decl "bool" list_props nil)) nil (list2set subtype "sets[set_as_list.T].add(set_as_list.a, set_as_list.list2set(set_as_list.q))" "{s: finite_sets[set_as_list.T].finite_set | s = {x | list_props[set_as_list.T].member(set_as_list.x, set_as_list.l)}}"))) (set2list_TCC1 0 (set2list_TCC1-1 nil 3656356303 ("" (skeep) (("" (use "empty_card") (("" (assert) (("" (replace -1) (("" (expand "length") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((empty_card formula-decl nil finite_sets nil) (T formal-type-decl nil set_as_list nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (member def-decl "bool" list_props nil) (length def-decl "nat" list_props nil)) nil (set2list subtype "list_adt[set_as_list.T].null" "{l: list_adt[set_as_list.T].list | booleans.AND(list_props[set_as_list.T].length(l) = finite_sets[set_as_list.T].card(set_as_list.s), FORALL (x: set_as_list.T): booleans.IFF(set_as_list.s(x), list_props[set_as_list.T].member(x, l)))}"))) (set2list_TCC2 0 (set2list_TCC2-1 nil 3656356303 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil set_as_list nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil (set2list subtype "set_as_list.s" "(sets[set_as_list.T].nonempty?)"))) (set2list_TCC3 0 (set2list_TCC3-1 nil 3656356303 ("" (skeep) (("" (use "card_rest") (("" (assert) nil nil)) nil)) nil) ((card_rest formula-decl nil finite_sets nil) (T formal-type-decl nil set_as_list nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finite_rest application-judgement "finite_set[T]" set_as_list nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (set2list termination "set_as_list.set2list(sets[set_as_list.T].rest(set_as_list.s))" "nil"))) (set2list_TCC4 0 (set2list_TCC4-1 nil 3656356303 ("" (skeep*) (("" (typepred "v(rest(s))") (("1" (split 2) (("1" (expand "length" 1 1) (("1" (replace -1 :hide? t) (("1" (use "card_rest") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "member" 1 1) (("2" (ground) (("1" (use "choose_rest_or[T]") (("1" (expand "member" -1) (("1" (inst -4 "x") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -3 "x") (("2" (assert) (("2" (use "rest_member[T]") (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "card_rest") (("2" (assert) nil nil)) nil)) nil)) nil) ((rest const-decl "set" sets nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (< const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_rest application-judgement "finite_set[T]" set_as_list nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (choose_rest_or formula-decl nil sets_lemmas nil) (rest_member formula-decl nil sets_lemmas nil) (card_rest formula-decl nil finite_sets nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (set2list subtype "list_adt[set_as_list.T].cons(sets[set_as_list.T].choose(set_as_list.s), set_as_list.set2list(sets[set_as_list.T].rest(set_as_list.s)))" "{l: list_adt[set_as_list.T].list | booleans.AND(list_props[set_as_list.T].length(l) = finite_sets[set_as_list.T].card(set_as_list.s), FORALL (x: set_as_list.T): booleans.IFF(set_as_list.s(x), list_props[set_as_list.T].member(x, l)))}"))) (card_sl_TCC1 0 (card_sl_TCC1-1 nil 3569678532 ("" (skeep) (("" (rewrite -1) (("" (expand "list2set") (("" (lemma "card_emptyset") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil set_as_list nil) (card_emptyset formula-decl nil finite_sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (finite_emptyset name-judgement "finite_set[T]" set_as_list nil) (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list nil)) nil (card_sl subtype "0" "{n: naturalnumbers.nat | n = finite_sets[set_as_list.T].Card(set_as_list.list2set(set_as_list.l))}"))) (card_sl_TCC2 0 (card_sl_TCC2-2 "" 3803616304 ("" (skeep) (("" (typepred "v(q)") (("" (typepred "list2set(l)") (("" (typepred "list2set(q)") (("" (rewrite -5) (("" (case "list2set(q) = list2set(l)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite -2) (("2" (rewrite -4) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (rewrite -3) (("2" (expand "member" 1 2) (("2" (case "x!1 = a") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (card_sl subtype "set_as_list.card_sl(set_as_list.q)" "{n: naturalnumbers.nat | n = finite_sets[set_as_list.T].Card(set_as_list.list2set(set_as_list.l))}")) (card_sl_TCC2-1 nil 3569678532 ("" (skeep) (("" (typepred "v(q)") (("" (typepred "list2set(l)") (("" (typepred "list2set(q)") (("" (rewrite -5) (("" (case "list2set(q) = list2set(l)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (rewrite -2) (("2" (rewrite -3) (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (rewrite -4) (("2" (expand "member" 1 2) (("2" (case "x!1 = a") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list nil) (member def-decl "bool" list_props nil) (Card const-decl "nat" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)) nil (card_sl subtype "set_as_list.card_sl(set_as_list.q)" "{n: naturalnumbers.nat | n = finite_sets[set_as_list.T].Card(set_as_list.list2set(set_as_list.l))}"))) (card_sl_TCC3 0 (card_sl_TCC3-1 nil 3569678532 ("" (skeep) (("" (typepred "list2set(q)") (("" (lemma "card_add") (("" (inst -1 "{x | member(x, q)}" "a") (("1" (typepred "list2set(l)") (("1" (rewrite -2) (("1" (rewrite -5) (("1" (expand "member" 2) (("1" (hide -1) (("1" (expand "add" -1) (("1" (expand "member" -1 1) (("1" (case "{y: T | a = y OR member(y, q)} = {x | x = a OR member(x, q)}") (("1" (rewrite -1) (("1" (assert) nil nil)) nil) ("2" (apply-extensionality 1) (("2" (case "x!1 = a") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ((list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list nil) (member def-decl "bool" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (list type-decl nil list_adt nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil set_as_list nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (q skolem-const-decl "list[T]" set_as_list nil) (add const-decl "(nonempty?)" sets nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (member const-decl "bool" sets nil) (card_add formula-decl nil finite_sets nil)) nil (card_sl subtype "(number_fields.+)(1, set_as_list.card_sl(set_as_list.q))" "{n: naturalnumbers.nat | n = finite_sets[set_as_list.T].Card(set_as_list.list2set(set_as_list.l))}"))) (reduce_sl_TCC1 0 (reduce_sl_TCC1-1 nil 3569739643 ("" (expand "equal_sl") (("" (skosimp*) (("" (rewrite -1) (("" (expand "subset_sl?") (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((subset_sl? def-decl "{b: bool | b IFF FORALL x: member(x, l1) => member(x, l2)}" set_as_list nil) (card_sl def-decl "{n: nat | n = Card(list2set(l))}" set_as_list nil) (length def-decl "nat" list_props nil) (equal_sl const-decl "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}" set_as_list nil)) nil (reduce_sl subtype "list_adt[set_as_list.T].null" "{ll: list_adt[set_as_list.T].list | booleans.&(set_as_list[set_as_list.T].equal_sl(set_as_list.l, ll), set_as_list.card_sl(ll) = list_props[set_as_list.T].length(ll))}"))) (reduce_sl_TCC2 0 (reduce_sl_TCC2-2 "" 3803616670 ("" (skosimp*) (("" (typepred "v!1(q!1)") (("1" (split) (("1" (expand "equal_sl" 1) (("1" (expand "equal_sl" -1) (("1" (flatten) (("1" (split) (("1" (expand "subset_sl?" 1) (("1" (rewrite -4) (("1" (assert) (("1" (typepred "subset_sl?(q!1,v!1(q!1))") (("1" (assert) (("1" (inst? -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite -4) (("2" (typepred "subset_sl?(v!1(q!1), cons(a!1, q!1))") (("2" (split -2) (("1" (propax) nil nil) ("2" (typepred "subset_sl?(v!1(q!1), q!1)") (("2" (skosimp*) (("2" (expand "member" 1) (("2" (assert) (("2" (flatten) (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (rewrite -1) (("2" (grind) nil nil)) nil)) nil)) nil) nil shostak (reduce_sl subtype "set_as_list.reduce_sl(set_as_list.q)" "{ll: list_adt[set_as_list.T].list | booleans.&(set_as_list[set_as_list.T].equal_sl(set_as_list.l, ll), set_as_list.card_sl(ll) = list_props[set_as_list.T].length(ll))}")) (reduce_sl_TCC2-1 nil 3569739643 ("" (skosimp*) (("" (typepred "v!1(q!1)") (("1" (split) (("1" (expand "equal_sl" 1) (("1" (expand "equal_sl" -1) (("1" (flatten) (("1" (split) (("1" (expand "subset_sl?" 1) (("1" (rewrite -5) (("1" (assert) (("1" (typepred "subset_sl?(q!1,v!1(q!1))") (("1" (assert) (("1" (inst? -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite -5) (("2" (typepred "subset_sl?(v!1(q!1), cons(a!1, q!1))") (("2" (split -2) (("1" (propax) nil nil) ("2" (typepred "subset_sl?(v!1(q!1), q!1)") (("2" (skosimp*) (("2" (expand "member" 1) (("2" (assert) (("2" (flatten) (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil) ("2" (rewrite -2) (("2" (grind) nil nil)) nil)) nil)) nil) ((length def-decl "nat" list_props nil) (card_sl def-decl "{n: nat | n = Card(list2set(l))}" set_as_list nil) (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list nil) (Card const-decl "nat" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (equal_sl const-decl "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}" set_as_list nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (subset_sl? def-decl "{b: bool | b IFF FORALL x: member(x, l1) => member(x, l2)}" set_as_list nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)) nil (reduce_sl subtype "set_as_list.reduce_sl(set_as_list.q)" "{ll: list_adt[set_as_list.T].list | booleans.&(set_as_list[set_as_list.T].equal_sl(set_as_list.l, ll), set_as_list.card_sl(ll) = list_props[set_as_list.T].length(ll))}"))) (reduce_sl_TCC3 0 (reduce_sl_TCC3-1 nil 3569739643 ("" (skosimp*) (("" (typepred "v!1(q!1)") (("1" (rewrite -3) (("1" (split) (("1" (typepred "equal_sl[T](q!1, v!1(q!1))") (("1" (typepred "equal_sl[T](cons(a!1, q!1), cons[T](a!1, v!1(q!1)))") (("1" (assert) (("1" (skosimp*) (("1" (hide -1) (("1" (hide -2) (("1" (expand "member" 1) (("1" (inst? -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "card_sl" 1) (("2" (assert) (("2" (typepred "equal_sl[T](q!1, v!1(q!1))") (("2" (assert) (("2" (hide -2) (("2" (inst? -1) (("2" (assert) (("2" (expand "length" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite -1) (("2" (grind) nil nil)) nil)) nil)) nil) ((length def-decl "nat" list_props nil) (card_sl def-decl "{n: nat | n = Card(list2set(l))}" set_as_list nil) (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list nil) (Card const-decl "nat" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (equal_sl const-decl "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}" set_as_list nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (reduce_sl subtype "list_adt[set_as_list.T].cons(set_as_list.a, set_as_list.reduce_sl(set_as_list.q))" "{ll: list_adt[set_as_list.T].list | booleans.&(set_as_list[set_as_list.T].equal_sl(set_as_list.l, ll), set_as_list.card_sl(ll) = list_props[set_as_list.T].length(ll))}"))) (equal_sl_card 0 (equal_sl_card-1 nil 3569741498 ("" (skeep) (("" (typepred "equal_sl(l1,l2)") (("" (assert) (("" (hide -2 -3) (("" (typepred "card_sl(l1)") (("" (typepred "card_sl(l2)") (("" (typepred "list2set(l1)") (("" (typepred "list2set(l2)") (("" (hide -1 -3) (("" (rewrite -1) (("" (rewrite -1) (("" (rewrite -1) (("" (rewrite -1) (("" (case "{x | member(x, l1)} = {x | member(x, l2)}") (("1" (assert) nil nil) ("2" (hide 2) (("2" (apply-extensionality 1) (("2" (inst? -1) (("2" (rewrite -1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((equal_sl const-decl "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}" set_as_list nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (list type-decl nil list_adt nil) (T formal-type-decl nil set_as_list nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (Card const-decl "nat" finite_sets nil) (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list nil) (card_sl def-decl "{n: nat | n = Card(list2set(l))}" set_as_list nil)) shostak)) (member_sl 0 (member_sl-1 nil 3681834201 ("" (expand "member" 1 2) (("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (expand "list2set" 1) (("" (lift-if) (("" (prop) (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (expand "add") (("2" (expand "reduce_sl" -2) (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (inst -3 "cdr(x!1)") (("1" (inst -3 "x") (("1" (assert) (("1" (expand "member" 3) (("1" (assert) (("1" (hide-all-but (4 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "member" -1) (("2" (inst -2 "cdr(x!1)") (("2" (inst -2 "x") (("2" (expand "member" 4) (("2" (assert) (("2" (hide-all-but (5 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (T formal-type-decl nil set_as_list nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (equal_sl const-decl "{b: bool | b IFF FORALL x: member(x, l1) IFF member(x, l2)}" set_as_list nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (Card const-decl "nat" finite_sets nil) (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list nil) (card_sl def-decl "{n: nat | n = Card(list2set(l))}" set_as_list nil) (reduce_sl def-decl "{ll: list[T] | equal_sl[T](l, ll) & card_sl(ll) = length(ll)}" set_as_list nil) (emptyset const-decl "set" sets nil) (finite_emptyset name-judgement "finite_set[T]" set_as_list nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil)) shostak)))
